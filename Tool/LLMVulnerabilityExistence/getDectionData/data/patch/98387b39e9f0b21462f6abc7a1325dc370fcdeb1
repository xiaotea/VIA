{
    "src/twisted/conch/ssh/transport.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 728,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 729,
                "afterPatchRowNumber": 729,
                "PatchRowcode": "         self.buf = self.buf + data"
            },
            "2": {
                "beforePatchRowNumber": 730,
                "afterPatchRowNumber": 730,
                "PatchRowcode": "         if not self.gotVersion:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 731,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 732,
                "PatchRowcode": "+            if len(self.buf) > 4096:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 733,
                "PatchRowcode": "+                self.sendDisconnect("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 734,
                "PatchRowcode": "+                    DISCONNECT_CONNECTION_LOST,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 735,
                "PatchRowcode": "+                    b\"Peer version string longer than 4KB. \""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 736,
                "PatchRowcode": "+                    b\"Preventing a denial of service attack.\","
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 737,
                "PatchRowcode": "+                )"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 738,
                "PatchRowcode": "+                return"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 739,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 731,
                "afterPatchRowNumber": 740,
                "PatchRowcode": "             if self.buf.find(b\"\\n\", self.buf.find(b\"SSH-\")) == -1:"
            },
            "13": {
                "beforePatchRowNumber": 732,
                "afterPatchRowNumber": 741,
                "PatchRowcode": "                 return"
            },
            "14": {
                "beforePatchRowNumber": 733,
                "afterPatchRowNumber": 742,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- test-case-name: twisted.conch.test.test_transport -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "The lowest level SSH protocol.  This handles the key negotiation, the",
            "encryption and the compression.  The transport layer is described in",
            "RFC 4253.",
            "",
            "Maintainer: Paul Swartz",
            "\"\"\"",
            "",
            "",
            "import binascii",
            "import hmac",
            "import struct",
            "import zlib",
            "from hashlib import md5, sha1, sha256, sha384, sha512",
            "from typing import Dict",
            "",
            "from cryptography.exceptions import UnsupportedAlgorithm",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives import serialization",
            "from cryptography.hazmat.primitives.asymmetric import dh, ec, x25519",
            "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes",
            "",
            "from twisted import __version__ as twisted_version",
            "from twisted.conch.ssh import _kex, address, keys",
            "from twisted.conch.ssh.common import MP, NS, ffs, getMP, getNS",
            "from twisted.internet import defer, protocol",
            "from twisted.logger import Logger",
            "from twisted.python import randbytes",
            "from twisted.python.compat import iterbytes, networkString",
            "",
            "# This import is needed if SHA256 hashing is used.",
            "# from twisted.python.compat import nativeString",
            "",
            "",
            "def _mpFromBytes(data):",
            "    \"\"\"Make an SSH multiple-precision integer from big-endian L{bytes}.",
            "",
            "    Used in ECDH key exchange.",
            "",
            "    @type data: L{bytes}",
            "    @param data: The input data, interpreted as a big-endian octet string.",
            "",
            "    @rtype: L{bytes}",
            "    @return: The given data encoded as an SSH multiple-precision integer.",
            "    \"\"\"",
            "    return MP(int.from_bytes(data, \"big\"))",
            "",
            "",
            "class _MACParams(tuple):",
            "    \"\"\"",
            "    L{_MACParams} represents the parameters necessary to compute SSH MAC",
            "    (Message Authenticate Codes).",
            "",
            "    L{_MACParams} is a L{tuple} subclass to maintain compatibility with older",
            "    versions of the code.  The elements of a L{_MACParams} are::",
            "",
            "        0. The digest object used for the MAC",
            "        1. The inner pad (\"ipad\") string",
            "        2. The outer pad (\"opad\") string",
            "        3. The size of the digest produced by the digest object",
            "",
            "    L{_MACParams} is also an object lesson in why tuples are a bad type for",
            "    public APIs.",
            "",
            "    @ivar key: The HMAC key which will be used.",
            "    \"\"\"",
            "",
            "",
            "class SSHCiphers:",
            "    \"\"\"",
            "    SSHCiphers represents all the encryption operations that need to occur",
            "    to encrypt and authenticate the SSH connection.",
            "",
            "    @cvar cipherMap: A dictionary mapping SSH encryption names to 3-tuples of",
            "        (<cryptography.hazmat.primitives.interfaces.CipherAlgorithm>,",
            "        <block size>, <cryptography.hazmat.primitives.interfaces.Mode>)",
            "    @cvar macMap: A dictionary mapping SSH MAC names to hash modules.",
            "",
            "    @ivar outCipType: the string type of the outgoing cipher.",
            "    @ivar inCipType: the string type of the incoming cipher.",
            "    @ivar outMACType: the string type of the incoming MAC.",
            "    @ivar inMACType: the string type of the incoming MAC.",
            "    @ivar encBlockSize: the block size of the outgoing cipher.",
            "    @ivar decBlockSize: the block size of the incoming cipher.",
            "    @ivar verifyDigestSize: the size of the incoming MAC.",
            "    @ivar outMAC: a tuple of (<hash module>, <inner key>, <outer key>,",
            "        <digest size>) representing the outgoing MAC.",
            "    @ivar inMAc: see outMAC, but for the incoming MAC.",
            "    \"\"\"",
            "",
            "    cipherMap = {",
            "        b\"3des-cbc\": (algorithms.TripleDES, 24, modes.CBC),",
            "        b\"blowfish-cbc\": (algorithms.Blowfish, 16, modes.CBC),",
            "        b\"aes256-cbc\": (algorithms.AES, 32, modes.CBC),",
            "        b\"aes192-cbc\": (algorithms.AES, 24, modes.CBC),",
            "        b\"aes128-cbc\": (algorithms.AES, 16, modes.CBC),",
            "        b\"cast128-cbc\": (algorithms.CAST5, 16, modes.CBC),",
            "        b\"aes128-ctr\": (algorithms.AES, 16, modes.CTR),",
            "        b\"aes192-ctr\": (algorithms.AES, 24, modes.CTR),",
            "        b\"aes256-ctr\": (algorithms.AES, 32, modes.CTR),",
            "        b\"3des-ctr\": (algorithms.TripleDES, 24, modes.CTR),",
            "        b\"blowfish-ctr\": (algorithms.Blowfish, 16, modes.CTR),",
            "        b\"cast128-ctr\": (algorithms.CAST5, 16, modes.CTR),",
            "        b\"none\": (None, 0, modes.CBC),",
            "    }",
            "    macMap = {",
            "        b\"hmac-sha2-512\": sha512,",
            "        b\"hmac-sha2-384\": sha384,",
            "        b\"hmac-sha2-256\": sha256,",
            "        b\"hmac-sha1\": sha1,",
            "        b\"hmac-md5\": md5,",
            "        b\"none\": None,",
            "    }",
            "",
            "    def __init__(self, outCip, inCip, outMac, inMac):",
            "        self.outCipType = outCip",
            "        self.inCipType = inCip",
            "        self.outMACType = outMac",
            "        self.inMACType = inMac",
            "        self.encBlockSize = 0",
            "        self.decBlockSize = 0",
            "        self.verifyDigestSize = 0",
            "        self.outMAC = (None, b\"\", b\"\", 0)",
            "        self.inMAC = (None, b\"\", b\"\", 0)",
            "",
            "    def setKeys(self, outIV, outKey, inIV, inKey, outInteg, inInteg):",
            "        \"\"\"",
            "        Set up the ciphers and hashes using the given keys,",
            "",
            "        @param outIV: the outgoing initialization vector",
            "        @param outKey: the outgoing encryption key",
            "        @param inIV: the incoming initialization vector",
            "        @param inKey: the incoming encryption key",
            "        @param outInteg: the outgoing integrity key",
            "        @param inInteg: the incoming integrity key.",
            "        \"\"\"",
            "        o = self._getCipher(self.outCipType, outIV, outKey)",
            "        self.encryptor = o.encryptor()",
            "        self.encBlockSize = o.algorithm.block_size // 8",
            "        o = self._getCipher(self.inCipType, inIV, inKey)",
            "        self.decryptor = o.decryptor()",
            "        self.decBlockSize = o.algorithm.block_size // 8",
            "        self.outMAC = self._getMAC(self.outMACType, outInteg)",
            "        self.inMAC = self._getMAC(self.inMACType, inInteg)",
            "        if self.inMAC:",
            "            self.verifyDigestSize = self.inMAC[3]",
            "",
            "    def _getCipher(self, cip, iv, key):",
            "        \"\"\"",
            "        Creates an initialized cipher object.",
            "",
            "        @param cip: the name of the cipher, maps into cipherMap",
            "        @param iv: the initialzation vector",
            "        @param key: the encryption key",
            "",
            "        @return: the cipher object.",
            "        \"\"\"",
            "        algorithmClass, keySize, modeClass = self.cipherMap[cip]",
            "        if algorithmClass is None:",
            "            return _DummyCipher()",
            "",
            "        return Cipher(",
            "            algorithmClass(key[:keySize]),",
            "            modeClass(iv[: algorithmClass.block_size // 8]),",
            "            backend=default_backend(),",
            "        )",
            "",
            "    def _getMAC(self, mac, key):",
            "        \"\"\"",
            "        Gets a 4-tuple representing the message authentication code.",
            "        (<hash module>, <inner hash value>, <outer hash value>,",
            "        <digest size>)",
            "",
            "        @type mac: L{bytes}",
            "        @param mac: a key mapping into macMap",
            "",
            "        @type key: L{bytes}",
            "        @param key: the MAC key.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The MAC components.",
            "        \"\"\"",
            "        mod = self.macMap[mac]",
            "        if not mod:",
            "            return (None, b\"\", b\"\", 0)",
            "",
            "        # With stdlib we can only get attributes fron an instantiated object.",
            "        hashObject = mod()",
            "        digestSize = hashObject.digest_size",
            "        blockSize = hashObject.block_size",
            "",
            "        # Truncation here appears to contravene RFC 2104, section 2.  However,",
            "        # implementing the hashing behavior prescribed by the RFC breaks",
            "        # interoperability with OpenSSH (at least version 5.5p1).",
            "        key = key[:digestSize] + (b\"\\x00\" * (blockSize - digestSize))",
            "        i = key.translate(hmac.trans_36)",
            "        o = key.translate(hmac.trans_5C)",
            "        result = _MACParams((mod, i, o, digestSize))",
            "        result.key = key",
            "        return result",
            "",
            "    def encrypt(self, blocks):",
            "        \"\"\"",
            "        Encrypt some data.",
            "",
            "        @type blocks: L{bytes}",
            "        @param blocks: The data to encrypt.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The encrypted data.",
            "        \"\"\"",
            "        return self.encryptor.update(blocks)",
            "",
            "    def decrypt(self, blocks):",
            "        \"\"\"",
            "        Decrypt some data.",
            "",
            "        @type blocks: L{bytes}",
            "        @param blocks: The data to decrypt.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The decrypted data.",
            "        \"\"\"",
            "        return self.decryptor.update(blocks)",
            "",
            "    def makeMAC(self, seqid, data):",
            "        \"\"\"",
            "        Create a message authentication code (MAC) for the given packet using",
            "        the outgoing MAC values.",
            "",
            "        @type seqid: L{int}",
            "        @param seqid: The sequence ID of the outgoing packet.",
            "",
            "        @type data: L{bytes}",
            "        @param data: The data to create a MAC for.",
            "",
            "        @rtype: L{str}",
            "        @return: The serialized MAC.",
            "        \"\"\"",
            "        if not self.outMAC[0]:",
            "            return b\"\"",
            "        data = struct.pack(\">L\", seqid) + data",
            "        return hmac.HMAC(self.outMAC.key, data, self.outMAC[0]).digest()",
            "",
            "    def verify(self, seqid, data, mac):",
            "        \"\"\"",
            "        Verify an incoming MAC using the incoming MAC values.",
            "",
            "        @type seqid: L{int}",
            "        @param seqid: The sequence ID of the incoming packet.",
            "",
            "        @type data: L{bytes}",
            "        @param data: The packet data to verify.",
            "",
            "        @type mac: L{bytes}",
            "        @param mac: The MAC sent with the packet.",
            "",
            "        @rtype: L{bool}",
            "        @return: C{True} if the MAC is valid.",
            "        \"\"\"",
            "        if not self.inMAC[0]:",
            "            return mac == b\"\"",
            "        data = struct.pack(\">L\", seqid) + data",
            "        outer = hmac.HMAC(self.inMAC.key, data, self.inMAC[0]).digest()",
            "        return hmac.compare_digest(mac, outer)",
            "",
            "",
            "def _getSupportedCiphers():",
            "    \"\"\"",
            "    Build a list of ciphers that are supported by the backend in use.",
            "",
            "    @return: a list of supported ciphers.",
            "    @rtype: L{list} of L{str}",
            "    \"\"\"",
            "    supportedCiphers = []",
            "    cs = [",
            "        b\"aes256-ctr\",",
            "        b\"aes256-cbc\",",
            "        b\"aes192-ctr\",",
            "        b\"aes192-cbc\",",
            "        b\"aes128-ctr\",",
            "        b\"aes128-cbc\",",
            "        b\"cast128-ctr\",",
            "        b\"cast128-cbc\",",
            "        b\"blowfish-ctr\",",
            "        b\"blowfish-cbc\",",
            "        b\"3des-ctr\",",
            "        b\"3des-cbc\",",
            "    ]",
            "    for cipher in cs:",
            "        algorithmClass, keySize, modeClass = SSHCiphers.cipherMap[cipher]",
            "        try:",
            "            Cipher(",
            "                algorithmClass(b\" \" * keySize),",
            "                modeClass(b\" \" * (algorithmClass.block_size // 8)),",
            "                backend=default_backend(),",
            "            ).encryptor()",
            "        except UnsupportedAlgorithm:",
            "            pass",
            "        else:",
            "            supportedCiphers.append(cipher)",
            "    return supportedCiphers",
            "",
            "",
            "class SSHTransportBase(protocol.Protocol):",
            "    \"\"\"",
            "    Protocol supporting basic SSH functionality: sending/receiving packets",
            "    and message dispatch.  To connect to or run a server, you must use",
            "    SSHClientTransport or SSHServerTransport.",
            "",
            "    @ivar protocolVersion: A string representing the version of the SSH",
            "        protocol we support.  Currently defaults to '2.0'.",
            "",
            "    @ivar version: A string representing the version of the server or client.",
            "        Currently defaults to 'Twisted'.",
            "",
            "    @ivar comment: An optional string giving more information about the",
            "        server or client.",
            "",
            "    @ivar supportedCiphers: A list of strings representing the encryption",
            "        algorithms supported, in order from most-preferred to least.",
            "",
            "    @ivar supportedMACs: A list of strings representing the message",
            "        authentication codes (hashes) supported, in order from most-preferred",
            "        to least.  Both this and supportedCiphers can include 'none' to use",
            "        no encryption or authentication, but that must be done manually,",
            "",
            "    @ivar supportedKeyExchanges: A list of strings representing the",
            "        key exchanges supported, in order from most-preferred to least.",
            "",
            "    @ivar supportedPublicKeys:  A list of strings representing the",
            "        public key types supported, in order from most-preferred to least.",
            "",
            "    @ivar supportedCompressions: A list of strings representing compression",
            "        types supported, from most-preferred to least.",
            "",
            "    @ivar supportedLanguages: A list of strings representing languages",
            "        supported, from most-preferred to least.",
            "",
            "    @ivar supportedVersions: A container of strings representing supported ssh",
            "        protocol version numbers.",
            "",
            "    @ivar isClient: A boolean indicating whether this is a client or server.",
            "",
            "    @ivar gotVersion: A boolean indicating whether we have received the",
            "        version string from the other side.",
            "",
            "    @ivar buf: Data we've received but hasn't been parsed into a packet.",
            "",
            "    @ivar outgoingPacketSequence: the sequence number of the next packet we",
            "        will send.",
            "",
            "    @ivar incomingPacketSequence: the sequence number of the next packet we",
            "        are expecting from the other side.",
            "",
            "    @ivar outgoingCompression: an object supporting the .compress(str) and",
            "        .flush() methods, or None if there is no outgoing compression.  Used to",
            "        compress outgoing data.",
            "",
            "    @ivar outgoingCompressionType: A string representing the outgoing",
            "        compression type.",
            "",
            "    @ivar incomingCompression: an object supporting the .decompress(str)",
            "        method, or None if there is no incoming compression.  Used to",
            "        decompress incoming data.",
            "",
            "    @ivar incomingCompressionType: A string representing the incoming",
            "        compression type.",
            "",
            "    @ivar ourVersionString: the version string that we sent to the other side.",
            "        Used in the key exchange.",
            "",
            "    @ivar otherVersionString: the version string sent by the other side.  Used",
            "        in the key exchange.",
            "",
            "    @ivar ourKexInitPayload: the MSG_KEXINIT payload we sent.  Used in the key",
            "        exchange.",
            "",
            "    @ivar otherKexInitPayload: the MSG_KEXINIT payload we received.  Used in",
            "        the key exchange",
            "",
            "    @ivar sessionID: a string that is unique to this SSH session.  Created as",
            "        part of the key exchange, sessionID is used to generate the various",
            "        encryption and authentication keys.",
            "",
            "    @ivar service: an SSHService instance, or None.  If it's set to an object,",
            "        it's the currently running service.",
            "",
            "    @ivar kexAlg: the agreed-upon key exchange algorithm.",
            "",
            "    @ivar keyAlg: the agreed-upon public key type for the key exchange.",
            "",
            "    @ivar currentEncryptions: an SSHCiphers instance.  It represents the",
            "        current encryption and authentication options for the transport.",
            "",
            "    @ivar nextEncryptions: an SSHCiphers instance.  Held here until the",
            "        MSG_NEWKEYS messages are exchanged, when nextEncryptions is",
            "        transitioned to currentEncryptions.",
            "",
            "    @ivar first: the first bytes of the next packet.  In order to avoid",
            "        decrypting data twice, the first bytes are decrypted and stored until",
            "        the whole packet is available.",
            "",
            "    @ivar _keyExchangeState: The current protocol state with respect to key",
            "        exchange.  This is either C{_KEY_EXCHANGE_NONE} if no key exchange is",
            "        in progress (and returns to this value after any key exchange",
            "        completqes), C{_KEY_EXCHANGE_REQUESTED} if this side of the connection",
            "        initiated a key exchange, and C{_KEY_EXCHANGE_PROGRESSING} if the other",
            "        side of the connection initiated a key exchange.  C{_KEY_EXCHANGE_NONE}",
            "        is the initial value (however SSH connections begin with key exchange,",
            "        so it will quickly change to another state).",
            "",
            "    @ivar _blockedByKeyExchange: Whenever C{_keyExchangeState} is not",
            "        C{_KEY_EXCHANGE_NONE}, this is a C{list} of pending messages which were",
            "        passed to L{sendPacket} but could not be sent because it is not legal",
            "        to send them while a key exchange is in progress.  When the key",
            "        exchange completes, another attempt is made to send these messages.",
            "",
            "    @ivar _peerSupportsExtensions: a boolean indicating whether the other side",
            "        of the connection supports RFC 8308 extension negotiation.",
            "",
            "    @ivar peerExtensions: a dict of extensions supported by the other side of",
            "        the connection.",
            "    \"\"\"",
            "",
            "    _log = Logger()",
            "",
            "    protocolVersion = b\"2.0\"",
            "    version = b\"Twisted_\" + twisted_version.encode(\"ascii\")",
            "    comment = b\"\"",
            "    ourVersionString = (",
            "        b\"SSH-\" + protocolVersion + b\"-\" + version + b\" \" + comment",
            "    ).strip()",
            "",
            "    # L{None} is supported as cipher and hmac. For security they are disabled",
            "    # by default. To enable them, subclass this class and add it, or do:",
            "    # SSHTransportBase.supportedCiphers.append('none')",
            "    # List ordered by preference.",
            "    supportedCiphers = _getSupportedCiphers()",
            "    supportedMACs = [",
            "        b\"hmac-sha2-512\",",
            "        b\"hmac-sha2-384\",",
            "        b\"hmac-sha2-256\",",
            "        b\"hmac-sha1\",",
            "        b\"hmac-md5\",",
            "        # `none`,",
            "    ]",
            "",
            "    supportedKeyExchanges = _kex.getSupportedKeyExchanges()",
            "    supportedPublicKeys = []",
            "",
            "    # Add the supported EC keys, and change the name from ecdh* to ecdsa*",
            "    for eckey in supportedKeyExchanges:",
            "        if eckey.find(b\"ecdh\") != -1:",
            "            supportedPublicKeys += [eckey.replace(b\"ecdh\", b\"ecdsa\")]",
            "",
            "    supportedPublicKeys += [b\"ssh-rsa\", b\"ssh-dss\"]",
            "    if default_backend().ed25519_supported():",
            "        supportedPublicKeys.append(b\"ssh-ed25519\")",
            "",
            "    supportedCompressions = [b\"none\", b\"zlib\"]",
            "    supportedLanguages = ()",
            "    supportedVersions = (b\"1.99\", b\"2.0\")",
            "    isClient = False",
            "    gotVersion = False",
            "    buf = b\"\"",
            "    outgoingPacketSequence = 0",
            "    incomingPacketSequence = 0",
            "    outgoingCompression = None",
            "    incomingCompression = None",
            "    sessionID = None",
            "    service = None",
            "",
            "    # There is no key exchange activity in progress.",
            "    _KEY_EXCHANGE_NONE = \"_KEY_EXCHANGE_NONE\"",
            "",
            "    # Key exchange is in progress and we started it.",
            "    _KEY_EXCHANGE_REQUESTED = \"_KEY_EXCHANGE_REQUESTED\"",
            "",
            "    # Key exchange is in progress and both sides have sent KEXINIT messages.",
            "    _KEY_EXCHANGE_PROGRESSING = \"_KEY_EXCHANGE_PROGRESSING\"",
            "",
            "    # There is a fourth conceptual state not represented here: KEXINIT received",
            "    # but not sent.  Since we always send a KEXINIT as soon as we get it, we",
            "    # can't ever be in that state.",
            "",
            "    # The current key exchange state.",
            "    _keyExchangeState = _KEY_EXCHANGE_NONE",
            "    _blockedByKeyExchange = None",
            "",
            "    # Added to key exchange algorithms by a client to indicate support for",
            "    # extension negotiation.",
            "    _EXT_INFO_C = b\"ext-info-c\"",
            "",
            "    # Added to key exchange algorithms by a server to indicate support for",
            "    # extension negotiation.",
            "    _EXT_INFO_S = b\"ext-info-s\"",
            "",
            "    _peerSupportsExtensions = False",
            "    peerExtensions: Dict[bytes, bytes] = {}",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        When the underlying connection is closed, stop the running service (if",
            "        any), and log out the avatar (if any).",
            "",
            "        @type reason: L{twisted.python.failure.Failure}",
            "        @param reason: The cause of the connection being closed.",
            "        \"\"\"",
            "        if self.service:",
            "            self.service.serviceStopped()",
            "        if hasattr(self, \"avatar\"):",
            "            self.logoutFunction()",
            "        self._log.info(\"connection lost\")",
            "",
            "    def connectionMade(self):",
            "        \"\"\"",
            "        Called when the connection is made to the other side.  We sent our",
            "        version and the MSG_KEXINIT packet.",
            "        \"\"\"",
            "        self.transport.write(self.ourVersionString + b\"\\r\\n\")",
            "        self.currentEncryptions = SSHCiphers(b\"none\", b\"none\", b\"none\", b\"none\")",
            "        self.currentEncryptions.setKeys(b\"\", b\"\", b\"\", b\"\", b\"\", b\"\")",
            "        self.sendKexInit()",
            "",
            "    def sendKexInit(self):",
            "        \"\"\"",
            "        Send a I{KEXINIT} message to initiate key exchange or to respond to a",
            "        key exchange initiated by the peer.",
            "",
            "        @raise RuntimeError: If a key exchange has already been started and it",
            "            is not appropriate to send a I{KEXINIT} message at this time.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        if self._keyExchangeState != self._KEY_EXCHANGE_NONE:",
            "            raise RuntimeError(",
            "                \"Cannot send KEXINIT while key exchange state is %r\"",
            "                % (self._keyExchangeState,)",
            "            )",
            "",
            "        supportedKeyExchanges = list(self.supportedKeyExchanges)",
            "        # Advertise extension negotiation (RFC 8308, section 2.1).  At",
            "        # present, the Conch client processes the \"server-sig-algs\"",
            "        # extension (section 3.1), and the Conch server sends that but",
            "        # ignores any extensions sent by the client, so strictly speaking at",
            "        # the moment we only need to send this in the client case; however,",
            "        # there's nothing to forbid the server from sending it as well, and",
            "        # doing so makes things easier if it needs to process extensions",
            "        # sent by clients in future.",
            "        supportedKeyExchanges.append(",
            "            self._EXT_INFO_C if self.isClient else self._EXT_INFO_S",
            "        )",
            "",
            "        self.ourKexInitPayload = b\"\".join(",
            "            [",
            "                bytes((MSG_KEXINIT,)),",
            "                randbytes.secureRandom(16),",
            "                NS(b\",\".join(supportedKeyExchanges)),",
            "                NS(b\",\".join(self.supportedPublicKeys)),",
            "                NS(b\",\".join(self.supportedCiphers)),",
            "                NS(b\",\".join(self.supportedCiphers)),",
            "                NS(b\",\".join(self.supportedMACs)),",
            "                NS(b\",\".join(self.supportedMACs)),",
            "                NS(b\",\".join(self.supportedCompressions)),",
            "                NS(b\",\".join(self.supportedCompressions)),",
            "                NS(b\",\".join(self.supportedLanguages)),",
            "                NS(b\",\".join(self.supportedLanguages)),",
            "                b\"\\000\\000\\000\\000\\000\",",
            "            ]",
            "        )",
            "        self.sendPacket(MSG_KEXINIT, self.ourKexInitPayload[1:])",
            "        self._keyExchangeState = self._KEY_EXCHANGE_REQUESTED",
            "        self._blockedByKeyExchange = []",
            "",
            "    def _allowedKeyExchangeMessageType(self, messageType):",
            "        \"\"\"",
            "        Determine if the given message type may be sent while key exchange is",
            "        in progress.",
            "",
            "        @param messageType: The type of message",
            "        @type messageType: L{int}",
            "",
            "        @return: C{True} if the given type of message may be sent while key",
            "            exchange is in progress, C{False} if it may not.",
            "        @rtype: L{bool}",
            "",
            "        @see: U{http://tools.ietf.org/html/rfc4253#section-7.1}",
            "        \"\"\"",
            "        # Written somewhat peculularly to reflect the way the specification",
            "        # defines the allowed message types.",
            "        if 1 <= messageType <= 19:",
            "            return messageType not in (",
            "                MSG_SERVICE_REQUEST,",
            "                MSG_SERVICE_ACCEPT,",
            "                MSG_EXT_INFO,",
            "            )",
            "        if 20 <= messageType <= 29:",
            "            return messageType not in (MSG_KEXINIT,)",
            "        return 30 <= messageType <= 49",
            "",
            "    def sendPacket(self, messageType, payload):",
            "        \"\"\"",
            "        Sends a packet.  If it's been set up, compress the data, encrypt it,",
            "        and authenticate it before sending.  If key exchange is in progress and",
            "        the message is not part of key exchange, queue it to be sent later.",
            "",
            "        @param messageType: The type of the packet; generally one of the",
            "                            MSG_* values.",
            "        @type messageType: L{int}",
            "        @param payload: The payload for the message.",
            "        @type payload: L{str}",
            "        \"\"\"",
            "        if self._keyExchangeState != self._KEY_EXCHANGE_NONE:",
            "            if not self._allowedKeyExchangeMessageType(messageType):",
            "                self._blockedByKeyExchange.append((messageType, payload))",
            "                return",
            "",
            "        payload = bytes((messageType,)) + payload",
            "        if self.outgoingCompression:",
            "            payload = self.outgoingCompression.compress(",
            "                payload",
            "            ) + self.outgoingCompression.flush(2)",
            "        bs = self.currentEncryptions.encBlockSize",
            "        # 4 for the packet length and 1 for the padding length",
            "        totalSize = 5 + len(payload)",
            "        lenPad = bs - (totalSize % bs)",
            "        if lenPad < 4:",
            "            lenPad = lenPad + bs",
            "        packet = (",
            "            struct.pack(\"!LB\", totalSize + lenPad - 4, lenPad)",
            "            + payload",
            "            + randbytes.secureRandom(lenPad)",
            "        )",
            "        encPacket = self.currentEncryptions.encrypt(",
            "            packet",
            "        ) + self.currentEncryptions.makeMAC(self.outgoingPacketSequence, packet)",
            "        self.transport.write(encPacket)",
            "        self.outgoingPacketSequence += 1",
            "",
            "    def getPacket(self):",
            "        \"\"\"",
            "        Try to return a decrypted, authenticated, and decompressed packet",
            "        out of the buffer.  If there is not enough data, return None.",
            "",
            "        @rtype: L{str} or L{None}",
            "        @return: The decoded packet, if any.",
            "        \"\"\"",
            "        bs = self.currentEncryptions.decBlockSize",
            "        ms = self.currentEncryptions.verifyDigestSize",
            "        if len(self.buf) < bs:",
            "            # Not enough data for a block",
            "            return",
            "        if not hasattr(self, \"first\"):",
            "            first = self.currentEncryptions.decrypt(self.buf[:bs])",
            "        else:",
            "            first = self.first",
            "            del self.first",
            "        packetLen, paddingLen = struct.unpack(\"!LB\", first[:5])",
            "        if packetLen > 1048576:  # 1024 ** 2",
            "            self.sendDisconnect(",
            "                DISCONNECT_PROTOCOL_ERROR,",
            "                networkString(f\"bad packet length {packetLen}\"),",
            "            )",
            "            return",
            "        if len(self.buf) < packetLen + 4 + ms:",
            "            # Not enough data for a packet",
            "            self.first = first",
            "            return",
            "        if (packetLen + 4) % bs != 0:",
            "            self.sendDisconnect(",
            "                DISCONNECT_PROTOCOL_ERROR,",
            "                networkString(",
            "                    \"bad packet mod (%i%%%i == %i)\"",
            "                    % (packetLen + 4, bs, (packetLen + 4) % bs)",
            "                ),",
            "            )",
            "            return",
            "        encData, self.buf = self.buf[: 4 + packetLen], self.buf[4 + packetLen :]",
            "        packet = first + self.currentEncryptions.decrypt(encData[bs:])",
            "        if len(packet) != 4 + packetLen:",
            "            self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR, b\"bad decryption\")",
            "            return",
            "        if ms:",
            "            macData, self.buf = self.buf[:ms], self.buf[ms:]",
            "            if not self.currentEncryptions.verify(",
            "                self.incomingPacketSequence, packet, macData",
            "            ):",
            "                self.sendDisconnect(DISCONNECT_MAC_ERROR, b\"bad MAC\")",
            "                return",
            "        payload = packet[5:-paddingLen]",
            "        if self.incomingCompression:",
            "            try:",
            "                payload = self.incomingCompression.decompress(payload)",
            "            except Exception:",
            "                # Tolerate any errors in decompression",
            "                self._log.failure(\"Error decompressing payload\")",
            "                self.sendDisconnect(DISCONNECT_COMPRESSION_ERROR, b\"compression error\")",
            "                return",
            "        self.incomingPacketSequence += 1",
            "        return payload",
            "",
            "    def _unsupportedVersionReceived(self, remoteVersion):",
            "        \"\"\"",
            "        Called when an unsupported version of the ssh protocol is received from",
            "        the remote endpoint.",
            "",
            "        @param remoteVersion: remote ssh protocol version which is unsupported",
            "            by us.",
            "        @type remoteVersion: L{str}",
            "        \"\"\"",
            "        self.sendDisconnect(",
            "            DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED, b\"bad version \" + remoteVersion",
            "        )",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        First, check for the version string (SSH-2.0-*).  After that has been",
            "        received, this method adds data to the buffer, and pulls out any",
            "        packets.",
            "",
            "        @type data: L{bytes}",
            "        @param data: The data that was received.",
            "        \"\"\"",
            "        self.buf = self.buf + data",
            "        if not self.gotVersion:",
            "            if self.buf.find(b\"\\n\", self.buf.find(b\"SSH-\")) == -1:",
            "                return",
            "",
            "            # RFC 4253 section 4.2 ask for strict `\\r\\n` line ending.",
            "            # Here we are a bit more relaxed and accept implementations ending",
            "            # only in '\\n'.",
            "            # https://tools.ietf.org/html/rfc4253#section-4.2",
            "            lines = self.buf.split(b\"\\n\")",
            "            for p in lines:",
            "                if p.startswith(b\"SSH-\"):",
            "                    self.gotVersion = True",
            "                    # Since the line was split on '\\n' and most of the time",
            "                    # it uses '\\r\\n' we may get an extra '\\r'.",
            "                    self.otherVersionString = p.rstrip(b\"\\r\")",
            "                    remoteVersion = p.split(b\"-\")[1]",
            "                    if remoteVersion not in self.supportedVersions:",
            "                        self._unsupportedVersionReceived(remoteVersion)",
            "                        return",
            "                    i = lines.index(p)",
            "                    self.buf = b\"\\n\".join(lines[i + 1 :])",
            "        packet = self.getPacket()",
            "        while packet:",
            "            messageNum = ord(packet[0:1])",
            "            self.dispatchMessage(messageNum, packet[1:])",
            "            packet = self.getPacket()",
            "",
            "    def dispatchMessage(self, messageNum, payload):",
            "        \"\"\"",
            "        Send a received message to the appropriate method.",
            "",
            "        @type messageNum: L{int}",
            "        @param messageNum: The message number.",
            "",
            "        @type payload: L{bytes}",
            "        @param payload: The message payload.",
            "        \"\"\"",
            "        if messageNum < 50 and messageNum in messages:",
            "            messageType = messages[messageNum][4:]",
            "            f = getattr(self, f\"ssh_{messageType}\", None)",
            "            if f is not None:",
            "                f(payload)",
            "            else:",
            "                self._log.debug(",
            "                    \"couldn't handle {messageType}: {payload!r}\",",
            "                    messageType=messageType,",
            "                    payload=payload,",
            "                )",
            "                self.sendUnimplemented()",
            "        elif self.service:",
            "            self.service.packetReceived(messageNum, payload)",
            "        else:",
            "            self._log.debug(",
            "                \"couldn't handle {messageNum}: {payload!r}\",",
            "                messageNum=messageNum,",
            "                payload=payload,",
            "            )",
            "            self.sendUnimplemented()",
            "",
            "    def getPeer(self):",
            "        \"\"\"",
            "        Returns an L{SSHTransportAddress} corresponding to the other (peer)",
            "        side of this transport.",
            "",
            "        @return: L{SSHTransportAddress} for the peer",
            "        @rtype: L{SSHTransportAddress}",
            "        @since: 12.1",
            "        \"\"\"",
            "        return address.SSHTransportAddress(self.transport.getPeer())",
            "",
            "    def getHost(self):",
            "        \"\"\"",
            "        Returns an L{SSHTransportAddress} corresponding to the this side of",
            "        transport.",
            "",
            "        @return: L{SSHTransportAddress} for the peer",
            "        @rtype: L{SSHTransportAddress}",
            "        @since: 12.1",
            "        \"\"\"",
            "        return address.SSHTransportAddress(self.transport.getHost())",
            "",
            "    @property",
            "    def kexAlg(self):",
            "        \"\"\"",
            "        The key exchange algorithm name agreed between client and server.",
            "        \"\"\"",
            "        return self._kexAlg",
            "",
            "    @kexAlg.setter",
            "    def kexAlg(self, value):",
            "        \"\"\"",
            "        Set the key exchange algorithm name.",
            "        \"\"\"",
            "        self._kexAlg = value",
            "",
            "    # Client-initiated rekeying looks like this:",
            "    #",
            "    #  C> MSG_KEXINIT",
            "    #  S> MSG_KEXINIT",
            "    #  C> MSG_KEX_DH_GEX_REQUEST  or   MSG_KEXDH_INIT",
            "    #  S> MSG_KEX_DH_GEX_GROUP    or   MSG_KEXDH_REPLY",
            "    #  C> MSG_KEX_DH_GEX_INIT     or   --",
            "    #  S> MSG_KEX_DH_GEX_REPLY    or   --",
            "    #  C> MSG_NEWKEYS",
            "    #  S> MSG_NEWKEYS",
            "    #",
            "    # Server-initiated rekeying is the same, only the first two messages are",
            "    # switched.",
            "",
            "    def ssh_KEXINIT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEXINIT message.  Payload::",
            "            bytes[16] cookie",
            "            string keyExchangeAlgorithms",
            "            string keyAlgorithms",
            "            string incomingEncryptions",
            "            string outgoingEncryptions",
            "            string incomingAuthentications",
            "            string outgoingAuthentications",
            "            string incomingCompressions",
            "            string outgoingCompressions",
            "            string incomingLanguages",
            "            string outgoingLanguages",
            "            bool firstPacketFollows",
            "            unit32 0 (reserved)",
            "",
            "        Starts setting up the key exchange, keys, encryptions, and",
            "        authentications.  Extended by ssh_KEXINIT in SSHServerTransport and",
            "        SSHClientTransport.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: A L{tuple} of negotiated key exchange algorithms, key",
            "        algorithms, and unhandled data, or L{None} if something went wrong.",
            "        \"\"\"",
            "        self.otherKexInitPayload = bytes((MSG_KEXINIT,)) + packet",
            "        # This is useless to us:",
            "        # cookie = packet[: 16]",
            "        k = getNS(packet[16:], 10)",
            "        strings, rest = k[:-1], k[-1]",
            "        (",
            "            kexAlgs,",
            "            keyAlgs,",
            "            encCS,",
            "            encSC,",
            "            macCS,",
            "            macSC,",
            "            compCS,",
            "            compSC,",
            "            langCS,",
            "            langSC,",
            "        ) = (s.split(b\",\") for s in strings)",
            "        # These are the server directions",
            "        outs = [encSC, macSC, compSC]",
            "        ins = [encCS, macCS, compCS]",
            "        if self.isClient:",
            "            outs, ins = ins, outs  # Switch directions",
            "        server = (",
            "            self.supportedKeyExchanges,",
            "            self.supportedPublicKeys,",
            "            self.supportedCiphers,",
            "            self.supportedCiphers,",
            "            self.supportedMACs,",
            "            self.supportedMACs,",
            "            self.supportedCompressions,",
            "            self.supportedCompressions,",
            "        )",
            "        client = (kexAlgs, keyAlgs, outs[0], ins[0], outs[1], ins[1], outs[2], ins[2])",
            "        if self.isClient:",
            "            server, client = client, server",
            "        self.kexAlg = ffs(client[0], server[0])",
            "        self.keyAlg = ffs(client[1], server[1])",
            "        self.nextEncryptions = SSHCiphers(",
            "            ffs(client[2], server[2]),",
            "            ffs(client[3], server[3]),",
            "            ffs(client[4], server[4]),",
            "            ffs(client[5], server[5]),",
            "        )",
            "        self.outgoingCompressionType = ffs(client[6], server[6])",
            "        self.incomingCompressionType = ffs(client[7], server[7])",
            "        if (",
            "            None",
            "            in (",
            "                self.kexAlg,",
            "                self.keyAlg,",
            "                self.outgoingCompressionType,",
            "                self.incomingCompressionType,",
            "            )",
            "            # We MUST disconnect if an extension negotiation indication ends",
            "            # up being negotiated as a key exchange method (RFC 8308,",
            "            # section 2.2).",
            "            or self.kexAlg in (self._EXT_INFO_C, self._EXT_INFO_S)",
            "        ):",
            "            self.sendDisconnect(",
            "                DISCONNECT_KEY_EXCHANGE_FAILED, b\"couldn't match all kex parts\"",
            "            )",
            "            return",
            "        if None in self.nextEncryptions.__dict__.values():",
            "            self.sendDisconnect(",
            "                DISCONNECT_KEY_EXCHANGE_FAILED, b\"couldn't match all kex parts\"",
            "            )",
            "            return",
            "        self._peerSupportsExtensions = (",
            "            self._EXT_INFO_S if self.isClient else self._EXT_INFO_C",
            "        ) in kexAlgs",
            "        self._log.debug(",
            "            \"kex alg={kexAlg!r} key alg={keyAlg!r}\",",
            "            kexAlg=self.kexAlg,",
            "            keyAlg=self.keyAlg,",
            "        )",
            "        self._log.debug(",
            "            \"outgoing: {cip!r} {mac!r} {compression!r}\",",
            "            cip=self.nextEncryptions.outCipType,",
            "            mac=self.nextEncryptions.outMACType,",
            "            compression=self.outgoingCompressionType,",
            "        )",
            "        self._log.debug(",
            "            \"incoming: {cip!r} {mac!r} {compression!r}\",",
            "            cip=self.nextEncryptions.inCipType,",
            "            mac=self.nextEncryptions.inMACType,",
            "            compression=self.incomingCompressionType,",
            "        )",
            "",
            "        if self._keyExchangeState == self._KEY_EXCHANGE_REQUESTED:",
            "            self._keyExchangeState = self._KEY_EXCHANGE_PROGRESSING",
            "        else:",
            "            self.sendKexInit()",
            "",
            "        return kexAlgs, keyAlgs, rest  # For SSHServerTransport to use",
            "",
            "    def ssh_DISCONNECT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_DISCONNECT message.  Payload::",
            "            long code",
            "            string description",
            "",
            "        This means that the other side has disconnected.  Pass the message up",
            "        and disconnect ourselves.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        reasonCode = struct.unpack(\">L\", packet[:4])[0]",
            "        description, foo = getNS(packet[4:])",
            "        self.receiveError(reasonCode, description)",
            "        self.transport.loseConnection()",
            "",
            "    def ssh_IGNORE(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_IGNORE message.  No payload.",
            "        This means nothing; we simply return.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "",
            "    def ssh_UNIMPLEMENTED(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_UNIMPLEMENTED message.  Payload::",
            "            long packet",
            "",
            "        This means that the other side did not implement one of our packets.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        (seqnum,) = struct.unpack(\">L\", packet)",
            "        self.receiveUnimplemented(seqnum)",
            "",
            "    def ssh_DEBUG(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_DEBUG message.  Payload::",
            "            bool alwaysDisplay",
            "            string message",
            "            string language",
            "",
            "        This means the other side has passed along some debugging info.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        alwaysDisplay = bool(ord(packet[0:1]))",
            "        message, lang, foo = getNS(packet[1:], 2)",
            "        self.receiveDebug(alwaysDisplay, message, lang)",
            "",
            "    def ssh_EXT_INFO(self, packet):",
            "        \"\"\"",
            "        Called when we get a MSG_EXT_INFO message.  Payload::",
            "            uint32 nr-extensions",
            "            repeat the following 2 fields \"nr-extensions\" times:",
            "              string extension-name",
            "              string extension-value (binary)",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        (numExtensions,) = struct.unpack(\">L\", packet[:4])",
            "        packet = packet[4:]",
            "        extensions = {}",
            "        for _ in range(numExtensions):",
            "            extName, extValue, packet = getNS(packet, 2)",
            "            extensions[extName] = extValue",
            "        self.peerExtensions = extensions",
            "",
            "    def setService(self, service):",
            "        \"\"\"",
            "        Set our service to service and start it running.  If we were",
            "        running a service previously, stop it first.",
            "",
            "        @type service: C{SSHService}",
            "        @param service: The service to attach.",
            "        \"\"\"",
            "        self._log.debug(\"starting service {service!r}\", service=service.name)",
            "        if self.service:",
            "            self.service.serviceStopped()",
            "        self.service = service",
            "        service.transport = self",
            "        self.service.serviceStarted()",
            "",
            "    def sendDebug(self, message, alwaysDisplay=False, language=b\"\"):",
            "        \"\"\"",
            "        Send a debug message to the other side.",
            "",
            "        @param message: the message to send.",
            "        @type message: L{str}",
            "        @param alwaysDisplay: if True, tell the other side to always",
            "                              display this message.",
            "        @type alwaysDisplay: L{bool}",
            "        @param language: optionally, the language the message is in.",
            "        @type language: L{str}",
            "        \"\"\"",
            "        self.sendPacket(",
            "            MSG_DEBUG, (b\"\\1\" if alwaysDisplay else b\"\\0\") + NS(message) + NS(language)",
            "        )",
            "",
            "    def sendIgnore(self, message):",
            "        \"\"\"",
            "        Send a message that will be ignored by the other side.  This is",
            "        useful to fool attacks based on guessing packet sizes in the",
            "        encrypted stream.",
            "",
            "        @param message: data to send with the message",
            "        @type message: L{str}",
            "        \"\"\"",
            "        self.sendPacket(MSG_IGNORE, NS(message))",
            "",
            "    def sendUnimplemented(self):",
            "        \"\"\"",
            "        Send a message to the other side that the last packet was not",
            "        understood.",
            "        \"\"\"",
            "        seqnum = self.incomingPacketSequence",
            "        self.sendPacket(MSG_UNIMPLEMENTED, struct.pack(\"!L\", seqnum))",
            "",
            "    def sendDisconnect(self, reason, desc):",
            "        \"\"\"",
            "        Send a disconnect message to the other side and then disconnect.",
            "",
            "        @param reason: the reason for the disconnect.  Should be one of the",
            "                       DISCONNECT_* values.",
            "        @type reason: L{int}",
            "        @param desc: a descrption of the reason for the disconnection.",
            "        @type desc: L{str}",
            "        \"\"\"",
            "        self.sendPacket(MSG_DISCONNECT, struct.pack(\">L\", reason) + NS(desc) + NS(b\"\"))",
            "        self._log.info(",
            "            \"Disconnecting with error, code {code}\\nreason: {description}\",",
            "            code=reason,",
            "            description=desc,",
            "        )",
            "        self.transport.loseConnection()",
            "",
            "    def sendExtInfo(self, extensions):",
            "        \"\"\"",
            "        Send an RFC 8308 extension advertisement to the remote peer.",
            "",
            "        Nothing is sent if the peer doesn't support negotiations.",
            "        @type extensions: L{list} of (L{bytes}, L{bytes})",
            "        @param extensions: a list of (extension-name, extension-value) pairs.",
            "        \"\"\"",
            "        if self._peerSupportsExtensions:",
            "            payload = b\"\".join(",
            "                [struct.pack(\">L\", len(extensions))]",
            "                + [NS(name) + NS(value) for name, value in extensions]",
            "            )",
            "            self.sendPacket(MSG_EXT_INFO, payload)",
            "",
            "    def _startEphemeralDH(self):",
            "        \"\"\"",
            "        Prepares for a Diffie-Hellman key agreement exchange.",
            "",
            "        Creates an ephemeral keypair in the group defined by (self.g,",
            "        self.p) and stores it.",
            "        \"\"\"",
            "",
            "        numbers = dh.DHParameterNumbers(self.p, self.g)",
            "        parameters = numbers.parameters(default_backend())",
            "        self.dhSecretKey = parameters.generate_private_key()",
            "        y = self.dhSecretKey.public_key().public_numbers().y",
            "        self.dhSecretKeyPublicMP = MP(y)",
            "",
            "    def _finishEphemeralDH(self, remoteDHpublicKey):",
            "        \"\"\"",
            "        Completes the Diffie-Hellman key agreement started by",
            "        _startEphemeralDH, and forgets the ephemeral secret key.",
            "",
            "        @type remoteDHpublicKey: L{int}",
            "        @rtype: L{bytes}",
            "        @return: The new shared secret, in SSH C{mpint} format.",
            "",
            "        \"\"\"",
            "",
            "        remoteKey = dh.DHPublicNumbers(",
            "            remoteDHpublicKey, dh.DHParameterNumbers(self.p, self.g)",
            "        ).public_key(default_backend())",
            "        secret = self.dhSecretKey.exchange(remoteKey)",
            "        del self.dhSecretKey",
            "",
            "        # The result of a Diffie-Hellman exchange is an integer, but",
            "        # the Cryptography module returns it as bytes in a form that",
            "        # is only vaguely documented. We fix it up to match the SSH",
            "        # MP-integer format as described in RFC4251.",
            "        secret = secret.lstrip(b\"\\x00\")",
            "        ch = ord(secret[0:1])",
            "        if ch & 0x80:  # High bit set?",
            "            # Make room for the sign bit",
            "            prefix = struct.pack(\">L\", len(secret) + 1) + b\"\\x00\"",
            "        else:",
            "            prefix = struct.pack(\">L\", len(secret))",
            "        return prefix + secret",
            "",
            "    def _getKey(self, c, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        Get one of the keys for authentication/encryption.",
            "",
            "        @type c: L{bytes}",
            "        @param c: The letter identifying which key this is.",
            "",
            "        @type sharedSecret: L{bytes}",
            "        @param sharedSecret: The shared secret K.",
            "",
            "        @type exchangeHash: L{bytes}",
            "        @param exchangeHash: The hash H from key exchange.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The derived key.",
            "        \"\"\"",
            "        hashProcessor = _kex.getHashProcessor(self.kexAlg)",
            "        k1 = hashProcessor(sharedSecret + exchangeHash + c + self.sessionID)",
            "        k1 = k1.digest()",
            "        k2 = hashProcessor(sharedSecret + exchangeHash + k1).digest()",
            "        k3 = hashProcessor(sharedSecret + exchangeHash + k1 + k2).digest()",
            "        k4 = hashProcessor(sharedSecret + exchangeHash + k1 + k2 + k3).digest()",
            "        return k1 + k2 + k3 + k4",
            "",
            "    def _keySetup(self, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        Set up the keys for the connection and sends MSG_NEWKEYS when",
            "        finished,",
            "",
            "        @param sharedSecret: a secret string agreed upon using a Diffie-",
            "                             Hellman exchange, so it is only shared between",
            "                             the server and the client.",
            "        @type sharedSecret: L{str}",
            "        @param exchangeHash: A hash of various data known by both sides.",
            "        @type exchangeHash: L{str}",
            "        \"\"\"",
            "        if not self.sessionID:",
            "            self.sessionID = exchangeHash",
            "        initIVCS = self._getKey(b\"A\", sharedSecret, exchangeHash)",
            "        initIVSC = self._getKey(b\"B\", sharedSecret, exchangeHash)",
            "        encKeyCS = self._getKey(b\"C\", sharedSecret, exchangeHash)",
            "        encKeySC = self._getKey(b\"D\", sharedSecret, exchangeHash)",
            "        integKeyCS = self._getKey(b\"E\", sharedSecret, exchangeHash)",
            "        integKeySC = self._getKey(b\"F\", sharedSecret, exchangeHash)",
            "        outs = [initIVSC, encKeySC, integKeySC]",
            "        ins = [initIVCS, encKeyCS, integKeyCS]",
            "        if self.isClient:  # Reverse for the client",
            "            outs, ins = ins, outs",
            "        self.nextEncryptions.setKeys(outs[0], outs[1], ins[0], ins[1], outs[2], ins[2])",
            "        self.sendPacket(MSG_NEWKEYS, b\"\")",
            "",
            "    def _newKeys(self):",
            "        \"\"\"",
            "        Called back by a subclass once a I{MSG_NEWKEYS} message has been",
            "        received.  This indicates key exchange has completed and new encryption",
            "        and compression parameters should be adopted.  Any messages which were",
            "        queued during key exchange will also be flushed.",
            "        \"\"\"",
            "        self._log.debug(\"NEW KEYS\")",
            "        self.currentEncryptions = self.nextEncryptions",
            "        if self.outgoingCompressionType == b\"zlib\":",
            "            self.outgoingCompression = zlib.compressobj(6)",
            "        if self.incomingCompressionType == b\"zlib\":",
            "            self.incomingCompression = zlib.decompressobj()",
            "",
            "        self._keyExchangeState = self._KEY_EXCHANGE_NONE",
            "        messages = self._blockedByKeyExchange",
            "        self._blockedByKeyExchange = None",
            "        for (messageType, payload) in messages:",
            "            self.sendPacket(messageType, payload)",
            "",
            "    def isEncrypted(self, direction=\"out\"):",
            "        \"\"\"",
            "        Check if the connection is encrypted in the given direction.",
            "",
            "        @type direction: L{str}",
            "        @param direction: The direction: one of 'out', 'in', or 'both'.",
            "",
            "        @rtype: L{bool}",
            "        @return: C{True} if it is encrypted.",
            "        \"\"\"",
            "        if direction == \"out\":",
            "            return self.currentEncryptions.outCipType != b\"none\"",
            "        elif direction == \"in\":",
            "            return self.currentEncryptions.inCipType != b\"none\"",
            "        elif direction == \"both\":",
            "            return self.isEncrypted(\"in\") and self.isEncrypted(\"out\")",
            "        else:",
            "            raise TypeError('direction must be \"out\", \"in\", or \"both\"')",
            "",
            "    def isVerified(self, direction=\"out\"):",
            "        \"\"\"",
            "        Check if the connection is verified/authentication in the given direction.",
            "",
            "        @type direction: L{str}",
            "        @param direction: The direction: one of 'out', 'in', or 'both'.",
            "",
            "        @rtype: L{bool}",
            "        @return: C{True} if it is verified.",
            "        \"\"\"",
            "        if direction == \"out\":",
            "            return self.currentEncryptions.outMACType != b\"none\"",
            "        elif direction == \"in\":",
            "            return self.currentEncryptions.inMACType != b\"none\"",
            "        elif direction == \"both\":",
            "            return self.isVerified(\"in\") and self.isVerified(\"out\")",
            "        else:",
            "            raise TypeError('direction must be \"out\", \"in\", or \"both\"')",
            "",
            "    def loseConnection(self):",
            "        \"\"\"",
            "        Lose the connection to the other side, sending a",
            "        DISCONNECT_CONNECTION_LOST message.",
            "        \"\"\"",
            "        self.sendDisconnect(DISCONNECT_CONNECTION_LOST, b\"user closed connection\")",
            "",
            "    # Client methods",
            "",
            "    def receiveError(self, reasonCode, description):",
            "        \"\"\"",
            "        Called when we receive a disconnect error message from the other",
            "        side.",
            "",
            "        @param reasonCode: the reason for the disconnect, one of the",
            "                           DISCONNECT_ values.",
            "        @type reasonCode: L{int}",
            "        @param description: a human-readable description of the",
            "                            disconnection.",
            "        @type description: L{str}",
            "        \"\"\"",
            "        self._log.error(",
            "            \"Got remote error, code {code}\\nreason: {description}\",",
            "            code=reasonCode,",
            "            description=description,",
            "        )",
            "",
            "    def receiveUnimplemented(self, seqnum):",
            "        \"\"\"",
            "        Called when we receive an unimplemented packet message from the other",
            "        side.",
            "",
            "        @param seqnum: the sequence number that was not understood.",
            "        @type seqnum: L{int}",
            "        \"\"\"",
            "        self._log.warn(\"other side unimplemented packet #{seqnum}\", seqnum=seqnum)",
            "",
            "    def receiveDebug(self, alwaysDisplay, message, lang):",
            "        \"\"\"",
            "        Called when we receive a debug message from the other side.",
            "",
            "        @param alwaysDisplay: if True, this message should always be",
            "                              displayed.",
            "        @type alwaysDisplay: L{bool}",
            "        @param message: the debug message",
            "        @type message: L{str}",
            "        @param lang: optionally the language the message is in.",
            "        @type lang: L{str}",
            "        \"\"\"",
            "        if alwaysDisplay:",
            "            self._log.debug(\"Remote Debug Message: {message}\", message=message)",
            "",
            "    def _generateECPrivateKey(self):",
            "        \"\"\"",
            "        Generate an private key for ECDH key exchange.",
            "",
            "        @rtype: The appropriate private key type matching C{self.kexAlg}:",
            "            L{ec.EllipticCurvePrivateKey} for C{ecdh-sha2-nistp*}, or",
            "            L{x25519.X25519PrivateKey} for C{curve25519-sha256}.",
            "        @return: The generated private key.",
            "        \"\"\"",
            "        if self.kexAlg.startswith(b\"ecdh-sha2-nistp\"):",
            "            try:",
            "                curve = keys._curveTable[b\"ecdsa\" + self.kexAlg[4:]]",
            "            except KeyError:",
            "                raise UnsupportedAlgorithm(\"unused-key\")",
            "",
            "            return ec.generate_private_key(curve, default_backend())",
            "        elif self.kexAlg in (b\"curve25519-sha256\", b\"curve25519-sha256@libssh.org\"):",
            "            return x25519.X25519PrivateKey.generate()",
            "        else:",
            "            raise UnsupportedAlgorithm(",
            "                \"Cannot generate elliptic curve private key for {!r}\".format(",
            "                    self.kexAlg",
            "                )",
            "            )",
            "",
            "    def _encodeECPublicKey(self, ecPub):",
            "        \"\"\"",
            "        Encode an elliptic curve public key to bytes.",
            "",
            "        @type ecPub: The appropriate public key type matching",
            "            C{self.kexAlg}: L{ec.EllipticCurvePublicKey} for",
            "            C{ecdh-sha2-nistp*}, or L{x25519.X25519PublicKey} for",
            "            C{curve25519-sha256}.",
            "        @param ecPub: The public key to encode.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The encoded public key.",
            "        \"\"\"",
            "        if self.kexAlg.startswith(b\"ecdh-sha2-nistp\"):",
            "            return ecPub.public_bytes(",
            "                serialization.Encoding.X962,",
            "                serialization.PublicFormat.UncompressedPoint,",
            "            )",
            "        elif self.kexAlg in (b\"curve25519-sha256\", b\"curve25519-sha256@libssh.org\"):",
            "            return ecPub.public_bytes(",
            "                serialization.Encoding.Raw, serialization.PublicFormat.Raw",
            "            )",
            "        else:",
            "            raise UnsupportedAlgorithm(",
            "                f\"Cannot encode elliptic curve public key for {self.kexAlg!r}\"",
            "            )",
            "",
            "    def _generateECSharedSecret(self, ecPriv, theirECPubBytes):",
            "        \"\"\"",
            "        Generate a shared secret for ECDH key exchange.",
            "",
            "        @type ecPriv: The appropriate private key type matching",
            "            C{self.kexAlg}: L{ec.EllipticCurvePrivateKey} for",
            "            C{ecdh-sha2-nistp*}, or L{x25519.X25519PrivateKey} for",
            "            C{curve25519-sha256}.",
            "        @param ecPriv: Our private key.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The generated shared secret, as an SSH multiple-precision",
            "            integer.",
            "        \"\"\"",
            "        if self.kexAlg.startswith(b\"ecdh-sha2-nistp\"):",
            "            try:",
            "                curve = keys._curveTable[b\"ecdsa\" + self.kexAlg[4:]]",
            "            except KeyError:",
            "                raise UnsupportedAlgorithm(\"unused-key\")",
            "",
            "            theirECPub = ec.EllipticCurvePublicKey.from_encoded_point(",
            "                curve, theirECPubBytes",
            "            )",
            "            sharedSecret = ecPriv.exchange(ec.ECDH(), theirECPub)",
            "        elif self.kexAlg in (b\"curve25519-sha256\", b\"curve25519-sha256@libssh.org\"):",
            "            theirECPub = x25519.X25519PublicKey.from_public_bytes(theirECPubBytes)",
            "            sharedSecret = ecPriv.exchange(theirECPub)",
            "        else:",
            "            raise UnsupportedAlgorithm(",
            "                \"Cannot generate elliptic curve shared secret for {!r}\".format(",
            "                    self.kexAlg",
            "                )",
            "            )",
            "",
            "        return _mpFromBytes(sharedSecret)",
            "",
            "",
            "class SSHServerTransport(SSHTransportBase):",
            "    \"\"\"",
            "    SSHServerTransport implements the server side of the SSH protocol.",
            "",
            "    @ivar isClient: since we are never the client, this is always False.",
            "",
            "    @ivar ignoreNextPacket: if True, ignore the next key exchange packet.  This",
            "        is set when the client sends a guessed key exchange packet but with",
            "        an incorrect guess.",
            "",
            "    @ivar dhGexRequest: the KEX_DH_GEX_REQUEST(_OLD) that the client sent.",
            "        The key generation needs this to be stored.",
            "",
            "    @ivar g: the Diffie-Hellman group generator.",
            "",
            "    @ivar p: the Diffie-Hellman group prime.",
            "    \"\"\"",
            "",
            "    isClient = False",
            "    ignoreNextPacket = 0",
            "",
            "    def ssh_KEXINIT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEXINIT message.  For a description",
            "        of the packet, see SSHTransportBase.ssh_KEXINIT().  Additionally,",
            "        this method checks if a guessed key exchange packet was sent.  If",
            "        it was sent, and it guessed incorrectly, the next key exchange",
            "        packet MUST be ignored.",
            "        \"\"\"",
            "        retval = SSHTransportBase.ssh_KEXINIT(self, packet)",
            "        if not retval:  # Disconnected",
            "            return",
            "        else:",
            "            kexAlgs, keyAlgs, rest = retval",
            "        if ord(rest[0:1]):  # Flag first_kex_packet_follows?",
            "            if (",
            "                kexAlgs[0] != self.supportedKeyExchanges[0]",
            "                or keyAlgs[0] != self.supportedPublicKeys[0]",
            "            ):",
            "                self.ignoreNextPacket = True  # Guess was wrong",
            "",
            "    def _ssh_KEX_ECDH_INIT(self, packet):",
            "        \"\"\"",
            "        Called from L{ssh_KEX_DH_GEX_REQUEST_OLD} to handle",
            "        elliptic curve key exchanges.",
            "",
            "        Payload::",
            "",
            "            string client Elliptic Curve Diffie-Hellman public key",
            "",
            "        Just like L{_ssh_KEXDH_INIT} this message type is also not dispatched",
            "        directly. Extra check to determine if this is really KEX_ECDH_INIT",
            "        is required.",
            "",
            "        First we load the host's public/private keys.",
            "        Then we generate the ECDH public/private keypair for the given curve.",
            "        With that we generate the shared secret key.",
            "        Then we compute the hash to sign and send back to the client",
            "        Along with the server's public key and the ECDH public key.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: None.",
            "        \"\"\"",
            "        # Get the raw client public key.",
            "        pktPub, packet = getNS(packet)",
            "",
            "        # Get the host's public and private keys",
            "        pubHostKey = self.factory.publicKeys[self.keyAlg]",
            "        privHostKey = self.factory.privateKeys[self.keyAlg]",
            "",
            "        # Generate the private key",
            "        ecPriv = self._generateECPrivateKey()",
            "",
            "        # Get the public key",
            "        self.ecPub = ecPriv.public_key()",
            "        encPub = self._encodeECPublicKey(self.ecPub)",
            "",
            "        # Generate the shared secret",
            "        sharedSecret = self._generateECSharedSecret(ecPriv, pktPub)",
            "",
            "        # Finish update and digest",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(pubHostKey.blob()))",
            "        h.update(NS(pktPub))",
            "        h.update(NS(encPub))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        self.sendPacket(",
            "            MSG_KEXDH_REPLY,",
            "            NS(pubHostKey.blob()) + NS(encPub) + NS(privHostKey.sign(exchangeHash)),",
            "        )",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def _ssh_KEXDH_INIT(self, packet):",
            "        \"\"\"",
            "        Called to handle the beginning of a non-group key exchange.",
            "",
            "        Unlike other message types, this is not dispatched automatically.  It",
            "        is called from C{ssh_KEX_DH_GEX_REQUEST_OLD} because an extra check is",
            "        required to determine if this is really a KEXDH_INIT message or if it",
            "        is a KEX_DH_GEX_REQUEST_OLD message.",
            "",
            "        The KEXDH_INIT payload::",
            "",
            "                integer e (the client's Diffie-Hellman public key)",
            "",
            "        We send the KEXDH_REPLY with our host key and signature.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        clientDHpublicKey, foo = getMP(packet)",
            "        self.g, self.p = _kex.getDHGeneratorAndPrime(self.kexAlg)",
            "        self._startEphemeralDH()",
            "        sharedSecret = self._finishEphemeralDH(clientDHpublicKey)",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(self.factory.publicKeys[self.keyAlg].blob()))",
            "        h.update(MP(clientDHpublicKey))",
            "        h.update(self.dhSecretKeyPublicMP)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        self.sendPacket(",
            "            MSG_KEXDH_REPLY,",
            "            NS(self.factory.publicKeys[self.keyAlg].blob())",
            "            + self.dhSecretKeyPublicMP",
            "            + NS(self.factory.privateKeys[self.keyAlg].sign(exchangeHash)),",
            "        )",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def ssh_KEX_DH_GEX_REQUEST_OLD(self, packet):",
            "        \"\"\"",
            "        This represents different key exchange methods that share the same",
            "        integer value.  If the message is determined to be a KEXDH_INIT,",
            "        L{_ssh_KEXDH_INIT} is called to handle it. If it is a KEX_ECDH_INIT,",
            "        L{_ssh_KEX_ECDH_INIT} is called.",
            "        Otherwise, for KEX_DH_GEX_REQUEST_OLD payload::",
            "",
            "                integer ideal (ideal size for the Diffie-Hellman prime)",
            "",
            "            We send the KEX_DH_GEX_GROUP message with the group that is",
            "            closest in size to ideal.",
            "",
            "        If we were told to ignore the next key exchange packet by ssh_KEXINIT,",
            "        drop it on the floor and return.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if self.ignoreNextPacket:",
            "            self.ignoreNextPacket = 0",
            "            return",
            "",
            "        # KEXDH_INIT, KEX_ECDH_INIT, and KEX_DH_GEX_REQUEST_OLD",
            "        # have the same value, so use another cue",
            "        # to decide what kind of message the peer sent us.",
            "        if _kex.isFixedGroup(self.kexAlg):",
            "            return self._ssh_KEXDH_INIT(packet)",
            "        elif _kex.isEllipticCurve(self.kexAlg):",
            "            return self._ssh_KEX_ECDH_INIT(packet)",
            "        else:",
            "            self.dhGexRequest = packet",
            "            ideal = struct.unpack(\">L\", packet)[0]",
            "            self.g, self.p = self.factory.getDHPrime(ideal)",
            "            self._startEphemeralDH()",
            "            self.sendPacket(MSG_KEX_DH_GEX_GROUP, MP(self.p) + MP(self.g))",
            "",
            "    def ssh_KEX_DH_GEX_REQUEST(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEX_DH_GEX_REQUEST message.  Payload::",
            "            integer minimum",
            "            integer ideal",
            "            integer maximum",
            "",
            "        The client is asking for a Diffie-Hellman group between minimum and",
            "        maximum size, and close to ideal if possible.  We reply with a",
            "        MSG_KEX_DH_GEX_GROUP message.",
            "",
            "        If we were told to ignore the next key exchange packet by ssh_KEXINIT,",
            "        drop it on the floor and return.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if self.ignoreNextPacket:",
            "            self.ignoreNextPacket = 0",
            "            return",
            "        self.dhGexRequest = packet",
            "        min, ideal, max = struct.unpack(\">3L\", packet)",
            "        self.g, self.p = self.factory.getDHPrime(ideal)",
            "        self._startEphemeralDH()",
            "        self.sendPacket(MSG_KEX_DH_GEX_GROUP, MP(self.p) + MP(self.g))",
            "",
            "    def ssh_KEX_DH_GEX_INIT(self, packet):",
            "        \"\"\"",
            "        Called when we get a MSG_KEX_DH_GEX_INIT message.  Payload::",
            "            integer e (client DH public key)",
            "",
            "        We send the MSG_KEX_DH_GEX_REPLY message with our host key and",
            "        signature.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        clientDHpublicKey, foo = getMP(packet)",
            "        # TODO: we should also look at the value they send to us and reject",
            "        # insecure values of f (if g==2 and f has a single '1' bit while the",
            "        # rest are '0's, then they must have used a small y also).",
            "",
            "        # TODO: This could be computed when self.p is set up",
            "        #  or do as openssh does and scan f for a single '1' bit instead",
            "",
            "        sharedSecret = self._finishEphemeralDH(clientDHpublicKey)",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(self.factory.publicKeys[self.keyAlg].blob()))",
            "        h.update(self.dhGexRequest)",
            "        h.update(MP(self.p))",
            "        h.update(MP(self.g))",
            "        h.update(MP(clientDHpublicKey))",
            "        h.update(self.dhSecretKeyPublicMP)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        self.sendPacket(",
            "            MSG_KEX_DH_GEX_REPLY,",
            "            NS(self.factory.publicKeys[self.keyAlg].blob())",
            "            + self.dhSecretKeyPublicMP",
            "            + NS(self.factory.privateKeys[self.keyAlg].sign(exchangeHash)),",
            "        )",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def _keySetup(self, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        See SSHTransportBase._keySetup().",
            "        \"\"\"",
            "        firstKey = self.sessionID is None",
            "        SSHTransportBase._keySetup(self, sharedSecret, exchangeHash)",
            "        # RFC 8308 section 2.4 says that the server MAY send EXT_INFO at",
            "        # zero, one, or both of the following opportunities: the next packet",
            "        # following the server's first MSG_NEWKEYS, or immediately preceding",
            "        # the server's MSG_USERAUTH_SUCCESS.  We have no need for the",
            "        # latter, so make sure we only send it in the former case.",
            "        if firstKey:",
            "            self.sendExtInfo(",
            "                [(b\"server-sig-algs\", b\",\".join(self.supportedPublicKeys))]",
            "            )",
            "",
            "    def ssh_NEWKEYS(self, packet):",
            "        \"\"\"",
            "        Called when we get a MSG_NEWKEYS message.  No payload.",
            "        When we get this, the keys have been set on both sides, and we",
            "        start using them to encrypt and authenticate the connection.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if packet != b\"\":",
            "            self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR, b\"NEWKEYS takes no data\")",
            "            return",
            "        self._newKeys()",
            "",
            "    def ssh_SERVICE_REQUEST(self, packet):",
            "        \"\"\"",
            "        Called when we get a MSG_SERVICE_REQUEST message.  Payload::",
            "            string serviceName",
            "",
            "        The client has requested a service.  If we can start the service,",
            "        start it; otherwise, disconnect with",
            "        DISCONNECT_SERVICE_NOT_AVAILABLE.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        service, rest = getNS(packet)",
            "        cls = self.factory.getService(self, service)",
            "        if not cls:",
            "            self.sendDisconnect(",
            "                DISCONNECT_SERVICE_NOT_AVAILABLE, b\"don't have service \" + service",
            "            )",
            "            return",
            "        else:",
            "            self.sendPacket(MSG_SERVICE_ACCEPT, NS(service))",
            "            self.setService(cls())",
            "",
            "",
            "class SSHClientTransport(SSHTransportBase):",
            "    \"\"\"",
            "    SSHClientTransport implements the client side of the SSH protocol.",
            "",
            "    @ivar isClient: since we are always the client, this is always True.",
            "",
            "    @ivar _gotNewKeys: if we receive a MSG_NEWKEYS message before we are",
            "        ready to transition to the new keys, this is set to True so we",
            "        can transition when the keys are ready locally.",
            "",
            "    @ivar x: our Diffie-Hellman private key.",
            "",
            "    @ivar e: our Diffie-Hellman public key.",
            "",
            "    @ivar g: the Diffie-Hellman group generator.",
            "",
            "    @ivar p: the Diffie-Hellman group prime",
            "",
            "    @ivar instance: the SSHService object we are requesting.",
            "",
            "    @ivar _dhMinimalGroupSize: Minimal acceptable group size advertised by the",
            "        client in MSG_KEX_DH_GEX_REQUEST.",
            "    @type _dhMinimalGroupSize: int",
            "",
            "    @ivar _dhMaximalGroupSize: Maximal acceptable group size advertised by the",
            "        client in MSG_KEX_DH_GEX_REQUEST.",
            "    @type _dhMaximalGroupSize: int",
            "",
            "    @ivar _dhPreferredGroupSize: Preferred group size advertised by the client",
            "        in MSG_KEX_DH_GEX_REQUEST.",
            "    @type _dhPreferredGroupSize: int",
            "    \"\"\"",
            "",
            "    isClient = True",
            "",
            "    # Recommended minimal and maximal values from RFC 4419, 3.",
            "    _dhMinimalGroupSize = 1024",
            "    _dhMaximalGroupSize = 8192",
            "    # FIXME: https://twistedmatrix.com/trac/ticket/8103",
            "    # This may need to be more dynamic; compare kexgex_client in",
            "    # OpenSSH.",
            "    _dhPreferredGroupSize = 2048",
            "",
            "    def connectionMade(self):",
            "        \"\"\"",
            "        Called when the connection is started with the server.  Just sets",
            "        up a private instance variable.",
            "        \"\"\"",
            "        SSHTransportBase.connectionMade(self)",
            "        self._gotNewKeys = 0",
            "",
            "    def ssh_KEXINIT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEXINIT message.  For a description",
            "        of the packet, see SSHTransportBase.ssh_KEXINIT().  Additionally,",
            "        this method sends the first key exchange packet.",
            "",
            "        If the agreed-upon exchange is ECDH, generate a key pair for the",
            "        corresponding curve and send the public key.",
            "",
            "        If the agreed-upon exchange has a fixed prime/generator group,",
            "        generate a public key and send it in a MSG_KEXDH_INIT message.",
            "        Otherwise, ask for a 2048 bit group with a MSG_KEX_DH_GEX_REQUEST",
            "        message.",
            "        \"\"\"",
            "        if SSHTransportBase.ssh_KEXINIT(self, packet) is None:",
            "            # Connection was disconnected while doing base processing.",
            "            # Maybe no common protocols were agreed.",
            "            return",
            "        # Are we using ECDH?",
            "        if _kex.isEllipticCurve(self.kexAlg):",
            "            # Generate the keys",
            "            self.ecPriv = self._generateECPrivateKey()",
            "            self.ecPub = self.ecPriv.public_key()",
            "",
            "            # DH_GEX_REQUEST_OLD is the same number we need.",
            "            self.sendPacket(",
            "                MSG_KEX_DH_GEX_REQUEST_OLD, NS(self._encodeECPublicKey(self.ecPub))",
            "            )",
            "        elif _kex.isFixedGroup(self.kexAlg):",
            "            # We agreed on a fixed group key exchange algorithm.",
            "            self.g, self.p = _kex.getDHGeneratorAndPrime(self.kexAlg)",
            "            self._startEphemeralDH()",
            "            self.sendPacket(MSG_KEXDH_INIT, self.dhSecretKeyPublicMP)",
            "        else:",
            "            # We agreed on a dynamic group. Tell the server what range of",
            "            # group sizes we accept, and what size we prefer; the server",
            "            # will then select a group.",
            "            self.sendPacket(",
            "                MSG_KEX_DH_GEX_REQUEST,",
            "                struct.pack(",
            "                    \"!LLL\",",
            "                    self._dhMinimalGroupSize,",
            "                    self._dhPreferredGroupSize,",
            "                    self._dhMaximalGroupSize,",
            "                ),",
            "            )",
            "",
            "    def _ssh_KEX_ECDH_REPLY(self, packet):",
            "        \"\"\"",
            "        Called to handle a reply to a ECDH exchange message(KEX_ECDH_INIT).",
            "",
            "        Like the handler for I{KEXDH_INIT}, this message type has an",
            "        overlapping value.  This method is called from C{ssh_KEX_DH_GEX_GROUP}",
            "        if that method detects a non-group key exchange is in progress.",
            "",
            "        Payload::",
            "",
            "            string serverHostKey",
            "            string server Elliptic Curve Diffie-Hellman public key",
            "            string signature",
            "",
            "        We verify the host key and continue if it passes verificiation.",
            "        Otherwise raise an exception and return.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: A deferred firing when key exchange is complete.",
            "        \"\"\"",
            "",
            "        def _continue_KEX_ECDH_REPLY(ignored, hostKey, pubKey, signature):",
            "            # Save off the host public key.",
            "            theirECHost = hostKey",
            "",
            "            sharedSecret = self._generateECSharedSecret(self.ecPriv, pubKey)",
            "",
            "            h = _kex.getHashProcessor(self.kexAlg)()",
            "            h.update(NS(self.ourVersionString))",
            "            h.update(NS(self.otherVersionString))",
            "            h.update(NS(self.ourKexInitPayload))",
            "            h.update(NS(self.otherKexInitPayload))",
            "            h.update(NS(theirECHost))",
            "            h.update(NS(self._encodeECPublicKey(self.ecPub)))",
            "            h.update(NS(pubKey))",
            "            h.update(sharedSecret)",
            "",
            "            exchangeHash = h.digest()",
            "",
            "            if not keys.Key.fromString(theirECHost).verify(signature, exchangeHash):",
            "                self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED, b\"bad signature\")",
            "            else:",
            "                self._keySetup(sharedSecret, exchangeHash)",
            "",
            "        # Get the host public key,",
            "        # the raw ECDH public key bytes and the signature",
            "        hostKey, pubKey, signature, packet = getNS(packet, 3)",
            "",
            "        # Easier to comment this out for now than to update all of the tests.",
            "        # fingerprint = nativeString(base64.b64encode(",
            "        #        sha256(hostKey).digest()))",
            "",
            "        fingerprint = b\":\".join(",
            "            [binascii.hexlify(ch) for ch in iterbytes(md5(hostKey).digest())]",
            "        )",
            "        d = self.verifyHostKey(hostKey, fingerprint)",
            "        d.addCallback(_continue_KEX_ECDH_REPLY, hostKey, pubKey, signature)",
            "        d.addErrback(",
            "            lambda unused: self.sendDisconnect(",
            "                DISCONNECT_HOST_KEY_NOT_VERIFIABLE, b\"bad host key\"",
            "            )",
            "        )",
            "        return d",
            "",
            "    def _ssh_KEXDH_REPLY(self, packet):",
            "        \"\"\"",
            "        Called to handle a reply to a non-group key exchange message",
            "        (KEXDH_INIT).",
            "",
            "        Like the handler for I{KEXDH_INIT}, this message type has an",
            "        overlapping value.  This method is called from C{ssh_KEX_DH_GEX_GROUP}",
            "        if that method detects a non-group key exchange is in progress.",
            "",
            "        Payload::",
            "",
            "            string serverHostKey",
            "            integer f (server Diffie-Hellman public key)",
            "            string signature",
            "",
            "        We verify the host key by calling verifyHostKey, then continue in",
            "        _continueKEXDH_REPLY.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: A deferred firing when key exchange is complete.",
            "        \"\"\"",
            "        pubKey, packet = getNS(packet)",
            "        f, packet = getMP(packet)",
            "        signature, packet = getNS(packet)",
            "        fingerprint = b\":\".join(",
            "            [binascii.hexlify(ch) for ch in iterbytes(md5(pubKey).digest())]",
            "        )",
            "        d = self.verifyHostKey(pubKey, fingerprint)",
            "        d.addCallback(self._continueKEXDH_REPLY, pubKey, f, signature)",
            "        d.addErrback(",
            "            lambda unused: self.sendDisconnect(",
            "                DISCONNECT_HOST_KEY_NOT_VERIFIABLE, b\"bad host key\"",
            "            )",
            "        )",
            "        return d",
            "",
            "    def ssh_KEX_DH_GEX_GROUP(self, packet):",
            "        \"\"\"",
            "        This handles different messages which share an integer value.",
            "",
            "        If the key exchange does not have a fixed prime/generator group,",
            "        we generate a Diffie-Hellman public key and send it in a",
            "        MSG_KEX_DH_GEX_INIT message.",
            "",
            "        Payload::",
            "            string g (group generator)",
            "            string p (group prime)",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if _kex.isFixedGroup(self.kexAlg):",
            "            return self._ssh_KEXDH_REPLY(packet)",
            "        elif _kex.isEllipticCurve(self.kexAlg):",
            "            return self._ssh_KEX_ECDH_REPLY(packet)",
            "        else:",
            "            self.p, rest = getMP(packet)",
            "            self.g, rest = getMP(rest)",
            "            self._startEphemeralDH()",
            "            self.sendPacket(MSG_KEX_DH_GEX_INIT, self.dhSecretKeyPublicMP)",
            "",
            "    def _continueKEXDH_REPLY(self, ignored, pubKey, f, signature):",
            "        \"\"\"",
            "        The host key has been verified, so we generate the keys.",
            "",
            "        @param ignored: Ignored.",
            "",
            "        @param pubKey: the public key blob for the server's public key.",
            "        @type pubKey: L{str}",
            "        @param f: the server's Diffie-Hellman public key.",
            "        @type f: L{int}",
            "        @param signature: the server's signature, verifying that it has the",
            "            correct private key.",
            "        @type signature: L{str}",
            "        \"\"\"",
            "        serverKey = keys.Key.fromString(pubKey)",
            "        sharedSecret = self._finishEphemeralDH(f)",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(pubKey))",
            "        h.update(self.dhSecretKeyPublicMP)",
            "        h.update(MP(f))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        if not serverKey.verify(signature, exchangeHash):",
            "            self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED, b\"bad signature\")",
            "            return",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def ssh_KEX_DH_GEX_REPLY(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEX_DH_GEX_REPLY message.  Payload::",
            "            string server host key",
            "            integer f (server DH public key)",
            "",
            "        We verify the host key by calling verifyHostKey, then continue in",
            "        _continueGEX_REPLY.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: A deferred firing once key exchange is complete.",
            "        \"\"\"",
            "        pubKey, packet = getNS(packet)",
            "        f, packet = getMP(packet)",
            "        signature, packet = getNS(packet)",
            "        fingerprint = b\":\".join(",
            "            [binascii.hexlify(c) for c in iterbytes(md5(pubKey).digest())]",
            "        )",
            "        d = self.verifyHostKey(pubKey, fingerprint)",
            "        d.addCallback(self._continueGEX_REPLY, pubKey, f, signature)",
            "        d.addErrback(",
            "            lambda unused: self.sendDisconnect(",
            "                DISCONNECT_HOST_KEY_NOT_VERIFIABLE, b\"bad host key\"",
            "            )",
            "        )",
            "        return d",
            "",
            "    def _continueGEX_REPLY(self, ignored, pubKey, f, signature):",
            "        \"\"\"",
            "        The host key has been verified, so we generate the keys.",
            "",
            "        @param ignored: Ignored.",
            "",
            "        @param pubKey: the public key blob for the server's public key.",
            "        @type pubKey: L{str}",
            "        @param f: the server's Diffie-Hellman public key.",
            "        @type f: L{int}",
            "        @param signature: the server's signature, verifying that it has the",
            "            correct private key.",
            "        @type signature: L{str}",
            "        \"\"\"",
            "        serverKey = keys.Key.fromString(pubKey)",
            "        sharedSecret = self._finishEphemeralDH(f)",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(pubKey))",
            "        h.update(",
            "            struct.pack(",
            "                \"!LLL\",",
            "                self._dhMinimalGroupSize,",
            "                self._dhPreferredGroupSize,",
            "                self._dhMaximalGroupSize,",
            "            )",
            "        )",
            "        h.update(MP(self.p))",
            "        h.update(MP(self.g))",
            "        h.update(self.dhSecretKeyPublicMP)",
            "        h.update(MP(f))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        if not serverKey.verify(signature, exchangeHash):",
            "            self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED, b\"bad signature\")",
            "            return",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def _keySetup(self, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        See SSHTransportBase._keySetup().",
            "        \"\"\"",
            "        SSHTransportBase._keySetup(self, sharedSecret, exchangeHash)",
            "        if self._gotNewKeys:",
            "            self.ssh_NEWKEYS(b\"\")",
            "",
            "    def ssh_NEWKEYS(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_NEWKEYS message.  No payload.",
            "        If we've finished setting up our own keys, start using them.",
            "        Otherwise, remember that we've received this message.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if packet != b\"\":",
            "            self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR, b\"NEWKEYS takes no data\")",
            "            return",
            "        if not self.nextEncryptions.encBlockSize:",
            "            self._gotNewKeys = 1",
            "            return",
            "        self._newKeys()",
            "        self.connectionSecure()",
            "",
            "    def ssh_SERVICE_ACCEPT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_SERVICE_ACCEPT message.  Payload::",
            "            string service name",
            "",
            "        Start the service we requested.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if packet == b\"\":",
            "            self._log.info(\"got SERVICE_ACCEPT without payload\")",
            "        else:",
            "            name = getNS(packet)[0]",
            "            if name != self.instance.name:",
            "                self.sendDisconnect(",
            "                    DISCONNECT_PROTOCOL_ERROR,",
            "                    b\"received accept for service we did not request\",",
            "                )",
            "        self.setService(self.instance)",
            "",
            "    def requestService(self, instance):",
            "        \"\"\"",
            "        Request that a service be run over this transport.",
            "",
            "        @type instance: subclass of L{twisted.conch.ssh.service.SSHService}",
            "        @param instance: The service to run.",
            "        \"\"\"",
            "        self.sendPacket(MSG_SERVICE_REQUEST, NS(instance.name))",
            "        self.instance = instance",
            "",
            "    # Client methods",
            "",
            "    def verifyHostKey(self, hostKey, fingerprint):",
            "        \"\"\"",
            "        Returns a Deferred that gets a callback if it is a valid key, or",
            "        an errback if not.",
            "",
            "        @type hostKey: L{bytes}",
            "        @param hostKey: The host key to verify.",
            "",
            "        @type fingerprint: L{bytes}",
            "        @param fingerprint: The fingerprint of the key.",
            "",
            "        @return: A deferred firing with C{True} if the key is valid.",
            "        \"\"\"",
            "        return defer.fail(NotImplementedError())",
            "",
            "    def connectionSecure(self):",
            "        \"\"\"",
            "        Called when the encryption has been set up.  Generally,",
            "        requestService() is called to run another service over the transport.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "",
            "class _NullEncryptionContext:",
            "    \"\"\"",
            "    An encryption context that does not actually encrypt anything.",
            "    \"\"\"",
            "",
            "    def update(self, data):",
            "        \"\"\"",
            "        'Encrypt' new data by doing nothing.",
            "",
            "        @type data: L{bytes}",
            "        @param data: The data to 'encrypt'.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The 'encrypted' data.",
            "        \"\"\"",
            "        return data",
            "",
            "",
            "class _DummyAlgorithm:",
            "    \"\"\"",
            "    An encryption algorithm that does not actually encrypt anything.",
            "    \"\"\"",
            "",
            "    block_size = 64",
            "",
            "",
            "class _DummyCipher:",
            "    \"\"\"",
            "    A cipher for the none encryption method.",
            "",
            "    @ivar block_size: the block size of the encryption.  In the case of the",
            "    none cipher, this is 8 bytes.",
            "    \"\"\"",
            "",
            "    algorithm = _DummyAlgorithm()",
            "",
            "    def encryptor(self):",
            "        \"\"\"",
            "        Construct a noop encryptor.",
            "",
            "        @return: The encryptor.",
            "        \"\"\"",
            "        return _NullEncryptionContext()",
            "",
            "    def decryptor(self):",
            "        \"\"\"",
            "        Construct a noop decryptor.",
            "",
            "        @return: The decryptor.",
            "        \"\"\"",
            "        return _NullEncryptionContext()",
            "",
            "",
            "DH_GENERATOR, DH_PRIME = _kex.getDHGeneratorAndPrime(b\"diffie-hellman-group14-sha1\")",
            "",
            "",
            "MSG_DISCONNECT = 1",
            "MSG_IGNORE = 2",
            "MSG_UNIMPLEMENTED = 3",
            "MSG_DEBUG = 4",
            "MSG_SERVICE_REQUEST = 5",
            "MSG_SERVICE_ACCEPT = 6",
            "MSG_EXT_INFO = 7",
            "MSG_KEXINIT = 20",
            "MSG_NEWKEYS = 21",
            "MSG_KEXDH_INIT = 30",
            "MSG_KEXDH_REPLY = 31",
            "MSG_KEX_DH_GEX_REQUEST_OLD = 30",
            "MSG_KEX_DH_GEX_REQUEST = 34",
            "MSG_KEX_DH_GEX_GROUP = 31",
            "MSG_KEX_DH_GEX_INIT = 32",
            "MSG_KEX_DH_GEX_REPLY = 33",
            "",
            "",
            "DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT = 1",
            "DISCONNECT_PROTOCOL_ERROR = 2",
            "DISCONNECT_KEY_EXCHANGE_FAILED = 3",
            "DISCONNECT_RESERVED = 4",
            "DISCONNECT_MAC_ERROR = 5",
            "DISCONNECT_COMPRESSION_ERROR = 6",
            "DISCONNECT_SERVICE_NOT_AVAILABLE = 7",
            "DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED = 8",
            "DISCONNECT_HOST_KEY_NOT_VERIFIABLE = 9",
            "DISCONNECT_CONNECTION_LOST = 10",
            "DISCONNECT_BY_APPLICATION = 11",
            "DISCONNECT_TOO_MANY_CONNECTIONS = 12",
            "DISCONNECT_AUTH_CANCELLED_BY_USER = 13",
            "DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE = 14",
            "DISCONNECT_ILLEGAL_USER_NAME = 15",
            "",
            "",
            "messages = {}",
            "for name, value in list(globals().items()):",
            "    # Avoid legacy messages which overlap with never ones",
            "    if name.startswith(\"MSG_\") and not name.startswith(\"MSG_KEXDH_\"):",
            "        messages[value] = name",
            "# Check for regressions (#5352)",
            "if \"MSG_KEXDH_INIT\" in messages or \"MSG_KEXDH_REPLY\" in messages:",
            "    raise RuntimeError(\"legacy SSH mnemonics should not end up in messages dict\")"
        ],
        "afterPatchFile": [
            "# -*- test-case-name: twisted.conch.test.test_transport -*-",
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "The lowest level SSH protocol.  This handles the key negotiation, the",
            "encryption and the compression.  The transport layer is described in",
            "RFC 4253.",
            "",
            "Maintainer: Paul Swartz",
            "\"\"\"",
            "",
            "",
            "import binascii",
            "import hmac",
            "import struct",
            "import zlib",
            "from hashlib import md5, sha1, sha256, sha384, sha512",
            "from typing import Dict",
            "",
            "from cryptography.exceptions import UnsupportedAlgorithm",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives import serialization",
            "from cryptography.hazmat.primitives.asymmetric import dh, ec, x25519",
            "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes",
            "",
            "from twisted import __version__ as twisted_version",
            "from twisted.conch.ssh import _kex, address, keys",
            "from twisted.conch.ssh.common import MP, NS, ffs, getMP, getNS",
            "from twisted.internet import defer, protocol",
            "from twisted.logger import Logger",
            "from twisted.python import randbytes",
            "from twisted.python.compat import iterbytes, networkString",
            "",
            "# This import is needed if SHA256 hashing is used.",
            "# from twisted.python.compat import nativeString",
            "",
            "",
            "def _mpFromBytes(data):",
            "    \"\"\"Make an SSH multiple-precision integer from big-endian L{bytes}.",
            "",
            "    Used in ECDH key exchange.",
            "",
            "    @type data: L{bytes}",
            "    @param data: The input data, interpreted as a big-endian octet string.",
            "",
            "    @rtype: L{bytes}",
            "    @return: The given data encoded as an SSH multiple-precision integer.",
            "    \"\"\"",
            "    return MP(int.from_bytes(data, \"big\"))",
            "",
            "",
            "class _MACParams(tuple):",
            "    \"\"\"",
            "    L{_MACParams} represents the parameters necessary to compute SSH MAC",
            "    (Message Authenticate Codes).",
            "",
            "    L{_MACParams} is a L{tuple} subclass to maintain compatibility with older",
            "    versions of the code.  The elements of a L{_MACParams} are::",
            "",
            "        0. The digest object used for the MAC",
            "        1. The inner pad (\"ipad\") string",
            "        2. The outer pad (\"opad\") string",
            "        3. The size of the digest produced by the digest object",
            "",
            "    L{_MACParams} is also an object lesson in why tuples are a bad type for",
            "    public APIs.",
            "",
            "    @ivar key: The HMAC key which will be used.",
            "    \"\"\"",
            "",
            "",
            "class SSHCiphers:",
            "    \"\"\"",
            "    SSHCiphers represents all the encryption operations that need to occur",
            "    to encrypt and authenticate the SSH connection.",
            "",
            "    @cvar cipherMap: A dictionary mapping SSH encryption names to 3-tuples of",
            "        (<cryptography.hazmat.primitives.interfaces.CipherAlgorithm>,",
            "        <block size>, <cryptography.hazmat.primitives.interfaces.Mode>)",
            "    @cvar macMap: A dictionary mapping SSH MAC names to hash modules.",
            "",
            "    @ivar outCipType: the string type of the outgoing cipher.",
            "    @ivar inCipType: the string type of the incoming cipher.",
            "    @ivar outMACType: the string type of the incoming MAC.",
            "    @ivar inMACType: the string type of the incoming MAC.",
            "    @ivar encBlockSize: the block size of the outgoing cipher.",
            "    @ivar decBlockSize: the block size of the incoming cipher.",
            "    @ivar verifyDigestSize: the size of the incoming MAC.",
            "    @ivar outMAC: a tuple of (<hash module>, <inner key>, <outer key>,",
            "        <digest size>) representing the outgoing MAC.",
            "    @ivar inMAc: see outMAC, but for the incoming MAC.",
            "    \"\"\"",
            "",
            "    cipherMap = {",
            "        b\"3des-cbc\": (algorithms.TripleDES, 24, modes.CBC),",
            "        b\"blowfish-cbc\": (algorithms.Blowfish, 16, modes.CBC),",
            "        b\"aes256-cbc\": (algorithms.AES, 32, modes.CBC),",
            "        b\"aes192-cbc\": (algorithms.AES, 24, modes.CBC),",
            "        b\"aes128-cbc\": (algorithms.AES, 16, modes.CBC),",
            "        b\"cast128-cbc\": (algorithms.CAST5, 16, modes.CBC),",
            "        b\"aes128-ctr\": (algorithms.AES, 16, modes.CTR),",
            "        b\"aes192-ctr\": (algorithms.AES, 24, modes.CTR),",
            "        b\"aes256-ctr\": (algorithms.AES, 32, modes.CTR),",
            "        b\"3des-ctr\": (algorithms.TripleDES, 24, modes.CTR),",
            "        b\"blowfish-ctr\": (algorithms.Blowfish, 16, modes.CTR),",
            "        b\"cast128-ctr\": (algorithms.CAST5, 16, modes.CTR),",
            "        b\"none\": (None, 0, modes.CBC),",
            "    }",
            "    macMap = {",
            "        b\"hmac-sha2-512\": sha512,",
            "        b\"hmac-sha2-384\": sha384,",
            "        b\"hmac-sha2-256\": sha256,",
            "        b\"hmac-sha1\": sha1,",
            "        b\"hmac-md5\": md5,",
            "        b\"none\": None,",
            "    }",
            "",
            "    def __init__(self, outCip, inCip, outMac, inMac):",
            "        self.outCipType = outCip",
            "        self.inCipType = inCip",
            "        self.outMACType = outMac",
            "        self.inMACType = inMac",
            "        self.encBlockSize = 0",
            "        self.decBlockSize = 0",
            "        self.verifyDigestSize = 0",
            "        self.outMAC = (None, b\"\", b\"\", 0)",
            "        self.inMAC = (None, b\"\", b\"\", 0)",
            "",
            "    def setKeys(self, outIV, outKey, inIV, inKey, outInteg, inInteg):",
            "        \"\"\"",
            "        Set up the ciphers and hashes using the given keys,",
            "",
            "        @param outIV: the outgoing initialization vector",
            "        @param outKey: the outgoing encryption key",
            "        @param inIV: the incoming initialization vector",
            "        @param inKey: the incoming encryption key",
            "        @param outInteg: the outgoing integrity key",
            "        @param inInteg: the incoming integrity key.",
            "        \"\"\"",
            "        o = self._getCipher(self.outCipType, outIV, outKey)",
            "        self.encryptor = o.encryptor()",
            "        self.encBlockSize = o.algorithm.block_size // 8",
            "        o = self._getCipher(self.inCipType, inIV, inKey)",
            "        self.decryptor = o.decryptor()",
            "        self.decBlockSize = o.algorithm.block_size // 8",
            "        self.outMAC = self._getMAC(self.outMACType, outInteg)",
            "        self.inMAC = self._getMAC(self.inMACType, inInteg)",
            "        if self.inMAC:",
            "            self.verifyDigestSize = self.inMAC[3]",
            "",
            "    def _getCipher(self, cip, iv, key):",
            "        \"\"\"",
            "        Creates an initialized cipher object.",
            "",
            "        @param cip: the name of the cipher, maps into cipherMap",
            "        @param iv: the initialzation vector",
            "        @param key: the encryption key",
            "",
            "        @return: the cipher object.",
            "        \"\"\"",
            "        algorithmClass, keySize, modeClass = self.cipherMap[cip]",
            "        if algorithmClass is None:",
            "            return _DummyCipher()",
            "",
            "        return Cipher(",
            "            algorithmClass(key[:keySize]),",
            "            modeClass(iv[: algorithmClass.block_size // 8]),",
            "            backend=default_backend(),",
            "        )",
            "",
            "    def _getMAC(self, mac, key):",
            "        \"\"\"",
            "        Gets a 4-tuple representing the message authentication code.",
            "        (<hash module>, <inner hash value>, <outer hash value>,",
            "        <digest size>)",
            "",
            "        @type mac: L{bytes}",
            "        @param mac: a key mapping into macMap",
            "",
            "        @type key: L{bytes}",
            "        @param key: the MAC key.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The MAC components.",
            "        \"\"\"",
            "        mod = self.macMap[mac]",
            "        if not mod:",
            "            return (None, b\"\", b\"\", 0)",
            "",
            "        # With stdlib we can only get attributes fron an instantiated object.",
            "        hashObject = mod()",
            "        digestSize = hashObject.digest_size",
            "        blockSize = hashObject.block_size",
            "",
            "        # Truncation here appears to contravene RFC 2104, section 2.  However,",
            "        # implementing the hashing behavior prescribed by the RFC breaks",
            "        # interoperability with OpenSSH (at least version 5.5p1).",
            "        key = key[:digestSize] + (b\"\\x00\" * (blockSize - digestSize))",
            "        i = key.translate(hmac.trans_36)",
            "        o = key.translate(hmac.trans_5C)",
            "        result = _MACParams((mod, i, o, digestSize))",
            "        result.key = key",
            "        return result",
            "",
            "    def encrypt(self, blocks):",
            "        \"\"\"",
            "        Encrypt some data.",
            "",
            "        @type blocks: L{bytes}",
            "        @param blocks: The data to encrypt.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The encrypted data.",
            "        \"\"\"",
            "        return self.encryptor.update(blocks)",
            "",
            "    def decrypt(self, blocks):",
            "        \"\"\"",
            "        Decrypt some data.",
            "",
            "        @type blocks: L{bytes}",
            "        @param blocks: The data to decrypt.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The decrypted data.",
            "        \"\"\"",
            "        return self.decryptor.update(blocks)",
            "",
            "    def makeMAC(self, seqid, data):",
            "        \"\"\"",
            "        Create a message authentication code (MAC) for the given packet using",
            "        the outgoing MAC values.",
            "",
            "        @type seqid: L{int}",
            "        @param seqid: The sequence ID of the outgoing packet.",
            "",
            "        @type data: L{bytes}",
            "        @param data: The data to create a MAC for.",
            "",
            "        @rtype: L{str}",
            "        @return: The serialized MAC.",
            "        \"\"\"",
            "        if not self.outMAC[0]:",
            "            return b\"\"",
            "        data = struct.pack(\">L\", seqid) + data",
            "        return hmac.HMAC(self.outMAC.key, data, self.outMAC[0]).digest()",
            "",
            "    def verify(self, seqid, data, mac):",
            "        \"\"\"",
            "        Verify an incoming MAC using the incoming MAC values.",
            "",
            "        @type seqid: L{int}",
            "        @param seqid: The sequence ID of the incoming packet.",
            "",
            "        @type data: L{bytes}",
            "        @param data: The packet data to verify.",
            "",
            "        @type mac: L{bytes}",
            "        @param mac: The MAC sent with the packet.",
            "",
            "        @rtype: L{bool}",
            "        @return: C{True} if the MAC is valid.",
            "        \"\"\"",
            "        if not self.inMAC[0]:",
            "            return mac == b\"\"",
            "        data = struct.pack(\">L\", seqid) + data",
            "        outer = hmac.HMAC(self.inMAC.key, data, self.inMAC[0]).digest()",
            "        return hmac.compare_digest(mac, outer)",
            "",
            "",
            "def _getSupportedCiphers():",
            "    \"\"\"",
            "    Build a list of ciphers that are supported by the backend in use.",
            "",
            "    @return: a list of supported ciphers.",
            "    @rtype: L{list} of L{str}",
            "    \"\"\"",
            "    supportedCiphers = []",
            "    cs = [",
            "        b\"aes256-ctr\",",
            "        b\"aes256-cbc\",",
            "        b\"aes192-ctr\",",
            "        b\"aes192-cbc\",",
            "        b\"aes128-ctr\",",
            "        b\"aes128-cbc\",",
            "        b\"cast128-ctr\",",
            "        b\"cast128-cbc\",",
            "        b\"blowfish-ctr\",",
            "        b\"blowfish-cbc\",",
            "        b\"3des-ctr\",",
            "        b\"3des-cbc\",",
            "    ]",
            "    for cipher in cs:",
            "        algorithmClass, keySize, modeClass = SSHCiphers.cipherMap[cipher]",
            "        try:",
            "            Cipher(",
            "                algorithmClass(b\" \" * keySize),",
            "                modeClass(b\" \" * (algorithmClass.block_size // 8)),",
            "                backend=default_backend(),",
            "            ).encryptor()",
            "        except UnsupportedAlgorithm:",
            "            pass",
            "        else:",
            "            supportedCiphers.append(cipher)",
            "    return supportedCiphers",
            "",
            "",
            "class SSHTransportBase(protocol.Protocol):",
            "    \"\"\"",
            "    Protocol supporting basic SSH functionality: sending/receiving packets",
            "    and message dispatch.  To connect to or run a server, you must use",
            "    SSHClientTransport or SSHServerTransport.",
            "",
            "    @ivar protocolVersion: A string representing the version of the SSH",
            "        protocol we support.  Currently defaults to '2.0'.",
            "",
            "    @ivar version: A string representing the version of the server or client.",
            "        Currently defaults to 'Twisted'.",
            "",
            "    @ivar comment: An optional string giving more information about the",
            "        server or client.",
            "",
            "    @ivar supportedCiphers: A list of strings representing the encryption",
            "        algorithms supported, in order from most-preferred to least.",
            "",
            "    @ivar supportedMACs: A list of strings representing the message",
            "        authentication codes (hashes) supported, in order from most-preferred",
            "        to least.  Both this and supportedCiphers can include 'none' to use",
            "        no encryption or authentication, but that must be done manually,",
            "",
            "    @ivar supportedKeyExchanges: A list of strings representing the",
            "        key exchanges supported, in order from most-preferred to least.",
            "",
            "    @ivar supportedPublicKeys:  A list of strings representing the",
            "        public key types supported, in order from most-preferred to least.",
            "",
            "    @ivar supportedCompressions: A list of strings representing compression",
            "        types supported, from most-preferred to least.",
            "",
            "    @ivar supportedLanguages: A list of strings representing languages",
            "        supported, from most-preferred to least.",
            "",
            "    @ivar supportedVersions: A container of strings representing supported ssh",
            "        protocol version numbers.",
            "",
            "    @ivar isClient: A boolean indicating whether this is a client or server.",
            "",
            "    @ivar gotVersion: A boolean indicating whether we have received the",
            "        version string from the other side.",
            "",
            "    @ivar buf: Data we've received but hasn't been parsed into a packet.",
            "",
            "    @ivar outgoingPacketSequence: the sequence number of the next packet we",
            "        will send.",
            "",
            "    @ivar incomingPacketSequence: the sequence number of the next packet we",
            "        are expecting from the other side.",
            "",
            "    @ivar outgoingCompression: an object supporting the .compress(str) and",
            "        .flush() methods, or None if there is no outgoing compression.  Used to",
            "        compress outgoing data.",
            "",
            "    @ivar outgoingCompressionType: A string representing the outgoing",
            "        compression type.",
            "",
            "    @ivar incomingCompression: an object supporting the .decompress(str)",
            "        method, or None if there is no incoming compression.  Used to",
            "        decompress incoming data.",
            "",
            "    @ivar incomingCompressionType: A string representing the incoming",
            "        compression type.",
            "",
            "    @ivar ourVersionString: the version string that we sent to the other side.",
            "        Used in the key exchange.",
            "",
            "    @ivar otherVersionString: the version string sent by the other side.  Used",
            "        in the key exchange.",
            "",
            "    @ivar ourKexInitPayload: the MSG_KEXINIT payload we sent.  Used in the key",
            "        exchange.",
            "",
            "    @ivar otherKexInitPayload: the MSG_KEXINIT payload we received.  Used in",
            "        the key exchange",
            "",
            "    @ivar sessionID: a string that is unique to this SSH session.  Created as",
            "        part of the key exchange, sessionID is used to generate the various",
            "        encryption and authentication keys.",
            "",
            "    @ivar service: an SSHService instance, or None.  If it's set to an object,",
            "        it's the currently running service.",
            "",
            "    @ivar kexAlg: the agreed-upon key exchange algorithm.",
            "",
            "    @ivar keyAlg: the agreed-upon public key type for the key exchange.",
            "",
            "    @ivar currentEncryptions: an SSHCiphers instance.  It represents the",
            "        current encryption and authentication options for the transport.",
            "",
            "    @ivar nextEncryptions: an SSHCiphers instance.  Held here until the",
            "        MSG_NEWKEYS messages are exchanged, when nextEncryptions is",
            "        transitioned to currentEncryptions.",
            "",
            "    @ivar first: the first bytes of the next packet.  In order to avoid",
            "        decrypting data twice, the first bytes are decrypted and stored until",
            "        the whole packet is available.",
            "",
            "    @ivar _keyExchangeState: The current protocol state with respect to key",
            "        exchange.  This is either C{_KEY_EXCHANGE_NONE} if no key exchange is",
            "        in progress (and returns to this value after any key exchange",
            "        completqes), C{_KEY_EXCHANGE_REQUESTED} if this side of the connection",
            "        initiated a key exchange, and C{_KEY_EXCHANGE_PROGRESSING} if the other",
            "        side of the connection initiated a key exchange.  C{_KEY_EXCHANGE_NONE}",
            "        is the initial value (however SSH connections begin with key exchange,",
            "        so it will quickly change to another state).",
            "",
            "    @ivar _blockedByKeyExchange: Whenever C{_keyExchangeState} is not",
            "        C{_KEY_EXCHANGE_NONE}, this is a C{list} of pending messages which were",
            "        passed to L{sendPacket} but could not be sent because it is not legal",
            "        to send them while a key exchange is in progress.  When the key",
            "        exchange completes, another attempt is made to send these messages.",
            "",
            "    @ivar _peerSupportsExtensions: a boolean indicating whether the other side",
            "        of the connection supports RFC 8308 extension negotiation.",
            "",
            "    @ivar peerExtensions: a dict of extensions supported by the other side of",
            "        the connection.",
            "    \"\"\"",
            "",
            "    _log = Logger()",
            "",
            "    protocolVersion = b\"2.0\"",
            "    version = b\"Twisted_\" + twisted_version.encode(\"ascii\")",
            "    comment = b\"\"",
            "    ourVersionString = (",
            "        b\"SSH-\" + protocolVersion + b\"-\" + version + b\" \" + comment",
            "    ).strip()",
            "",
            "    # L{None} is supported as cipher and hmac. For security they are disabled",
            "    # by default. To enable them, subclass this class and add it, or do:",
            "    # SSHTransportBase.supportedCiphers.append('none')",
            "    # List ordered by preference.",
            "    supportedCiphers = _getSupportedCiphers()",
            "    supportedMACs = [",
            "        b\"hmac-sha2-512\",",
            "        b\"hmac-sha2-384\",",
            "        b\"hmac-sha2-256\",",
            "        b\"hmac-sha1\",",
            "        b\"hmac-md5\",",
            "        # `none`,",
            "    ]",
            "",
            "    supportedKeyExchanges = _kex.getSupportedKeyExchanges()",
            "    supportedPublicKeys = []",
            "",
            "    # Add the supported EC keys, and change the name from ecdh* to ecdsa*",
            "    for eckey in supportedKeyExchanges:",
            "        if eckey.find(b\"ecdh\") != -1:",
            "            supportedPublicKeys += [eckey.replace(b\"ecdh\", b\"ecdsa\")]",
            "",
            "    supportedPublicKeys += [b\"ssh-rsa\", b\"ssh-dss\"]",
            "    if default_backend().ed25519_supported():",
            "        supportedPublicKeys.append(b\"ssh-ed25519\")",
            "",
            "    supportedCompressions = [b\"none\", b\"zlib\"]",
            "    supportedLanguages = ()",
            "    supportedVersions = (b\"1.99\", b\"2.0\")",
            "    isClient = False",
            "    gotVersion = False",
            "    buf = b\"\"",
            "    outgoingPacketSequence = 0",
            "    incomingPacketSequence = 0",
            "    outgoingCompression = None",
            "    incomingCompression = None",
            "    sessionID = None",
            "    service = None",
            "",
            "    # There is no key exchange activity in progress.",
            "    _KEY_EXCHANGE_NONE = \"_KEY_EXCHANGE_NONE\"",
            "",
            "    # Key exchange is in progress and we started it.",
            "    _KEY_EXCHANGE_REQUESTED = \"_KEY_EXCHANGE_REQUESTED\"",
            "",
            "    # Key exchange is in progress and both sides have sent KEXINIT messages.",
            "    _KEY_EXCHANGE_PROGRESSING = \"_KEY_EXCHANGE_PROGRESSING\"",
            "",
            "    # There is a fourth conceptual state not represented here: KEXINIT received",
            "    # but not sent.  Since we always send a KEXINIT as soon as we get it, we",
            "    # can't ever be in that state.",
            "",
            "    # The current key exchange state.",
            "    _keyExchangeState = _KEY_EXCHANGE_NONE",
            "    _blockedByKeyExchange = None",
            "",
            "    # Added to key exchange algorithms by a client to indicate support for",
            "    # extension negotiation.",
            "    _EXT_INFO_C = b\"ext-info-c\"",
            "",
            "    # Added to key exchange algorithms by a server to indicate support for",
            "    # extension negotiation.",
            "    _EXT_INFO_S = b\"ext-info-s\"",
            "",
            "    _peerSupportsExtensions = False",
            "    peerExtensions: Dict[bytes, bytes] = {}",
            "",
            "    def connectionLost(self, reason):",
            "        \"\"\"",
            "        When the underlying connection is closed, stop the running service (if",
            "        any), and log out the avatar (if any).",
            "",
            "        @type reason: L{twisted.python.failure.Failure}",
            "        @param reason: The cause of the connection being closed.",
            "        \"\"\"",
            "        if self.service:",
            "            self.service.serviceStopped()",
            "        if hasattr(self, \"avatar\"):",
            "            self.logoutFunction()",
            "        self._log.info(\"connection lost\")",
            "",
            "    def connectionMade(self):",
            "        \"\"\"",
            "        Called when the connection is made to the other side.  We sent our",
            "        version and the MSG_KEXINIT packet.",
            "        \"\"\"",
            "        self.transport.write(self.ourVersionString + b\"\\r\\n\")",
            "        self.currentEncryptions = SSHCiphers(b\"none\", b\"none\", b\"none\", b\"none\")",
            "        self.currentEncryptions.setKeys(b\"\", b\"\", b\"\", b\"\", b\"\", b\"\")",
            "        self.sendKexInit()",
            "",
            "    def sendKexInit(self):",
            "        \"\"\"",
            "        Send a I{KEXINIT} message to initiate key exchange or to respond to a",
            "        key exchange initiated by the peer.",
            "",
            "        @raise RuntimeError: If a key exchange has already been started and it",
            "            is not appropriate to send a I{KEXINIT} message at this time.",
            "",
            "        @return: L{None}",
            "        \"\"\"",
            "        if self._keyExchangeState != self._KEY_EXCHANGE_NONE:",
            "            raise RuntimeError(",
            "                \"Cannot send KEXINIT while key exchange state is %r\"",
            "                % (self._keyExchangeState,)",
            "            )",
            "",
            "        supportedKeyExchanges = list(self.supportedKeyExchanges)",
            "        # Advertise extension negotiation (RFC 8308, section 2.1).  At",
            "        # present, the Conch client processes the \"server-sig-algs\"",
            "        # extension (section 3.1), and the Conch server sends that but",
            "        # ignores any extensions sent by the client, so strictly speaking at",
            "        # the moment we only need to send this in the client case; however,",
            "        # there's nothing to forbid the server from sending it as well, and",
            "        # doing so makes things easier if it needs to process extensions",
            "        # sent by clients in future.",
            "        supportedKeyExchanges.append(",
            "            self._EXT_INFO_C if self.isClient else self._EXT_INFO_S",
            "        )",
            "",
            "        self.ourKexInitPayload = b\"\".join(",
            "            [",
            "                bytes((MSG_KEXINIT,)),",
            "                randbytes.secureRandom(16),",
            "                NS(b\",\".join(supportedKeyExchanges)),",
            "                NS(b\",\".join(self.supportedPublicKeys)),",
            "                NS(b\",\".join(self.supportedCiphers)),",
            "                NS(b\",\".join(self.supportedCiphers)),",
            "                NS(b\",\".join(self.supportedMACs)),",
            "                NS(b\",\".join(self.supportedMACs)),",
            "                NS(b\",\".join(self.supportedCompressions)),",
            "                NS(b\",\".join(self.supportedCompressions)),",
            "                NS(b\",\".join(self.supportedLanguages)),",
            "                NS(b\",\".join(self.supportedLanguages)),",
            "                b\"\\000\\000\\000\\000\\000\",",
            "            ]",
            "        )",
            "        self.sendPacket(MSG_KEXINIT, self.ourKexInitPayload[1:])",
            "        self._keyExchangeState = self._KEY_EXCHANGE_REQUESTED",
            "        self._blockedByKeyExchange = []",
            "",
            "    def _allowedKeyExchangeMessageType(self, messageType):",
            "        \"\"\"",
            "        Determine if the given message type may be sent while key exchange is",
            "        in progress.",
            "",
            "        @param messageType: The type of message",
            "        @type messageType: L{int}",
            "",
            "        @return: C{True} if the given type of message may be sent while key",
            "            exchange is in progress, C{False} if it may not.",
            "        @rtype: L{bool}",
            "",
            "        @see: U{http://tools.ietf.org/html/rfc4253#section-7.1}",
            "        \"\"\"",
            "        # Written somewhat peculularly to reflect the way the specification",
            "        # defines the allowed message types.",
            "        if 1 <= messageType <= 19:",
            "            return messageType not in (",
            "                MSG_SERVICE_REQUEST,",
            "                MSG_SERVICE_ACCEPT,",
            "                MSG_EXT_INFO,",
            "            )",
            "        if 20 <= messageType <= 29:",
            "            return messageType not in (MSG_KEXINIT,)",
            "        return 30 <= messageType <= 49",
            "",
            "    def sendPacket(self, messageType, payload):",
            "        \"\"\"",
            "        Sends a packet.  If it's been set up, compress the data, encrypt it,",
            "        and authenticate it before sending.  If key exchange is in progress and",
            "        the message is not part of key exchange, queue it to be sent later.",
            "",
            "        @param messageType: The type of the packet; generally one of the",
            "                            MSG_* values.",
            "        @type messageType: L{int}",
            "        @param payload: The payload for the message.",
            "        @type payload: L{str}",
            "        \"\"\"",
            "        if self._keyExchangeState != self._KEY_EXCHANGE_NONE:",
            "            if not self._allowedKeyExchangeMessageType(messageType):",
            "                self._blockedByKeyExchange.append((messageType, payload))",
            "                return",
            "",
            "        payload = bytes((messageType,)) + payload",
            "        if self.outgoingCompression:",
            "            payload = self.outgoingCompression.compress(",
            "                payload",
            "            ) + self.outgoingCompression.flush(2)",
            "        bs = self.currentEncryptions.encBlockSize",
            "        # 4 for the packet length and 1 for the padding length",
            "        totalSize = 5 + len(payload)",
            "        lenPad = bs - (totalSize % bs)",
            "        if lenPad < 4:",
            "            lenPad = lenPad + bs",
            "        packet = (",
            "            struct.pack(\"!LB\", totalSize + lenPad - 4, lenPad)",
            "            + payload",
            "            + randbytes.secureRandom(lenPad)",
            "        )",
            "        encPacket = self.currentEncryptions.encrypt(",
            "            packet",
            "        ) + self.currentEncryptions.makeMAC(self.outgoingPacketSequence, packet)",
            "        self.transport.write(encPacket)",
            "        self.outgoingPacketSequence += 1",
            "",
            "    def getPacket(self):",
            "        \"\"\"",
            "        Try to return a decrypted, authenticated, and decompressed packet",
            "        out of the buffer.  If there is not enough data, return None.",
            "",
            "        @rtype: L{str} or L{None}",
            "        @return: The decoded packet, if any.",
            "        \"\"\"",
            "        bs = self.currentEncryptions.decBlockSize",
            "        ms = self.currentEncryptions.verifyDigestSize",
            "        if len(self.buf) < bs:",
            "            # Not enough data for a block",
            "            return",
            "        if not hasattr(self, \"first\"):",
            "            first = self.currentEncryptions.decrypt(self.buf[:bs])",
            "        else:",
            "            first = self.first",
            "            del self.first",
            "        packetLen, paddingLen = struct.unpack(\"!LB\", first[:5])",
            "        if packetLen > 1048576:  # 1024 ** 2",
            "            self.sendDisconnect(",
            "                DISCONNECT_PROTOCOL_ERROR,",
            "                networkString(f\"bad packet length {packetLen}\"),",
            "            )",
            "            return",
            "        if len(self.buf) < packetLen + 4 + ms:",
            "            # Not enough data for a packet",
            "            self.first = first",
            "            return",
            "        if (packetLen + 4) % bs != 0:",
            "            self.sendDisconnect(",
            "                DISCONNECT_PROTOCOL_ERROR,",
            "                networkString(",
            "                    \"bad packet mod (%i%%%i == %i)\"",
            "                    % (packetLen + 4, bs, (packetLen + 4) % bs)",
            "                ),",
            "            )",
            "            return",
            "        encData, self.buf = self.buf[: 4 + packetLen], self.buf[4 + packetLen :]",
            "        packet = first + self.currentEncryptions.decrypt(encData[bs:])",
            "        if len(packet) != 4 + packetLen:",
            "            self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR, b\"bad decryption\")",
            "            return",
            "        if ms:",
            "            macData, self.buf = self.buf[:ms], self.buf[ms:]",
            "            if not self.currentEncryptions.verify(",
            "                self.incomingPacketSequence, packet, macData",
            "            ):",
            "                self.sendDisconnect(DISCONNECT_MAC_ERROR, b\"bad MAC\")",
            "                return",
            "        payload = packet[5:-paddingLen]",
            "        if self.incomingCompression:",
            "            try:",
            "                payload = self.incomingCompression.decompress(payload)",
            "            except Exception:",
            "                # Tolerate any errors in decompression",
            "                self._log.failure(\"Error decompressing payload\")",
            "                self.sendDisconnect(DISCONNECT_COMPRESSION_ERROR, b\"compression error\")",
            "                return",
            "        self.incomingPacketSequence += 1",
            "        return payload",
            "",
            "    def _unsupportedVersionReceived(self, remoteVersion):",
            "        \"\"\"",
            "        Called when an unsupported version of the ssh protocol is received from",
            "        the remote endpoint.",
            "",
            "        @param remoteVersion: remote ssh protocol version which is unsupported",
            "            by us.",
            "        @type remoteVersion: L{str}",
            "        \"\"\"",
            "        self.sendDisconnect(",
            "            DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED, b\"bad version \" + remoteVersion",
            "        )",
            "",
            "    def dataReceived(self, data):",
            "        \"\"\"",
            "        First, check for the version string (SSH-2.0-*).  After that has been",
            "        received, this method adds data to the buffer, and pulls out any",
            "        packets.",
            "",
            "        @type data: L{bytes}",
            "        @param data: The data that was received.",
            "        \"\"\"",
            "        self.buf = self.buf + data",
            "        if not self.gotVersion:",
            "",
            "            if len(self.buf) > 4096:",
            "                self.sendDisconnect(",
            "                    DISCONNECT_CONNECTION_LOST,",
            "                    b\"Peer version string longer than 4KB. \"",
            "                    b\"Preventing a denial of service attack.\",",
            "                )",
            "                return",
            "",
            "            if self.buf.find(b\"\\n\", self.buf.find(b\"SSH-\")) == -1:",
            "                return",
            "",
            "            # RFC 4253 section 4.2 ask for strict `\\r\\n` line ending.",
            "            # Here we are a bit more relaxed and accept implementations ending",
            "            # only in '\\n'.",
            "            # https://tools.ietf.org/html/rfc4253#section-4.2",
            "            lines = self.buf.split(b\"\\n\")",
            "            for p in lines:",
            "                if p.startswith(b\"SSH-\"):",
            "                    self.gotVersion = True",
            "                    # Since the line was split on '\\n' and most of the time",
            "                    # it uses '\\r\\n' we may get an extra '\\r'.",
            "                    self.otherVersionString = p.rstrip(b\"\\r\")",
            "                    remoteVersion = p.split(b\"-\")[1]",
            "                    if remoteVersion not in self.supportedVersions:",
            "                        self._unsupportedVersionReceived(remoteVersion)",
            "                        return",
            "                    i = lines.index(p)",
            "                    self.buf = b\"\\n\".join(lines[i + 1 :])",
            "        packet = self.getPacket()",
            "        while packet:",
            "            messageNum = ord(packet[0:1])",
            "            self.dispatchMessage(messageNum, packet[1:])",
            "            packet = self.getPacket()",
            "",
            "    def dispatchMessage(self, messageNum, payload):",
            "        \"\"\"",
            "        Send a received message to the appropriate method.",
            "",
            "        @type messageNum: L{int}",
            "        @param messageNum: The message number.",
            "",
            "        @type payload: L{bytes}",
            "        @param payload: The message payload.",
            "        \"\"\"",
            "        if messageNum < 50 and messageNum in messages:",
            "            messageType = messages[messageNum][4:]",
            "            f = getattr(self, f\"ssh_{messageType}\", None)",
            "            if f is not None:",
            "                f(payload)",
            "            else:",
            "                self._log.debug(",
            "                    \"couldn't handle {messageType}: {payload!r}\",",
            "                    messageType=messageType,",
            "                    payload=payload,",
            "                )",
            "                self.sendUnimplemented()",
            "        elif self.service:",
            "            self.service.packetReceived(messageNum, payload)",
            "        else:",
            "            self._log.debug(",
            "                \"couldn't handle {messageNum}: {payload!r}\",",
            "                messageNum=messageNum,",
            "                payload=payload,",
            "            )",
            "            self.sendUnimplemented()",
            "",
            "    def getPeer(self):",
            "        \"\"\"",
            "        Returns an L{SSHTransportAddress} corresponding to the other (peer)",
            "        side of this transport.",
            "",
            "        @return: L{SSHTransportAddress} for the peer",
            "        @rtype: L{SSHTransportAddress}",
            "        @since: 12.1",
            "        \"\"\"",
            "        return address.SSHTransportAddress(self.transport.getPeer())",
            "",
            "    def getHost(self):",
            "        \"\"\"",
            "        Returns an L{SSHTransportAddress} corresponding to the this side of",
            "        transport.",
            "",
            "        @return: L{SSHTransportAddress} for the peer",
            "        @rtype: L{SSHTransportAddress}",
            "        @since: 12.1",
            "        \"\"\"",
            "        return address.SSHTransportAddress(self.transport.getHost())",
            "",
            "    @property",
            "    def kexAlg(self):",
            "        \"\"\"",
            "        The key exchange algorithm name agreed between client and server.",
            "        \"\"\"",
            "        return self._kexAlg",
            "",
            "    @kexAlg.setter",
            "    def kexAlg(self, value):",
            "        \"\"\"",
            "        Set the key exchange algorithm name.",
            "        \"\"\"",
            "        self._kexAlg = value",
            "",
            "    # Client-initiated rekeying looks like this:",
            "    #",
            "    #  C> MSG_KEXINIT",
            "    #  S> MSG_KEXINIT",
            "    #  C> MSG_KEX_DH_GEX_REQUEST  or   MSG_KEXDH_INIT",
            "    #  S> MSG_KEX_DH_GEX_GROUP    or   MSG_KEXDH_REPLY",
            "    #  C> MSG_KEX_DH_GEX_INIT     or   --",
            "    #  S> MSG_KEX_DH_GEX_REPLY    or   --",
            "    #  C> MSG_NEWKEYS",
            "    #  S> MSG_NEWKEYS",
            "    #",
            "    # Server-initiated rekeying is the same, only the first two messages are",
            "    # switched.",
            "",
            "    def ssh_KEXINIT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEXINIT message.  Payload::",
            "            bytes[16] cookie",
            "            string keyExchangeAlgorithms",
            "            string keyAlgorithms",
            "            string incomingEncryptions",
            "            string outgoingEncryptions",
            "            string incomingAuthentications",
            "            string outgoingAuthentications",
            "            string incomingCompressions",
            "            string outgoingCompressions",
            "            string incomingLanguages",
            "            string outgoingLanguages",
            "            bool firstPacketFollows",
            "            unit32 0 (reserved)",
            "",
            "        Starts setting up the key exchange, keys, encryptions, and",
            "        authentications.  Extended by ssh_KEXINIT in SSHServerTransport and",
            "        SSHClientTransport.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: A L{tuple} of negotiated key exchange algorithms, key",
            "        algorithms, and unhandled data, or L{None} if something went wrong.",
            "        \"\"\"",
            "        self.otherKexInitPayload = bytes((MSG_KEXINIT,)) + packet",
            "        # This is useless to us:",
            "        # cookie = packet[: 16]",
            "        k = getNS(packet[16:], 10)",
            "        strings, rest = k[:-1], k[-1]",
            "        (",
            "            kexAlgs,",
            "            keyAlgs,",
            "            encCS,",
            "            encSC,",
            "            macCS,",
            "            macSC,",
            "            compCS,",
            "            compSC,",
            "            langCS,",
            "            langSC,",
            "        ) = (s.split(b\",\") for s in strings)",
            "        # These are the server directions",
            "        outs = [encSC, macSC, compSC]",
            "        ins = [encCS, macCS, compCS]",
            "        if self.isClient:",
            "            outs, ins = ins, outs  # Switch directions",
            "        server = (",
            "            self.supportedKeyExchanges,",
            "            self.supportedPublicKeys,",
            "            self.supportedCiphers,",
            "            self.supportedCiphers,",
            "            self.supportedMACs,",
            "            self.supportedMACs,",
            "            self.supportedCompressions,",
            "            self.supportedCompressions,",
            "        )",
            "        client = (kexAlgs, keyAlgs, outs[0], ins[0], outs[1], ins[1], outs[2], ins[2])",
            "        if self.isClient:",
            "            server, client = client, server",
            "        self.kexAlg = ffs(client[0], server[0])",
            "        self.keyAlg = ffs(client[1], server[1])",
            "        self.nextEncryptions = SSHCiphers(",
            "            ffs(client[2], server[2]),",
            "            ffs(client[3], server[3]),",
            "            ffs(client[4], server[4]),",
            "            ffs(client[5], server[5]),",
            "        )",
            "        self.outgoingCompressionType = ffs(client[6], server[6])",
            "        self.incomingCompressionType = ffs(client[7], server[7])",
            "        if (",
            "            None",
            "            in (",
            "                self.kexAlg,",
            "                self.keyAlg,",
            "                self.outgoingCompressionType,",
            "                self.incomingCompressionType,",
            "            )",
            "            # We MUST disconnect if an extension negotiation indication ends",
            "            # up being negotiated as a key exchange method (RFC 8308,",
            "            # section 2.2).",
            "            or self.kexAlg in (self._EXT_INFO_C, self._EXT_INFO_S)",
            "        ):",
            "            self.sendDisconnect(",
            "                DISCONNECT_KEY_EXCHANGE_FAILED, b\"couldn't match all kex parts\"",
            "            )",
            "            return",
            "        if None in self.nextEncryptions.__dict__.values():",
            "            self.sendDisconnect(",
            "                DISCONNECT_KEY_EXCHANGE_FAILED, b\"couldn't match all kex parts\"",
            "            )",
            "            return",
            "        self._peerSupportsExtensions = (",
            "            self._EXT_INFO_S if self.isClient else self._EXT_INFO_C",
            "        ) in kexAlgs",
            "        self._log.debug(",
            "            \"kex alg={kexAlg!r} key alg={keyAlg!r}\",",
            "            kexAlg=self.kexAlg,",
            "            keyAlg=self.keyAlg,",
            "        )",
            "        self._log.debug(",
            "            \"outgoing: {cip!r} {mac!r} {compression!r}\",",
            "            cip=self.nextEncryptions.outCipType,",
            "            mac=self.nextEncryptions.outMACType,",
            "            compression=self.outgoingCompressionType,",
            "        )",
            "        self._log.debug(",
            "            \"incoming: {cip!r} {mac!r} {compression!r}\",",
            "            cip=self.nextEncryptions.inCipType,",
            "            mac=self.nextEncryptions.inMACType,",
            "            compression=self.incomingCompressionType,",
            "        )",
            "",
            "        if self._keyExchangeState == self._KEY_EXCHANGE_REQUESTED:",
            "            self._keyExchangeState = self._KEY_EXCHANGE_PROGRESSING",
            "        else:",
            "            self.sendKexInit()",
            "",
            "        return kexAlgs, keyAlgs, rest  # For SSHServerTransport to use",
            "",
            "    def ssh_DISCONNECT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_DISCONNECT message.  Payload::",
            "            long code",
            "            string description",
            "",
            "        This means that the other side has disconnected.  Pass the message up",
            "        and disconnect ourselves.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        reasonCode = struct.unpack(\">L\", packet[:4])[0]",
            "        description, foo = getNS(packet[4:])",
            "        self.receiveError(reasonCode, description)",
            "        self.transport.loseConnection()",
            "",
            "    def ssh_IGNORE(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_IGNORE message.  No payload.",
            "        This means nothing; we simply return.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "",
            "    def ssh_UNIMPLEMENTED(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_UNIMPLEMENTED message.  Payload::",
            "            long packet",
            "",
            "        This means that the other side did not implement one of our packets.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        (seqnum,) = struct.unpack(\">L\", packet)",
            "        self.receiveUnimplemented(seqnum)",
            "",
            "    def ssh_DEBUG(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_DEBUG message.  Payload::",
            "            bool alwaysDisplay",
            "            string message",
            "            string language",
            "",
            "        This means the other side has passed along some debugging info.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        alwaysDisplay = bool(ord(packet[0:1]))",
            "        message, lang, foo = getNS(packet[1:], 2)",
            "        self.receiveDebug(alwaysDisplay, message, lang)",
            "",
            "    def ssh_EXT_INFO(self, packet):",
            "        \"\"\"",
            "        Called when we get a MSG_EXT_INFO message.  Payload::",
            "            uint32 nr-extensions",
            "            repeat the following 2 fields \"nr-extensions\" times:",
            "              string extension-name",
            "              string extension-value (binary)",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        (numExtensions,) = struct.unpack(\">L\", packet[:4])",
            "        packet = packet[4:]",
            "        extensions = {}",
            "        for _ in range(numExtensions):",
            "            extName, extValue, packet = getNS(packet, 2)",
            "            extensions[extName] = extValue",
            "        self.peerExtensions = extensions",
            "",
            "    def setService(self, service):",
            "        \"\"\"",
            "        Set our service to service and start it running.  If we were",
            "        running a service previously, stop it first.",
            "",
            "        @type service: C{SSHService}",
            "        @param service: The service to attach.",
            "        \"\"\"",
            "        self._log.debug(\"starting service {service!r}\", service=service.name)",
            "        if self.service:",
            "            self.service.serviceStopped()",
            "        self.service = service",
            "        service.transport = self",
            "        self.service.serviceStarted()",
            "",
            "    def sendDebug(self, message, alwaysDisplay=False, language=b\"\"):",
            "        \"\"\"",
            "        Send a debug message to the other side.",
            "",
            "        @param message: the message to send.",
            "        @type message: L{str}",
            "        @param alwaysDisplay: if True, tell the other side to always",
            "                              display this message.",
            "        @type alwaysDisplay: L{bool}",
            "        @param language: optionally, the language the message is in.",
            "        @type language: L{str}",
            "        \"\"\"",
            "        self.sendPacket(",
            "            MSG_DEBUG, (b\"\\1\" if alwaysDisplay else b\"\\0\") + NS(message) + NS(language)",
            "        )",
            "",
            "    def sendIgnore(self, message):",
            "        \"\"\"",
            "        Send a message that will be ignored by the other side.  This is",
            "        useful to fool attacks based on guessing packet sizes in the",
            "        encrypted stream.",
            "",
            "        @param message: data to send with the message",
            "        @type message: L{str}",
            "        \"\"\"",
            "        self.sendPacket(MSG_IGNORE, NS(message))",
            "",
            "    def sendUnimplemented(self):",
            "        \"\"\"",
            "        Send a message to the other side that the last packet was not",
            "        understood.",
            "        \"\"\"",
            "        seqnum = self.incomingPacketSequence",
            "        self.sendPacket(MSG_UNIMPLEMENTED, struct.pack(\"!L\", seqnum))",
            "",
            "    def sendDisconnect(self, reason, desc):",
            "        \"\"\"",
            "        Send a disconnect message to the other side and then disconnect.",
            "",
            "        @param reason: the reason for the disconnect.  Should be one of the",
            "                       DISCONNECT_* values.",
            "        @type reason: L{int}",
            "        @param desc: a descrption of the reason for the disconnection.",
            "        @type desc: L{str}",
            "        \"\"\"",
            "        self.sendPacket(MSG_DISCONNECT, struct.pack(\">L\", reason) + NS(desc) + NS(b\"\"))",
            "        self._log.info(",
            "            \"Disconnecting with error, code {code}\\nreason: {description}\",",
            "            code=reason,",
            "            description=desc,",
            "        )",
            "        self.transport.loseConnection()",
            "",
            "    def sendExtInfo(self, extensions):",
            "        \"\"\"",
            "        Send an RFC 8308 extension advertisement to the remote peer.",
            "",
            "        Nothing is sent if the peer doesn't support negotiations.",
            "        @type extensions: L{list} of (L{bytes}, L{bytes})",
            "        @param extensions: a list of (extension-name, extension-value) pairs.",
            "        \"\"\"",
            "        if self._peerSupportsExtensions:",
            "            payload = b\"\".join(",
            "                [struct.pack(\">L\", len(extensions))]",
            "                + [NS(name) + NS(value) for name, value in extensions]",
            "            )",
            "            self.sendPacket(MSG_EXT_INFO, payload)",
            "",
            "    def _startEphemeralDH(self):",
            "        \"\"\"",
            "        Prepares for a Diffie-Hellman key agreement exchange.",
            "",
            "        Creates an ephemeral keypair in the group defined by (self.g,",
            "        self.p) and stores it.",
            "        \"\"\"",
            "",
            "        numbers = dh.DHParameterNumbers(self.p, self.g)",
            "        parameters = numbers.parameters(default_backend())",
            "        self.dhSecretKey = parameters.generate_private_key()",
            "        y = self.dhSecretKey.public_key().public_numbers().y",
            "        self.dhSecretKeyPublicMP = MP(y)",
            "",
            "    def _finishEphemeralDH(self, remoteDHpublicKey):",
            "        \"\"\"",
            "        Completes the Diffie-Hellman key agreement started by",
            "        _startEphemeralDH, and forgets the ephemeral secret key.",
            "",
            "        @type remoteDHpublicKey: L{int}",
            "        @rtype: L{bytes}",
            "        @return: The new shared secret, in SSH C{mpint} format.",
            "",
            "        \"\"\"",
            "",
            "        remoteKey = dh.DHPublicNumbers(",
            "            remoteDHpublicKey, dh.DHParameterNumbers(self.p, self.g)",
            "        ).public_key(default_backend())",
            "        secret = self.dhSecretKey.exchange(remoteKey)",
            "        del self.dhSecretKey",
            "",
            "        # The result of a Diffie-Hellman exchange is an integer, but",
            "        # the Cryptography module returns it as bytes in a form that",
            "        # is only vaguely documented. We fix it up to match the SSH",
            "        # MP-integer format as described in RFC4251.",
            "        secret = secret.lstrip(b\"\\x00\")",
            "        ch = ord(secret[0:1])",
            "        if ch & 0x80:  # High bit set?",
            "            # Make room for the sign bit",
            "            prefix = struct.pack(\">L\", len(secret) + 1) + b\"\\x00\"",
            "        else:",
            "            prefix = struct.pack(\">L\", len(secret))",
            "        return prefix + secret",
            "",
            "    def _getKey(self, c, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        Get one of the keys for authentication/encryption.",
            "",
            "        @type c: L{bytes}",
            "        @param c: The letter identifying which key this is.",
            "",
            "        @type sharedSecret: L{bytes}",
            "        @param sharedSecret: The shared secret K.",
            "",
            "        @type exchangeHash: L{bytes}",
            "        @param exchangeHash: The hash H from key exchange.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The derived key.",
            "        \"\"\"",
            "        hashProcessor = _kex.getHashProcessor(self.kexAlg)",
            "        k1 = hashProcessor(sharedSecret + exchangeHash + c + self.sessionID)",
            "        k1 = k1.digest()",
            "        k2 = hashProcessor(sharedSecret + exchangeHash + k1).digest()",
            "        k3 = hashProcessor(sharedSecret + exchangeHash + k1 + k2).digest()",
            "        k4 = hashProcessor(sharedSecret + exchangeHash + k1 + k2 + k3).digest()",
            "        return k1 + k2 + k3 + k4",
            "",
            "    def _keySetup(self, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        Set up the keys for the connection and sends MSG_NEWKEYS when",
            "        finished,",
            "",
            "        @param sharedSecret: a secret string agreed upon using a Diffie-",
            "                             Hellman exchange, so it is only shared between",
            "                             the server and the client.",
            "        @type sharedSecret: L{str}",
            "        @param exchangeHash: A hash of various data known by both sides.",
            "        @type exchangeHash: L{str}",
            "        \"\"\"",
            "        if not self.sessionID:",
            "            self.sessionID = exchangeHash",
            "        initIVCS = self._getKey(b\"A\", sharedSecret, exchangeHash)",
            "        initIVSC = self._getKey(b\"B\", sharedSecret, exchangeHash)",
            "        encKeyCS = self._getKey(b\"C\", sharedSecret, exchangeHash)",
            "        encKeySC = self._getKey(b\"D\", sharedSecret, exchangeHash)",
            "        integKeyCS = self._getKey(b\"E\", sharedSecret, exchangeHash)",
            "        integKeySC = self._getKey(b\"F\", sharedSecret, exchangeHash)",
            "        outs = [initIVSC, encKeySC, integKeySC]",
            "        ins = [initIVCS, encKeyCS, integKeyCS]",
            "        if self.isClient:  # Reverse for the client",
            "            outs, ins = ins, outs",
            "        self.nextEncryptions.setKeys(outs[0], outs[1], ins[0], ins[1], outs[2], ins[2])",
            "        self.sendPacket(MSG_NEWKEYS, b\"\")",
            "",
            "    def _newKeys(self):",
            "        \"\"\"",
            "        Called back by a subclass once a I{MSG_NEWKEYS} message has been",
            "        received.  This indicates key exchange has completed and new encryption",
            "        and compression parameters should be adopted.  Any messages which were",
            "        queued during key exchange will also be flushed.",
            "        \"\"\"",
            "        self._log.debug(\"NEW KEYS\")",
            "        self.currentEncryptions = self.nextEncryptions",
            "        if self.outgoingCompressionType == b\"zlib\":",
            "            self.outgoingCompression = zlib.compressobj(6)",
            "        if self.incomingCompressionType == b\"zlib\":",
            "            self.incomingCompression = zlib.decompressobj()",
            "",
            "        self._keyExchangeState = self._KEY_EXCHANGE_NONE",
            "        messages = self._blockedByKeyExchange",
            "        self._blockedByKeyExchange = None",
            "        for (messageType, payload) in messages:",
            "            self.sendPacket(messageType, payload)",
            "",
            "    def isEncrypted(self, direction=\"out\"):",
            "        \"\"\"",
            "        Check if the connection is encrypted in the given direction.",
            "",
            "        @type direction: L{str}",
            "        @param direction: The direction: one of 'out', 'in', or 'both'.",
            "",
            "        @rtype: L{bool}",
            "        @return: C{True} if it is encrypted.",
            "        \"\"\"",
            "        if direction == \"out\":",
            "            return self.currentEncryptions.outCipType != b\"none\"",
            "        elif direction == \"in\":",
            "            return self.currentEncryptions.inCipType != b\"none\"",
            "        elif direction == \"both\":",
            "            return self.isEncrypted(\"in\") and self.isEncrypted(\"out\")",
            "        else:",
            "            raise TypeError('direction must be \"out\", \"in\", or \"both\"')",
            "",
            "    def isVerified(self, direction=\"out\"):",
            "        \"\"\"",
            "        Check if the connection is verified/authentication in the given direction.",
            "",
            "        @type direction: L{str}",
            "        @param direction: The direction: one of 'out', 'in', or 'both'.",
            "",
            "        @rtype: L{bool}",
            "        @return: C{True} if it is verified.",
            "        \"\"\"",
            "        if direction == \"out\":",
            "            return self.currentEncryptions.outMACType != b\"none\"",
            "        elif direction == \"in\":",
            "            return self.currentEncryptions.inMACType != b\"none\"",
            "        elif direction == \"both\":",
            "            return self.isVerified(\"in\") and self.isVerified(\"out\")",
            "        else:",
            "            raise TypeError('direction must be \"out\", \"in\", or \"both\"')",
            "",
            "    def loseConnection(self):",
            "        \"\"\"",
            "        Lose the connection to the other side, sending a",
            "        DISCONNECT_CONNECTION_LOST message.",
            "        \"\"\"",
            "        self.sendDisconnect(DISCONNECT_CONNECTION_LOST, b\"user closed connection\")",
            "",
            "    # Client methods",
            "",
            "    def receiveError(self, reasonCode, description):",
            "        \"\"\"",
            "        Called when we receive a disconnect error message from the other",
            "        side.",
            "",
            "        @param reasonCode: the reason for the disconnect, one of the",
            "                           DISCONNECT_ values.",
            "        @type reasonCode: L{int}",
            "        @param description: a human-readable description of the",
            "                            disconnection.",
            "        @type description: L{str}",
            "        \"\"\"",
            "        self._log.error(",
            "            \"Got remote error, code {code}\\nreason: {description}\",",
            "            code=reasonCode,",
            "            description=description,",
            "        )",
            "",
            "    def receiveUnimplemented(self, seqnum):",
            "        \"\"\"",
            "        Called when we receive an unimplemented packet message from the other",
            "        side.",
            "",
            "        @param seqnum: the sequence number that was not understood.",
            "        @type seqnum: L{int}",
            "        \"\"\"",
            "        self._log.warn(\"other side unimplemented packet #{seqnum}\", seqnum=seqnum)",
            "",
            "    def receiveDebug(self, alwaysDisplay, message, lang):",
            "        \"\"\"",
            "        Called when we receive a debug message from the other side.",
            "",
            "        @param alwaysDisplay: if True, this message should always be",
            "                              displayed.",
            "        @type alwaysDisplay: L{bool}",
            "        @param message: the debug message",
            "        @type message: L{str}",
            "        @param lang: optionally the language the message is in.",
            "        @type lang: L{str}",
            "        \"\"\"",
            "        if alwaysDisplay:",
            "            self._log.debug(\"Remote Debug Message: {message}\", message=message)",
            "",
            "    def _generateECPrivateKey(self):",
            "        \"\"\"",
            "        Generate an private key for ECDH key exchange.",
            "",
            "        @rtype: The appropriate private key type matching C{self.kexAlg}:",
            "            L{ec.EllipticCurvePrivateKey} for C{ecdh-sha2-nistp*}, or",
            "            L{x25519.X25519PrivateKey} for C{curve25519-sha256}.",
            "        @return: The generated private key.",
            "        \"\"\"",
            "        if self.kexAlg.startswith(b\"ecdh-sha2-nistp\"):",
            "            try:",
            "                curve = keys._curveTable[b\"ecdsa\" + self.kexAlg[4:]]",
            "            except KeyError:",
            "                raise UnsupportedAlgorithm(\"unused-key\")",
            "",
            "            return ec.generate_private_key(curve, default_backend())",
            "        elif self.kexAlg in (b\"curve25519-sha256\", b\"curve25519-sha256@libssh.org\"):",
            "            return x25519.X25519PrivateKey.generate()",
            "        else:",
            "            raise UnsupportedAlgorithm(",
            "                \"Cannot generate elliptic curve private key for {!r}\".format(",
            "                    self.kexAlg",
            "                )",
            "            )",
            "",
            "    def _encodeECPublicKey(self, ecPub):",
            "        \"\"\"",
            "        Encode an elliptic curve public key to bytes.",
            "",
            "        @type ecPub: The appropriate public key type matching",
            "            C{self.kexAlg}: L{ec.EllipticCurvePublicKey} for",
            "            C{ecdh-sha2-nistp*}, or L{x25519.X25519PublicKey} for",
            "            C{curve25519-sha256}.",
            "        @param ecPub: The public key to encode.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The encoded public key.",
            "        \"\"\"",
            "        if self.kexAlg.startswith(b\"ecdh-sha2-nistp\"):",
            "            return ecPub.public_bytes(",
            "                serialization.Encoding.X962,",
            "                serialization.PublicFormat.UncompressedPoint,",
            "            )",
            "        elif self.kexAlg in (b\"curve25519-sha256\", b\"curve25519-sha256@libssh.org\"):",
            "            return ecPub.public_bytes(",
            "                serialization.Encoding.Raw, serialization.PublicFormat.Raw",
            "            )",
            "        else:",
            "            raise UnsupportedAlgorithm(",
            "                f\"Cannot encode elliptic curve public key for {self.kexAlg!r}\"",
            "            )",
            "",
            "    def _generateECSharedSecret(self, ecPriv, theirECPubBytes):",
            "        \"\"\"",
            "        Generate a shared secret for ECDH key exchange.",
            "",
            "        @type ecPriv: The appropriate private key type matching",
            "            C{self.kexAlg}: L{ec.EllipticCurvePrivateKey} for",
            "            C{ecdh-sha2-nistp*}, or L{x25519.X25519PrivateKey} for",
            "            C{curve25519-sha256}.",
            "        @param ecPriv: Our private key.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The generated shared secret, as an SSH multiple-precision",
            "            integer.",
            "        \"\"\"",
            "        if self.kexAlg.startswith(b\"ecdh-sha2-nistp\"):",
            "            try:",
            "                curve = keys._curveTable[b\"ecdsa\" + self.kexAlg[4:]]",
            "            except KeyError:",
            "                raise UnsupportedAlgorithm(\"unused-key\")",
            "",
            "            theirECPub = ec.EllipticCurvePublicKey.from_encoded_point(",
            "                curve, theirECPubBytes",
            "            )",
            "            sharedSecret = ecPriv.exchange(ec.ECDH(), theirECPub)",
            "        elif self.kexAlg in (b\"curve25519-sha256\", b\"curve25519-sha256@libssh.org\"):",
            "            theirECPub = x25519.X25519PublicKey.from_public_bytes(theirECPubBytes)",
            "            sharedSecret = ecPriv.exchange(theirECPub)",
            "        else:",
            "            raise UnsupportedAlgorithm(",
            "                \"Cannot generate elliptic curve shared secret for {!r}\".format(",
            "                    self.kexAlg",
            "                )",
            "            )",
            "",
            "        return _mpFromBytes(sharedSecret)",
            "",
            "",
            "class SSHServerTransport(SSHTransportBase):",
            "    \"\"\"",
            "    SSHServerTransport implements the server side of the SSH protocol.",
            "",
            "    @ivar isClient: since we are never the client, this is always False.",
            "",
            "    @ivar ignoreNextPacket: if True, ignore the next key exchange packet.  This",
            "        is set when the client sends a guessed key exchange packet but with",
            "        an incorrect guess.",
            "",
            "    @ivar dhGexRequest: the KEX_DH_GEX_REQUEST(_OLD) that the client sent.",
            "        The key generation needs this to be stored.",
            "",
            "    @ivar g: the Diffie-Hellman group generator.",
            "",
            "    @ivar p: the Diffie-Hellman group prime.",
            "    \"\"\"",
            "",
            "    isClient = False",
            "    ignoreNextPacket = 0",
            "",
            "    def ssh_KEXINIT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEXINIT message.  For a description",
            "        of the packet, see SSHTransportBase.ssh_KEXINIT().  Additionally,",
            "        this method checks if a guessed key exchange packet was sent.  If",
            "        it was sent, and it guessed incorrectly, the next key exchange",
            "        packet MUST be ignored.",
            "        \"\"\"",
            "        retval = SSHTransportBase.ssh_KEXINIT(self, packet)",
            "        if not retval:  # Disconnected",
            "            return",
            "        else:",
            "            kexAlgs, keyAlgs, rest = retval",
            "        if ord(rest[0:1]):  # Flag first_kex_packet_follows?",
            "            if (",
            "                kexAlgs[0] != self.supportedKeyExchanges[0]",
            "                or keyAlgs[0] != self.supportedPublicKeys[0]",
            "            ):",
            "                self.ignoreNextPacket = True  # Guess was wrong",
            "",
            "    def _ssh_KEX_ECDH_INIT(self, packet):",
            "        \"\"\"",
            "        Called from L{ssh_KEX_DH_GEX_REQUEST_OLD} to handle",
            "        elliptic curve key exchanges.",
            "",
            "        Payload::",
            "",
            "            string client Elliptic Curve Diffie-Hellman public key",
            "",
            "        Just like L{_ssh_KEXDH_INIT} this message type is also not dispatched",
            "        directly. Extra check to determine if this is really KEX_ECDH_INIT",
            "        is required.",
            "",
            "        First we load the host's public/private keys.",
            "        Then we generate the ECDH public/private keypair for the given curve.",
            "        With that we generate the shared secret key.",
            "        Then we compute the hash to sign and send back to the client",
            "        Along with the server's public key and the ECDH public key.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: None.",
            "        \"\"\"",
            "        # Get the raw client public key.",
            "        pktPub, packet = getNS(packet)",
            "",
            "        # Get the host's public and private keys",
            "        pubHostKey = self.factory.publicKeys[self.keyAlg]",
            "        privHostKey = self.factory.privateKeys[self.keyAlg]",
            "",
            "        # Generate the private key",
            "        ecPriv = self._generateECPrivateKey()",
            "",
            "        # Get the public key",
            "        self.ecPub = ecPriv.public_key()",
            "        encPub = self._encodeECPublicKey(self.ecPub)",
            "",
            "        # Generate the shared secret",
            "        sharedSecret = self._generateECSharedSecret(ecPriv, pktPub)",
            "",
            "        # Finish update and digest",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(pubHostKey.blob()))",
            "        h.update(NS(pktPub))",
            "        h.update(NS(encPub))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        self.sendPacket(",
            "            MSG_KEXDH_REPLY,",
            "            NS(pubHostKey.blob()) + NS(encPub) + NS(privHostKey.sign(exchangeHash)),",
            "        )",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def _ssh_KEXDH_INIT(self, packet):",
            "        \"\"\"",
            "        Called to handle the beginning of a non-group key exchange.",
            "",
            "        Unlike other message types, this is not dispatched automatically.  It",
            "        is called from C{ssh_KEX_DH_GEX_REQUEST_OLD} because an extra check is",
            "        required to determine if this is really a KEXDH_INIT message or if it",
            "        is a KEX_DH_GEX_REQUEST_OLD message.",
            "",
            "        The KEXDH_INIT payload::",
            "",
            "                integer e (the client's Diffie-Hellman public key)",
            "",
            "        We send the KEXDH_REPLY with our host key and signature.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        clientDHpublicKey, foo = getMP(packet)",
            "        self.g, self.p = _kex.getDHGeneratorAndPrime(self.kexAlg)",
            "        self._startEphemeralDH()",
            "        sharedSecret = self._finishEphemeralDH(clientDHpublicKey)",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(self.factory.publicKeys[self.keyAlg].blob()))",
            "        h.update(MP(clientDHpublicKey))",
            "        h.update(self.dhSecretKeyPublicMP)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        self.sendPacket(",
            "            MSG_KEXDH_REPLY,",
            "            NS(self.factory.publicKeys[self.keyAlg].blob())",
            "            + self.dhSecretKeyPublicMP",
            "            + NS(self.factory.privateKeys[self.keyAlg].sign(exchangeHash)),",
            "        )",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def ssh_KEX_DH_GEX_REQUEST_OLD(self, packet):",
            "        \"\"\"",
            "        This represents different key exchange methods that share the same",
            "        integer value.  If the message is determined to be a KEXDH_INIT,",
            "        L{_ssh_KEXDH_INIT} is called to handle it. If it is a KEX_ECDH_INIT,",
            "        L{_ssh_KEX_ECDH_INIT} is called.",
            "        Otherwise, for KEX_DH_GEX_REQUEST_OLD payload::",
            "",
            "                integer ideal (ideal size for the Diffie-Hellman prime)",
            "",
            "            We send the KEX_DH_GEX_GROUP message with the group that is",
            "            closest in size to ideal.",
            "",
            "        If we were told to ignore the next key exchange packet by ssh_KEXINIT,",
            "        drop it on the floor and return.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if self.ignoreNextPacket:",
            "            self.ignoreNextPacket = 0",
            "            return",
            "",
            "        # KEXDH_INIT, KEX_ECDH_INIT, and KEX_DH_GEX_REQUEST_OLD",
            "        # have the same value, so use another cue",
            "        # to decide what kind of message the peer sent us.",
            "        if _kex.isFixedGroup(self.kexAlg):",
            "            return self._ssh_KEXDH_INIT(packet)",
            "        elif _kex.isEllipticCurve(self.kexAlg):",
            "            return self._ssh_KEX_ECDH_INIT(packet)",
            "        else:",
            "            self.dhGexRequest = packet",
            "            ideal = struct.unpack(\">L\", packet)[0]",
            "            self.g, self.p = self.factory.getDHPrime(ideal)",
            "            self._startEphemeralDH()",
            "            self.sendPacket(MSG_KEX_DH_GEX_GROUP, MP(self.p) + MP(self.g))",
            "",
            "    def ssh_KEX_DH_GEX_REQUEST(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEX_DH_GEX_REQUEST message.  Payload::",
            "            integer minimum",
            "            integer ideal",
            "            integer maximum",
            "",
            "        The client is asking for a Diffie-Hellman group between minimum and",
            "        maximum size, and close to ideal if possible.  We reply with a",
            "        MSG_KEX_DH_GEX_GROUP message.",
            "",
            "        If we were told to ignore the next key exchange packet by ssh_KEXINIT,",
            "        drop it on the floor and return.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if self.ignoreNextPacket:",
            "            self.ignoreNextPacket = 0",
            "            return",
            "        self.dhGexRequest = packet",
            "        min, ideal, max = struct.unpack(\">3L\", packet)",
            "        self.g, self.p = self.factory.getDHPrime(ideal)",
            "        self._startEphemeralDH()",
            "        self.sendPacket(MSG_KEX_DH_GEX_GROUP, MP(self.p) + MP(self.g))",
            "",
            "    def ssh_KEX_DH_GEX_INIT(self, packet):",
            "        \"\"\"",
            "        Called when we get a MSG_KEX_DH_GEX_INIT message.  Payload::",
            "            integer e (client DH public key)",
            "",
            "        We send the MSG_KEX_DH_GEX_REPLY message with our host key and",
            "        signature.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        clientDHpublicKey, foo = getMP(packet)",
            "        # TODO: we should also look at the value they send to us and reject",
            "        # insecure values of f (if g==2 and f has a single '1' bit while the",
            "        # rest are '0's, then they must have used a small y also).",
            "",
            "        # TODO: This could be computed when self.p is set up",
            "        #  or do as openssh does and scan f for a single '1' bit instead",
            "",
            "        sharedSecret = self._finishEphemeralDH(clientDHpublicKey)",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(self.factory.publicKeys[self.keyAlg].blob()))",
            "        h.update(self.dhGexRequest)",
            "        h.update(MP(self.p))",
            "        h.update(MP(self.g))",
            "        h.update(MP(clientDHpublicKey))",
            "        h.update(self.dhSecretKeyPublicMP)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        self.sendPacket(",
            "            MSG_KEX_DH_GEX_REPLY,",
            "            NS(self.factory.publicKeys[self.keyAlg].blob())",
            "            + self.dhSecretKeyPublicMP",
            "            + NS(self.factory.privateKeys[self.keyAlg].sign(exchangeHash)),",
            "        )",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def _keySetup(self, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        See SSHTransportBase._keySetup().",
            "        \"\"\"",
            "        firstKey = self.sessionID is None",
            "        SSHTransportBase._keySetup(self, sharedSecret, exchangeHash)",
            "        # RFC 8308 section 2.4 says that the server MAY send EXT_INFO at",
            "        # zero, one, or both of the following opportunities: the next packet",
            "        # following the server's first MSG_NEWKEYS, or immediately preceding",
            "        # the server's MSG_USERAUTH_SUCCESS.  We have no need for the",
            "        # latter, so make sure we only send it in the former case.",
            "        if firstKey:",
            "            self.sendExtInfo(",
            "                [(b\"server-sig-algs\", b\",\".join(self.supportedPublicKeys))]",
            "            )",
            "",
            "    def ssh_NEWKEYS(self, packet):",
            "        \"\"\"",
            "        Called when we get a MSG_NEWKEYS message.  No payload.",
            "        When we get this, the keys have been set on both sides, and we",
            "        start using them to encrypt and authenticate the connection.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if packet != b\"\":",
            "            self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR, b\"NEWKEYS takes no data\")",
            "            return",
            "        self._newKeys()",
            "",
            "    def ssh_SERVICE_REQUEST(self, packet):",
            "        \"\"\"",
            "        Called when we get a MSG_SERVICE_REQUEST message.  Payload::",
            "            string serviceName",
            "",
            "        The client has requested a service.  If we can start the service,",
            "        start it; otherwise, disconnect with",
            "        DISCONNECT_SERVICE_NOT_AVAILABLE.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        service, rest = getNS(packet)",
            "        cls = self.factory.getService(self, service)",
            "        if not cls:",
            "            self.sendDisconnect(",
            "                DISCONNECT_SERVICE_NOT_AVAILABLE, b\"don't have service \" + service",
            "            )",
            "            return",
            "        else:",
            "            self.sendPacket(MSG_SERVICE_ACCEPT, NS(service))",
            "            self.setService(cls())",
            "",
            "",
            "class SSHClientTransport(SSHTransportBase):",
            "    \"\"\"",
            "    SSHClientTransport implements the client side of the SSH protocol.",
            "",
            "    @ivar isClient: since we are always the client, this is always True.",
            "",
            "    @ivar _gotNewKeys: if we receive a MSG_NEWKEYS message before we are",
            "        ready to transition to the new keys, this is set to True so we",
            "        can transition when the keys are ready locally.",
            "",
            "    @ivar x: our Diffie-Hellman private key.",
            "",
            "    @ivar e: our Diffie-Hellman public key.",
            "",
            "    @ivar g: the Diffie-Hellman group generator.",
            "",
            "    @ivar p: the Diffie-Hellman group prime",
            "",
            "    @ivar instance: the SSHService object we are requesting.",
            "",
            "    @ivar _dhMinimalGroupSize: Minimal acceptable group size advertised by the",
            "        client in MSG_KEX_DH_GEX_REQUEST.",
            "    @type _dhMinimalGroupSize: int",
            "",
            "    @ivar _dhMaximalGroupSize: Maximal acceptable group size advertised by the",
            "        client in MSG_KEX_DH_GEX_REQUEST.",
            "    @type _dhMaximalGroupSize: int",
            "",
            "    @ivar _dhPreferredGroupSize: Preferred group size advertised by the client",
            "        in MSG_KEX_DH_GEX_REQUEST.",
            "    @type _dhPreferredGroupSize: int",
            "    \"\"\"",
            "",
            "    isClient = True",
            "",
            "    # Recommended minimal and maximal values from RFC 4419, 3.",
            "    _dhMinimalGroupSize = 1024",
            "    _dhMaximalGroupSize = 8192",
            "    # FIXME: https://twistedmatrix.com/trac/ticket/8103",
            "    # This may need to be more dynamic; compare kexgex_client in",
            "    # OpenSSH.",
            "    _dhPreferredGroupSize = 2048",
            "",
            "    def connectionMade(self):",
            "        \"\"\"",
            "        Called when the connection is started with the server.  Just sets",
            "        up a private instance variable.",
            "        \"\"\"",
            "        SSHTransportBase.connectionMade(self)",
            "        self._gotNewKeys = 0",
            "",
            "    def ssh_KEXINIT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEXINIT message.  For a description",
            "        of the packet, see SSHTransportBase.ssh_KEXINIT().  Additionally,",
            "        this method sends the first key exchange packet.",
            "",
            "        If the agreed-upon exchange is ECDH, generate a key pair for the",
            "        corresponding curve and send the public key.",
            "",
            "        If the agreed-upon exchange has a fixed prime/generator group,",
            "        generate a public key and send it in a MSG_KEXDH_INIT message.",
            "        Otherwise, ask for a 2048 bit group with a MSG_KEX_DH_GEX_REQUEST",
            "        message.",
            "        \"\"\"",
            "        if SSHTransportBase.ssh_KEXINIT(self, packet) is None:",
            "            # Connection was disconnected while doing base processing.",
            "            # Maybe no common protocols were agreed.",
            "            return",
            "        # Are we using ECDH?",
            "        if _kex.isEllipticCurve(self.kexAlg):",
            "            # Generate the keys",
            "            self.ecPriv = self._generateECPrivateKey()",
            "            self.ecPub = self.ecPriv.public_key()",
            "",
            "            # DH_GEX_REQUEST_OLD is the same number we need.",
            "            self.sendPacket(",
            "                MSG_KEX_DH_GEX_REQUEST_OLD, NS(self._encodeECPublicKey(self.ecPub))",
            "            )",
            "        elif _kex.isFixedGroup(self.kexAlg):",
            "            # We agreed on a fixed group key exchange algorithm.",
            "            self.g, self.p = _kex.getDHGeneratorAndPrime(self.kexAlg)",
            "            self._startEphemeralDH()",
            "            self.sendPacket(MSG_KEXDH_INIT, self.dhSecretKeyPublicMP)",
            "        else:",
            "            # We agreed on a dynamic group. Tell the server what range of",
            "            # group sizes we accept, and what size we prefer; the server",
            "            # will then select a group.",
            "            self.sendPacket(",
            "                MSG_KEX_DH_GEX_REQUEST,",
            "                struct.pack(",
            "                    \"!LLL\",",
            "                    self._dhMinimalGroupSize,",
            "                    self._dhPreferredGroupSize,",
            "                    self._dhMaximalGroupSize,",
            "                ),",
            "            )",
            "",
            "    def _ssh_KEX_ECDH_REPLY(self, packet):",
            "        \"\"\"",
            "        Called to handle a reply to a ECDH exchange message(KEX_ECDH_INIT).",
            "",
            "        Like the handler for I{KEXDH_INIT}, this message type has an",
            "        overlapping value.  This method is called from C{ssh_KEX_DH_GEX_GROUP}",
            "        if that method detects a non-group key exchange is in progress.",
            "",
            "        Payload::",
            "",
            "            string serverHostKey",
            "            string server Elliptic Curve Diffie-Hellman public key",
            "            string signature",
            "",
            "        We verify the host key and continue if it passes verificiation.",
            "        Otherwise raise an exception and return.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: A deferred firing when key exchange is complete.",
            "        \"\"\"",
            "",
            "        def _continue_KEX_ECDH_REPLY(ignored, hostKey, pubKey, signature):",
            "            # Save off the host public key.",
            "            theirECHost = hostKey",
            "",
            "            sharedSecret = self._generateECSharedSecret(self.ecPriv, pubKey)",
            "",
            "            h = _kex.getHashProcessor(self.kexAlg)()",
            "            h.update(NS(self.ourVersionString))",
            "            h.update(NS(self.otherVersionString))",
            "            h.update(NS(self.ourKexInitPayload))",
            "            h.update(NS(self.otherKexInitPayload))",
            "            h.update(NS(theirECHost))",
            "            h.update(NS(self._encodeECPublicKey(self.ecPub)))",
            "            h.update(NS(pubKey))",
            "            h.update(sharedSecret)",
            "",
            "            exchangeHash = h.digest()",
            "",
            "            if not keys.Key.fromString(theirECHost).verify(signature, exchangeHash):",
            "                self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED, b\"bad signature\")",
            "            else:",
            "                self._keySetup(sharedSecret, exchangeHash)",
            "",
            "        # Get the host public key,",
            "        # the raw ECDH public key bytes and the signature",
            "        hostKey, pubKey, signature, packet = getNS(packet, 3)",
            "",
            "        # Easier to comment this out for now than to update all of the tests.",
            "        # fingerprint = nativeString(base64.b64encode(",
            "        #        sha256(hostKey).digest()))",
            "",
            "        fingerprint = b\":\".join(",
            "            [binascii.hexlify(ch) for ch in iterbytes(md5(hostKey).digest())]",
            "        )",
            "        d = self.verifyHostKey(hostKey, fingerprint)",
            "        d.addCallback(_continue_KEX_ECDH_REPLY, hostKey, pubKey, signature)",
            "        d.addErrback(",
            "            lambda unused: self.sendDisconnect(",
            "                DISCONNECT_HOST_KEY_NOT_VERIFIABLE, b\"bad host key\"",
            "            )",
            "        )",
            "        return d",
            "",
            "    def _ssh_KEXDH_REPLY(self, packet):",
            "        \"\"\"",
            "        Called to handle a reply to a non-group key exchange message",
            "        (KEXDH_INIT).",
            "",
            "        Like the handler for I{KEXDH_INIT}, this message type has an",
            "        overlapping value.  This method is called from C{ssh_KEX_DH_GEX_GROUP}",
            "        if that method detects a non-group key exchange is in progress.",
            "",
            "        Payload::",
            "",
            "            string serverHostKey",
            "            integer f (server Diffie-Hellman public key)",
            "            string signature",
            "",
            "        We verify the host key by calling verifyHostKey, then continue in",
            "        _continueKEXDH_REPLY.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: A deferred firing when key exchange is complete.",
            "        \"\"\"",
            "        pubKey, packet = getNS(packet)",
            "        f, packet = getMP(packet)",
            "        signature, packet = getNS(packet)",
            "        fingerprint = b\":\".join(",
            "            [binascii.hexlify(ch) for ch in iterbytes(md5(pubKey).digest())]",
            "        )",
            "        d = self.verifyHostKey(pubKey, fingerprint)",
            "        d.addCallback(self._continueKEXDH_REPLY, pubKey, f, signature)",
            "        d.addErrback(",
            "            lambda unused: self.sendDisconnect(",
            "                DISCONNECT_HOST_KEY_NOT_VERIFIABLE, b\"bad host key\"",
            "            )",
            "        )",
            "        return d",
            "",
            "    def ssh_KEX_DH_GEX_GROUP(self, packet):",
            "        \"\"\"",
            "        This handles different messages which share an integer value.",
            "",
            "        If the key exchange does not have a fixed prime/generator group,",
            "        we generate a Diffie-Hellman public key and send it in a",
            "        MSG_KEX_DH_GEX_INIT message.",
            "",
            "        Payload::",
            "            string g (group generator)",
            "            string p (group prime)",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if _kex.isFixedGroup(self.kexAlg):",
            "            return self._ssh_KEXDH_REPLY(packet)",
            "        elif _kex.isEllipticCurve(self.kexAlg):",
            "            return self._ssh_KEX_ECDH_REPLY(packet)",
            "        else:",
            "            self.p, rest = getMP(packet)",
            "            self.g, rest = getMP(rest)",
            "            self._startEphemeralDH()",
            "            self.sendPacket(MSG_KEX_DH_GEX_INIT, self.dhSecretKeyPublicMP)",
            "",
            "    def _continueKEXDH_REPLY(self, ignored, pubKey, f, signature):",
            "        \"\"\"",
            "        The host key has been verified, so we generate the keys.",
            "",
            "        @param ignored: Ignored.",
            "",
            "        @param pubKey: the public key blob for the server's public key.",
            "        @type pubKey: L{str}",
            "        @param f: the server's Diffie-Hellman public key.",
            "        @type f: L{int}",
            "        @param signature: the server's signature, verifying that it has the",
            "            correct private key.",
            "        @type signature: L{str}",
            "        \"\"\"",
            "        serverKey = keys.Key.fromString(pubKey)",
            "        sharedSecret = self._finishEphemeralDH(f)",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(pubKey))",
            "        h.update(self.dhSecretKeyPublicMP)",
            "        h.update(MP(f))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        if not serverKey.verify(signature, exchangeHash):",
            "            self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED, b\"bad signature\")",
            "            return",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def ssh_KEX_DH_GEX_REPLY(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_KEX_DH_GEX_REPLY message.  Payload::",
            "            string server host key",
            "            integer f (server DH public key)",
            "",
            "        We verify the host key by calling verifyHostKey, then continue in",
            "        _continueGEX_REPLY.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "",
            "        @return: A deferred firing once key exchange is complete.",
            "        \"\"\"",
            "        pubKey, packet = getNS(packet)",
            "        f, packet = getMP(packet)",
            "        signature, packet = getNS(packet)",
            "        fingerprint = b\":\".join(",
            "            [binascii.hexlify(c) for c in iterbytes(md5(pubKey).digest())]",
            "        )",
            "        d = self.verifyHostKey(pubKey, fingerprint)",
            "        d.addCallback(self._continueGEX_REPLY, pubKey, f, signature)",
            "        d.addErrback(",
            "            lambda unused: self.sendDisconnect(",
            "                DISCONNECT_HOST_KEY_NOT_VERIFIABLE, b\"bad host key\"",
            "            )",
            "        )",
            "        return d",
            "",
            "    def _continueGEX_REPLY(self, ignored, pubKey, f, signature):",
            "        \"\"\"",
            "        The host key has been verified, so we generate the keys.",
            "",
            "        @param ignored: Ignored.",
            "",
            "        @param pubKey: the public key blob for the server's public key.",
            "        @type pubKey: L{str}",
            "        @param f: the server's Diffie-Hellman public key.",
            "        @type f: L{int}",
            "        @param signature: the server's signature, verifying that it has the",
            "            correct private key.",
            "        @type signature: L{str}",
            "        \"\"\"",
            "        serverKey = keys.Key.fromString(pubKey)",
            "        sharedSecret = self._finishEphemeralDH(f)",
            "        h = _kex.getHashProcessor(self.kexAlg)()",
            "        h.update(NS(self.ourVersionString))",
            "        h.update(NS(self.otherVersionString))",
            "        h.update(NS(self.ourKexInitPayload))",
            "        h.update(NS(self.otherKexInitPayload))",
            "        h.update(NS(pubKey))",
            "        h.update(",
            "            struct.pack(",
            "                \"!LLL\",",
            "                self._dhMinimalGroupSize,",
            "                self._dhPreferredGroupSize,",
            "                self._dhMaximalGroupSize,",
            "            )",
            "        )",
            "        h.update(MP(self.p))",
            "        h.update(MP(self.g))",
            "        h.update(self.dhSecretKeyPublicMP)",
            "        h.update(MP(f))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        if not serverKey.verify(signature, exchangeHash):",
            "            self.sendDisconnect(DISCONNECT_KEY_EXCHANGE_FAILED, b\"bad signature\")",
            "            return",
            "        self._keySetup(sharedSecret, exchangeHash)",
            "",
            "    def _keySetup(self, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        See SSHTransportBase._keySetup().",
            "        \"\"\"",
            "        SSHTransportBase._keySetup(self, sharedSecret, exchangeHash)",
            "        if self._gotNewKeys:",
            "            self.ssh_NEWKEYS(b\"\")",
            "",
            "    def ssh_NEWKEYS(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_NEWKEYS message.  No payload.",
            "        If we've finished setting up our own keys, start using them.",
            "        Otherwise, remember that we've received this message.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if packet != b\"\":",
            "            self.sendDisconnect(DISCONNECT_PROTOCOL_ERROR, b\"NEWKEYS takes no data\")",
            "            return",
            "        if not self.nextEncryptions.encBlockSize:",
            "            self._gotNewKeys = 1",
            "            return",
            "        self._newKeys()",
            "        self.connectionSecure()",
            "",
            "    def ssh_SERVICE_ACCEPT(self, packet):",
            "        \"\"\"",
            "        Called when we receive a MSG_SERVICE_ACCEPT message.  Payload::",
            "            string service name",
            "",
            "        Start the service we requested.",
            "",
            "        @type packet: L{bytes}",
            "        @param packet: The message data.",
            "        \"\"\"",
            "        if packet == b\"\":",
            "            self._log.info(\"got SERVICE_ACCEPT without payload\")",
            "        else:",
            "            name = getNS(packet)[0]",
            "            if name != self.instance.name:",
            "                self.sendDisconnect(",
            "                    DISCONNECT_PROTOCOL_ERROR,",
            "                    b\"received accept for service we did not request\",",
            "                )",
            "        self.setService(self.instance)",
            "",
            "    def requestService(self, instance):",
            "        \"\"\"",
            "        Request that a service be run over this transport.",
            "",
            "        @type instance: subclass of L{twisted.conch.ssh.service.SSHService}",
            "        @param instance: The service to run.",
            "        \"\"\"",
            "        self.sendPacket(MSG_SERVICE_REQUEST, NS(instance.name))",
            "        self.instance = instance",
            "",
            "    # Client methods",
            "",
            "    def verifyHostKey(self, hostKey, fingerprint):",
            "        \"\"\"",
            "        Returns a Deferred that gets a callback if it is a valid key, or",
            "        an errback if not.",
            "",
            "        @type hostKey: L{bytes}",
            "        @param hostKey: The host key to verify.",
            "",
            "        @type fingerprint: L{bytes}",
            "        @param fingerprint: The fingerprint of the key.",
            "",
            "        @return: A deferred firing with C{True} if the key is valid.",
            "        \"\"\"",
            "        return defer.fail(NotImplementedError())",
            "",
            "    def connectionSecure(self):",
            "        \"\"\"",
            "        Called when the encryption has been set up.  Generally,",
            "        requestService() is called to run another service over the transport.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "",
            "class _NullEncryptionContext:",
            "    \"\"\"",
            "    An encryption context that does not actually encrypt anything.",
            "    \"\"\"",
            "",
            "    def update(self, data):",
            "        \"\"\"",
            "        'Encrypt' new data by doing nothing.",
            "",
            "        @type data: L{bytes}",
            "        @param data: The data to 'encrypt'.",
            "",
            "        @rtype: L{bytes}",
            "        @return: The 'encrypted' data.",
            "        \"\"\"",
            "        return data",
            "",
            "",
            "class _DummyAlgorithm:",
            "    \"\"\"",
            "    An encryption algorithm that does not actually encrypt anything.",
            "    \"\"\"",
            "",
            "    block_size = 64",
            "",
            "",
            "class _DummyCipher:",
            "    \"\"\"",
            "    A cipher for the none encryption method.",
            "",
            "    @ivar block_size: the block size of the encryption.  In the case of the",
            "    none cipher, this is 8 bytes.",
            "    \"\"\"",
            "",
            "    algorithm = _DummyAlgorithm()",
            "",
            "    def encryptor(self):",
            "        \"\"\"",
            "        Construct a noop encryptor.",
            "",
            "        @return: The encryptor.",
            "        \"\"\"",
            "        return _NullEncryptionContext()",
            "",
            "    def decryptor(self):",
            "        \"\"\"",
            "        Construct a noop decryptor.",
            "",
            "        @return: The decryptor.",
            "        \"\"\"",
            "        return _NullEncryptionContext()",
            "",
            "",
            "DH_GENERATOR, DH_PRIME = _kex.getDHGeneratorAndPrime(b\"diffie-hellman-group14-sha1\")",
            "",
            "",
            "MSG_DISCONNECT = 1",
            "MSG_IGNORE = 2",
            "MSG_UNIMPLEMENTED = 3",
            "MSG_DEBUG = 4",
            "MSG_SERVICE_REQUEST = 5",
            "MSG_SERVICE_ACCEPT = 6",
            "MSG_EXT_INFO = 7",
            "MSG_KEXINIT = 20",
            "MSG_NEWKEYS = 21",
            "MSG_KEXDH_INIT = 30",
            "MSG_KEXDH_REPLY = 31",
            "MSG_KEX_DH_GEX_REQUEST_OLD = 30",
            "MSG_KEX_DH_GEX_REQUEST = 34",
            "MSG_KEX_DH_GEX_GROUP = 31",
            "MSG_KEX_DH_GEX_INIT = 32",
            "MSG_KEX_DH_GEX_REPLY = 33",
            "",
            "",
            "DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT = 1",
            "DISCONNECT_PROTOCOL_ERROR = 2",
            "DISCONNECT_KEY_EXCHANGE_FAILED = 3",
            "DISCONNECT_RESERVED = 4",
            "DISCONNECT_MAC_ERROR = 5",
            "DISCONNECT_COMPRESSION_ERROR = 6",
            "DISCONNECT_SERVICE_NOT_AVAILABLE = 7",
            "DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED = 8",
            "DISCONNECT_HOST_KEY_NOT_VERIFIABLE = 9",
            "DISCONNECT_CONNECTION_LOST = 10",
            "DISCONNECT_BY_APPLICATION = 11",
            "DISCONNECT_TOO_MANY_CONNECTIONS = 12",
            "DISCONNECT_AUTH_CANCELLED_BY_USER = 13",
            "DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE = 14",
            "DISCONNECT_ILLEGAL_USER_NAME = 15",
            "",
            "",
            "messages = {}",
            "for name, value in list(globals().items()):",
            "    # Avoid legacy messages which overlap with never ones",
            "    if name.startswith(\"MSG_\") and not name.startswith(\"MSG_KEXDH_\"):",
            "        messages[value] = name",
            "# Check for regressions (#5352)",
            "if \"MSG_KEXDH_INIT\" in messages or \"MSG_KEXDH_REPLY\" in messages:",
            "    raise RuntimeError(\"legacy SSH mnemonics should not end up in messages dict\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "openstack_dashboard.dashboards.project.stacks.forms.TemplateForm"
        ]
    },
    "src/twisted/conch/test/test_transport.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": 515,
                "PatchRowcode": "         )"
            },
            "1": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 516,
                "PatchRowcode": "         self.assertRegex(softwareVersion, softwareVersionRegex)"
            },
            "2": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 517,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 518,
                "PatchRowcode": "+    def test_dataReceiveVersionNotSentMemoryDOS(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 519,
                "PatchRowcode": "+        \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 520,
                "PatchRowcode": "+        When the peer is not sending its SSH version but keeps sending data,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 521,
                "PatchRowcode": "+        the connection is disconnected after 4KB to prevent buffering too"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 522,
                "PatchRowcode": "+        much and running our of memory."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 523,
                "PatchRowcode": "+        \"\"\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 524,
                "PatchRowcode": "+        sut = MockTransportBase()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 525,
                "PatchRowcode": "+        sut.makeConnection(self.transport)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 526,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 527,
                "PatchRowcode": "+        # Data can be received over multiple chunks."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 528,
                "PatchRowcode": "+        sut.dataReceived(b\"SSH-2-Server-Identifier\")"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 529,
                "PatchRowcode": "+        sut.dataReceived(b\"1234567890\" * 406)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 530,
                "PatchRowcode": "+        sut.dataReceived(b\"1235678\")"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 531,
                "PatchRowcode": "+        self.assertFalse(self.transport.disconnecting)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 532,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 533,
                "PatchRowcode": "+        # Here we are going over the limit."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 534,
                "PatchRowcode": "+        sut.dataReceived(b\"1234567\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 535,
                "PatchRowcode": "+        # Once a lot of data is received without an SSH version string,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 536,
                "PatchRowcode": "+        # the transport is disconnected."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 537,
                "PatchRowcode": "+        self.assertTrue(self.transport.disconnecting)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 538,
                "PatchRowcode": "+        self.assertIn(b\"Preventing a denial of service attack\", self.transport.value())"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 539,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 540,
                "PatchRowcode": "     def test_sendPacketPlain(self):"
            },
            "26": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": 541,
                "PatchRowcode": "         \"\"\""
            },
            "27": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": 542,
                "PatchRowcode": "         Test that plain (unencrypted, uncompressed) packets are sent"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Tests for ssh/transport.py and the classes therein.",
            "\"\"\"",
            "",
            "",
            "import binascii",
            "import re",
            "import string",
            "import struct",
            "import types",
            "from hashlib import md5, sha1, sha256, sha384, sha512",
            "from typing import Optional, Type",
            "",
            "from twisted import __version__ as twisted_version",
            "from twisted.conch.error import ConchError",
            "from twisted.conch.ssh import _kex, address, service",
            "from twisted.internet import defer",
            "from twisted.protocols import loopback",
            "from twisted.python import randbytes",
            "from twisted.python.compat import iterbytes",
            "from twisted.python.randbytes import insecureRandom",
            "from twisted.python.reflect import requireModule",
            "from twisted.test import proto_helpers",
            "from twisted.trial.unittest import TestCase",
            "",
            "pyasn1 = requireModule(\"pyasn1\")",
            "cryptography = requireModule(\"cryptography\")",
            "",
            "dependencySkip: Optional[str]",
            "if pyasn1 and cryptography:",
            "    dependencySkip = None",
            "    from cryptography.exceptions import UnsupportedAlgorithm",
            "    from cryptography.hazmat.backends import default_backend",
            "    from cryptography.hazmat.primitives import serialization",
            "    from cryptography.hazmat.primitives.asymmetric import dh, ec",
            "",
            "    from twisted.conch.ssh import common, factory, keys, transport",
            "    from twisted.conch.test import keydata",
            "",
            "    X25519_SUPPORTED = default_backend().x25519_supported()",
            "else:",
            "    if not pyasn1:",
            "        dependencySkip = \"Cannot run without PyASN1\"",
            "    elif not cryptography:",
            "        dependencySkip = \"can't run without cryptography\"",
            "    X25519_SUPPORTED = False",
            "",
            "    # fictional modules to make classes work",
            "    class transport:  # type: ignore[no-redef]",
            "        class SSHTransportBase:",
            "            pass",
            "",
            "        class SSHServerTransport:",
            "            pass",
            "",
            "        class SSHClientTransport:",
            "            pass",
            "",
            "    class factory:  # type: ignore[no-redef]",
            "        class SSHFactory:",
            "            pass",
            "",
            "    class common:  # type: ignore[no-redef]",
            "        @classmethod",
            "        def NS(self, arg):",
            "            return b\"\"",
            "",
            "",
            "def skipWithoutX25519(f):",
            "    if not X25519_SUPPORTED:",
            "        f.skip = \"x25519 not supported on this system\"",
            "    return f",
            "",
            "",
            "def _MPpow(x, y, z):",
            "    \"\"\"",
            "    Return the MP version of C{(x ** y) % z}.",
            "    \"\"\"",
            "    return common.MP(pow(x, y, z))",
            "",
            "",
            "class MockTransportBase(transport.SSHTransportBase):",
            "    \"\"\"",
            "    A base class for the client and server protocols.  Stores the messages",
            "    it receives instead of ignoring them.",
            "",
            "    @ivar errors: a list of tuples: (reasonCode, description)",
            "    @ivar unimplementeds: a list of integers: sequence number",
            "    @ivar debugs: a list of tuples: (alwaysDisplay, message, lang)",
            "    @ivar ignoreds: a list of strings: ignored data",
            "    \"\"\"",
            "",
            "    def connectionMade(self):",
            "        \"\"\"",
            "        Set up instance variables.",
            "        \"\"\"",
            "        transport.SSHTransportBase.connectionMade(self)",
            "        self.errors = []",
            "        self.unimplementeds = []",
            "        self.debugs = []",
            "        self.ignoreds = []",
            "        self.gotUnsupportedVersion = None",
            "",
            "    def _unsupportedVersionReceived(self, remoteVersion):",
            "        \"\"\"",
            "        Intercept unsupported version call.",
            "",
            "        @type remoteVersion: L{str}",
            "        \"\"\"",
            "        self.gotUnsupportedVersion = remoteVersion",
            "        return transport.SSHTransportBase._unsupportedVersionReceived(",
            "            self, remoteVersion",
            "        )",
            "",
            "    def receiveError(self, reasonCode, description):",
            "        \"\"\"",
            "        Store any errors received.",
            "",
            "        @type reasonCode: L{int}",
            "        @type description: L{str}",
            "        \"\"\"",
            "        self.errors.append((reasonCode, description))",
            "",
            "    def receiveUnimplemented(self, seqnum):",
            "        \"\"\"",
            "        Store any unimplemented packet messages.",
            "",
            "        @type seqnum: L{int}",
            "        \"\"\"",
            "        self.unimplementeds.append(seqnum)",
            "",
            "    def receiveDebug(self, alwaysDisplay, message, lang):",
            "        \"\"\"",
            "        Store any debug messages.",
            "",
            "        @type alwaysDisplay: L{bool}",
            "        @type message: L{str}",
            "        @type lang: L{str}",
            "        \"\"\"",
            "        self.debugs.append((alwaysDisplay, message, lang))",
            "",
            "    def ssh_IGNORE(self, packet):",
            "        \"\"\"",
            "        Store any ignored data.",
            "",
            "        @type packet: L{str}",
            "        \"\"\"",
            "        self.ignoreds.append(packet)",
            "",
            "",
            "class MockCipher:",
            "    \"\"\"",
            "    A mocked-up version of twisted.conch.ssh.transport.SSHCiphers.",
            "    \"\"\"",
            "",
            "    outCipType = b\"test\"",
            "    encBlockSize = 6",
            "    inCipType = b\"test\"",
            "    decBlockSize = 6",
            "    inMACType = b\"test\"",
            "    outMACType = b\"test\"",
            "    verifyDigestSize = 1",
            "    usedEncrypt = False",
            "    usedDecrypt = False",
            "    outMAC = (None, b\"\", b\"\", 1)",
            "    inMAC = (None, b\"\", b\"\", 1)",
            "    keys = ()",
            "",
            "    def encrypt(self, x):",
            "        \"\"\"",
            "        Called to encrypt the packet.  Simply record that encryption was used",
            "        and return the data unchanged.",
            "        \"\"\"",
            "        self.usedEncrypt = True",
            "        if (len(x) % self.encBlockSize) != 0:",
            "            raise RuntimeError(",
            "                \"length %i modulo blocksize %i is not 0: %i\"",
            "                % (len(x), self.encBlockSize, len(x) % self.encBlockSize)",
            "            )",
            "        return x",
            "",
            "    def decrypt(self, x):",
            "        \"\"\"",
            "        Called to decrypt the packet.  Simply record that decryption was used",
            "        and return the data unchanged.",
            "        \"\"\"",
            "        self.usedDecrypt = True",
            "        if (len(x) % self.encBlockSize) != 0:",
            "            raise RuntimeError(",
            "                \"length %i modulo blocksize %i is not 0: %i\"",
            "                % (len(x), self.decBlockSize, len(x) % self.decBlockSize)",
            "            )",
            "        return x",
            "",
            "    def makeMAC(self, outgoingPacketSequence, payload):",
            "        \"\"\"",
            "        Make a Message Authentication Code by sending the character value of",
            "        the outgoing packet.",
            "        \"\"\"",
            "        return bytes((outgoingPacketSequence,))",
            "",
            "    def verify(self, incomingPacketSequence, packet, macData):",
            "        \"\"\"",
            "        Verify the Message Authentication Code by checking that the packet",
            "        sequence number is the same.",
            "        \"\"\"",
            "        return bytes((incomingPacketSequence,)) == macData",
            "",
            "    def setKeys(self, ivOut, keyOut, ivIn, keyIn, macIn, macOut):",
            "        \"\"\"",
            "        Record the keys.",
            "        \"\"\"",
            "        self.keys = (ivOut, keyOut, ivIn, keyIn, macIn, macOut)",
            "",
            "",
            "class MockCompression:",
            "    \"\"\"",
            "    A mocked-up compression, based on the zlib interface.  Instead of",
            "    compressing, it reverses the data and adds a 0x66 byte to the end.",
            "    \"\"\"",
            "",
            "    def compress(self, payload):",
            "        return payload[::-1]  # reversed",
            "",
            "    def decompress(self, payload):",
            "        return payload[:-1][::-1]",
            "",
            "    def flush(self, kind):",
            "        return b\"\\x66\"",
            "",
            "",
            "class MockService(service.SSHService):",
            "    \"\"\"",
            "    A mocked-up service, based on twisted.conch.ssh.service.SSHService.",
            "",
            "    @ivar started: True if this service has been started.",
            "    @ivar stopped: True if this service has been stopped.",
            "    \"\"\"",
            "",
            "    name = b\"MockService\"",
            "    started = False",
            "    stopped = False",
            "    protocolMessages = {0xFF: \"MSG_TEST\", 71: \"MSG_fiction\"}",
            "",
            "    def logPrefix(self):",
            "        return \"MockService\"",
            "",
            "    def serviceStarted(self):",
            "        \"\"\"",
            "        Record that the service was started.",
            "        \"\"\"",
            "        self.started = True",
            "",
            "    def serviceStopped(self):",
            "        \"\"\"",
            "        Record that the service was stopped.",
            "        \"\"\"",
            "        self.stopped = True",
            "",
            "    def ssh_TEST(self, packet):",
            "        \"\"\"",
            "        A message that this service responds to.",
            "        \"\"\"",
            "        self.transport.sendPacket(0xFF, packet)",
            "",
            "",
            "class MockFactory(factory.SSHFactory):",
            "    \"\"\"",
            "    A mocked-up factory based on twisted.conch.ssh.factory.SSHFactory.",
            "    \"\"\"",
            "",
            "    services = {b\"ssh-userauth\": MockService}",
            "",
            "    def getPublicKeys(self):",
            "        \"\"\"",
            "        Return the public keys that authenticate this server.",
            "        \"\"\"",
            "        return {",
            "            b\"ssh-rsa\": keys.Key.fromString(keydata.publicRSA_openssh),",
            "            b\"ssh-dsa\": keys.Key.fromString(keydata.publicDSA_openssh),",
            "        }",
            "",
            "    def getPrivateKeys(self):",
            "        \"\"\"",
            "        Return the private keys that authenticate this server.",
            "        \"\"\"",
            "        return {",
            "            b\"ssh-rsa\": keys.Key.fromString(keydata.privateRSA_openssh),",
            "            b\"ssh-dsa\": keys.Key.fromString(keydata.privateDSA_openssh),",
            "        }",
            "",
            "    def getPrimes(self):",
            "        \"\"\"",
            "        Diffie-Hellman primes that can be used for key exchange algorithms",
            "        that use group exchange to establish a prime / generator group.",
            "",
            "        @return: The primes and generators.",
            "        @rtype: L{dict} mapping the key size to a C{list} of",
            "            C{(generator, prime)} tuple.",
            "        \"\"\"",
            "        # In these tests, we hardwire the prime values to those",
            "        # defined by the diffie-hellman-group14-sha1 key exchange",
            "        # algorithm, to avoid requiring a moduli file when running",
            "        # tests.",
            "        # See OpenSSHFactory.getPrimes.",
            "        group14 = _kex.getDHGeneratorAndPrime(b\"diffie-hellman-group14-sha1\")",
            "        return {2048: (group14,), 4096: ((5, 7),)}",
            "",
            "",
            "class MockOldFactoryPublicKeys(MockFactory):",
            "    \"\"\"",
            "    The old SSHFactory returned mappings from key names to strings from",
            "    getPublicKeys().  We return those here for testing.",
            "    \"\"\"",
            "",
            "    def getPublicKeys(self):",
            "        \"\"\"",
            "        We used to map key types to public key blobs as strings.",
            "        \"\"\"",
            "        keys = MockFactory.getPublicKeys(self)",
            "        for name, key in keys.items()[:]:",
            "            keys[name] = key.blob()",
            "        return keys",
            "",
            "",
            "class MockOldFactoryPrivateKeys(MockFactory):",
            "    \"\"\"",
            "    The old SSHFactory returned mappings from key names to cryptography key",
            "    objects from getPrivateKeys().  We return those here for testing.",
            "    \"\"\"",
            "",
            "    def getPrivateKeys(self):",
            "        \"\"\"",
            "        We used to map key types to cryptography key objects.",
            "        \"\"\"",
            "        keys = MockFactory.getPrivateKeys(self)",
            "        for name, key in keys.items()[:]:",
            "            keys[name] = key.keyObject",
            "        return keys",
            "",
            "",
            "def generatePredictableKey(transport):",
            "    p = transport.p",
            "    g = transport.g",
            "    bits = p.bit_length()",
            "    x = sum(0x9 << x for x in range(0, bits - 3, 4))",
            "    # The cryptography module doesn't let us create a secret key directly from",
            "    # an \"x\" value; we need to compute the public value ourselves.",
            "    y = pow(g, x, p)",
            "    try:",
            "        transport.dhSecretKey = dh.DHPrivateNumbers(",
            "            x, dh.DHPublicNumbers(y, dh.DHParameterNumbers(p, g))",
            "        ).private_key(default_backend())",
            "    except ValueError:",
            "        print(f\"\\np={p}\\ng={g}\\nx={x}\\n\")",
            "        raise",
            "    transport.dhSecretKeyPublicMP = common.MP(",
            "        transport.dhSecretKey.public_key().public_numbers().y",
            "    )",
            "",
            "",
            "class TransportTestCase(TestCase):",
            "    \"\"\"",
            "    Base class for transport test cases.",
            "    \"\"\"",
            "",
            "    klass: Optional[Type[transport.SSHTransportBase]] = None",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    def setUp(self):",
            "        self.transport = proto_helpers.StringTransport()",
            "        self.proto = self.klass()",
            "        self.packets = []",
            "",
            "        def secureRandom(len):",
            "            \"\"\"",
            "            Return a consistent entropy value",
            "            \"\"\"",
            "            return b\"\\x99\" * len",
            "",
            "        self.patch(randbytes, \"secureRandom\", secureRandom)",
            "        self.proto._startEphemeralDH = types.MethodType(",
            "            generatePredictableKey, self.proto",
            "        )",
            "",
            "        def stubSendPacket(messageType, payload):",
            "            self.packets.append((messageType, payload))",
            "",
            "        self.proto.makeConnection(self.transport)",
            "        # we just let the kex packet go into the transport",
            "        self.proto.sendPacket = stubSendPacket",
            "",
            "    def finishKeyExchange(self, proto):",
            "        \"\"\"",
            "        Deliver enough additional messages to C{proto} so that the key exchange",
            "        which is started in L{SSHTransportBase.connectionMade} completes and",
            "        non-key exchange messages can be sent and received.",
            "        \"\"\"",
            "        proto.dataReceived(b\"SSH-2.0-BogoClient-1.2i\\r\\n\")",
            "        proto.dispatchMessage(transport.MSG_KEXINIT, self._A_KEXINIT_MESSAGE)",
            "        proto._keySetup(b\"foo\", b\"bar\")",
            "        # SSHTransportBase can't handle MSG_NEWKEYS, or it would be the right",
            "        # thing to deliver next.  _newKeys won't work either, because",
            "        # sendKexInit (probably) hasn't been called.  sendKexInit is",
            "        # responsible for setting up certain state _newKeys relies on.  So,",
            "        # just change the key exchange state to what it would be when key",
            "        # exchange is finished.",
            "        proto._keyExchangeState = proto._KEY_EXCHANGE_NONE",
            "",
            "    def simulateKeyExchange(self, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        Finish a key exchange by calling C{_keySetup} with the given arguments.",
            "        Also do extra whitebox stuff to satisfy that method's assumption that",
            "        some kind of key exchange has actually taken place.",
            "        \"\"\"",
            "        self.proto._keyExchangeState = self.proto._KEY_EXCHANGE_REQUESTED",
            "        self.proto._blockedByKeyExchange = []",
            "        self.proto._keySetup(sharedSecret, exchangeHash)",
            "",
            "",
            "class DHGroupExchangeSHA1Mixin:",
            "    \"\"\"",
            "    Mixin for diffie-hellman-group-exchange-sha1 tests.",
            "    \"\"\"",
            "",
            "    kexAlgorithm = b\"diffie-hellman-group-exchange-sha1\"",
            "    hashProcessor = sha1",
            "",
            "",
            "class DHGroupExchangeSHA256Mixin:",
            "    \"\"\"",
            "    Mixin for diffie-hellman-group-exchange-sha256 tests.",
            "    \"\"\"",
            "",
            "    kexAlgorithm = b\"diffie-hellman-group-exchange-sha256\"",
            "    hashProcessor = sha256",
            "",
            "",
            "class ECDHMixin:",
            "    \"\"\"",
            "    Mixin for elliptic curve diffie-hellman tests.",
            "    \"\"\"",
            "",
            "    kexAlgorithm = b\"ecdh-sha2-nistp256\"",
            "    hashProcessor = sha256",
            "",
            "",
            "class Curve25519SHA256Mixin:",
            "    \"\"\"",
            "    Mixin for curve25519-sha256 tests.",
            "    \"\"\"",
            "",
            "    kexAlgorithm = b\"curve25519-sha256\"",
            "    hashProcessor = sha256",
            "",
            "",
            "class BaseSSHTransportBaseCase:",
            "    \"\"\"",
            "    Base case for TransportBase tests.",
            "    \"\"\"",
            "",
            "    klass: Optional[Type[transport.SSHTransportBase]] = MockTransportBase",
            "",
            "",
            "class BaseSSHTransportTests(BaseSSHTransportBaseCase, TransportTestCase):",
            "    \"\"\"",
            "    Test TransportBase. It implements the non-server/client specific",
            "    parts of the SSH transport protocol.",
            "    \"\"\"",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    _A_KEXINIT_MESSAGE = (",
            "        b\"\\xAA\" * 16",
            "        + common.NS(b\"diffie-hellman-group14-sha1\")",
            "        + common.NS(b\"ssh-rsa\")",
            "        + common.NS(b\"aes256-ctr\")",
            "        + common.NS(b\"aes256-ctr\")",
            "        + common.NS(b\"hmac-sha1\")",
            "        + common.NS(b\"hmac-sha1\")",
            "        + common.NS(b\"none\")",
            "        + common.NS(b\"none\")",
            "        + common.NS(b\"\")",
            "        + common.NS(b\"\")",
            "        + b\"\\x00\"",
            "        + b\"\\x00\\x00\\x00\\x00\"",
            "    )",
            "",
            "    def test_sendVersion(self):",
            "        \"\"\"",
            "        Test that the first thing sent over the connection is the version",
            "        string.  The 'softwareversion' part must consist of printable",
            "        US-ASCII characters, with the exception of whitespace characters and",
            "        the minus sign.",
            "",
            "        RFC 4253, section 4.2.",
            "        \"\"\"",
            "        # the other setup was done in the setup method",
            "        version = self.transport.value().split(b\"\\r\\n\", 1)[0]",
            "        self.assertEqual(version, b\"SSH-2.0-Twisted_\" + twisted_version.encode(\"ascii\"))",
            "        softwareVersion = version.decode(\"ascii\")[len(\"SSH-2.0-\") :]",
            "        # This is an inefficient regex, but it's simple to build.",
            "        softwareVersionRegex = (",
            "            r\"^(\"",
            "            + \"|\".join(",
            "                re.escape(c) for c in string.printable if c != \"-\" and not c.isspace()",
            "            )",
            "            + r\")*$\"",
            "        )",
            "        self.assertRegex(softwareVersion, softwareVersionRegex)",
            "",
            "    def test_sendPacketPlain(self):",
            "        \"\"\"",
            "        Test that plain (unencrypted, uncompressed) packets are sent",
            "        correctly.  The format is::",
            "            uint32 length (including type and padding length)",
            "            byte padding length",
            "            byte type",
            "            bytes[length-padding length-2] data",
            "            bytes[padding length] padding",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        self.transport.clear()",
            "        message = ord(\"A\")",
            "        payload = b\"BCDEFG\"",
            "        proto.sendPacket(message, payload)",
            "        value = self.transport.value()",
            "        self.assertEqual(value, b\"\\x00\\x00\\x00\\x0c\\x04ABCDEFG\\x99\\x99\\x99\\x99\")",
            "",
            "    def test_sendPacketEncrypted(self):",
            "        \"\"\"",
            "        Test that packets sent while encryption is enabled are sent",
            "        correctly.  The whole packet should be encrypted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        proto.currentEncryptions = testCipher = MockCipher()",
            "        message = ord(\"A\")",
            "        payload = b\"BC\"",
            "        self.transport.clear()",
            "        proto.sendPacket(message, payload)",
            "        self.assertTrue(testCipher.usedEncrypt)",
            "        value = self.transport.value()",
            "        self.assertEqual(",
            "            value,",
            "            # Four byte length prefix",
            "            b\"\\x00\\x00\\x00\\x08\"",
            "            # One byte padding length",
            "            b\"\\x04\"",
            "            # The actual application data",
            "            b\"ABC\"",
            "            # \"Random\" padding - see the secureRandom monkeypatch in setUp",
            "            b\"\\x99\\x99\\x99\\x99\"",
            "            # The MAC",
            "            b\"\\x02\",",
            "        )",
            "",
            "    def test_sendPacketCompressed(self):",
            "        \"\"\"",
            "        Test that packets sent while compression is enabled are sent",
            "        correctly.  The packet type and data should be encrypted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        proto.outgoingCompression = MockCompression()",
            "        self.transport.clear()",
            "        proto.sendPacket(ord(\"A\"), b\"B\")",
            "        value = self.transport.value()",
            "        self.assertEqual(",
            "            value, b\"\\x00\\x00\\x00\\x0c\\x08BA\\x66\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\"",
            "        )",
            "",
            "    def test_sendPacketBoth(self):",
            "        \"\"\"",
            "        Test that packets sent while compression and encryption are",
            "        enabled are sent correctly.  The packet type and data should be",
            "        compressed and then the whole packet should be encrypted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        proto.currentEncryptions = testCipher = MockCipher()",
            "        proto.outgoingCompression = MockCompression()",
            "        message = ord(\"A\")",
            "        payload = b\"BC\"",
            "        self.transport.clear()",
            "        proto.sendPacket(message, payload)",
            "        self.assertTrue(testCipher.usedEncrypt)",
            "        value = self.transport.value()",
            "        self.assertEqual(",
            "            value,",
            "            # Four byte length prefix",
            "            b\"\\x00\\x00\\x00\\x0e\"",
            "            # One byte padding length",
            "            b\"\\x09\"",
            "            # Compressed application data",
            "            b\"CBA\\x66\"",
            "            # \"Random\" padding - see the secureRandom monkeypatch in setUp",
            "            b\"\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\"",
            "            # The MAC",
            "            b\"\\x02\",",
            "        )",
            "",
            "    def test_getPacketPlain(self):",
            "        \"\"\"",
            "        Test that packets are retrieved correctly out of the buffer when",
            "        no encryption is enabled.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        self.transport.clear()",
            "        proto.sendPacket(ord(\"A\"), b\"BC\")",
            "        proto.buf = self.transport.value() + b\"extra\"",
            "        self.assertEqual(proto.getPacket(), b\"ABC\")",
            "        self.assertEqual(proto.buf, b\"extra\")",
            "",
            "    def test_getPacketEncrypted(self):",
            "        \"\"\"",
            "        Test that encrypted packets are retrieved correctly.",
            "        See test_sendPacketEncrypted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.sendKexInit = lambda: None  # don't send packets",
            "        proto.makeConnection(self.transport)",
            "        self.transport.clear()",
            "        proto.currentEncryptions = testCipher = MockCipher()",
            "        proto.sendPacket(ord(\"A\"), b\"BCD\")",
            "        value = self.transport.value()",
            "        proto.buf = value[: MockCipher.decBlockSize]",
            "        self.assertIsNone(proto.getPacket())",
            "        self.assertTrue(testCipher.usedDecrypt)",
            "        self.assertEqual(proto.first, b\"\\x00\\x00\\x00\\x0e\\x09A\")",
            "        proto.buf += value[MockCipher.decBlockSize :]",
            "        self.assertEqual(proto.getPacket(), b\"ABCD\")",
            "        self.assertEqual(proto.buf, b\"\")",
            "",
            "    def test_getPacketCompressed(self):",
            "        \"\"\"",
            "        Test that compressed packets are retrieved correctly.  See",
            "        test_sendPacketCompressed.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        self.transport.clear()",
            "        proto.outgoingCompression = MockCompression()",
            "        proto.incomingCompression = proto.outgoingCompression",
            "        proto.sendPacket(ord(\"A\"), b\"BCD\")",
            "        proto.buf = self.transport.value()",
            "        self.assertEqual(proto.getPacket(), b\"ABCD\")",
            "",
            "    def test_getPacketBoth(self):",
            "        \"\"\"",
            "        Test that compressed and encrypted packets are retrieved correctly.",
            "        See test_sendPacketBoth.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.sendKexInit = lambda: None",
            "        proto.makeConnection(self.transport)",
            "        self.transport.clear()",
            "        proto.currentEncryptions = MockCipher()",
            "        proto.outgoingCompression = MockCompression()",
            "        proto.incomingCompression = proto.outgoingCompression",
            "        proto.sendPacket(ord(\"A\"), b\"BCDEFG\")",
            "        proto.buf = self.transport.value()",
            "        self.assertEqual(proto.getPacket(), b\"ABCDEFG\")",
            "",
            "    def test_ciphersAreValid(self):",
            "        \"\"\"",
            "        Test that all the supportedCiphers are valid.",
            "        \"\"\"",
            "        ciphers = transport.SSHCiphers(b\"A\", b\"B\", b\"C\", b\"D\")",
            "        iv = key = b\"\\x00\" * 16",
            "        for cipName in self.proto.supportedCiphers:",
            "            self.assertTrue(ciphers._getCipher(cipName, iv, key))",
            "",
            "    def test_sendKexInit(self):",
            "        \"\"\"",
            "        Test that the KEXINIT (key exchange initiation) message is sent",
            "        correctly.  Payload::",
            "            bytes[16] cookie",
            "            string key exchange algorithms",
            "            string public key algorithms",
            "            string outgoing ciphers",
            "            string incoming ciphers",
            "            string outgoing MACs",
            "            string incoming MACs",
            "            string outgoing compressions",
            "            string incoming compressions",
            "            bool first packet follows",
            "            uint32 0",
            "        \"\"\"",
            "        value = self.transport.value().split(b\"\\r\\n\", 1)[1]",
            "        self.proto.buf = value",
            "        packet = self.proto.getPacket()",
            "        self.assertEqual(packet[0:1], bytes((transport.MSG_KEXINIT,)))",
            "        self.assertEqual(packet[1:17], b\"\\x99\" * 16)",
            "        (",
            "            keyExchanges,",
            "            pubkeys,",
            "            ciphers1,",
            "            ciphers2,",
            "            macs1,",
            "            macs2,",
            "            compressions1,",
            "            compressions2,",
            "            languages1,",
            "            languages2,",
            "            buf,",
            "        ) = common.getNS(packet[17:], 10)",
            "",
            "        self.assertEqual(",
            "            keyExchanges, b\",\".join(self.proto.supportedKeyExchanges + [b\"ext-info-s\"])",
            "        )",
            "        self.assertEqual(pubkeys, b\",\".join(self.proto.supportedPublicKeys))",
            "        self.assertEqual(ciphers1, b\",\".join(self.proto.supportedCiphers))",
            "        self.assertEqual(ciphers2, b\",\".join(self.proto.supportedCiphers))",
            "        self.assertEqual(macs1, b\",\".join(self.proto.supportedMACs))",
            "        self.assertEqual(macs2, b\",\".join(self.proto.supportedMACs))",
            "        self.assertEqual(compressions1, b\",\".join(self.proto.supportedCompressions))",
            "        self.assertEqual(compressions2, b\",\".join(self.proto.supportedCompressions))",
            "        self.assertEqual(languages1, b\",\".join(self.proto.supportedLanguages))",
            "        self.assertEqual(languages2, b\",\".join(self.proto.supportedLanguages))",
            "        self.assertEqual(buf, b\"\\x00\" * 5)",
            "",
            "    def test_receiveKEXINITReply(self):",
            "        \"\"\"",
            "        Immediately after connecting, the transport expects a KEXINIT message",
            "        and does not reply to it.",
            "        \"\"\"",
            "        self.transport.clear()",
            "        self.proto.dispatchMessage(transport.MSG_KEXINIT, self._A_KEXINIT_MESSAGE)",
            "        self.assertEqual(self.packets, [])",
            "",
            "    def test_sendKEXINITReply(self):",
            "        \"\"\"",
            "        When a KEXINIT message is received which is not a reply to an earlier",
            "        KEXINIT message which was sent, a KEXINIT reply is sent.",
            "        \"\"\"",
            "        self.finishKeyExchange(self.proto)",
            "        del self.packets[:]",
            "",
            "        self.proto.dispatchMessage(transport.MSG_KEXINIT, self._A_KEXINIT_MESSAGE)",
            "        self.assertEqual(len(self.packets), 1)",
            "        self.assertEqual(self.packets[0][0], transport.MSG_KEXINIT)",
            "",
            "    def test_sendKexInitTwiceFails(self):",
            "        \"\"\"",
            "        A new key exchange cannot be started while a key exchange is already in",
            "        progress.  If an attempt is made to send a I{KEXINIT} message using",
            "        L{SSHTransportBase.sendKexInit} while a key exchange is in progress",
            "        causes that method to raise a L{RuntimeError}.",
            "        \"\"\"",
            "        self.assertRaises(RuntimeError, self.proto.sendKexInit)",
            "",
            "    def test_sendKexInitBlocksOthers(self):",
            "        \"\"\"",
            "        After L{SSHTransportBase.sendKexInit} has been called, messages types",
            "        other than the following are queued and not sent until after I{NEWKEYS}",
            "        is sent by L{SSHTransportBase._keySetup}.",
            "",
            "        RFC 4253, section 7.1.",
            "        \"\"\"",
            "        # sendKexInit is called by connectionMade, which is called in setUp.",
            "        # So we're in the state already.",
            "        disallowedMessageTypes = [",
            "            transport.MSG_SERVICE_REQUEST,",
            "            transport.MSG_KEXINIT,",
            "        ]",
            "",
            "        # Drop all the bytes sent by setUp, they're not relevant to this test.",
            "        self.transport.clear()",
            "",
            "        # Get rid of the sendPacket monkey patch, we are testing the behavior",
            "        # of sendPacket.",
            "        del self.proto.sendPacket",
            "",
            "        for messageType in disallowedMessageTypes:",
            "            self.proto.sendPacket(messageType, b\"foo\")",
            "            self.assertEqual(self.transport.value(), b\"\")",
            "",
            "        self.finishKeyExchange(self.proto)",
            "        # Make the bytes written to the transport cleartext so it's easier to",
            "        # make an assertion about them.",
            "        self.proto.nextEncryptions = MockCipher()",
            "",
            "        # Pseudo-deliver the peer's NEWKEYS message, which should flush the",
            "        # messages which were queued above.",
            "        self.proto._newKeys()",
            "        self.assertEqual(self.transport.value().count(b\"foo\"), 2)",
            "",
            "    def test_sendExtInfo(self):",
            "        \"\"\"",
            "        Test that EXT_INFO messages are sent correctly.  See RFC 8308,",
            "        section 2.3.",
            "        \"\"\"",
            "        self.proto._peerSupportsExtensions = True",
            "        self.proto.sendExtInfo(",
            "            [",
            "                (b\"server-sig-algs\", b\"ssh-rsa,rsa-sha2-256\"),",
            "                (b\"elevation\", b\"d\"),",
            "            ]",
            "        )",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_EXT_INFO,",
            "                    b\"\\x00\\x00\\x00\\x02\"",
            "                    + common.NS(b\"server-sig-algs\")",
            "                    + common.NS(b\"ssh-rsa,rsa-sha2-256\")",
            "                    + common.NS(b\"elevation\")",
            "                    + common.NS(b\"d\"),",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_sendExtInfoUnsupported(self):",
            "        \"\"\"",
            "        If the peer has not advertised support for extension negotiation, no",
            "        EXT_INFO message is sent, since RFC 8308 only guarantees that the",
            "        peer will be prepared to accept it if it has advertised support.",
            "        \"\"\"",
            "        self.proto.sendExtInfo([(b\"server-sig-algs\", b\"ssh-rsa,rsa-sha2-256\")])",
            "        self.assertEqual(self.packets, [])",
            "",
            "    def test_EXT_INFO(self):",
            "        \"\"\"",
            "        When an EXT_INFO message is received, the transport stores a mapping",
            "        of the peer's advertised extensions.  See RFC 8308, section 2.3.",
            "        \"\"\"",
            "        self.proto.dispatchMessage(",
            "            transport.MSG_EXT_INFO,",
            "            b\"\\x00\\x00\\x00\\x02\"",
            "            + common.NS(b\"server-sig-algs\")",
            "            + common.NS(b\"ssh-rsa,rsa-sha2-256,rsa-sha2-512\")",
            "            + common.NS(b\"no-flow-control\")",
            "            + common.NS(b\"s\"),",
            "        )",
            "        self.assertEqual(",
            "            self.proto.peerExtensions,",
            "            {",
            "                b\"server-sig-algs\": b\"ssh-rsa,rsa-sha2-256,rsa-sha2-512\",",
            "                b\"no-flow-control\": b\"s\",",
            "            },",
            "        )",
            "",
            "    def test_sendDebug(self):",
            "        \"\"\"",
            "        Test that debug messages are sent correctly.  Payload::",
            "            bool always display",
            "            string debug message",
            "            string language",
            "        \"\"\"",
            "        self.proto.sendDebug(b\"test\", True, b\"en\")",
            "        self.assertEqual(",
            "            self.packets,",
            "            [(transport.MSG_DEBUG, b\"\\x01\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x02en\")],",
            "        )",
            "",
            "    def test_receiveDebug(self):",
            "        \"\"\"",
            "        Test that debug messages are received correctly.  See test_sendDebug.",
            "        \"\"\"",
            "        self.proto.dispatchMessage(",
            "            transport.MSG_DEBUG, b\"\\x01\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x02en\"",
            "        )",
            "        self.proto.dispatchMessage(",
            "            transport.MSG_DEBUG, b\"\\x00\\x00\\x00\\x00\\x06silent\\x00\\x00\\x00\\x02en\"",
            "        )",
            "        self.assertEqual(",
            "            self.proto.debugs, [(True, b\"test\", b\"en\"), (False, b\"silent\", b\"en\")]",
            "        )",
            "",
            "    def test_sendIgnore(self):",
            "        \"\"\"",
            "        Test that ignored messages are sent correctly.  Payload::",
            "            string ignored data",
            "        \"\"\"",
            "        self.proto.sendIgnore(b\"test\")",
            "        self.assertEqual(",
            "            self.packets, [(transport.MSG_IGNORE, b\"\\x00\\x00\\x00\\x04test\")]",
            "        )",
            "",
            "    def test_receiveIgnore(self):",
            "        \"\"\"",
            "        Test that ignored messages are received correctly.  See",
            "        test_sendIgnore.",
            "        \"\"\"",
            "        self.proto.dispatchMessage(transport.MSG_IGNORE, b\"test\")",
            "        self.assertEqual(self.proto.ignoreds, [b\"test\"])",
            "",
            "    def test_sendUnimplemented(self):",
            "        \"\"\"",
            "        Test that unimplemented messages are sent correctly.  Payload::",
            "            uint32 sequence number",
            "        \"\"\"",
            "        self.proto.sendUnimplemented()",
            "        self.assertEqual(",
            "            self.packets, [(transport.MSG_UNIMPLEMENTED, b\"\\x00\\x00\\x00\\x00\")]",
            "        )",
            "",
            "    def test_receiveUnimplemented(self):",
            "        \"\"\"",
            "        Test that unimplemented messages are received correctly.  See",
            "        test_sendUnimplemented.",
            "        \"\"\"",
            "        self.proto.dispatchMessage(transport.MSG_UNIMPLEMENTED, b\"\\x00\\x00\\x00\\xff\")",
            "        self.assertEqual(self.proto.unimplementeds, [255])",
            "",
            "    def test_sendDisconnect(self):",
            "        \"\"\"",
            "        Test that disconnection messages are sent correctly.  Payload::",
            "            uint32 reason code",
            "            string reason description",
            "            string language",
            "        \"\"\"",
            "        disconnected = [False]",
            "",
            "        def stubLoseConnection():",
            "            disconnected[0] = True",
            "",
            "        self.transport.loseConnection = stubLoseConnection",
            "        self.proto.sendDisconnect(0xFF, b\"test\")",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_DISCONNECT,",
            "                    b\"\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x00\",",
            "                )",
            "            ],",
            "        )",
            "        self.assertTrue(disconnected[0])",
            "",
            "    def test_receiveDisconnect(self):",
            "        \"\"\"",
            "        Test that disconnection messages are received correctly.  See",
            "        test_sendDisconnect.",
            "        \"\"\"",
            "        disconnected = [False]",
            "",
            "        def stubLoseConnection():",
            "            disconnected[0] = True",
            "",
            "        self.transport.loseConnection = stubLoseConnection",
            "        self.proto.dispatchMessage(",
            "            transport.MSG_DISCONNECT, b\"\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x04test\"",
            "        )",
            "        self.assertEqual(self.proto.errors, [(255, b\"test\")])",
            "        self.assertTrue(disconnected[0])",
            "",
            "    def test_dataReceived(self):",
            "        \"\"\"",
            "        Test that dataReceived parses packets and dispatches them to",
            "        ssh_* methods.",
            "        \"\"\"",
            "        kexInit = [False]",
            "",
            "        def stubKEXINIT(packet):",
            "            kexInit[0] = True",
            "",
            "        self.proto.ssh_KEXINIT = stubKEXINIT",
            "        self.proto.dataReceived(self.transport.value())",
            "        self.assertTrue(self.proto.gotVersion)",
            "        self.assertEqual(self.proto.ourVersionString, self.proto.otherVersionString)",
            "        self.assertTrue(kexInit[0])",
            "",
            "    def test_service(self):",
            "        \"\"\"",
            "        Test that the transport can set the running service and dispatches",
            "        packets to the service's packetReceived method.",
            "        \"\"\"",
            "        service = MockService()",
            "        self.proto.setService(service)",
            "        self.assertEqual(self.proto.service, service)",
            "        self.assertTrue(service.started)",
            "        self.proto.dispatchMessage(0xFF, b\"test\")",
            "        self.assertEqual(self.packets, [(0xFF, b\"test\")])",
            "",
            "        service2 = MockService()",
            "        self.proto.setService(service2)",
            "        self.assertTrue(service2.started)",
            "        self.assertTrue(service.stopped)",
            "",
            "        self.proto.connectionLost(None)",
            "        self.assertTrue(service2.stopped)",
            "",
            "    def test_avatar(self):",
            "        \"\"\"",
            "        Test that the transport notifies the avatar of disconnections.",
            "        \"\"\"",
            "        disconnected = [False]",
            "",
            "        def logout():",
            "            disconnected[0] = True",
            "",
            "        self.proto.logoutFunction = logout",
            "        self.proto.avatar = True",
            "",
            "        self.proto.connectionLost(None)",
            "        self.assertTrue(disconnected[0])",
            "",
            "    def test_isEncrypted(self):",
            "        \"\"\"",
            "        Test that the transport accurately reflects its encrypted status.",
            "        \"\"\"",
            "        self.assertFalse(self.proto.isEncrypted(\"in\"))",
            "        self.assertFalse(self.proto.isEncrypted(\"out\"))",
            "        self.assertFalse(self.proto.isEncrypted(\"both\"))",
            "        self.proto.currentEncryptions = MockCipher()",
            "        self.assertTrue(self.proto.isEncrypted(\"in\"))",
            "        self.assertTrue(self.proto.isEncrypted(\"out\"))",
            "        self.assertTrue(self.proto.isEncrypted(\"both\"))",
            "        self.proto.currentEncryptions = transport.SSHCiphers(",
            "            b\"none\", b\"none\", b\"none\", b\"none\"",
            "        )",
            "        self.assertFalse(self.proto.isEncrypted(\"in\"))",
            "        self.assertFalse(self.proto.isEncrypted(\"out\"))",
            "        self.assertFalse(self.proto.isEncrypted(\"both\"))",
            "",
            "        self.assertRaises(TypeError, self.proto.isEncrypted, \"bad\")",
            "",
            "    def test_isVerified(self):",
            "        \"\"\"",
            "        Test that the transport accurately reflects its verified status.",
            "        \"\"\"",
            "        self.assertFalse(self.proto.isVerified(\"in\"))",
            "        self.assertFalse(self.proto.isVerified(\"out\"))",
            "        self.assertFalse(self.proto.isVerified(\"both\"))",
            "        self.proto.currentEncryptions = MockCipher()",
            "        self.assertTrue(self.proto.isVerified(\"in\"))",
            "        self.assertTrue(self.proto.isVerified(\"out\"))",
            "        self.assertTrue(self.proto.isVerified(\"both\"))",
            "        self.proto.currentEncryptions = transport.SSHCiphers(",
            "            b\"none\", b\"none\", b\"none\", b\"none\"",
            "        )",
            "        self.assertFalse(self.proto.isVerified(\"in\"))",
            "        self.assertFalse(self.proto.isVerified(\"out\"))",
            "        self.assertFalse(self.proto.isVerified(\"both\"))",
            "",
            "        self.assertRaises(TypeError, self.proto.isVerified, \"bad\")",
            "",
            "    def test_loseConnection(self):",
            "        \"\"\"",
            "        Test that loseConnection sends a disconnect message and closes the",
            "        connection.",
            "        \"\"\"",
            "        disconnected = [False]",
            "",
            "        def stubLoseConnection():",
            "            disconnected[0] = True",
            "",
            "        self.transport.loseConnection = stubLoseConnection",
            "        self.proto.loseConnection()",
            "        self.assertEqual(self.packets[0][0], transport.MSG_DISCONNECT)",
            "        self.assertEqual(",
            "            self.packets[0][1][3:4], bytes((transport.DISCONNECT_CONNECTION_LOST,))",
            "        )",
            "",
            "    def test_badVersion(self):",
            "        \"\"\"",
            "        Test that the transport disconnects when it receives a bad version.",
            "        \"\"\"",
            "",
            "        def testBad(version):",
            "            self.packets = []",
            "            self.proto.gotVersion = False",
            "            disconnected = [False]",
            "",
            "            def stubLoseConnection():",
            "                disconnected[0] = True",
            "",
            "            self.transport.loseConnection = stubLoseConnection",
            "            for c in iterbytes(version + b\"\\r\\n\"):",
            "                self.proto.dataReceived(c)",
            "            self.assertTrue(disconnected[0])",
            "            self.assertEqual(self.packets[0][0], transport.MSG_DISCONNECT)",
            "            self.assertEqual(",
            "                self.packets[0][1][3:4],",
            "                bytes((transport.DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED,)),",
            "            )",
            "",
            "        testBad(b\"SSH-1.5-OpenSSH\")",
            "        testBad(b\"SSH-3.0-Twisted\")",
            "        testBad(b\"GET / HTTP/1.1\")",
            "",
            "    def test_dataBeforeVersion(self):",
            "        \"\"\"",
            "        Test that the transport ignores data sent before the version string.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(proto_helpers.StringTransport())",
            "        data = (",
            "            b\"\"\"here's some stuff beforehand",
            "here's some other stuff",
            "\"\"\"",
            "            + proto.ourVersionString",
            "            + b\"\\r\\n\"",
            "        )",
            "        [proto.dataReceived(c) for c in iterbytes(data)]",
            "        self.assertTrue(proto.gotVersion)",
            "        self.assertEqual(proto.otherVersionString, proto.ourVersionString)",
            "",
            "    def test_compatabilityVersion(self):",
            "        \"\"\"",
            "        Test that the transport treats the compatibility version (1.99)",
            "        as equivalent to version 2.0.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(proto_helpers.StringTransport())",
            "        proto.dataReceived(b\"SSH-1.99-OpenSSH\\n\")",
            "        self.assertTrue(proto.gotVersion)",
            "        self.assertEqual(proto.otherVersionString, b\"SSH-1.99-OpenSSH\")",
            "",
            "    def test_dataReceivedSSHVersionUnixNewline(self):",
            "        \"\"\"",
            "        It can parse the SSH version string even when it ends only in",
            "        Unix newlines (CR) and does not follows the RFC 4253 to use",
            "        network newlines (CR LF).",
            "        \"\"\"",
            "        sut = MockTransportBase()",
            "        sut.makeConnection(proto_helpers.StringTransport())",
            "",
            "        sut.dataReceived(b\"SSH-2.0-PoorSSHD Some-comment here\\n\" b\"more-data\")",
            "",
            "        self.assertTrue(sut.gotVersion)",
            "        self.assertEqual(sut.otherVersionString, b\"SSH-2.0-PoorSSHD Some-comment here\")",
            "",
            "    def test_dataReceivedSSHVersionTrailingSpaces(self):",
            "        \"\"\"",
            "        The trailing spaces from SSH version comment are not removed.",
            "",
            "        The SSH version string needs to be kept as received",
            "        (without CR LF end of line) as they are used in the host",
            "        authentication process.",
            "",
            "        This can happen with a Bitvise SSH server which hides its version.",
            "        \"\"\"",
            "        sut = MockTransportBase()",
            "        sut.makeConnection(proto_helpers.StringTransport())",
            "",
            "        sut.dataReceived(",
            "            b\"SSH-2.0-9.99 FlowSsh: Bitvise SSH Server (WinSSHD) \\r\\n\" b\"more-data\"",
            "        )",
            "",
            "        self.assertTrue(sut.gotVersion)",
            "        self.assertEqual(",
            "            sut.otherVersionString,",
            "            b\"SSH-2.0-9.99 FlowSsh: Bitvise SSH Server (WinSSHD) \",",
            "        )",
            "",
            "    def test_supportedVersionsAreAllowed(self):",
            "        \"\"\"",
            "        If an unusual SSH version is received and is included in",
            "        C{supportedVersions}, an unsupported version error is not emitted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.supportedVersions = (b\"9.99\",)",
            "        proto.makeConnection(proto_helpers.StringTransport())",
            "        proto.dataReceived(b\"SSH-9.99-OpenSSH\\n\")",
            "        self.assertFalse(proto.gotUnsupportedVersion)",
            "",
            "    def test_unsupportedVersionsCallUnsupportedVersionReceived(self):",
            "        \"\"\"",
            "        If an unusual SSH version is received and is not included in",
            "        C{supportedVersions}, an unsupported version error is emitted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.supportedVersions = (b\"2.0\",)",
            "        proto.makeConnection(proto_helpers.StringTransport())",
            "        proto.dataReceived(b\"SSH-9.99-OpenSSH\\n\")",
            "        self.assertEqual(b\"9.99\", proto.gotUnsupportedVersion)",
            "",
            "    def test_badPackets(self):",
            "        \"\"\"",
            "        Test that the transport disconnects with an error when it receives",
            "        bad packets.",
            "        \"\"\"",
            "",
            "        def testBad(packet, error=transport.DISCONNECT_PROTOCOL_ERROR):",
            "            self.packets = []",
            "            self.proto.buf = packet",
            "            self.assertIsNone(self.proto.getPacket())",
            "            self.assertEqual(len(self.packets), 1)",
            "            self.assertEqual(self.packets[0][0], transport.MSG_DISCONNECT)",
            "            self.assertEqual(self.packets[0][1][3:4], bytes((error,)))",
            "",
            "        testBad(b\"\\xff\" * 8)  # big packet",
            "        testBad(b\"\\x00\\x00\\x00\\x05\\x00BCDE\")  # length not modulo blocksize",
            "        oldEncryptions = self.proto.currentEncryptions",
            "        self.proto.currentEncryptions = MockCipher()",
            "        testBad(",
            "            b\"\\x00\\x00\\x00\\x08\\x06AB123456\", transport.DISCONNECT_MAC_ERROR  # bad MAC",
            "        )",
            "        self.proto.currentEncryptions.decrypt = lambda x: x[:-1]",
            "        testBad(b\"\\x00\\x00\\x00\\x08\\x06BCDEFGHIJK\")  # bad decryption",
            "        self.proto.currentEncryptions = oldEncryptions",
            "        self.proto.incomingCompression = MockCompression()",
            "",
            "        def stubDecompress(payload):",
            "            raise Exception(\"bad compression\")",
            "",
            "        self.proto.incomingCompression.decompress = stubDecompress",
            "        testBad(",
            "            b\"\\x00\\x00\\x00\\x04\\x00BCDE\",  # bad decompression",
            "            transport.DISCONNECT_COMPRESSION_ERROR,",
            "        )",
            "        self.flushLoggedErrors()",
            "",
            "    def test_unimplementedPackets(self):",
            "        \"\"\"",
            "        Test that unimplemented packet types cause MSG_UNIMPLEMENTED packets",
            "        to be sent.",
            "        \"\"\"",
            "        seqnum = self.proto.incomingPacketSequence",
            "",
            "        def checkUnimplemented(seqnum=seqnum):",
            "            self.assertEqual(self.packets[0][0], transport.MSG_UNIMPLEMENTED)",
            "            self.assertEqual(self.packets[0][1][3:4], bytes((seqnum,)))",
            "            self.proto.packets = []",
            "            seqnum += 1",
            "",
            "        self.proto.dispatchMessage(40, b\"\")",
            "        checkUnimplemented()",
            "        transport.messages[41] = b\"MSG_fiction\"",
            "        self.proto.dispatchMessage(41, b\"\")",
            "        checkUnimplemented()",
            "        self.proto.dispatchMessage(60, b\"\")",
            "        checkUnimplemented()",
            "        self.proto.setService(MockService())",
            "        self.proto.dispatchMessage(70, b\"\")",
            "        checkUnimplemented()",
            "        self.proto.dispatchMessage(71, b\"\")",
            "        checkUnimplemented()",
            "",
            "    def test_multipleClasses(self):",
            "        \"\"\"",
            "        Test that multiple instances have distinct states.",
            "        \"\"\"",
            "        proto = self.proto",
            "        proto.dataReceived(self.transport.value())",
            "        proto.currentEncryptions = MockCipher()",
            "        proto.outgoingCompression = MockCompression()",
            "        proto.incomingCompression = MockCompression()",
            "        proto.setService(MockService())",
            "        proto2 = MockTransportBase()",
            "        proto2.makeConnection(proto_helpers.StringTransport())",
            "        proto2.sendIgnore(b\"\")",
            "        self.assertNotEqual(proto.gotVersion, proto2.gotVersion)",
            "        self.assertNotEqual(proto.transport, proto2.transport)",
            "        self.assertNotEqual(proto.outgoingPacketSequence, proto2.outgoingPacketSequence)",
            "        self.assertNotEqual(proto.incomingPacketSequence, proto2.incomingPacketSequence)",
            "        self.assertNotEqual(proto.currentEncryptions, proto2.currentEncryptions)",
            "        self.assertNotEqual(proto.service, proto2.service)",
            "",
            "",
            "class BaseSSHTransportDHGroupExchangeBaseCase(BaseSSHTransportBaseCase):",
            "    \"\"\"",
            "    Diffie-Hellman group exchange tests for TransportBase.",
            "    \"\"\"",
            "",
            "    def test_getKey(self):",
            "        \"\"\"",
            "        Test that _getKey generates the correct keys.",
            "        \"\"\"",
            "        self.proto.kexAlg = self.kexAlgorithm",
            "        self.proto.sessionID = b\"EF\"",
            "",
            "        k1 = self.hashProcessor(b\"AB\" + b\"CD\" + b\"K\" + self.proto.sessionID).digest()",
            "        k2 = self.hashProcessor(b\"ABCD\" + k1).digest()",
            "        k3 = self.hashProcessor(b\"ABCD\" + k1 + k2).digest()",
            "        k4 = self.hashProcessor(b\"ABCD\" + k1 + k2 + k3).digest()",
            "        self.assertEqual(self.proto._getKey(b\"K\", b\"AB\", b\"CD\"), k1 + k2 + k3 + k4)",
            "",
            "",
            "class BaseSSHTransportDHGroupExchangeSHA1Tests(",
            "    BaseSSHTransportDHGroupExchangeBaseCase, DHGroupExchangeSHA1Mixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha1 tests for TransportBase.",
            "    \"\"\"",
            "",
            "",
            "class BaseSSHTransportDHGroupExchangeSHA256Tests(",
            "    BaseSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA256Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha256 tests for TransportBase.",
            "    \"\"\"",
            "",
            "",
            "class BaseSSHTransportEllipticCurveTests(",
            "    BaseSSHTransportDHGroupExchangeBaseCase, ECDHMixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    ecdh-sha2-nistp256 tests for TransportBase",
            "    \"\"\"",
            "",
            "",
            "@skipWithoutX25519",
            "class BaseSSHTransportCurve25519SHA256Tests(",
            "    BaseSSHTransportDHGroupExchangeBaseCase, Curve25519SHA256Mixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    curve25519-sha256 tests for TransportBase",
            "    \"\"\"",
            "",
            "",
            "class ServerAndClientSSHTransportBaseCase:",
            "    \"\"\"",
            "    Tests that need to be run on both the server and the client.",
            "    \"\"\"",
            "",
            "    def checkDisconnected(self, kind=None):",
            "        \"\"\"",
            "        Helper function to check if the transport disconnected.",
            "        \"\"\"",
            "        if kind is None:",
            "            kind = transport.DISCONNECT_PROTOCOL_ERROR",
            "        self.assertEqual(self.packets[-1][0], transport.MSG_DISCONNECT)",
            "        self.assertEqual(self.packets[-1][1][3:4], bytes((kind,)))",
            "",
            "    def connectModifiedProtocol(self, protoModification, kind=None):",
            "        \"\"\"",
            "        Helper function to connect a modified protocol to the test protocol",
            "        and test for disconnection.",
            "        \"\"\"",
            "        if kind is None:",
            "            kind = transport.DISCONNECT_KEY_EXCHANGE_FAILED",
            "        proto2 = self.klass()",
            "        protoModification(proto2)",
            "        proto2.makeConnection(proto_helpers.StringTransport())",
            "        self.proto.dataReceived(proto2.transport.value())",
            "        if kind:",
            "            self.checkDisconnected(kind)",
            "        return proto2",
            "",
            "    def test_disconnectIfCantMatchKex(self):",
            "        \"\"\"",
            "        Test that the transport disconnects if it can't match the key",
            "        exchange",
            "        \"\"\"",
            "",
            "        def blankKeyExchanges(proto2):",
            "            proto2.supportedKeyExchanges = []",
            "",
            "        self.connectModifiedProtocol(blankKeyExchanges)",
            "",
            "    def test_disconnectIfCantMatchKeyAlg(self):",
            "        \"\"\"",
            "        Like test_disconnectIfCantMatchKex, but for the key algorithm.",
            "        \"\"\"",
            "",
            "        def blankPublicKeys(proto2):",
            "            proto2.supportedPublicKeys = []",
            "",
            "        self.connectModifiedProtocol(blankPublicKeys)",
            "",
            "    def test_disconnectIfCantMatchCompression(self):",
            "        \"\"\"",
            "        Like test_disconnectIfCantMatchKex, but for the compression.",
            "        \"\"\"",
            "",
            "        def blankCompressions(proto2):",
            "            proto2.supportedCompressions = []",
            "",
            "        self.connectModifiedProtocol(blankCompressions)",
            "",
            "    def test_disconnectIfCantMatchCipher(self):",
            "        \"\"\"",
            "        Like test_disconnectIfCantMatchKex, but for the encryption.",
            "        \"\"\"",
            "",
            "        def blankCiphers(proto2):",
            "            proto2.supportedCiphers = []",
            "",
            "        self.connectModifiedProtocol(blankCiphers)",
            "",
            "    def test_disconnectIfCantMatchMAC(self):",
            "        \"\"\"",
            "        Like test_disconnectIfCantMatchKex, but for the MAC.",
            "        \"\"\"",
            "",
            "        def blankMACs(proto2):",
            "            proto2.supportedMACs = []",
            "",
            "        self.connectModifiedProtocol(blankMACs)",
            "",
            "    def test_getPeer(self):",
            "        \"\"\"",
            "        Test that the transport's L{getPeer} method returns an",
            "        L{SSHTransportAddress} with the L{IAddress} of the peer.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.proto.getPeer(),",
            "            address.SSHTransportAddress(self.proto.transport.getPeer()),",
            "        )",
            "",
            "    def test_getHost(self):",
            "        \"\"\"",
            "        Test that the transport's L{getHost} method returns an",
            "        L{SSHTransportAddress} with the L{IAddress} of the host.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.proto.getHost(),",
            "            address.SSHTransportAddress(self.proto.transport.getHost()),",
            "        )",
            "",
            "",
            "class ServerSSHTransportBaseCase(ServerAndClientSSHTransportBaseCase):",
            "    \"\"\"",
            "    Base case for SSHServerTransport tests.",
            "    \"\"\"",
            "",
            "    klass: Optional[Type[transport.SSHTransportBase]] = transport.SSHServerTransport",
            "",
            "    def setUp(self):",
            "        TransportTestCase.setUp(self)",
            "        self.proto.factory = MockFactory()",
            "        self.proto.factory.startFactory()",
            "",
            "    def tearDown(self):",
            "        TransportTestCase.tearDown(self)",
            "        self.proto.factory.stopFactory()",
            "        del self.proto.factory",
            "",
            "",
            "class ServerSSHTransportTests(ServerSSHTransportBaseCase, TransportTestCase):",
            "    \"\"\"",
            "    Tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "    def test_KEXINITMultipleAlgorithms(self):",
            "        \"\"\"",
            "        Receiving a KEXINIT packet listing multiple supported algorithms will",
            "        set up the first common algorithm found in the client's preference",
            "        list.",
            "        \"\"\"",
            "        self.proto.dataReceived(",
            "            b\"SSH-2.0-Twisted\\r\\n\\x00\\x00\\x01\\xf4\\x04\\x14\"",
            "            b\"\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\"",
            "            b\"\\x99\\x00\\x00\\x00bdiffie-hellman-group1-sha1,diffie-hellman-g\"",
            "            b\"roup-exchange-sha1,diffie-hellman-group-exchange-sha256\\x00\"",
            "            b\"\\x00\\x00\\x0fssh-dss,ssh-rsa\\x00\\x00\\x00\\x85aes128-ctr,aes128-\"",
            "            b\"cbc,aes192-ctr,aes192-cbc,aes256-ctr,aes256-cbc,cast128-ctr,c\"",
            "            b\"ast128-cbc,blowfish-ctr,blowfish-cbc,3des-ctr,3des-cbc\\x00\"",
            "            b\"\\x00\\x00\\x85aes128-ctr,aes128-cbc,aes192-ctr,aes192-cbc,aes25\"",
            "            b\"6-ctr,aes256-cbc,cast128-ctr,cast128-cbc,blowfish-ctr,blowfis\"",
            "            b\"h-cbc,3des-ctr,3des-cbc\\x00\\x00\\x00\\x12hmac-md5,hmac-sha1\\x00\"",
            "            b\"\\x00\\x00\\x12hmac-md5,hmac-sha1\\x00\\x00\\x00\\tnone,zlib\\x00\\x00\"",
            "            b\"\\x00\\tnone,zlib\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"",
            "            b\"\\x00\\x00\\x99\\x99\\x99\\x99\"",
            "        )",
            "",
            "        # Even if as server we prefer diffie-hellman-group-exchange-sha256 the",
            "        # client preference is used, after skipping diffie-hellman-group1-sha1",
            "        self.assertEqual(self.proto.kexAlg, b\"diffie-hellman-group-exchange-sha1\")",
            "        self.assertEqual(self.proto.keyAlg, b\"ssh-dss\")",
            "        self.assertEqual(self.proto.outgoingCompressionType, b\"none\")",
            "        self.assertEqual(self.proto.incomingCompressionType, b\"none\")",
            "        self.assertFalse(self.proto._peerSupportsExtensions)",
            "        ne = self.proto.nextEncryptions",
            "        self.assertEqual(ne.outCipType, b\"aes128-ctr\")",
            "        self.assertEqual(ne.inCipType, b\"aes128-ctr\")",
            "        self.assertEqual(ne.outMACType, b\"hmac-md5\")",
            "        self.assertEqual(ne.inMACType, b\"hmac-md5\")",
            "",
            "    def test_KEXINITExtensionNegotiation(self):",
            "        \"\"\"",
            "        If the client sends \"ext-info-c\" in its key exchange algorithms,",
            "        then the server notes that the client supports extension",
            "        negotiation.  See RFC 8308, section 2.1.",
            "        \"\"\"",
            "        kexInitPacket = (",
            "            b\"\\x00\" * 16",
            "            + common.NS(b\"diffie-hellman-group-exchange-sha256,ext-info-c\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "        self.proto.ssh_KEXINIT(kexInitPacket)",
            "        self.assertEqual(self.proto.kexAlg, b\"diffie-hellman-group-exchange-sha256\")",
            "        self.assertTrue(self.proto._peerSupportsExtensions)",
            "",
            "    def test_ignoreGuessPacketKex(self):",
            "        \"\"\"",
            "        The client is allowed to send a guessed key exchange packet",
            "        after it sends the KEXINIT packet.  However, if the key exchanges",
            "        do not match, that guess packet must be ignored.  This tests that",
            "        the packet is ignored in the case of the key exchange method not",
            "        matching.",
            "        \"\"\"",
            "        kexInitPacket = (",
            "            b\"\\x00\" * 16",
            "            + (",
            "                b\"\".join(",
            "                    [",
            "                        common.NS(x)",
            "                        for x in [",
            "                            b\",\".join(y)",
            "                            for y in [",
            "                                self.proto.supportedKeyExchanges[::-1],",
            "                                self.proto.supportedPublicKeys,",
            "                                self.proto.supportedCiphers,",
            "                                self.proto.supportedCiphers,",
            "                                self.proto.supportedMACs,",
            "                                self.proto.supportedMACs,",
            "                                self.proto.supportedCompressions,",
            "                                self.proto.supportedCompressions,",
            "                                self.proto.supportedLanguages,",
            "                                self.proto.supportedLanguages,",
            "                            ]",
            "                        ]",
            "                    ]",
            "                )",
            "            )",
            "            + (b\"\\xff\\x00\\x00\\x00\\x00\")",
            "        )",
            "        self.proto.ssh_KEXINIT(kexInitPacket)",
            "        self.assertTrue(self.proto.ignoreNextPacket)",
            "        self.proto.ssh_DEBUG(b\"\\x01\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x00\")",
            "        self.assertTrue(self.proto.ignoreNextPacket)",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(b\"\\x00\\x00\\x08\\x00\")",
            "        self.assertFalse(self.proto.ignoreNextPacket)",
            "        self.assertEqual(self.packets, [])",
            "        self.proto.ignoreNextPacket = True",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST(b\"\\x00\\x00\\x08\\x00\" * 3)",
            "        self.assertFalse(self.proto.ignoreNextPacket)",
            "        self.assertEqual(self.packets, [])",
            "",
            "    def test_ignoreGuessPacketKey(self):",
            "        \"\"\"",
            "        Like test_ignoreGuessPacketKex, but for an incorrectly guessed",
            "        public key format.",
            "        \"\"\"",
            "        kexInitPacket = (",
            "            b\"\\x00\" * 16",
            "            + (",
            "                b\"\".join(",
            "                    [",
            "                        common.NS(x)",
            "                        for x in [",
            "                            b\",\".join(y)",
            "                            for y in [",
            "                                self.proto.supportedKeyExchanges,",
            "                                self.proto.supportedPublicKeys[::-1],",
            "                                self.proto.supportedCiphers,",
            "                                self.proto.supportedCiphers,",
            "                                self.proto.supportedMACs,",
            "                                self.proto.supportedMACs,",
            "                                self.proto.supportedCompressions,",
            "                                self.proto.supportedCompressions,",
            "                                self.proto.supportedLanguages,",
            "                                self.proto.supportedLanguages,",
            "                            ]",
            "                        ]",
            "                    ]",
            "                )",
            "            )",
            "            + (b\"\\xff\\x00\\x00\\x00\\x00\")",
            "        )",
            "        self.proto.ssh_KEXINIT(kexInitPacket)",
            "        self.assertTrue(self.proto.ignoreNextPacket)",
            "        self.proto.ssh_DEBUG(b\"\\x01\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x00\")",
            "        self.assertTrue(self.proto.ignoreNextPacket)",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(b\"\\x00\\x00\\x08\\x00\")",
            "        self.assertFalse(self.proto.ignoreNextPacket)",
            "        self.assertEqual(self.packets, [])",
            "        self.proto.ignoreNextPacket = True",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST(b\"\\x00\\x00\\x08\\x00\" * 3)",
            "        self.assertFalse(self.proto.ignoreNextPacket)",
            "        self.assertEqual(self.packets, [])",
            "",
            "    def assertKexDHInitResponse(self, kexAlgorithm, bits):",
            "        \"\"\"",
            "        Test that the KEXDH_INIT packet causes the server to send a",
            "        KEXDH_REPLY with the server's public key and a signature.",
            "",
            "        @param kexAlgorithm: The key exchange algorithm to use.",
            "        @type kexAlgorithm: L{str}",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [kexAlgorithm]",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\"]",
            "        self.proto.dataReceived(self.transport.value())",
            "",
            "        g, p = _kex.getDHGeneratorAndPrime(kexAlgorithm)",
            "        e = pow(g, 5000, p)",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(common.MP(e))",
            "        y = common.getMP(common.NS(b\"\\x99\" * (bits // 8)))[0]",
            "        f = _MPpow(self.proto.g, y, self.proto.p)",
            "        self.assertEqual(self.proto.dhSecretKeyPublicMP, f)",
            "        sharedSecret = _MPpow(e, y, self.proto.p)",
            "",
            "        h = sha1()",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob()))",
            "        h.update(common.MP(e))",
            "        h.update(f)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = self.proto.factory.privateKeys[b\"ssh-rsa\"].sign(exchangeHash)",
            "",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEXDH_REPLY,",
            "                    common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob())",
            "                    + f",
            "                    + common.NS(signature),",
            "                ),",
            "                (transport.MSG_NEWKEYS, b\"\"),",
            "            ],",
            "        )",
            "",
            "    def test_checkBad_KEX_ECDH_INIT_CurveName(self):",
            "        \"\"\"",
            "        Test that if the server receives a KEX_DH_GEX_REQUEST_OLD message",
            "        and the key exchange algorithm is not set, we raise a ConchError.",
            "        \"\"\"",
            "        self.proto.kexAlg = b\"bad-curve\"",
            "        self.proto.keyAlg = b\"ssh-rsa\"",
            "        self.assertRaises(",
            "            UnsupportedAlgorithm,",
            "            self.proto._ssh_KEX_ECDH_INIT,",
            "            common.NS(b\"unused-key\"),",
            "        )",
            "",
            "    def test_checkBad_KEX_INIT_CurveName(self):",
            "        \"\"\"",
            "        Test that if the server received a bad name for a curve",
            "        we raise an UnsupportedAlgorithm error.",
            "        \"\"\"",
            "        kexmsg = (",
            "            b\"\\xAA\" * 16",
            "            + common.NS(b\"ecdh-sha2-nistp256\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "",
            "        self.proto.ssh_KEXINIT(kexmsg)",
            "        self.assertRaises(AttributeError)",
            "        self.assertRaises(UnsupportedAlgorithm)",
            "",
            "    def test_KEXDH_INIT_GROUP14(self):",
            "        \"\"\"",
            "        KEXDH_INIT messages are processed when the",
            "        diffie-hellman-group14-sha1 key exchange algorithm is requested.",
            "        \"\"\"",
            "        self.assertKexDHInitResponse(b\"diffie-hellman-group14-sha1\", 2048)",
            "",
            "    def test_keySetup(self):",
            "        \"\"\"",
            "        Test that _keySetup sets up the next encryption keys.",
            "        \"\"\"",
            "        self.proto.kexAlg = b\"diffie-hellman-group14-sha1\"",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.assertEqual(self.packets[-1], (transport.MSG_NEWKEYS, b\"\"))",
            "        newKeys = [self.proto._getKey(c, b\"AB\", b\"EF\") for c in iterbytes(b\"ABCDEF\")]",
            "        self.assertEqual(",
            "            self.proto.nextEncryptions.keys,",
            "            (newKeys[1], newKeys[3], newKeys[0], newKeys[2], newKeys[5], newKeys[4]),",
            "        )",
            "",
            "    def test_keySetupWithExtInfo(self):",
            "        \"\"\"",
            "        If the client advertised support for extension negotiation, then",
            "        _keySetup sends SSH_MSG_EXT_INFO with the \"server-sig-algs\"",
            "        extension as the next packet following the server's first",
            "        SSH_MSG_NEWKEYS.  See RFC 8308, sections 2.4 and 3.1.",
            "        \"\"\"",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\", b\"rsa-sha2-256\", b\"rsa-sha2-512\"]",
            "        self.proto.kexAlg = b\"diffie-hellman-group14-sha1\"",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.proto._peerSupportsExtensions = True",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertEqual(self.packets[-2], (transport.MSG_NEWKEYS, b\"\"))",
            "        self.assertEqual(",
            "            self.packets[-1],",
            "            (",
            "                transport.MSG_EXT_INFO,",
            "                b\"\\x00\\x00\\x00\\x01\"",
            "                + common.NS(b\"server-sig-algs\")",
            "                + common.NS(b\"ssh-rsa,rsa-sha2-256,rsa-sha2-512\"),",
            "            ),",
            "        )",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.assertEqual(self.packets[-1], (transport.MSG_NEWKEYS, b\"\"))",
            "",
            "    def test_ECDH_keySetup(self):",
            "        \"\"\"",
            "        Test that _keySetup sets up the next encryption keys.",
            "        \"\"\"",
            "        self.proto.kexAlg = b\"ecdh-sha2-nistp256\"",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.assertEqual(self.packets[-1], (transport.MSG_NEWKEYS, b\"\"))",
            "        newKeys = [self.proto._getKey(c, b\"AB\", b\"EF\") for c in iterbytes(b\"ABCDEF\")]",
            "        self.assertEqual(",
            "            self.proto.nextEncryptions.keys,",
            "            (newKeys[1], newKeys[3], newKeys[0], newKeys[2], newKeys[5], newKeys[4]),",
            "        )",
            "",
            "    def test_NEWKEYS(self):",
            "        \"\"\"",
            "        Test that NEWKEYS transitions the keys in nextEncryptions to",
            "        currentEncryptions.",
            "        \"\"\"",
            "        self.test_KEXINITMultipleAlgorithms()",
            "",
            "        self.proto.nextEncryptions = transport.SSHCiphers(",
            "            b\"none\", b\"none\", b\"none\", b\"none\"",
            "        )",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIs(self.proto.currentEncryptions, self.proto.nextEncryptions)",
            "        self.assertIsNone(self.proto.outgoingCompression)",
            "        self.assertIsNone(self.proto.incomingCompression)",
            "        self.proto.outgoingCompressionType = b\"zlib\"",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNotNone(self.proto.outgoingCompression)",
            "        self.proto.incomingCompressionType = b\"zlib\"",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNotNone(self.proto.incomingCompression)",
            "",
            "    def test_SERVICE_REQUEST(self):",
            "        \"\"\"",
            "        Test that the SERVICE_REQUEST message requests and starts a",
            "        service.",
            "        \"\"\"",
            "        self.proto.ssh_SERVICE_REQUEST(common.NS(b\"ssh-userauth\"))",
            "        self.assertEqual(",
            "            self.packets, [(transport.MSG_SERVICE_ACCEPT, common.NS(b\"ssh-userauth\"))]",
            "        )",
            "        self.assertEqual(self.proto.service.name, b\"MockService\")",
            "",
            "    def test_disconnectNEWKEYSData(self):",
            "        \"\"\"",
            "        Test that NEWKEYS disconnects if it receives data.",
            "        \"\"\"",
            "        self.proto.ssh_NEWKEYS(b\"bad packet\")",
            "        self.checkDisconnected()",
            "",
            "    def test_disconnectSERVICE_REQUESTBadService(self):",
            "        \"\"\"",
            "        Test that SERVICE_REQUESTS disconnects if an unknown service is",
            "        requested.",
            "        \"\"\"",
            "        self.proto.ssh_SERVICE_REQUEST(common.NS(b\"no service\"))",
            "        self.checkDisconnected(transport.DISCONNECT_SERVICE_NOT_AVAILABLE)",
            "",
            "",
            "class ServerSSHTransportDHGroupExchangeBaseCase(ServerSSHTransportBaseCase):",
            "    \"\"\"",
            "    Diffie-Hellman group exchange tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "    def test_KEX_DH_GEX_REQUEST_OLD(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_REQUEST_OLD message causes the server",
            "        to reply with a KEX_DH_GEX_GROUP message with the correct",
            "        Diffie-Hellman group.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\"]",
            "        self.proto.dataReceived(self.transport.value())",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(b\"\\x00\\x00\\x04\\x00\")",
            "        dhGenerator, dhPrime = self.proto.factory.getPrimes().get(2048)[0]",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEX_DH_GEX_GROUP,",
            "                    common.MP(dhPrime) + b\"\\x00\\x00\\x00\\x01\\x02\",",
            "                )",
            "            ],",
            "        )",
            "        self.assertEqual(self.proto.g, 2)",
            "        self.assertEqual(self.proto.p, dhPrime)",
            "",
            "    def test_KEX_DH_GEX_REQUEST_OLD_badKexAlg(self):",
            "        \"\"\"",
            "        Test that if the server receives a KEX_DH_GEX_REQUEST_OLD message",
            "        and the key exchange algorithm is not set, we raise a ConchError.",
            "        \"\"\"",
            "        self.proto.kexAlg = None",
            "        self.assertRaises(ConchError, self.proto.ssh_KEX_DH_GEX_REQUEST_OLD, None)",
            "",
            "    def test_KEX_DH_GEX_REQUEST(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_REQUEST message causes the server to reply",
            "        with a KEX_DH_GEX_GROUP message with the correct Diffie-Hellman",
            "        group.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\"]",
            "        self.proto.dataReceived(self.transport.value())",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST(",
            "            b\"\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\" + b\"\\x00\\x00\\x0c\\x00\"",
            "        )",
            "        dhGenerator, dhPrime = self.proto.factory.getPrimes().get(2048)[0]",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEX_DH_GEX_GROUP,",
            "                    common.MP(dhPrime) + b\"\\x00\\x00\\x00\\x01\\x02\",",
            "                )",
            "            ],",
            "        )",
            "        self.assertEqual(self.proto.g, 2)",
            "        self.assertEqual(self.proto.p, dhPrime)",
            "",
            "    def test_KEX_DH_GEX_INIT_after_REQUEST_OLD(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_INIT message after the client sends",
            "        KEX_DH_GEX_REQUEST_OLD causes the server to send a KEX_DH_GEX_INIT",
            "        message with a public key and signature.",
            "        \"\"\"",
            "        self.test_KEX_DH_GEX_REQUEST_OLD()",
            "        e = pow(self.proto.g, 3, self.proto.p)",
            "        y = common.getMP(b\"\\x00\\x00\\x01\\x00\" + b\"\\x99\" * 512)[0]",
            "        self.assertEqual(self.proto.dhSecretKey.private_numbers().x, y)",
            "        f = _MPpow(self.proto.g, y, self.proto.p)",
            "        self.assertEqual(self.proto.dhSecretKeyPublicMP, f)",
            "        sharedSecret = _MPpow(e, y, self.proto.p)",
            "        h = self.hashProcessor()",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob()))",
            "        h.update(b\"\\x00\\x00\\x04\\x00\")",
            "        h.update(common.MP(self.proto.p))",
            "        h.update(common.MP(self.proto.g))",
            "        h.update(common.MP(e))",
            "        h.update(f)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        self.proto.ssh_KEX_DH_GEX_INIT(common.MP(e))",
            "        self.assertEqual(",
            "            self.packets[1:],",
            "            [",
            "                (",
            "                    transport.MSG_KEX_DH_GEX_REPLY,",
            "                    common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob())",
            "                    + f",
            "                    + common.NS(",
            "                        self.proto.factory.privateKeys[b\"ssh-rsa\"].sign(exchangeHash)",
            "                    ),",
            "                ),",
            "                (transport.MSG_NEWKEYS, b\"\"),",
            "            ],",
            "        )",
            "",
            "    def test_KEX_DH_GEX_INIT_after_REQUEST(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_INIT message after the client sends",
            "        KEX_DH_GEX_REQUEST causes the server to send a KEX_DH_GEX_INIT message",
            "        with a public key and signature.",
            "        \"\"\"",
            "        self.test_KEX_DH_GEX_REQUEST()",
            "        e = pow(self.proto.g, 3, self.proto.p)",
            "        y = common.getMP(b\"\\x00\\x00\\x01\\x00\" + b\"\\x99\" * 256)[0]",
            "        f = _MPpow(self.proto.g, y, self.proto.p)",
            "        sharedSecret = _MPpow(e, y, self.proto.p)",
            "",
            "        h = self.hashProcessor()",
            "",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob()))",
            "        h.update(b\"\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x0c\\x00\")",
            "        h.update(common.MP(self.proto.p))",
            "        h.update(common.MP(self.proto.g))",
            "        h.update(common.MP(e))",
            "        h.update(f)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        self.proto.ssh_KEX_DH_GEX_INIT(common.MP(e))",
            "        self.assertEqual(",
            "            self.packets[1],",
            "            (",
            "                transport.MSG_KEX_DH_GEX_REPLY,",
            "                common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob())",
            "                + f",
            "                + common.NS(",
            "                    self.proto.factory.privateKeys[b\"ssh-rsa\"].sign(exchangeHash)",
            "                ),",
            "            ),",
            "        )",
            "",
            "",
            "class ServerSSHTransportDHGroupExchangeSHA1Tests(",
            "    ServerSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA1Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha1 tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "",
            "class ServerSSHTransportDHGroupExchangeSHA256Tests(",
            "    ServerSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA256Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha256 tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "",
            "class ServerSSHTransportECDHBaseCase(ServerSSHTransportBaseCase):",
            "    \"\"\"",
            "    Elliptic Curve Diffie-Hellman tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "    def test_KEX_ECDH_INIT(self):",
            "        \"\"\"",
            "        Test that the KEXDH_INIT message causes the server to send a",
            "        KEXDH_REPLY with the server's public key and a signature.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\"]",
            "        self.proto.dataReceived(self.transport.value())",
            "",
            "        privKey = self.proto.factory.privateKeys[b\"ssh-rsa\"]",
            "        pubKey = self.proto.factory.publicKeys[b\"ssh-rsa\"]",
            "        ecPriv = self.proto._generateECPrivateKey()",
            "        ecPub = ecPriv.public_key()",
            "        encPub = self.proto._encodeECPublicKey(ecPub)",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(common.NS(encPub))",
            "",
            "        sharedSecret = self.proto._generateECSharedSecret(",
            "            ecPriv, self.proto._encodeECPublicKey(self.proto.ecPub)",
            "        )",
            "",
            "        h = self.hashProcessor()",
            "        h.update(common.NS(self.proto.otherVersionString))",
            "        h.update(common.NS(self.proto.ourVersionString))",
            "        h.update(common.NS(self.proto.otherKexInitPayload))",
            "        h.update(common.NS(self.proto.ourKexInitPayload))",
            "        h.update(common.NS(pubKey.blob()))",
            "        h.update(common.NS(encPub))",
            "        h.update(common.NS(self.proto._encodeECPublicKey(self.proto.ecPub)))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = privKey.sign(exchangeHash)",
            "",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEXDH_REPLY,",
            "                    common.NS(pubKey.blob())",
            "                    + common.NS(self.proto._encodeECPublicKey(self.proto.ecPub))",
            "                    + common.NS(signature),",
            "                ),",
            "                (transport.MSG_NEWKEYS, b\"\"),",
            "            ],",
            "        )",
            "",
            "",
            "class ServerSSHTransportECDHTests(",
            "    ServerSSHTransportECDHBaseCase, ECDHMixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    ecdh-sha2-nistp256 tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "",
            "@skipWithoutX25519",
            "class ServerSSHTransportCurve25519SHA256Tests(",
            "    ServerSSHTransportECDHBaseCase, Curve25519SHA256Mixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    curve25519-sha256 tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "",
            "class ClientSSHTransportBaseCase(ServerAndClientSSHTransportBaseCase):",
            "    \"\"\"",
            "    Base case for SSHClientTransport tests.",
            "    \"\"\"",
            "",
            "    klass: Optional[Type[transport.SSHTransportBase]] = transport.SSHClientTransport",
            "",
            "    def verifyHostKey(self, pubKey, fingerprint):",
            "        \"\"\"",
            "        Mock version of SSHClientTransport.verifyHostKey.",
            "        \"\"\"",
            "        self.calledVerifyHostKey = True",
            "        self.assertEqual(pubKey, self.blob)",
            "        self.assertEqual(",
            "            fingerprint.replace(b\":\", b\"\"), binascii.hexlify(md5(pubKey).digest())",
            "        )",
            "        return defer.succeed(True)",
            "",
            "    def setUp(self):",
            "        TransportTestCase.setUp(self)",
            "        self.blob = keys.Key.fromString(keydata.publicRSA_openssh).blob()",
            "        self.privObj = keys.Key.fromString(keydata.privateRSA_openssh)",
            "        self.calledVerifyHostKey = False",
            "        self.proto.verifyHostKey = self.verifyHostKey",
            "",
            "",
            "class ClientSSHTransportTests(ClientSSHTransportBaseCase, TransportTestCase):",
            "    \"\"\"",
            "    Tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "    def test_KEXINITMultipleAlgorithms(self):",
            "        \"\"\"",
            "        Receiving a KEXINIT packet listing multiple supported",
            "        algorithms will set up the first common algorithm, ordered after our",
            "        preference.",
            "        \"\"\"",
            "        self.proto.dataReceived(",
            "            b\"SSH-2.0-Twisted\\r\\n\\x00\\x00\\x01\\xf4\\x04\\x14\"",
            "            b\"\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\"",
            "            b\"\\x99\\x00\\x00\\x00bdiffie-hellman-group1-sha1,diffie-hellman-g\"",
            "            b\"roup-exchange-sha1,diffie-hellman-group-exchange-sha256\\x00\"",
            "            b\"\\x00\\x00\\x0fssh-dss,ssh-rsa\\x00\\x00\\x00\\x85aes128-ctr,aes128-\"",
            "            b\"cbc,aes192-ctr,aes192-cbc,aes256-ctr,aes256-cbc,cast128-ctr,c\"",
            "            b\"ast128-cbc,blowfish-ctr,blowfish-cbc,3des-ctr,3des-cbc\\x00\"",
            "            b\"\\x00\\x00\\x85aes128-ctr,aes128-cbc,aes192-ctr,aes192-cbc,aes25\"",
            "            b\"6-ctr,aes256-cbc,cast128-ctr,cast128-cbc,blowfish-ctr,blowfis\"",
            "            b\"h-cbc,3des-ctr,3des-cbc\\x00\\x00\\x00\\x12hmac-md5,hmac-sha1\\x00\"",
            "            b\"\\x00\\x00\\x12hmac-md5,hmac-sha1\\x00\\x00\\x00\\tzlib,none\\x00\\x00\"",
            "            b\"\\x00\\tzlib,none\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"",
            "            b\"\\x00\\x00\\x99\\x99\\x99\\x99\"",
            "        )",
            "        # Even if client prefer diffie-hellman-group1-sha1, we will go for",
            "        # diffie-hellman-group-exchange-sha256 as this what we prefer and is",
            "        # also supported by the server.",
            "        self.assertEqual(self.proto.kexAlg, b\"diffie-hellman-group-exchange-sha256\")",
            "        self.assertEqual(self.proto.keyAlg, b\"ssh-rsa\")",
            "        self.assertEqual(self.proto.outgoingCompressionType, b\"none\")",
            "        self.assertEqual(self.proto.incomingCompressionType, b\"none\")",
            "        ne = self.proto.nextEncryptions",
            "        self.assertEqual(ne.outCipType, b\"aes256-ctr\")",
            "        self.assertEqual(ne.inCipType, b\"aes256-ctr\")",
            "        self.assertEqual(ne.outMACType, b\"hmac-sha1\")",
            "        self.assertEqual(ne.inMACType, b\"hmac-sha1\")",
            "",
            "    def test_notImplementedClientMethods(self):",
            "        \"\"\"",
            "        verifyHostKey() should return a Deferred which fails with a",
            "        NotImplementedError exception.  connectionSecure() should raise",
            "        NotImplementedError().",
            "        \"\"\"",
            "        self.assertRaises(NotImplementedError, self.klass().connectionSecure)",
            "",
            "        def _checkRaises(f):",
            "            f.trap(NotImplementedError)",
            "",
            "        d = self.klass().verifyHostKey(None, None)",
            "        return d.addCallback(self.fail).addErrback(_checkRaises)",
            "",
            "    def assertKexInitResponseForDH(self, kexAlgorithm, bits):",
            "        \"\"\"",
            "        Test that a KEXINIT packet with a group1 or group14 key exchange",
            "        results in a correct KEXDH_INIT response.",
            "",
            "        @param kexAlgorithm: The key exchange algorithm to use",
            "        @type kexAlgorithm: L{str}",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [kexAlgorithm]",
            "",
            "        # Imitate reception of server key exchange request contained",
            "        # in data returned by self.transport.value()",
            "        self.proto.dataReceived(self.transport.value())",
            "",
            "        x = self.proto.dhSecretKey.private_numbers().x",
            "        self.assertEqual(common.MP(x)[5:], b\"\\x99\" * (bits // 8))",
            "",
            "        # Data sent to server should be a transport.MSG_KEXDH_INIT",
            "        # message containing our public key.",
            "        self.assertEqual(",
            "            self.packets, [(transport.MSG_KEXDH_INIT, self.proto.dhSecretKeyPublicMP)]",
            "        )",
            "",
            "    def test_KEXINIT_group14(self):",
            "        \"\"\"",
            "        KEXINIT messages requesting diffie-hellman-group14-sha1 result in",
            "        KEXDH_INIT responses.",
            "        \"\"\"",
            "        self.assertKexInitResponseForDH(b\"diffie-hellman-group14-sha1\", 2048)",
            "",
            "    def test_KEXINIT_badKexAlg(self):",
            "        \"\"\"",
            "        Test that the client raises a ConchError if it receives a",
            "        KEXINIT message but doesn't have a key exchange algorithm that we",
            "        understand.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [b\"diffie-hellman-group24-sha1\"]",
            "        data = self.transport.value().replace(b\"group14\", b\"group24\")",
            "        self.assertRaises(ConchError, self.proto.dataReceived, data)",
            "",
            "    def test_KEXINITExtensionNegotiation(self):",
            "        \"\"\"",
            "        If the server sends \"ext-info-s\" in its key exchange algorithms,",
            "        then the client notes that the server supports extension",
            "        negotiation.  See RFC 8308, section 2.1.",
            "        \"\"\"",
            "        kexInitPacket = (",
            "            b\"\\x00\" * 16",
            "            + common.NS(b\"diffie-hellman-group-exchange-sha256,ext-info-s\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "        self.proto.ssh_KEXINIT(kexInitPacket)",
            "        self.assertTrue(self.proto._peerSupportsExtensions)",
            "",
            "    def begin_KEXDH_REPLY(self):",
            "        \"\"\"",
            "        Utility for test_KEXDH_REPLY and",
            "        test_disconnectKEXDH_REPLYBadSignature.",
            "",
            "        Begins a Diffie-Hellman key exchange in the named group",
            "        Group-14 and computes information needed to return either a",
            "        correct or incorrect signature.",
            "",
            "        \"\"\"",
            "        self.test_KEXINIT_group14()",
            "",
            "        f = 2",
            "        fMP = common.MP(f)",
            "        x = self.proto.dhSecretKey.private_numbers().x",
            "        p = self.proto.p",
            "        sharedSecret = _MPpow(f, x, p)",
            "        h = sha1()",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.blob))",
            "        h.update(self.proto.dhSecretKeyPublicMP)",
            "        h.update(fMP)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = self.privObj.sign(exchangeHash)",
            "",
            "        return (exchangeHash, signature, common.NS(self.blob) + fMP)",
            "",
            "    def test_KEXDH_REPLY(self):",
            "        \"\"\"",
            "        Test that the KEXDH_REPLY message verifies the server.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEXDH_REPLY()",
            "",
            "        def _cbTestKEXDH_REPLY(value):",
            "            self.assertIsNone(value)",
            "            self.assertTrue(self.calledVerifyHostKey)",
            "            self.assertEqual(self.proto.sessionID, exchangeHash)",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_GROUP(packetStart + common.NS(signature))",
            "        d.addCallback(_cbTestKEXDH_REPLY)",
            "",
            "        return d",
            "",
            "    def test_keySetup(self):",
            "        \"\"\"",
            "        Test that _keySetup sets up the next encryption keys.",
            "        \"\"\"",
            "        self.proto.kexAlg = b\"diffie-hellman-group14-sha1\"",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.assertEqual(self.packets[-1], (transport.MSG_NEWKEYS, b\"\"))",
            "        newKeys = [self.proto._getKey(c, b\"AB\", b\"EF\") for c in iterbytes(b\"ABCDEF\")]",
            "        self.assertEqual(",
            "            self.proto.nextEncryptions.keys,",
            "            (newKeys[0], newKeys[2], newKeys[1], newKeys[3], newKeys[4], newKeys[5]),",
            "        )",
            "",
            "    def test_NEWKEYS(self):",
            "        \"\"\"",
            "        Test that NEWKEYS transitions the keys from nextEncryptions to",
            "        currentEncryptions.",
            "        \"\"\"",
            "        self.test_KEXINITMultipleAlgorithms()",
            "        secure = [False]",
            "",
            "        def stubConnectionSecure():",
            "            secure[0] = True",
            "",
            "        self.proto.connectionSecure = stubConnectionSecure",
            "",
            "        self.proto.nextEncryptions = transport.SSHCiphers(",
            "            b\"none\", b\"none\", b\"none\", b\"none\"",
            "        )",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertIsNot(self.proto.currentEncryptions, self.proto.nextEncryptions)",
            "",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNone(self.proto.outgoingCompression)",
            "        self.assertIsNone(self.proto.incomingCompression)",
            "        self.assertIs(self.proto.currentEncryptions, self.proto.nextEncryptions)",
            "        self.assertTrue(secure[0])",
            "        self.proto.outgoingCompressionType = b\"zlib\"",
            "        self.simulateKeyExchange(b\"AB\", b\"GH\")",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNotNone(self.proto.outgoingCompression)",
            "        self.proto.incomingCompressionType = b\"zlib\"",
            "        self.simulateKeyExchange(b\"AB\", b\"IJ\")",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNotNone(self.proto.incomingCompression)",
            "",
            "    def test_SERVICE_ACCEPT(self):",
            "        \"\"\"",
            "        Test that the SERVICE_ACCEPT packet starts the requested service.",
            "        \"\"\"",
            "        self.proto.instance = MockService()",
            "        self.proto.ssh_SERVICE_ACCEPT(b\"\\x00\\x00\\x00\\x0bMockService\")",
            "        self.assertTrue(self.proto.instance.started)",
            "",
            "    def test_requestService(self):",
            "        \"\"\"",
            "        Test that requesting a service sends a SERVICE_REQUEST packet.",
            "        \"\"\"",
            "        self.proto.requestService(MockService())",
            "        self.assertEqual(",
            "            self.packets,",
            "            [(transport.MSG_SERVICE_REQUEST, b\"\\x00\\x00\\x00\\x0bMockService\")],",
            "        )",
            "",
            "    def test_disconnectKEXDH_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEXDH_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEXDH_REPLY()",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_GROUP(packetStart + common.NS(b\"bad signature\"))",
            "        return d.addCallback(",
            "            lambda _: self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "        )",
            "",
            "    def test_disconnectKEX_ECDH_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEX_ECDH_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        kexmsg = (",
            "            b\"\\xAA\" * 16",
            "            + common.NS(b\"ecdh-sha2-nistp256\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "",
            "        self.proto.ssh_KEXINIT(kexmsg)",
            "",
            "        self.proto.dataReceived(b\"SSH-2.0-OpenSSH\\r\\n\")",
            "",
            "        self.proto.ecPriv = ec.generate_private_key(ec.SECP256R1(), default_backend())",
            "        self.proto.ecPub = self.proto.ecPriv.public_key()",
            "",
            "        # Generate the private key",
            "        thisPriv = ec.generate_private_key(ec.SECP256R1(), default_backend())",
            "        # Get the public key",
            "        thisPub = thisPriv.public_key()",
            "        encPub = thisPub.public_bytes(",
            "            serialization.Encoding.X962, serialization.PublicFormat.UncompressedPoint",
            "        )",
            "        self.proto.curve = ec.SECP256R1()",
            "",
            "        self.proto.kexAlg = b\"ecdh-sha2-nistp256\"",
            "",
            "        self.proto._ssh_KEX_ECDH_REPLY(",
            "            common.NS(MockFactory().getPublicKeys()[b\"ssh-rsa\"].blob())",
            "            + common.NS(encPub)",
            "            + common.NS(b\"bad-signature\")",
            "        )",
            "",
            "        self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "",
            "    def test_disconnectNEWKEYSData(self):",
            "        \"\"\"",
            "        Test that NEWKEYS disconnects if it receives data.",
            "        \"\"\"",
            "        self.proto.ssh_NEWKEYS(b\"bad packet\")",
            "        self.checkDisconnected()",
            "",
            "    def test_disconnectSERVICE_ACCEPT(self):",
            "        \"\"\"",
            "        Test that SERVICE_ACCEPT disconnects if the accepted protocol is",
            "        differet from the asked-for protocol.",
            "        \"\"\"",
            "        self.proto.instance = MockService()",
            "        self.proto.ssh_SERVICE_ACCEPT(b\"\\x00\\x00\\x00\\x03bad\")",
            "        self.checkDisconnected()",
            "",
            "    def test_noPayloadSERVICE_ACCEPT(self):",
            "        \"\"\"",
            "        Some commercial SSH servers don't send a payload with the",
            "        SERVICE_ACCEPT message.  Conch pretends that it got the correct",
            "        name of the service.",
            "        \"\"\"",
            "        self.proto.instance = MockService()",
            "        self.proto.ssh_SERVICE_ACCEPT(b\"\")  # no payload",
            "        self.assertTrue(self.proto.instance.started)",
            "        self.assertEqual(len(self.packets), 0)  # not disconnected",
            "",
            "",
            "class ClientSSHTransportDHGroupExchangeBaseCase(ClientSSHTransportBaseCase):",
            "    \"\"\"",
            "    Diffie-Hellman group exchange tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "    \"\"\"",
            "    1536-bit modulus from RFC 3526",
            "    \"\"\"",
            "    P1536 = int(",
            "        \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"",
            "        \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"",
            "        \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"",
            "        \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"",
            "        \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\"",
            "        \"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\"",
            "        \"83655D23DCA3AD961C62F356208552BB9ED529077096966D\"",
            "        \"670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF\",",
            "        16,",
            "    )",
            "",
            "    def test_KEXINIT_groupexchange(self):",
            "        \"\"\"",
            "        KEXINIT packet with a group-exchange key exchange results",
            "        in a KEX_DH_GEX_REQUEST message.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.dataReceived(self.transport.value())",
            "        # The response will include our advertised group sizes.",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEX_DH_GEX_REQUEST,",
            "                    b\"\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x20\\x00\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_KEX_DH_GEX_GROUP(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_GROUP message results in a",
            "        KEX_DH_GEX_INIT message with the client's Diffie-Hellman public key.",
            "        \"\"\"",
            "        self.test_KEXINIT_groupexchange()",
            "        self.proto.ssh_KEX_DH_GEX_GROUP(common.MP(self.P1536) + common.MP(2))",
            "        self.assertEqual(self.proto.p, self.P1536)",
            "        self.assertEqual(self.proto.g, 2)",
            "        x = self.proto.dhSecretKey.private_numbers().x",
            "        self.assertEqual(common.MP(x)[5:], b\"\\x99\" * 192)",
            "        self.assertEqual(",
            "            self.proto.dhSecretKeyPublicMP, common.MP(pow(2, x, self.P1536))",
            "        )",
            "        self.assertEqual(",
            "            self.packets[1:],",
            "            [(transport.MSG_KEX_DH_GEX_INIT, self.proto.dhSecretKeyPublicMP)],",
            "        )",
            "",
            "    def begin_KEX_DH_GEX_REPLY(self):",
            "        \"\"\"",
            "        Utility for test_KEX_DH_GEX_REPLY and",
            "        test_disconnectGEX_REPLYBadSignature.",
            "",
            "        Begins a Diffie-Hellman key exchange in an unnamed",
            "        (server-specified) group and computes information needed to",
            "        return either a correct or incorrect signature.",
            "        \"\"\"",
            "        self.test_KEX_DH_GEX_GROUP()",
            "        p = self.proto.p",
            "        f = 3",
            "        fMP = common.MP(f)",
            "        sharedSecret = _MPpow(f, self.proto.dhSecretKey.private_numbers().x, p)",
            "        h = self.hashProcessor()",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.blob))",
            "        # Here is the wire format for advertised min, pref and max DH sizes.",
            "        h.update(b\"\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x20\\x00\")",
            "        # And the selected group parameters.",
            "        h.update(common.MP(self.P1536) + common.MP(2))",
            "        h.update(self.proto.dhSecretKeyPublicMP)",
            "        h.update(fMP)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = self.privObj.sign(exchangeHash)",
            "",
            "        return (exchangeHash, signature, common.NS(self.blob) + fMP)",
            "",
            "    def test_KEX_DH_GEX_REPLY(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_REPLY message results in a verified",
            "        server.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEX_DH_GEX_REPLY()",
            "",
            "        def _cbTestKEX_DH_GEX_REPLY(value):",
            "            self.assertIsNone(value)",
            "            self.assertTrue(self.calledVerifyHostKey)",
            "            self.assertEqual(self.proto.sessionID, exchangeHash)",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_REPLY(packetStart + common.NS(signature))",
            "        d.addCallback(_cbTestKEX_DH_GEX_REPLY)",
            "        return d",
            "",
            "    def test_disconnectGEX_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEX_DH_GEX_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEX_DH_GEX_REPLY()",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_REPLY(packetStart + common.NS(b\"bad signature\"))",
            "        return d.addCallback(",
            "            lambda _: self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "        )",
            "",
            "    def test_disconnectKEX_ECDH_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEX_ECDH_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        kexmsg = (",
            "            b\"\\xAA\" * 16",
            "            + common.NS(b\"ecdh-sha2-nistp256\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "",
            "        self.proto.ssh_KEXINIT(kexmsg)",
            "",
            "        self.proto.dataReceived(b\"SSH-2.0-OpenSSH\\r\\n\")",
            "",
            "        self.proto.ecPriv = ec.generate_private_key(ec.SECP256R1(), default_backend())",
            "        self.proto.ecPub = self.proto.ecPriv.public_key()",
            "",
            "        # Generate the private key",
            "        thisPriv = ec.generate_private_key(ec.SECP256R1(), default_backend())",
            "        # Get the public key",
            "        thisPub = thisPriv.public_key()",
            "        encPub = thisPub.public_bytes(",
            "            serialization.Encoding.X962, serialization.PublicFormat.UncompressedPoint",
            "        )",
            "        self.proto.curve = ec.SECP256R1()",
            "",
            "        self.proto.kexAlg = b\"ecdh-sha2-nistp256\"",
            "",
            "        self.proto._ssh_KEX_ECDH_REPLY(",
            "            common.NS(MockFactory().getPublicKeys()[b\"ssh-rsa\"].blob())",
            "            + common.NS(encPub)",
            "            + common.NS(b\"bad-signature\")",
            "        )",
            "",
            "        self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "",
            "",
            "class ClientSSHTransportDHGroupExchangeSHA1Tests(",
            "    ClientSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA1Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha1 tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "",
            "class ClientSSHTransportDHGroupExchangeSHA256Tests(",
            "    ClientSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA256Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha256 tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "",
            "class ClientSSHTransportECDHBaseCase(ClientSSHTransportBaseCase):",
            "    \"\"\"",
            "    Elliptic Curve Diffie-Hellman tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "    def test_KEXINIT(self):",
            "        \"\"\"",
            "        KEXINIT packet with an elliptic curve key exchange results",
            "        in a KEXDH_INIT message.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.dataReceived(self.transport.value())",
            "        # The response will include the client's ephemeral public key.",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEXDH_INIT,",
            "                    common.NS(self.proto._encodeECPublicKey(self.proto.ecPub)),",
            "                )",
            "            ],",
            "        )",
            "",
            "    def begin_KEXDH_REPLY(self):",
            "        \"\"\"",
            "        Utility for test_KEXDH_REPLY and",
            "        test_disconnectKEXDH_REPLYBadSignature.",
            "",
            "        Begins an Elliptic Curve Diffie-Hellman key exchange and computes",
            "        information needed to return either a correct or incorrect",
            "        signature.",
            "        \"\"\"",
            "        self.test_KEXINIT()",
            "",
            "        privKey = MockFactory().getPrivateKeys()[b\"ssh-rsa\"]",
            "        pubKey = MockFactory().getPublicKeys()[b\"ssh-rsa\"]",
            "        ecPriv = self.proto._generateECPrivateKey()",
            "        ecPub = ecPriv.public_key()",
            "        encPub = self.proto._encodeECPublicKey(ecPub)",
            "",
            "        sharedSecret = self.proto._generateECSharedSecret(",
            "            ecPriv, self.proto._encodeECPublicKey(self.proto.ecPub)",
            "        )",
            "",
            "        h = self.hashProcessor()",
            "        h.update(common.NS(self.proto.ourVersionString))",
            "        h.update(common.NS(self.proto.otherVersionString))",
            "        h.update(common.NS(self.proto.ourKexInitPayload))",
            "        h.update(common.NS(self.proto.otherKexInitPayload))",
            "        h.update(common.NS(pubKey.blob()))",
            "        h.update(common.NS(self.proto._encodeECPublicKey(self.proto.ecPub)))",
            "        h.update(common.NS(encPub))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = privKey.sign(exchangeHash)",
            "",
            "        return (exchangeHash, signature, common.NS(pubKey.blob()) + common.NS(encPub))",
            "",
            "    def test_KEXDH_REPLY(self):",
            "        \"\"\"",
            "        Test that the KEXDH_REPLY message completes the key exchange.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEXDH_REPLY()",
            "",
            "        def _cbTestKEXDH_REPLY(value):",
            "            self.assertIsNone(value)",
            "            self.assertTrue(self.calledVerifyHostKey)",
            "            self.assertEqual(self.proto.sessionID, exchangeHash)",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_GROUP(packetStart + common.NS(signature))",
            "        d.addCallback(_cbTestKEXDH_REPLY)",
            "        return d",
            "",
            "    def test_disconnectKEXDH_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEX_ECDH_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEXDH_REPLY()",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_GROUP(packetStart + common.NS(b\"bad signature\"))",
            "        return d.addCallback(",
            "            lambda _: self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "        )",
            "",
            "",
            "class ClientSSHTransportECDHTests(",
            "    ClientSSHTransportECDHBaseCase, ECDHMixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    ecdh-sha2-nistp256 tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "",
            "@skipWithoutX25519",
            "class ClientSSHTransportCurve25519SHA256Tests(",
            "    ClientSSHTransportECDHBaseCase, Curve25519SHA256Mixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    curve25519-sha256 tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "",
            "class GetMACTests(TestCase):",
            "    \"\"\"",
            "    Tests for L{SSHCiphers._getMAC}.",
            "    \"\"\"",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    def setUp(self):",
            "        self.ciphers = transport.SSHCiphers(b\"A\", b\"B\", b\"C\", b\"D\")",
            "",
            "    def getSharedSecret(self):",
            "        \"\"\"",
            "        Generate a new shared secret to be used with the tests.",
            "",
            "        @return: A new secret.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "        return insecureRandom(64)",
            "",
            "    def assertGetMAC(self, hmacName, hashProcessor, digestSize, blockPadSize):",
            "        \"\"\"",
            "        Check that when L{SSHCiphers._getMAC} is called with a supportd HMAC",
            "        algorithm name it returns a tuple of",
            "        (digest object, inner pad, outer pad, digest size) with a C{key}",
            "        attribute set to the value of the key supplied.",
            "",
            "        @param hmacName: Identifier of HMAC algorithm.",
            "        @type hmacName: L{bytes}",
            "",
            "        @param hashProcessor: Callable for the hash algorithm.",
            "        @type hashProcessor: C{callable}",
            "",
            "        @param digestSize: Size of the digest for algorithm.",
            "        @type digestSize: L{int}",
            "",
            "        @param blockPadSize: Size of padding applied to the shared secret to",
            "            match the block size.",
            "        @type blockPadSize: L{int}",
            "        \"\"\"",
            "        secret = self.getSharedSecret()",
            "",
            "        params = self.ciphers._getMAC(hmacName, secret)",
            "",
            "        key = secret[:digestSize] + b\"\\x00\" * blockPadSize",
            "        innerPad = bytes(ord(b) ^ 0x36 for b in iterbytes(key))",
            "        outerPad = bytes(ord(b) ^ 0x5C for b in iterbytes(key))",
            "        self.assertEqual((hashProcessor, innerPad, outerPad, digestSize), params)",
            "        self.assertEqual(key, params.key)",
            "",
            "    def test_hmacsha2512(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-sha2-512\"} MAC",
            "        algorithm name it returns a tuple of (sha512 digest object, inner pad,",
            "        outer pad, sha512 digest size) with a C{key} attribute set to the",
            "        value of the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-sha2-512\", sha512, digestSize=64, blockPadSize=64)",
            "",
            "    def test_hmacsha2384(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-sha2-384\"} MAC",
            "        algorithm name it returns a tuple of (sha384 digest object, inner pad,",
            "        outer pad, sha384 digest size) with a C{key} attribute set to the",
            "        value of the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-sha2-384\", sha384, digestSize=48, blockPadSize=80)",
            "",
            "    def test_hmacsha2256(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-sha2-256\"} MAC",
            "        algorithm name it returns a tuple of (sha256 digest object, inner pad,",
            "        outer pad, sha256 digest size) with a C{key} attribute set to the",
            "        value of the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-sha2-256\", sha256, digestSize=32, blockPadSize=32)",
            "",
            "    def test_hmacsha1(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-sha1\"} MAC",
            "        algorithm name it returns a tuple of (sha1 digest object, inner pad,",
            "        outer pad, sha1 digest size) with a C{key} attribute set to the value",
            "        of the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-sha1\", sha1, digestSize=20, blockPadSize=44)",
            "",
            "    def test_hmacmd5(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-md5\"} MAC",
            "        algorithm name it returns a tuple of (md5 digest object, inner pad,",
            "        outer pad, md5 digest size) with a C{key} attribute set to the value of",
            "        the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-md5\", md5, digestSize=16, blockPadSize=48)",
            "",
            "    def test_none(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"none\"} MAC algorithm",
            "        name it returns a tuple of (None, \"\", \"\", 0).",
            "        \"\"\"",
            "        key = self.getSharedSecret()",
            "",
            "        params = self.ciphers._getMAC(b\"none\", key)",
            "",
            "        self.assertEqual((None, b\"\", b\"\", 0), params)",
            "",
            "",
            "class SSHCiphersTests(TestCase):",
            "    \"\"\"",
            "    Tests for the SSHCiphers helper class.",
            "    \"\"\"",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    def test_init(self):",
            "        \"\"\"",
            "        Test that the initializer sets up the SSHCiphers object.",
            "        \"\"\"",
            "        ciphers = transport.SSHCiphers(b\"A\", b\"B\", b\"C\", b\"D\")",
            "        self.assertEqual(ciphers.outCipType, b\"A\")",
            "        self.assertEqual(ciphers.inCipType, b\"B\")",
            "        self.assertEqual(ciphers.outMACType, b\"C\")",
            "        self.assertEqual(ciphers.inMACType, b\"D\")",
            "",
            "    def test_getCipher(self):",
            "        \"\"\"",
            "        Test that the _getCipher method returns the correct cipher.",
            "        \"\"\"",
            "        ciphers = transport.SSHCiphers(b\"A\", b\"B\", b\"C\", b\"D\")",
            "        iv = key = b\"\\x00\" * 16",
            "        for cipName, (algClass, keySize, counter) in ciphers.cipherMap.items():",
            "            cip = ciphers._getCipher(cipName, iv, key)",
            "            if cipName == b\"none\":",
            "                self.assertIsInstance(cip, transport._DummyCipher)",
            "            else:",
            "                self.assertIsInstance(cip.algorithm, algClass)",
            "",
            "    def test_setKeysCiphers(self):",
            "        \"\"\"",
            "        Test that setKeys sets up the ciphers.",
            "        \"\"\"",
            "        key = b\"\\x00\" * 64",
            "        for cipName in transport.SSHTransportBase.supportedCiphers:",
            "            modName, keySize, counter = transport.SSHCiphers.cipherMap[cipName]",
            "            encCipher = transport.SSHCiphers(cipName, b\"none\", b\"none\", b\"none\")",
            "            decCipher = transport.SSHCiphers(b\"none\", cipName, b\"none\", b\"none\")",
            "            cip = encCipher._getCipher(cipName, key, key)",
            "            bs = cip.algorithm.block_size // 8",
            "            encCipher.setKeys(key, key, b\"\", b\"\", b\"\", b\"\")",
            "            decCipher.setKeys(b\"\", b\"\", key, key, b\"\", b\"\")",
            "            self.assertEqual(encCipher.encBlockSize, bs)",
            "            self.assertEqual(decCipher.decBlockSize, bs)",
            "            encryptor = cip.encryptor()",
            "            enc = encryptor.update(key[:bs])",
            "            enc2 = encryptor.update(key[:bs])",
            "            self.assertEqual(encCipher.encrypt(key[:bs]), enc)",
            "            self.assertEqual(encCipher.encrypt(key[:bs]), enc2)",
            "            self.assertEqual(decCipher.decrypt(enc), key[:bs])",
            "            self.assertEqual(decCipher.decrypt(enc2), key[:bs])",
            "",
            "    def test_setKeysMACs(self):",
            "        \"\"\"",
            "        Test that setKeys sets up the MACs.",
            "        \"\"\"",
            "        key = b\"\\x00\" * 64",
            "        for macName, mod in transport.SSHCiphers.macMap.items():",
            "            outMac = transport.SSHCiphers(b\"none\", b\"none\", macName, b\"none\")",
            "            inMac = transport.SSHCiphers(b\"none\", b\"none\", b\"none\", macName)",
            "            outMac.setKeys(b\"\", b\"\", b\"\", b\"\", key, b\"\")",
            "            inMac.setKeys(b\"\", b\"\", b\"\", b\"\", b\"\", key)",
            "            if mod:",
            "                ds = mod().digest_size",
            "            else:",
            "                ds = 0",
            "            self.assertEqual(inMac.verifyDigestSize, ds)",
            "            if mod:",
            "                mod, i, o, ds = outMac._getMAC(macName, key)",
            "            seqid = 0",
            "            data = key",
            "            packet = b\"\\x00\" * 4 + key",
            "            if mod:",
            "                mac = mod(o + mod(i + packet).digest()).digest()",
            "            else:",
            "                mac = b\"\"",
            "            self.assertEqual(outMac.makeMAC(seqid, data), mac)",
            "            self.assertTrue(inMac.verify(seqid, data, mac))",
            "",
            "    def test_makeMAC(self):",
            "        \"\"\"",
            "        L{SSHCiphers.makeMAC} computes the HMAC of an outgoing SSH message with",
            "        a particular sequence id and content data.",
            "        \"\"\"",
            "        # Use the test vectors given in the appendix of RFC 2104.",
            "        vectors = [",
            "            (b\"\\x0b\" * 16, b\"Hi There\", b\"9294727a3638bb1c13f48ef8158bfc9d\"),",
            "            (",
            "                b\"Jefe\",",
            "                b\"what do ya want for nothing?\",",
            "                b\"750c783e6ab0b503eaa86e310a5db738\",",
            "            ),",
            "            (b\"\\xAA\" * 16, b\"\\xDD\" * 50, b\"56be34521d144c88dbb8c733f0e8b3f6\"),",
            "        ]",
            "",
            "        for key, data, mac in vectors:",
            "            outMAC = transport.SSHCiphers(b\"none\", b\"none\", b\"hmac-md5\", b\"none\")",
            "            outMAC.outMAC = outMAC._getMAC(b\"hmac-md5\", key)",
            "            (seqid,) = struct.unpack(\">L\", data[:4])",
            "            shortened = data[4:]",
            "            self.assertEqual(",
            "                mac,",
            "                binascii.hexlify(outMAC.makeMAC(seqid, shortened)),",
            "                f\"Failed HMAC test vector; key={key!r} data={data!r}\",",
            "            )",
            "",
            "",
            "class TransportLoopbackTests(TestCase):",
            "    \"\"\"",
            "    Test the server transport and client transport against each other,",
            "    \"\"\"",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    def _runClientServer(self, mod):",
            "        \"\"\"",
            "        Run an async client and server, modifying each using the mod function",
            "        provided.  Returns a Deferred called back when both Protocols have",
            "        disconnected.",
            "",
            "        @type mod: C{func}",
            "        @rtype: C{defer.Deferred}",
            "        \"\"\"",
            "        factory = MockFactory()",
            "        server = transport.SSHServerTransport()",
            "        server.factory = factory",
            "        factory.startFactory()",
            "        server.errors = []",
            "        server.receiveError = lambda code, desc: server.errors.append((code, desc))",
            "        client = transport.SSHClientTransport()",
            "        client.verifyHostKey = lambda x, y: defer.succeed(None)",
            "        client.errors = []",
            "        client.receiveError = lambda code, desc: client.errors.append((code, desc))",
            "        client.connectionSecure = lambda: client.loseConnection()",
            "        server.supportedPublicKeys = list(server.factory.getPublicKeys().keys())",
            "        server = mod(server)",
            "        client = mod(client)",
            "",
            "        def check(ignored, server, client):",
            "            name = repr(",
            "                [",
            "                    server.supportedCiphers[0],",
            "                    server.supportedMACs[0],",
            "                    server.supportedKeyExchanges[0],",
            "                    server.supportedCompressions[0],",
            "                ]",
            "            )",
            "            self.assertEqual(client.errors, [])",
            "            self.assertEqual(",
            "                server.errors,",
            "                [(transport.DISCONNECT_CONNECTION_LOST, b\"user closed connection\")],",
            "            )",
            "            if server.supportedCiphers[0] == b\"none\":",
            "                self.assertFalse(server.isEncrypted(), name)",
            "                self.assertFalse(client.isEncrypted(), name)",
            "            else:",
            "                self.assertTrue(server.isEncrypted(), name)",
            "                self.assertTrue(client.isEncrypted(), name)",
            "            if server.supportedMACs[0] == b\"none\":",
            "                self.assertFalse(server.isVerified(), name)",
            "                self.assertFalse(client.isVerified(), name)",
            "            else:",
            "                self.assertTrue(server.isVerified(), name)",
            "                self.assertTrue(client.isVerified(), name)",
            "",
            "        d = loopback.loopbackAsync(server, client)",
            "        d.addCallback(check, server, client)",
            "        return d",
            "",
            "    def test_ciphers(self):",
            "        \"\"\"",
            "        Test that the client and server play nicely together, in all",
            "        the various combinations of ciphers.",
            "        \"\"\"",
            "        deferreds = []",
            "        for cipher in transport.SSHTransportBase.supportedCiphers + [b\"none\"]:",
            "",
            "            def setCipher(proto):",
            "                proto.supportedCiphers = [cipher]",
            "                return proto",
            "",
            "            deferreds.append(self._runClientServer(setCipher))",
            "        return defer.DeferredList(deferreds, fireOnOneErrback=True)",
            "",
            "    def test_macs(self):",
            "        \"\"\"",
            "        Like test_ciphers, but for the various MACs.",
            "        \"\"\"",
            "        deferreds = []",
            "        for mac in transport.SSHTransportBase.supportedMACs + [b\"none\"]:",
            "",
            "            def setMAC(proto):",
            "                proto.supportedMACs = [mac]",
            "                return proto",
            "",
            "            deferreds.append(self._runClientServer(setMAC))",
            "        return defer.DeferredList(deferreds, fireOnOneErrback=True)",
            "",
            "    def test_keyexchanges(self):",
            "        \"\"\"",
            "        Like test_ciphers, but for the various key exchanges.",
            "        \"\"\"",
            "        deferreds = []",
            "        for kexAlgorithm in transport.SSHTransportBase.supportedKeyExchanges:",
            "",
            "            def setKeyExchange(proto):",
            "                proto.supportedKeyExchanges = [kexAlgorithm]",
            "                return proto",
            "",
            "            deferreds.append(self._runClientServer(setKeyExchange))",
            "        return defer.DeferredList(deferreds, fireOnOneErrback=True)",
            "",
            "    def test_compressions(self):",
            "        \"\"\"",
            "        Like test_ciphers, but for the various compressions.",
            "        \"\"\"",
            "        deferreds = []",
            "        for compression in transport.SSHTransportBase.supportedCompressions:",
            "",
            "            def setCompression(proto):",
            "                proto.supportedCompressions = [compression]",
            "                return proto",
            "",
            "            deferreds.append(self._runClientServer(setCompression))",
            "        return defer.DeferredList(deferreds, fireOnOneErrback=True)"
        ],
        "afterPatchFile": [
            "# Copyright (c) Twisted Matrix Laboratories.",
            "# See LICENSE for details.",
            "",
            "\"\"\"",
            "Tests for ssh/transport.py and the classes therein.",
            "\"\"\"",
            "",
            "",
            "import binascii",
            "import re",
            "import string",
            "import struct",
            "import types",
            "from hashlib import md5, sha1, sha256, sha384, sha512",
            "from typing import Optional, Type",
            "",
            "from twisted import __version__ as twisted_version",
            "from twisted.conch.error import ConchError",
            "from twisted.conch.ssh import _kex, address, service",
            "from twisted.internet import defer",
            "from twisted.protocols import loopback",
            "from twisted.python import randbytes",
            "from twisted.python.compat import iterbytes",
            "from twisted.python.randbytes import insecureRandom",
            "from twisted.python.reflect import requireModule",
            "from twisted.test import proto_helpers",
            "from twisted.trial.unittest import TestCase",
            "",
            "pyasn1 = requireModule(\"pyasn1\")",
            "cryptography = requireModule(\"cryptography\")",
            "",
            "dependencySkip: Optional[str]",
            "if pyasn1 and cryptography:",
            "    dependencySkip = None",
            "    from cryptography.exceptions import UnsupportedAlgorithm",
            "    from cryptography.hazmat.backends import default_backend",
            "    from cryptography.hazmat.primitives import serialization",
            "    from cryptography.hazmat.primitives.asymmetric import dh, ec",
            "",
            "    from twisted.conch.ssh import common, factory, keys, transport",
            "    from twisted.conch.test import keydata",
            "",
            "    X25519_SUPPORTED = default_backend().x25519_supported()",
            "else:",
            "    if not pyasn1:",
            "        dependencySkip = \"Cannot run without PyASN1\"",
            "    elif not cryptography:",
            "        dependencySkip = \"can't run without cryptography\"",
            "    X25519_SUPPORTED = False",
            "",
            "    # fictional modules to make classes work",
            "    class transport:  # type: ignore[no-redef]",
            "        class SSHTransportBase:",
            "            pass",
            "",
            "        class SSHServerTransport:",
            "            pass",
            "",
            "        class SSHClientTransport:",
            "            pass",
            "",
            "    class factory:  # type: ignore[no-redef]",
            "        class SSHFactory:",
            "            pass",
            "",
            "    class common:  # type: ignore[no-redef]",
            "        @classmethod",
            "        def NS(self, arg):",
            "            return b\"\"",
            "",
            "",
            "def skipWithoutX25519(f):",
            "    if not X25519_SUPPORTED:",
            "        f.skip = \"x25519 not supported on this system\"",
            "    return f",
            "",
            "",
            "def _MPpow(x, y, z):",
            "    \"\"\"",
            "    Return the MP version of C{(x ** y) % z}.",
            "    \"\"\"",
            "    return common.MP(pow(x, y, z))",
            "",
            "",
            "class MockTransportBase(transport.SSHTransportBase):",
            "    \"\"\"",
            "    A base class for the client and server protocols.  Stores the messages",
            "    it receives instead of ignoring them.",
            "",
            "    @ivar errors: a list of tuples: (reasonCode, description)",
            "    @ivar unimplementeds: a list of integers: sequence number",
            "    @ivar debugs: a list of tuples: (alwaysDisplay, message, lang)",
            "    @ivar ignoreds: a list of strings: ignored data",
            "    \"\"\"",
            "",
            "    def connectionMade(self):",
            "        \"\"\"",
            "        Set up instance variables.",
            "        \"\"\"",
            "        transport.SSHTransportBase.connectionMade(self)",
            "        self.errors = []",
            "        self.unimplementeds = []",
            "        self.debugs = []",
            "        self.ignoreds = []",
            "        self.gotUnsupportedVersion = None",
            "",
            "    def _unsupportedVersionReceived(self, remoteVersion):",
            "        \"\"\"",
            "        Intercept unsupported version call.",
            "",
            "        @type remoteVersion: L{str}",
            "        \"\"\"",
            "        self.gotUnsupportedVersion = remoteVersion",
            "        return transport.SSHTransportBase._unsupportedVersionReceived(",
            "            self, remoteVersion",
            "        )",
            "",
            "    def receiveError(self, reasonCode, description):",
            "        \"\"\"",
            "        Store any errors received.",
            "",
            "        @type reasonCode: L{int}",
            "        @type description: L{str}",
            "        \"\"\"",
            "        self.errors.append((reasonCode, description))",
            "",
            "    def receiveUnimplemented(self, seqnum):",
            "        \"\"\"",
            "        Store any unimplemented packet messages.",
            "",
            "        @type seqnum: L{int}",
            "        \"\"\"",
            "        self.unimplementeds.append(seqnum)",
            "",
            "    def receiveDebug(self, alwaysDisplay, message, lang):",
            "        \"\"\"",
            "        Store any debug messages.",
            "",
            "        @type alwaysDisplay: L{bool}",
            "        @type message: L{str}",
            "        @type lang: L{str}",
            "        \"\"\"",
            "        self.debugs.append((alwaysDisplay, message, lang))",
            "",
            "    def ssh_IGNORE(self, packet):",
            "        \"\"\"",
            "        Store any ignored data.",
            "",
            "        @type packet: L{str}",
            "        \"\"\"",
            "        self.ignoreds.append(packet)",
            "",
            "",
            "class MockCipher:",
            "    \"\"\"",
            "    A mocked-up version of twisted.conch.ssh.transport.SSHCiphers.",
            "    \"\"\"",
            "",
            "    outCipType = b\"test\"",
            "    encBlockSize = 6",
            "    inCipType = b\"test\"",
            "    decBlockSize = 6",
            "    inMACType = b\"test\"",
            "    outMACType = b\"test\"",
            "    verifyDigestSize = 1",
            "    usedEncrypt = False",
            "    usedDecrypt = False",
            "    outMAC = (None, b\"\", b\"\", 1)",
            "    inMAC = (None, b\"\", b\"\", 1)",
            "    keys = ()",
            "",
            "    def encrypt(self, x):",
            "        \"\"\"",
            "        Called to encrypt the packet.  Simply record that encryption was used",
            "        and return the data unchanged.",
            "        \"\"\"",
            "        self.usedEncrypt = True",
            "        if (len(x) % self.encBlockSize) != 0:",
            "            raise RuntimeError(",
            "                \"length %i modulo blocksize %i is not 0: %i\"",
            "                % (len(x), self.encBlockSize, len(x) % self.encBlockSize)",
            "            )",
            "        return x",
            "",
            "    def decrypt(self, x):",
            "        \"\"\"",
            "        Called to decrypt the packet.  Simply record that decryption was used",
            "        and return the data unchanged.",
            "        \"\"\"",
            "        self.usedDecrypt = True",
            "        if (len(x) % self.encBlockSize) != 0:",
            "            raise RuntimeError(",
            "                \"length %i modulo blocksize %i is not 0: %i\"",
            "                % (len(x), self.decBlockSize, len(x) % self.decBlockSize)",
            "            )",
            "        return x",
            "",
            "    def makeMAC(self, outgoingPacketSequence, payload):",
            "        \"\"\"",
            "        Make a Message Authentication Code by sending the character value of",
            "        the outgoing packet.",
            "        \"\"\"",
            "        return bytes((outgoingPacketSequence,))",
            "",
            "    def verify(self, incomingPacketSequence, packet, macData):",
            "        \"\"\"",
            "        Verify the Message Authentication Code by checking that the packet",
            "        sequence number is the same.",
            "        \"\"\"",
            "        return bytes((incomingPacketSequence,)) == macData",
            "",
            "    def setKeys(self, ivOut, keyOut, ivIn, keyIn, macIn, macOut):",
            "        \"\"\"",
            "        Record the keys.",
            "        \"\"\"",
            "        self.keys = (ivOut, keyOut, ivIn, keyIn, macIn, macOut)",
            "",
            "",
            "class MockCompression:",
            "    \"\"\"",
            "    A mocked-up compression, based on the zlib interface.  Instead of",
            "    compressing, it reverses the data and adds a 0x66 byte to the end.",
            "    \"\"\"",
            "",
            "    def compress(self, payload):",
            "        return payload[::-1]  # reversed",
            "",
            "    def decompress(self, payload):",
            "        return payload[:-1][::-1]",
            "",
            "    def flush(self, kind):",
            "        return b\"\\x66\"",
            "",
            "",
            "class MockService(service.SSHService):",
            "    \"\"\"",
            "    A mocked-up service, based on twisted.conch.ssh.service.SSHService.",
            "",
            "    @ivar started: True if this service has been started.",
            "    @ivar stopped: True if this service has been stopped.",
            "    \"\"\"",
            "",
            "    name = b\"MockService\"",
            "    started = False",
            "    stopped = False",
            "    protocolMessages = {0xFF: \"MSG_TEST\", 71: \"MSG_fiction\"}",
            "",
            "    def logPrefix(self):",
            "        return \"MockService\"",
            "",
            "    def serviceStarted(self):",
            "        \"\"\"",
            "        Record that the service was started.",
            "        \"\"\"",
            "        self.started = True",
            "",
            "    def serviceStopped(self):",
            "        \"\"\"",
            "        Record that the service was stopped.",
            "        \"\"\"",
            "        self.stopped = True",
            "",
            "    def ssh_TEST(self, packet):",
            "        \"\"\"",
            "        A message that this service responds to.",
            "        \"\"\"",
            "        self.transport.sendPacket(0xFF, packet)",
            "",
            "",
            "class MockFactory(factory.SSHFactory):",
            "    \"\"\"",
            "    A mocked-up factory based on twisted.conch.ssh.factory.SSHFactory.",
            "    \"\"\"",
            "",
            "    services = {b\"ssh-userauth\": MockService}",
            "",
            "    def getPublicKeys(self):",
            "        \"\"\"",
            "        Return the public keys that authenticate this server.",
            "        \"\"\"",
            "        return {",
            "            b\"ssh-rsa\": keys.Key.fromString(keydata.publicRSA_openssh),",
            "            b\"ssh-dsa\": keys.Key.fromString(keydata.publicDSA_openssh),",
            "        }",
            "",
            "    def getPrivateKeys(self):",
            "        \"\"\"",
            "        Return the private keys that authenticate this server.",
            "        \"\"\"",
            "        return {",
            "            b\"ssh-rsa\": keys.Key.fromString(keydata.privateRSA_openssh),",
            "            b\"ssh-dsa\": keys.Key.fromString(keydata.privateDSA_openssh),",
            "        }",
            "",
            "    def getPrimes(self):",
            "        \"\"\"",
            "        Diffie-Hellman primes that can be used for key exchange algorithms",
            "        that use group exchange to establish a prime / generator group.",
            "",
            "        @return: The primes and generators.",
            "        @rtype: L{dict} mapping the key size to a C{list} of",
            "            C{(generator, prime)} tuple.",
            "        \"\"\"",
            "        # In these tests, we hardwire the prime values to those",
            "        # defined by the diffie-hellman-group14-sha1 key exchange",
            "        # algorithm, to avoid requiring a moduli file when running",
            "        # tests.",
            "        # See OpenSSHFactory.getPrimes.",
            "        group14 = _kex.getDHGeneratorAndPrime(b\"diffie-hellman-group14-sha1\")",
            "        return {2048: (group14,), 4096: ((5, 7),)}",
            "",
            "",
            "class MockOldFactoryPublicKeys(MockFactory):",
            "    \"\"\"",
            "    The old SSHFactory returned mappings from key names to strings from",
            "    getPublicKeys().  We return those here for testing.",
            "    \"\"\"",
            "",
            "    def getPublicKeys(self):",
            "        \"\"\"",
            "        We used to map key types to public key blobs as strings.",
            "        \"\"\"",
            "        keys = MockFactory.getPublicKeys(self)",
            "        for name, key in keys.items()[:]:",
            "            keys[name] = key.blob()",
            "        return keys",
            "",
            "",
            "class MockOldFactoryPrivateKeys(MockFactory):",
            "    \"\"\"",
            "    The old SSHFactory returned mappings from key names to cryptography key",
            "    objects from getPrivateKeys().  We return those here for testing.",
            "    \"\"\"",
            "",
            "    def getPrivateKeys(self):",
            "        \"\"\"",
            "        We used to map key types to cryptography key objects.",
            "        \"\"\"",
            "        keys = MockFactory.getPrivateKeys(self)",
            "        for name, key in keys.items()[:]:",
            "            keys[name] = key.keyObject",
            "        return keys",
            "",
            "",
            "def generatePredictableKey(transport):",
            "    p = transport.p",
            "    g = transport.g",
            "    bits = p.bit_length()",
            "    x = sum(0x9 << x for x in range(0, bits - 3, 4))",
            "    # The cryptography module doesn't let us create a secret key directly from",
            "    # an \"x\" value; we need to compute the public value ourselves.",
            "    y = pow(g, x, p)",
            "    try:",
            "        transport.dhSecretKey = dh.DHPrivateNumbers(",
            "            x, dh.DHPublicNumbers(y, dh.DHParameterNumbers(p, g))",
            "        ).private_key(default_backend())",
            "    except ValueError:",
            "        print(f\"\\np={p}\\ng={g}\\nx={x}\\n\")",
            "        raise",
            "    transport.dhSecretKeyPublicMP = common.MP(",
            "        transport.dhSecretKey.public_key().public_numbers().y",
            "    )",
            "",
            "",
            "class TransportTestCase(TestCase):",
            "    \"\"\"",
            "    Base class for transport test cases.",
            "    \"\"\"",
            "",
            "    klass: Optional[Type[transport.SSHTransportBase]] = None",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    def setUp(self):",
            "        self.transport = proto_helpers.StringTransport()",
            "        self.proto = self.klass()",
            "        self.packets = []",
            "",
            "        def secureRandom(len):",
            "            \"\"\"",
            "            Return a consistent entropy value",
            "            \"\"\"",
            "            return b\"\\x99\" * len",
            "",
            "        self.patch(randbytes, \"secureRandom\", secureRandom)",
            "        self.proto._startEphemeralDH = types.MethodType(",
            "            generatePredictableKey, self.proto",
            "        )",
            "",
            "        def stubSendPacket(messageType, payload):",
            "            self.packets.append((messageType, payload))",
            "",
            "        self.proto.makeConnection(self.transport)",
            "        # we just let the kex packet go into the transport",
            "        self.proto.sendPacket = stubSendPacket",
            "",
            "    def finishKeyExchange(self, proto):",
            "        \"\"\"",
            "        Deliver enough additional messages to C{proto} so that the key exchange",
            "        which is started in L{SSHTransportBase.connectionMade} completes and",
            "        non-key exchange messages can be sent and received.",
            "        \"\"\"",
            "        proto.dataReceived(b\"SSH-2.0-BogoClient-1.2i\\r\\n\")",
            "        proto.dispatchMessage(transport.MSG_KEXINIT, self._A_KEXINIT_MESSAGE)",
            "        proto._keySetup(b\"foo\", b\"bar\")",
            "        # SSHTransportBase can't handle MSG_NEWKEYS, or it would be the right",
            "        # thing to deliver next.  _newKeys won't work either, because",
            "        # sendKexInit (probably) hasn't been called.  sendKexInit is",
            "        # responsible for setting up certain state _newKeys relies on.  So,",
            "        # just change the key exchange state to what it would be when key",
            "        # exchange is finished.",
            "        proto._keyExchangeState = proto._KEY_EXCHANGE_NONE",
            "",
            "    def simulateKeyExchange(self, sharedSecret, exchangeHash):",
            "        \"\"\"",
            "        Finish a key exchange by calling C{_keySetup} with the given arguments.",
            "        Also do extra whitebox stuff to satisfy that method's assumption that",
            "        some kind of key exchange has actually taken place.",
            "        \"\"\"",
            "        self.proto._keyExchangeState = self.proto._KEY_EXCHANGE_REQUESTED",
            "        self.proto._blockedByKeyExchange = []",
            "        self.proto._keySetup(sharedSecret, exchangeHash)",
            "",
            "",
            "class DHGroupExchangeSHA1Mixin:",
            "    \"\"\"",
            "    Mixin for diffie-hellman-group-exchange-sha1 tests.",
            "    \"\"\"",
            "",
            "    kexAlgorithm = b\"diffie-hellman-group-exchange-sha1\"",
            "    hashProcessor = sha1",
            "",
            "",
            "class DHGroupExchangeSHA256Mixin:",
            "    \"\"\"",
            "    Mixin for diffie-hellman-group-exchange-sha256 tests.",
            "    \"\"\"",
            "",
            "    kexAlgorithm = b\"diffie-hellman-group-exchange-sha256\"",
            "    hashProcessor = sha256",
            "",
            "",
            "class ECDHMixin:",
            "    \"\"\"",
            "    Mixin for elliptic curve diffie-hellman tests.",
            "    \"\"\"",
            "",
            "    kexAlgorithm = b\"ecdh-sha2-nistp256\"",
            "    hashProcessor = sha256",
            "",
            "",
            "class Curve25519SHA256Mixin:",
            "    \"\"\"",
            "    Mixin for curve25519-sha256 tests.",
            "    \"\"\"",
            "",
            "    kexAlgorithm = b\"curve25519-sha256\"",
            "    hashProcessor = sha256",
            "",
            "",
            "class BaseSSHTransportBaseCase:",
            "    \"\"\"",
            "    Base case for TransportBase tests.",
            "    \"\"\"",
            "",
            "    klass: Optional[Type[transport.SSHTransportBase]] = MockTransportBase",
            "",
            "",
            "class BaseSSHTransportTests(BaseSSHTransportBaseCase, TransportTestCase):",
            "    \"\"\"",
            "    Test TransportBase. It implements the non-server/client specific",
            "    parts of the SSH transport protocol.",
            "    \"\"\"",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    _A_KEXINIT_MESSAGE = (",
            "        b\"\\xAA\" * 16",
            "        + common.NS(b\"diffie-hellman-group14-sha1\")",
            "        + common.NS(b\"ssh-rsa\")",
            "        + common.NS(b\"aes256-ctr\")",
            "        + common.NS(b\"aes256-ctr\")",
            "        + common.NS(b\"hmac-sha1\")",
            "        + common.NS(b\"hmac-sha1\")",
            "        + common.NS(b\"none\")",
            "        + common.NS(b\"none\")",
            "        + common.NS(b\"\")",
            "        + common.NS(b\"\")",
            "        + b\"\\x00\"",
            "        + b\"\\x00\\x00\\x00\\x00\"",
            "    )",
            "",
            "    def test_sendVersion(self):",
            "        \"\"\"",
            "        Test that the first thing sent over the connection is the version",
            "        string.  The 'softwareversion' part must consist of printable",
            "        US-ASCII characters, with the exception of whitespace characters and",
            "        the minus sign.",
            "",
            "        RFC 4253, section 4.2.",
            "        \"\"\"",
            "        # the other setup was done in the setup method",
            "        version = self.transport.value().split(b\"\\r\\n\", 1)[0]",
            "        self.assertEqual(version, b\"SSH-2.0-Twisted_\" + twisted_version.encode(\"ascii\"))",
            "        softwareVersion = version.decode(\"ascii\")[len(\"SSH-2.0-\") :]",
            "        # This is an inefficient regex, but it's simple to build.",
            "        softwareVersionRegex = (",
            "            r\"^(\"",
            "            + \"|\".join(",
            "                re.escape(c) for c in string.printable if c != \"-\" and not c.isspace()",
            "            )",
            "            + r\")*$\"",
            "        )",
            "        self.assertRegex(softwareVersion, softwareVersionRegex)",
            "",
            "    def test_dataReceiveVersionNotSentMemoryDOS(self):",
            "        \"\"\"",
            "        When the peer is not sending its SSH version but keeps sending data,",
            "        the connection is disconnected after 4KB to prevent buffering too",
            "        much and running our of memory.",
            "        \"\"\"",
            "        sut = MockTransportBase()",
            "        sut.makeConnection(self.transport)",
            "",
            "        # Data can be received over multiple chunks.",
            "        sut.dataReceived(b\"SSH-2-Server-Identifier\")",
            "        sut.dataReceived(b\"1234567890\" * 406)",
            "        sut.dataReceived(b\"1235678\")",
            "        self.assertFalse(self.transport.disconnecting)",
            "",
            "        # Here we are going over the limit.",
            "        sut.dataReceived(b\"1234567\")",
            "        # Once a lot of data is received without an SSH version string,",
            "        # the transport is disconnected.",
            "        self.assertTrue(self.transport.disconnecting)",
            "        self.assertIn(b\"Preventing a denial of service attack\", self.transport.value())",
            "",
            "    def test_sendPacketPlain(self):",
            "        \"\"\"",
            "        Test that plain (unencrypted, uncompressed) packets are sent",
            "        correctly.  The format is::",
            "            uint32 length (including type and padding length)",
            "            byte padding length",
            "            byte type",
            "            bytes[length-padding length-2] data",
            "            bytes[padding length] padding",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        self.transport.clear()",
            "        message = ord(\"A\")",
            "        payload = b\"BCDEFG\"",
            "        proto.sendPacket(message, payload)",
            "        value = self.transport.value()",
            "        self.assertEqual(value, b\"\\x00\\x00\\x00\\x0c\\x04ABCDEFG\\x99\\x99\\x99\\x99\")",
            "",
            "    def test_sendPacketEncrypted(self):",
            "        \"\"\"",
            "        Test that packets sent while encryption is enabled are sent",
            "        correctly.  The whole packet should be encrypted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        proto.currentEncryptions = testCipher = MockCipher()",
            "        message = ord(\"A\")",
            "        payload = b\"BC\"",
            "        self.transport.clear()",
            "        proto.sendPacket(message, payload)",
            "        self.assertTrue(testCipher.usedEncrypt)",
            "        value = self.transport.value()",
            "        self.assertEqual(",
            "            value,",
            "            # Four byte length prefix",
            "            b\"\\x00\\x00\\x00\\x08\"",
            "            # One byte padding length",
            "            b\"\\x04\"",
            "            # The actual application data",
            "            b\"ABC\"",
            "            # \"Random\" padding - see the secureRandom monkeypatch in setUp",
            "            b\"\\x99\\x99\\x99\\x99\"",
            "            # The MAC",
            "            b\"\\x02\",",
            "        )",
            "",
            "    def test_sendPacketCompressed(self):",
            "        \"\"\"",
            "        Test that packets sent while compression is enabled are sent",
            "        correctly.  The packet type and data should be encrypted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        proto.outgoingCompression = MockCompression()",
            "        self.transport.clear()",
            "        proto.sendPacket(ord(\"A\"), b\"B\")",
            "        value = self.transport.value()",
            "        self.assertEqual(",
            "            value, b\"\\x00\\x00\\x00\\x0c\\x08BA\\x66\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\"",
            "        )",
            "",
            "    def test_sendPacketBoth(self):",
            "        \"\"\"",
            "        Test that packets sent while compression and encryption are",
            "        enabled are sent correctly.  The packet type and data should be",
            "        compressed and then the whole packet should be encrypted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        proto.currentEncryptions = testCipher = MockCipher()",
            "        proto.outgoingCompression = MockCompression()",
            "        message = ord(\"A\")",
            "        payload = b\"BC\"",
            "        self.transport.clear()",
            "        proto.sendPacket(message, payload)",
            "        self.assertTrue(testCipher.usedEncrypt)",
            "        value = self.transport.value()",
            "        self.assertEqual(",
            "            value,",
            "            # Four byte length prefix",
            "            b\"\\x00\\x00\\x00\\x0e\"",
            "            # One byte padding length",
            "            b\"\\x09\"",
            "            # Compressed application data",
            "            b\"CBA\\x66\"",
            "            # \"Random\" padding - see the secureRandom monkeypatch in setUp",
            "            b\"\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\"",
            "            # The MAC",
            "            b\"\\x02\",",
            "        )",
            "",
            "    def test_getPacketPlain(self):",
            "        \"\"\"",
            "        Test that packets are retrieved correctly out of the buffer when",
            "        no encryption is enabled.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        self.transport.clear()",
            "        proto.sendPacket(ord(\"A\"), b\"BC\")",
            "        proto.buf = self.transport.value() + b\"extra\"",
            "        self.assertEqual(proto.getPacket(), b\"ABC\")",
            "        self.assertEqual(proto.buf, b\"extra\")",
            "",
            "    def test_getPacketEncrypted(self):",
            "        \"\"\"",
            "        Test that encrypted packets are retrieved correctly.",
            "        See test_sendPacketEncrypted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.sendKexInit = lambda: None  # don't send packets",
            "        proto.makeConnection(self.transport)",
            "        self.transport.clear()",
            "        proto.currentEncryptions = testCipher = MockCipher()",
            "        proto.sendPacket(ord(\"A\"), b\"BCD\")",
            "        value = self.transport.value()",
            "        proto.buf = value[: MockCipher.decBlockSize]",
            "        self.assertIsNone(proto.getPacket())",
            "        self.assertTrue(testCipher.usedDecrypt)",
            "        self.assertEqual(proto.first, b\"\\x00\\x00\\x00\\x0e\\x09A\")",
            "        proto.buf += value[MockCipher.decBlockSize :]",
            "        self.assertEqual(proto.getPacket(), b\"ABCD\")",
            "        self.assertEqual(proto.buf, b\"\")",
            "",
            "    def test_getPacketCompressed(self):",
            "        \"\"\"",
            "        Test that compressed packets are retrieved correctly.  See",
            "        test_sendPacketCompressed.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(self.transport)",
            "        self.finishKeyExchange(proto)",
            "        self.transport.clear()",
            "        proto.outgoingCompression = MockCompression()",
            "        proto.incomingCompression = proto.outgoingCompression",
            "        proto.sendPacket(ord(\"A\"), b\"BCD\")",
            "        proto.buf = self.transport.value()",
            "        self.assertEqual(proto.getPacket(), b\"ABCD\")",
            "",
            "    def test_getPacketBoth(self):",
            "        \"\"\"",
            "        Test that compressed and encrypted packets are retrieved correctly.",
            "        See test_sendPacketBoth.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.sendKexInit = lambda: None",
            "        proto.makeConnection(self.transport)",
            "        self.transport.clear()",
            "        proto.currentEncryptions = MockCipher()",
            "        proto.outgoingCompression = MockCompression()",
            "        proto.incomingCompression = proto.outgoingCompression",
            "        proto.sendPacket(ord(\"A\"), b\"BCDEFG\")",
            "        proto.buf = self.transport.value()",
            "        self.assertEqual(proto.getPacket(), b\"ABCDEFG\")",
            "",
            "    def test_ciphersAreValid(self):",
            "        \"\"\"",
            "        Test that all the supportedCiphers are valid.",
            "        \"\"\"",
            "        ciphers = transport.SSHCiphers(b\"A\", b\"B\", b\"C\", b\"D\")",
            "        iv = key = b\"\\x00\" * 16",
            "        for cipName in self.proto.supportedCiphers:",
            "            self.assertTrue(ciphers._getCipher(cipName, iv, key))",
            "",
            "    def test_sendKexInit(self):",
            "        \"\"\"",
            "        Test that the KEXINIT (key exchange initiation) message is sent",
            "        correctly.  Payload::",
            "            bytes[16] cookie",
            "            string key exchange algorithms",
            "            string public key algorithms",
            "            string outgoing ciphers",
            "            string incoming ciphers",
            "            string outgoing MACs",
            "            string incoming MACs",
            "            string outgoing compressions",
            "            string incoming compressions",
            "            bool first packet follows",
            "            uint32 0",
            "        \"\"\"",
            "        value = self.transport.value().split(b\"\\r\\n\", 1)[1]",
            "        self.proto.buf = value",
            "        packet = self.proto.getPacket()",
            "        self.assertEqual(packet[0:1], bytes((transport.MSG_KEXINIT,)))",
            "        self.assertEqual(packet[1:17], b\"\\x99\" * 16)",
            "        (",
            "            keyExchanges,",
            "            pubkeys,",
            "            ciphers1,",
            "            ciphers2,",
            "            macs1,",
            "            macs2,",
            "            compressions1,",
            "            compressions2,",
            "            languages1,",
            "            languages2,",
            "            buf,",
            "        ) = common.getNS(packet[17:], 10)",
            "",
            "        self.assertEqual(",
            "            keyExchanges, b\",\".join(self.proto.supportedKeyExchanges + [b\"ext-info-s\"])",
            "        )",
            "        self.assertEqual(pubkeys, b\",\".join(self.proto.supportedPublicKeys))",
            "        self.assertEqual(ciphers1, b\",\".join(self.proto.supportedCiphers))",
            "        self.assertEqual(ciphers2, b\",\".join(self.proto.supportedCiphers))",
            "        self.assertEqual(macs1, b\",\".join(self.proto.supportedMACs))",
            "        self.assertEqual(macs2, b\",\".join(self.proto.supportedMACs))",
            "        self.assertEqual(compressions1, b\",\".join(self.proto.supportedCompressions))",
            "        self.assertEqual(compressions2, b\",\".join(self.proto.supportedCompressions))",
            "        self.assertEqual(languages1, b\",\".join(self.proto.supportedLanguages))",
            "        self.assertEqual(languages2, b\",\".join(self.proto.supportedLanguages))",
            "        self.assertEqual(buf, b\"\\x00\" * 5)",
            "",
            "    def test_receiveKEXINITReply(self):",
            "        \"\"\"",
            "        Immediately after connecting, the transport expects a KEXINIT message",
            "        and does not reply to it.",
            "        \"\"\"",
            "        self.transport.clear()",
            "        self.proto.dispatchMessage(transport.MSG_KEXINIT, self._A_KEXINIT_MESSAGE)",
            "        self.assertEqual(self.packets, [])",
            "",
            "    def test_sendKEXINITReply(self):",
            "        \"\"\"",
            "        When a KEXINIT message is received which is not a reply to an earlier",
            "        KEXINIT message which was sent, a KEXINIT reply is sent.",
            "        \"\"\"",
            "        self.finishKeyExchange(self.proto)",
            "        del self.packets[:]",
            "",
            "        self.proto.dispatchMessage(transport.MSG_KEXINIT, self._A_KEXINIT_MESSAGE)",
            "        self.assertEqual(len(self.packets), 1)",
            "        self.assertEqual(self.packets[0][0], transport.MSG_KEXINIT)",
            "",
            "    def test_sendKexInitTwiceFails(self):",
            "        \"\"\"",
            "        A new key exchange cannot be started while a key exchange is already in",
            "        progress.  If an attempt is made to send a I{KEXINIT} message using",
            "        L{SSHTransportBase.sendKexInit} while a key exchange is in progress",
            "        causes that method to raise a L{RuntimeError}.",
            "        \"\"\"",
            "        self.assertRaises(RuntimeError, self.proto.sendKexInit)",
            "",
            "    def test_sendKexInitBlocksOthers(self):",
            "        \"\"\"",
            "        After L{SSHTransportBase.sendKexInit} has been called, messages types",
            "        other than the following are queued and not sent until after I{NEWKEYS}",
            "        is sent by L{SSHTransportBase._keySetup}.",
            "",
            "        RFC 4253, section 7.1.",
            "        \"\"\"",
            "        # sendKexInit is called by connectionMade, which is called in setUp.",
            "        # So we're in the state already.",
            "        disallowedMessageTypes = [",
            "            transport.MSG_SERVICE_REQUEST,",
            "            transport.MSG_KEXINIT,",
            "        ]",
            "",
            "        # Drop all the bytes sent by setUp, they're not relevant to this test.",
            "        self.transport.clear()",
            "",
            "        # Get rid of the sendPacket monkey patch, we are testing the behavior",
            "        # of sendPacket.",
            "        del self.proto.sendPacket",
            "",
            "        for messageType in disallowedMessageTypes:",
            "            self.proto.sendPacket(messageType, b\"foo\")",
            "            self.assertEqual(self.transport.value(), b\"\")",
            "",
            "        self.finishKeyExchange(self.proto)",
            "        # Make the bytes written to the transport cleartext so it's easier to",
            "        # make an assertion about them.",
            "        self.proto.nextEncryptions = MockCipher()",
            "",
            "        # Pseudo-deliver the peer's NEWKEYS message, which should flush the",
            "        # messages which were queued above.",
            "        self.proto._newKeys()",
            "        self.assertEqual(self.transport.value().count(b\"foo\"), 2)",
            "",
            "    def test_sendExtInfo(self):",
            "        \"\"\"",
            "        Test that EXT_INFO messages are sent correctly.  See RFC 8308,",
            "        section 2.3.",
            "        \"\"\"",
            "        self.proto._peerSupportsExtensions = True",
            "        self.proto.sendExtInfo(",
            "            [",
            "                (b\"server-sig-algs\", b\"ssh-rsa,rsa-sha2-256\"),",
            "                (b\"elevation\", b\"d\"),",
            "            ]",
            "        )",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_EXT_INFO,",
            "                    b\"\\x00\\x00\\x00\\x02\"",
            "                    + common.NS(b\"server-sig-algs\")",
            "                    + common.NS(b\"ssh-rsa,rsa-sha2-256\")",
            "                    + common.NS(b\"elevation\")",
            "                    + common.NS(b\"d\"),",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_sendExtInfoUnsupported(self):",
            "        \"\"\"",
            "        If the peer has not advertised support for extension negotiation, no",
            "        EXT_INFO message is sent, since RFC 8308 only guarantees that the",
            "        peer will be prepared to accept it if it has advertised support.",
            "        \"\"\"",
            "        self.proto.sendExtInfo([(b\"server-sig-algs\", b\"ssh-rsa,rsa-sha2-256\")])",
            "        self.assertEqual(self.packets, [])",
            "",
            "    def test_EXT_INFO(self):",
            "        \"\"\"",
            "        When an EXT_INFO message is received, the transport stores a mapping",
            "        of the peer's advertised extensions.  See RFC 8308, section 2.3.",
            "        \"\"\"",
            "        self.proto.dispatchMessage(",
            "            transport.MSG_EXT_INFO,",
            "            b\"\\x00\\x00\\x00\\x02\"",
            "            + common.NS(b\"server-sig-algs\")",
            "            + common.NS(b\"ssh-rsa,rsa-sha2-256,rsa-sha2-512\")",
            "            + common.NS(b\"no-flow-control\")",
            "            + common.NS(b\"s\"),",
            "        )",
            "        self.assertEqual(",
            "            self.proto.peerExtensions,",
            "            {",
            "                b\"server-sig-algs\": b\"ssh-rsa,rsa-sha2-256,rsa-sha2-512\",",
            "                b\"no-flow-control\": b\"s\",",
            "            },",
            "        )",
            "",
            "    def test_sendDebug(self):",
            "        \"\"\"",
            "        Test that debug messages are sent correctly.  Payload::",
            "            bool always display",
            "            string debug message",
            "            string language",
            "        \"\"\"",
            "        self.proto.sendDebug(b\"test\", True, b\"en\")",
            "        self.assertEqual(",
            "            self.packets,",
            "            [(transport.MSG_DEBUG, b\"\\x01\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x02en\")],",
            "        )",
            "",
            "    def test_receiveDebug(self):",
            "        \"\"\"",
            "        Test that debug messages are received correctly.  See test_sendDebug.",
            "        \"\"\"",
            "        self.proto.dispatchMessage(",
            "            transport.MSG_DEBUG, b\"\\x01\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x02en\"",
            "        )",
            "        self.proto.dispatchMessage(",
            "            transport.MSG_DEBUG, b\"\\x00\\x00\\x00\\x00\\x06silent\\x00\\x00\\x00\\x02en\"",
            "        )",
            "        self.assertEqual(",
            "            self.proto.debugs, [(True, b\"test\", b\"en\"), (False, b\"silent\", b\"en\")]",
            "        )",
            "",
            "    def test_sendIgnore(self):",
            "        \"\"\"",
            "        Test that ignored messages are sent correctly.  Payload::",
            "            string ignored data",
            "        \"\"\"",
            "        self.proto.sendIgnore(b\"test\")",
            "        self.assertEqual(",
            "            self.packets, [(transport.MSG_IGNORE, b\"\\x00\\x00\\x00\\x04test\")]",
            "        )",
            "",
            "    def test_receiveIgnore(self):",
            "        \"\"\"",
            "        Test that ignored messages are received correctly.  See",
            "        test_sendIgnore.",
            "        \"\"\"",
            "        self.proto.dispatchMessage(transport.MSG_IGNORE, b\"test\")",
            "        self.assertEqual(self.proto.ignoreds, [b\"test\"])",
            "",
            "    def test_sendUnimplemented(self):",
            "        \"\"\"",
            "        Test that unimplemented messages are sent correctly.  Payload::",
            "            uint32 sequence number",
            "        \"\"\"",
            "        self.proto.sendUnimplemented()",
            "        self.assertEqual(",
            "            self.packets, [(transport.MSG_UNIMPLEMENTED, b\"\\x00\\x00\\x00\\x00\")]",
            "        )",
            "",
            "    def test_receiveUnimplemented(self):",
            "        \"\"\"",
            "        Test that unimplemented messages are received correctly.  See",
            "        test_sendUnimplemented.",
            "        \"\"\"",
            "        self.proto.dispatchMessage(transport.MSG_UNIMPLEMENTED, b\"\\x00\\x00\\x00\\xff\")",
            "        self.assertEqual(self.proto.unimplementeds, [255])",
            "",
            "    def test_sendDisconnect(self):",
            "        \"\"\"",
            "        Test that disconnection messages are sent correctly.  Payload::",
            "            uint32 reason code",
            "            string reason description",
            "            string language",
            "        \"\"\"",
            "        disconnected = [False]",
            "",
            "        def stubLoseConnection():",
            "            disconnected[0] = True",
            "",
            "        self.transport.loseConnection = stubLoseConnection",
            "        self.proto.sendDisconnect(0xFF, b\"test\")",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_DISCONNECT,",
            "                    b\"\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x00\",",
            "                )",
            "            ],",
            "        )",
            "        self.assertTrue(disconnected[0])",
            "",
            "    def test_receiveDisconnect(self):",
            "        \"\"\"",
            "        Test that disconnection messages are received correctly.  See",
            "        test_sendDisconnect.",
            "        \"\"\"",
            "        disconnected = [False]",
            "",
            "        def stubLoseConnection():",
            "            disconnected[0] = True",
            "",
            "        self.transport.loseConnection = stubLoseConnection",
            "        self.proto.dispatchMessage(",
            "            transport.MSG_DISCONNECT, b\"\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x04test\"",
            "        )",
            "        self.assertEqual(self.proto.errors, [(255, b\"test\")])",
            "        self.assertTrue(disconnected[0])",
            "",
            "    def test_dataReceived(self):",
            "        \"\"\"",
            "        Test that dataReceived parses packets and dispatches them to",
            "        ssh_* methods.",
            "        \"\"\"",
            "        kexInit = [False]",
            "",
            "        def stubKEXINIT(packet):",
            "            kexInit[0] = True",
            "",
            "        self.proto.ssh_KEXINIT = stubKEXINIT",
            "        self.proto.dataReceived(self.transport.value())",
            "        self.assertTrue(self.proto.gotVersion)",
            "        self.assertEqual(self.proto.ourVersionString, self.proto.otherVersionString)",
            "        self.assertTrue(kexInit[0])",
            "",
            "    def test_service(self):",
            "        \"\"\"",
            "        Test that the transport can set the running service and dispatches",
            "        packets to the service's packetReceived method.",
            "        \"\"\"",
            "        service = MockService()",
            "        self.proto.setService(service)",
            "        self.assertEqual(self.proto.service, service)",
            "        self.assertTrue(service.started)",
            "        self.proto.dispatchMessage(0xFF, b\"test\")",
            "        self.assertEqual(self.packets, [(0xFF, b\"test\")])",
            "",
            "        service2 = MockService()",
            "        self.proto.setService(service2)",
            "        self.assertTrue(service2.started)",
            "        self.assertTrue(service.stopped)",
            "",
            "        self.proto.connectionLost(None)",
            "        self.assertTrue(service2.stopped)",
            "",
            "    def test_avatar(self):",
            "        \"\"\"",
            "        Test that the transport notifies the avatar of disconnections.",
            "        \"\"\"",
            "        disconnected = [False]",
            "",
            "        def logout():",
            "            disconnected[0] = True",
            "",
            "        self.proto.logoutFunction = logout",
            "        self.proto.avatar = True",
            "",
            "        self.proto.connectionLost(None)",
            "        self.assertTrue(disconnected[0])",
            "",
            "    def test_isEncrypted(self):",
            "        \"\"\"",
            "        Test that the transport accurately reflects its encrypted status.",
            "        \"\"\"",
            "        self.assertFalse(self.proto.isEncrypted(\"in\"))",
            "        self.assertFalse(self.proto.isEncrypted(\"out\"))",
            "        self.assertFalse(self.proto.isEncrypted(\"both\"))",
            "        self.proto.currentEncryptions = MockCipher()",
            "        self.assertTrue(self.proto.isEncrypted(\"in\"))",
            "        self.assertTrue(self.proto.isEncrypted(\"out\"))",
            "        self.assertTrue(self.proto.isEncrypted(\"both\"))",
            "        self.proto.currentEncryptions = transport.SSHCiphers(",
            "            b\"none\", b\"none\", b\"none\", b\"none\"",
            "        )",
            "        self.assertFalse(self.proto.isEncrypted(\"in\"))",
            "        self.assertFalse(self.proto.isEncrypted(\"out\"))",
            "        self.assertFalse(self.proto.isEncrypted(\"both\"))",
            "",
            "        self.assertRaises(TypeError, self.proto.isEncrypted, \"bad\")",
            "",
            "    def test_isVerified(self):",
            "        \"\"\"",
            "        Test that the transport accurately reflects its verified status.",
            "        \"\"\"",
            "        self.assertFalse(self.proto.isVerified(\"in\"))",
            "        self.assertFalse(self.proto.isVerified(\"out\"))",
            "        self.assertFalse(self.proto.isVerified(\"both\"))",
            "        self.proto.currentEncryptions = MockCipher()",
            "        self.assertTrue(self.proto.isVerified(\"in\"))",
            "        self.assertTrue(self.proto.isVerified(\"out\"))",
            "        self.assertTrue(self.proto.isVerified(\"both\"))",
            "        self.proto.currentEncryptions = transport.SSHCiphers(",
            "            b\"none\", b\"none\", b\"none\", b\"none\"",
            "        )",
            "        self.assertFalse(self.proto.isVerified(\"in\"))",
            "        self.assertFalse(self.proto.isVerified(\"out\"))",
            "        self.assertFalse(self.proto.isVerified(\"both\"))",
            "",
            "        self.assertRaises(TypeError, self.proto.isVerified, \"bad\")",
            "",
            "    def test_loseConnection(self):",
            "        \"\"\"",
            "        Test that loseConnection sends a disconnect message and closes the",
            "        connection.",
            "        \"\"\"",
            "        disconnected = [False]",
            "",
            "        def stubLoseConnection():",
            "            disconnected[0] = True",
            "",
            "        self.transport.loseConnection = stubLoseConnection",
            "        self.proto.loseConnection()",
            "        self.assertEqual(self.packets[0][0], transport.MSG_DISCONNECT)",
            "        self.assertEqual(",
            "            self.packets[0][1][3:4], bytes((transport.DISCONNECT_CONNECTION_LOST,))",
            "        )",
            "",
            "    def test_badVersion(self):",
            "        \"\"\"",
            "        Test that the transport disconnects when it receives a bad version.",
            "        \"\"\"",
            "",
            "        def testBad(version):",
            "            self.packets = []",
            "            self.proto.gotVersion = False",
            "            disconnected = [False]",
            "",
            "            def stubLoseConnection():",
            "                disconnected[0] = True",
            "",
            "            self.transport.loseConnection = stubLoseConnection",
            "            for c in iterbytes(version + b\"\\r\\n\"):",
            "                self.proto.dataReceived(c)",
            "            self.assertTrue(disconnected[0])",
            "            self.assertEqual(self.packets[0][0], transport.MSG_DISCONNECT)",
            "            self.assertEqual(",
            "                self.packets[0][1][3:4],",
            "                bytes((transport.DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED,)),",
            "            )",
            "",
            "        testBad(b\"SSH-1.5-OpenSSH\")",
            "        testBad(b\"SSH-3.0-Twisted\")",
            "        testBad(b\"GET / HTTP/1.1\")",
            "",
            "    def test_dataBeforeVersion(self):",
            "        \"\"\"",
            "        Test that the transport ignores data sent before the version string.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(proto_helpers.StringTransport())",
            "        data = (",
            "            b\"\"\"here's some stuff beforehand",
            "here's some other stuff",
            "\"\"\"",
            "            + proto.ourVersionString",
            "            + b\"\\r\\n\"",
            "        )",
            "        [proto.dataReceived(c) for c in iterbytes(data)]",
            "        self.assertTrue(proto.gotVersion)",
            "        self.assertEqual(proto.otherVersionString, proto.ourVersionString)",
            "",
            "    def test_compatabilityVersion(self):",
            "        \"\"\"",
            "        Test that the transport treats the compatibility version (1.99)",
            "        as equivalent to version 2.0.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.makeConnection(proto_helpers.StringTransport())",
            "        proto.dataReceived(b\"SSH-1.99-OpenSSH\\n\")",
            "        self.assertTrue(proto.gotVersion)",
            "        self.assertEqual(proto.otherVersionString, b\"SSH-1.99-OpenSSH\")",
            "",
            "    def test_dataReceivedSSHVersionUnixNewline(self):",
            "        \"\"\"",
            "        It can parse the SSH version string even when it ends only in",
            "        Unix newlines (CR) and does not follows the RFC 4253 to use",
            "        network newlines (CR LF).",
            "        \"\"\"",
            "        sut = MockTransportBase()",
            "        sut.makeConnection(proto_helpers.StringTransport())",
            "",
            "        sut.dataReceived(b\"SSH-2.0-PoorSSHD Some-comment here\\n\" b\"more-data\")",
            "",
            "        self.assertTrue(sut.gotVersion)",
            "        self.assertEqual(sut.otherVersionString, b\"SSH-2.0-PoorSSHD Some-comment here\")",
            "",
            "    def test_dataReceivedSSHVersionTrailingSpaces(self):",
            "        \"\"\"",
            "        The trailing spaces from SSH version comment are not removed.",
            "",
            "        The SSH version string needs to be kept as received",
            "        (without CR LF end of line) as they are used in the host",
            "        authentication process.",
            "",
            "        This can happen with a Bitvise SSH server which hides its version.",
            "        \"\"\"",
            "        sut = MockTransportBase()",
            "        sut.makeConnection(proto_helpers.StringTransport())",
            "",
            "        sut.dataReceived(",
            "            b\"SSH-2.0-9.99 FlowSsh: Bitvise SSH Server (WinSSHD) \\r\\n\" b\"more-data\"",
            "        )",
            "",
            "        self.assertTrue(sut.gotVersion)",
            "        self.assertEqual(",
            "            sut.otherVersionString,",
            "            b\"SSH-2.0-9.99 FlowSsh: Bitvise SSH Server (WinSSHD) \",",
            "        )",
            "",
            "    def test_supportedVersionsAreAllowed(self):",
            "        \"\"\"",
            "        If an unusual SSH version is received and is included in",
            "        C{supportedVersions}, an unsupported version error is not emitted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.supportedVersions = (b\"9.99\",)",
            "        proto.makeConnection(proto_helpers.StringTransport())",
            "        proto.dataReceived(b\"SSH-9.99-OpenSSH\\n\")",
            "        self.assertFalse(proto.gotUnsupportedVersion)",
            "",
            "    def test_unsupportedVersionsCallUnsupportedVersionReceived(self):",
            "        \"\"\"",
            "        If an unusual SSH version is received and is not included in",
            "        C{supportedVersions}, an unsupported version error is emitted.",
            "        \"\"\"",
            "        proto = MockTransportBase()",
            "        proto.supportedVersions = (b\"2.0\",)",
            "        proto.makeConnection(proto_helpers.StringTransport())",
            "        proto.dataReceived(b\"SSH-9.99-OpenSSH\\n\")",
            "        self.assertEqual(b\"9.99\", proto.gotUnsupportedVersion)",
            "",
            "    def test_badPackets(self):",
            "        \"\"\"",
            "        Test that the transport disconnects with an error when it receives",
            "        bad packets.",
            "        \"\"\"",
            "",
            "        def testBad(packet, error=transport.DISCONNECT_PROTOCOL_ERROR):",
            "            self.packets = []",
            "            self.proto.buf = packet",
            "            self.assertIsNone(self.proto.getPacket())",
            "            self.assertEqual(len(self.packets), 1)",
            "            self.assertEqual(self.packets[0][0], transport.MSG_DISCONNECT)",
            "            self.assertEqual(self.packets[0][1][3:4], bytes((error,)))",
            "",
            "        testBad(b\"\\xff\" * 8)  # big packet",
            "        testBad(b\"\\x00\\x00\\x00\\x05\\x00BCDE\")  # length not modulo blocksize",
            "        oldEncryptions = self.proto.currentEncryptions",
            "        self.proto.currentEncryptions = MockCipher()",
            "        testBad(",
            "            b\"\\x00\\x00\\x00\\x08\\x06AB123456\", transport.DISCONNECT_MAC_ERROR  # bad MAC",
            "        )",
            "        self.proto.currentEncryptions.decrypt = lambda x: x[:-1]",
            "        testBad(b\"\\x00\\x00\\x00\\x08\\x06BCDEFGHIJK\")  # bad decryption",
            "        self.proto.currentEncryptions = oldEncryptions",
            "        self.proto.incomingCompression = MockCompression()",
            "",
            "        def stubDecompress(payload):",
            "            raise Exception(\"bad compression\")",
            "",
            "        self.proto.incomingCompression.decompress = stubDecompress",
            "        testBad(",
            "            b\"\\x00\\x00\\x00\\x04\\x00BCDE\",  # bad decompression",
            "            transport.DISCONNECT_COMPRESSION_ERROR,",
            "        )",
            "        self.flushLoggedErrors()",
            "",
            "    def test_unimplementedPackets(self):",
            "        \"\"\"",
            "        Test that unimplemented packet types cause MSG_UNIMPLEMENTED packets",
            "        to be sent.",
            "        \"\"\"",
            "        seqnum = self.proto.incomingPacketSequence",
            "",
            "        def checkUnimplemented(seqnum=seqnum):",
            "            self.assertEqual(self.packets[0][0], transport.MSG_UNIMPLEMENTED)",
            "            self.assertEqual(self.packets[0][1][3:4], bytes((seqnum,)))",
            "            self.proto.packets = []",
            "            seqnum += 1",
            "",
            "        self.proto.dispatchMessage(40, b\"\")",
            "        checkUnimplemented()",
            "        transport.messages[41] = b\"MSG_fiction\"",
            "        self.proto.dispatchMessage(41, b\"\")",
            "        checkUnimplemented()",
            "        self.proto.dispatchMessage(60, b\"\")",
            "        checkUnimplemented()",
            "        self.proto.setService(MockService())",
            "        self.proto.dispatchMessage(70, b\"\")",
            "        checkUnimplemented()",
            "        self.proto.dispatchMessage(71, b\"\")",
            "        checkUnimplemented()",
            "",
            "    def test_multipleClasses(self):",
            "        \"\"\"",
            "        Test that multiple instances have distinct states.",
            "        \"\"\"",
            "        proto = self.proto",
            "        proto.dataReceived(self.transport.value())",
            "        proto.currentEncryptions = MockCipher()",
            "        proto.outgoingCompression = MockCompression()",
            "        proto.incomingCompression = MockCompression()",
            "        proto.setService(MockService())",
            "        proto2 = MockTransportBase()",
            "        proto2.makeConnection(proto_helpers.StringTransport())",
            "        proto2.sendIgnore(b\"\")",
            "        self.assertNotEqual(proto.gotVersion, proto2.gotVersion)",
            "        self.assertNotEqual(proto.transport, proto2.transport)",
            "        self.assertNotEqual(proto.outgoingPacketSequence, proto2.outgoingPacketSequence)",
            "        self.assertNotEqual(proto.incomingPacketSequence, proto2.incomingPacketSequence)",
            "        self.assertNotEqual(proto.currentEncryptions, proto2.currentEncryptions)",
            "        self.assertNotEqual(proto.service, proto2.service)",
            "",
            "",
            "class BaseSSHTransportDHGroupExchangeBaseCase(BaseSSHTransportBaseCase):",
            "    \"\"\"",
            "    Diffie-Hellman group exchange tests for TransportBase.",
            "    \"\"\"",
            "",
            "    def test_getKey(self):",
            "        \"\"\"",
            "        Test that _getKey generates the correct keys.",
            "        \"\"\"",
            "        self.proto.kexAlg = self.kexAlgorithm",
            "        self.proto.sessionID = b\"EF\"",
            "",
            "        k1 = self.hashProcessor(b\"AB\" + b\"CD\" + b\"K\" + self.proto.sessionID).digest()",
            "        k2 = self.hashProcessor(b\"ABCD\" + k1).digest()",
            "        k3 = self.hashProcessor(b\"ABCD\" + k1 + k2).digest()",
            "        k4 = self.hashProcessor(b\"ABCD\" + k1 + k2 + k3).digest()",
            "        self.assertEqual(self.proto._getKey(b\"K\", b\"AB\", b\"CD\"), k1 + k2 + k3 + k4)",
            "",
            "",
            "class BaseSSHTransportDHGroupExchangeSHA1Tests(",
            "    BaseSSHTransportDHGroupExchangeBaseCase, DHGroupExchangeSHA1Mixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha1 tests for TransportBase.",
            "    \"\"\"",
            "",
            "",
            "class BaseSSHTransportDHGroupExchangeSHA256Tests(",
            "    BaseSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA256Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha256 tests for TransportBase.",
            "    \"\"\"",
            "",
            "",
            "class BaseSSHTransportEllipticCurveTests(",
            "    BaseSSHTransportDHGroupExchangeBaseCase, ECDHMixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    ecdh-sha2-nistp256 tests for TransportBase",
            "    \"\"\"",
            "",
            "",
            "@skipWithoutX25519",
            "class BaseSSHTransportCurve25519SHA256Tests(",
            "    BaseSSHTransportDHGroupExchangeBaseCase, Curve25519SHA256Mixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    curve25519-sha256 tests for TransportBase",
            "    \"\"\"",
            "",
            "",
            "class ServerAndClientSSHTransportBaseCase:",
            "    \"\"\"",
            "    Tests that need to be run on both the server and the client.",
            "    \"\"\"",
            "",
            "    def checkDisconnected(self, kind=None):",
            "        \"\"\"",
            "        Helper function to check if the transport disconnected.",
            "        \"\"\"",
            "        if kind is None:",
            "            kind = transport.DISCONNECT_PROTOCOL_ERROR",
            "        self.assertEqual(self.packets[-1][0], transport.MSG_DISCONNECT)",
            "        self.assertEqual(self.packets[-1][1][3:4], bytes((kind,)))",
            "",
            "    def connectModifiedProtocol(self, protoModification, kind=None):",
            "        \"\"\"",
            "        Helper function to connect a modified protocol to the test protocol",
            "        and test for disconnection.",
            "        \"\"\"",
            "        if kind is None:",
            "            kind = transport.DISCONNECT_KEY_EXCHANGE_FAILED",
            "        proto2 = self.klass()",
            "        protoModification(proto2)",
            "        proto2.makeConnection(proto_helpers.StringTransport())",
            "        self.proto.dataReceived(proto2.transport.value())",
            "        if kind:",
            "            self.checkDisconnected(kind)",
            "        return proto2",
            "",
            "    def test_disconnectIfCantMatchKex(self):",
            "        \"\"\"",
            "        Test that the transport disconnects if it can't match the key",
            "        exchange",
            "        \"\"\"",
            "",
            "        def blankKeyExchanges(proto2):",
            "            proto2.supportedKeyExchanges = []",
            "",
            "        self.connectModifiedProtocol(blankKeyExchanges)",
            "",
            "    def test_disconnectIfCantMatchKeyAlg(self):",
            "        \"\"\"",
            "        Like test_disconnectIfCantMatchKex, but for the key algorithm.",
            "        \"\"\"",
            "",
            "        def blankPublicKeys(proto2):",
            "            proto2.supportedPublicKeys = []",
            "",
            "        self.connectModifiedProtocol(blankPublicKeys)",
            "",
            "    def test_disconnectIfCantMatchCompression(self):",
            "        \"\"\"",
            "        Like test_disconnectIfCantMatchKex, but for the compression.",
            "        \"\"\"",
            "",
            "        def blankCompressions(proto2):",
            "            proto2.supportedCompressions = []",
            "",
            "        self.connectModifiedProtocol(blankCompressions)",
            "",
            "    def test_disconnectIfCantMatchCipher(self):",
            "        \"\"\"",
            "        Like test_disconnectIfCantMatchKex, but for the encryption.",
            "        \"\"\"",
            "",
            "        def blankCiphers(proto2):",
            "            proto2.supportedCiphers = []",
            "",
            "        self.connectModifiedProtocol(blankCiphers)",
            "",
            "    def test_disconnectIfCantMatchMAC(self):",
            "        \"\"\"",
            "        Like test_disconnectIfCantMatchKex, but for the MAC.",
            "        \"\"\"",
            "",
            "        def blankMACs(proto2):",
            "            proto2.supportedMACs = []",
            "",
            "        self.connectModifiedProtocol(blankMACs)",
            "",
            "    def test_getPeer(self):",
            "        \"\"\"",
            "        Test that the transport's L{getPeer} method returns an",
            "        L{SSHTransportAddress} with the L{IAddress} of the peer.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.proto.getPeer(),",
            "            address.SSHTransportAddress(self.proto.transport.getPeer()),",
            "        )",
            "",
            "    def test_getHost(self):",
            "        \"\"\"",
            "        Test that the transport's L{getHost} method returns an",
            "        L{SSHTransportAddress} with the L{IAddress} of the host.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            self.proto.getHost(),",
            "            address.SSHTransportAddress(self.proto.transport.getHost()),",
            "        )",
            "",
            "",
            "class ServerSSHTransportBaseCase(ServerAndClientSSHTransportBaseCase):",
            "    \"\"\"",
            "    Base case for SSHServerTransport tests.",
            "    \"\"\"",
            "",
            "    klass: Optional[Type[transport.SSHTransportBase]] = transport.SSHServerTransport",
            "",
            "    def setUp(self):",
            "        TransportTestCase.setUp(self)",
            "        self.proto.factory = MockFactory()",
            "        self.proto.factory.startFactory()",
            "",
            "    def tearDown(self):",
            "        TransportTestCase.tearDown(self)",
            "        self.proto.factory.stopFactory()",
            "        del self.proto.factory",
            "",
            "",
            "class ServerSSHTransportTests(ServerSSHTransportBaseCase, TransportTestCase):",
            "    \"\"\"",
            "    Tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "    def test_KEXINITMultipleAlgorithms(self):",
            "        \"\"\"",
            "        Receiving a KEXINIT packet listing multiple supported algorithms will",
            "        set up the first common algorithm found in the client's preference",
            "        list.",
            "        \"\"\"",
            "        self.proto.dataReceived(",
            "            b\"SSH-2.0-Twisted\\r\\n\\x00\\x00\\x01\\xf4\\x04\\x14\"",
            "            b\"\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\"",
            "            b\"\\x99\\x00\\x00\\x00bdiffie-hellman-group1-sha1,diffie-hellman-g\"",
            "            b\"roup-exchange-sha1,diffie-hellman-group-exchange-sha256\\x00\"",
            "            b\"\\x00\\x00\\x0fssh-dss,ssh-rsa\\x00\\x00\\x00\\x85aes128-ctr,aes128-\"",
            "            b\"cbc,aes192-ctr,aes192-cbc,aes256-ctr,aes256-cbc,cast128-ctr,c\"",
            "            b\"ast128-cbc,blowfish-ctr,blowfish-cbc,3des-ctr,3des-cbc\\x00\"",
            "            b\"\\x00\\x00\\x85aes128-ctr,aes128-cbc,aes192-ctr,aes192-cbc,aes25\"",
            "            b\"6-ctr,aes256-cbc,cast128-ctr,cast128-cbc,blowfish-ctr,blowfis\"",
            "            b\"h-cbc,3des-ctr,3des-cbc\\x00\\x00\\x00\\x12hmac-md5,hmac-sha1\\x00\"",
            "            b\"\\x00\\x00\\x12hmac-md5,hmac-sha1\\x00\\x00\\x00\\tnone,zlib\\x00\\x00\"",
            "            b\"\\x00\\tnone,zlib\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"",
            "            b\"\\x00\\x00\\x99\\x99\\x99\\x99\"",
            "        )",
            "",
            "        # Even if as server we prefer diffie-hellman-group-exchange-sha256 the",
            "        # client preference is used, after skipping diffie-hellman-group1-sha1",
            "        self.assertEqual(self.proto.kexAlg, b\"diffie-hellman-group-exchange-sha1\")",
            "        self.assertEqual(self.proto.keyAlg, b\"ssh-dss\")",
            "        self.assertEqual(self.proto.outgoingCompressionType, b\"none\")",
            "        self.assertEqual(self.proto.incomingCompressionType, b\"none\")",
            "        self.assertFalse(self.proto._peerSupportsExtensions)",
            "        ne = self.proto.nextEncryptions",
            "        self.assertEqual(ne.outCipType, b\"aes128-ctr\")",
            "        self.assertEqual(ne.inCipType, b\"aes128-ctr\")",
            "        self.assertEqual(ne.outMACType, b\"hmac-md5\")",
            "        self.assertEqual(ne.inMACType, b\"hmac-md5\")",
            "",
            "    def test_KEXINITExtensionNegotiation(self):",
            "        \"\"\"",
            "        If the client sends \"ext-info-c\" in its key exchange algorithms,",
            "        then the server notes that the client supports extension",
            "        negotiation.  See RFC 8308, section 2.1.",
            "        \"\"\"",
            "        kexInitPacket = (",
            "            b\"\\x00\" * 16",
            "            + common.NS(b\"diffie-hellman-group-exchange-sha256,ext-info-c\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "        self.proto.ssh_KEXINIT(kexInitPacket)",
            "        self.assertEqual(self.proto.kexAlg, b\"diffie-hellman-group-exchange-sha256\")",
            "        self.assertTrue(self.proto._peerSupportsExtensions)",
            "",
            "    def test_ignoreGuessPacketKex(self):",
            "        \"\"\"",
            "        The client is allowed to send a guessed key exchange packet",
            "        after it sends the KEXINIT packet.  However, if the key exchanges",
            "        do not match, that guess packet must be ignored.  This tests that",
            "        the packet is ignored in the case of the key exchange method not",
            "        matching.",
            "        \"\"\"",
            "        kexInitPacket = (",
            "            b\"\\x00\" * 16",
            "            + (",
            "                b\"\".join(",
            "                    [",
            "                        common.NS(x)",
            "                        for x in [",
            "                            b\",\".join(y)",
            "                            for y in [",
            "                                self.proto.supportedKeyExchanges[::-1],",
            "                                self.proto.supportedPublicKeys,",
            "                                self.proto.supportedCiphers,",
            "                                self.proto.supportedCiphers,",
            "                                self.proto.supportedMACs,",
            "                                self.proto.supportedMACs,",
            "                                self.proto.supportedCompressions,",
            "                                self.proto.supportedCompressions,",
            "                                self.proto.supportedLanguages,",
            "                                self.proto.supportedLanguages,",
            "                            ]",
            "                        ]",
            "                    ]",
            "                )",
            "            )",
            "            + (b\"\\xff\\x00\\x00\\x00\\x00\")",
            "        )",
            "        self.proto.ssh_KEXINIT(kexInitPacket)",
            "        self.assertTrue(self.proto.ignoreNextPacket)",
            "        self.proto.ssh_DEBUG(b\"\\x01\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x00\")",
            "        self.assertTrue(self.proto.ignoreNextPacket)",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(b\"\\x00\\x00\\x08\\x00\")",
            "        self.assertFalse(self.proto.ignoreNextPacket)",
            "        self.assertEqual(self.packets, [])",
            "        self.proto.ignoreNextPacket = True",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST(b\"\\x00\\x00\\x08\\x00\" * 3)",
            "        self.assertFalse(self.proto.ignoreNextPacket)",
            "        self.assertEqual(self.packets, [])",
            "",
            "    def test_ignoreGuessPacketKey(self):",
            "        \"\"\"",
            "        Like test_ignoreGuessPacketKex, but for an incorrectly guessed",
            "        public key format.",
            "        \"\"\"",
            "        kexInitPacket = (",
            "            b\"\\x00\" * 16",
            "            + (",
            "                b\"\".join(",
            "                    [",
            "                        common.NS(x)",
            "                        for x in [",
            "                            b\",\".join(y)",
            "                            for y in [",
            "                                self.proto.supportedKeyExchanges,",
            "                                self.proto.supportedPublicKeys[::-1],",
            "                                self.proto.supportedCiphers,",
            "                                self.proto.supportedCiphers,",
            "                                self.proto.supportedMACs,",
            "                                self.proto.supportedMACs,",
            "                                self.proto.supportedCompressions,",
            "                                self.proto.supportedCompressions,",
            "                                self.proto.supportedLanguages,",
            "                                self.proto.supportedLanguages,",
            "                            ]",
            "                        ]",
            "                    ]",
            "                )",
            "            )",
            "            + (b\"\\xff\\x00\\x00\\x00\\x00\")",
            "        )",
            "        self.proto.ssh_KEXINIT(kexInitPacket)",
            "        self.assertTrue(self.proto.ignoreNextPacket)",
            "        self.proto.ssh_DEBUG(b\"\\x01\\x00\\x00\\x00\\x04test\\x00\\x00\\x00\\x00\")",
            "        self.assertTrue(self.proto.ignoreNextPacket)",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(b\"\\x00\\x00\\x08\\x00\")",
            "        self.assertFalse(self.proto.ignoreNextPacket)",
            "        self.assertEqual(self.packets, [])",
            "        self.proto.ignoreNextPacket = True",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST(b\"\\x00\\x00\\x08\\x00\" * 3)",
            "        self.assertFalse(self.proto.ignoreNextPacket)",
            "        self.assertEqual(self.packets, [])",
            "",
            "    def assertKexDHInitResponse(self, kexAlgorithm, bits):",
            "        \"\"\"",
            "        Test that the KEXDH_INIT packet causes the server to send a",
            "        KEXDH_REPLY with the server's public key and a signature.",
            "",
            "        @param kexAlgorithm: The key exchange algorithm to use.",
            "        @type kexAlgorithm: L{str}",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [kexAlgorithm]",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\"]",
            "        self.proto.dataReceived(self.transport.value())",
            "",
            "        g, p = _kex.getDHGeneratorAndPrime(kexAlgorithm)",
            "        e = pow(g, 5000, p)",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(common.MP(e))",
            "        y = common.getMP(common.NS(b\"\\x99\" * (bits // 8)))[0]",
            "        f = _MPpow(self.proto.g, y, self.proto.p)",
            "        self.assertEqual(self.proto.dhSecretKeyPublicMP, f)",
            "        sharedSecret = _MPpow(e, y, self.proto.p)",
            "",
            "        h = sha1()",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob()))",
            "        h.update(common.MP(e))",
            "        h.update(f)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = self.proto.factory.privateKeys[b\"ssh-rsa\"].sign(exchangeHash)",
            "",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEXDH_REPLY,",
            "                    common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob())",
            "                    + f",
            "                    + common.NS(signature),",
            "                ),",
            "                (transport.MSG_NEWKEYS, b\"\"),",
            "            ],",
            "        )",
            "",
            "    def test_checkBad_KEX_ECDH_INIT_CurveName(self):",
            "        \"\"\"",
            "        Test that if the server receives a KEX_DH_GEX_REQUEST_OLD message",
            "        and the key exchange algorithm is not set, we raise a ConchError.",
            "        \"\"\"",
            "        self.proto.kexAlg = b\"bad-curve\"",
            "        self.proto.keyAlg = b\"ssh-rsa\"",
            "        self.assertRaises(",
            "            UnsupportedAlgorithm,",
            "            self.proto._ssh_KEX_ECDH_INIT,",
            "            common.NS(b\"unused-key\"),",
            "        )",
            "",
            "    def test_checkBad_KEX_INIT_CurveName(self):",
            "        \"\"\"",
            "        Test that if the server received a bad name for a curve",
            "        we raise an UnsupportedAlgorithm error.",
            "        \"\"\"",
            "        kexmsg = (",
            "            b\"\\xAA\" * 16",
            "            + common.NS(b\"ecdh-sha2-nistp256\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "",
            "        self.proto.ssh_KEXINIT(kexmsg)",
            "        self.assertRaises(AttributeError)",
            "        self.assertRaises(UnsupportedAlgorithm)",
            "",
            "    def test_KEXDH_INIT_GROUP14(self):",
            "        \"\"\"",
            "        KEXDH_INIT messages are processed when the",
            "        diffie-hellman-group14-sha1 key exchange algorithm is requested.",
            "        \"\"\"",
            "        self.assertKexDHInitResponse(b\"diffie-hellman-group14-sha1\", 2048)",
            "",
            "    def test_keySetup(self):",
            "        \"\"\"",
            "        Test that _keySetup sets up the next encryption keys.",
            "        \"\"\"",
            "        self.proto.kexAlg = b\"diffie-hellman-group14-sha1\"",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.assertEqual(self.packets[-1], (transport.MSG_NEWKEYS, b\"\"))",
            "        newKeys = [self.proto._getKey(c, b\"AB\", b\"EF\") for c in iterbytes(b\"ABCDEF\")]",
            "        self.assertEqual(",
            "            self.proto.nextEncryptions.keys,",
            "            (newKeys[1], newKeys[3], newKeys[0], newKeys[2], newKeys[5], newKeys[4]),",
            "        )",
            "",
            "    def test_keySetupWithExtInfo(self):",
            "        \"\"\"",
            "        If the client advertised support for extension negotiation, then",
            "        _keySetup sends SSH_MSG_EXT_INFO with the \"server-sig-algs\"",
            "        extension as the next packet following the server's first",
            "        SSH_MSG_NEWKEYS.  See RFC 8308, sections 2.4 and 3.1.",
            "        \"\"\"",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\", b\"rsa-sha2-256\", b\"rsa-sha2-512\"]",
            "        self.proto.kexAlg = b\"diffie-hellman-group14-sha1\"",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.proto._peerSupportsExtensions = True",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertEqual(self.packets[-2], (transport.MSG_NEWKEYS, b\"\"))",
            "        self.assertEqual(",
            "            self.packets[-1],",
            "            (",
            "                transport.MSG_EXT_INFO,",
            "                b\"\\x00\\x00\\x00\\x01\"",
            "                + common.NS(b\"server-sig-algs\")",
            "                + common.NS(b\"ssh-rsa,rsa-sha2-256,rsa-sha2-512\"),",
            "            ),",
            "        )",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.assertEqual(self.packets[-1], (transport.MSG_NEWKEYS, b\"\"))",
            "",
            "    def test_ECDH_keySetup(self):",
            "        \"\"\"",
            "        Test that _keySetup sets up the next encryption keys.",
            "        \"\"\"",
            "        self.proto.kexAlg = b\"ecdh-sha2-nistp256\"",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.assertEqual(self.packets[-1], (transport.MSG_NEWKEYS, b\"\"))",
            "        newKeys = [self.proto._getKey(c, b\"AB\", b\"EF\") for c in iterbytes(b\"ABCDEF\")]",
            "        self.assertEqual(",
            "            self.proto.nextEncryptions.keys,",
            "            (newKeys[1], newKeys[3], newKeys[0], newKeys[2], newKeys[5], newKeys[4]),",
            "        )",
            "",
            "    def test_NEWKEYS(self):",
            "        \"\"\"",
            "        Test that NEWKEYS transitions the keys in nextEncryptions to",
            "        currentEncryptions.",
            "        \"\"\"",
            "        self.test_KEXINITMultipleAlgorithms()",
            "",
            "        self.proto.nextEncryptions = transport.SSHCiphers(",
            "            b\"none\", b\"none\", b\"none\", b\"none\"",
            "        )",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIs(self.proto.currentEncryptions, self.proto.nextEncryptions)",
            "        self.assertIsNone(self.proto.outgoingCompression)",
            "        self.assertIsNone(self.proto.incomingCompression)",
            "        self.proto.outgoingCompressionType = b\"zlib\"",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNotNone(self.proto.outgoingCompression)",
            "        self.proto.incomingCompressionType = b\"zlib\"",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNotNone(self.proto.incomingCompression)",
            "",
            "    def test_SERVICE_REQUEST(self):",
            "        \"\"\"",
            "        Test that the SERVICE_REQUEST message requests and starts a",
            "        service.",
            "        \"\"\"",
            "        self.proto.ssh_SERVICE_REQUEST(common.NS(b\"ssh-userauth\"))",
            "        self.assertEqual(",
            "            self.packets, [(transport.MSG_SERVICE_ACCEPT, common.NS(b\"ssh-userauth\"))]",
            "        )",
            "        self.assertEqual(self.proto.service.name, b\"MockService\")",
            "",
            "    def test_disconnectNEWKEYSData(self):",
            "        \"\"\"",
            "        Test that NEWKEYS disconnects if it receives data.",
            "        \"\"\"",
            "        self.proto.ssh_NEWKEYS(b\"bad packet\")",
            "        self.checkDisconnected()",
            "",
            "    def test_disconnectSERVICE_REQUESTBadService(self):",
            "        \"\"\"",
            "        Test that SERVICE_REQUESTS disconnects if an unknown service is",
            "        requested.",
            "        \"\"\"",
            "        self.proto.ssh_SERVICE_REQUEST(common.NS(b\"no service\"))",
            "        self.checkDisconnected(transport.DISCONNECT_SERVICE_NOT_AVAILABLE)",
            "",
            "",
            "class ServerSSHTransportDHGroupExchangeBaseCase(ServerSSHTransportBaseCase):",
            "    \"\"\"",
            "    Diffie-Hellman group exchange tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "    def test_KEX_DH_GEX_REQUEST_OLD(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_REQUEST_OLD message causes the server",
            "        to reply with a KEX_DH_GEX_GROUP message with the correct",
            "        Diffie-Hellman group.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\"]",
            "        self.proto.dataReceived(self.transport.value())",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(b\"\\x00\\x00\\x04\\x00\")",
            "        dhGenerator, dhPrime = self.proto.factory.getPrimes().get(2048)[0]",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEX_DH_GEX_GROUP,",
            "                    common.MP(dhPrime) + b\"\\x00\\x00\\x00\\x01\\x02\",",
            "                )",
            "            ],",
            "        )",
            "        self.assertEqual(self.proto.g, 2)",
            "        self.assertEqual(self.proto.p, dhPrime)",
            "",
            "    def test_KEX_DH_GEX_REQUEST_OLD_badKexAlg(self):",
            "        \"\"\"",
            "        Test that if the server receives a KEX_DH_GEX_REQUEST_OLD message",
            "        and the key exchange algorithm is not set, we raise a ConchError.",
            "        \"\"\"",
            "        self.proto.kexAlg = None",
            "        self.assertRaises(ConchError, self.proto.ssh_KEX_DH_GEX_REQUEST_OLD, None)",
            "",
            "    def test_KEX_DH_GEX_REQUEST(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_REQUEST message causes the server to reply",
            "        with a KEX_DH_GEX_GROUP message with the correct Diffie-Hellman",
            "        group.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\"]",
            "        self.proto.dataReceived(self.transport.value())",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST(",
            "            b\"\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\" + b\"\\x00\\x00\\x0c\\x00\"",
            "        )",
            "        dhGenerator, dhPrime = self.proto.factory.getPrimes().get(2048)[0]",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEX_DH_GEX_GROUP,",
            "                    common.MP(dhPrime) + b\"\\x00\\x00\\x00\\x01\\x02\",",
            "                )",
            "            ],",
            "        )",
            "        self.assertEqual(self.proto.g, 2)",
            "        self.assertEqual(self.proto.p, dhPrime)",
            "",
            "    def test_KEX_DH_GEX_INIT_after_REQUEST_OLD(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_INIT message after the client sends",
            "        KEX_DH_GEX_REQUEST_OLD causes the server to send a KEX_DH_GEX_INIT",
            "        message with a public key and signature.",
            "        \"\"\"",
            "        self.test_KEX_DH_GEX_REQUEST_OLD()",
            "        e = pow(self.proto.g, 3, self.proto.p)",
            "        y = common.getMP(b\"\\x00\\x00\\x01\\x00\" + b\"\\x99\" * 512)[0]",
            "        self.assertEqual(self.proto.dhSecretKey.private_numbers().x, y)",
            "        f = _MPpow(self.proto.g, y, self.proto.p)",
            "        self.assertEqual(self.proto.dhSecretKeyPublicMP, f)",
            "        sharedSecret = _MPpow(e, y, self.proto.p)",
            "        h = self.hashProcessor()",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob()))",
            "        h.update(b\"\\x00\\x00\\x04\\x00\")",
            "        h.update(common.MP(self.proto.p))",
            "        h.update(common.MP(self.proto.g))",
            "        h.update(common.MP(e))",
            "        h.update(f)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        self.proto.ssh_KEX_DH_GEX_INIT(common.MP(e))",
            "        self.assertEqual(",
            "            self.packets[1:],",
            "            [",
            "                (",
            "                    transport.MSG_KEX_DH_GEX_REPLY,",
            "                    common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob())",
            "                    + f",
            "                    + common.NS(",
            "                        self.proto.factory.privateKeys[b\"ssh-rsa\"].sign(exchangeHash)",
            "                    ),",
            "                ),",
            "                (transport.MSG_NEWKEYS, b\"\"),",
            "            ],",
            "        )",
            "",
            "    def test_KEX_DH_GEX_INIT_after_REQUEST(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_INIT message after the client sends",
            "        KEX_DH_GEX_REQUEST causes the server to send a KEX_DH_GEX_INIT message",
            "        with a public key and signature.",
            "        \"\"\"",
            "        self.test_KEX_DH_GEX_REQUEST()",
            "        e = pow(self.proto.g, 3, self.proto.p)",
            "        y = common.getMP(b\"\\x00\\x00\\x01\\x00\" + b\"\\x99\" * 256)[0]",
            "        f = _MPpow(self.proto.g, y, self.proto.p)",
            "        sharedSecret = _MPpow(e, y, self.proto.p)",
            "",
            "        h = self.hashProcessor()",
            "",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob()))",
            "        h.update(b\"\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x0c\\x00\")",
            "        h.update(common.MP(self.proto.p))",
            "        h.update(common.MP(self.proto.g))",
            "        h.update(common.MP(e))",
            "        h.update(f)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "        self.proto.ssh_KEX_DH_GEX_INIT(common.MP(e))",
            "        self.assertEqual(",
            "            self.packets[1],",
            "            (",
            "                transport.MSG_KEX_DH_GEX_REPLY,",
            "                common.NS(self.proto.factory.publicKeys[b\"ssh-rsa\"].blob())",
            "                + f",
            "                + common.NS(",
            "                    self.proto.factory.privateKeys[b\"ssh-rsa\"].sign(exchangeHash)",
            "                ),",
            "            ),",
            "        )",
            "",
            "",
            "class ServerSSHTransportDHGroupExchangeSHA1Tests(",
            "    ServerSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA1Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha1 tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "",
            "class ServerSSHTransportDHGroupExchangeSHA256Tests(",
            "    ServerSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA256Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha256 tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "",
            "class ServerSSHTransportECDHBaseCase(ServerSSHTransportBaseCase):",
            "    \"\"\"",
            "    Elliptic Curve Diffie-Hellman tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "    def test_KEX_ECDH_INIT(self):",
            "        \"\"\"",
            "        Test that the KEXDH_INIT message causes the server to send a",
            "        KEXDH_REPLY with the server's public key and a signature.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.supportedPublicKeys = [b\"ssh-rsa\"]",
            "        self.proto.dataReceived(self.transport.value())",
            "",
            "        privKey = self.proto.factory.privateKeys[b\"ssh-rsa\"]",
            "        pubKey = self.proto.factory.publicKeys[b\"ssh-rsa\"]",
            "        ecPriv = self.proto._generateECPrivateKey()",
            "        ecPub = ecPriv.public_key()",
            "        encPub = self.proto._encodeECPublicKey(ecPub)",
            "",
            "        self.proto.ssh_KEX_DH_GEX_REQUEST_OLD(common.NS(encPub))",
            "",
            "        sharedSecret = self.proto._generateECSharedSecret(",
            "            ecPriv, self.proto._encodeECPublicKey(self.proto.ecPub)",
            "        )",
            "",
            "        h = self.hashProcessor()",
            "        h.update(common.NS(self.proto.otherVersionString))",
            "        h.update(common.NS(self.proto.ourVersionString))",
            "        h.update(common.NS(self.proto.otherKexInitPayload))",
            "        h.update(common.NS(self.proto.ourKexInitPayload))",
            "        h.update(common.NS(pubKey.blob()))",
            "        h.update(common.NS(encPub))",
            "        h.update(common.NS(self.proto._encodeECPublicKey(self.proto.ecPub)))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = privKey.sign(exchangeHash)",
            "",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEXDH_REPLY,",
            "                    common.NS(pubKey.blob())",
            "                    + common.NS(self.proto._encodeECPublicKey(self.proto.ecPub))",
            "                    + common.NS(signature),",
            "                ),",
            "                (transport.MSG_NEWKEYS, b\"\"),",
            "            ],",
            "        )",
            "",
            "",
            "class ServerSSHTransportECDHTests(",
            "    ServerSSHTransportECDHBaseCase, ECDHMixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    ecdh-sha2-nistp256 tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "",
            "@skipWithoutX25519",
            "class ServerSSHTransportCurve25519SHA256Tests(",
            "    ServerSSHTransportECDHBaseCase, Curve25519SHA256Mixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    curve25519-sha256 tests for SSHServerTransport.",
            "    \"\"\"",
            "",
            "",
            "class ClientSSHTransportBaseCase(ServerAndClientSSHTransportBaseCase):",
            "    \"\"\"",
            "    Base case for SSHClientTransport tests.",
            "    \"\"\"",
            "",
            "    klass: Optional[Type[transport.SSHTransportBase]] = transport.SSHClientTransport",
            "",
            "    def verifyHostKey(self, pubKey, fingerprint):",
            "        \"\"\"",
            "        Mock version of SSHClientTransport.verifyHostKey.",
            "        \"\"\"",
            "        self.calledVerifyHostKey = True",
            "        self.assertEqual(pubKey, self.blob)",
            "        self.assertEqual(",
            "            fingerprint.replace(b\":\", b\"\"), binascii.hexlify(md5(pubKey).digest())",
            "        )",
            "        return defer.succeed(True)",
            "",
            "    def setUp(self):",
            "        TransportTestCase.setUp(self)",
            "        self.blob = keys.Key.fromString(keydata.publicRSA_openssh).blob()",
            "        self.privObj = keys.Key.fromString(keydata.privateRSA_openssh)",
            "        self.calledVerifyHostKey = False",
            "        self.proto.verifyHostKey = self.verifyHostKey",
            "",
            "",
            "class ClientSSHTransportTests(ClientSSHTransportBaseCase, TransportTestCase):",
            "    \"\"\"",
            "    Tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "    def test_KEXINITMultipleAlgorithms(self):",
            "        \"\"\"",
            "        Receiving a KEXINIT packet listing multiple supported",
            "        algorithms will set up the first common algorithm, ordered after our",
            "        preference.",
            "        \"\"\"",
            "        self.proto.dataReceived(",
            "            b\"SSH-2.0-Twisted\\r\\n\\x00\\x00\\x01\\xf4\\x04\\x14\"",
            "            b\"\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\\x99\"",
            "            b\"\\x99\\x00\\x00\\x00bdiffie-hellman-group1-sha1,diffie-hellman-g\"",
            "            b\"roup-exchange-sha1,diffie-hellman-group-exchange-sha256\\x00\"",
            "            b\"\\x00\\x00\\x0fssh-dss,ssh-rsa\\x00\\x00\\x00\\x85aes128-ctr,aes128-\"",
            "            b\"cbc,aes192-ctr,aes192-cbc,aes256-ctr,aes256-cbc,cast128-ctr,c\"",
            "            b\"ast128-cbc,blowfish-ctr,blowfish-cbc,3des-ctr,3des-cbc\\x00\"",
            "            b\"\\x00\\x00\\x85aes128-ctr,aes128-cbc,aes192-ctr,aes192-cbc,aes25\"",
            "            b\"6-ctr,aes256-cbc,cast128-ctr,cast128-cbc,blowfish-ctr,blowfis\"",
            "            b\"h-cbc,3des-ctr,3des-cbc\\x00\\x00\\x00\\x12hmac-md5,hmac-sha1\\x00\"",
            "            b\"\\x00\\x00\\x12hmac-md5,hmac-sha1\\x00\\x00\\x00\\tzlib,none\\x00\\x00\"",
            "            b\"\\x00\\tzlib,none\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"",
            "            b\"\\x00\\x00\\x99\\x99\\x99\\x99\"",
            "        )",
            "        # Even if client prefer diffie-hellman-group1-sha1, we will go for",
            "        # diffie-hellman-group-exchange-sha256 as this what we prefer and is",
            "        # also supported by the server.",
            "        self.assertEqual(self.proto.kexAlg, b\"diffie-hellman-group-exchange-sha256\")",
            "        self.assertEqual(self.proto.keyAlg, b\"ssh-rsa\")",
            "        self.assertEqual(self.proto.outgoingCompressionType, b\"none\")",
            "        self.assertEqual(self.proto.incomingCompressionType, b\"none\")",
            "        ne = self.proto.nextEncryptions",
            "        self.assertEqual(ne.outCipType, b\"aes256-ctr\")",
            "        self.assertEqual(ne.inCipType, b\"aes256-ctr\")",
            "        self.assertEqual(ne.outMACType, b\"hmac-sha1\")",
            "        self.assertEqual(ne.inMACType, b\"hmac-sha1\")",
            "",
            "    def test_notImplementedClientMethods(self):",
            "        \"\"\"",
            "        verifyHostKey() should return a Deferred which fails with a",
            "        NotImplementedError exception.  connectionSecure() should raise",
            "        NotImplementedError().",
            "        \"\"\"",
            "        self.assertRaises(NotImplementedError, self.klass().connectionSecure)",
            "",
            "        def _checkRaises(f):",
            "            f.trap(NotImplementedError)",
            "",
            "        d = self.klass().verifyHostKey(None, None)",
            "        return d.addCallback(self.fail).addErrback(_checkRaises)",
            "",
            "    def assertKexInitResponseForDH(self, kexAlgorithm, bits):",
            "        \"\"\"",
            "        Test that a KEXINIT packet with a group1 or group14 key exchange",
            "        results in a correct KEXDH_INIT response.",
            "",
            "        @param kexAlgorithm: The key exchange algorithm to use",
            "        @type kexAlgorithm: L{str}",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [kexAlgorithm]",
            "",
            "        # Imitate reception of server key exchange request contained",
            "        # in data returned by self.transport.value()",
            "        self.proto.dataReceived(self.transport.value())",
            "",
            "        x = self.proto.dhSecretKey.private_numbers().x",
            "        self.assertEqual(common.MP(x)[5:], b\"\\x99\" * (bits // 8))",
            "",
            "        # Data sent to server should be a transport.MSG_KEXDH_INIT",
            "        # message containing our public key.",
            "        self.assertEqual(",
            "            self.packets, [(transport.MSG_KEXDH_INIT, self.proto.dhSecretKeyPublicMP)]",
            "        )",
            "",
            "    def test_KEXINIT_group14(self):",
            "        \"\"\"",
            "        KEXINIT messages requesting diffie-hellman-group14-sha1 result in",
            "        KEXDH_INIT responses.",
            "        \"\"\"",
            "        self.assertKexInitResponseForDH(b\"diffie-hellman-group14-sha1\", 2048)",
            "",
            "    def test_KEXINIT_badKexAlg(self):",
            "        \"\"\"",
            "        Test that the client raises a ConchError if it receives a",
            "        KEXINIT message but doesn't have a key exchange algorithm that we",
            "        understand.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [b\"diffie-hellman-group24-sha1\"]",
            "        data = self.transport.value().replace(b\"group14\", b\"group24\")",
            "        self.assertRaises(ConchError, self.proto.dataReceived, data)",
            "",
            "    def test_KEXINITExtensionNegotiation(self):",
            "        \"\"\"",
            "        If the server sends \"ext-info-s\" in its key exchange algorithms,",
            "        then the client notes that the server supports extension",
            "        negotiation.  See RFC 8308, section 2.1.",
            "        \"\"\"",
            "        kexInitPacket = (",
            "            b\"\\x00\" * 16",
            "            + common.NS(b\"diffie-hellman-group-exchange-sha256,ext-info-s\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "        self.proto.ssh_KEXINIT(kexInitPacket)",
            "        self.assertTrue(self.proto._peerSupportsExtensions)",
            "",
            "    def begin_KEXDH_REPLY(self):",
            "        \"\"\"",
            "        Utility for test_KEXDH_REPLY and",
            "        test_disconnectKEXDH_REPLYBadSignature.",
            "",
            "        Begins a Diffie-Hellman key exchange in the named group",
            "        Group-14 and computes information needed to return either a",
            "        correct or incorrect signature.",
            "",
            "        \"\"\"",
            "        self.test_KEXINIT_group14()",
            "",
            "        f = 2",
            "        fMP = common.MP(f)",
            "        x = self.proto.dhSecretKey.private_numbers().x",
            "        p = self.proto.p",
            "        sharedSecret = _MPpow(f, x, p)",
            "        h = sha1()",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.blob))",
            "        h.update(self.proto.dhSecretKeyPublicMP)",
            "        h.update(fMP)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = self.privObj.sign(exchangeHash)",
            "",
            "        return (exchangeHash, signature, common.NS(self.blob) + fMP)",
            "",
            "    def test_KEXDH_REPLY(self):",
            "        \"\"\"",
            "        Test that the KEXDH_REPLY message verifies the server.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEXDH_REPLY()",
            "",
            "        def _cbTestKEXDH_REPLY(value):",
            "            self.assertIsNone(value)",
            "            self.assertTrue(self.calledVerifyHostKey)",
            "            self.assertEqual(self.proto.sessionID, exchangeHash)",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_GROUP(packetStart + common.NS(signature))",
            "        d.addCallback(_cbTestKEXDH_REPLY)",
            "",
            "        return d",
            "",
            "    def test_keySetup(self):",
            "        \"\"\"",
            "        Test that _keySetup sets up the next encryption keys.",
            "        \"\"\"",
            "        self.proto.kexAlg = b\"diffie-hellman-group14-sha1\"",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.simulateKeyExchange(b\"AB\", b\"EF\")",
            "        self.assertEqual(self.proto.sessionID, b\"CD\")",
            "        self.assertEqual(self.packets[-1], (transport.MSG_NEWKEYS, b\"\"))",
            "        newKeys = [self.proto._getKey(c, b\"AB\", b\"EF\") for c in iterbytes(b\"ABCDEF\")]",
            "        self.assertEqual(",
            "            self.proto.nextEncryptions.keys,",
            "            (newKeys[0], newKeys[2], newKeys[1], newKeys[3], newKeys[4], newKeys[5]),",
            "        )",
            "",
            "    def test_NEWKEYS(self):",
            "        \"\"\"",
            "        Test that NEWKEYS transitions the keys from nextEncryptions to",
            "        currentEncryptions.",
            "        \"\"\"",
            "        self.test_KEXINITMultipleAlgorithms()",
            "        secure = [False]",
            "",
            "        def stubConnectionSecure():",
            "            secure[0] = True",
            "",
            "        self.proto.connectionSecure = stubConnectionSecure",
            "",
            "        self.proto.nextEncryptions = transport.SSHCiphers(",
            "            b\"none\", b\"none\", b\"none\", b\"none\"",
            "        )",
            "        self.simulateKeyExchange(b\"AB\", b\"CD\")",
            "        self.assertIsNot(self.proto.currentEncryptions, self.proto.nextEncryptions)",
            "",
            "        self.proto.nextEncryptions = MockCipher()",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNone(self.proto.outgoingCompression)",
            "        self.assertIsNone(self.proto.incomingCompression)",
            "        self.assertIs(self.proto.currentEncryptions, self.proto.nextEncryptions)",
            "        self.assertTrue(secure[0])",
            "        self.proto.outgoingCompressionType = b\"zlib\"",
            "        self.simulateKeyExchange(b\"AB\", b\"GH\")",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNotNone(self.proto.outgoingCompression)",
            "        self.proto.incomingCompressionType = b\"zlib\"",
            "        self.simulateKeyExchange(b\"AB\", b\"IJ\")",
            "        self.proto.ssh_NEWKEYS(b\"\")",
            "        self.assertIsNotNone(self.proto.incomingCompression)",
            "",
            "    def test_SERVICE_ACCEPT(self):",
            "        \"\"\"",
            "        Test that the SERVICE_ACCEPT packet starts the requested service.",
            "        \"\"\"",
            "        self.proto.instance = MockService()",
            "        self.proto.ssh_SERVICE_ACCEPT(b\"\\x00\\x00\\x00\\x0bMockService\")",
            "        self.assertTrue(self.proto.instance.started)",
            "",
            "    def test_requestService(self):",
            "        \"\"\"",
            "        Test that requesting a service sends a SERVICE_REQUEST packet.",
            "        \"\"\"",
            "        self.proto.requestService(MockService())",
            "        self.assertEqual(",
            "            self.packets,",
            "            [(transport.MSG_SERVICE_REQUEST, b\"\\x00\\x00\\x00\\x0bMockService\")],",
            "        )",
            "",
            "    def test_disconnectKEXDH_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEXDH_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEXDH_REPLY()",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_GROUP(packetStart + common.NS(b\"bad signature\"))",
            "        return d.addCallback(",
            "            lambda _: self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "        )",
            "",
            "    def test_disconnectKEX_ECDH_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEX_ECDH_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        kexmsg = (",
            "            b\"\\xAA\" * 16",
            "            + common.NS(b\"ecdh-sha2-nistp256\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "",
            "        self.proto.ssh_KEXINIT(kexmsg)",
            "",
            "        self.proto.dataReceived(b\"SSH-2.0-OpenSSH\\r\\n\")",
            "",
            "        self.proto.ecPriv = ec.generate_private_key(ec.SECP256R1(), default_backend())",
            "        self.proto.ecPub = self.proto.ecPriv.public_key()",
            "",
            "        # Generate the private key",
            "        thisPriv = ec.generate_private_key(ec.SECP256R1(), default_backend())",
            "        # Get the public key",
            "        thisPub = thisPriv.public_key()",
            "        encPub = thisPub.public_bytes(",
            "            serialization.Encoding.X962, serialization.PublicFormat.UncompressedPoint",
            "        )",
            "        self.proto.curve = ec.SECP256R1()",
            "",
            "        self.proto.kexAlg = b\"ecdh-sha2-nistp256\"",
            "",
            "        self.proto._ssh_KEX_ECDH_REPLY(",
            "            common.NS(MockFactory().getPublicKeys()[b\"ssh-rsa\"].blob())",
            "            + common.NS(encPub)",
            "            + common.NS(b\"bad-signature\")",
            "        )",
            "",
            "        self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "",
            "    def test_disconnectNEWKEYSData(self):",
            "        \"\"\"",
            "        Test that NEWKEYS disconnects if it receives data.",
            "        \"\"\"",
            "        self.proto.ssh_NEWKEYS(b\"bad packet\")",
            "        self.checkDisconnected()",
            "",
            "    def test_disconnectSERVICE_ACCEPT(self):",
            "        \"\"\"",
            "        Test that SERVICE_ACCEPT disconnects if the accepted protocol is",
            "        differet from the asked-for protocol.",
            "        \"\"\"",
            "        self.proto.instance = MockService()",
            "        self.proto.ssh_SERVICE_ACCEPT(b\"\\x00\\x00\\x00\\x03bad\")",
            "        self.checkDisconnected()",
            "",
            "    def test_noPayloadSERVICE_ACCEPT(self):",
            "        \"\"\"",
            "        Some commercial SSH servers don't send a payload with the",
            "        SERVICE_ACCEPT message.  Conch pretends that it got the correct",
            "        name of the service.",
            "        \"\"\"",
            "        self.proto.instance = MockService()",
            "        self.proto.ssh_SERVICE_ACCEPT(b\"\")  # no payload",
            "        self.assertTrue(self.proto.instance.started)",
            "        self.assertEqual(len(self.packets), 0)  # not disconnected",
            "",
            "",
            "class ClientSSHTransportDHGroupExchangeBaseCase(ClientSSHTransportBaseCase):",
            "    \"\"\"",
            "    Diffie-Hellman group exchange tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "    \"\"\"",
            "    1536-bit modulus from RFC 3526",
            "    \"\"\"",
            "    P1536 = int(",
            "        \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"",
            "        \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"",
            "        \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"",
            "        \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"",
            "        \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\"",
            "        \"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\"",
            "        \"83655D23DCA3AD961C62F356208552BB9ED529077096966D\"",
            "        \"670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF\",",
            "        16,",
            "    )",
            "",
            "    def test_KEXINIT_groupexchange(self):",
            "        \"\"\"",
            "        KEXINIT packet with a group-exchange key exchange results",
            "        in a KEX_DH_GEX_REQUEST message.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.dataReceived(self.transport.value())",
            "        # The response will include our advertised group sizes.",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEX_DH_GEX_REQUEST,",
            "                    b\"\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x20\\x00\",",
            "                )",
            "            ],",
            "        )",
            "",
            "    def test_KEX_DH_GEX_GROUP(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_GROUP message results in a",
            "        KEX_DH_GEX_INIT message with the client's Diffie-Hellman public key.",
            "        \"\"\"",
            "        self.test_KEXINIT_groupexchange()",
            "        self.proto.ssh_KEX_DH_GEX_GROUP(common.MP(self.P1536) + common.MP(2))",
            "        self.assertEqual(self.proto.p, self.P1536)",
            "        self.assertEqual(self.proto.g, 2)",
            "        x = self.proto.dhSecretKey.private_numbers().x",
            "        self.assertEqual(common.MP(x)[5:], b\"\\x99\" * 192)",
            "        self.assertEqual(",
            "            self.proto.dhSecretKeyPublicMP, common.MP(pow(2, x, self.P1536))",
            "        )",
            "        self.assertEqual(",
            "            self.packets[1:],",
            "            [(transport.MSG_KEX_DH_GEX_INIT, self.proto.dhSecretKeyPublicMP)],",
            "        )",
            "",
            "    def begin_KEX_DH_GEX_REPLY(self):",
            "        \"\"\"",
            "        Utility for test_KEX_DH_GEX_REPLY and",
            "        test_disconnectGEX_REPLYBadSignature.",
            "",
            "        Begins a Diffie-Hellman key exchange in an unnamed",
            "        (server-specified) group and computes information needed to",
            "        return either a correct or incorrect signature.",
            "        \"\"\"",
            "        self.test_KEX_DH_GEX_GROUP()",
            "        p = self.proto.p",
            "        f = 3",
            "        fMP = common.MP(f)",
            "        sharedSecret = _MPpow(f, self.proto.dhSecretKey.private_numbers().x, p)",
            "        h = self.hashProcessor()",
            "        h.update(common.NS(self.proto.ourVersionString) * 2)",
            "        h.update(common.NS(self.proto.ourKexInitPayload) * 2)",
            "        h.update(common.NS(self.blob))",
            "        # Here is the wire format for advertised min, pref and max DH sizes.",
            "        h.update(b\"\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x20\\x00\")",
            "        # And the selected group parameters.",
            "        h.update(common.MP(self.P1536) + common.MP(2))",
            "        h.update(self.proto.dhSecretKeyPublicMP)",
            "        h.update(fMP)",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = self.privObj.sign(exchangeHash)",
            "",
            "        return (exchangeHash, signature, common.NS(self.blob) + fMP)",
            "",
            "    def test_KEX_DH_GEX_REPLY(self):",
            "        \"\"\"",
            "        Test that the KEX_DH_GEX_REPLY message results in a verified",
            "        server.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEX_DH_GEX_REPLY()",
            "",
            "        def _cbTestKEX_DH_GEX_REPLY(value):",
            "            self.assertIsNone(value)",
            "            self.assertTrue(self.calledVerifyHostKey)",
            "            self.assertEqual(self.proto.sessionID, exchangeHash)",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_REPLY(packetStart + common.NS(signature))",
            "        d.addCallback(_cbTestKEX_DH_GEX_REPLY)",
            "        return d",
            "",
            "    def test_disconnectGEX_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEX_DH_GEX_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEX_DH_GEX_REPLY()",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_REPLY(packetStart + common.NS(b\"bad signature\"))",
            "        return d.addCallback(",
            "            lambda _: self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "        )",
            "",
            "    def test_disconnectKEX_ECDH_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEX_ECDH_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        kexmsg = (",
            "            b\"\\xAA\" * 16",
            "            + common.NS(b\"ecdh-sha2-nistp256\")",
            "            + common.NS(b\"ssh-rsa\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"aes256-ctr\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"hmac-sha1\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"none\")",
            "            + common.NS(b\"\")",
            "            + common.NS(b\"\")",
            "            + b\"\\x00\"",
            "            + b\"\\x00\\x00\\x00\\x00\"",
            "        )",
            "",
            "        self.proto.ssh_KEXINIT(kexmsg)",
            "",
            "        self.proto.dataReceived(b\"SSH-2.0-OpenSSH\\r\\n\")",
            "",
            "        self.proto.ecPriv = ec.generate_private_key(ec.SECP256R1(), default_backend())",
            "        self.proto.ecPub = self.proto.ecPriv.public_key()",
            "",
            "        # Generate the private key",
            "        thisPriv = ec.generate_private_key(ec.SECP256R1(), default_backend())",
            "        # Get the public key",
            "        thisPub = thisPriv.public_key()",
            "        encPub = thisPub.public_bytes(",
            "            serialization.Encoding.X962, serialization.PublicFormat.UncompressedPoint",
            "        )",
            "        self.proto.curve = ec.SECP256R1()",
            "",
            "        self.proto.kexAlg = b\"ecdh-sha2-nistp256\"",
            "",
            "        self.proto._ssh_KEX_ECDH_REPLY(",
            "            common.NS(MockFactory().getPublicKeys()[b\"ssh-rsa\"].blob())",
            "            + common.NS(encPub)",
            "            + common.NS(b\"bad-signature\")",
            "        )",
            "",
            "        self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "",
            "",
            "class ClientSSHTransportDHGroupExchangeSHA1Tests(",
            "    ClientSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA1Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha1 tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "",
            "class ClientSSHTransportDHGroupExchangeSHA256Tests(",
            "    ClientSSHTransportDHGroupExchangeBaseCase,",
            "    DHGroupExchangeSHA256Mixin,",
            "    TransportTestCase,",
            "):",
            "    \"\"\"",
            "    diffie-hellman-group-exchange-sha256 tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "",
            "class ClientSSHTransportECDHBaseCase(ClientSSHTransportBaseCase):",
            "    \"\"\"",
            "    Elliptic Curve Diffie-Hellman tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "    def test_KEXINIT(self):",
            "        \"\"\"",
            "        KEXINIT packet with an elliptic curve key exchange results",
            "        in a KEXDH_INIT message.",
            "        \"\"\"",
            "        self.proto.supportedKeyExchanges = [self.kexAlgorithm]",
            "        self.proto.dataReceived(self.transport.value())",
            "        # The response will include the client's ephemeral public key.",
            "        self.assertEqual(",
            "            self.packets,",
            "            [",
            "                (",
            "                    transport.MSG_KEXDH_INIT,",
            "                    common.NS(self.proto._encodeECPublicKey(self.proto.ecPub)),",
            "                )",
            "            ],",
            "        )",
            "",
            "    def begin_KEXDH_REPLY(self):",
            "        \"\"\"",
            "        Utility for test_KEXDH_REPLY and",
            "        test_disconnectKEXDH_REPLYBadSignature.",
            "",
            "        Begins an Elliptic Curve Diffie-Hellman key exchange and computes",
            "        information needed to return either a correct or incorrect",
            "        signature.",
            "        \"\"\"",
            "        self.test_KEXINIT()",
            "",
            "        privKey = MockFactory().getPrivateKeys()[b\"ssh-rsa\"]",
            "        pubKey = MockFactory().getPublicKeys()[b\"ssh-rsa\"]",
            "        ecPriv = self.proto._generateECPrivateKey()",
            "        ecPub = ecPriv.public_key()",
            "        encPub = self.proto._encodeECPublicKey(ecPub)",
            "",
            "        sharedSecret = self.proto._generateECSharedSecret(",
            "            ecPriv, self.proto._encodeECPublicKey(self.proto.ecPub)",
            "        )",
            "",
            "        h = self.hashProcessor()",
            "        h.update(common.NS(self.proto.ourVersionString))",
            "        h.update(common.NS(self.proto.otherVersionString))",
            "        h.update(common.NS(self.proto.ourKexInitPayload))",
            "        h.update(common.NS(self.proto.otherKexInitPayload))",
            "        h.update(common.NS(pubKey.blob()))",
            "        h.update(common.NS(self.proto._encodeECPublicKey(self.proto.ecPub)))",
            "        h.update(common.NS(encPub))",
            "        h.update(sharedSecret)",
            "        exchangeHash = h.digest()",
            "",
            "        signature = privKey.sign(exchangeHash)",
            "",
            "        return (exchangeHash, signature, common.NS(pubKey.blob()) + common.NS(encPub))",
            "",
            "    def test_KEXDH_REPLY(self):",
            "        \"\"\"",
            "        Test that the KEXDH_REPLY message completes the key exchange.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEXDH_REPLY()",
            "",
            "        def _cbTestKEXDH_REPLY(value):",
            "            self.assertIsNone(value)",
            "            self.assertTrue(self.calledVerifyHostKey)",
            "            self.assertEqual(self.proto.sessionID, exchangeHash)",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_GROUP(packetStart + common.NS(signature))",
            "        d.addCallback(_cbTestKEXDH_REPLY)",
            "        return d",
            "",
            "    def test_disconnectKEXDH_REPLYBadSignature(self):",
            "        \"\"\"",
            "        Test that KEX_ECDH_REPLY disconnects if the signature is bad.",
            "        \"\"\"",
            "        (exchangeHash, signature, packetStart) = self.begin_KEXDH_REPLY()",
            "",
            "        d = self.proto.ssh_KEX_DH_GEX_GROUP(packetStart + common.NS(b\"bad signature\"))",
            "        return d.addCallback(",
            "            lambda _: self.checkDisconnected(transport.DISCONNECT_KEY_EXCHANGE_FAILED)",
            "        )",
            "",
            "",
            "class ClientSSHTransportECDHTests(",
            "    ClientSSHTransportECDHBaseCase, ECDHMixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    ecdh-sha2-nistp256 tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "",
            "@skipWithoutX25519",
            "class ClientSSHTransportCurve25519SHA256Tests(",
            "    ClientSSHTransportECDHBaseCase, Curve25519SHA256Mixin, TransportTestCase",
            "):",
            "    \"\"\"",
            "    curve25519-sha256 tests for SSHClientTransport.",
            "    \"\"\"",
            "",
            "",
            "class GetMACTests(TestCase):",
            "    \"\"\"",
            "    Tests for L{SSHCiphers._getMAC}.",
            "    \"\"\"",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    def setUp(self):",
            "        self.ciphers = transport.SSHCiphers(b\"A\", b\"B\", b\"C\", b\"D\")",
            "",
            "    def getSharedSecret(self):",
            "        \"\"\"",
            "        Generate a new shared secret to be used with the tests.",
            "",
            "        @return: A new secret.",
            "        @rtype: L{bytes}",
            "        \"\"\"",
            "        return insecureRandom(64)",
            "",
            "    def assertGetMAC(self, hmacName, hashProcessor, digestSize, blockPadSize):",
            "        \"\"\"",
            "        Check that when L{SSHCiphers._getMAC} is called with a supportd HMAC",
            "        algorithm name it returns a tuple of",
            "        (digest object, inner pad, outer pad, digest size) with a C{key}",
            "        attribute set to the value of the key supplied.",
            "",
            "        @param hmacName: Identifier of HMAC algorithm.",
            "        @type hmacName: L{bytes}",
            "",
            "        @param hashProcessor: Callable for the hash algorithm.",
            "        @type hashProcessor: C{callable}",
            "",
            "        @param digestSize: Size of the digest for algorithm.",
            "        @type digestSize: L{int}",
            "",
            "        @param blockPadSize: Size of padding applied to the shared secret to",
            "            match the block size.",
            "        @type blockPadSize: L{int}",
            "        \"\"\"",
            "        secret = self.getSharedSecret()",
            "",
            "        params = self.ciphers._getMAC(hmacName, secret)",
            "",
            "        key = secret[:digestSize] + b\"\\x00\" * blockPadSize",
            "        innerPad = bytes(ord(b) ^ 0x36 for b in iterbytes(key))",
            "        outerPad = bytes(ord(b) ^ 0x5C for b in iterbytes(key))",
            "        self.assertEqual((hashProcessor, innerPad, outerPad, digestSize), params)",
            "        self.assertEqual(key, params.key)",
            "",
            "    def test_hmacsha2512(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-sha2-512\"} MAC",
            "        algorithm name it returns a tuple of (sha512 digest object, inner pad,",
            "        outer pad, sha512 digest size) with a C{key} attribute set to the",
            "        value of the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-sha2-512\", sha512, digestSize=64, blockPadSize=64)",
            "",
            "    def test_hmacsha2384(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-sha2-384\"} MAC",
            "        algorithm name it returns a tuple of (sha384 digest object, inner pad,",
            "        outer pad, sha384 digest size) with a C{key} attribute set to the",
            "        value of the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-sha2-384\", sha384, digestSize=48, blockPadSize=80)",
            "",
            "    def test_hmacsha2256(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-sha2-256\"} MAC",
            "        algorithm name it returns a tuple of (sha256 digest object, inner pad,",
            "        outer pad, sha256 digest size) with a C{key} attribute set to the",
            "        value of the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-sha2-256\", sha256, digestSize=32, blockPadSize=32)",
            "",
            "    def test_hmacsha1(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-sha1\"} MAC",
            "        algorithm name it returns a tuple of (sha1 digest object, inner pad,",
            "        outer pad, sha1 digest size) with a C{key} attribute set to the value",
            "        of the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-sha1\", sha1, digestSize=20, blockPadSize=44)",
            "",
            "    def test_hmacmd5(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"hmac-md5\"} MAC",
            "        algorithm name it returns a tuple of (md5 digest object, inner pad,",
            "        outer pad, md5 digest size) with a C{key} attribute set to the value of",
            "        the key supplied.",
            "        \"\"\"",
            "        self.assertGetMAC(b\"hmac-md5\", md5, digestSize=16, blockPadSize=48)",
            "",
            "    def test_none(self):",
            "        \"\"\"",
            "        When L{SSHCiphers._getMAC} is called with the C{b\"none\"} MAC algorithm",
            "        name it returns a tuple of (None, \"\", \"\", 0).",
            "        \"\"\"",
            "        key = self.getSharedSecret()",
            "",
            "        params = self.ciphers._getMAC(b\"none\", key)",
            "",
            "        self.assertEqual((None, b\"\", b\"\", 0), params)",
            "",
            "",
            "class SSHCiphersTests(TestCase):",
            "    \"\"\"",
            "    Tests for the SSHCiphers helper class.",
            "    \"\"\"",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    def test_init(self):",
            "        \"\"\"",
            "        Test that the initializer sets up the SSHCiphers object.",
            "        \"\"\"",
            "        ciphers = transport.SSHCiphers(b\"A\", b\"B\", b\"C\", b\"D\")",
            "        self.assertEqual(ciphers.outCipType, b\"A\")",
            "        self.assertEqual(ciphers.inCipType, b\"B\")",
            "        self.assertEqual(ciphers.outMACType, b\"C\")",
            "        self.assertEqual(ciphers.inMACType, b\"D\")",
            "",
            "    def test_getCipher(self):",
            "        \"\"\"",
            "        Test that the _getCipher method returns the correct cipher.",
            "        \"\"\"",
            "        ciphers = transport.SSHCiphers(b\"A\", b\"B\", b\"C\", b\"D\")",
            "        iv = key = b\"\\x00\" * 16",
            "        for cipName, (algClass, keySize, counter) in ciphers.cipherMap.items():",
            "            cip = ciphers._getCipher(cipName, iv, key)",
            "            if cipName == b\"none\":",
            "                self.assertIsInstance(cip, transport._DummyCipher)",
            "            else:",
            "                self.assertIsInstance(cip.algorithm, algClass)",
            "",
            "    def test_setKeysCiphers(self):",
            "        \"\"\"",
            "        Test that setKeys sets up the ciphers.",
            "        \"\"\"",
            "        key = b\"\\x00\" * 64",
            "        for cipName in transport.SSHTransportBase.supportedCiphers:",
            "            modName, keySize, counter = transport.SSHCiphers.cipherMap[cipName]",
            "            encCipher = transport.SSHCiphers(cipName, b\"none\", b\"none\", b\"none\")",
            "            decCipher = transport.SSHCiphers(b\"none\", cipName, b\"none\", b\"none\")",
            "            cip = encCipher._getCipher(cipName, key, key)",
            "            bs = cip.algorithm.block_size // 8",
            "            encCipher.setKeys(key, key, b\"\", b\"\", b\"\", b\"\")",
            "            decCipher.setKeys(b\"\", b\"\", key, key, b\"\", b\"\")",
            "            self.assertEqual(encCipher.encBlockSize, bs)",
            "            self.assertEqual(decCipher.decBlockSize, bs)",
            "            encryptor = cip.encryptor()",
            "            enc = encryptor.update(key[:bs])",
            "            enc2 = encryptor.update(key[:bs])",
            "            self.assertEqual(encCipher.encrypt(key[:bs]), enc)",
            "            self.assertEqual(encCipher.encrypt(key[:bs]), enc2)",
            "            self.assertEqual(decCipher.decrypt(enc), key[:bs])",
            "            self.assertEqual(decCipher.decrypt(enc2), key[:bs])",
            "",
            "    def test_setKeysMACs(self):",
            "        \"\"\"",
            "        Test that setKeys sets up the MACs.",
            "        \"\"\"",
            "        key = b\"\\x00\" * 64",
            "        for macName, mod in transport.SSHCiphers.macMap.items():",
            "            outMac = transport.SSHCiphers(b\"none\", b\"none\", macName, b\"none\")",
            "            inMac = transport.SSHCiphers(b\"none\", b\"none\", b\"none\", macName)",
            "            outMac.setKeys(b\"\", b\"\", b\"\", b\"\", key, b\"\")",
            "            inMac.setKeys(b\"\", b\"\", b\"\", b\"\", b\"\", key)",
            "            if mod:",
            "                ds = mod().digest_size",
            "            else:",
            "                ds = 0",
            "            self.assertEqual(inMac.verifyDigestSize, ds)",
            "            if mod:",
            "                mod, i, o, ds = outMac._getMAC(macName, key)",
            "            seqid = 0",
            "            data = key",
            "            packet = b\"\\x00\" * 4 + key",
            "            if mod:",
            "                mac = mod(o + mod(i + packet).digest()).digest()",
            "            else:",
            "                mac = b\"\"",
            "            self.assertEqual(outMac.makeMAC(seqid, data), mac)",
            "            self.assertTrue(inMac.verify(seqid, data, mac))",
            "",
            "    def test_makeMAC(self):",
            "        \"\"\"",
            "        L{SSHCiphers.makeMAC} computes the HMAC of an outgoing SSH message with",
            "        a particular sequence id and content data.",
            "        \"\"\"",
            "        # Use the test vectors given in the appendix of RFC 2104.",
            "        vectors = [",
            "            (b\"\\x0b\" * 16, b\"Hi There\", b\"9294727a3638bb1c13f48ef8158bfc9d\"),",
            "            (",
            "                b\"Jefe\",",
            "                b\"what do ya want for nothing?\",",
            "                b\"750c783e6ab0b503eaa86e310a5db738\",",
            "            ),",
            "            (b\"\\xAA\" * 16, b\"\\xDD\" * 50, b\"56be34521d144c88dbb8c733f0e8b3f6\"),",
            "        ]",
            "",
            "        for key, data, mac in vectors:",
            "            outMAC = transport.SSHCiphers(b\"none\", b\"none\", b\"hmac-md5\", b\"none\")",
            "            outMAC.outMAC = outMAC._getMAC(b\"hmac-md5\", key)",
            "            (seqid,) = struct.unpack(\">L\", data[:4])",
            "            shortened = data[4:]",
            "            self.assertEqual(",
            "                mac,",
            "                binascii.hexlify(outMAC.makeMAC(seqid, shortened)),",
            "                f\"Failed HMAC test vector; key={key!r} data={data!r}\",",
            "            )",
            "",
            "",
            "class TransportLoopbackTests(TestCase):",
            "    \"\"\"",
            "    Test the server transport and client transport against each other,",
            "    \"\"\"",
            "",
            "    if dependencySkip:",
            "        skip = dependencySkip",
            "",
            "    def _runClientServer(self, mod):",
            "        \"\"\"",
            "        Run an async client and server, modifying each using the mod function",
            "        provided.  Returns a Deferred called back when both Protocols have",
            "        disconnected.",
            "",
            "        @type mod: C{func}",
            "        @rtype: C{defer.Deferred}",
            "        \"\"\"",
            "        factory = MockFactory()",
            "        server = transport.SSHServerTransport()",
            "        server.factory = factory",
            "        factory.startFactory()",
            "        server.errors = []",
            "        server.receiveError = lambda code, desc: server.errors.append((code, desc))",
            "        client = transport.SSHClientTransport()",
            "        client.verifyHostKey = lambda x, y: defer.succeed(None)",
            "        client.errors = []",
            "        client.receiveError = lambda code, desc: client.errors.append((code, desc))",
            "        client.connectionSecure = lambda: client.loseConnection()",
            "        server.supportedPublicKeys = list(server.factory.getPublicKeys().keys())",
            "        server = mod(server)",
            "        client = mod(client)",
            "",
            "        def check(ignored, server, client):",
            "            name = repr(",
            "                [",
            "                    server.supportedCiphers[0],",
            "                    server.supportedMACs[0],",
            "                    server.supportedKeyExchanges[0],",
            "                    server.supportedCompressions[0],",
            "                ]",
            "            )",
            "            self.assertEqual(client.errors, [])",
            "            self.assertEqual(",
            "                server.errors,",
            "                [(transport.DISCONNECT_CONNECTION_LOST, b\"user closed connection\")],",
            "            )",
            "            if server.supportedCiphers[0] == b\"none\":",
            "                self.assertFalse(server.isEncrypted(), name)",
            "                self.assertFalse(client.isEncrypted(), name)",
            "            else:",
            "                self.assertTrue(server.isEncrypted(), name)",
            "                self.assertTrue(client.isEncrypted(), name)",
            "            if server.supportedMACs[0] == b\"none\":",
            "                self.assertFalse(server.isVerified(), name)",
            "                self.assertFalse(client.isVerified(), name)",
            "            else:",
            "                self.assertTrue(server.isVerified(), name)",
            "                self.assertTrue(client.isVerified(), name)",
            "",
            "        d = loopback.loopbackAsync(server, client)",
            "        d.addCallback(check, server, client)",
            "        return d",
            "",
            "    def test_ciphers(self):",
            "        \"\"\"",
            "        Test that the client and server play nicely together, in all",
            "        the various combinations of ciphers.",
            "        \"\"\"",
            "        deferreds = []",
            "        for cipher in transport.SSHTransportBase.supportedCiphers + [b\"none\"]:",
            "",
            "            def setCipher(proto):",
            "                proto.supportedCiphers = [cipher]",
            "                return proto",
            "",
            "            deferreds.append(self._runClientServer(setCipher))",
            "        return defer.DeferredList(deferreds, fireOnOneErrback=True)",
            "",
            "    def test_macs(self):",
            "        \"\"\"",
            "        Like test_ciphers, but for the various MACs.",
            "        \"\"\"",
            "        deferreds = []",
            "        for mac in transport.SSHTransportBase.supportedMACs + [b\"none\"]:",
            "",
            "            def setMAC(proto):",
            "                proto.supportedMACs = [mac]",
            "                return proto",
            "",
            "            deferreds.append(self._runClientServer(setMAC))",
            "        return defer.DeferredList(deferreds, fireOnOneErrback=True)",
            "",
            "    def test_keyexchanges(self):",
            "        \"\"\"",
            "        Like test_ciphers, but for the various key exchanges.",
            "        \"\"\"",
            "        deferreds = []",
            "        for kexAlgorithm in transport.SSHTransportBase.supportedKeyExchanges:",
            "",
            "            def setKeyExchange(proto):",
            "                proto.supportedKeyExchanges = [kexAlgorithm]",
            "                return proto",
            "",
            "            deferreds.append(self._runClientServer(setKeyExchange))",
            "        return defer.DeferredList(deferreds, fireOnOneErrback=True)",
            "",
            "    def test_compressions(self):",
            "        \"\"\"",
            "        Like test_ciphers, but for the various compressions.",
            "        \"\"\"",
            "        deferreds = []",
            "        for compression in transport.SSHTransportBase.supportedCompressions:",
            "",
            "            def setCompression(proto):",
            "                proto.supportedCompressions = [compression]",
            "                return proto",
            "",
            "            deferreds.append(self._runClientServer(setCompression))",
            "        return defer.DeferredList(deferreds, fireOnOneErrback=True)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "openstack_dashboard.dashboards.project.stacks.forms.TemplateForm",
            "src.twisted.conch.test.test_transport.TransportTestCase.self",
            "src.twisted.conch.test.test_transport.BaseSSHTransportTests.self"
        ]
    }
}