{
    "src/octoprint/plugins/logging/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "             or is_hidden_path(secure)"
            },
            "1": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "             or not filename.endswith(\".log\")"
            },
            "2": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         ):"
            },
            "3": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return make_response(\"File not found: %s\" % filename, 404)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            return make_response(\"File not found\", 404)"
            },
            "5": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         os.remove(secure)"
            },
            "7": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2018 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "import io",
            "import os",
            "",
            "import yaml",
            "from flask import jsonify, make_response, request, url_for",
            "from flask_babel import gettext",
            "from werkzeug.exceptions import BadRequest",
            "from werkzeug.utils import secure_filename",
            "",
            "import octoprint.plugin",
            "from octoprint.access import ADMIN_GROUP",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.server import NO_CONTENT",
            "from octoprint.server.util.flask import no_firstrun_access, redirect_to_tornado",
            "from octoprint.settings import settings",
            "from octoprint.util import is_hidden_path",
            "",
            "try:",
            "    from os import scandir",
            "except ImportError:",
            "    from scandir import scandir",
            "",
            "",
            "class LoggingPlugin(",
            "    octoprint.plugin.AssetPlugin,",
            "    octoprint.plugin.SettingsPlugin,",
            "    octoprint.plugin.TemplatePlugin,",
            "    octoprint.plugin.BlueprintPlugin,",
            "):",
            "",
            "    # Additional permissions hook",
            "",
            "    def get_additional_permissions(self):",
            "        return [",
            "            {",
            "                \"key\": \"MANAGE\",",
            "                \"name\": \"Logging management\",",
            "                \"description\": gettext(",
            "                    \"Allows to download and delete log files and list and set log levels.\"",
            "                ),",
            "                \"default_groups\": [ADMIN_GROUP],",
            "                \"roles\": [\"manage\"],",
            "            }",
            "        ]",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def get_all(self):",
            "        files = self._getLogFiles()",
            "        free, total = self._get_usage()",
            "        loggers = self._get_available_loggers()",
            "        levels = self._get_logging_levels()",
            "        serial_log_enabled = self._settings.global_get_boolean([\"serial\", \"log\"])",
            "        plugintimings_log_enabled = self._settings.global_get_boolean(",
            "            [\"devel\", \"pluginTimings\"]",
            "        )",
            "        return jsonify(",
            "            logs={\"files\": files, \"free\": free, \"total\": total},",
            "            setup={\"loggers\": loggers, \"levels\": levels},",
            "            serial_log={\"enabled\": serial_log_enabled},",
            "            plugintimings_log={\"enabled\": plugintimings_log_enabled},",
            "        )",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/logs\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def get_log_files(self):",
            "        files = self._getLogFiles()",
            "        free, total = self._get_usage()",
            "        return jsonify(files=files, free=free, total=total)",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/logs/<path:filename>\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def download_log(self, filename):",
            "        return redirect_to_tornado(",
            "            request, url_for(\"index\") + \"downloads/logs/\" + filename",
            "        )",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/logs/<path:filename>\", methods=[\"DELETE\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def delete_log(self, filename):",
            "        secure = os.path.join(settings().getBaseFolder(\"logs\"), secure_filename(filename))",
            "        if (",
            "            not os.path.exists(secure)",
            "            or is_hidden_path(secure)",
            "            or not filename.endswith(\".log\")",
            "        ):",
            "            return make_response(\"File not found: %s\" % filename, 404)",
            "",
            "        os.remove(secure)",
            "",
            "        return NO_CONTENT",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/setup\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def get_logging_setup(self):",
            "        loggers = self._get_available_loggers()",
            "        levels = self._get_logging_levels()",
            "        return jsonify(loggers=loggers, levels=levels)",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/setup/levels\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def get_logging_levels_api(self):",
            "        return jsonify(self._get_logging_levels())",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/setup/levels\", methods=[\"PUT\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def set_logging_levels_api(self):",
            "        if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "            return make_response(\"Expected content-type JSON\", 400)",
            "",
            "        try:",
            "            json_data = request.json",
            "        except BadRequest:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        if not isinstance(json_data, dict):",
            "            return make_response(\"Invalid log level configuration\", 400)",
            "",
            "        # TODO validate further",
            "",
            "        self._set_logging_levels(json_data)",
            "        return self.get_logging_levels_api()",
            "",
            "    def is_blueprint_protected(self):",
            "        return False",
            "",
            "    def _get_usage(self):",
            "        import psutil",
            "",
            "        usage = psutil.disk_usage(settings().getBaseFolder(\"logs\", check_writable=False))",
            "        return usage.free, usage.total",
            "",
            "    def _getLogFiles(self):",
            "        files = []",
            "        basedir = settings().getBaseFolder(\"logs\", check_writable=False)",
            "        for entry in scandir(basedir):",
            "            if is_hidden_path(entry.path) or not entry.name.endswith(\".log\"):",
            "                continue",
            "",
            "            if not entry.is_file():",
            "                continue",
            "",
            "            files.append(",
            "                {",
            "                    \"name\": entry.name,",
            "                    \"date\": int(entry.stat().st_mtime),",
            "                    \"size\": entry.stat().st_size,",
            "                    \"refs\": {",
            "                        \"resource\": url_for(",
            "                            \".download_log\", filename=entry.name, _external=True",
            "                        ),",
            "                        \"download\": url_for(\"index\", _external=True)",
            "                        + \"downloads/logs/\"",
            "                        + entry.name,",
            "                    },",
            "                }",
            "            )",
            "",
            "        return files",
            "",
            "    def _get_available_loggers(self):",
            "        return list(",
            "            filter(",
            "                lambda x: self._is_managed_logger(x),",
            "                self._logger.manager.loggerDict.keys(),",
            "            )",
            "        )",
            "",
            "    def _get_logging_file(self):",
            "        # TODO this might not be the logging config we are actually using here (command line parameter...)",
            "        return os.path.join(self._settings.getBaseFolder(\"base\"), \"logging.yaml\")",
            "",
            "    def _get_logging_config(self):",
            "        logging_file = self._get_logging_file()",
            "",
            "        config_from_file = {}",
            "        if os.path.exists(logging_file) and os.path.isfile(logging_file):",
            "            import yaml",
            "",
            "            with io.open(logging_file, \"rt\", encoding=\"utf-8\") as f:",
            "                config_from_file = yaml.safe_load(f)",
            "        return config_from_file",
            "",
            "    def _get_logging_levels(self):",
            "        config = self._get_logging_config()",
            "        if config is None or not isinstance(config, dict):",
            "            return {}",
            "",
            "        return dict(",
            "            (key, value.get(\"level\"))",
            "            for key, value in config.get(\"loggers\", {}).items()",
            "            if isinstance(value, dict) and \"level\" in value",
            "        )",
            "",
            "    def _set_logging_levels(self, new_levels):",
            "        import logging",
            "",
            "        config = self._get_logging_config()",
            "",
            "        # clear all configured logging levels",
            "        if \"loggers\" in config:",
            "            purge = []",
            "            for component, data in config[\"loggers\"].items():",
            "                if not self._is_managed_logger(component):",
            "                    continue",
            "                try:",
            "                    del data[\"level\"]",
            "                    self._logger.manager.loggerDict[component].setLevel(logging.INFO)",
            "                except KeyError:",
            "                    pass",
            "                if len(data) == 0:",
            "                    purge.append(component)",
            "            for component in purge:",
            "                del config[\"loggers\"][component]",
            "        else:",
            "            config[\"loggers\"] = {}",
            "",
            "        # update all logging levels",
            "        for logger, level in new_levels.items():",
            "            if logger not in config[\"loggers\"]:",
            "                config[\"loggers\"][logger] = {}",
            "            config[\"loggers\"][logger][\"level\"] = level",
            "",
            "        # delete empty entries",
            "        config[\"loggers\"] = {k: v for k, v in config[\"loggers\"].items() if len(v)}",
            "",
            "        # save",
            "        with octoprint.util.atomic_write(",
            "            self._get_logging_file(), mode=\"wt\", max_permissions=0o666",
            "        ) as f:",
            "            yaml.safe_dump(",
            "                config, f, default_flow_style=False, indent=2, allow_unicode=True",
            "            )",
            "",
            "        # set runtime logging levels now",
            "        for logger, level in new_levels.items():",
            "            level = logging.getLevelName(level)",
            "",
            "            self._logger.info(\"Setting logger {} level to {}\".format(logger, level))",
            "            self._logger.manager.loggerDict[logger].setLevel(level)",
            "",
            "    def _is_managed_logger(self, logger):",
            "        return logger and (logger.startswith(\"octoprint\") or logger.startswith(\"tornado\"))",
            "",
            "    def get_template_configs(self):",
            "        return [",
            "            {",
            "                \"type\": \"navbar\",",
            "                \"template\": \"logging_navbar_seriallog.jinja2\",",
            "                \"suffix\": \"_seriallog\",",
            "            },",
            "            {",
            "                \"type\": \"navbar\",",
            "                \"template\": \"logging_navbar_plugintimingslog.jinja2\",",
            "                \"suffix\": \"_plugintimingslog\",",
            "            },",
            "            {\"type\": \"settings\", \"custom_bindings\": True},",
            "        ]",
            "",
            "    def get_assets(self):",
            "        return {",
            "            \"js\": [\"js/logging.js\"],",
            "            \"clientjs\": [\"clientjs/logging.js\"],",
            "            \"less\": [\"less/logging.less\"],",
            "            \"css\": [\"css/logging.css\"],",
            "        }",
            "",
            "",
            "__plugin_name__ = \"Logging\"",
            "__plugin_author__ = \"Shawn Bruce, based on work by Gina H\u00e4u\u00dfge and Marc Hannappel\"",
            "__plugin_description__ = \"Provides access to OctoPrint's logs and logging configuration.\"",
            "__plugin_disabling_discouraged__ = gettext(",
            "    \"Without this plugin you will no longer be able to retrieve \"",
            "    \"OctoPrint's logs or modify the current logging levels through \"",
            "    \"the web interface.\"",
            ")",
            "__plugin_license__ = \"AGPLv3\"",
            "__plugin_pythoncompat__ = \">=2.7,<4\"",
            "__plugin_implementation__ = LoggingPlugin()",
            "__plugin_hooks__ = {",
            "    \"octoprint.access.permissions\": __plugin_implementation__.get_additional_permissions",
            "}"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2018 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "import io",
            "import os",
            "",
            "import yaml",
            "from flask import jsonify, make_response, request, url_for",
            "from flask_babel import gettext",
            "from werkzeug.exceptions import BadRequest",
            "from werkzeug.utils import secure_filename",
            "",
            "import octoprint.plugin",
            "from octoprint.access import ADMIN_GROUP",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.server import NO_CONTENT",
            "from octoprint.server.util.flask import no_firstrun_access, redirect_to_tornado",
            "from octoprint.settings import settings",
            "from octoprint.util import is_hidden_path",
            "",
            "try:",
            "    from os import scandir",
            "except ImportError:",
            "    from scandir import scandir",
            "",
            "",
            "class LoggingPlugin(",
            "    octoprint.plugin.AssetPlugin,",
            "    octoprint.plugin.SettingsPlugin,",
            "    octoprint.plugin.TemplatePlugin,",
            "    octoprint.plugin.BlueprintPlugin,",
            "):",
            "",
            "    # Additional permissions hook",
            "",
            "    def get_additional_permissions(self):",
            "        return [",
            "            {",
            "                \"key\": \"MANAGE\",",
            "                \"name\": \"Logging management\",",
            "                \"description\": gettext(",
            "                    \"Allows to download and delete log files and list and set log levels.\"",
            "                ),",
            "                \"default_groups\": [ADMIN_GROUP],",
            "                \"roles\": [\"manage\"],",
            "            }",
            "        ]",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def get_all(self):",
            "        files = self._getLogFiles()",
            "        free, total = self._get_usage()",
            "        loggers = self._get_available_loggers()",
            "        levels = self._get_logging_levels()",
            "        serial_log_enabled = self._settings.global_get_boolean([\"serial\", \"log\"])",
            "        plugintimings_log_enabled = self._settings.global_get_boolean(",
            "            [\"devel\", \"pluginTimings\"]",
            "        )",
            "        return jsonify(",
            "            logs={\"files\": files, \"free\": free, \"total\": total},",
            "            setup={\"loggers\": loggers, \"levels\": levels},",
            "            serial_log={\"enabled\": serial_log_enabled},",
            "            plugintimings_log={\"enabled\": plugintimings_log_enabled},",
            "        )",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/logs\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def get_log_files(self):",
            "        files = self._getLogFiles()",
            "        free, total = self._get_usage()",
            "        return jsonify(files=files, free=free, total=total)",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/logs/<path:filename>\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def download_log(self, filename):",
            "        return redirect_to_tornado(",
            "            request, url_for(\"index\") + \"downloads/logs/\" + filename",
            "        )",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/logs/<path:filename>\", methods=[\"DELETE\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def delete_log(self, filename):",
            "        secure = os.path.join(settings().getBaseFolder(\"logs\"), secure_filename(filename))",
            "        if (",
            "            not os.path.exists(secure)",
            "            or is_hidden_path(secure)",
            "            or not filename.endswith(\".log\")",
            "        ):",
            "            return make_response(\"File not found\", 404)",
            "",
            "        os.remove(secure)",
            "",
            "        return NO_CONTENT",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/setup\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def get_logging_setup(self):",
            "        loggers = self._get_available_loggers()",
            "        levels = self._get_logging_levels()",
            "        return jsonify(loggers=loggers, levels=levels)",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/setup/levels\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def get_logging_levels_api(self):",
            "        return jsonify(self._get_logging_levels())",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/setup/levels\", methods=[\"PUT\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_LOGGING_MANAGE.require(403)",
            "    def set_logging_levels_api(self):",
            "        if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "            return make_response(\"Expected content-type JSON\", 400)",
            "",
            "        try:",
            "            json_data = request.json",
            "        except BadRequest:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        if not isinstance(json_data, dict):",
            "            return make_response(\"Invalid log level configuration\", 400)",
            "",
            "        # TODO validate further",
            "",
            "        self._set_logging_levels(json_data)",
            "        return self.get_logging_levels_api()",
            "",
            "    def is_blueprint_protected(self):",
            "        return False",
            "",
            "    def _get_usage(self):",
            "        import psutil",
            "",
            "        usage = psutil.disk_usage(settings().getBaseFolder(\"logs\", check_writable=False))",
            "        return usage.free, usage.total",
            "",
            "    def _getLogFiles(self):",
            "        files = []",
            "        basedir = settings().getBaseFolder(\"logs\", check_writable=False)",
            "        for entry in scandir(basedir):",
            "            if is_hidden_path(entry.path) or not entry.name.endswith(\".log\"):",
            "                continue",
            "",
            "            if not entry.is_file():",
            "                continue",
            "",
            "            files.append(",
            "                {",
            "                    \"name\": entry.name,",
            "                    \"date\": int(entry.stat().st_mtime),",
            "                    \"size\": entry.stat().st_size,",
            "                    \"refs\": {",
            "                        \"resource\": url_for(",
            "                            \".download_log\", filename=entry.name, _external=True",
            "                        ),",
            "                        \"download\": url_for(\"index\", _external=True)",
            "                        + \"downloads/logs/\"",
            "                        + entry.name,",
            "                    },",
            "                }",
            "            )",
            "",
            "        return files",
            "",
            "    def _get_available_loggers(self):",
            "        return list(",
            "            filter(",
            "                lambda x: self._is_managed_logger(x),",
            "                self._logger.manager.loggerDict.keys(),",
            "            )",
            "        )",
            "",
            "    def _get_logging_file(self):",
            "        # TODO this might not be the logging config we are actually using here (command line parameter...)",
            "        return os.path.join(self._settings.getBaseFolder(\"base\"), \"logging.yaml\")",
            "",
            "    def _get_logging_config(self):",
            "        logging_file = self._get_logging_file()",
            "",
            "        config_from_file = {}",
            "        if os.path.exists(logging_file) and os.path.isfile(logging_file):",
            "            import yaml",
            "",
            "            with io.open(logging_file, \"rt\", encoding=\"utf-8\") as f:",
            "                config_from_file = yaml.safe_load(f)",
            "        return config_from_file",
            "",
            "    def _get_logging_levels(self):",
            "        config = self._get_logging_config()",
            "        if config is None or not isinstance(config, dict):",
            "            return {}",
            "",
            "        return dict(",
            "            (key, value.get(\"level\"))",
            "            for key, value in config.get(\"loggers\", {}).items()",
            "            if isinstance(value, dict) and \"level\" in value",
            "        )",
            "",
            "    def _set_logging_levels(self, new_levels):",
            "        import logging",
            "",
            "        config = self._get_logging_config()",
            "",
            "        # clear all configured logging levels",
            "        if \"loggers\" in config:",
            "            purge = []",
            "            for component, data in config[\"loggers\"].items():",
            "                if not self._is_managed_logger(component):",
            "                    continue",
            "                try:",
            "                    del data[\"level\"]",
            "                    self._logger.manager.loggerDict[component].setLevel(logging.INFO)",
            "                except KeyError:",
            "                    pass",
            "                if len(data) == 0:",
            "                    purge.append(component)",
            "            for component in purge:",
            "                del config[\"loggers\"][component]",
            "        else:",
            "            config[\"loggers\"] = {}",
            "",
            "        # update all logging levels",
            "        for logger, level in new_levels.items():",
            "            if logger not in config[\"loggers\"]:",
            "                config[\"loggers\"][logger] = {}",
            "            config[\"loggers\"][logger][\"level\"] = level",
            "",
            "        # delete empty entries",
            "        config[\"loggers\"] = {k: v for k, v in config[\"loggers\"].items() if len(v)}",
            "",
            "        # save",
            "        with octoprint.util.atomic_write(",
            "            self._get_logging_file(), mode=\"wt\", max_permissions=0o666",
            "        ) as f:",
            "            yaml.safe_dump(",
            "                config, f, default_flow_style=False, indent=2, allow_unicode=True",
            "            )",
            "",
            "        # set runtime logging levels now",
            "        for logger, level in new_levels.items():",
            "            level = logging.getLevelName(level)",
            "",
            "            self._logger.info(\"Setting logger {} level to {}\".format(logger, level))",
            "            self._logger.manager.loggerDict[logger].setLevel(level)",
            "",
            "    def _is_managed_logger(self, logger):",
            "        return logger and (logger.startswith(\"octoprint\") or logger.startswith(\"tornado\"))",
            "",
            "    def get_template_configs(self):",
            "        return [",
            "            {",
            "                \"type\": \"navbar\",",
            "                \"template\": \"logging_navbar_seriallog.jinja2\",",
            "                \"suffix\": \"_seriallog\",",
            "            },",
            "            {",
            "                \"type\": \"navbar\",",
            "                \"template\": \"logging_navbar_plugintimingslog.jinja2\",",
            "                \"suffix\": \"_plugintimingslog\",",
            "            },",
            "            {\"type\": \"settings\", \"custom_bindings\": True},",
            "        ]",
            "",
            "    def get_assets(self):",
            "        return {",
            "            \"js\": [\"js/logging.js\"],",
            "            \"clientjs\": [\"clientjs/logging.js\"],",
            "            \"less\": [\"less/logging.less\"],",
            "            \"css\": [\"css/logging.css\"],",
            "        }",
            "",
            "",
            "__plugin_name__ = \"Logging\"",
            "__plugin_author__ = \"Shawn Bruce, based on work by Gina H\u00e4u\u00dfge and Marc Hannappel\"",
            "__plugin_description__ = \"Provides access to OctoPrint's logs and logging configuration.\"",
            "__plugin_disabling_discouraged__ = gettext(",
            "    \"Without this plugin you will no longer be able to retrieve \"",
            "    \"OctoPrint's logs or modify the current logging levels through \"",
            "    \"the web interface.\"",
            ")",
            "__plugin_license__ = \"AGPLv3\"",
            "__plugin_pythoncompat__ = \">=2.7,<4\"",
            "__plugin_implementation__ = LoggingPlugin()",
            "__plugin_hooks__ = {",
            "    \"octoprint.access.permissions\": __plugin_implementation__.get_additional_permissions",
            "}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "97": [
                "LoggingPlugin",
                "delete_log"
            ]
        },
        "addLocation": []
    },
    "src/octoprint/plugins/pluginmanager/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": 646,
                "PatchRowcode": "         elif command == \"uninstall\":"
            },
            "1": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": 647,
                "PatchRowcode": "             plugin_name = data[\"plugin\"]"
            },
            "2": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": 648,
                "PatchRowcode": "             if plugin_name not in self._plugin_manager.plugins:"
            },
            "3": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return make_response(\"Unknown plugin: %s\" % plugin_name, 404)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 649,
                "PatchRowcode": "+                return make_response(\"Unknown plugin\", 404)"
            },
            "5": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 650,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 651,
                "PatchRowcode": "             plugin = self._plugin_manager.plugins[plugin_name]"
            },
            "7": {
                "beforePatchRowNumber": 652,
                "afterPatchRowNumber": 652,
                "PatchRowcode": "             return self.command_uninstall(plugin, cleanup=data.get(\"cleanup\", False))"
            },
            "8": {
                "beforePatchRowNumber": 667,
                "afterPatchRowNumber": 667,
                "PatchRowcode": "         elif command == \"enable\" or command == \"disable\":"
            },
            "9": {
                "beforePatchRowNumber": 668,
                "afterPatchRowNumber": 668,
                "PatchRowcode": "             plugin_name = data[\"plugin\"]"
            },
            "10": {
                "beforePatchRowNumber": 669,
                "afterPatchRowNumber": 669,
                "PatchRowcode": "             if plugin_name not in self._plugin_manager.plugins:"
            },
            "11": {
                "beforePatchRowNumber": 670,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return make_response(\"Unknown plugin: %s\" % plugin_name, 404)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 670,
                "PatchRowcode": "+                return make_response(\"Unknown plugin\", 404)"
            },
            "13": {
                "beforePatchRowNumber": 671,
                "afterPatchRowNumber": 671,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 672,
                "afterPatchRowNumber": 672,
                "PatchRowcode": "             plugin = self._plugin_manager.plugins[plugin_name]"
            },
            "15": {
                "beforePatchRowNumber": 673,
                "afterPatchRowNumber": 673,
                "PatchRowcode": "             return self.command_toggle(plugin, command)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2015 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "import copy",
            "import io",
            "import logging",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import tempfile",
            "import threading",
            "import time",
            "from datetime import datetime",
            "",
            "import filetype",
            "import pkg_resources",
            "import requests",
            "import sarge",
            "from flask import Response, abort, jsonify, make_response, request",
            "from flask_babel import gettext",
            "from past.builtins import basestring",
            "",
            "import octoprint.plugin",
            "import octoprint.plugin.core",
            "from octoprint.access import ADMIN_GROUP",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.events import Events",
            "from octoprint.server import safe_mode",
            "from octoprint.server.util.flask import (",
            "    check_etag,",
            "    no_firstrun_access,",
            "    with_revalidation_checking,",
            ")",
            "from octoprint.settings import valid_boolean_trues",
            "from octoprint.util import TemporaryDirectory, deprecated, to_bytes, to_native_str",
            "from octoprint.util.net import download_file",
            "from octoprint.util.pip import create_pip_caller",
            "from octoprint.util.platform import get_os, is_os_compatible",
            "from octoprint.util.version import (",
            "    get_octoprint_version,",
            "    get_octoprint_version_string,",
            "    is_octoprint_compatible,",
            "    is_python_compatible,",
            ")",
            "",
            "from . import exceptions",
            "",
            "try:",
            "    from os import scandir",
            "except ImportError:",
            "    from scandir import scandir",
            "",
            "_DATA_FORMAT_VERSION = \"v3\"",
            "",
            "DEFAULT_PLUGIN_REPOSITORY = \"https://plugins.octoprint.org/plugins.json\"",
            "DEFAULT_PLUGIN_NOTICES = \"https://plugins.octoprint.org/notices.json\"",
            "",
            "",
            "def map_repository_entry(entry):",
            "    if not isinstance(entry, dict):",
            "        return None",
            "",
            "    result = copy.deepcopy(entry)",
            "",
            "    if \"follow_dependency_links\" not in result:",
            "        result[\"follow_dependency_links\"] = False",
            "",
            "    result[\"is_compatible\"] = {\"octoprint\": True, \"os\": True, \"python\": True}",
            "",
            "    if \"compatibility\" in entry:",
            "        if (",
            "            \"octoprint\" in entry[\"compatibility\"]",
            "            and entry[\"compatibility\"][\"octoprint\"] is not None",
            "            and isinstance(entry[\"compatibility\"][\"octoprint\"], (list, tuple))",
            "            and len(entry[\"compatibility\"][\"octoprint\"])",
            "        ):",
            "            result[\"is_compatible\"][\"octoprint\"] = is_octoprint_compatible(",
            "                *entry[\"compatibility\"][\"octoprint\"]",
            "            )",
            "",
            "        if (",
            "            \"os\" in entry[\"compatibility\"]",
            "            and entry[\"compatibility\"][\"os\"] is not None",
            "            and isinstance(entry[\"compatibility\"][\"os\"], (list, tuple))",
            "            and len(entry[\"compatibility\"][\"os\"])",
            "        ):",
            "            result[\"is_compatible\"][\"os\"] = is_os_compatible(entry[\"compatibility\"][\"os\"])",
            "",
            "        if (",
            "            \"python\" in entry[\"compatibility\"]",
            "            and entry[\"compatibility\"][\"python\"] is not None",
            "            and isinstance(entry[\"compatibility\"][\"python\"], basestring)",
            "        ):",
            "            result[\"is_compatible\"][\"python\"] = is_python_compatible(",
            "                entry[\"compatibility\"][\"python\"]",
            "            )",
            "        else:",
            "            # we default to only assume py2 compatiblity for now",
            "            result[\"is_compatible\"][\"python\"] = is_python_compatible(\">=2.7,<3\")",
            "",
            "    return result",
            "",
            "",
            "already_installed_string = \"Requirement already satisfied (use --upgrade to upgrade)\"",
            "success_string = \"Successfully installed\"",
            "failure_string = \"Could not install\"",
            "",
            "",
            "class PluginManagerPlugin(",
            "    octoprint.plugin.SimpleApiPlugin,",
            "    octoprint.plugin.TemplatePlugin,",
            "    octoprint.plugin.AssetPlugin,",
            "    octoprint.plugin.SettingsPlugin,",
            "    octoprint.plugin.StartupPlugin,",
            "    octoprint.plugin.BlueprintPlugin,",
            "    octoprint.plugin.EventHandlerPlugin,",
            "):",
            "",
            "    ARCHIVE_EXTENSIONS = (\".zip\", \".tar.gz\", \".tgz\", \".tar\", \".gz\")",
            "    PYTHON_EXTENSIONS = (\".py\",)",
            "",
            "    # valid pip install URL schemes according to https://pip.pypa.io/en/stable/reference/pip_install/",
            "    URL_SCHEMES = (",
            "        \"http\",",
            "        \"https\",",
            "        \"git\",",
            "        \"git+http\",",
            "        \"git+https\",",
            "        \"git+ssh\",",
            "        \"git+git\",",
            "        \"hg+http\",",
            "        \"hg+https\",",
            "        \"hg+static-http\",",
            "        \"hg+ssh\",",
            "        \"svn\",",
            "        \"svn+svn\",",
            "        \"svn+http\",",
            "        \"svn+https\",",
            "        \"svn+ssh\",",
            "        \"bzr+http\",",
            "        \"bzr+https\",",
            "        \"bzr+ssh\",",
            "        \"bzr+sftp\",",
            "        \"bzr+ftp\",",
            "        \"bzr+lp\",",
            "    )",
            "",
            "    OPERATING_SYSTEMS = {",
            "        \"windows\": [\"win32\"],",
            "        \"linux\": lambda x: x.startswith(\"linux\"),",
            "        \"macos\": [\"darwin\"],",
            "        \"freebsd\": lambda x: x.startswith(\"freebsd\"),",
            "    }",
            "",
            "    PIP_INAPPLICABLE_ARGUMENTS = {\"uninstall\": [\"--user\"]}",
            "",
            "    RECONNECT_HOOKS = [",
            "        \"octoprint.comm.protocol.*\",",
            "    ]",
            "",
            "    # noinspection PyMissingConstructor",
            "    def __init__(self):",
            "        self._pending_enable = set()",
            "        self._pending_disable = set()",
            "        self._pending_install = set()",
            "        self._pending_uninstall = set()",
            "",
            "        self._pip_caller = None",
            "",
            "        self._repository_available = False",
            "        self._repository_plugins = []",
            "        self._repository_cache_path = None",
            "        self._repository_cache_ttl = 0",
            "        self._repository_mtime = None",
            "",
            "        self._notices = {}",
            "        self._notices_available = False",
            "        self._notices_cache_path = None",
            "        self._notices_cache_ttl = 0",
            "        self._notices_mtime = None",
            "",
            "        self._orphans = None",
            "",
            "        self._console_logger = None",
            "",
            "        self._get_throttled = lambda: False",
            "",
            "        self._install_task = None",
            "        self._install_lock = threading.RLock()",
            "",
            "    def initialize(self):",
            "        self._console_logger = logging.getLogger(",
            "            \"octoprint.plugins.pluginmanager.console\"",
            "        )",
            "        self._repository_cache_path = os.path.join(",
            "            self.get_plugin_data_folder(), \"plugins.json\"",
            "        )",
            "        self._repository_cache_ttl = self._settings.get_int([\"repository_ttl\"]) * 60",
            "        self._notices_cache_path = os.path.join(",
            "            self.get_plugin_data_folder(), \"notices.json\"",
            "        )",
            "        self._notices_cache_ttl = self._settings.get_int([\"notices_ttl\"]) * 60",
            "        self._confirm_disable = self._settings.global_get_boolean([\"confirm_disable\"])",
            "",
            "        self._pip_caller = create_pip_caller(",
            "            command=self._settings.global_get([\"server\", \"commands\", \"localPipCommand\"]),",
            "            force_user=self._settings.get_boolean([\"pip_force_user\"]),",
            "        )",
            "        self._pip_caller.on_log_call = self._log_call",
            "        self._pip_caller.on_log_stdout = self._log_stdout",
            "        self._pip_caller.on_log_stderr = self._log_stderr",
            "",
            "    ##~~ Body size hook",
            "",
            "    def increase_upload_bodysize(self, current_max_body_sizes, *args, **kwargs):",
            "        # set a maximum body size of 50 MB for plugin archive uploads",
            "        return [(\"POST\", r\"/upload_file\", 50 * 1024 * 1024)]",
            "",
            "    # Additional permissions hook",
            "",
            "    def get_additional_permissions(self):",
            "        return [",
            "            {",
            "                \"key\": \"MANAGE\",",
            "                \"name\": \"Manage plugins\",",
            "                \"description\": gettext(",
            "                    \"Allows to enable, disable and uninstall installed plugins.\"",
            "                ),",
            "                \"default_groups\": [ADMIN_GROUP],",
            "                \"roles\": [\"manage\"],",
            "            },",
            "            {",
            "                \"key\": \"INSTALL\",",
            "                \"name\": \"Install new plugins\",",
            "                \"description\": gettext(",
            "                    'Allows to install new plugins. Includes the \"Manage plugins\" permission.'",
            "                ),",
            "                \"default_groups\": [ADMIN_GROUP],",
            "                \"roles\": [\"install\"],",
            "                \"permissions\": [\"PLUGIN_PLUGINMANAGER_MANAGE\"],",
            "                \"dangerous\": True,",
            "            },",
            "        ]",
            "",
            "    ##~~ StartupPlugin",
            "",
            "    def on_after_startup(self):",
            "        from octoprint.logging.handlers import CleaningTimedRotatingFileHandler",
            "",
            "        console_logging_handler = CleaningTimedRotatingFileHandler(",
            "            self._settings.get_plugin_logfile_path(postfix=\"console\"),",
            "            when=\"D\",",
            "            backupCount=3,",
            "        )",
            "        console_logging_handler.setFormatter(logging.Formatter(\"%(asctime)s %(message)s\"))",
            "        console_logging_handler.setLevel(logging.DEBUG)",
            "",
            "        self._console_logger.addHandler(console_logging_handler)",
            "        self._console_logger.setLevel(logging.DEBUG)",
            "        self._console_logger.propagate = False",
            "",
            "        helpers = self._plugin_manager.get_helpers(\"pi_support\", \"get_throttled\")",
            "        if helpers and \"get_throttled\" in helpers:",
            "            self._get_throttled = helpers[\"get_throttled\"]",
            "            if self._settings.get_boolean([\"ignore_throttled\"]):",
            "                self._logger.warning(",
            "                    \"!!! THROTTLE STATE IGNORED !!! You have configured the Plugin Manager plugin to ignore an active throttle state of the underlying system. You might run into stability issues or outright corrupt your install. Consider fixing the throttling issue instead of suppressing it.\"",
            "                )",
            "",
            "        # decouple repository fetching from server startup",
            "        self._fetch_all_data(do_async=True)",
            "",
            "    ##~~ SettingsPlugin",
            "",
            "    def get_settings_defaults(self):",
            "        return {",
            "            \"repository\": DEFAULT_PLUGIN_REPOSITORY,",
            "            \"repository_ttl\": 24 * 60,",
            "            \"notices\": DEFAULT_PLUGIN_NOTICES,",
            "            \"notices_ttl\": 6 * 60,",
            "            \"pip_args\": None,",
            "            \"pip_force_user\": False,",
            "            \"confirm_disable\": False,",
            "            \"dependency_links\": False,",
            "            \"hidden\": [],",
            "            \"ignore_throttled\": False,",
            "        }",
            "",
            "    def on_settings_save(self, data):",
            "        octoprint.plugin.SettingsPlugin.on_settings_save(self, data)",
            "",
            "        self._repository_cache_ttl = self._settings.get_int([\"repository_ttl\"]) * 60",
            "        self._notices_cache_ttl = self._settings.get_int([\"notices_ttl\"]) * 60",
            "        self._pip_caller.force_user = self._settings.get_boolean([\"pip_force_user\"])",
            "        self._confirm_disable = self._settings.global_get_boolean([\"confirm_disable\"])",
            "",
            "    ##~~ AssetPlugin",
            "",
            "    def get_assets(self):",
            "        return {",
            "            \"js\": [\"js/pluginmanager.js\"],",
            "            \"clientjs\": [\"clientjs/pluginmanager.js\"],",
            "            \"css\": [\"css/pluginmanager.css\"],",
            "            \"less\": [\"less/pluginmanager.less\"],",
            "        }",
            "",
            "    ##~~ TemplatePlugin",
            "",
            "    def get_template_configs(self):",
            "        return [",
            "            {",
            "                \"type\": \"settings\",",
            "                \"name\": gettext(\"Plugin Manager\"),",
            "                \"template\": \"pluginmanager_settings.jinja2\",",
            "                \"custom_bindings\": True,",
            "            },",
            "            {",
            "                \"type\": \"about\",",
            "                \"name\": \"Plugin Licenses\",",
            "                \"template\": \"pluginmanager_about.jinja2\",",
            "            },",
            "        ]",
            "",
            "    def get_template_vars(self):",
            "        plugins = sorted(self._get_plugins(), key=lambda x: x[\"name\"].lower())",
            "        return {",
            "            \"all\": plugins,",
            "            \"thirdparty\": list(filter(lambda p: not p[\"bundled\"], plugins)),",
            "            \"file_extensions\": self.ARCHIVE_EXTENSIONS + self.PYTHON_EXTENSIONS,",
            "        }",
            "",
            "    def get_template_types(self, template_sorting, template_rules, *args, **kwargs):",
            "        return [",
            "            (",
            "                \"about_thirdparty\",",
            "                {},",
            "                {\"template\": lambda x: x + \"_about_thirdparty.jinja2\"},",
            "            )",
            "        ]",
            "",
            "    ##~~ BlueprintPlugin",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/upload_file\", methods=[\"POST\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_PLUGINMANAGER_INSTALL.require(403)",
            "    def upload_file(self):",
            "        import flask",
            "",
            "        input_name = \"file\"",
            "        input_upload_path = (",
            "            input_name",
            "            + \".\"",
            "            + self._settings.global_get([\"server\", \"uploads\", \"pathSuffix\"])",
            "        )",
            "        input_upload_name = (",
            "            input_name",
            "            + \".\"",
            "            + self._settings.global_get([\"server\", \"uploads\", \"nameSuffix\"])",
            "        )",
            "",
            "        if (",
            "            input_upload_path not in flask.request.values",
            "            or input_upload_name not in flask.request.values",
            "        ):",
            "            return flask.make_response(\"No file included\", 400)",
            "        upload_path = flask.request.values[input_upload_path]",
            "        upload_name = flask.request.values[input_upload_name]",
            "",
            "        exts = list(",
            "            filter(",
            "                lambda x: upload_name.lower().endswith(x),",
            "                self.ARCHIVE_EXTENSIONS + self.PYTHON_EXTENSIONS,",
            "            )",
            "        )",
            "        if not len(exts):",
            "            return flask.make_response(",
            "                \"File doesn't have a valid extension for a plugin archive or a single file plugin\",",
            "                400,",
            "            )",
            "",
            "        ext = exts[0]",
            "        archive = tempfile.NamedTemporaryFile(delete=False, suffix=ext)",
            "        archive.close()",
            "        shutil.copy(upload_path, archive.name)",
            "",
            "        def perform_install(source, name, force=False):",
            "            try:",
            "                self.command_install(",
            "                    path=source,",
            "                    name=name,",
            "                    force=force,",
            "                )",
            "            finally:",
            "                try:",
            "                    os.remove(archive.name)",
            "                except Exception as e:",
            "                    self._logger.warning(",
            "                        \"Could not remove temporary file {path} again: {message}\".format(",
            "                            path=archive.name, message=str(e)",
            "                        )",
            "                    )",
            "",
            "        with self._install_lock:",
            "            if self._install_task is not None:",
            "                return make_response(\"There's already a plugin being installed\", 409)",
            "",
            "            self._install_task = threading.Thread(",
            "                target=perform_install,",
            "                args=(archive.name, upload_name),",
            "                kwargs={",
            "                    \"force\": \"force\" in flask.request.values",
            "                    and flask.request.values[\"force\"] in valid_boolean_trues",
            "                },",
            "            )",
            "            self._install_task.daemon = True",
            "            self._install_task.start()",
            "",
            "            return jsonify(in_progress=True)",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/export\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def export_plugin_list(self):",
            "        import json",
            "",
            "        plugins = self.generate_plugins_json(self._settings, self._plugin_manager)",
            "",
            "        return Response(",
            "            json.dumps(plugins),",
            "            mimetype=\"text/plain\",",
            "            headers={\"Content-Disposition\": 'attachment; filename=\"plugin_list.json\"'},",
            "        )",
            "",
            "    def _plugin_response(self):",
            "        return {",
            "            \"plugins\": self._get_plugins(),",
            "            \"os\": get_os(),",
            "            \"octoprint\": get_octoprint_version_string(),",
            "            \"pip\": {",
            "                \"available\": self._pip_caller.available,",
            "                \"version\": self._pip_caller.version_string,",
            "                \"install_dir\": self._pip_caller.install_dir,",
            "                \"use_user\": self._pip_caller.use_user,",
            "                \"virtual_env\": self._pip_caller.virtual_env,",
            "                \"additional_args\": self._settings.get([\"pip_args\"]),",
            "                \"python\": sys.executable,",
            "            },",
            "            \"safe_mode\": safe_mode,",
            "            \"online\": self._connectivity_checker.online,",
            "        }",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/plugins\")",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def retrieve_plugins(self):",
            "        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues",
            "        if refresh or not self._is_notices_cache_valid():",
            "            self._notices_available = self._refresh_notices()",
            "",
            "        def view():",
            "            return jsonify(**self._plugin_response())",
            "",
            "        def etag():",
            "            import hashlib",
            "",
            "            hash = hashlib.sha1()",
            "",
            "            def hash_update(value):",
            "                value = value.encode(\"utf-8\")",
            "                hash.update(value)",
            "",
            "            hash_update(repr(self._get_plugins()))",
            "            hash_update(str(self._notices_available))",
            "            hash_update(repr(self._notices))",
            "            hash_update(repr(safe_mode))",
            "            hash_update(repr(self._connectivity_checker.online))",
            "            hash_update(repr(_DATA_FORMAT_VERSION))",
            "            return hash.hexdigest()",
            "",
            "        def condition():",
            "            return check_etag(etag())",
            "",
            "        return with_revalidation_checking(",
            "            etag_factory=lambda *args, **kwargs: etag(),",
            "            condition=lambda *args, **kwargs: condition(),",
            "            unless=lambda: refresh,",
            "        )(view)()",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/plugins/<string:key>\")",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def retrieve_specific_plugin(self, key):",
            "        plugin = self._plugin_manager.get_plugin_info(key, require_enabled=False)",
            "        if plugin is None:",
            "            return abort(404)",
            "",
            "        return jsonify(plugin=self._to_external_plugin(plugin))",
            "",
            "    def _orphan_response(self):",
            "        return {\"orphan_data\": self._get_orphans()}",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/orphans\")",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def retrieve_plugin_orphans(self):",
            "        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():",
            "            return make_response(\"Insufficient rights\", 403)",
            "",
            "        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues",
            "        if refresh:",
            "            self._get_orphans(refresh=True)",
            "",
            "        def view():",
            "            return jsonify(**self._orphan_response())",
            "",
            "        def etag():",
            "            import hashlib",
            "",
            "            hash = hashlib.sha1()",
            "",
            "            def hash_update(value):",
            "                value = value.encode(\"utf-8\")",
            "                hash.update(value)",
            "",
            "            hash_update(repr(self._get_orphans()))",
            "            hash_update(repr(_DATA_FORMAT_VERSION))",
            "            return hash.hexdigest()",
            "",
            "        def condition():",
            "            return check_etag(etag())",
            "",
            "        return with_revalidation_checking(",
            "            etag_factory=lambda *args, **kwargs: etag(),",
            "            condition=lambda *args, **kwargs: condition(),",
            "            unless=lambda: refresh,",
            "        )(view)()",
            "",
            "    def _repository_response(self):",
            "        return {",
            "            \"repository\": {",
            "                \"available\": self._repository_available,",
            "                \"plugins\": self._repository_plugins,",
            "            }",
            "        }",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/repository\")",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def retrieve_plugin_repository(self):",
            "        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():",
            "            return make_response(\"Insufficient rights\", 403)",
            "",
            "        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues",
            "        if refresh or not self._is_repository_cache_valid():",
            "            self._repository_available = self._refresh_repository()",
            "",
            "        def view():",
            "            return jsonify(**self._repository_response())",
            "",
            "        def etag():",
            "            import hashlib",
            "",
            "            hash = hashlib.sha1()",
            "",
            "            def hash_update(value):",
            "                value = value.encode(\"utf-8\")",
            "                hash.update(value)",
            "",
            "            hash_update(str(self._repository_available))",
            "            hash_update(repr(self._repository_plugins))",
            "            hash_update(repr(_DATA_FORMAT_VERSION))",
            "            return hash.hexdigest()",
            "",
            "        def condition():",
            "            return check_etag(etag())",
            "",
            "        return with_revalidation_checking(",
            "            etag_factory=lambda *args, **kwargs: etag(),",
            "            condition=lambda *args, **kwargs: condition(),",
            "            unless=lambda: refresh,",
            "        )(view)()",
            "",
            "    def is_blueprint_protected(self):",
            "        return False",
            "",
            "    ##~~ EventHandlerPlugin",
            "",
            "    def on_event(self, event, payload):",
            "        from octoprint.events import Events",
            "",
            "        if (",
            "            event != Events.CONNECTIVITY_CHANGED",
            "            or not payload",
            "            or not payload.get(\"new\", False)",
            "        ):",
            "            return",
            "        self._fetch_all_data(do_async=True)",
            "",
            "    ##~~ SimpleApiPlugin",
            "",
            "    def get_api_commands(self):",
            "        return {",
            "            \"install\": [\"url\"],",
            "            \"uninstall\": [\"plugin\"],",
            "            \"enable\": [\"plugin\"],",
            "            \"disable\": [\"plugin\"],",
            "            \"cleanup\": [\"plugin\"],",
            "            \"cleanup_all\": [],",
            "            \"refresh_repository\": [],",
            "        }",
            "",
            "    def on_api_command(self, command, data):",
            "        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():",
            "            return make_response(\"Insufficient rights\", 403)",
            "",
            "        if self._printer.is_printing() or self._printer.is_paused():",
            "            # do not update while a print job is running",
            "            return make_response(\"Printer is currently printing or paused\", 409)",
            "",
            "        if command == \"install\":",
            "            if not Permissions.PLUGIN_PLUGINMANAGER_INSTALL.can():",
            "                return make_response(\"Insufficient rights\", 403)",
            "            url = data[\"url\"]",
            "            plugin_name = data[\"plugin\"] if \"plugin\" in data else None",
            "",
            "            with self._install_lock:",
            "                if self._install_task is not None:",
            "                    return make_response(\"There's already a plugin being installed\", 409)",
            "",
            "                self._install_task = threading.Thread(",
            "                    target=self.command_install,",
            "                    kwargs={",
            "                        \"url\": url,",
            "                        \"force\": \"force\" in data and data[\"force\"] in valid_boolean_trues,",
            "                        \"dependency_links\": \"dependency_links\" in data",
            "                        and data[\"dependency_links\"] in valid_boolean_trues,",
            "                        \"reinstall\": plugin_name,",
            "                    },",
            "                )",
            "                self._install_task.daemon = True",
            "                self._install_task.start()",
            "",
            "                return jsonify(in_progress=True)",
            "",
            "        elif command == \"uninstall\":",
            "            plugin_name = data[\"plugin\"]",
            "            if plugin_name not in self._plugin_manager.plugins:",
            "                return make_response(\"Unknown plugin: %s\" % plugin_name, 404)",
            "",
            "            plugin = self._plugin_manager.plugins[plugin_name]",
            "            return self.command_uninstall(plugin, cleanup=data.get(\"cleanup\", False))",
            "",
            "        elif command == \"cleanup\":",
            "            plugin = data[\"plugin\"]",
            "            try:",
            "                plugin = self._plugin_manager.plugins[plugin]",
            "            except KeyError:",
            "                # not installed, we are cleaning up left overs, that's ok",
            "                pass",
            "",
            "            return self.command_cleanup(plugin, include_disabled=True)",
            "",
            "        elif command == \"cleanup_all\":",
            "            return self.command_cleanup_all()",
            "",
            "        elif command == \"enable\" or command == \"disable\":",
            "            plugin_name = data[\"plugin\"]",
            "            if plugin_name not in self._plugin_manager.plugins:",
            "                return make_response(\"Unknown plugin: %s\" % plugin_name, 404)",
            "",
            "            plugin = self._plugin_manager.plugins[plugin_name]",
            "            return self.command_toggle(plugin, command)",
            "",
            "    @deprecated(",
            "        \"Deprecated API endpoint api/plugin/pluginmanager used. \"",
            "        \"Please switch clients to plugin/pluginmanager/*\",",
            "        since=\"1.6.0\",",
            "    )",
            "    def on_api_get(self, r):",
            "        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():",
            "            return make_response(\"Insufficient rights\", 403)",
            "",
            "        refresh_repository = (",
            "            request.values.get(\"refresh_repository\", \"false\") in valid_boolean_trues",
            "        )",
            "        if refresh_repository or not self._is_repository_cache_valid():",
            "            self._repository_available = self._refresh_repository()",
            "",
            "        refresh_notices = (",
            "            request.values.get(\"refresh_notices\", \"false\") in valid_boolean_trues",
            "        )",
            "        if refresh_notices or not self._is_notices_cache_valid():",
            "            self._notices_available = self._refresh_notices()",
            "",
            "        refresh_orphan = (",
            "            request.values.get(\"refresh_orphans\", \"false\") in valid_boolean_trues",
            "        )",
            "        if refresh_orphan:",
            "            self._get_orphans(refresh=True)",
            "",
            "        result = {}",
            "        result.update(**self._plugin_response())",
            "        result.update(**self._orphan_response())",
            "        result.update(**self._repository_response())",
            "        return jsonify(**result)",
            "",
            "    # noinspection PyMethodMayBeStatic",
            "    def _is_archive(self, path):",
            "        _, ext = os.path.splitext(path)",
            "        if ext in PluginManagerPlugin.ARCHIVE_EXTENSIONS:",
            "            return True",
            "",
            "        kind = filetype.guess(to_native_str(path))",
            "        if kind:",
            "            return \".{}\".format(kind.extension) in PluginManagerPlugin.ARCHIVE_EXTENSIONS",
            "        return False",
            "",
            "    def _is_pythonfile(self, path):",
            "        _, ext = os.path.splitext(path)",
            "        if ext in PluginManagerPlugin.PYTHON_EXTENSIONS:",
            "            import ast",
            "",
            "            try:",
            "                with io.open(path, \"rb\") as f:",
            "                    ast.parse(f.read(), filename=path)",
            "                return True",
            "            except Exception as exc:",
            "                self._logger.exception(",
            "                    \"Could not parse {} as python file: {}\".format(path, exc)",
            "                )",
            "",
            "        return False",
            "",
            "    def command_install(",
            "        self,",
            "        url=None,",
            "        path=None,",
            "        name=None,",
            "        force=False,",
            "        reinstall=None,",
            "        dependency_links=False,",
            "    ):",
            "        folder = None",
            "",
            "        with self._install_lock:",
            "            try:",
            "                source = path",
            "                source_type = \"path\"",
            "",
            "                if url is not None:",
            "                    # fetch URL",
            "                    folder = TemporaryDirectory()",
            "                    path = download_file(url, folder.name)",
            "                    source = url",
            "                    source_type = \"url\"",
            "",
            "                # determine type of path",
            "                if self._is_archive(path):",
            "                    result = self._command_install_archive(",
            "                        path,",
            "                        source=source,",
            "                        source_type=source_type,",
            "                        force=force,",
            "                        reinstall=reinstall,",
            "                        dependency_links=dependency_links,",
            "                    )",
            "",
            "                elif self._is_pythonfile(path):",
            "                    result = self._command_install_pythonfile(",
            "                        path, source=source, source_type=source_type, name=name",
            "                    )",
            "",
            "                else:",
            "                    raise exceptions.InvalidPackageFormat()",
            "",
            "            except requests.exceptions.HTTPError as e:",
            "                self._logger.error(\"Could not fetch plugin from server, got {}\".format(e))",
            "                result = {",
            "                    \"result\": False,",
            "                    \"source\": source,",
            "                    \"source_type\": source_type,",
            "                    \"reason\": \"Could not fetch plugin from server, got {}\".format(e),",
            "                }",
            "                self._send_result_notification(\"install\", result)",
            "",
            "            except exceptions.InvalidPackageFormat:",
            "                self._logger.error(",
            "                    \"{} is neither an archive nor a python file, can't install that.\".format(",
            "                        source",
            "                    )",
            "                )",
            "                result = {",
            "                    \"result\": False,",
            "                    \"source\": source,",
            "                    \"source_type\": source_type,",
            "                    \"reason\": \"Could not install plugin from {}, was neither \"",
            "                    \"a plugin archive nor a single file plugin\".format(source),",
            "                }",
            "                self._send_result_notification(\"install\", result)",
            "",
            "            except Exception:",
            "                error_msg = (",
            "                    \"Unexpected error while trying to install plugin from {}\".format(",
            "                        source",
            "                    )",
            "                )",
            "                self._logger.exception(error_msg)",
            "                result = {",
            "                    \"result\": False,",
            "                    \"source\": source,",
            "                    \"source_type\": source_type,",
            "                    \"reason\": error_msg,",
            "                }",
            "                self._send_result_notification(\"install\", result)",
            "",
            "            finally:",
            "                if folder is not None:",
            "                    folder.cleanup()",
            "                self._install_task = None",
            "",
            "        return result",
            "",
            "    # noinspection DuplicatedCode",
            "    def _command_install_archive(",
            "        self,",
            "        path,",
            "        source=None,",
            "        source_type=None,",
            "        force=False,",
            "        reinstall=None,",
            "        dependency_links=False,",
            "    ):",
            "        throttled = self._get_throttled()",
            "        if (",
            "            throttled",
            "            and isinstance(throttled, dict)",
            "            and throttled.get(\"current_issue\", False)",
            "            and not self._settings.get_boolean([\"ignore_throttled\"])",
            "        ):",
            "            # currently throttled, we refuse to run",
            "            error_msg = (",
            "                \"System is currently throttled, refusing to install anything\"",
            "                \" due to possible stability issues\"",
            "            )",
            "            self._logger.error(error_msg)",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": error_msg,",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        try:",
            "            # Py3",
            "            from urllib.parse import quote as url_quote",
            "        except ImportError:",
            "            # Py2",
            "            from urllib import quote as url_quote",
            "",
            "        path = os.path.abspath(path)",
            "        if os.sep != \"/\":",
            "            # windows gets special handling",
            "            drive, loc = os.path.splitdrive(path)",
            "            path_url = (",
            "                \"file:///\" + drive.lower() + url_quote(loc.replace(os.sep, \"/\").lower())",
            "            )",
            "            shell_quote = lambda x: x  # do not shell quote under windows, non posix shell",
            "        else:",
            "            path_url = \"file://\" + url_quote(path)",
            "            shell_quote = sarge.shell_quote",
            "",
            "        already_installed_check = (",
            "            lambda line: path_url in line.lower()",
            "        )  # lower case in case of windows",
            "",
            "        self._logger.info(\"Installing plugin from {}\".format(source))",
            "        pip_args = [",
            "            \"--disable-pip-version-check\",",
            "            \"install\",",
            "            shell_quote(path_url),",
            "            \"--no-cache-dir\",",
            "        ]",
            "",
            "        if dependency_links or self._settings.get_boolean([\"dependency_links\"]):",
            "            pip_args.append(\"--process-dependency-links\")",
            "",
            "        all_plugins_before = self._plugin_manager.find_plugins(existing={})",
            "",
            "        try:",
            "            returncode, stdout, stderr = self._call_pip(pip_args)",
            "",
            "            # pip's output for a package that is already installed looks something like any of these:",
            "            #",
            "            #   Requirement already satisfied (use --upgrade to upgrade): OctoPrint-Plugin==1.0 from \\",
            "            #     https://example.com/foobar.zip in <lib>",
            "            #   Requirement already satisfied (use --upgrade to upgrade): OctoPrint-Plugin in <lib>",
            "            #   Requirement already satisfied (use --upgrade to upgrade): OctoPrint-Plugin==1.0 from \\",
            "            #     file:///tmp/foobar.zip in <lib>",
            "            #   Requirement already satisfied (use --upgrade to upgrade): OctoPrint-Plugin==1.0 from \\",
            "            #     file:///C:/Temp/foobar.zip in <lib>",
            "            #",
            "            # If we detect any of these matching what we just tried to install, we'll need to trigger a second",
            "            # install with reinstall flags.",
            "",
            "            if not force and any(",
            "                map(",
            "                    lambda x: x.strip().startswith(already_installed_string)",
            "                    and already_installed_check(x),",
            "                    stdout,",
            "                )",
            "            ):",
            "                self._logger.info(",
            "                    \"Plugin to be installed from {} was already installed, forcing a reinstall\".format(",
            "                        source",
            "                    )",
            "                )",
            "                self._log_message(",
            "                    \"Looks like the plugin was already installed. Forcing a reinstall.\"",
            "                )",
            "                force = True",
            "        except Exception as e:",
            "            self._logger.exception(\"Could not install plugin from {}\".format(source))",
            "            self._logger.exception(\"Reason: {}\".format(repr(e)))",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": \"Could not install plugin from {}, see the log for more details\".format(",
            "                    source",
            "                ),",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        else:",
            "            if force:",
            "                # We don't use --upgrade here because that will also happily update all our dependencies - we'd rather",
            "                # do that in a controlled manner",
            "                pip_args += [\"--ignore-installed\", \"--force-reinstall\", \"--no-deps\"]",
            "                try:",
            "                    returncode, stdout, stderr = self._call_pip(pip_args)",
            "                except Exception as e:",
            "                    self._logger.exception(",
            "                        \"Could not install plugin from {}\".format(source)",
            "                    )",
            "                    self._logger.exception(\"Reason: {}\".format(repr(e)))",
            "                    result = {",
            "                        \"result\": False,",
            "                        \"source\": source,",
            "                        \"source_type\": source_type,",
            "                        \"reason\": \"Could not install plugin from source {}, see the log for more details\".format(",
            "                            source",
            "                        ),",
            "                    }",
            "                    self._send_result_notification(\"install\", result)",
            "                    return result",
            "",
            "        try:",
            "            result_line = list(",
            "                filter(",
            "                    lambda x: x.startswith(success_string)",
            "                    or x.startswith(failure_string),",
            "                    stdout,",
            "                )",
            "            )[-1]",
            "        except IndexError:",
            "            self._logger.error(",
            "                \"Installing the plugin from {} failed, could not parse output from pip. \"",
            "                \"See plugin_pluginmanager_console.log for generated output\".format(source)",
            "            )",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": \"Could not parse output from pip, see plugin_pluginmanager_console.log \"",
            "                \"for generated output\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        # The final output of a pip install command looks something like this:",
            "        #",
            "        #   Successfully installed OctoPrint-Plugin-1.0 Dependency-One-0.1 Dependency-Two-9.3",
            "        #",
            "        # or this:",
            "        #",
            "        #   Successfully installed OctoPrint-Plugin Dependency-One Dependency-Two",
            "        #   Cleaning up...",
            "        #",
            "        # So we'll need to fetch the \"Successfully installed\" line, strip the \"Successfully\" part, then split",
            "        # by whitespace and strip to get all installed packages.",
            "        #",
            "        # We then need to iterate over all known plugins and see if either the package name or the package name plus",
            "        # version number matches one of our installed packages. If it does, that's our installed plugin.",
            "        #",
            "        # Known issue: This might return the wrong plugin if more than one plugin was installed through this",
            "        # command (e.g. due to pulling in another plugin as dependency). It should be safe for now though to",
            "        # consider this a rare corner case. Once it becomes a real problem we'll just extend the plugin manager",
            "        # so that it can report on more than one installed plugin.",
            "",
            "        result_line = result_line.strip()",
            "        if not result_line.startswith(success_string):",
            "            self._logger.error(",
            "                \"Installing the plugin from {} failed, pip did not report successful installation\".format(",
            "                    source",
            "                )",
            "            )",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": \"Pip did not report successful installation\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        installed = list(",
            "            map(lambda x: x.strip(), result_line[len(success_string) :].split(\" \"))",
            "        )",
            "        all_plugins_after = self._plugin_manager.find_plugins(",
            "            existing={}, ignore_uninstalled=False",
            "        )",
            "",
            "        new_plugin = self._find_installed_plugin(installed, plugins=all_plugins_after)",
            "",
            "        if new_plugin is None:",
            "            self._logger.warning(",
            "                \"The plugin was installed successfully, but couldn't be found afterwards to \"",
            "                \"initialize properly during runtime. Please restart OctoPrint.\"",
            "            )",
            "            result = {",
            "                \"result\": True,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"needs_restart\": True,",
            "                \"needs_refresh\": True,",
            "                \"needs_reconnect\": True,",
            "                \"was_reinstalled\": False,",
            "                \"plugin\": \"unknown\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        self._plugin_manager.reload_plugins()",
            "        needs_restart = (",
            "            self._plugin_manager.is_restart_needing_plugin(new_plugin)",
            "            or new_plugin.key in all_plugins_before",
            "            or reinstall is not None",
            "        )",
            "        needs_refresh = new_plugin.implementation and isinstance(",
            "            new_plugin.implementation, octoprint.plugin.ReloadNeedingPlugin",
            "        )",
            "        needs_reconnect = (",
            "            self._plugin_manager.has_any_of_hooks(new_plugin, self._reconnect_hooks)",
            "            and self._printer.is_operational()",
            "        )",
            "",
            "        is_reinstall = self._plugin_manager.is_plugin_marked(",
            "            new_plugin.key, \"uninstalled\"",
            "        )",
            "        self._plugin_manager.mark_plugin(",
            "            new_plugin.key,",
            "            uninstalled=False,",
            "            installed=not is_reinstall and needs_restart,",
            "        )",
            "",
            "        self._plugin_manager.log_all_plugins()",
            "",
            "        self._logger.info(",
            "            \"The plugin was installed successfully: {}, version {}\".format(",
            "                new_plugin.name, new_plugin.version",
            "            )",
            "        )",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_INSTALL_PLUGIN,",
            "            {",
            "                \"id\": new_plugin.key,",
            "                \"version\": new_plugin.version,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "            },",
            "        )",
            "",
            "        result = {",
            "            \"result\": True,",
            "            \"source\": source,",
            "            \"source_type\": source_type,",
            "            \"needs_restart\": needs_restart,",
            "            \"needs_refresh\": needs_refresh,",
            "            \"needs_reconnect\": needs_reconnect,",
            "            \"was_reinstalled\": new_plugin.key in all_plugins_before",
            "            or reinstall is not None,",
            "            \"plugin\": self._to_external_plugin(new_plugin),",
            "        }",
            "        self._send_result_notification(\"install\", result)",
            "        return result",
            "",
            "    # noinspection DuplicatedCode",
            "    def _command_install_pythonfile(self, path, source=None, source_type=None, name=None):",
            "        if name is None:",
            "            name = os.path.basename(path)",
            "",
            "        self._logger.info(\"Installing single file plugin {} from {}\".format(name, source))",
            "",
            "        all_plugins_before = self._plugin_manager.find_plugins(existing={})",
            "",
            "        destination = os.path.join(self._settings.global_get_basefolder(\"plugins\"), name)",
            "        plugin_id, _ = os.path.splitext(name)",
            "",
            "        try:",
            "            self._log_call(\"cp {} {}\".format(path, destination))",
            "            shutil.copy(path, destination)",
            "        except Exception:",
            "            self._logger.exception(\"Installing plugin from {} failed\".format(source))",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": \"Plugin could not be copied\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        plugins = self._plugin_manager.find_plugins(existing={}, ignore_uninstalled=False)",
            "        new_plugin = plugins.get(plugin_id)",
            "        if new_plugin is None:",
            "            self._logger.warning(",
            "                \"The plugin was installed successfully, but couldn't be found afterwards to \"",
            "                \"initialize properly during runtime. Please restart OctoPrint.\"",
            "            )",
            "            result = {",
            "                \"result\": True,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"needs_restart\": True,",
            "                \"needs_refresh\": True,",
            "                \"needs_reconnect\": True,",
            "                \"was_reinstalled\": False,",
            "                \"plugin\": \"unknown\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        self._plugin_manager.reload_plugins()",
            "        needs_restart = (",
            "            self._plugin_manager.is_restart_needing_plugin(new_plugin)",
            "            or new_plugin.key in all_plugins_before",
            "        )",
            "        needs_refresh = new_plugin.implementation and isinstance(",
            "            new_plugin.implementation, octoprint.plugin.ReloadNeedingPlugin",
            "        )",
            "        needs_reconnect = (",
            "            self._plugin_manager.has_any_of_hooks(new_plugin, self._reconnect_hooks)",
            "            and self._printer.is_operational()",
            "        )",
            "",
            "        self._logger.info(",
            "            \"The plugin was installed successfully: {}, version {}\".format(",
            "                new_plugin.name, new_plugin.version",
            "            )",
            "        )",
            "        self._plugin_manager.log_all_plugins()",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_INSTALL_PLUGIN,",
            "            {",
            "                \"id\": new_plugin.key,",
            "                \"version\": new_plugin.version,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "            },",
            "        )",
            "",
            "        result = {",
            "            \"result\": True,",
            "            \"source\": source,",
            "            \"source_type\": source_type,",
            "            \"needs_restart\": needs_restart,",
            "            \"needs_refresh\": needs_refresh,",
            "            \"needs_reconnect\": needs_reconnect,",
            "            \"was_reinstalled\": new_plugin.key in all_plugins_before,",
            "            \"plugin\": self._to_external_plugin(new_plugin),",
            "        }",
            "        self._send_result_notification(\"install\", result)",
            "        return result",
            "",
            "    def command_uninstall(self, plugin, cleanup=False):",
            "        if plugin.key == \"pluginmanager\":",
            "            return make_response(\"Can't uninstall Plugin Manager\", 403)",
            "",
            "        if not plugin.managable:",
            "            return make_response(",
            "                \"Plugin is not managable and hence cannot be uninstalled\", 403",
            "            )",
            "",
            "        if plugin.bundled:",
            "            return make_response(\"Bundled plugins cannot be uninstalled\", 403)",
            "",
            "        if plugin.origin is None:",
            "            self._logger.warning(",
            "                \"Trying to uninstall plugin {plugin} but origin is unknown\".format(",
            "                    **locals()",
            "                )",
            "            )",
            "            return make_response(\"Could not uninstall plugin, its origin is unknown\")",
            "",
            "        if plugin.origin.type == \"entry_point\":",
            "            # plugin is installed through entry point, need to use pip to uninstall it",
            "            origin = plugin.origin[3]",
            "            if origin is None:",
            "                origin = plugin.origin[2]",
            "",
            "            pip_args = [\"--disable-pip-version-check\", \"uninstall\", \"--yes\", origin]",
            "            try:",
            "                self._call_pip(pip_args)",
            "            except Exception:",
            "                self._logger.exception(\"Could not uninstall plugin via pip\")",
            "                return make_response(",
            "                    \"Could not uninstall plugin via pip, see the log for more details\",",
            "                    500,",
            "                )",
            "",
            "        elif plugin.origin.type == \"folder\":",
            "            import os",
            "            import shutil",
            "",
            "            full_path = os.path.realpath(plugin.location)",
            "",
            "            if os.path.isdir(full_path):",
            "                # plugin is installed via a plugin folder, need to use rmtree to get rid of it",
            "                self._log_stdout(",
            "                    \"Deleting plugin from {folder}\".format(folder=plugin.location)",
            "                )",
            "                shutil.rmtree(full_path)",
            "            elif os.path.isfile(full_path):",
            "                self._log_stdout(",
            "                    \"Deleting plugin from {file}\".format(file=plugin.location)",
            "                )",
            "                os.remove(full_path)",
            "",
            "                if full_path.endswith(\".py\"):",
            "                    pyc_file = \"{full_path}c\".format(**locals())",
            "                    if os.path.isfile(pyc_file):",
            "                        self._log_stdout(",
            "                            \"Deleting plugin from {file}\".format(file=pyc_file)",
            "                        )",
            "                        os.remove(pyc_file)",
            "",
            "        else:",
            "            self._logger.warning(",
            "                \"Trying to uninstall plugin {plugin} but origin is unknown ({plugin.origin.type})\".format(",
            "                    **locals()",
            "                )",
            "            )",
            "            return make_response(\"Could not uninstall plugin, its origin is unknown\")",
            "",
            "        needs_restart = self._plugin_manager.is_restart_needing_plugin(plugin) or cleanup",
            "        needs_refresh = plugin.implementation and isinstance(",
            "            plugin.implementation, octoprint.plugin.ReloadNeedingPlugin",
            "        )",
            "        needs_reconnect = (",
            "            self._plugin_manager.has_any_of_hooks(plugin, self._reconnect_hooks)",
            "            and self._printer.is_operational()",
            "        )",
            "",
            "        was_pending_install = self._plugin_manager.is_plugin_marked(",
            "            plugin.key, \"installed\"",
            "        )",
            "        self._plugin_manager.mark_plugin(",
            "            plugin.key,",
            "            uninstalled=not was_pending_install and needs_restart,",
            "            installed=False,",
            "        )",
            "",
            "        if not needs_restart:",
            "            try:",
            "                if plugin.enabled:",
            "                    self._plugin_manager.disable_plugin(plugin.key, plugin=plugin)",
            "            except octoprint.plugin.core.PluginLifecycleException as e:",
            "                self._logger.exception(",
            "                    \"Problem disabling plugin {name}\".format(name=plugin.key)",
            "                )",
            "                result = {",
            "                    \"result\": False,",
            "                    \"uninstalled\": True,",
            "                    \"disabled\": False,",
            "                    \"unloaded\": False,",
            "                    \"reason\": e.reason,",
            "                }",
            "                self._send_result_notification(\"uninstall\", result)",
            "                return jsonify(result)",
            "",
            "            try:",
            "                if plugin.loaded:",
            "                    self._plugin_manager.unload_plugin(plugin.key)",
            "            except octoprint.plugin.core.PluginLifecycleException as e:",
            "                self._logger.exception(",
            "                    \"Problem unloading plugin {name}\".format(name=plugin.key)",
            "                )",
            "                result = {",
            "                    \"result\": False,",
            "                    \"uninstalled\": True,",
            "                    \"disabled\": True,",
            "                    \"unloaded\": False,",
            "                    \"reason\": e.reason,",
            "                }",
            "                self._send_result_notification(\"uninstall\", result)",
            "                return jsonify(result)",
            "",
            "        self._plugin_manager.reload_plugins()",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_UNINSTALL_PLUGIN,",
            "            {\"id\": plugin.key, \"version\": plugin.version},",
            "        )",
            "",
            "        result = {",
            "            \"result\": True,",
            "            \"needs_restart\": needs_restart,",
            "            \"needs_refresh\": needs_refresh,",
            "            \"needs_reconnect\": needs_reconnect,",
            "            \"plugin\": self._to_external_plugin(plugin),",
            "        }",
            "        self._send_result_notification(\"uninstall\", result)",
            "        self._logger.info(\"Plugin {} uninstalled\".format(plugin.key))",
            "",
            "        self._cleanup_disabled(plugin.key)",
            "        if cleanup:",
            "            self.command_cleanup(plugin.key, result_notifications=False)",
            "",
            "        return jsonify(result)",
            "",
            "    def command_cleanup(",
            "        self,",
            "        plugin,",
            "        include_disabled=False,",
            "        result_notifications=True,",
            "        settings_save=True,",
            "    ):",
            "        if isinstance(plugin, basestring):",
            "            key = result_value = plugin",
            "        else:",
            "            key = plugin.key",
            "            result_value = self._to_external_plugin(plugin)",
            "",
            "        message = \"Cleaning up plugin {}...\".format(key)",
            "        self._logger.info(message)",
            "        self._log_stdout(message)",
            "",
            "        # delete plugin settings",
            "        self._cleanup_settings(key)",
            "",
            "        # delete plugin disabled entry",
            "        if include_disabled:",
            "            self._cleanup_disabled(key)",
            "",
            "        # delete plugin data folder",
            "        result_data = True",
            "        if not self._cleanup_data(key):",
            "            message = \"Could not delete data folder of plugin {}\".format(key)",
            "            self._logger.exception(message)",
            "            self._log_stderr(message)",
            "            result_data = False",
            "",
            "        if settings_save:",
            "            self._settings.save()",
            "",
            "        result = {\"result\": result_data, \"needs_restart\": True, \"plugin\": result_value}",
            "        if result_notifications:",
            "            self._send_result_notification(\"cleanup\", result)",
            "",
            "        # cleaning orphan cache",
            "        self._orphans = None",
            "",
            "        return jsonify(result)",
            "",
            "    def command_cleanup_all(self):",
            "        orphans = self._get_orphans()",
            "        cleaned_up = set()",
            "",
            "        for orphan in sorted(orphans.keys()):",
            "            self.command_cleanup(",
            "                orphan,",
            "                include_disabled=True,",
            "                result_notifications=False,",
            "                settings_save=False,",
            "            )",
            "            cleaned_up.add(orphan)",
            "",
            "        self._settings.save()",
            "",
            "        result = {",
            "            \"result\": True,",
            "            \"needs_restart\": len(cleaned_up) > 0,",
            "            \"cleaned_up\": sorted(list(cleaned_up)),",
            "        }",
            "        self._send_result_notification(\"cleanup_all\", result)",
            "        self._logger.info(",
            "            \"Cleaned up all data, {} left overs removed\".format(len(cleaned_up))",
            "        )",
            "",
            "        # cleaning orphan cache",
            "        self._orphans = None",
            "",
            "        return jsonify(result)",
            "",
            "    def _cleanup_disabled(self, plugin):",
            "        # delete from disabled list",
            "        disabled = self._settings.global_get([\"plugins\", \"_disabled\"])",
            "        try:",
            "            disabled.remove(plugin)",
            "        except ValueError:",
            "            # not in list, ok",
            "            pass",
            "        self._settings.global_set([\"plugins\", \"_disabled\"], disabled)",
            "",
            "    def _cleanup_settings(self, plugin):",
            "        # delete plugin settings",
            "        self._settings.global_remove([\"plugins\", plugin])",
            "        self._settings.global_remove([\"server\", \"seenWizards\", plugin])",
            "        return True",
            "",
            "    def _cleanup_data(self, plugin):",
            "        import os",
            "        import shutil",
            "",
            "        data_folder = os.path.join(self._settings.getBaseFolder(\"data\"), plugin)",
            "        if os.path.exists(data_folder):",
            "            try:",
            "                shutil.rmtree(data_folder)",
            "                return True",
            "            except Exception:",
            "                self._logger.exception(",
            "                    \"Could not delete plugin data folder at {}\".format(data_folder)",
            "                )",
            "                return False",
            "        else:",
            "            return True",
            "",
            "    def command_toggle(self, plugin, command):",
            "        if plugin.key == \"pluginmanager\" or (plugin.hidden and plugin.bundled):",
            "            return make_response(\"Can't enable/disable Plugin Manager\", 400)",
            "",
            "        pending = (command == \"disable\" and plugin.key in self._pending_enable) or (",
            "            command == \"enable\" and plugin.key in self._pending_disable",
            "        )",
            "        safe_mode_victim = getattr(plugin, \"safe_mode_victim\", False)",
            "",
            "        needs_restart = self._plugin_manager.is_restart_needing_plugin(plugin)",
            "        needs_refresh = plugin.implementation and isinstance(",
            "            plugin.implementation, octoprint.plugin.ReloadNeedingPlugin",
            "        )",
            "        needs_reconnect = (",
            "            self._plugin_manager.has_any_of_hooks(plugin, self._reconnect_hooks)",
            "            and self._printer.is_operational()",
            "        )",
            "",
            "        needs_restart_api = (",
            "            needs_restart or safe_mode_victim or plugin.forced_disabled",
            "        ) and not pending",
            "        needs_refresh_api = needs_refresh and not pending",
            "        needs_reconnect_api = needs_reconnect and not pending",
            "",
            "        try:",
            "            if command == \"disable\":",
            "                self._mark_plugin_disabled(plugin, needs_restart=needs_restart)",
            "            elif command == \"enable\":",
            "                self._mark_plugin_enabled(plugin, needs_restart=needs_restart)",
            "        except octoprint.plugin.core.PluginLifecycleException as e:",
            "            self._logger.exception(",
            "                \"Problem toggling enabled state of {name}: {reason}\".format(",
            "                    name=plugin.key, reason=e.reason",
            "                )",
            "            )",
            "            result = {\"result\": False, \"reason\": e.reason}",
            "        except octoprint.plugin.core.PluginNeedsRestart:",
            "            result = {",
            "                \"result\": True,",
            "                \"needs_restart\": True,",
            "                \"needs_refresh\": True,",
            "                \"needs_reconnect\": True,",
            "                \"plugin\": self._to_external_plugin(plugin),",
            "            }",
            "        else:",
            "            result = {",
            "                \"result\": True,",
            "                \"needs_restart\": needs_restart_api,",
            "                \"needs_refresh\": needs_refresh_api,",
            "                \"needs_reconnect\": needs_reconnect_api,",
            "                \"plugin\": self._to_external_plugin(plugin),",
            "            }",
            "",
            "        self._send_result_notification(command, result)",
            "        return jsonify(result)",
            "",
            "    def _find_installed_plugin(self, packages, plugins=None):",
            "        if plugins is None:",
            "            plugins = self._plugin_manager.find_plugins(",
            "                existing={}, ignore_uninstalled=False",
            "            )",
            "",
            "        for plugin in plugins.values():",
            "            if plugin.origin is None or plugin.origin.type != \"entry_point\":",
            "                continue",
            "",
            "            package_name = plugin.origin.package_name",
            "            package_version = plugin.origin.package_version",
            "            versioned_package = \"{package_name}-{package_version}\".format(**locals())",
            "",
            "            if package_name in packages or versioned_package in packages:",
            "                # exact match, we are done here",
            "                return plugin",
            "",
            "            else:",
            "                # it might still be a version that got stripped by python's package resources, e.g. 1.4.5a0 => 1.4.5a",
            "                found = False",
            "",
            "                for inst in packages:",
            "                    if inst.startswith(versioned_package):",
            "                        found = True",
            "                        break",
            "",
            "                if found:",
            "                    return plugin",
            "",
            "        return None",
            "",
            "    def _send_result_notification(self, action, result):",
            "        notification = {\"type\": \"result\", \"action\": action}",
            "        notification.update(result)",
            "        self._plugin_manager.send_plugin_message(self._identifier, notification)",
            "",
            "    def _call_pip(self, args):",
            "        if self._pip_caller is None or not self._pip_caller.available:",
            "            raise RuntimeError(\"No pip available, can't operate\".format(**locals()))",
            "",
            "        if \"--process-dependency-links\" in args:",
            "            self._log_message(",
            "                \"Installation needs to process external dependencies, that might make it take a bit longer than usual depending on the pip version\"",
            "            )",
            "",
            "        additional_args = self._settings.get([\"pip_args\"])",
            "",
            "        if additional_args is not None:",
            "",
            "            inapplicable_arguments = self.__class__.PIP_INAPPLICABLE_ARGUMENTS.get(",
            "                args[0], list()",
            "            )",
            "            for inapplicable_argument in inapplicable_arguments:",
            "                additional_args = re.sub(",
            "                    r\"(^|\\s)\" + re.escape(inapplicable_argument) + r\"\\\\b\",",
            "                    \"\",",
            "                    additional_args,",
            "                )",
            "",
            "            if additional_args:",
            "                args.append(additional_args)",
            "",
            "        kwargs = {",
            "            \"env\": {",
            "                \"PYTHONWARNINGS\": \"ignore:DEPRECATION::pip._internal.cli.base_command\"",
            "            }",
            "        }",
            "",
            "        return self._pip_caller.execute(*args, **kwargs)",
            "",
            "    def _log_message(self, *lines):",
            "        self._log(lines, prefix=\"*\", stream=\"message\")",
            "",
            "    def _log_call(self, *lines):",
            "        self._log(lines, prefix=\" \", stream=\"call\")",
            "",
            "    def _log_stdout(self, *lines):",
            "        self._log(lines, prefix=\">\", stream=\"stdout\")",
            "",
            "    def _log_stderr(self, *lines):",
            "        self._log(lines, prefix=\"!\", stream=\"stderr\")",
            "",
            "    def _log(self, lines, prefix=None, stream=None, strip=True):",
            "        if strip:",
            "            lines = list(map(lambda x: x.strip(), lines))",
            "",
            "        self._plugin_manager.send_plugin_message(",
            "            self._identifier,",
            "            {",
            "                \"type\": \"loglines\",",
            "                \"loglines\": [{\"line\": line, \"stream\": stream} for line in lines],",
            "            },",
            "        )",
            "        for line in lines:  # noqa: B007",
            "            self._console_logger.debug(\"{prefix} {line}\".format(**locals()))",
            "",
            "    def _mark_plugin_enabled(self, plugin, needs_restart=False):",
            "        disabled_list = list(",
            "            self._settings.global_get(",
            "                [\"plugins\", \"_disabled\"],",
            "                validator=lambda x: isinstance(x, list),",
            "                fallback=[],",
            "            )",
            "        )",
            "        if plugin.key in disabled_list:",
            "            disabled_list.remove(plugin.key)",
            "            self._settings.global_set([\"plugins\", \"_disabled\"], disabled_list)",
            "            self._settings.save(force=True)",
            "",
            "        if (",
            "            not needs_restart",
            "            and not plugin.forced_disabled",
            "            and not getattr(plugin, \"safe_mode_victim\", False)",
            "        ):",
            "            self._plugin_manager.enable_plugin(plugin.key)",
            "        else:",
            "            if plugin.key in self._pending_disable:",
            "                self._pending_disable.remove(plugin.key)",
            "            elif not plugin.enabled and plugin.key not in self._pending_enable:",
            "                self._pending_enable.add(plugin.key)",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_ENABLE_PLUGIN,",
            "            {\"id\": plugin.key, \"version\": plugin.version},",
            "        )",
            "",
            "    def _mark_plugin_disabled(self, plugin, needs_restart=False):",
            "        disabled_list = list(",
            "            self._settings.global_get(",
            "                [\"plugins\", \"_disabled\"],",
            "                validator=lambda x: isinstance(x, list),",
            "                fallback=[],",
            "            )",
            "        )",
            "        if plugin.key not in disabled_list:",
            "            disabled_list.append(plugin.key)",
            "            self._settings.global_set([\"plugins\", \"_disabled\"], disabled_list)",
            "            self._settings.save(force=True)",
            "",
            "        if (",
            "            not needs_restart",
            "            and not plugin.forced_disabled",
            "            and not getattr(plugin, \"safe_mode_victim\", False)",
            "        ):",
            "            self._plugin_manager.disable_plugin(plugin.key)",
            "        else:",
            "            if plugin.key in self._pending_enable:",
            "                self._pending_enable.remove(plugin.key)",
            "            elif (",
            "                plugin.enabled",
            "                or plugin.forced_disabled",
            "                or getattr(plugin, \"safe_mode_victim\", False)",
            "            ) and plugin.key not in self._pending_disable:",
            "                self._pending_disable.add(plugin.key)",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_DISABLE_PLUGIN,",
            "            {\"id\": plugin.key, \"version\": plugin.version},",
            "        )",
            "",
            "    def _fetch_all_data(self, do_async=False):",
            "        def run():",
            "            self._repository_available = self._fetch_repository_from_disk()",
            "            self._notices_available = self._fetch_notices_from_disk()",
            "",
            "        if do_async:",
            "            thread = threading.Thread(target=run)",
            "            thread.daemon = True",
            "            thread.start()",
            "        else:",
            "            run()",
            "",
            "    def _is_repository_cache_valid(self, mtime=None):",
            "        import time",
            "",
            "        if mtime is None:",
            "            mtime = self._repository_mtime",
            "        if mtime is None:",
            "            return False",
            "        return mtime + self._repository_cache_ttl >= time.time() > mtime",
            "",
            "    def _fetch_repository_from_disk(self):",
            "        repo_data = None",
            "        if os.path.isfile(self._repository_cache_path):",
            "            mtime = os.path.getmtime(self._repository_cache_path)",
            "            if self._is_repository_cache_valid(mtime=mtime):",
            "                try:",
            "                    import json",
            "",
            "                    with io.open(",
            "                        self._repository_cache_path, \"rt\", encoding=\"utf-8\"",
            "                    ) as f:",
            "                        repo_data = json.load(f)",
            "                    self._repository_mtime = mtime",
            "                    self._logger.info(",
            "                        \"Loaded plugin repository data from disk, was still valid\"",
            "                    )",
            "                except Exception:",
            "                    self._logger.exception(",
            "                        \"Error while loading repository data from {}\".format(",
            "                            self._repository_cache_path",
            "                        )",
            "                    )",
            "",
            "        return self._refresh_repository(repo_data=repo_data)",
            "",
            "    def _fetch_repository_from_url(self):",
            "        if not self._connectivity_checker.online:",
            "            self._logger.info(",
            "                \"Looks like we are offline, can't fetch repository from network\"",
            "            )",
            "            return None",
            "",
            "        repository_url = self._settings.get([\"repository\"])",
            "        try:",
            "            r = requests.get(repository_url, timeout=30)",
            "            r.raise_for_status()",
            "            self._logger.info(",
            "                \"Loaded plugin repository data from {}\".format(repository_url)",
            "            )",
            "        except Exception as e:",
            "            self._logger.exception(",
            "                \"Could not fetch plugins from repository at {repository_url}: {message}\".format(",
            "                    repository_url=repository_url, message=e",
            "                )",
            "            )",
            "            return None",
            "",
            "        try:",
            "            repo_data = r.json()",
            "        except Exception as e:",
            "            self._logger.exception(\"Error while reading repository data: {}\".format(e))",
            "            return None",
            "",
            "        # validation",
            "        if not isinstance(repo_data, (list, tuple)):",
            "            self._logger.warning(",
            "                \"Invalid repository data: expected a list, got {!r}\".format(repo_data)",
            "            )",
            "            return None",
            "",
            "        try:",
            "            import json",
            "",
            "            with octoprint.util.atomic_write(self._repository_cache_path, mode=\"wb\") as f:",
            "                f.write(to_bytes(json.dumps(repo_data)))",
            "            self._repository_mtime = os.path.getmtime(self._repository_cache_path)",
            "        except Exception as e:",
            "            self._logger.exception(",
            "                \"Error while saving repository data to {}: {}\".format(",
            "                    self._repository_cache_path, e",
            "                )",
            "            )",
            "",
            "        return repo_data",
            "",
            "    def _refresh_repository(self, repo_data=None):",
            "        if repo_data is None:",
            "            repo_data = self._fetch_repository_from_url()",
            "            if repo_data is None:",
            "                return False",
            "",
            "        self._repository_plugins = list(",
            "            filter(lambda x: x is not None, map(map_repository_entry, repo_data))",
            "        )",
            "        return True",
            "",
            "    def _is_notices_cache_valid(self, mtime=None):",
            "        import time",
            "",
            "        if mtime is None:",
            "            mtime = self._notices_mtime",
            "        if mtime is None:",
            "            return False",
            "        return mtime + self._notices_cache_ttl >= time.time() > mtime",
            "",
            "    def _fetch_notices_from_disk(self):",
            "        notice_data = None",
            "        if os.path.isfile(self._notices_cache_path):",
            "            mtime = os.path.getmtime(self._notices_cache_path)",
            "            if self._is_notices_cache_valid(mtime=mtime):",
            "                try:",
            "                    import json",
            "",
            "                    with io.open(self._notices_cache_path, \"rt\", encoding=\"utf-8\") as f:",
            "                        notice_data = json.load(f)",
            "                    self._notices_mtime = mtime",
            "                    self._logger.info(\"Loaded notice data from disk, was still valid\")",
            "                except Exception:",
            "                    self._logger.exception(",
            "                        \"Error while loading notices from {}\".format(",
            "                            self._notices_cache_path",
            "                        )",
            "                    )",
            "",
            "        return self._refresh_notices(notice_data=notice_data)",
            "",
            "    def _fetch_notices_from_url(self):",
            "        if not self._connectivity_checker.online:",
            "            self._logger.info(",
            "                \"Looks like we are offline, can't fetch notices from network\"",
            "            )",
            "            return None",
            "",
            "        notices_url = self._settings.get([\"notices\"])",
            "        try:",
            "            r = requests.get(notices_url, timeout=30)",
            "            r.raise_for_status()",
            "            self._logger.info(\"Loaded plugin notices data from {}\".format(notices_url))",
            "        except Exception as e:",
            "            self._logger.exception(",
            "                \"Could not fetch notices from {notices_url}: {message}\".format(",
            "                    notices_url=notices_url, message=str(e)",
            "                )",
            "            )",
            "            return None",
            "",
            "        notice_data = r.json()",
            "",
            "        try:",
            "            import json",
            "",
            "            with octoprint.util.atomic_write(self._notices_cache_path, mode=\"wb\") as f:",
            "                f.write(to_bytes(json.dumps(notice_data)))",
            "            self._notices_mtime = os.path.getmtime(self._notices_cache_path)",
            "        except Exception as e:",
            "            self._logger.exception(",
            "                \"Error while saving notices to {}: {}\".format(",
            "                    self._notices_cache_path, str(e)",
            "                )",
            "            )",
            "        return notice_data",
            "",
            "    def _refresh_notices(self, notice_data=None):",
            "        if notice_data is None:",
            "            notice_data = self._fetch_notices_from_url()",
            "            if notice_data is None:",
            "                return False",
            "",
            "        notices = {}",
            "        for notice in notice_data:",
            "            if \"plugin\" not in notice or \"text\" not in notice or \"date\" not in notice:",
            "                continue",
            "",
            "            key = notice[\"plugin\"]",
            "",
            "            try:",
            "                # Jekyll turns \"%Y-%m-%d %H:%M:%SZ\" into \"%Y-%m-%d %H:%M:%S +0000\", so be sure to ignore \"+0000\"",
            "                #",
            "                # Being able to use dateutil here would make things way easier but sadly that can no longer get",
            "                # installed (from source) under OctoPi 0.14 due to its setuptools-scm dependency, so we have to do",
            "                # without it for now until we can drop support for OctoPi 0.14.",
            "                parsed_date = datetime.strptime(notice[\"date\"], \"%Y-%m-%d %H:%M:%S +0000\")",
            "                notice[\"timestamp\"] = parsed_date.timetuple()",
            "            except Exception as e:",
            "                self._logger.warning(",
            "                    \"Error while parsing date {!r} for plugin notice \"",
            "                    \"of plugin {}, ignoring notice: {}\".format(",
            "                        notice[\"date\"], key, str(e)",
            "                    )",
            "                )",
            "                continue",
            "",
            "            if key not in notices:",
            "                notices[key] = []",
            "            notices[key].append(notice)",
            "",
            "        self._notices = notices",
            "        return True",
            "",
            "    def _get_orphans(self, refresh=False):",
            "        from collections import defaultdict",
            "",
            "        if self._orphans is not None and not refresh:",
            "            return self._orphans",
            "",
            "        installed_keys = self._plugin_manager.plugins.keys()",
            "        orphans = defaultdict(",
            "            lambda: {\"settings\": False, \"data\": False, \"disabled\": False}",
            "        )",
            "",
            "        # settings",
            "        for key in list(self._settings.global_get([\"plugins\"]).keys()):",
            "            if key.startswith(\"_\"):",
            "                # internal key, like _disabled",
            "                continue",
            "",
            "            if key not in installed_keys:",
            "                orphans[key][\"settings\"] = True",
            "",
            "        # data",
            "        for entry in scandir(self._settings.getBaseFolder(\"data\")):",
            "            if not entry.is_dir():",
            "                continue",
            "",
            "            if entry.name not in installed_keys:",
            "                orphans[entry.name][\"data\"] = True",
            "",
            "        # disabled",
            "        disabled = self._settings.global_get([\"plugins\", \"_disabled\"])",
            "        for key in disabled:",
            "            if key not in installed_keys:",
            "                orphans[key][\"disabled\"] = True",
            "",
            "        self._orphans = dict(**orphans)",
            "        return self._orphans",
            "",
            "    @property",
            "    def _reconnect_hooks(self):",
            "        reconnect_hooks = self.__class__.RECONNECT_HOOKS",
            "",
            "        reconnect_hook_provider_hooks = self._plugin_manager.get_hooks(",
            "            \"octoprint.plugin.pluginmanager.reconnect_hooks\"",
            "        )",
            "        for name, hook in reconnect_hook_provider_hooks.items():",
            "            try:",
            "                result = hook()",
            "                if isinstance(result, (list, tuple)):",
            "                    reconnect_hooks.extend(",
            "                        filter(lambda x: isinstance(x, basestring), result)",
            "                    )",
            "            except Exception:",
            "                self._logger.exception(",
            "                    \"Error while retrieving additional hooks for which a \"",
            "                    \"reconnect is required from plugin {name}\".format(**locals()),",
            "                    extra={\"plugin\": name},",
            "                )",
            "",
            "        return reconnect_hooks",
            "",
            "    def _get_plugins(self):",
            "        plugins = self._plugin_manager.plugins",
            "",
            "        hidden = self._settings.get([\"hidden\"])",
            "        result = []",
            "        for key, plugin in plugins.items():",
            "            if key in hidden or (plugin.bundled and plugin.hidden):",
            "                continue",
            "            result.append(self._to_external_plugin(plugin))",
            "",
            "        return result",
            "",
            "    @staticmethod",
            "    def generate_plugins_json(",
            "        settings, plugin_manager, ignore_bundled=True, ignore_plugins_folder=True",
            "    ):",
            "        plugins = []",
            "        plugin_folder = settings.getBaseFolder(\"plugins\")",
            "        for plugin in plugin_manager.plugins.values():",
            "            if (ignore_bundled and plugin.bundled) or (",
            "                ignore_plugins_folder",
            "                and isinstance(plugin.origin, octoprint.plugin.core.FolderOrigin)",
            "                and plugin.origin.folder == plugin_folder",
            "            ):",
            "                # ignore bundled or from the plugins folder already included in the backup",
            "                continue",
            "",
            "            plugins.append({\"key\": plugin.key, \"name\": plugin.name, \"url\": plugin.url})",
            "        return plugins",
            "",
            "    def _to_external_plugin(self, plugin):",
            "        return {",
            "            \"key\": plugin.key,",
            "            \"name\": plugin.name,",
            "            \"description\": plugin.description,",
            "            \"disabling_discouraged\": gettext(plugin.disabling_discouraged)",
            "            if plugin.disabling_discouraged",
            "            else False,",
            "            \"author\": plugin.author,",
            "            \"version\": plugin.version,",
            "            \"url\": plugin.url,",
            "            \"license\": plugin.license,",
            "            \"python\": plugin.pythoncompat,",
            "            \"bundled\": plugin.bundled,",
            "            \"managable\": plugin.managable,",
            "            \"enabled\": plugin.enabled,",
            "            \"blacklisted\": plugin.blacklisted,",
            "            \"forced_disabled\": plugin.forced_disabled,",
            "            \"incompatible\": plugin.incompatible,",
            "            \"safe_mode_victim\": getattr(plugin, \"safe_mode_victim\", False),",
            "            \"pending_enable\": (",
            "                not plugin.enabled",
            "                and not getattr(plugin, \"safe_mode_victim\", False)",
            "                and plugin.key in self._pending_enable",
            "            ),",
            "            \"pending_disable\": (",
            "                (plugin.enabled or getattr(plugin, \"safe_mode_victim\", False))",
            "                and plugin.key in self._pending_disable",
            "            ),",
            "            \"pending_install\": (",
            "                self._plugin_manager.is_plugin_marked(plugin.key, \"installed\")",
            "            ),",
            "            \"pending_uninstall\": (",
            "                self._plugin_manager.is_plugin_marked(plugin.key, \"uninstalled\")",
            "            ),",
            "            \"origin\": plugin.origin.type,",
            "            \"notifications\": self._get_notifications(plugin),",
            "        }",
            "",
            "    def _get_notifications(self, plugin):",
            "        key = plugin.key",
            "        if not plugin.enabled:",
            "            return",
            "",
            "        if key not in self._notices:",
            "            return",
            "",
            "        octoprint_version = get_octoprint_version(base=True)",
            "        plugin_notifications = self._notices.get(key, [])",
            "",
            "        def map_notification(notification):",
            "            return self._to_external_notification(key, notification)",
            "",
            "        return list(",
            "            filter(",
            "                lambda x: x is not None,",
            "                map(",
            "                    map_notification,",
            "                    filter(",
            "                        lambda n: _filter_relevant_notification(",
            "                            n, plugin.version, octoprint_version",
            "                        ),",
            "                        plugin_notifications,",
            "                    ),",
            "                ),",
            "            )",
            "        )",
            "",
            "    def _to_external_notification(self, key, notification):",
            "        return {",
            "            \"key\": key,",
            "            \"date\": time.mktime(notification[\"timestamp\"]),",
            "            \"text\": notification[\"text\"],",
            "            \"link\": notification.get(\"link\"),",
            "            \"versions\": notification.get(",
            "                \"pluginversions\", notification.get(\"versions\", [])",
            "            ),",
            "            \"important\": notification.get(\"important\", False),",
            "        }",
            "",
            "",
            "def _filter_relevant_notification(notification, plugin_version, octoprint_version):",
            "    if \"pluginversions\" in notification:",
            "        pluginversions = notification[\"pluginversions\"]",
            "",
            "        is_range = lambda x: \"=\" in x or \">\" in x or \"<\" in x",
            "        version_ranges = list(",
            "            map(",
            "                lambda x: pkg_resources.Requirement.parse(notification[\"plugin\"] + x),",
            "                filter(is_range, pluginversions),",
            "            )",
            "        )",
            "        versions = list(filter(lambda x: not is_range(x), pluginversions))",
            "    elif \"versions\" in notification:",
            "        version_ranges = []",
            "        versions = notification[\"versions\"]",
            "    else:",
            "        version_ranges = versions = None",
            "",
            "    return (",
            "        \"text\" in notification",
            "        and \"date\" in notification",
            "        and (",
            "            (version_ranges is None and versions is None)",
            "            or (",
            "                version_ranges",
            "                and (any(map(lambda v: plugin_version in v, version_ranges)))",
            "            )",
            "            or (versions and plugin_version in versions)",
            "        )",
            "        and (",
            "            \"octoversions\" not in notification",
            "            or is_octoprint_compatible(",
            "                *notification[\"octoversions\"], octoprint_version=octoprint_version",
            "            )",
            "        )",
            "    )",
            "",
            "",
            "def _register_custom_events(*args, **kwargs):",
            "    return [\"install_plugin\", \"uninstall_plugin\", \"enable_plugin\", \"disable_plugin\"]",
            "",
            "",
            "__plugin_name__ = \"Plugin Manager\"",
            "__plugin_author__ = \"Gina H\u00e4u\u00dfge\"",
            "__plugin_url__ = \"http://docs.octoprint.org/en/master/bundledplugins/pluginmanager.html\"",
            "__plugin_description__ = \"Allows installing and managing OctoPrint plugins\"",
            "__plugin_license__ = \"AGPLv3\"",
            "__plugin_pythoncompat__ = \">=2.7,<4\"",
            "__plugin_hidden__ = True",
            "",
            "",
            "def __plugin_load__():",
            "    global __plugin_implementation__",
            "    __plugin_implementation__ = PluginManagerPlugin()",
            "",
            "    global __plugin_hooks__",
            "    __plugin_hooks__ = {",
            "        \"octoprint.server.http.bodysize\": __plugin_implementation__.increase_upload_bodysize,",
            "        \"octoprint.ui.web.templatetypes\": __plugin_implementation__.get_template_types,",
            "        \"octoprint.events.register_custom_events\": _register_custom_events,",
            "        \"octoprint.access.permissions\": __plugin_implementation__.get_additional_permissions,",
            "    }",
            "",
            "    global __plugin_helpers__",
            "    __plugin_helpers__ = {",
            "        \"generate_plugins_json\": __plugin_implementation__.generate_plugins_json,",
            "    }"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2015 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "import copy",
            "import io",
            "import logging",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import tempfile",
            "import threading",
            "import time",
            "from datetime import datetime",
            "",
            "import filetype",
            "import pkg_resources",
            "import requests",
            "import sarge",
            "from flask import Response, abort, jsonify, make_response, request",
            "from flask_babel import gettext",
            "from past.builtins import basestring",
            "",
            "import octoprint.plugin",
            "import octoprint.plugin.core",
            "from octoprint.access import ADMIN_GROUP",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.events import Events",
            "from octoprint.server import safe_mode",
            "from octoprint.server.util.flask import (",
            "    check_etag,",
            "    no_firstrun_access,",
            "    with_revalidation_checking,",
            ")",
            "from octoprint.settings import valid_boolean_trues",
            "from octoprint.util import TemporaryDirectory, deprecated, to_bytes, to_native_str",
            "from octoprint.util.net import download_file",
            "from octoprint.util.pip import create_pip_caller",
            "from octoprint.util.platform import get_os, is_os_compatible",
            "from octoprint.util.version import (",
            "    get_octoprint_version,",
            "    get_octoprint_version_string,",
            "    is_octoprint_compatible,",
            "    is_python_compatible,",
            ")",
            "",
            "from . import exceptions",
            "",
            "try:",
            "    from os import scandir",
            "except ImportError:",
            "    from scandir import scandir",
            "",
            "_DATA_FORMAT_VERSION = \"v3\"",
            "",
            "DEFAULT_PLUGIN_REPOSITORY = \"https://plugins.octoprint.org/plugins.json\"",
            "DEFAULT_PLUGIN_NOTICES = \"https://plugins.octoprint.org/notices.json\"",
            "",
            "",
            "def map_repository_entry(entry):",
            "    if not isinstance(entry, dict):",
            "        return None",
            "",
            "    result = copy.deepcopy(entry)",
            "",
            "    if \"follow_dependency_links\" not in result:",
            "        result[\"follow_dependency_links\"] = False",
            "",
            "    result[\"is_compatible\"] = {\"octoprint\": True, \"os\": True, \"python\": True}",
            "",
            "    if \"compatibility\" in entry:",
            "        if (",
            "            \"octoprint\" in entry[\"compatibility\"]",
            "            and entry[\"compatibility\"][\"octoprint\"] is not None",
            "            and isinstance(entry[\"compatibility\"][\"octoprint\"], (list, tuple))",
            "            and len(entry[\"compatibility\"][\"octoprint\"])",
            "        ):",
            "            result[\"is_compatible\"][\"octoprint\"] = is_octoprint_compatible(",
            "                *entry[\"compatibility\"][\"octoprint\"]",
            "            )",
            "",
            "        if (",
            "            \"os\" in entry[\"compatibility\"]",
            "            and entry[\"compatibility\"][\"os\"] is not None",
            "            and isinstance(entry[\"compatibility\"][\"os\"], (list, tuple))",
            "            and len(entry[\"compatibility\"][\"os\"])",
            "        ):",
            "            result[\"is_compatible\"][\"os\"] = is_os_compatible(entry[\"compatibility\"][\"os\"])",
            "",
            "        if (",
            "            \"python\" in entry[\"compatibility\"]",
            "            and entry[\"compatibility\"][\"python\"] is not None",
            "            and isinstance(entry[\"compatibility\"][\"python\"], basestring)",
            "        ):",
            "            result[\"is_compatible\"][\"python\"] = is_python_compatible(",
            "                entry[\"compatibility\"][\"python\"]",
            "            )",
            "        else:",
            "            # we default to only assume py2 compatiblity for now",
            "            result[\"is_compatible\"][\"python\"] = is_python_compatible(\">=2.7,<3\")",
            "",
            "    return result",
            "",
            "",
            "already_installed_string = \"Requirement already satisfied (use --upgrade to upgrade)\"",
            "success_string = \"Successfully installed\"",
            "failure_string = \"Could not install\"",
            "",
            "",
            "class PluginManagerPlugin(",
            "    octoprint.plugin.SimpleApiPlugin,",
            "    octoprint.plugin.TemplatePlugin,",
            "    octoprint.plugin.AssetPlugin,",
            "    octoprint.plugin.SettingsPlugin,",
            "    octoprint.plugin.StartupPlugin,",
            "    octoprint.plugin.BlueprintPlugin,",
            "    octoprint.plugin.EventHandlerPlugin,",
            "):",
            "",
            "    ARCHIVE_EXTENSIONS = (\".zip\", \".tar.gz\", \".tgz\", \".tar\", \".gz\")",
            "    PYTHON_EXTENSIONS = (\".py\",)",
            "",
            "    # valid pip install URL schemes according to https://pip.pypa.io/en/stable/reference/pip_install/",
            "    URL_SCHEMES = (",
            "        \"http\",",
            "        \"https\",",
            "        \"git\",",
            "        \"git+http\",",
            "        \"git+https\",",
            "        \"git+ssh\",",
            "        \"git+git\",",
            "        \"hg+http\",",
            "        \"hg+https\",",
            "        \"hg+static-http\",",
            "        \"hg+ssh\",",
            "        \"svn\",",
            "        \"svn+svn\",",
            "        \"svn+http\",",
            "        \"svn+https\",",
            "        \"svn+ssh\",",
            "        \"bzr+http\",",
            "        \"bzr+https\",",
            "        \"bzr+ssh\",",
            "        \"bzr+sftp\",",
            "        \"bzr+ftp\",",
            "        \"bzr+lp\",",
            "    )",
            "",
            "    OPERATING_SYSTEMS = {",
            "        \"windows\": [\"win32\"],",
            "        \"linux\": lambda x: x.startswith(\"linux\"),",
            "        \"macos\": [\"darwin\"],",
            "        \"freebsd\": lambda x: x.startswith(\"freebsd\"),",
            "    }",
            "",
            "    PIP_INAPPLICABLE_ARGUMENTS = {\"uninstall\": [\"--user\"]}",
            "",
            "    RECONNECT_HOOKS = [",
            "        \"octoprint.comm.protocol.*\",",
            "    ]",
            "",
            "    # noinspection PyMissingConstructor",
            "    def __init__(self):",
            "        self._pending_enable = set()",
            "        self._pending_disable = set()",
            "        self._pending_install = set()",
            "        self._pending_uninstall = set()",
            "",
            "        self._pip_caller = None",
            "",
            "        self._repository_available = False",
            "        self._repository_plugins = []",
            "        self._repository_cache_path = None",
            "        self._repository_cache_ttl = 0",
            "        self._repository_mtime = None",
            "",
            "        self._notices = {}",
            "        self._notices_available = False",
            "        self._notices_cache_path = None",
            "        self._notices_cache_ttl = 0",
            "        self._notices_mtime = None",
            "",
            "        self._orphans = None",
            "",
            "        self._console_logger = None",
            "",
            "        self._get_throttled = lambda: False",
            "",
            "        self._install_task = None",
            "        self._install_lock = threading.RLock()",
            "",
            "    def initialize(self):",
            "        self._console_logger = logging.getLogger(",
            "            \"octoprint.plugins.pluginmanager.console\"",
            "        )",
            "        self._repository_cache_path = os.path.join(",
            "            self.get_plugin_data_folder(), \"plugins.json\"",
            "        )",
            "        self._repository_cache_ttl = self._settings.get_int([\"repository_ttl\"]) * 60",
            "        self._notices_cache_path = os.path.join(",
            "            self.get_plugin_data_folder(), \"notices.json\"",
            "        )",
            "        self._notices_cache_ttl = self._settings.get_int([\"notices_ttl\"]) * 60",
            "        self._confirm_disable = self._settings.global_get_boolean([\"confirm_disable\"])",
            "",
            "        self._pip_caller = create_pip_caller(",
            "            command=self._settings.global_get([\"server\", \"commands\", \"localPipCommand\"]),",
            "            force_user=self._settings.get_boolean([\"pip_force_user\"]),",
            "        )",
            "        self._pip_caller.on_log_call = self._log_call",
            "        self._pip_caller.on_log_stdout = self._log_stdout",
            "        self._pip_caller.on_log_stderr = self._log_stderr",
            "",
            "    ##~~ Body size hook",
            "",
            "    def increase_upload_bodysize(self, current_max_body_sizes, *args, **kwargs):",
            "        # set a maximum body size of 50 MB for plugin archive uploads",
            "        return [(\"POST\", r\"/upload_file\", 50 * 1024 * 1024)]",
            "",
            "    # Additional permissions hook",
            "",
            "    def get_additional_permissions(self):",
            "        return [",
            "            {",
            "                \"key\": \"MANAGE\",",
            "                \"name\": \"Manage plugins\",",
            "                \"description\": gettext(",
            "                    \"Allows to enable, disable and uninstall installed plugins.\"",
            "                ),",
            "                \"default_groups\": [ADMIN_GROUP],",
            "                \"roles\": [\"manage\"],",
            "            },",
            "            {",
            "                \"key\": \"INSTALL\",",
            "                \"name\": \"Install new plugins\",",
            "                \"description\": gettext(",
            "                    'Allows to install new plugins. Includes the \"Manage plugins\" permission.'",
            "                ),",
            "                \"default_groups\": [ADMIN_GROUP],",
            "                \"roles\": [\"install\"],",
            "                \"permissions\": [\"PLUGIN_PLUGINMANAGER_MANAGE\"],",
            "                \"dangerous\": True,",
            "            },",
            "        ]",
            "",
            "    ##~~ StartupPlugin",
            "",
            "    def on_after_startup(self):",
            "        from octoprint.logging.handlers import CleaningTimedRotatingFileHandler",
            "",
            "        console_logging_handler = CleaningTimedRotatingFileHandler(",
            "            self._settings.get_plugin_logfile_path(postfix=\"console\"),",
            "            when=\"D\",",
            "            backupCount=3,",
            "        )",
            "        console_logging_handler.setFormatter(logging.Formatter(\"%(asctime)s %(message)s\"))",
            "        console_logging_handler.setLevel(logging.DEBUG)",
            "",
            "        self._console_logger.addHandler(console_logging_handler)",
            "        self._console_logger.setLevel(logging.DEBUG)",
            "        self._console_logger.propagate = False",
            "",
            "        helpers = self._plugin_manager.get_helpers(\"pi_support\", \"get_throttled\")",
            "        if helpers and \"get_throttled\" in helpers:",
            "            self._get_throttled = helpers[\"get_throttled\"]",
            "            if self._settings.get_boolean([\"ignore_throttled\"]):",
            "                self._logger.warning(",
            "                    \"!!! THROTTLE STATE IGNORED !!! You have configured the Plugin Manager plugin to ignore an active throttle state of the underlying system. You might run into stability issues or outright corrupt your install. Consider fixing the throttling issue instead of suppressing it.\"",
            "                )",
            "",
            "        # decouple repository fetching from server startup",
            "        self._fetch_all_data(do_async=True)",
            "",
            "    ##~~ SettingsPlugin",
            "",
            "    def get_settings_defaults(self):",
            "        return {",
            "            \"repository\": DEFAULT_PLUGIN_REPOSITORY,",
            "            \"repository_ttl\": 24 * 60,",
            "            \"notices\": DEFAULT_PLUGIN_NOTICES,",
            "            \"notices_ttl\": 6 * 60,",
            "            \"pip_args\": None,",
            "            \"pip_force_user\": False,",
            "            \"confirm_disable\": False,",
            "            \"dependency_links\": False,",
            "            \"hidden\": [],",
            "            \"ignore_throttled\": False,",
            "        }",
            "",
            "    def on_settings_save(self, data):",
            "        octoprint.plugin.SettingsPlugin.on_settings_save(self, data)",
            "",
            "        self._repository_cache_ttl = self._settings.get_int([\"repository_ttl\"]) * 60",
            "        self._notices_cache_ttl = self._settings.get_int([\"notices_ttl\"]) * 60",
            "        self._pip_caller.force_user = self._settings.get_boolean([\"pip_force_user\"])",
            "        self._confirm_disable = self._settings.global_get_boolean([\"confirm_disable\"])",
            "",
            "    ##~~ AssetPlugin",
            "",
            "    def get_assets(self):",
            "        return {",
            "            \"js\": [\"js/pluginmanager.js\"],",
            "            \"clientjs\": [\"clientjs/pluginmanager.js\"],",
            "            \"css\": [\"css/pluginmanager.css\"],",
            "            \"less\": [\"less/pluginmanager.less\"],",
            "        }",
            "",
            "    ##~~ TemplatePlugin",
            "",
            "    def get_template_configs(self):",
            "        return [",
            "            {",
            "                \"type\": \"settings\",",
            "                \"name\": gettext(\"Plugin Manager\"),",
            "                \"template\": \"pluginmanager_settings.jinja2\",",
            "                \"custom_bindings\": True,",
            "            },",
            "            {",
            "                \"type\": \"about\",",
            "                \"name\": \"Plugin Licenses\",",
            "                \"template\": \"pluginmanager_about.jinja2\",",
            "            },",
            "        ]",
            "",
            "    def get_template_vars(self):",
            "        plugins = sorted(self._get_plugins(), key=lambda x: x[\"name\"].lower())",
            "        return {",
            "            \"all\": plugins,",
            "            \"thirdparty\": list(filter(lambda p: not p[\"bundled\"], plugins)),",
            "            \"file_extensions\": self.ARCHIVE_EXTENSIONS + self.PYTHON_EXTENSIONS,",
            "        }",
            "",
            "    def get_template_types(self, template_sorting, template_rules, *args, **kwargs):",
            "        return [",
            "            (",
            "                \"about_thirdparty\",",
            "                {},",
            "                {\"template\": lambda x: x + \"_about_thirdparty.jinja2\"},",
            "            )",
            "        ]",
            "",
            "    ##~~ BlueprintPlugin",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/upload_file\", methods=[\"POST\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_PLUGINMANAGER_INSTALL.require(403)",
            "    def upload_file(self):",
            "        import flask",
            "",
            "        input_name = \"file\"",
            "        input_upload_path = (",
            "            input_name",
            "            + \".\"",
            "            + self._settings.global_get([\"server\", \"uploads\", \"pathSuffix\"])",
            "        )",
            "        input_upload_name = (",
            "            input_name",
            "            + \".\"",
            "            + self._settings.global_get([\"server\", \"uploads\", \"nameSuffix\"])",
            "        )",
            "",
            "        if (",
            "            input_upload_path not in flask.request.values",
            "            or input_upload_name not in flask.request.values",
            "        ):",
            "            return flask.make_response(\"No file included\", 400)",
            "        upload_path = flask.request.values[input_upload_path]",
            "        upload_name = flask.request.values[input_upload_name]",
            "",
            "        exts = list(",
            "            filter(",
            "                lambda x: upload_name.lower().endswith(x),",
            "                self.ARCHIVE_EXTENSIONS + self.PYTHON_EXTENSIONS,",
            "            )",
            "        )",
            "        if not len(exts):",
            "            return flask.make_response(",
            "                \"File doesn't have a valid extension for a plugin archive or a single file plugin\",",
            "                400,",
            "            )",
            "",
            "        ext = exts[0]",
            "        archive = tempfile.NamedTemporaryFile(delete=False, suffix=ext)",
            "        archive.close()",
            "        shutil.copy(upload_path, archive.name)",
            "",
            "        def perform_install(source, name, force=False):",
            "            try:",
            "                self.command_install(",
            "                    path=source,",
            "                    name=name,",
            "                    force=force,",
            "                )",
            "            finally:",
            "                try:",
            "                    os.remove(archive.name)",
            "                except Exception as e:",
            "                    self._logger.warning(",
            "                        \"Could not remove temporary file {path} again: {message}\".format(",
            "                            path=archive.name, message=str(e)",
            "                        )",
            "                    )",
            "",
            "        with self._install_lock:",
            "            if self._install_task is not None:",
            "                return make_response(\"There's already a plugin being installed\", 409)",
            "",
            "            self._install_task = threading.Thread(",
            "                target=perform_install,",
            "                args=(archive.name, upload_name),",
            "                kwargs={",
            "                    \"force\": \"force\" in flask.request.values",
            "                    and flask.request.values[\"force\"] in valid_boolean_trues",
            "                },",
            "            )",
            "            self._install_task.daemon = True",
            "            self._install_task.start()",
            "",
            "            return jsonify(in_progress=True)",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/export\", methods=[\"GET\"])",
            "    @no_firstrun_access",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def export_plugin_list(self):",
            "        import json",
            "",
            "        plugins = self.generate_plugins_json(self._settings, self._plugin_manager)",
            "",
            "        return Response(",
            "            json.dumps(plugins),",
            "            mimetype=\"text/plain\",",
            "            headers={\"Content-Disposition\": 'attachment; filename=\"plugin_list.json\"'},",
            "        )",
            "",
            "    def _plugin_response(self):",
            "        return {",
            "            \"plugins\": self._get_plugins(),",
            "            \"os\": get_os(),",
            "            \"octoprint\": get_octoprint_version_string(),",
            "            \"pip\": {",
            "                \"available\": self._pip_caller.available,",
            "                \"version\": self._pip_caller.version_string,",
            "                \"install_dir\": self._pip_caller.install_dir,",
            "                \"use_user\": self._pip_caller.use_user,",
            "                \"virtual_env\": self._pip_caller.virtual_env,",
            "                \"additional_args\": self._settings.get([\"pip_args\"]),",
            "                \"python\": sys.executable,",
            "            },",
            "            \"safe_mode\": safe_mode,",
            "            \"online\": self._connectivity_checker.online,",
            "        }",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/plugins\")",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def retrieve_plugins(self):",
            "        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues",
            "        if refresh or not self._is_notices_cache_valid():",
            "            self._notices_available = self._refresh_notices()",
            "",
            "        def view():",
            "            return jsonify(**self._plugin_response())",
            "",
            "        def etag():",
            "            import hashlib",
            "",
            "            hash = hashlib.sha1()",
            "",
            "            def hash_update(value):",
            "                value = value.encode(\"utf-8\")",
            "                hash.update(value)",
            "",
            "            hash_update(repr(self._get_plugins()))",
            "            hash_update(str(self._notices_available))",
            "            hash_update(repr(self._notices))",
            "            hash_update(repr(safe_mode))",
            "            hash_update(repr(self._connectivity_checker.online))",
            "            hash_update(repr(_DATA_FORMAT_VERSION))",
            "            return hash.hexdigest()",
            "",
            "        def condition():",
            "            return check_etag(etag())",
            "",
            "        return with_revalidation_checking(",
            "            etag_factory=lambda *args, **kwargs: etag(),",
            "            condition=lambda *args, **kwargs: condition(),",
            "            unless=lambda: refresh,",
            "        )(view)()",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/plugins/<string:key>\")",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def retrieve_specific_plugin(self, key):",
            "        plugin = self._plugin_manager.get_plugin_info(key, require_enabled=False)",
            "        if plugin is None:",
            "            return abort(404)",
            "",
            "        return jsonify(plugin=self._to_external_plugin(plugin))",
            "",
            "    def _orphan_response(self):",
            "        return {\"orphan_data\": self._get_orphans()}",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/orphans\")",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def retrieve_plugin_orphans(self):",
            "        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():",
            "            return make_response(\"Insufficient rights\", 403)",
            "",
            "        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues",
            "        if refresh:",
            "            self._get_orphans(refresh=True)",
            "",
            "        def view():",
            "            return jsonify(**self._orphan_response())",
            "",
            "        def etag():",
            "            import hashlib",
            "",
            "            hash = hashlib.sha1()",
            "",
            "            def hash_update(value):",
            "                value = value.encode(\"utf-8\")",
            "                hash.update(value)",
            "",
            "            hash_update(repr(self._get_orphans()))",
            "            hash_update(repr(_DATA_FORMAT_VERSION))",
            "            return hash.hexdigest()",
            "",
            "        def condition():",
            "            return check_etag(etag())",
            "",
            "        return with_revalidation_checking(",
            "            etag_factory=lambda *args, **kwargs: etag(),",
            "            condition=lambda *args, **kwargs: condition(),",
            "            unless=lambda: refresh,",
            "        )(view)()",
            "",
            "    def _repository_response(self):",
            "        return {",
            "            \"repository\": {",
            "                \"available\": self._repository_available,",
            "                \"plugins\": self._repository_plugins,",
            "            }",
            "        }",
            "",
            "    @octoprint.plugin.BlueprintPlugin.route(\"/repository\")",
            "    @Permissions.PLUGIN_PLUGINMANAGER_MANAGE.require(403)",
            "    def retrieve_plugin_repository(self):",
            "        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():",
            "            return make_response(\"Insufficient rights\", 403)",
            "",
            "        refresh = request.values.get(\"refresh\", \"false\") in valid_boolean_trues",
            "        if refresh or not self._is_repository_cache_valid():",
            "            self._repository_available = self._refresh_repository()",
            "",
            "        def view():",
            "            return jsonify(**self._repository_response())",
            "",
            "        def etag():",
            "            import hashlib",
            "",
            "            hash = hashlib.sha1()",
            "",
            "            def hash_update(value):",
            "                value = value.encode(\"utf-8\")",
            "                hash.update(value)",
            "",
            "            hash_update(str(self._repository_available))",
            "            hash_update(repr(self._repository_plugins))",
            "            hash_update(repr(_DATA_FORMAT_VERSION))",
            "            return hash.hexdigest()",
            "",
            "        def condition():",
            "            return check_etag(etag())",
            "",
            "        return with_revalidation_checking(",
            "            etag_factory=lambda *args, **kwargs: etag(),",
            "            condition=lambda *args, **kwargs: condition(),",
            "            unless=lambda: refresh,",
            "        )(view)()",
            "",
            "    def is_blueprint_protected(self):",
            "        return False",
            "",
            "    ##~~ EventHandlerPlugin",
            "",
            "    def on_event(self, event, payload):",
            "        from octoprint.events import Events",
            "",
            "        if (",
            "            event != Events.CONNECTIVITY_CHANGED",
            "            or not payload",
            "            or not payload.get(\"new\", False)",
            "        ):",
            "            return",
            "        self._fetch_all_data(do_async=True)",
            "",
            "    ##~~ SimpleApiPlugin",
            "",
            "    def get_api_commands(self):",
            "        return {",
            "            \"install\": [\"url\"],",
            "            \"uninstall\": [\"plugin\"],",
            "            \"enable\": [\"plugin\"],",
            "            \"disable\": [\"plugin\"],",
            "            \"cleanup\": [\"plugin\"],",
            "            \"cleanup_all\": [],",
            "            \"refresh_repository\": [],",
            "        }",
            "",
            "    def on_api_command(self, command, data):",
            "        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():",
            "            return make_response(\"Insufficient rights\", 403)",
            "",
            "        if self._printer.is_printing() or self._printer.is_paused():",
            "            # do not update while a print job is running",
            "            return make_response(\"Printer is currently printing or paused\", 409)",
            "",
            "        if command == \"install\":",
            "            if not Permissions.PLUGIN_PLUGINMANAGER_INSTALL.can():",
            "                return make_response(\"Insufficient rights\", 403)",
            "            url = data[\"url\"]",
            "            plugin_name = data[\"plugin\"] if \"plugin\" in data else None",
            "",
            "            with self._install_lock:",
            "                if self._install_task is not None:",
            "                    return make_response(\"There's already a plugin being installed\", 409)",
            "",
            "                self._install_task = threading.Thread(",
            "                    target=self.command_install,",
            "                    kwargs={",
            "                        \"url\": url,",
            "                        \"force\": \"force\" in data and data[\"force\"] in valid_boolean_trues,",
            "                        \"dependency_links\": \"dependency_links\" in data",
            "                        and data[\"dependency_links\"] in valid_boolean_trues,",
            "                        \"reinstall\": plugin_name,",
            "                    },",
            "                )",
            "                self._install_task.daemon = True",
            "                self._install_task.start()",
            "",
            "                return jsonify(in_progress=True)",
            "",
            "        elif command == \"uninstall\":",
            "            plugin_name = data[\"plugin\"]",
            "            if plugin_name not in self._plugin_manager.plugins:",
            "                return make_response(\"Unknown plugin\", 404)",
            "",
            "            plugin = self._plugin_manager.plugins[plugin_name]",
            "            return self.command_uninstall(plugin, cleanup=data.get(\"cleanup\", False))",
            "",
            "        elif command == \"cleanup\":",
            "            plugin = data[\"plugin\"]",
            "            try:",
            "                plugin = self._plugin_manager.plugins[plugin]",
            "            except KeyError:",
            "                # not installed, we are cleaning up left overs, that's ok",
            "                pass",
            "",
            "            return self.command_cleanup(plugin, include_disabled=True)",
            "",
            "        elif command == \"cleanup_all\":",
            "            return self.command_cleanup_all()",
            "",
            "        elif command == \"enable\" or command == \"disable\":",
            "            plugin_name = data[\"plugin\"]",
            "            if plugin_name not in self._plugin_manager.plugins:",
            "                return make_response(\"Unknown plugin\", 404)",
            "",
            "            plugin = self._plugin_manager.plugins[plugin_name]",
            "            return self.command_toggle(plugin, command)",
            "",
            "    @deprecated(",
            "        \"Deprecated API endpoint api/plugin/pluginmanager used. \"",
            "        \"Please switch clients to plugin/pluginmanager/*\",",
            "        since=\"1.6.0\",",
            "    )",
            "    def on_api_get(self, r):",
            "        if not Permissions.PLUGIN_PLUGINMANAGER_MANAGE.can():",
            "            return make_response(\"Insufficient rights\", 403)",
            "",
            "        refresh_repository = (",
            "            request.values.get(\"refresh_repository\", \"false\") in valid_boolean_trues",
            "        )",
            "        if refresh_repository or not self._is_repository_cache_valid():",
            "            self._repository_available = self._refresh_repository()",
            "",
            "        refresh_notices = (",
            "            request.values.get(\"refresh_notices\", \"false\") in valid_boolean_trues",
            "        )",
            "        if refresh_notices or not self._is_notices_cache_valid():",
            "            self._notices_available = self._refresh_notices()",
            "",
            "        refresh_orphan = (",
            "            request.values.get(\"refresh_orphans\", \"false\") in valid_boolean_trues",
            "        )",
            "        if refresh_orphan:",
            "            self._get_orphans(refresh=True)",
            "",
            "        result = {}",
            "        result.update(**self._plugin_response())",
            "        result.update(**self._orphan_response())",
            "        result.update(**self._repository_response())",
            "        return jsonify(**result)",
            "",
            "    # noinspection PyMethodMayBeStatic",
            "    def _is_archive(self, path):",
            "        _, ext = os.path.splitext(path)",
            "        if ext in PluginManagerPlugin.ARCHIVE_EXTENSIONS:",
            "            return True",
            "",
            "        kind = filetype.guess(to_native_str(path))",
            "        if kind:",
            "            return \".{}\".format(kind.extension) in PluginManagerPlugin.ARCHIVE_EXTENSIONS",
            "        return False",
            "",
            "    def _is_pythonfile(self, path):",
            "        _, ext = os.path.splitext(path)",
            "        if ext in PluginManagerPlugin.PYTHON_EXTENSIONS:",
            "            import ast",
            "",
            "            try:",
            "                with io.open(path, \"rb\") as f:",
            "                    ast.parse(f.read(), filename=path)",
            "                return True",
            "            except Exception as exc:",
            "                self._logger.exception(",
            "                    \"Could not parse {} as python file: {}\".format(path, exc)",
            "                )",
            "",
            "        return False",
            "",
            "    def command_install(",
            "        self,",
            "        url=None,",
            "        path=None,",
            "        name=None,",
            "        force=False,",
            "        reinstall=None,",
            "        dependency_links=False,",
            "    ):",
            "        folder = None",
            "",
            "        with self._install_lock:",
            "            try:",
            "                source = path",
            "                source_type = \"path\"",
            "",
            "                if url is not None:",
            "                    # fetch URL",
            "                    folder = TemporaryDirectory()",
            "                    path = download_file(url, folder.name)",
            "                    source = url",
            "                    source_type = \"url\"",
            "",
            "                # determine type of path",
            "                if self._is_archive(path):",
            "                    result = self._command_install_archive(",
            "                        path,",
            "                        source=source,",
            "                        source_type=source_type,",
            "                        force=force,",
            "                        reinstall=reinstall,",
            "                        dependency_links=dependency_links,",
            "                    )",
            "",
            "                elif self._is_pythonfile(path):",
            "                    result = self._command_install_pythonfile(",
            "                        path, source=source, source_type=source_type, name=name",
            "                    )",
            "",
            "                else:",
            "                    raise exceptions.InvalidPackageFormat()",
            "",
            "            except requests.exceptions.HTTPError as e:",
            "                self._logger.error(\"Could not fetch plugin from server, got {}\".format(e))",
            "                result = {",
            "                    \"result\": False,",
            "                    \"source\": source,",
            "                    \"source_type\": source_type,",
            "                    \"reason\": \"Could not fetch plugin from server, got {}\".format(e),",
            "                }",
            "                self._send_result_notification(\"install\", result)",
            "",
            "            except exceptions.InvalidPackageFormat:",
            "                self._logger.error(",
            "                    \"{} is neither an archive nor a python file, can't install that.\".format(",
            "                        source",
            "                    )",
            "                )",
            "                result = {",
            "                    \"result\": False,",
            "                    \"source\": source,",
            "                    \"source_type\": source_type,",
            "                    \"reason\": \"Could not install plugin from {}, was neither \"",
            "                    \"a plugin archive nor a single file plugin\".format(source),",
            "                }",
            "                self._send_result_notification(\"install\", result)",
            "",
            "            except Exception:",
            "                error_msg = (",
            "                    \"Unexpected error while trying to install plugin from {}\".format(",
            "                        source",
            "                    )",
            "                )",
            "                self._logger.exception(error_msg)",
            "                result = {",
            "                    \"result\": False,",
            "                    \"source\": source,",
            "                    \"source_type\": source_type,",
            "                    \"reason\": error_msg,",
            "                }",
            "                self._send_result_notification(\"install\", result)",
            "",
            "            finally:",
            "                if folder is not None:",
            "                    folder.cleanup()",
            "                self._install_task = None",
            "",
            "        return result",
            "",
            "    # noinspection DuplicatedCode",
            "    def _command_install_archive(",
            "        self,",
            "        path,",
            "        source=None,",
            "        source_type=None,",
            "        force=False,",
            "        reinstall=None,",
            "        dependency_links=False,",
            "    ):",
            "        throttled = self._get_throttled()",
            "        if (",
            "            throttled",
            "            and isinstance(throttled, dict)",
            "            and throttled.get(\"current_issue\", False)",
            "            and not self._settings.get_boolean([\"ignore_throttled\"])",
            "        ):",
            "            # currently throttled, we refuse to run",
            "            error_msg = (",
            "                \"System is currently throttled, refusing to install anything\"",
            "                \" due to possible stability issues\"",
            "            )",
            "            self._logger.error(error_msg)",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": error_msg,",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        try:",
            "            # Py3",
            "            from urllib.parse import quote as url_quote",
            "        except ImportError:",
            "            # Py2",
            "            from urllib import quote as url_quote",
            "",
            "        path = os.path.abspath(path)",
            "        if os.sep != \"/\":",
            "            # windows gets special handling",
            "            drive, loc = os.path.splitdrive(path)",
            "            path_url = (",
            "                \"file:///\" + drive.lower() + url_quote(loc.replace(os.sep, \"/\").lower())",
            "            )",
            "            shell_quote = lambda x: x  # do not shell quote under windows, non posix shell",
            "        else:",
            "            path_url = \"file://\" + url_quote(path)",
            "            shell_quote = sarge.shell_quote",
            "",
            "        already_installed_check = (",
            "            lambda line: path_url in line.lower()",
            "        )  # lower case in case of windows",
            "",
            "        self._logger.info(\"Installing plugin from {}\".format(source))",
            "        pip_args = [",
            "            \"--disable-pip-version-check\",",
            "            \"install\",",
            "            shell_quote(path_url),",
            "            \"--no-cache-dir\",",
            "        ]",
            "",
            "        if dependency_links or self._settings.get_boolean([\"dependency_links\"]):",
            "            pip_args.append(\"--process-dependency-links\")",
            "",
            "        all_plugins_before = self._plugin_manager.find_plugins(existing={})",
            "",
            "        try:",
            "            returncode, stdout, stderr = self._call_pip(pip_args)",
            "",
            "            # pip's output for a package that is already installed looks something like any of these:",
            "            #",
            "            #   Requirement already satisfied (use --upgrade to upgrade): OctoPrint-Plugin==1.0 from \\",
            "            #     https://example.com/foobar.zip in <lib>",
            "            #   Requirement already satisfied (use --upgrade to upgrade): OctoPrint-Plugin in <lib>",
            "            #   Requirement already satisfied (use --upgrade to upgrade): OctoPrint-Plugin==1.0 from \\",
            "            #     file:///tmp/foobar.zip in <lib>",
            "            #   Requirement already satisfied (use --upgrade to upgrade): OctoPrint-Plugin==1.0 from \\",
            "            #     file:///C:/Temp/foobar.zip in <lib>",
            "            #",
            "            # If we detect any of these matching what we just tried to install, we'll need to trigger a second",
            "            # install with reinstall flags.",
            "",
            "            if not force and any(",
            "                map(",
            "                    lambda x: x.strip().startswith(already_installed_string)",
            "                    and already_installed_check(x),",
            "                    stdout,",
            "                )",
            "            ):",
            "                self._logger.info(",
            "                    \"Plugin to be installed from {} was already installed, forcing a reinstall\".format(",
            "                        source",
            "                    )",
            "                )",
            "                self._log_message(",
            "                    \"Looks like the plugin was already installed. Forcing a reinstall.\"",
            "                )",
            "                force = True",
            "        except Exception as e:",
            "            self._logger.exception(\"Could not install plugin from {}\".format(source))",
            "            self._logger.exception(\"Reason: {}\".format(repr(e)))",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": \"Could not install plugin from {}, see the log for more details\".format(",
            "                    source",
            "                ),",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        else:",
            "            if force:",
            "                # We don't use --upgrade here because that will also happily update all our dependencies - we'd rather",
            "                # do that in a controlled manner",
            "                pip_args += [\"--ignore-installed\", \"--force-reinstall\", \"--no-deps\"]",
            "                try:",
            "                    returncode, stdout, stderr = self._call_pip(pip_args)",
            "                except Exception as e:",
            "                    self._logger.exception(",
            "                        \"Could not install plugin from {}\".format(source)",
            "                    )",
            "                    self._logger.exception(\"Reason: {}\".format(repr(e)))",
            "                    result = {",
            "                        \"result\": False,",
            "                        \"source\": source,",
            "                        \"source_type\": source_type,",
            "                        \"reason\": \"Could not install plugin from source {}, see the log for more details\".format(",
            "                            source",
            "                        ),",
            "                    }",
            "                    self._send_result_notification(\"install\", result)",
            "                    return result",
            "",
            "        try:",
            "            result_line = list(",
            "                filter(",
            "                    lambda x: x.startswith(success_string)",
            "                    or x.startswith(failure_string),",
            "                    stdout,",
            "                )",
            "            )[-1]",
            "        except IndexError:",
            "            self._logger.error(",
            "                \"Installing the plugin from {} failed, could not parse output from pip. \"",
            "                \"See plugin_pluginmanager_console.log for generated output\".format(source)",
            "            )",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": \"Could not parse output from pip, see plugin_pluginmanager_console.log \"",
            "                \"for generated output\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        # The final output of a pip install command looks something like this:",
            "        #",
            "        #   Successfully installed OctoPrint-Plugin-1.0 Dependency-One-0.1 Dependency-Two-9.3",
            "        #",
            "        # or this:",
            "        #",
            "        #   Successfully installed OctoPrint-Plugin Dependency-One Dependency-Two",
            "        #   Cleaning up...",
            "        #",
            "        # So we'll need to fetch the \"Successfully installed\" line, strip the \"Successfully\" part, then split",
            "        # by whitespace and strip to get all installed packages.",
            "        #",
            "        # We then need to iterate over all known plugins and see if either the package name or the package name plus",
            "        # version number matches one of our installed packages. If it does, that's our installed plugin.",
            "        #",
            "        # Known issue: This might return the wrong plugin if more than one plugin was installed through this",
            "        # command (e.g. due to pulling in another plugin as dependency). It should be safe for now though to",
            "        # consider this a rare corner case. Once it becomes a real problem we'll just extend the plugin manager",
            "        # so that it can report on more than one installed plugin.",
            "",
            "        result_line = result_line.strip()",
            "        if not result_line.startswith(success_string):",
            "            self._logger.error(",
            "                \"Installing the plugin from {} failed, pip did not report successful installation\".format(",
            "                    source",
            "                )",
            "            )",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": \"Pip did not report successful installation\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        installed = list(",
            "            map(lambda x: x.strip(), result_line[len(success_string) :].split(\" \"))",
            "        )",
            "        all_plugins_after = self._plugin_manager.find_plugins(",
            "            existing={}, ignore_uninstalled=False",
            "        )",
            "",
            "        new_plugin = self._find_installed_plugin(installed, plugins=all_plugins_after)",
            "",
            "        if new_plugin is None:",
            "            self._logger.warning(",
            "                \"The plugin was installed successfully, but couldn't be found afterwards to \"",
            "                \"initialize properly during runtime. Please restart OctoPrint.\"",
            "            )",
            "            result = {",
            "                \"result\": True,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"needs_restart\": True,",
            "                \"needs_refresh\": True,",
            "                \"needs_reconnect\": True,",
            "                \"was_reinstalled\": False,",
            "                \"plugin\": \"unknown\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        self._plugin_manager.reload_plugins()",
            "        needs_restart = (",
            "            self._plugin_manager.is_restart_needing_plugin(new_plugin)",
            "            or new_plugin.key in all_plugins_before",
            "            or reinstall is not None",
            "        )",
            "        needs_refresh = new_plugin.implementation and isinstance(",
            "            new_plugin.implementation, octoprint.plugin.ReloadNeedingPlugin",
            "        )",
            "        needs_reconnect = (",
            "            self._plugin_manager.has_any_of_hooks(new_plugin, self._reconnect_hooks)",
            "            and self._printer.is_operational()",
            "        )",
            "",
            "        is_reinstall = self._plugin_manager.is_plugin_marked(",
            "            new_plugin.key, \"uninstalled\"",
            "        )",
            "        self._plugin_manager.mark_plugin(",
            "            new_plugin.key,",
            "            uninstalled=False,",
            "            installed=not is_reinstall and needs_restart,",
            "        )",
            "",
            "        self._plugin_manager.log_all_plugins()",
            "",
            "        self._logger.info(",
            "            \"The plugin was installed successfully: {}, version {}\".format(",
            "                new_plugin.name, new_plugin.version",
            "            )",
            "        )",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_INSTALL_PLUGIN,",
            "            {",
            "                \"id\": new_plugin.key,",
            "                \"version\": new_plugin.version,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "            },",
            "        )",
            "",
            "        result = {",
            "            \"result\": True,",
            "            \"source\": source,",
            "            \"source_type\": source_type,",
            "            \"needs_restart\": needs_restart,",
            "            \"needs_refresh\": needs_refresh,",
            "            \"needs_reconnect\": needs_reconnect,",
            "            \"was_reinstalled\": new_plugin.key in all_plugins_before",
            "            or reinstall is not None,",
            "            \"plugin\": self._to_external_plugin(new_plugin),",
            "        }",
            "        self._send_result_notification(\"install\", result)",
            "        return result",
            "",
            "    # noinspection DuplicatedCode",
            "    def _command_install_pythonfile(self, path, source=None, source_type=None, name=None):",
            "        if name is None:",
            "            name = os.path.basename(path)",
            "",
            "        self._logger.info(\"Installing single file plugin {} from {}\".format(name, source))",
            "",
            "        all_plugins_before = self._plugin_manager.find_plugins(existing={})",
            "",
            "        destination = os.path.join(self._settings.global_get_basefolder(\"plugins\"), name)",
            "        plugin_id, _ = os.path.splitext(name)",
            "",
            "        try:",
            "            self._log_call(\"cp {} {}\".format(path, destination))",
            "            shutil.copy(path, destination)",
            "        except Exception:",
            "            self._logger.exception(\"Installing plugin from {} failed\".format(source))",
            "            result = {",
            "                \"result\": False,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"reason\": \"Plugin could not be copied\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        plugins = self._plugin_manager.find_plugins(existing={}, ignore_uninstalled=False)",
            "        new_plugin = plugins.get(plugin_id)",
            "        if new_plugin is None:",
            "            self._logger.warning(",
            "                \"The plugin was installed successfully, but couldn't be found afterwards to \"",
            "                \"initialize properly during runtime. Please restart OctoPrint.\"",
            "            )",
            "            result = {",
            "                \"result\": True,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "                \"needs_restart\": True,",
            "                \"needs_refresh\": True,",
            "                \"needs_reconnect\": True,",
            "                \"was_reinstalled\": False,",
            "                \"plugin\": \"unknown\",",
            "            }",
            "            self._send_result_notification(\"install\", result)",
            "            return result",
            "",
            "        self._plugin_manager.reload_plugins()",
            "        needs_restart = (",
            "            self._plugin_manager.is_restart_needing_plugin(new_plugin)",
            "            or new_plugin.key in all_plugins_before",
            "        )",
            "        needs_refresh = new_plugin.implementation and isinstance(",
            "            new_plugin.implementation, octoprint.plugin.ReloadNeedingPlugin",
            "        )",
            "        needs_reconnect = (",
            "            self._plugin_manager.has_any_of_hooks(new_plugin, self._reconnect_hooks)",
            "            and self._printer.is_operational()",
            "        )",
            "",
            "        self._logger.info(",
            "            \"The plugin was installed successfully: {}, version {}\".format(",
            "                new_plugin.name, new_plugin.version",
            "            )",
            "        )",
            "        self._plugin_manager.log_all_plugins()",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_INSTALL_PLUGIN,",
            "            {",
            "                \"id\": new_plugin.key,",
            "                \"version\": new_plugin.version,",
            "                \"source\": source,",
            "                \"source_type\": source_type,",
            "            },",
            "        )",
            "",
            "        result = {",
            "            \"result\": True,",
            "            \"source\": source,",
            "            \"source_type\": source_type,",
            "            \"needs_restart\": needs_restart,",
            "            \"needs_refresh\": needs_refresh,",
            "            \"needs_reconnect\": needs_reconnect,",
            "            \"was_reinstalled\": new_plugin.key in all_plugins_before,",
            "            \"plugin\": self._to_external_plugin(new_plugin),",
            "        }",
            "        self._send_result_notification(\"install\", result)",
            "        return result",
            "",
            "    def command_uninstall(self, plugin, cleanup=False):",
            "        if plugin.key == \"pluginmanager\":",
            "            return make_response(\"Can't uninstall Plugin Manager\", 403)",
            "",
            "        if not plugin.managable:",
            "            return make_response(",
            "                \"Plugin is not managable and hence cannot be uninstalled\", 403",
            "            )",
            "",
            "        if plugin.bundled:",
            "            return make_response(\"Bundled plugins cannot be uninstalled\", 403)",
            "",
            "        if plugin.origin is None:",
            "            self._logger.warning(",
            "                \"Trying to uninstall plugin {plugin} but origin is unknown\".format(",
            "                    **locals()",
            "                )",
            "            )",
            "            return make_response(\"Could not uninstall plugin, its origin is unknown\")",
            "",
            "        if plugin.origin.type == \"entry_point\":",
            "            # plugin is installed through entry point, need to use pip to uninstall it",
            "            origin = plugin.origin[3]",
            "            if origin is None:",
            "                origin = plugin.origin[2]",
            "",
            "            pip_args = [\"--disable-pip-version-check\", \"uninstall\", \"--yes\", origin]",
            "            try:",
            "                self._call_pip(pip_args)",
            "            except Exception:",
            "                self._logger.exception(\"Could not uninstall plugin via pip\")",
            "                return make_response(",
            "                    \"Could not uninstall plugin via pip, see the log for more details\",",
            "                    500,",
            "                )",
            "",
            "        elif plugin.origin.type == \"folder\":",
            "            import os",
            "            import shutil",
            "",
            "            full_path = os.path.realpath(plugin.location)",
            "",
            "            if os.path.isdir(full_path):",
            "                # plugin is installed via a plugin folder, need to use rmtree to get rid of it",
            "                self._log_stdout(",
            "                    \"Deleting plugin from {folder}\".format(folder=plugin.location)",
            "                )",
            "                shutil.rmtree(full_path)",
            "            elif os.path.isfile(full_path):",
            "                self._log_stdout(",
            "                    \"Deleting plugin from {file}\".format(file=plugin.location)",
            "                )",
            "                os.remove(full_path)",
            "",
            "                if full_path.endswith(\".py\"):",
            "                    pyc_file = \"{full_path}c\".format(**locals())",
            "                    if os.path.isfile(pyc_file):",
            "                        self._log_stdout(",
            "                            \"Deleting plugin from {file}\".format(file=pyc_file)",
            "                        )",
            "                        os.remove(pyc_file)",
            "",
            "        else:",
            "            self._logger.warning(",
            "                \"Trying to uninstall plugin {plugin} but origin is unknown ({plugin.origin.type})\".format(",
            "                    **locals()",
            "                )",
            "            )",
            "            return make_response(\"Could not uninstall plugin, its origin is unknown\")",
            "",
            "        needs_restart = self._plugin_manager.is_restart_needing_plugin(plugin) or cleanup",
            "        needs_refresh = plugin.implementation and isinstance(",
            "            plugin.implementation, octoprint.plugin.ReloadNeedingPlugin",
            "        )",
            "        needs_reconnect = (",
            "            self._plugin_manager.has_any_of_hooks(plugin, self._reconnect_hooks)",
            "            and self._printer.is_operational()",
            "        )",
            "",
            "        was_pending_install = self._plugin_manager.is_plugin_marked(",
            "            plugin.key, \"installed\"",
            "        )",
            "        self._plugin_manager.mark_plugin(",
            "            plugin.key,",
            "            uninstalled=not was_pending_install and needs_restart,",
            "            installed=False,",
            "        )",
            "",
            "        if not needs_restart:",
            "            try:",
            "                if plugin.enabled:",
            "                    self._plugin_manager.disable_plugin(plugin.key, plugin=plugin)",
            "            except octoprint.plugin.core.PluginLifecycleException as e:",
            "                self._logger.exception(",
            "                    \"Problem disabling plugin {name}\".format(name=plugin.key)",
            "                )",
            "                result = {",
            "                    \"result\": False,",
            "                    \"uninstalled\": True,",
            "                    \"disabled\": False,",
            "                    \"unloaded\": False,",
            "                    \"reason\": e.reason,",
            "                }",
            "                self._send_result_notification(\"uninstall\", result)",
            "                return jsonify(result)",
            "",
            "            try:",
            "                if plugin.loaded:",
            "                    self._plugin_manager.unload_plugin(plugin.key)",
            "            except octoprint.plugin.core.PluginLifecycleException as e:",
            "                self._logger.exception(",
            "                    \"Problem unloading plugin {name}\".format(name=plugin.key)",
            "                )",
            "                result = {",
            "                    \"result\": False,",
            "                    \"uninstalled\": True,",
            "                    \"disabled\": True,",
            "                    \"unloaded\": False,",
            "                    \"reason\": e.reason,",
            "                }",
            "                self._send_result_notification(\"uninstall\", result)",
            "                return jsonify(result)",
            "",
            "        self._plugin_manager.reload_plugins()",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_UNINSTALL_PLUGIN,",
            "            {\"id\": plugin.key, \"version\": plugin.version},",
            "        )",
            "",
            "        result = {",
            "            \"result\": True,",
            "            \"needs_restart\": needs_restart,",
            "            \"needs_refresh\": needs_refresh,",
            "            \"needs_reconnect\": needs_reconnect,",
            "            \"plugin\": self._to_external_plugin(plugin),",
            "        }",
            "        self._send_result_notification(\"uninstall\", result)",
            "        self._logger.info(\"Plugin {} uninstalled\".format(plugin.key))",
            "",
            "        self._cleanup_disabled(plugin.key)",
            "        if cleanup:",
            "            self.command_cleanup(plugin.key, result_notifications=False)",
            "",
            "        return jsonify(result)",
            "",
            "    def command_cleanup(",
            "        self,",
            "        plugin,",
            "        include_disabled=False,",
            "        result_notifications=True,",
            "        settings_save=True,",
            "    ):",
            "        if isinstance(plugin, basestring):",
            "            key = result_value = plugin",
            "        else:",
            "            key = plugin.key",
            "            result_value = self._to_external_plugin(plugin)",
            "",
            "        message = \"Cleaning up plugin {}...\".format(key)",
            "        self._logger.info(message)",
            "        self._log_stdout(message)",
            "",
            "        # delete plugin settings",
            "        self._cleanup_settings(key)",
            "",
            "        # delete plugin disabled entry",
            "        if include_disabled:",
            "            self._cleanup_disabled(key)",
            "",
            "        # delete plugin data folder",
            "        result_data = True",
            "        if not self._cleanup_data(key):",
            "            message = \"Could not delete data folder of plugin {}\".format(key)",
            "            self._logger.exception(message)",
            "            self._log_stderr(message)",
            "            result_data = False",
            "",
            "        if settings_save:",
            "            self._settings.save()",
            "",
            "        result = {\"result\": result_data, \"needs_restart\": True, \"plugin\": result_value}",
            "        if result_notifications:",
            "            self._send_result_notification(\"cleanup\", result)",
            "",
            "        # cleaning orphan cache",
            "        self._orphans = None",
            "",
            "        return jsonify(result)",
            "",
            "    def command_cleanup_all(self):",
            "        orphans = self._get_orphans()",
            "        cleaned_up = set()",
            "",
            "        for orphan in sorted(orphans.keys()):",
            "            self.command_cleanup(",
            "                orphan,",
            "                include_disabled=True,",
            "                result_notifications=False,",
            "                settings_save=False,",
            "            )",
            "            cleaned_up.add(orphan)",
            "",
            "        self._settings.save()",
            "",
            "        result = {",
            "            \"result\": True,",
            "            \"needs_restart\": len(cleaned_up) > 0,",
            "            \"cleaned_up\": sorted(list(cleaned_up)),",
            "        }",
            "        self._send_result_notification(\"cleanup_all\", result)",
            "        self._logger.info(",
            "            \"Cleaned up all data, {} left overs removed\".format(len(cleaned_up))",
            "        )",
            "",
            "        # cleaning orphan cache",
            "        self._orphans = None",
            "",
            "        return jsonify(result)",
            "",
            "    def _cleanup_disabled(self, plugin):",
            "        # delete from disabled list",
            "        disabled = self._settings.global_get([\"plugins\", \"_disabled\"])",
            "        try:",
            "            disabled.remove(plugin)",
            "        except ValueError:",
            "            # not in list, ok",
            "            pass",
            "        self._settings.global_set([\"plugins\", \"_disabled\"], disabled)",
            "",
            "    def _cleanup_settings(self, plugin):",
            "        # delete plugin settings",
            "        self._settings.global_remove([\"plugins\", plugin])",
            "        self._settings.global_remove([\"server\", \"seenWizards\", plugin])",
            "        return True",
            "",
            "    def _cleanup_data(self, plugin):",
            "        import os",
            "        import shutil",
            "",
            "        data_folder = os.path.join(self._settings.getBaseFolder(\"data\"), plugin)",
            "        if os.path.exists(data_folder):",
            "            try:",
            "                shutil.rmtree(data_folder)",
            "                return True",
            "            except Exception:",
            "                self._logger.exception(",
            "                    \"Could not delete plugin data folder at {}\".format(data_folder)",
            "                )",
            "                return False",
            "        else:",
            "            return True",
            "",
            "    def command_toggle(self, plugin, command):",
            "        if plugin.key == \"pluginmanager\" or (plugin.hidden and plugin.bundled):",
            "            return make_response(\"Can't enable/disable Plugin Manager\", 400)",
            "",
            "        pending = (command == \"disable\" and plugin.key in self._pending_enable) or (",
            "            command == \"enable\" and plugin.key in self._pending_disable",
            "        )",
            "        safe_mode_victim = getattr(plugin, \"safe_mode_victim\", False)",
            "",
            "        needs_restart = self._plugin_manager.is_restart_needing_plugin(plugin)",
            "        needs_refresh = plugin.implementation and isinstance(",
            "            plugin.implementation, octoprint.plugin.ReloadNeedingPlugin",
            "        )",
            "        needs_reconnect = (",
            "            self._plugin_manager.has_any_of_hooks(plugin, self._reconnect_hooks)",
            "            and self._printer.is_operational()",
            "        )",
            "",
            "        needs_restart_api = (",
            "            needs_restart or safe_mode_victim or plugin.forced_disabled",
            "        ) and not pending",
            "        needs_refresh_api = needs_refresh and not pending",
            "        needs_reconnect_api = needs_reconnect and not pending",
            "",
            "        try:",
            "            if command == \"disable\":",
            "                self._mark_plugin_disabled(plugin, needs_restart=needs_restart)",
            "            elif command == \"enable\":",
            "                self._mark_plugin_enabled(plugin, needs_restart=needs_restart)",
            "        except octoprint.plugin.core.PluginLifecycleException as e:",
            "            self._logger.exception(",
            "                \"Problem toggling enabled state of {name}: {reason}\".format(",
            "                    name=plugin.key, reason=e.reason",
            "                )",
            "            )",
            "            result = {\"result\": False, \"reason\": e.reason}",
            "        except octoprint.plugin.core.PluginNeedsRestart:",
            "            result = {",
            "                \"result\": True,",
            "                \"needs_restart\": True,",
            "                \"needs_refresh\": True,",
            "                \"needs_reconnect\": True,",
            "                \"plugin\": self._to_external_plugin(plugin),",
            "            }",
            "        else:",
            "            result = {",
            "                \"result\": True,",
            "                \"needs_restart\": needs_restart_api,",
            "                \"needs_refresh\": needs_refresh_api,",
            "                \"needs_reconnect\": needs_reconnect_api,",
            "                \"plugin\": self._to_external_plugin(plugin),",
            "            }",
            "",
            "        self._send_result_notification(command, result)",
            "        return jsonify(result)",
            "",
            "    def _find_installed_plugin(self, packages, plugins=None):",
            "        if plugins is None:",
            "            plugins = self._plugin_manager.find_plugins(",
            "                existing={}, ignore_uninstalled=False",
            "            )",
            "",
            "        for plugin in plugins.values():",
            "            if plugin.origin is None or plugin.origin.type != \"entry_point\":",
            "                continue",
            "",
            "            package_name = plugin.origin.package_name",
            "            package_version = plugin.origin.package_version",
            "            versioned_package = \"{package_name}-{package_version}\".format(**locals())",
            "",
            "            if package_name in packages or versioned_package in packages:",
            "                # exact match, we are done here",
            "                return plugin",
            "",
            "            else:",
            "                # it might still be a version that got stripped by python's package resources, e.g. 1.4.5a0 => 1.4.5a",
            "                found = False",
            "",
            "                for inst in packages:",
            "                    if inst.startswith(versioned_package):",
            "                        found = True",
            "                        break",
            "",
            "                if found:",
            "                    return plugin",
            "",
            "        return None",
            "",
            "    def _send_result_notification(self, action, result):",
            "        notification = {\"type\": \"result\", \"action\": action}",
            "        notification.update(result)",
            "        self._plugin_manager.send_plugin_message(self._identifier, notification)",
            "",
            "    def _call_pip(self, args):",
            "        if self._pip_caller is None or not self._pip_caller.available:",
            "            raise RuntimeError(\"No pip available, can't operate\".format(**locals()))",
            "",
            "        if \"--process-dependency-links\" in args:",
            "            self._log_message(",
            "                \"Installation needs to process external dependencies, that might make it take a bit longer than usual depending on the pip version\"",
            "            )",
            "",
            "        additional_args = self._settings.get([\"pip_args\"])",
            "",
            "        if additional_args is not None:",
            "",
            "            inapplicable_arguments = self.__class__.PIP_INAPPLICABLE_ARGUMENTS.get(",
            "                args[0], list()",
            "            )",
            "            for inapplicable_argument in inapplicable_arguments:",
            "                additional_args = re.sub(",
            "                    r\"(^|\\s)\" + re.escape(inapplicable_argument) + r\"\\\\b\",",
            "                    \"\",",
            "                    additional_args,",
            "                )",
            "",
            "            if additional_args:",
            "                args.append(additional_args)",
            "",
            "        kwargs = {",
            "            \"env\": {",
            "                \"PYTHONWARNINGS\": \"ignore:DEPRECATION::pip._internal.cli.base_command\"",
            "            }",
            "        }",
            "",
            "        return self._pip_caller.execute(*args, **kwargs)",
            "",
            "    def _log_message(self, *lines):",
            "        self._log(lines, prefix=\"*\", stream=\"message\")",
            "",
            "    def _log_call(self, *lines):",
            "        self._log(lines, prefix=\" \", stream=\"call\")",
            "",
            "    def _log_stdout(self, *lines):",
            "        self._log(lines, prefix=\">\", stream=\"stdout\")",
            "",
            "    def _log_stderr(self, *lines):",
            "        self._log(lines, prefix=\"!\", stream=\"stderr\")",
            "",
            "    def _log(self, lines, prefix=None, stream=None, strip=True):",
            "        if strip:",
            "            lines = list(map(lambda x: x.strip(), lines))",
            "",
            "        self._plugin_manager.send_plugin_message(",
            "            self._identifier,",
            "            {",
            "                \"type\": \"loglines\",",
            "                \"loglines\": [{\"line\": line, \"stream\": stream} for line in lines],",
            "            },",
            "        )",
            "        for line in lines:  # noqa: B007",
            "            self._console_logger.debug(\"{prefix} {line}\".format(**locals()))",
            "",
            "    def _mark_plugin_enabled(self, plugin, needs_restart=False):",
            "        disabled_list = list(",
            "            self._settings.global_get(",
            "                [\"plugins\", \"_disabled\"],",
            "                validator=lambda x: isinstance(x, list),",
            "                fallback=[],",
            "            )",
            "        )",
            "        if plugin.key in disabled_list:",
            "            disabled_list.remove(plugin.key)",
            "            self._settings.global_set([\"plugins\", \"_disabled\"], disabled_list)",
            "            self._settings.save(force=True)",
            "",
            "        if (",
            "            not needs_restart",
            "            and not plugin.forced_disabled",
            "            and not getattr(plugin, \"safe_mode_victim\", False)",
            "        ):",
            "            self._plugin_manager.enable_plugin(plugin.key)",
            "        else:",
            "            if plugin.key in self._pending_disable:",
            "                self._pending_disable.remove(plugin.key)",
            "            elif not plugin.enabled and plugin.key not in self._pending_enable:",
            "                self._pending_enable.add(plugin.key)",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_ENABLE_PLUGIN,",
            "            {\"id\": plugin.key, \"version\": plugin.version},",
            "        )",
            "",
            "    def _mark_plugin_disabled(self, plugin, needs_restart=False):",
            "        disabled_list = list(",
            "            self._settings.global_get(",
            "                [\"plugins\", \"_disabled\"],",
            "                validator=lambda x: isinstance(x, list),",
            "                fallback=[],",
            "            )",
            "        )",
            "        if plugin.key not in disabled_list:",
            "            disabled_list.append(plugin.key)",
            "            self._settings.global_set([\"plugins\", \"_disabled\"], disabled_list)",
            "            self._settings.save(force=True)",
            "",
            "        if (",
            "            not needs_restart",
            "            and not plugin.forced_disabled",
            "            and not getattr(plugin, \"safe_mode_victim\", False)",
            "        ):",
            "            self._plugin_manager.disable_plugin(plugin.key)",
            "        else:",
            "            if plugin.key in self._pending_enable:",
            "                self._pending_enable.remove(plugin.key)",
            "            elif (",
            "                plugin.enabled",
            "                or plugin.forced_disabled",
            "                or getattr(plugin, \"safe_mode_victim\", False)",
            "            ) and plugin.key not in self._pending_disable:",
            "                self._pending_disable.add(plugin.key)",
            "",
            "        # noinspection PyUnresolvedReferences",
            "        self._event_bus.fire(",
            "            Events.PLUGIN_PLUGINMANAGER_DISABLE_PLUGIN,",
            "            {\"id\": plugin.key, \"version\": plugin.version},",
            "        )",
            "",
            "    def _fetch_all_data(self, do_async=False):",
            "        def run():",
            "            self._repository_available = self._fetch_repository_from_disk()",
            "            self._notices_available = self._fetch_notices_from_disk()",
            "",
            "        if do_async:",
            "            thread = threading.Thread(target=run)",
            "            thread.daemon = True",
            "            thread.start()",
            "        else:",
            "            run()",
            "",
            "    def _is_repository_cache_valid(self, mtime=None):",
            "        import time",
            "",
            "        if mtime is None:",
            "            mtime = self._repository_mtime",
            "        if mtime is None:",
            "            return False",
            "        return mtime + self._repository_cache_ttl >= time.time() > mtime",
            "",
            "    def _fetch_repository_from_disk(self):",
            "        repo_data = None",
            "        if os.path.isfile(self._repository_cache_path):",
            "            mtime = os.path.getmtime(self._repository_cache_path)",
            "            if self._is_repository_cache_valid(mtime=mtime):",
            "                try:",
            "                    import json",
            "",
            "                    with io.open(",
            "                        self._repository_cache_path, \"rt\", encoding=\"utf-8\"",
            "                    ) as f:",
            "                        repo_data = json.load(f)",
            "                    self._repository_mtime = mtime",
            "                    self._logger.info(",
            "                        \"Loaded plugin repository data from disk, was still valid\"",
            "                    )",
            "                except Exception:",
            "                    self._logger.exception(",
            "                        \"Error while loading repository data from {}\".format(",
            "                            self._repository_cache_path",
            "                        )",
            "                    )",
            "",
            "        return self._refresh_repository(repo_data=repo_data)",
            "",
            "    def _fetch_repository_from_url(self):",
            "        if not self._connectivity_checker.online:",
            "            self._logger.info(",
            "                \"Looks like we are offline, can't fetch repository from network\"",
            "            )",
            "            return None",
            "",
            "        repository_url = self._settings.get([\"repository\"])",
            "        try:",
            "            r = requests.get(repository_url, timeout=30)",
            "            r.raise_for_status()",
            "            self._logger.info(",
            "                \"Loaded plugin repository data from {}\".format(repository_url)",
            "            )",
            "        except Exception as e:",
            "            self._logger.exception(",
            "                \"Could not fetch plugins from repository at {repository_url}: {message}\".format(",
            "                    repository_url=repository_url, message=e",
            "                )",
            "            )",
            "            return None",
            "",
            "        try:",
            "            repo_data = r.json()",
            "        except Exception as e:",
            "            self._logger.exception(\"Error while reading repository data: {}\".format(e))",
            "            return None",
            "",
            "        # validation",
            "        if not isinstance(repo_data, (list, tuple)):",
            "            self._logger.warning(",
            "                \"Invalid repository data: expected a list, got {!r}\".format(repo_data)",
            "            )",
            "            return None",
            "",
            "        try:",
            "            import json",
            "",
            "            with octoprint.util.atomic_write(self._repository_cache_path, mode=\"wb\") as f:",
            "                f.write(to_bytes(json.dumps(repo_data)))",
            "            self._repository_mtime = os.path.getmtime(self._repository_cache_path)",
            "        except Exception as e:",
            "            self._logger.exception(",
            "                \"Error while saving repository data to {}: {}\".format(",
            "                    self._repository_cache_path, e",
            "                )",
            "            )",
            "",
            "        return repo_data",
            "",
            "    def _refresh_repository(self, repo_data=None):",
            "        if repo_data is None:",
            "            repo_data = self._fetch_repository_from_url()",
            "            if repo_data is None:",
            "                return False",
            "",
            "        self._repository_plugins = list(",
            "            filter(lambda x: x is not None, map(map_repository_entry, repo_data))",
            "        )",
            "        return True",
            "",
            "    def _is_notices_cache_valid(self, mtime=None):",
            "        import time",
            "",
            "        if mtime is None:",
            "            mtime = self._notices_mtime",
            "        if mtime is None:",
            "            return False",
            "        return mtime + self._notices_cache_ttl >= time.time() > mtime",
            "",
            "    def _fetch_notices_from_disk(self):",
            "        notice_data = None",
            "        if os.path.isfile(self._notices_cache_path):",
            "            mtime = os.path.getmtime(self._notices_cache_path)",
            "            if self._is_notices_cache_valid(mtime=mtime):",
            "                try:",
            "                    import json",
            "",
            "                    with io.open(self._notices_cache_path, \"rt\", encoding=\"utf-8\") as f:",
            "                        notice_data = json.load(f)",
            "                    self._notices_mtime = mtime",
            "                    self._logger.info(\"Loaded notice data from disk, was still valid\")",
            "                except Exception:",
            "                    self._logger.exception(",
            "                        \"Error while loading notices from {}\".format(",
            "                            self._notices_cache_path",
            "                        )",
            "                    )",
            "",
            "        return self._refresh_notices(notice_data=notice_data)",
            "",
            "    def _fetch_notices_from_url(self):",
            "        if not self._connectivity_checker.online:",
            "            self._logger.info(",
            "                \"Looks like we are offline, can't fetch notices from network\"",
            "            )",
            "            return None",
            "",
            "        notices_url = self._settings.get([\"notices\"])",
            "        try:",
            "            r = requests.get(notices_url, timeout=30)",
            "            r.raise_for_status()",
            "            self._logger.info(\"Loaded plugin notices data from {}\".format(notices_url))",
            "        except Exception as e:",
            "            self._logger.exception(",
            "                \"Could not fetch notices from {notices_url}: {message}\".format(",
            "                    notices_url=notices_url, message=str(e)",
            "                )",
            "            )",
            "            return None",
            "",
            "        notice_data = r.json()",
            "",
            "        try:",
            "            import json",
            "",
            "            with octoprint.util.atomic_write(self._notices_cache_path, mode=\"wb\") as f:",
            "                f.write(to_bytes(json.dumps(notice_data)))",
            "            self._notices_mtime = os.path.getmtime(self._notices_cache_path)",
            "        except Exception as e:",
            "            self._logger.exception(",
            "                \"Error while saving notices to {}: {}\".format(",
            "                    self._notices_cache_path, str(e)",
            "                )",
            "            )",
            "        return notice_data",
            "",
            "    def _refresh_notices(self, notice_data=None):",
            "        if notice_data is None:",
            "            notice_data = self._fetch_notices_from_url()",
            "            if notice_data is None:",
            "                return False",
            "",
            "        notices = {}",
            "        for notice in notice_data:",
            "            if \"plugin\" not in notice or \"text\" not in notice or \"date\" not in notice:",
            "                continue",
            "",
            "            key = notice[\"plugin\"]",
            "",
            "            try:",
            "                # Jekyll turns \"%Y-%m-%d %H:%M:%SZ\" into \"%Y-%m-%d %H:%M:%S +0000\", so be sure to ignore \"+0000\"",
            "                #",
            "                # Being able to use dateutil here would make things way easier but sadly that can no longer get",
            "                # installed (from source) under OctoPi 0.14 due to its setuptools-scm dependency, so we have to do",
            "                # without it for now until we can drop support for OctoPi 0.14.",
            "                parsed_date = datetime.strptime(notice[\"date\"], \"%Y-%m-%d %H:%M:%S +0000\")",
            "                notice[\"timestamp\"] = parsed_date.timetuple()",
            "            except Exception as e:",
            "                self._logger.warning(",
            "                    \"Error while parsing date {!r} for plugin notice \"",
            "                    \"of plugin {}, ignoring notice: {}\".format(",
            "                        notice[\"date\"], key, str(e)",
            "                    )",
            "                )",
            "                continue",
            "",
            "            if key not in notices:",
            "                notices[key] = []",
            "            notices[key].append(notice)",
            "",
            "        self._notices = notices",
            "        return True",
            "",
            "    def _get_orphans(self, refresh=False):",
            "        from collections import defaultdict",
            "",
            "        if self._orphans is not None and not refresh:",
            "            return self._orphans",
            "",
            "        installed_keys = self._plugin_manager.plugins.keys()",
            "        orphans = defaultdict(",
            "            lambda: {\"settings\": False, \"data\": False, \"disabled\": False}",
            "        )",
            "",
            "        # settings",
            "        for key in list(self._settings.global_get([\"plugins\"]).keys()):",
            "            if key.startswith(\"_\"):",
            "                # internal key, like _disabled",
            "                continue",
            "",
            "            if key not in installed_keys:",
            "                orphans[key][\"settings\"] = True",
            "",
            "        # data",
            "        for entry in scandir(self._settings.getBaseFolder(\"data\")):",
            "            if not entry.is_dir():",
            "                continue",
            "",
            "            if entry.name not in installed_keys:",
            "                orphans[entry.name][\"data\"] = True",
            "",
            "        # disabled",
            "        disabled = self._settings.global_get([\"plugins\", \"_disabled\"])",
            "        for key in disabled:",
            "            if key not in installed_keys:",
            "                orphans[key][\"disabled\"] = True",
            "",
            "        self._orphans = dict(**orphans)",
            "        return self._orphans",
            "",
            "    @property",
            "    def _reconnect_hooks(self):",
            "        reconnect_hooks = self.__class__.RECONNECT_HOOKS",
            "",
            "        reconnect_hook_provider_hooks = self._plugin_manager.get_hooks(",
            "            \"octoprint.plugin.pluginmanager.reconnect_hooks\"",
            "        )",
            "        for name, hook in reconnect_hook_provider_hooks.items():",
            "            try:",
            "                result = hook()",
            "                if isinstance(result, (list, tuple)):",
            "                    reconnect_hooks.extend(",
            "                        filter(lambda x: isinstance(x, basestring), result)",
            "                    )",
            "            except Exception:",
            "                self._logger.exception(",
            "                    \"Error while retrieving additional hooks for which a \"",
            "                    \"reconnect is required from plugin {name}\".format(**locals()),",
            "                    extra={\"plugin\": name},",
            "                )",
            "",
            "        return reconnect_hooks",
            "",
            "    def _get_plugins(self):",
            "        plugins = self._plugin_manager.plugins",
            "",
            "        hidden = self._settings.get([\"hidden\"])",
            "        result = []",
            "        for key, plugin in plugins.items():",
            "            if key in hidden or (plugin.bundled and plugin.hidden):",
            "                continue",
            "            result.append(self._to_external_plugin(plugin))",
            "",
            "        return result",
            "",
            "    @staticmethod",
            "    def generate_plugins_json(",
            "        settings, plugin_manager, ignore_bundled=True, ignore_plugins_folder=True",
            "    ):",
            "        plugins = []",
            "        plugin_folder = settings.getBaseFolder(\"plugins\")",
            "        for plugin in plugin_manager.plugins.values():",
            "            if (ignore_bundled and plugin.bundled) or (",
            "                ignore_plugins_folder",
            "                and isinstance(plugin.origin, octoprint.plugin.core.FolderOrigin)",
            "                and plugin.origin.folder == plugin_folder",
            "            ):",
            "                # ignore bundled or from the plugins folder already included in the backup",
            "                continue",
            "",
            "            plugins.append({\"key\": plugin.key, \"name\": plugin.name, \"url\": plugin.url})",
            "        return plugins",
            "",
            "    def _to_external_plugin(self, plugin):",
            "        return {",
            "            \"key\": plugin.key,",
            "            \"name\": plugin.name,",
            "            \"description\": plugin.description,",
            "            \"disabling_discouraged\": gettext(plugin.disabling_discouraged)",
            "            if plugin.disabling_discouraged",
            "            else False,",
            "            \"author\": plugin.author,",
            "            \"version\": plugin.version,",
            "            \"url\": plugin.url,",
            "            \"license\": plugin.license,",
            "            \"python\": plugin.pythoncompat,",
            "            \"bundled\": plugin.bundled,",
            "            \"managable\": plugin.managable,",
            "            \"enabled\": plugin.enabled,",
            "            \"blacklisted\": plugin.blacklisted,",
            "            \"forced_disabled\": plugin.forced_disabled,",
            "            \"incompatible\": plugin.incompatible,",
            "            \"safe_mode_victim\": getattr(plugin, \"safe_mode_victim\", False),",
            "            \"pending_enable\": (",
            "                not plugin.enabled",
            "                and not getattr(plugin, \"safe_mode_victim\", False)",
            "                and plugin.key in self._pending_enable",
            "            ),",
            "            \"pending_disable\": (",
            "                (plugin.enabled or getattr(plugin, \"safe_mode_victim\", False))",
            "                and plugin.key in self._pending_disable",
            "            ),",
            "            \"pending_install\": (",
            "                self._plugin_manager.is_plugin_marked(plugin.key, \"installed\")",
            "            ),",
            "            \"pending_uninstall\": (",
            "                self._plugin_manager.is_plugin_marked(plugin.key, \"uninstalled\")",
            "            ),",
            "            \"origin\": plugin.origin.type,",
            "            \"notifications\": self._get_notifications(plugin),",
            "        }",
            "",
            "    def _get_notifications(self, plugin):",
            "        key = plugin.key",
            "        if not plugin.enabled:",
            "            return",
            "",
            "        if key not in self._notices:",
            "            return",
            "",
            "        octoprint_version = get_octoprint_version(base=True)",
            "        plugin_notifications = self._notices.get(key, [])",
            "",
            "        def map_notification(notification):",
            "            return self._to_external_notification(key, notification)",
            "",
            "        return list(",
            "            filter(",
            "                lambda x: x is not None,",
            "                map(",
            "                    map_notification,",
            "                    filter(",
            "                        lambda n: _filter_relevant_notification(",
            "                            n, plugin.version, octoprint_version",
            "                        ),",
            "                        plugin_notifications,",
            "                    ),",
            "                ),",
            "            )",
            "        )",
            "",
            "    def _to_external_notification(self, key, notification):",
            "        return {",
            "            \"key\": key,",
            "            \"date\": time.mktime(notification[\"timestamp\"]),",
            "            \"text\": notification[\"text\"],",
            "            \"link\": notification.get(\"link\"),",
            "            \"versions\": notification.get(",
            "                \"pluginversions\", notification.get(\"versions\", [])",
            "            ),",
            "            \"important\": notification.get(\"important\", False),",
            "        }",
            "",
            "",
            "def _filter_relevant_notification(notification, plugin_version, octoprint_version):",
            "    if \"pluginversions\" in notification:",
            "        pluginversions = notification[\"pluginversions\"]",
            "",
            "        is_range = lambda x: \"=\" in x or \">\" in x or \"<\" in x",
            "        version_ranges = list(",
            "            map(",
            "                lambda x: pkg_resources.Requirement.parse(notification[\"plugin\"] + x),",
            "                filter(is_range, pluginversions),",
            "            )",
            "        )",
            "        versions = list(filter(lambda x: not is_range(x), pluginversions))",
            "    elif \"versions\" in notification:",
            "        version_ranges = []",
            "        versions = notification[\"versions\"]",
            "    else:",
            "        version_ranges = versions = None",
            "",
            "    return (",
            "        \"text\" in notification",
            "        and \"date\" in notification",
            "        and (",
            "            (version_ranges is None and versions is None)",
            "            or (",
            "                version_ranges",
            "                and (any(map(lambda v: plugin_version in v, version_ranges)))",
            "            )",
            "            or (versions and plugin_version in versions)",
            "        )",
            "        and (",
            "            \"octoversions\" not in notification",
            "            or is_octoprint_compatible(",
            "                *notification[\"octoversions\"], octoprint_version=octoprint_version",
            "            )",
            "        )",
            "    )",
            "",
            "",
            "def _register_custom_events(*args, **kwargs):",
            "    return [\"install_plugin\", \"uninstall_plugin\", \"enable_plugin\", \"disable_plugin\"]",
            "",
            "",
            "__plugin_name__ = \"Plugin Manager\"",
            "__plugin_author__ = \"Gina H\u00e4u\u00dfge\"",
            "__plugin_url__ = \"http://docs.octoprint.org/en/master/bundledplugins/pluginmanager.html\"",
            "__plugin_description__ = \"Allows installing and managing OctoPrint plugins\"",
            "__plugin_license__ = \"AGPLv3\"",
            "__plugin_pythoncompat__ = \">=2.7,<4\"",
            "__plugin_hidden__ = True",
            "",
            "",
            "def __plugin_load__():",
            "    global __plugin_implementation__",
            "    __plugin_implementation__ = PluginManagerPlugin()",
            "",
            "    global __plugin_hooks__",
            "    __plugin_hooks__ = {",
            "        \"octoprint.server.http.bodysize\": __plugin_implementation__.increase_upload_bodysize,",
            "        \"octoprint.ui.web.templatetypes\": __plugin_implementation__.get_template_types,",
            "        \"octoprint.events.register_custom_events\": _register_custom_events,",
            "        \"octoprint.access.permissions\": __plugin_implementation__.get_additional_permissions,",
            "    }",
            "",
            "    global __plugin_helpers__",
            "    __plugin_helpers__ = {",
            "        \"generate_plugins_json\": __plugin_implementation__.generate_plugins_json,",
            "    }"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "649": [
                "PluginManagerPlugin",
                "on_api_command"
            ],
            "670": [
                "PluginManagerPlugin",
                "on_api_command"
            ]
        },
        "addLocation": []
    },
    "src/octoprint/server/api/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     if len(api_plugins) > 1:"
            },
            "2": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         return make_response("
            },
            "3": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"More than one api provider registered for {name}, can't proceed\".format("
            },
            "4": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                name=name"
            },
            "5": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            \"More than one api provider registered, can't proceed\","
            },
            "7": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "             500,"
            },
            "8": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         )"
            },
            "9": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "     if len(api_plugins) > 1:"
            },
            "12": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         return make_response("
            },
            "13": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"More than one api provider registered for {name}, can't proceed\".format("
            },
            "14": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                name=name"
            },
            "15": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            \"More than one api provider registered, can't proceed\","
            },
            "17": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             500,"
            },
            "18": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         )"
            },
            "19": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": 585,
                "PatchRowcode": "             timeout = float(data[\"timeout\"])"
            },
            "21": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": 586,
                "PatchRowcode": "         except Exception:"
            },
            "22": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": 587,
                "PatchRowcode": "             return make_response("
            },
            "23": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"{!r} is not a valid value for timeout (must be int or float)\".format("
            },
            "24": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    data[\"timeout\"]"
            },
            "25": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                ),"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 588,
                "PatchRowcode": "+                \"Not a valid value for timeout (must be int or float)\","
            },
            "27": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": 589,
                "PatchRowcode": "                 400,"
            },
            "28": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": 590,
                "PatchRowcode": "             )"
            },
            "29": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": 591,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 704,
                "afterPatchRowNumber": 698,
                "PatchRowcode": "     try:"
            },
            "31": {
                "beforePatchRowNumber": 705,
                "afterPatchRowNumber": 699,
                "PatchRowcode": "         port = int(data[\"port\"])"
            },
            "32": {
                "beforePatchRowNumber": 706,
                "afterPatchRowNumber": 700,
                "PatchRowcode": "     except Exception:"
            },
            "33": {
                "beforePatchRowNumber": 707,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return make_response("
            },
            "34": {
                "beforePatchRowNumber": 708,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"{!r} is not a valid value for port (must be int)\".format(data[\"port\"]), 400"
            },
            "35": {
                "beforePatchRowNumber": 709,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 701,
                "PatchRowcode": "+        return make_response(\"Not a valid value for port (must be int)\", 400)"
            },
            "37": {
                "beforePatchRowNumber": 710,
                "afterPatchRowNumber": 702,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 711,
                "afterPatchRowNumber": 703,
                "PatchRowcode": "     timeout = 3.05"
            },
            "39": {
                "beforePatchRowNumber": 712,
                "afterPatchRowNumber": 704,
                "PatchRowcode": "     if \"timeout\" in data:"
            },
            "40": {
                "beforePatchRowNumber": 713,
                "afterPatchRowNumber": 705,
                "PatchRowcode": "         try:"
            },
            "41": {
                "beforePatchRowNumber": 714,
                "afterPatchRowNumber": 706,
                "PatchRowcode": "             timeout = float(data[\"timeout\"])"
            },
            "42": {
                "beforePatchRowNumber": 715,
                "afterPatchRowNumber": 707,
                "PatchRowcode": "         except Exception:"
            },
            "43": {
                "beforePatchRowNumber": 716,
                "afterPatchRowNumber": 708,
                "PatchRowcode": "             return make_response("
            },
            "44": {
                "beforePatchRowNumber": 717,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"{!r} is not a valid value for timeout (must be int or float)\".format("
            },
            "45": {
                "beforePatchRowNumber": 718,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    data[\"timeout\"]"
            },
            "46": {
                "beforePatchRowNumber": 719,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                ),"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 709,
                "PatchRowcode": "+                \"Not a valid value for timeout (must be int or float)\","
            },
            "48": {
                "beforePatchRowNumber": 720,
                "afterPatchRowNumber": 710,
                "PatchRowcode": "                 400,"
            },
            "49": {
                "beforePatchRowNumber": 721,
                "afterPatchRowNumber": 711,
                "PatchRowcode": "             )"
            },
            "50": {
                "beforePatchRowNumber": 722,
                "afterPatchRowNumber": 712,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 723,
                "afterPatchRowNumber": 713,
                "PatchRowcode": "     protocol = data.get(\"protocol\", \"tcp\")"
            },
            "52": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": 714,
                "PatchRowcode": "     if protocol not in (\"tcp\", \"udp\"):"
            },
            "53": {
                "beforePatchRowNumber": 725,
                "afterPatchRowNumber": 715,
                "PatchRowcode": "         return make_response("
            },
            "54": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"{!r} is not a valid value for protocol, must be tcp or udp\".format(protocol),"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 716,
                "PatchRowcode": "+            \"Not a valid value for protocol, must be tcp or udp\","
            },
            "56": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 717,
                "PatchRowcode": "             400,"
            },
            "57": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 718,
                "PatchRowcode": "         )"
            },
            "58": {
                "beforePatchRowNumber": 729,
                "afterPatchRowNumber": 719,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "import io",
            "import logging",
            "",
            "from flask import (",
            "    Blueprint,",
            "    abort,",
            "    current_app,",
            "    g,",
            "    jsonify,",
            "    make_response,",
            "    request,",
            "    session,",
            ")",
            "from flask_login import current_user, login_user, logout_user",
            "from werkzeug.exceptions import HTTPException",
            "",
            "import octoprint.access.users",
            "import octoprint.plugin",
            "import octoprint.server",
            "import octoprint.util.net as util_net",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.events import Events, eventManager",
            "from octoprint.server import NO_CONTENT",
            "from octoprint.server.util import (",
            "    corsRequestHandler,",
            "    corsResponseHandler,",
            "    loginFromApiKeyRequestHandler,",
            "    loginFromAuthorizationHeaderRequestHandler,",
            "    noCachingExceptGetResponseHandler,",
            ")",
            "from octoprint.server.util.flask import (",
            "    get_json_command_from_request,",
            "    get_remote_address,",
            "    no_firstrun_access,",
            "    passive_login,",
            ")",
            "from octoprint.settings import settings as s",
            "from octoprint.settings import valid_boolean_trues",
            "from octoprint.vendor.flask_principal import Identity, identity_changed",
            "",
            "# ~~ init api blueprint, including sub modules",
            "",
            "api = Blueprint(\"api\", __name__)",
            "",
            "from . import access as api_access  # noqa: F401,E402",
            "from . import connection as api_connection  # noqa: F401,E402",
            "from . import files as api_files  # noqa: F401,E402",
            "from . import job as api_job  # noqa: F401,E402",
            "from . import languages as api_languages  # noqa: F401,E402",
            "from . import printer as api_printer  # noqa: F401,E402",
            "from . import printer_profiles as api_printer_profiles  # noqa: F401,E402",
            "from . import settings as api_settings  # noqa: F401,E402",
            "from . import slicing as api_slicing  # noqa: F401,E402",
            "from . import system as api_system  # noqa: F401,E402",
            "from . import timelapse as api_timelapse  # noqa: F401,E402",
            "from . import users as api_users  # noqa: F401,E402",
            "",
            "VERSION = \"0.1\"",
            "",
            "api.after_request(noCachingExceptGetResponseHandler)",
            "",
            "api.before_request(corsRequestHandler)",
            "api.before_request(loginFromAuthorizationHeaderRequestHandler)",
            "api.before_request(loginFromApiKeyRequestHandler)",
            "api.after_request(corsResponseHandler)",
            "",
            "# ~~ data from plugins",
            "",
            "",
            "@api.route(\"/plugin/<string:name>\", methods=[\"GET\"])",
            "def pluginData(name):",
            "    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(",
            "        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin",
            "    )",
            "    if not api_plugins:",
            "        return make_response(\"Not found\", 404)",
            "",
            "    if len(api_plugins) > 1:",
            "        return make_response(",
            "            \"More than one api provider registered for {name}, can't proceed\".format(",
            "                name=name",
            "            ),",
            "            500,",
            "        )",
            "",
            "    try:",
            "        api_plugin = api_plugins[0]",
            "        if api_plugin.is_api_adminonly() and not current_user.is_admin:",
            "            return make_response(\"Forbidden\", 403)",
            "",
            "        response = api_plugin.on_api_get(request)",
            "",
            "        if response is not None:",
            "            return response",
            "        return NO_CONTENT",
            "    except HTTPException:",
            "        raise",
            "    except Exception:",
            "        logging.getLogger(__name__).exception(",
            "            \"Error calling SimpleApiPlugin {}\".format(name), extra={\"plugin\": name}",
            "        )",
            "        return abort(500)",
            "",
            "",
            "# ~~ commands for plugins",
            "",
            "",
            "@api.route(\"/plugin/<string:name>\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "def pluginCommand(name):",
            "    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(",
            "        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin",
            "    )",
            "",
            "    if not api_plugins:",
            "        return make_response(\"Not found\", 404)",
            "",
            "    if len(api_plugins) > 1:",
            "        return make_response(",
            "            \"More than one api provider registered for {name}, can't proceed\".format(",
            "                name=name",
            "            ),",
            "            500,",
            "        )",
            "",
            "    api_plugin = api_plugins[0]",
            "    try:",
            "        valid_commands = api_plugin.get_api_commands()",
            "        if valid_commands is None:",
            "            return make_response(\"Method not allowed\", 405)",
            "",
            "        if api_plugin.is_api_adminonly() and not Permissions.ADMIN.can():",
            "            return make_response(\"Forbidden\", 403)",
            "",
            "        command, data, response = get_json_command_from_request(request, valid_commands)",
            "        if response is not None:",
            "            return response",
            "",
            "        response = api_plugin.on_api_command(command, data)",
            "        if response is not None:",
            "            return response",
            "        return NO_CONTENT",
            "    except HTTPException:",
            "        raise",
            "    except Exception:",
            "        logging.getLogger(__name__).exception(",
            "            \"Error while executing SimpleApiPlugin {}\".format(name),",
            "            extra={\"plugin\": name},",
            "        )",
            "        return abort(500)",
            "",
            "",
            "# ~~ first run setup",
            "",
            "",
            "@api.route(\"/setup/wizard\", methods=[\"GET\"])",
            "def wizardState():",
            "    if (",
            "        not s().getBoolean([\"server\", \"firstRun\"])",
            "        and octoprint.server.userManager.has_been_customized()",
            "        and not Permissions.ADMIN.can()",
            "    ):",
            "        abort(403)",
            "",
            "    seen_wizards = s().get([\"server\", \"seenWizards\"])",
            "",
            "    result = {}",
            "    wizard_plugins = octoprint.server.pluginManager.get_implementations(",
            "        octoprint.plugin.WizardPlugin",
            "    )",
            "    for implementation in wizard_plugins:",
            "        name = implementation._identifier",
            "        try:",
            "            required = implementation.is_wizard_required()",
            "            details = implementation.get_wizard_details()",
            "            version = implementation.get_wizard_version()",
            "            ignored = octoprint.plugin.WizardPlugin.is_wizard_ignored(",
            "                seen_wizards, implementation",
            "            )",
            "        except Exception:",
            "            logging.getLogger(__name__).exception(",
            "                \"There was an error fetching wizard \"",
            "                \"details for {}, ignoring\".format(name),",
            "                extra={\"plugin\": name},",
            "            )",
            "        else:",
            "            result[name] = {",
            "                \"required\": required,",
            "                \"details\": details,",
            "                \"version\": version,",
            "                \"ignored\": ignored,",
            "            }",
            "",
            "    return jsonify(result)",
            "",
            "",
            "@api.route(\"/setup/wizard\", methods=[\"POST\"])",
            "def wizardFinish():",
            "    if (",
            "        not s().getBoolean([\"server\", \"firstRun\"])",
            "        and octoprint.server.userManager.has_been_customized()",
            "        and not Permissions.ADMIN.can()",
            "    ):",
            "        abort(403)",
            "",
            "    data = {}",
            "    try:",
            "        data = request.get_json()",
            "    except Exception:",
            "        abort(400)",
            "",
            "    if data is None:",
            "        abort(400)",
            "",
            "    if \"handled\" not in data:",
            "        abort(400)",
            "    handled = data[\"handled\"]",
            "",
            "    if s().getBoolean([\"server\", \"firstRun\"]):",
            "        s().setBoolean([\"server\", \"firstRun\"], False)",
            "",
            "    seen_wizards = dict(s().get([\"server\", \"seenWizards\"]))",
            "",
            "    wizard_plugins = octoprint.server.pluginManager.get_implementations(",
            "        octoprint.plugin.WizardPlugin",
            "    )",
            "    for implementation in wizard_plugins:",
            "        name = implementation._identifier",
            "        try:",
            "            implementation.on_wizard_finish(name in handled)",
            "            if name in handled:",
            "                seen_wizards[name] = implementation.get_wizard_version()",
            "        except Exception:",
            "            logging.getLogger(__name__).exception(",
            "                \"There was an error finishing the \"",
            "                \"wizard for {}, ignoring\".format(name),",
            "                extra={\"plugin\": name},",
            "            )",
            "",
            "    s().set([\"server\", \"seenWizards\"], seen_wizards)",
            "    s().save()",
            "",
            "    return NO_CONTENT",
            "",
            "",
            "# ~~ system state",
            "",
            "",
            "@api.route(\"/state\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "def apiPrinterState():",
            "    return make_response(",
            "        (\"/api/state has been deprecated, use /api/printer instead\", 405, [])",
            "    )",
            "",
            "",
            "@api.route(\"/version\", methods=[\"GET\"])",
            "@Permissions.STATUS.require(403)",
            "def apiVersion():",
            "    return jsonify(",
            "        server=octoprint.server.VERSION,",
            "        api=VERSION,",
            "        text=\"OctoPrint {}\".format(octoprint.server.DISPLAY_VERSION),",
            "    )",
            "",
            "",
            "@api.route(\"/server\", methods=[\"GET\"])",
            "@Permissions.STATUS.require(403)",
            "def serverStatus():",
            "    return jsonify(version=octoprint.server.VERSION, safemode=octoprint.server.safe_mode)",
            "",
            "",
            "# ~~ Login/user handling",
            "",
            "",
            "@api.route(\"/login\", methods=[\"POST\"])",
            "def login():",
            "    data = request.get_json()",
            "    if not data:",
            "        data = request.values",
            "",
            "    if \"user\" in data and \"pass\" in data:",
            "        username = data[\"user\"]",
            "        password = data[\"pass\"]",
            "",
            "        if \"remember\" in data and data[\"remember\"] in valid_boolean_trues:",
            "            remember = True",
            "        else:",
            "            remember = False",
            "",
            "        if \"usersession.id\" in session:",
            "            _logout(current_user)",
            "",
            "        user = octoprint.server.userManager.find_user(username)",
            "        if user is not None:",
            "            if octoprint.server.userManager.check_password(username, password):",
            "                if not user.is_active:",
            "                    return make_response((\"Your account is deactivated\", 403, []))",
            "",
            "                user = octoprint.server.userManager.login_user(user)",
            "                session[\"usersession.id\"] = user.session",
            "                g.user = user",
            "",
            "                login_user(user, remember=remember)",
            "                identity_changed.send(",
            "                    current_app._get_current_object(), identity=Identity(user.get_id())",
            "                )",
            "                session[\"login_mechanism\"] = \"http\"",
            "",
            "                remote_addr = get_remote_address(request)",
            "                logging.getLogger(__name__).info(",
            "                    \"Actively logging in user {} from {}\".format(",
            "                        user.get_id(), remote_addr",
            "                    )",
            "                )",
            "",
            "                response = user.as_dict()",
            "                response[\"_is_external_client\"] = s().getBoolean(",
            "                    [\"server\", \"ipCheck\", \"enabled\"]",
            "                ) and not util_net.is_lan_address(",
            "                    remote_addr,",
            "                    additional_private=s().get([\"server\", \"ipCheck\", \"trustedSubnets\"]),",
            "                )",
            "                response[\"_login_mechanism\"] = session[\"login_mechanism\"]",
            "",
            "                r = make_response(jsonify(response))",
            "                r.delete_cookie(\"active_logout\")",
            "",
            "                eventManager().fire(",
            "                    Events.USER_LOGGED_IN, payload={\"username\": user.get_id()}",
            "                )",
            "",
            "                return r",
            "",
            "        return make_response((\"User unknown or password incorrect\", 403, []))",
            "",
            "    elif \"passive\" in data:",
            "        return passive_login()",
            "",
            "    return make_response(\"Neither user and pass attributes nor passive flag present\", 400)",
            "",
            "",
            "@api.route(\"/logout\", methods=[\"POST\"])",
            "def logout():",
            "    username = None",
            "    if current_user:",
            "        username = current_user.get_id()",
            "",
            "    # logout from user manager...",
            "    _logout(current_user)",
            "",
            "    # ... and from flask login (and principal)",
            "    logout_user()",
            "",
            "    # ... and send an active logout session cookie",
            "    r = make_response(jsonify(octoprint.server.userManager.anonymous_user_factory()))",
            "    r.set_cookie(\"active_logout\", \"true\")",
            "",
            "    if username:",
            "        eventManager().fire(Events.USER_LOGGED_OUT, payload={\"username\": username})",
            "",
            "    return r",
            "",
            "",
            "def _logout(user):",
            "    if \"usersession.id\" in session:",
            "        del session[\"usersession.id\"]",
            "    if \"login_mechanism\" in session:",
            "        del session[\"login_mechanism\"]",
            "    octoprint.server.userManager.logout_user(user)",
            "",
            "",
            "@api.route(\"/currentuser\", methods=[\"GET\"])",
            "def get_current_user():",
            "    return jsonify(",
            "        name=current_user.get_name(),",
            "        permissions=[permission.key for permission in current_user.effective_permissions],",
            "        groups=[group.key for group in current_user.groups],",
            "    )",
            "",
            "",
            "# ~~ Test utils",
            "",
            "",
            "@api.route(\"/util/test\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "@Permissions.ADMIN.require(403)",
            "def utilTest():",
            "    valid_commands = {",
            "        \"path\": [\"path\"],",
            "        \"url\": [\"url\"],",
            "        \"server\": [\"host\", \"port\"],",
            "        \"resolution\": [\"name\"],",
            "        \"address\": [],",
            "    }",
            "",
            "    command, data, response = get_json_command_from_request(request, valid_commands)",
            "    if response is not None:",
            "        return response",
            "",
            "    if command == \"path\":",
            "        return _test_path(data)",
            "    elif command == \"url\":",
            "        return _test_url(data)",
            "    elif command == \"server\":",
            "        return _test_server(data)",
            "    elif command == \"resolution\":",
            "        return _test_resolution(data)",
            "    elif command == \"address\":",
            "        return _test_address(data)",
            "",
            "",
            "def _test_path(data):",
            "    import os",
            "",
            "    from octoprint.util.paths import normalize",
            "",
            "    path = normalize(data[\"path\"], real=False)",
            "    if not path:",
            "        return jsonify(",
            "            path=path,",
            "            exists=False,",
            "            typeok=False,",
            "            broken_symlink=False,",
            "            access=False,",
            "            result=False,",
            "        )",
            "",
            "    unreal_path = path",
            "    path = os.path.realpath(path)",
            "",
            "    check_type = None",
            "    check_access = []",
            "",
            "    if \"check_type\" in data and data[\"check_type\"] in (\"file\", \"dir\"):",
            "        check_type = data[\"check_type\"]",
            "",
            "    if \"check_access\" in data:",
            "        request_check_access = data[\"check_access\"]",
            "        if not isinstance(request_check_access, list):",
            "            request_check_access = list(request_check_access)",
            "",
            "        check_access = [",
            "            check for check in request_check_access if check in (\"r\", \"w\", \"x\")",
            "        ]",
            "",
            "    allow_create_dir = data.get(\"allow_create_dir\", False) and check_type == \"dir\"",
            "    check_writable_dir = data.get(\"check_writable_dir\", False) and check_type == \"dir\"",
            "    if check_writable_dir and \"w\" not in check_access:",
            "        check_access.append(\"w\")",
            "",
            "    # check if path exists",
            "    exists = os.path.exists(path)",
            "    if not exists:",
            "        if os.path.islink(unreal_path):",
            "            # broken symlink, see #2644",
            "            logging.getLogger(__name__).error(",
            "                \"{} is a broken symlink pointing at non existing {}\".format(",
            "                    unreal_path, path",
            "                )",
            "            )",
            "            return jsonify(",
            "                path=unreal_path,",
            "                exists=False,",
            "                typeok=False,",
            "                broken_symlink=True,",
            "                access=False,",
            "                result=False,",
            "            )",
            "",
            "        elif check_type == \"dir\" and allow_create_dir:",
            "            try:",
            "                os.makedirs(path)",
            "            except Exception:",
            "                logging.getLogger(__name__).exception(",
            "                    \"Error while trying to create {}\".format(path)",
            "                )",
            "                return jsonify(",
            "                    path=path,",
            "                    exists=False,",
            "                    typeok=False,",
            "                    broken_symlink=False,",
            "                    access=False,",
            "                    result=False,",
            "                )",
            "            else:",
            "                exists = True",
            "",
            "    # check path type",
            "    type_mapping = {\"file\": os.path.isfile, \"dir\": os.path.isdir}",
            "    if check_type:",
            "        typeok = type_mapping[check_type](path)",
            "    else:",
            "        typeok = exists",
            "",
            "    # check if path allows requested access",
            "    access_mapping = {\"r\": os.R_OK, \"w\": os.W_OK, \"x\": os.X_OK}",
            "    if check_access:",
            "        mode = 0",
            "        for a in map(lambda x: access_mapping[x], check_access):",
            "            mode |= a",
            "        access = os.access(path, mode)",
            "    else:",
            "        access = exists",
            "",
            "    if check_writable_dir and check_type == \"dir\":",
            "        try:",
            "            test_path = os.path.join(path, \".testballoon.txt\")",
            "            with io.open(test_path, \"wb\") as f:",
            "                f.write(b\"Test\")",
            "            os.remove(test_path)",
            "        except Exception:",
            "            logging.getLogger(__name__).exception(",
            "                \"Error while testing if {} is really writable\".format(path)",
            "            )",
            "            return jsonify(",
            "                path=path,",
            "                exists=exists,",
            "                typeok=typeok,",
            "                broken_symlink=False,",
            "                access=False,",
            "                result=False,",
            "            )",
            "",
            "    return jsonify(",
            "        path=path,",
            "        exists=exists,",
            "        typeok=typeok,",
            "        broken_symlink=False,",
            "        access=access,",
            "        result=exists and typeok and access,",
            "    )",
            "",
            "",
            "def _test_url(data):",
            "    import requests",
            "",
            "    from octoprint import util as util",
            "",
            "    class StatusCodeRange(object):",
            "        def __init__(self, start=None, end=None):",
            "            self.start = start",
            "            self.end = end",
            "",
            "        def __contains__(self, item):",
            "            if not isinstance(item, int):",
            "                return False",
            "            if self.start and self.end:",
            "                return self.start <= item < self.end",
            "            elif self.start:",
            "                return self.start <= item",
            "            elif self.end:",
            "                return item < self.end",
            "            else:",
            "                return False",
            "",
            "        def as_dict(self):",
            "            return {\"start\": self.start, \"end\": self.end}",
            "",
            "    status_ranges = {",
            "        \"informational\": StatusCodeRange(start=100, end=200),",
            "        \"success\": StatusCodeRange(start=200, end=300),",
            "        \"redirection\": StatusCodeRange(start=300, end=400),",
            "        \"client_error\": StatusCodeRange(start=400, end=500),",
            "        \"server_error\": StatusCodeRange(start=500, end=600),",
            "        \"normal\": StatusCodeRange(end=400),",
            "        \"error\": StatusCodeRange(start=400, end=600),",
            "        \"any\": StatusCodeRange(start=100),",
            "        \"timeout\": StatusCodeRange(start=0, end=1),",
            "    }",
            "",
            "    url = data[\"url\"]",
            "    method = data.get(\"method\", \"HEAD\")",
            "    timeout = 3.0",
            "    valid_ssl = True",
            "    check_status = [status_ranges[\"normal\"]]",
            "    content_type_whitelist = None",
            "    content_type_blacklist = None",
            "",
            "    if \"timeout\" in data:",
            "        try:",
            "            timeout = float(data[\"timeout\"])",
            "        except Exception:",
            "            return make_response(",
            "                \"{!r} is not a valid value for timeout (must be int or float)\".format(",
            "                    data[\"timeout\"]",
            "                ),",
            "                400,",
            "            )",
            "",
            "    if \"validSsl\" in data:",
            "        valid_ssl = data[\"validSsl\"] in valid_boolean_trues",
            "",
            "    if \"status\" in data:",
            "        request_status = data[\"status\"]",
            "        if not isinstance(request_status, list):",
            "            request_status = [request_status]",
            "",
            "        check_status = []",
            "        for rs in request_status:",
            "            if isinstance(rs, int):",
            "                check_status.append([rs])",
            "            else:",
            "                if rs in status_ranges:",
            "                    check_status.append(status_ranges[rs])",
            "                else:",
            "                    code = requests.codes[rs]",
            "                    if code is not None:",
            "                        check_status.append([code])",
            "",
            "    if \"content_type_whitelist\" in data:",
            "        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):",
            "            return make_response(\"content_type_whitelist must be a list of mime types\")",
            "        content_type_whitelist = list(",
            "            map(util.parse_mime_type, data[\"content_type_whitelist\"])",
            "        )",
            "    if \"content_type_blacklist\" in data:",
            "        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):",
            "            return make_response(\"content_type_blacklist must be a list of mime types\")",
            "        content_type_blacklist = list(",
            "            map(util.parse_mime_type, data[\"content_type_blacklist\"])",
            "        )",
            "",
            "    response_result = None",
            "    outcome = True",
            "    status = 0",
            "    try:",
            "        with requests.request(",
            "            method=method, url=url, timeout=timeout, verify=valid_ssl, stream=True",
            "        ) as response:",
            "            status = response.status_code",
            "            outcome = outcome and any(map(lambda x: status in x, check_status))",
            "            content_type = response.headers.get(\"content-type\")",
            "",
            "            response_result = {",
            "                \"headers\": dict(response.headers),",
            "                \"content_type\": content_type,",
            "            }",
            "",
            "            if not content_type and data.get(\"content_type_guess\") in valid_boolean_trues:",
            "                content = response.content",
            "                content_type = util.guess_mime_type(bytearray(content))",
            "",
            "            if not content_type:",
            "                content_type = \"application/octet-stream\"",
            "",
            "            response_result = {\"assumed_content_type\": content_type}",
            "",
            "            parsed_content_type = util.parse_mime_type(content_type)",
            "",
            "            in_whitelist = content_type_whitelist is None or any(",
            "                map(",
            "                    lambda x: util.mime_type_matches(parsed_content_type, x),",
            "                    content_type_whitelist,",
            "                )",
            "            )",
            "            in_blacklist = content_type_blacklist is not None and any(",
            "                map(",
            "                    lambda x: util.mime_type_matches(parsed_content_type, x),",
            "                    content_type_blacklist,",
            "                )",
            "            )",
            "",
            "            if not in_whitelist or in_blacklist:",
            "                # we don't support this content type",
            "                response.close()",
            "                outcome = False",
            "",
            "            elif \"response\" in data and (",
            "                data[\"response\"] in valid_boolean_trues",
            "                or data[\"response\"] in (\"json\", \"bytes\")",
            "            ):",
            "                if data[\"response\"] == \"json\":",
            "                    content = response.json()",
            "",
            "                else:",
            "                    import base64",
            "",
            "                    content = base64.standard_b64encode(response.content)",
            "",
            "                response_result[\"content\"] = content",
            "    except Exception:",
            "        logging.getLogger(__name__).exception(",
            "            \"Error while running a test {} request on {}\".format(method, url)",
            "        )",
            "        outcome = False",
            "",
            "    result = {\"url\": url, \"status\": status, \"result\": outcome}",
            "    if response_result:",
            "        result[\"response\"] = response_result",
            "",
            "    return jsonify(**result)",
            "",
            "",
            "def _test_server(data):",
            "    host = data[\"host\"]",
            "    try:",
            "        port = int(data[\"port\"])",
            "    except Exception:",
            "        return make_response(",
            "            \"{!r} is not a valid value for port (must be int)\".format(data[\"port\"]), 400",
            "        )",
            "",
            "    timeout = 3.05",
            "    if \"timeout\" in data:",
            "        try:",
            "            timeout = float(data[\"timeout\"])",
            "        except Exception:",
            "            return make_response(",
            "                \"{!r} is not a valid value for timeout (must be int or float)\".format(",
            "                    data[\"timeout\"]",
            "                ),",
            "                400,",
            "            )",
            "",
            "    protocol = data.get(\"protocol\", \"tcp\")",
            "    if protocol not in (\"tcp\", \"udp\"):",
            "        return make_response(",
            "            \"{!r} is not a valid value for protocol, must be tcp or udp\".format(protocol),",
            "            400,",
            "        )",
            "",
            "    from octoprint.util import server_reachable",
            "",
            "    reachable = server_reachable(host, port, timeout=timeout, proto=protocol)",
            "",
            "    result = {\"host\": host, \"port\": port, \"protocol\": protocol, \"result\": reachable}",
            "",
            "    return jsonify(**result)",
            "",
            "",
            "def _test_resolution(data):",
            "    name = data[\"name\"]",
            "",
            "    from octoprint.util.net import resolve_host",
            "",
            "    resolvable = len(resolve_host(name)) > 0",
            "",
            "    result = {\"name\": name, \"result\": resolvable}",
            "",
            "    return jsonify(**result)",
            "",
            "",
            "def _test_address(data):",
            "    import netaddr",
            "",
            "    from octoprint.util.net import get_lan_ranges, sanitize_address",
            "",
            "    remote_addr = data.get(\"address\")",
            "    if not remote_addr:",
            "        remote_addr = get_remote_address(request)",
            "",
            "    remote_addr = sanitize_address(remote_addr)",
            "    ip = netaddr.IPAddress(remote_addr)",
            "",
            "    lan_subnets = get_lan_ranges()",
            "",
            "    detected_subnet = None",
            "    for subnet in lan_subnets:",
            "        if ip in subnet:",
            "            detected_subnet = subnet",
            "            break",
            "",
            "    result = {",
            "        \"is_lan_address\": detected_subnet is not None,",
            "        \"address\": remote_addr,",
            "    }",
            "",
            "    if detected_subnet is not None:",
            "        result[\"subnet\"] = str(detected_subnet)",
            "",
            "    return jsonify(**result)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "import io",
            "import logging",
            "",
            "from flask import (",
            "    Blueprint,",
            "    abort,",
            "    current_app,",
            "    g,",
            "    jsonify,",
            "    make_response,",
            "    request,",
            "    session,",
            ")",
            "from flask_login import current_user, login_user, logout_user",
            "from werkzeug.exceptions import HTTPException",
            "",
            "import octoprint.access.users",
            "import octoprint.plugin",
            "import octoprint.server",
            "import octoprint.util.net as util_net",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.events import Events, eventManager",
            "from octoprint.server import NO_CONTENT",
            "from octoprint.server.util import (",
            "    corsRequestHandler,",
            "    corsResponseHandler,",
            "    loginFromApiKeyRequestHandler,",
            "    loginFromAuthorizationHeaderRequestHandler,",
            "    noCachingExceptGetResponseHandler,",
            ")",
            "from octoprint.server.util.flask import (",
            "    get_json_command_from_request,",
            "    get_remote_address,",
            "    no_firstrun_access,",
            "    passive_login,",
            ")",
            "from octoprint.settings import settings as s",
            "from octoprint.settings import valid_boolean_trues",
            "from octoprint.vendor.flask_principal import Identity, identity_changed",
            "",
            "# ~~ init api blueprint, including sub modules",
            "",
            "api = Blueprint(\"api\", __name__)",
            "",
            "from . import access as api_access  # noqa: F401,E402",
            "from . import connection as api_connection  # noqa: F401,E402",
            "from . import files as api_files  # noqa: F401,E402",
            "from . import job as api_job  # noqa: F401,E402",
            "from . import languages as api_languages  # noqa: F401,E402",
            "from . import printer as api_printer  # noqa: F401,E402",
            "from . import printer_profiles as api_printer_profiles  # noqa: F401,E402",
            "from . import settings as api_settings  # noqa: F401,E402",
            "from . import slicing as api_slicing  # noqa: F401,E402",
            "from . import system as api_system  # noqa: F401,E402",
            "from . import timelapse as api_timelapse  # noqa: F401,E402",
            "from . import users as api_users  # noqa: F401,E402",
            "",
            "VERSION = \"0.1\"",
            "",
            "api.after_request(noCachingExceptGetResponseHandler)",
            "",
            "api.before_request(corsRequestHandler)",
            "api.before_request(loginFromAuthorizationHeaderRequestHandler)",
            "api.before_request(loginFromApiKeyRequestHandler)",
            "api.after_request(corsResponseHandler)",
            "",
            "# ~~ data from plugins",
            "",
            "",
            "@api.route(\"/plugin/<string:name>\", methods=[\"GET\"])",
            "def pluginData(name):",
            "    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(",
            "        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin",
            "    )",
            "    if not api_plugins:",
            "        return make_response(\"Not found\", 404)",
            "",
            "    if len(api_plugins) > 1:",
            "        return make_response(",
            "            \"More than one api provider registered, can't proceed\",",
            "            500,",
            "        )",
            "",
            "    try:",
            "        api_plugin = api_plugins[0]",
            "        if api_plugin.is_api_adminonly() and not current_user.is_admin:",
            "            return make_response(\"Forbidden\", 403)",
            "",
            "        response = api_plugin.on_api_get(request)",
            "",
            "        if response is not None:",
            "            return response",
            "        return NO_CONTENT",
            "    except HTTPException:",
            "        raise",
            "    except Exception:",
            "        logging.getLogger(__name__).exception(",
            "            \"Error calling SimpleApiPlugin {}\".format(name), extra={\"plugin\": name}",
            "        )",
            "        return abort(500)",
            "",
            "",
            "# ~~ commands for plugins",
            "",
            "",
            "@api.route(\"/plugin/<string:name>\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "def pluginCommand(name):",
            "    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(",
            "        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin",
            "    )",
            "",
            "    if not api_plugins:",
            "        return make_response(\"Not found\", 404)",
            "",
            "    if len(api_plugins) > 1:",
            "        return make_response(",
            "            \"More than one api provider registered, can't proceed\",",
            "            500,",
            "        )",
            "",
            "    api_plugin = api_plugins[0]",
            "    try:",
            "        valid_commands = api_plugin.get_api_commands()",
            "        if valid_commands is None:",
            "            return make_response(\"Method not allowed\", 405)",
            "",
            "        if api_plugin.is_api_adminonly() and not Permissions.ADMIN.can():",
            "            return make_response(\"Forbidden\", 403)",
            "",
            "        command, data, response = get_json_command_from_request(request, valid_commands)",
            "        if response is not None:",
            "            return response",
            "",
            "        response = api_plugin.on_api_command(command, data)",
            "        if response is not None:",
            "            return response",
            "        return NO_CONTENT",
            "    except HTTPException:",
            "        raise",
            "    except Exception:",
            "        logging.getLogger(__name__).exception(",
            "            \"Error while executing SimpleApiPlugin {}\".format(name),",
            "            extra={\"plugin\": name},",
            "        )",
            "        return abort(500)",
            "",
            "",
            "# ~~ first run setup",
            "",
            "",
            "@api.route(\"/setup/wizard\", methods=[\"GET\"])",
            "def wizardState():",
            "    if (",
            "        not s().getBoolean([\"server\", \"firstRun\"])",
            "        and octoprint.server.userManager.has_been_customized()",
            "        and not Permissions.ADMIN.can()",
            "    ):",
            "        abort(403)",
            "",
            "    seen_wizards = s().get([\"server\", \"seenWizards\"])",
            "",
            "    result = {}",
            "    wizard_plugins = octoprint.server.pluginManager.get_implementations(",
            "        octoprint.plugin.WizardPlugin",
            "    )",
            "    for implementation in wizard_plugins:",
            "        name = implementation._identifier",
            "        try:",
            "            required = implementation.is_wizard_required()",
            "            details = implementation.get_wizard_details()",
            "            version = implementation.get_wizard_version()",
            "            ignored = octoprint.plugin.WizardPlugin.is_wizard_ignored(",
            "                seen_wizards, implementation",
            "            )",
            "        except Exception:",
            "            logging.getLogger(__name__).exception(",
            "                \"There was an error fetching wizard \"",
            "                \"details for {}, ignoring\".format(name),",
            "                extra={\"plugin\": name},",
            "            )",
            "        else:",
            "            result[name] = {",
            "                \"required\": required,",
            "                \"details\": details,",
            "                \"version\": version,",
            "                \"ignored\": ignored,",
            "            }",
            "",
            "    return jsonify(result)",
            "",
            "",
            "@api.route(\"/setup/wizard\", methods=[\"POST\"])",
            "def wizardFinish():",
            "    if (",
            "        not s().getBoolean([\"server\", \"firstRun\"])",
            "        and octoprint.server.userManager.has_been_customized()",
            "        and not Permissions.ADMIN.can()",
            "    ):",
            "        abort(403)",
            "",
            "    data = {}",
            "    try:",
            "        data = request.get_json()",
            "    except Exception:",
            "        abort(400)",
            "",
            "    if data is None:",
            "        abort(400)",
            "",
            "    if \"handled\" not in data:",
            "        abort(400)",
            "    handled = data[\"handled\"]",
            "",
            "    if s().getBoolean([\"server\", \"firstRun\"]):",
            "        s().setBoolean([\"server\", \"firstRun\"], False)",
            "",
            "    seen_wizards = dict(s().get([\"server\", \"seenWizards\"]))",
            "",
            "    wizard_plugins = octoprint.server.pluginManager.get_implementations(",
            "        octoprint.plugin.WizardPlugin",
            "    )",
            "    for implementation in wizard_plugins:",
            "        name = implementation._identifier",
            "        try:",
            "            implementation.on_wizard_finish(name in handled)",
            "            if name in handled:",
            "                seen_wizards[name] = implementation.get_wizard_version()",
            "        except Exception:",
            "            logging.getLogger(__name__).exception(",
            "                \"There was an error finishing the \"",
            "                \"wizard for {}, ignoring\".format(name),",
            "                extra={\"plugin\": name},",
            "            )",
            "",
            "    s().set([\"server\", \"seenWizards\"], seen_wizards)",
            "    s().save()",
            "",
            "    return NO_CONTENT",
            "",
            "",
            "# ~~ system state",
            "",
            "",
            "@api.route(\"/state\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "def apiPrinterState():",
            "    return make_response(",
            "        (\"/api/state has been deprecated, use /api/printer instead\", 405, [])",
            "    )",
            "",
            "",
            "@api.route(\"/version\", methods=[\"GET\"])",
            "@Permissions.STATUS.require(403)",
            "def apiVersion():",
            "    return jsonify(",
            "        server=octoprint.server.VERSION,",
            "        api=VERSION,",
            "        text=\"OctoPrint {}\".format(octoprint.server.DISPLAY_VERSION),",
            "    )",
            "",
            "",
            "@api.route(\"/server\", methods=[\"GET\"])",
            "@Permissions.STATUS.require(403)",
            "def serverStatus():",
            "    return jsonify(version=octoprint.server.VERSION, safemode=octoprint.server.safe_mode)",
            "",
            "",
            "# ~~ Login/user handling",
            "",
            "",
            "@api.route(\"/login\", methods=[\"POST\"])",
            "def login():",
            "    data = request.get_json()",
            "    if not data:",
            "        data = request.values",
            "",
            "    if \"user\" in data and \"pass\" in data:",
            "        username = data[\"user\"]",
            "        password = data[\"pass\"]",
            "",
            "        if \"remember\" in data and data[\"remember\"] in valid_boolean_trues:",
            "            remember = True",
            "        else:",
            "            remember = False",
            "",
            "        if \"usersession.id\" in session:",
            "            _logout(current_user)",
            "",
            "        user = octoprint.server.userManager.find_user(username)",
            "        if user is not None:",
            "            if octoprint.server.userManager.check_password(username, password):",
            "                if not user.is_active:",
            "                    return make_response((\"Your account is deactivated\", 403, []))",
            "",
            "                user = octoprint.server.userManager.login_user(user)",
            "                session[\"usersession.id\"] = user.session",
            "                g.user = user",
            "",
            "                login_user(user, remember=remember)",
            "                identity_changed.send(",
            "                    current_app._get_current_object(), identity=Identity(user.get_id())",
            "                )",
            "                session[\"login_mechanism\"] = \"http\"",
            "",
            "                remote_addr = get_remote_address(request)",
            "                logging.getLogger(__name__).info(",
            "                    \"Actively logging in user {} from {}\".format(",
            "                        user.get_id(), remote_addr",
            "                    )",
            "                )",
            "",
            "                response = user.as_dict()",
            "                response[\"_is_external_client\"] = s().getBoolean(",
            "                    [\"server\", \"ipCheck\", \"enabled\"]",
            "                ) and not util_net.is_lan_address(",
            "                    remote_addr,",
            "                    additional_private=s().get([\"server\", \"ipCheck\", \"trustedSubnets\"]),",
            "                )",
            "                response[\"_login_mechanism\"] = session[\"login_mechanism\"]",
            "",
            "                r = make_response(jsonify(response))",
            "                r.delete_cookie(\"active_logout\")",
            "",
            "                eventManager().fire(",
            "                    Events.USER_LOGGED_IN, payload={\"username\": user.get_id()}",
            "                )",
            "",
            "                return r",
            "",
            "        return make_response((\"User unknown or password incorrect\", 403, []))",
            "",
            "    elif \"passive\" in data:",
            "        return passive_login()",
            "",
            "    return make_response(\"Neither user and pass attributes nor passive flag present\", 400)",
            "",
            "",
            "@api.route(\"/logout\", methods=[\"POST\"])",
            "def logout():",
            "    username = None",
            "    if current_user:",
            "        username = current_user.get_id()",
            "",
            "    # logout from user manager...",
            "    _logout(current_user)",
            "",
            "    # ... and from flask login (and principal)",
            "    logout_user()",
            "",
            "    # ... and send an active logout session cookie",
            "    r = make_response(jsonify(octoprint.server.userManager.anonymous_user_factory()))",
            "    r.set_cookie(\"active_logout\", \"true\")",
            "",
            "    if username:",
            "        eventManager().fire(Events.USER_LOGGED_OUT, payload={\"username\": username})",
            "",
            "    return r",
            "",
            "",
            "def _logout(user):",
            "    if \"usersession.id\" in session:",
            "        del session[\"usersession.id\"]",
            "    if \"login_mechanism\" in session:",
            "        del session[\"login_mechanism\"]",
            "    octoprint.server.userManager.logout_user(user)",
            "",
            "",
            "@api.route(\"/currentuser\", methods=[\"GET\"])",
            "def get_current_user():",
            "    return jsonify(",
            "        name=current_user.get_name(),",
            "        permissions=[permission.key for permission in current_user.effective_permissions],",
            "        groups=[group.key for group in current_user.groups],",
            "    )",
            "",
            "",
            "# ~~ Test utils",
            "",
            "",
            "@api.route(\"/util/test\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "@Permissions.ADMIN.require(403)",
            "def utilTest():",
            "    valid_commands = {",
            "        \"path\": [\"path\"],",
            "        \"url\": [\"url\"],",
            "        \"server\": [\"host\", \"port\"],",
            "        \"resolution\": [\"name\"],",
            "        \"address\": [],",
            "    }",
            "",
            "    command, data, response = get_json_command_from_request(request, valid_commands)",
            "    if response is not None:",
            "        return response",
            "",
            "    if command == \"path\":",
            "        return _test_path(data)",
            "    elif command == \"url\":",
            "        return _test_url(data)",
            "    elif command == \"server\":",
            "        return _test_server(data)",
            "    elif command == \"resolution\":",
            "        return _test_resolution(data)",
            "    elif command == \"address\":",
            "        return _test_address(data)",
            "",
            "",
            "def _test_path(data):",
            "    import os",
            "",
            "    from octoprint.util.paths import normalize",
            "",
            "    path = normalize(data[\"path\"], real=False)",
            "    if not path:",
            "        return jsonify(",
            "            path=path,",
            "            exists=False,",
            "            typeok=False,",
            "            broken_symlink=False,",
            "            access=False,",
            "            result=False,",
            "        )",
            "",
            "    unreal_path = path",
            "    path = os.path.realpath(path)",
            "",
            "    check_type = None",
            "    check_access = []",
            "",
            "    if \"check_type\" in data and data[\"check_type\"] in (\"file\", \"dir\"):",
            "        check_type = data[\"check_type\"]",
            "",
            "    if \"check_access\" in data:",
            "        request_check_access = data[\"check_access\"]",
            "        if not isinstance(request_check_access, list):",
            "            request_check_access = list(request_check_access)",
            "",
            "        check_access = [",
            "            check for check in request_check_access if check in (\"r\", \"w\", \"x\")",
            "        ]",
            "",
            "    allow_create_dir = data.get(\"allow_create_dir\", False) and check_type == \"dir\"",
            "    check_writable_dir = data.get(\"check_writable_dir\", False) and check_type == \"dir\"",
            "    if check_writable_dir and \"w\" not in check_access:",
            "        check_access.append(\"w\")",
            "",
            "    # check if path exists",
            "    exists = os.path.exists(path)",
            "    if not exists:",
            "        if os.path.islink(unreal_path):",
            "            # broken symlink, see #2644",
            "            logging.getLogger(__name__).error(",
            "                \"{} is a broken symlink pointing at non existing {}\".format(",
            "                    unreal_path, path",
            "                )",
            "            )",
            "            return jsonify(",
            "                path=unreal_path,",
            "                exists=False,",
            "                typeok=False,",
            "                broken_symlink=True,",
            "                access=False,",
            "                result=False,",
            "            )",
            "",
            "        elif check_type == \"dir\" and allow_create_dir:",
            "            try:",
            "                os.makedirs(path)",
            "            except Exception:",
            "                logging.getLogger(__name__).exception(",
            "                    \"Error while trying to create {}\".format(path)",
            "                )",
            "                return jsonify(",
            "                    path=path,",
            "                    exists=False,",
            "                    typeok=False,",
            "                    broken_symlink=False,",
            "                    access=False,",
            "                    result=False,",
            "                )",
            "            else:",
            "                exists = True",
            "",
            "    # check path type",
            "    type_mapping = {\"file\": os.path.isfile, \"dir\": os.path.isdir}",
            "    if check_type:",
            "        typeok = type_mapping[check_type](path)",
            "    else:",
            "        typeok = exists",
            "",
            "    # check if path allows requested access",
            "    access_mapping = {\"r\": os.R_OK, \"w\": os.W_OK, \"x\": os.X_OK}",
            "    if check_access:",
            "        mode = 0",
            "        for a in map(lambda x: access_mapping[x], check_access):",
            "            mode |= a",
            "        access = os.access(path, mode)",
            "    else:",
            "        access = exists",
            "",
            "    if check_writable_dir and check_type == \"dir\":",
            "        try:",
            "            test_path = os.path.join(path, \".testballoon.txt\")",
            "            with io.open(test_path, \"wb\") as f:",
            "                f.write(b\"Test\")",
            "            os.remove(test_path)",
            "        except Exception:",
            "            logging.getLogger(__name__).exception(",
            "                \"Error while testing if {} is really writable\".format(path)",
            "            )",
            "            return jsonify(",
            "                path=path,",
            "                exists=exists,",
            "                typeok=typeok,",
            "                broken_symlink=False,",
            "                access=False,",
            "                result=False,",
            "            )",
            "",
            "    return jsonify(",
            "        path=path,",
            "        exists=exists,",
            "        typeok=typeok,",
            "        broken_symlink=False,",
            "        access=access,",
            "        result=exists and typeok and access,",
            "    )",
            "",
            "",
            "def _test_url(data):",
            "    import requests",
            "",
            "    from octoprint import util as util",
            "",
            "    class StatusCodeRange(object):",
            "        def __init__(self, start=None, end=None):",
            "            self.start = start",
            "            self.end = end",
            "",
            "        def __contains__(self, item):",
            "            if not isinstance(item, int):",
            "                return False",
            "            if self.start and self.end:",
            "                return self.start <= item < self.end",
            "            elif self.start:",
            "                return self.start <= item",
            "            elif self.end:",
            "                return item < self.end",
            "            else:",
            "                return False",
            "",
            "        def as_dict(self):",
            "            return {\"start\": self.start, \"end\": self.end}",
            "",
            "    status_ranges = {",
            "        \"informational\": StatusCodeRange(start=100, end=200),",
            "        \"success\": StatusCodeRange(start=200, end=300),",
            "        \"redirection\": StatusCodeRange(start=300, end=400),",
            "        \"client_error\": StatusCodeRange(start=400, end=500),",
            "        \"server_error\": StatusCodeRange(start=500, end=600),",
            "        \"normal\": StatusCodeRange(end=400),",
            "        \"error\": StatusCodeRange(start=400, end=600),",
            "        \"any\": StatusCodeRange(start=100),",
            "        \"timeout\": StatusCodeRange(start=0, end=1),",
            "    }",
            "",
            "    url = data[\"url\"]",
            "    method = data.get(\"method\", \"HEAD\")",
            "    timeout = 3.0",
            "    valid_ssl = True",
            "    check_status = [status_ranges[\"normal\"]]",
            "    content_type_whitelist = None",
            "    content_type_blacklist = None",
            "",
            "    if \"timeout\" in data:",
            "        try:",
            "            timeout = float(data[\"timeout\"])",
            "        except Exception:",
            "            return make_response(",
            "                \"Not a valid value for timeout (must be int or float)\",",
            "                400,",
            "            )",
            "",
            "    if \"validSsl\" in data:",
            "        valid_ssl = data[\"validSsl\"] in valid_boolean_trues",
            "",
            "    if \"status\" in data:",
            "        request_status = data[\"status\"]",
            "        if not isinstance(request_status, list):",
            "            request_status = [request_status]",
            "",
            "        check_status = []",
            "        for rs in request_status:",
            "            if isinstance(rs, int):",
            "                check_status.append([rs])",
            "            else:",
            "                if rs in status_ranges:",
            "                    check_status.append(status_ranges[rs])",
            "                else:",
            "                    code = requests.codes[rs]",
            "                    if code is not None:",
            "                        check_status.append([code])",
            "",
            "    if \"content_type_whitelist\" in data:",
            "        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):",
            "            return make_response(\"content_type_whitelist must be a list of mime types\")",
            "        content_type_whitelist = list(",
            "            map(util.parse_mime_type, data[\"content_type_whitelist\"])",
            "        )",
            "    if \"content_type_blacklist\" in data:",
            "        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):",
            "            return make_response(\"content_type_blacklist must be a list of mime types\")",
            "        content_type_blacklist = list(",
            "            map(util.parse_mime_type, data[\"content_type_blacklist\"])",
            "        )",
            "",
            "    response_result = None",
            "    outcome = True",
            "    status = 0",
            "    try:",
            "        with requests.request(",
            "            method=method, url=url, timeout=timeout, verify=valid_ssl, stream=True",
            "        ) as response:",
            "            status = response.status_code",
            "            outcome = outcome and any(map(lambda x: status in x, check_status))",
            "            content_type = response.headers.get(\"content-type\")",
            "",
            "            response_result = {",
            "                \"headers\": dict(response.headers),",
            "                \"content_type\": content_type,",
            "            }",
            "",
            "            if not content_type and data.get(\"content_type_guess\") in valid_boolean_trues:",
            "                content = response.content",
            "                content_type = util.guess_mime_type(bytearray(content))",
            "",
            "            if not content_type:",
            "                content_type = \"application/octet-stream\"",
            "",
            "            response_result = {\"assumed_content_type\": content_type}",
            "",
            "            parsed_content_type = util.parse_mime_type(content_type)",
            "",
            "            in_whitelist = content_type_whitelist is None or any(",
            "                map(",
            "                    lambda x: util.mime_type_matches(parsed_content_type, x),",
            "                    content_type_whitelist,",
            "                )",
            "            )",
            "            in_blacklist = content_type_blacklist is not None and any(",
            "                map(",
            "                    lambda x: util.mime_type_matches(parsed_content_type, x),",
            "                    content_type_blacklist,",
            "                )",
            "            )",
            "",
            "            if not in_whitelist or in_blacklist:",
            "                # we don't support this content type",
            "                response.close()",
            "                outcome = False",
            "",
            "            elif \"response\" in data and (",
            "                data[\"response\"] in valid_boolean_trues",
            "                or data[\"response\"] in (\"json\", \"bytes\")",
            "            ):",
            "                if data[\"response\"] == \"json\":",
            "                    content = response.json()",
            "",
            "                else:",
            "                    import base64",
            "",
            "                    content = base64.standard_b64encode(response.content)",
            "",
            "                response_result[\"content\"] = content",
            "    except Exception:",
            "        logging.getLogger(__name__).exception(",
            "            \"Error while running a test {} request on {}\".format(method, url)",
            "        )",
            "        outcome = False",
            "",
            "    result = {\"url\": url, \"status\": status, \"result\": outcome}",
            "    if response_result:",
            "        result[\"response\"] = response_result",
            "",
            "    return jsonify(**result)",
            "",
            "",
            "def _test_server(data):",
            "    host = data[\"host\"]",
            "    try:",
            "        port = int(data[\"port\"])",
            "    except Exception:",
            "        return make_response(\"Not a valid value for port (must be int)\", 400)",
            "",
            "    timeout = 3.05",
            "    if \"timeout\" in data:",
            "        try:",
            "            timeout = float(data[\"timeout\"])",
            "        except Exception:",
            "            return make_response(",
            "                \"Not a valid value for timeout (must be int or float)\",",
            "                400,",
            "            )",
            "",
            "    protocol = data.get(\"protocol\", \"tcp\")",
            "    if protocol not in (\"tcp\", \"udp\"):",
            "        return make_response(",
            "            \"Not a valid value for protocol, must be tcp or udp\",",
            "            400,",
            "        )",
            "",
            "    from octoprint.util import server_reachable",
            "",
            "    reachable = server_reachable(host, port, timeout=timeout, proto=protocol)",
            "",
            "    result = {\"host\": host, \"port\": port, \"protocol\": protocol, \"result\": reachable}",
            "",
            "    return jsonify(**result)",
            "",
            "",
            "def _test_resolution(data):",
            "    name = data[\"name\"]",
            "",
            "    from octoprint.util.net import resolve_host",
            "",
            "    resolvable = len(resolve_host(name)) > 0",
            "",
            "    result = {\"name\": name, \"result\": resolvable}",
            "",
            "    return jsonify(**result)",
            "",
            "",
            "def _test_address(data):",
            "    import netaddr",
            "",
            "    from octoprint.util.net import get_lan_ranges, sanitize_address",
            "",
            "    remote_addr = data.get(\"address\")",
            "    if not remote_addr:",
            "        remote_addr = get_remote_address(request)",
            "",
            "    remote_addr = sanitize_address(remote_addr)",
            "    ip = netaddr.IPAddress(remote_addr)",
            "",
            "    lan_subnets = get_lan_ranges()",
            "",
            "    detected_subnet = None",
            "    for subnet in lan_subnets:",
            "        if ip in subnet:",
            "            detected_subnet = subnet",
            "            break",
            "",
            "    result = {",
            "        \"is_lan_address\": detected_subnet is not None,",
            "        \"address\": remote_addr,",
            "    }",
            "",
            "    if detected_subnet is not None:",
            "        result[\"subnet\"] = str(detected_subnet)",
            "",
            "    return jsonify(**result)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "87": [
                "pluginData"
            ],
            "88": [
                "pluginData"
            ],
            "89": [
                "pluginData"
            ],
            "127": [
                "pluginCommand"
            ],
            "128": [
                "pluginCommand"
            ],
            "129": [
                "pluginCommand"
            ],
            "592": [
                "_test_url"
            ],
            "593": [
                "_test_url"
            ],
            "594": [
                "_test_url"
            ],
            "707": [
                "_test_server"
            ],
            "708": [
                "_test_server"
            ],
            "709": [
                "_test_server"
            ],
            "717": [
                "_test_server"
            ],
            "718": [
                "_test_server"
            ],
            "719": [
                "_test_server"
            ],
            "726": [
                "_test_server"
            ]
        },
        "addLocation": []
    },
    "src/octoprint/server/api/access.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "         try:"
            },
            "1": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "             userManager.change_user_password(username, data[\"password\"])"
            },
            "2": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         except users.UnknownUser:"
            },
            "3": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return make_response((\"Unknown user: %s\" % username, 404, []))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+            return make_response((\"Unknown user\", 404, []))"
            },
            "5": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "         return jsonify(SUCCESS)"
            },
            "7": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "     else:"
            },
            "8": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "     try:"
            },
            "9": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "         return jsonify(userManager.get_all_user_settings(username))"
            },
            "10": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "     except users.UnknownUser:"
            },
            "11": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return make_response(\"Unknown user: %s\" % username, 404)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+        return make_response(\"Unknown user\", 404)"
            },
            "13": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 304,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 305,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 306,
                "PatchRowcode": " @api.route(\"/access/users/<username>/settings\", methods=[\"PATCH\"])"
            },
            "16": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "         userManager.change_user_settings(username, data)"
            },
            "17": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "         return jsonify(SUCCESS)"
            },
            "18": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "     except users.UnknownUser:"
            },
            "19": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return make_response(\"Unknown user: %s\" % username, 404)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+        return make_response(\"Unknown user\", 404)"
            },
            "21": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 332,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 333,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 334,
                "PatchRowcode": " @api.route(\"/access/users/<username>/apikey\", methods=[\"DELETE\"])"
            },
            "24": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "         try:"
            },
            "25": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "             userManager.delete_api_key(username)"
            },
            "26": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "         except users.UnknownUser:"
            },
            "27": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return make_response((\"Unknown user: %s\" % username, 404, []))"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+            return make_response((\"Unknown user\", 404, []))"
            },
            "29": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "         return jsonify(SUCCESS)"
            },
            "30": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "     else:"
            },
            "31": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "         return make_response((\"Forbidden\", 403, []))"
            },
            "32": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "         try:"
            },
            "33": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "             apikey = userManager.generate_api_key(username)"
            },
            "34": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "         except users.UnknownUser:"
            },
            "35": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return make_response((\"Unknown user: %s\" % username, 404, []))"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+            return make_response((\"Unknown user\", 404, []))"
            },
            "37": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "         return jsonify({\"apikey\": apikey})"
            },
            "38": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "     else:"
            },
            "39": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "         return make_response((\"Forbidden\", 403, []))"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__author__ = \"Marc Hannappel <salandora@gmail.com>\"",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2017 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "from flask import abort, jsonify, make_response, request",
            "from flask_login import current_user",
            "from werkzeug.exceptions import BadRequest",
            "",
            "import octoprint.access.groups as groups",
            "import octoprint.access.users as users",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.server import SUCCESS, groupManager, userManager",
            "from octoprint.server.api import api, valid_boolean_trues",
            "from octoprint.server.util.flask import no_firstrun_access",
            "",
            "# ~~ permission api",
            "",
            "",
            "@api.route(\"/access/permissions\", methods=[\"GET\"])",
            "def get_permissions():",
            "    return jsonify(permissions=[permission.as_dict() for permission in Permissions.all()])",
            "",
            "",
            "# ~~ group api",
            "",
            "",
            "@api.route(\"/access/groups\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def get_groups():",
            "    return jsonify(groups=list(map(lambda g: g.as_dict(), groupManager.groups)))",
            "",
            "",
            "@api.route(\"/access/groups\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def add_group():",
            "    if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "        return make_response(\"Expected content-type JSON\", 400)",
            "",
            "    try:",
            "        data = request.get_json()",
            "    except BadRequest:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    if \"key\" not in data:",
            "        return make_response(\"Missing mandatory key field\", 400)",
            "    if \"name\" not in data:",
            "        return make_response(\"Missing mandatory name field\", 400)",
            "    if \"permissions\" not in data:",
            "        return make_response(\"Missing mandatory permissions field\", 400)",
            "",
            "    key = data[\"key\"]",
            "    name = data[\"name\"]",
            "    description = data.get(\"description\", \"\")",
            "    permissions = data[\"permissions\"]",
            "    subgroups = data[\"subgroups\"]",
            "    default = data.get(\"default\", False)",
            "",
            "    try:",
            "        groupManager.add_group(",
            "            key,",
            "            name,",
            "            description=description,",
            "            permissions=permissions,",
            "            subgroups=subgroups,",
            "            default=default,",
            "        )",
            "    except groups.GroupAlreadyExists:",
            "        abort(409)",
            "    return get_groups()",
            "",
            "",
            "@api.route(\"/access/groups/<key>\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def get_group(key):",
            "    group = groupManager.find_group(key)",
            "    if group is not None:",
            "        return jsonify(group)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@api.route(\"/access/groups/<key>\", methods=[\"PUT\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def update_group(key):",
            "    if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "        return make_response(\"Expected content-type JSON\", 400)",
            "",
            "    try:",
            "        data = request.get_json()",
            "    except BadRequest:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    try:",
            "        kwargs = {}",
            "",
            "        if \"permissions\" in data:",
            "            kwargs[\"permissions\"] = data[\"permissions\"]",
            "",
            "        if \"subgroups\" in data:",
            "            kwargs[\"subgroups\"] = data[\"subgroups\"]",
            "",
            "        if \"default\" in data:",
            "            kwargs[\"default\"] = data[\"default\"] in valid_boolean_trues",
            "",
            "        if \"description\" in data:",
            "            kwargs[\"description\"] = data[\"description\"]",
            "",
            "        groupManager.update_group(key, **kwargs)",
            "",
            "        return get_groups()",
            "    except groups.GroupCantBeChanged:",
            "        abort(403)",
            "    except groups.UnknownGroup:",
            "        abort(404)",
            "",
            "",
            "@api.route(\"/access/groups/<key>\", methods=[\"DELETE\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def remove_group(key):",
            "    try:",
            "        groupManager.remove_group(key)",
            "        return get_groups()",
            "    except groups.UnknownGroup:",
            "        abort(404)",
            "    except groups.GroupUnremovable:",
            "        abort(403)",
            "",
            "",
            "# ~~ user api",
            "",
            "",
            "@api.route(\"/access/users\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def get_users():",
            "    return jsonify(users=list(map(lambda u: u.as_dict(), userManager.get_all_users())))",
            "",
            "",
            "@api.route(\"/access/users\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def add_user():",
            "    if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "        return make_response(\"Expected content-type JSON\", 400)",
            "",
            "    try:",
            "        data = request.get_json()",
            "    except BadRequest:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    if data is None:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    if \"name\" not in data:",
            "        return make_response(\"Missing mandatory name field\", 400)",
            "    if \"password\" not in data:",
            "        return make_response(\"Missing mandatory password field\", 400)",
            "    if \"active\" not in data:",
            "        return make_response(\"Missing mandatory active field\", 400)",
            "",
            "    name = data[\"name\"]",
            "    password = data[\"password\"]",
            "    active = data[\"active\"] in valid_boolean_trues",
            "",
            "    groups = data.get(\"groups\", None)",
            "    permissions = data.get(\"permissions\", None)",
            "",
            "    try:",
            "        userManager.add_user(name, password, active, permissions, groups)",
            "    except users.UserAlreadyExists:",
            "        abort(409)",
            "    return get_users()",
            "",
            "",
            "@api.route(\"/access/users/<username>\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "def get_user(username):",
            "    if (",
            "        current_user is not None",
            "        and not current_user.is_anonymous",
            "        and (",
            "            current_user.get_name() == username",
            "            or current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        user = userManager.find_user(username)",
            "        if user is not None:",
            "            return jsonify(user)",
            "        else:",
            "            abort(404)",
            "    else:",
            "        abort(403)",
            "",
            "",
            "@api.route(\"/access/users/<username>\", methods=[\"PUT\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def update_user(username):",
            "    user = userManager.find_user(username)",
            "    if user is not None:",
            "        if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "            return make_response(\"Expected content-type JSON\", 400)",
            "",
            "        try:",
            "            data = request.get_json()",
            "        except BadRequest:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        # change groups",
            "        if \"groups\" in data:",
            "            groups = data[\"groups\"]",
            "            userManager.change_user_groups(username, groups)",
            "",
            "        # change permissions",
            "        if \"permissions\" in data:",
            "            permissions = data[\"permissions\"]",
            "            userManager.change_user_permissions(username, permissions)",
            "",
            "        if data is None:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        # change activation",
            "        if \"active\" in data:",
            "            userManager.change_user_activation(",
            "                username, data[\"active\"] in valid_boolean_trues",
            "            )",
            "",
            "        return get_users()",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@api.route(\"/access/users/<username>\", methods=[\"DELETE\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def remove_user(username):",
            "    try:",
            "        userManager.remove_user(username)",
            "        return get_users()",
            "    except users.UnknownUser:",
            "        abort(404)",
            "",
            "",
            "@api.route(\"/access/users/<username>/password\", methods=[\"PUT\"])",
            "@no_firstrun_access",
            "def change_password_for_user(username):",
            "    if not userManager.enabled:",
            "        return jsonify(SUCCESS)",
            "",
            "    if (",
            "        current_user is not None",
            "        and not current_user.is_anonymous",
            "        and (current_user.get_name() == username or current_user.is_admin)",
            "    ):",
            "        if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "            return make_response(\"Expected content-type JSON\", 400)",
            "",
            "        try:",
            "            data = request.get_json()",
            "        except BadRequest:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        if data is None:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        if \"password\" not in data or not data[\"password\"]:",
            "            return make_response(\"password is missing from request\", 400)",
            "",
            "        try:",
            "            userManager.change_user_password(username, data[\"password\"])",
            "        except users.UnknownUser:",
            "            return make_response((\"Unknown user: %s\" % username, 404, []))",
            "",
            "        return jsonify(SUCCESS)",
            "    else:",
            "        return make_response((\"Forbidden\", 403, []))",
            "",
            "",
            "@api.route(\"/access/users/<username>/settings\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "def get_settings_for_user(username):",
            "    if (",
            "        current_user is None",
            "        or current_user.is_anonymous",
            "        or (",
            "            current_user.get_name() != username",
            "            and not current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        return make_response(\"Forbidden\", 403)",
            "",
            "    try:",
            "        return jsonify(userManager.get_all_user_settings(username))",
            "    except users.UnknownUser:",
            "        return make_response(\"Unknown user: %s\" % username, 404)",
            "",
            "",
            "@api.route(\"/access/users/<username>/settings\", methods=[\"PATCH\"])",
            "@no_firstrun_access",
            "def change_settings_for_user(username):",
            "    if (",
            "        current_user is None",
            "        or current_user.is_anonymous",
            "        or (",
            "            current_user.get_name() != username",
            "            and not current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        return make_response(\"Forbidden\", 403)",
            "",
            "    try:",
            "        data = request.get_json()",
            "    except BadRequest:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    if data is None:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    try:",
            "        userManager.change_user_settings(username, data)",
            "        return jsonify(SUCCESS)",
            "    except users.UnknownUser:",
            "        return make_response(\"Unknown user: %s\" % username, 404)",
            "",
            "",
            "@api.route(\"/access/users/<username>/apikey\", methods=[\"DELETE\"])",
            "@no_firstrun_access",
            "def delete_apikey_for_user(username):",
            "    if (",
            "        current_user is not None",
            "        and not current_user.is_anonymous",
            "        and (",
            "            current_user.get_name() == username",
            "            or current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        try:",
            "            userManager.delete_api_key(username)",
            "        except users.UnknownUser:",
            "            return make_response((\"Unknown user: %s\" % username, 404, []))",
            "        return jsonify(SUCCESS)",
            "    else:",
            "        return make_response((\"Forbidden\", 403, []))",
            "",
            "",
            "@api.route(\"/access/users/<username>/apikey\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "def generate_apikey_for_user(username):",
            "    if not userManager.enabled:",
            "        return jsonify(SUCCESS)",
            "",
            "    if (",
            "        current_user is not None",
            "        and not current_user.is_anonymous",
            "        and (",
            "            current_user.get_name() == username",
            "            or current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        try:",
            "            apikey = userManager.generate_api_key(username)",
            "        except users.UnknownUser:",
            "            return make_response((\"Unknown user: %s\" % username, 404, []))",
            "        return jsonify({\"apikey\": apikey})",
            "    else:",
            "        return make_response((\"Forbidden\", 403, []))",
            "",
            "",
            "def _to_external_permissions(*permissions):",
            "    return list(map(lambda p: p.get_name(), permissions))",
            "",
            "",
            "def _to_external_groups(*groups):",
            "    return list(map(lambda g: g.get_name(), groups))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__author__ = \"Marc Hannappel <salandora@gmail.com>\"",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2017 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "from flask import abort, jsonify, make_response, request",
            "from flask_login import current_user",
            "from werkzeug.exceptions import BadRequest",
            "",
            "import octoprint.access.groups as groups",
            "import octoprint.access.users as users",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.server import SUCCESS, groupManager, userManager",
            "from octoprint.server.api import api, valid_boolean_trues",
            "from octoprint.server.util.flask import no_firstrun_access",
            "",
            "# ~~ permission api",
            "",
            "",
            "@api.route(\"/access/permissions\", methods=[\"GET\"])",
            "def get_permissions():",
            "    return jsonify(permissions=[permission.as_dict() for permission in Permissions.all()])",
            "",
            "",
            "# ~~ group api",
            "",
            "",
            "@api.route(\"/access/groups\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def get_groups():",
            "    return jsonify(groups=list(map(lambda g: g.as_dict(), groupManager.groups)))",
            "",
            "",
            "@api.route(\"/access/groups\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def add_group():",
            "    if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "        return make_response(\"Expected content-type JSON\", 400)",
            "",
            "    try:",
            "        data = request.get_json()",
            "    except BadRequest:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    if \"key\" not in data:",
            "        return make_response(\"Missing mandatory key field\", 400)",
            "    if \"name\" not in data:",
            "        return make_response(\"Missing mandatory name field\", 400)",
            "    if \"permissions\" not in data:",
            "        return make_response(\"Missing mandatory permissions field\", 400)",
            "",
            "    key = data[\"key\"]",
            "    name = data[\"name\"]",
            "    description = data.get(\"description\", \"\")",
            "    permissions = data[\"permissions\"]",
            "    subgroups = data[\"subgroups\"]",
            "    default = data.get(\"default\", False)",
            "",
            "    try:",
            "        groupManager.add_group(",
            "            key,",
            "            name,",
            "            description=description,",
            "            permissions=permissions,",
            "            subgroups=subgroups,",
            "            default=default,",
            "        )",
            "    except groups.GroupAlreadyExists:",
            "        abort(409)",
            "    return get_groups()",
            "",
            "",
            "@api.route(\"/access/groups/<key>\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def get_group(key):",
            "    group = groupManager.find_group(key)",
            "    if group is not None:",
            "        return jsonify(group)",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@api.route(\"/access/groups/<key>\", methods=[\"PUT\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def update_group(key):",
            "    if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "        return make_response(\"Expected content-type JSON\", 400)",
            "",
            "    try:",
            "        data = request.get_json()",
            "    except BadRequest:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    try:",
            "        kwargs = {}",
            "",
            "        if \"permissions\" in data:",
            "            kwargs[\"permissions\"] = data[\"permissions\"]",
            "",
            "        if \"subgroups\" in data:",
            "            kwargs[\"subgroups\"] = data[\"subgroups\"]",
            "",
            "        if \"default\" in data:",
            "            kwargs[\"default\"] = data[\"default\"] in valid_boolean_trues",
            "",
            "        if \"description\" in data:",
            "            kwargs[\"description\"] = data[\"description\"]",
            "",
            "        groupManager.update_group(key, **kwargs)",
            "",
            "        return get_groups()",
            "    except groups.GroupCantBeChanged:",
            "        abort(403)",
            "    except groups.UnknownGroup:",
            "        abort(404)",
            "",
            "",
            "@api.route(\"/access/groups/<key>\", methods=[\"DELETE\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def remove_group(key):",
            "    try:",
            "        groupManager.remove_group(key)",
            "        return get_groups()",
            "    except groups.UnknownGroup:",
            "        abort(404)",
            "    except groups.GroupUnremovable:",
            "        abort(403)",
            "",
            "",
            "# ~~ user api",
            "",
            "",
            "@api.route(\"/access/users\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def get_users():",
            "    return jsonify(users=list(map(lambda u: u.as_dict(), userManager.get_all_users())))",
            "",
            "",
            "@api.route(\"/access/users\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def add_user():",
            "    if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "        return make_response(\"Expected content-type JSON\", 400)",
            "",
            "    try:",
            "        data = request.get_json()",
            "    except BadRequest:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    if data is None:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    if \"name\" not in data:",
            "        return make_response(\"Missing mandatory name field\", 400)",
            "    if \"password\" not in data:",
            "        return make_response(\"Missing mandatory password field\", 400)",
            "    if \"active\" not in data:",
            "        return make_response(\"Missing mandatory active field\", 400)",
            "",
            "    name = data[\"name\"]",
            "    password = data[\"password\"]",
            "    active = data[\"active\"] in valid_boolean_trues",
            "",
            "    groups = data.get(\"groups\", None)",
            "    permissions = data.get(\"permissions\", None)",
            "",
            "    try:",
            "        userManager.add_user(name, password, active, permissions, groups)",
            "    except users.UserAlreadyExists:",
            "        abort(409)",
            "    return get_users()",
            "",
            "",
            "@api.route(\"/access/users/<username>\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "def get_user(username):",
            "    if (",
            "        current_user is not None",
            "        and not current_user.is_anonymous",
            "        and (",
            "            current_user.get_name() == username",
            "            or current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        user = userManager.find_user(username)",
            "        if user is not None:",
            "            return jsonify(user)",
            "        else:",
            "            abort(404)",
            "    else:",
            "        abort(403)",
            "",
            "",
            "@api.route(\"/access/users/<username>\", methods=[\"PUT\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def update_user(username):",
            "    user = userManager.find_user(username)",
            "    if user is not None:",
            "        if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "            return make_response(\"Expected content-type JSON\", 400)",
            "",
            "        try:",
            "            data = request.get_json()",
            "        except BadRequest:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        # change groups",
            "        if \"groups\" in data:",
            "            groups = data[\"groups\"]",
            "            userManager.change_user_groups(username, groups)",
            "",
            "        # change permissions",
            "        if \"permissions\" in data:",
            "            permissions = data[\"permissions\"]",
            "            userManager.change_user_permissions(username, permissions)",
            "",
            "        if data is None:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        # change activation",
            "        if \"active\" in data:",
            "            userManager.change_user_activation(",
            "                username, data[\"active\"] in valid_boolean_trues",
            "            )",
            "",
            "        return get_users()",
            "    else:",
            "        abort(404)",
            "",
            "",
            "@api.route(\"/access/users/<username>\", methods=[\"DELETE\"])",
            "@no_firstrun_access",
            "@Permissions.SETTINGS.require(403)",
            "def remove_user(username):",
            "    try:",
            "        userManager.remove_user(username)",
            "        return get_users()",
            "    except users.UnknownUser:",
            "        abort(404)",
            "",
            "",
            "@api.route(\"/access/users/<username>/password\", methods=[\"PUT\"])",
            "@no_firstrun_access",
            "def change_password_for_user(username):",
            "    if not userManager.enabled:",
            "        return jsonify(SUCCESS)",
            "",
            "    if (",
            "        current_user is not None",
            "        and not current_user.is_anonymous",
            "        and (current_user.get_name() == username or current_user.is_admin)",
            "    ):",
            "        if \"application/json\" not in request.headers[\"Content-Type\"]:",
            "            return make_response(\"Expected content-type JSON\", 400)",
            "",
            "        try:",
            "            data = request.get_json()",
            "        except BadRequest:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        if data is None:",
            "            return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "        if \"password\" not in data or not data[\"password\"]:",
            "            return make_response(\"password is missing from request\", 400)",
            "",
            "        try:",
            "            userManager.change_user_password(username, data[\"password\"])",
            "        except users.UnknownUser:",
            "            return make_response((\"Unknown user\", 404, []))",
            "",
            "        return jsonify(SUCCESS)",
            "    else:",
            "        return make_response((\"Forbidden\", 403, []))",
            "",
            "",
            "@api.route(\"/access/users/<username>/settings\", methods=[\"GET\"])",
            "@no_firstrun_access",
            "def get_settings_for_user(username):",
            "    if (",
            "        current_user is None",
            "        or current_user.is_anonymous",
            "        or (",
            "            current_user.get_name() != username",
            "            and not current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        return make_response(\"Forbidden\", 403)",
            "",
            "    try:",
            "        return jsonify(userManager.get_all_user_settings(username))",
            "    except users.UnknownUser:",
            "        return make_response(\"Unknown user\", 404)",
            "",
            "",
            "@api.route(\"/access/users/<username>/settings\", methods=[\"PATCH\"])",
            "@no_firstrun_access",
            "def change_settings_for_user(username):",
            "    if (",
            "        current_user is None",
            "        or current_user.is_anonymous",
            "        or (",
            "            current_user.get_name() != username",
            "            and not current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        return make_response(\"Forbidden\", 403)",
            "",
            "    try:",
            "        data = request.get_json()",
            "    except BadRequest:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    if data is None:",
            "        return make_response(\"Malformed JSON body in request\", 400)",
            "",
            "    try:",
            "        userManager.change_user_settings(username, data)",
            "        return jsonify(SUCCESS)",
            "    except users.UnknownUser:",
            "        return make_response(\"Unknown user\", 404)",
            "",
            "",
            "@api.route(\"/access/users/<username>/apikey\", methods=[\"DELETE\"])",
            "@no_firstrun_access",
            "def delete_apikey_for_user(username):",
            "    if (",
            "        current_user is not None",
            "        and not current_user.is_anonymous",
            "        and (",
            "            current_user.get_name() == username",
            "            or current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        try:",
            "            userManager.delete_api_key(username)",
            "        except users.UnknownUser:",
            "            return make_response((\"Unknown user\", 404, []))",
            "        return jsonify(SUCCESS)",
            "    else:",
            "        return make_response((\"Forbidden\", 403, []))",
            "",
            "",
            "@api.route(\"/access/users/<username>/apikey\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "def generate_apikey_for_user(username):",
            "    if not userManager.enabled:",
            "        return jsonify(SUCCESS)",
            "",
            "    if (",
            "        current_user is not None",
            "        and not current_user.is_anonymous",
            "        and (",
            "            current_user.get_name() == username",
            "            or current_user.has_permission(Permissions.ADMIN)",
            "        )",
            "    ):",
            "        try:",
            "            apikey = userManager.generate_api_key(username)",
            "        except users.UnknownUser:",
            "            return make_response((\"Unknown user\", 404, []))",
            "        return jsonify({\"apikey\": apikey})",
            "    else:",
            "        return make_response((\"Forbidden\", 403, []))",
            "",
            "",
            "def _to_external_permissions(*permissions):",
            "    return list(map(lambda p: p.get_name(), permissions))",
            "",
            "",
            "def _to_external_groups(*groups):",
            "    return list(map(lambda g: g.get_name(), groups))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "280": [
                "change_password_for_user"
            ],
            "303": [
                "get_settings_for_user"
            ],
            "331": [
                "change_settings_for_user"
            ],
            "348": [
                "delete_apikey_for_user"
            ],
            "371": [
                "generate_apikey_for_user"
            ]
        },
        "addLocation": []
    },
    "src/octoprint/server/api/connection.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         if \"port\" in data:"
            },
            "1": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             port = data[\"port\"]"
            },
            "2": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             if port not in connection_options[\"ports\"] and port != \"AUTO\":"
            },
            "3": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return make_response(\"Invalid port: %s\" % port, 400)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                return make_response(\"Invalid port\", 400)"
            },
            "5": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         if \"baudrate\" in data:"
            },
            "6": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "             baudrate = data[\"baudrate\"]"
            },
            "7": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             if baudrate not in connection_options[\"baudrates\"] and baudrate != 0:"
            },
            "8": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return make_response(\"Invalid baudrate: %d\" % baudrate, 400)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+                return make_response(\"Invalid baudrate\", 400)"
            },
            "10": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         if \"printerProfile\" in data:"
            },
            "11": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             printerProfile = data[\"printerProfile\"]"
            },
            "12": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             if not printerProfileManager.exists(printerProfile):"
            },
            "13": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return make_response(\"Invalid printer profile: %s\" % printerProfile, 400)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                return make_response(\"Invalid printer profile\", 400)"
            },
            "15": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         if \"save\" in data and data[\"save\"]:"
            },
            "16": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             settings().set([\"serial\", \"port\"], port)"
            },
            "17": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "             settings().setInt([\"serial\", \"baudrate\"], baudrate)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "from flask import jsonify, make_response, request",
            "",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.server import NO_CONTENT, printer, printerProfileManager",
            "from octoprint.server.api import api",
            "from octoprint.server.util.flask import get_json_command_from_request, no_firstrun_access",
            "from octoprint.settings import settings",
            "",
            "",
            "@api.route(\"/connection\", methods=[\"GET\"])",
            "@Permissions.STATUS.require(403)",
            "def connectionState():",
            "    state, port, baudrate, printer_profile = printer.get_current_connection()",
            "    current = {",
            "        \"state\": state,",
            "        \"port\": port,",
            "        \"baudrate\": baudrate,",
            "        \"printerProfile\": printer_profile[\"id\"]",
            "        if printer_profile is not None and \"id\" in printer_profile",
            "        else \"_default\",",
            "    }",
            "",
            "    return jsonify({\"current\": current, \"options\": _get_options()})",
            "",
            "",
            "@api.route(\"/connection\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "@Permissions.CONNECTION.require(403)",
            "def connectionCommand():",
            "    valid_commands = {\"connect\": [], \"disconnect\": [], \"fake_ack\": []}",
            "",
            "    command, data, response = get_json_command_from_request(request, valid_commands)",
            "    if response is not None:",
            "        return response",
            "",
            "    if command == \"connect\":",
            "        connection_options = printer.__class__.get_connection_options()",
            "",
            "        port = None",
            "        baudrate = None",
            "        printerProfile = None",
            "        if \"port\" in data:",
            "            port = data[\"port\"]",
            "            if port not in connection_options[\"ports\"] and port != \"AUTO\":",
            "                return make_response(\"Invalid port: %s\" % port, 400)",
            "        if \"baudrate\" in data:",
            "            baudrate = data[\"baudrate\"]",
            "            if baudrate not in connection_options[\"baudrates\"] and baudrate != 0:",
            "                return make_response(\"Invalid baudrate: %d\" % baudrate, 400)",
            "        if \"printerProfile\" in data:",
            "            printerProfile = data[\"printerProfile\"]",
            "            if not printerProfileManager.exists(printerProfile):",
            "                return make_response(\"Invalid printer profile: %s\" % printerProfile, 400)",
            "        if \"save\" in data and data[\"save\"]:",
            "            settings().set([\"serial\", \"port\"], port)",
            "            settings().setInt([\"serial\", \"baudrate\"], baudrate)",
            "            printerProfileManager.set_default(printerProfile)",
            "        if \"autoconnect\" in data:",
            "            settings().setBoolean([\"serial\", \"autoconnect\"], data[\"autoconnect\"])",
            "        settings().save()",
            "        printer.connect(port=port, baudrate=baudrate, profile=printerProfile)",
            "    elif command == \"disconnect\":",
            "        printer.disconnect()",
            "    elif command == \"fake_ack\":",
            "        printer.fake_ack()",
            "",
            "    return NO_CONTENT",
            "",
            "",
            "def _get_options():",
            "    connection_options = printer.__class__.get_connection_options()",
            "    profile_options = printerProfileManager.get_all()",
            "    default_profile = printerProfileManager.get_default()",
            "",
            "    options = {",
            "        \"ports\": connection_options[\"ports\"],",
            "        \"baudrates\": connection_options[\"baudrates\"],",
            "        \"printerProfiles\": [",
            "            {",
            "                \"id\": printer_profile[\"id\"],",
            "                \"name\": printer_profile[\"name\"]",
            "                if \"name\" in printer_profile",
            "                else printer_profile[\"id\"],",
            "            }",
            "            for printer_profile in profile_options.values()",
            "            if \"id\" in printer_profile",
            "        ],",
            "        \"portPreference\": connection_options[\"portPreference\"],",
            "        \"baudratePreference\": connection_options[\"baudratePreference\"],",
            "        \"printerProfilePreference\": default_profile[\"id\"]",
            "        if \"id\" in default_profile",
            "        else None,",
            "    }",
            "",
            "    return options"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function, unicode_literals",
            "",
            "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"",
            "__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"",
            "__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"",
            "",
            "from flask import jsonify, make_response, request",
            "",
            "from octoprint.access.permissions import Permissions",
            "from octoprint.server import NO_CONTENT, printer, printerProfileManager",
            "from octoprint.server.api import api",
            "from octoprint.server.util.flask import get_json_command_from_request, no_firstrun_access",
            "from octoprint.settings import settings",
            "",
            "",
            "@api.route(\"/connection\", methods=[\"GET\"])",
            "@Permissions.STATUS.require(403)",
            "def connectionState():",
            "    state, port, baudrate, printer_profile = printer.get_current_connection()",
            "    current = {",
            "        \"state\": state,",
            "        \"port\": port,",
            "        \"baudrate\": baudrate,",
            "        \"printerProfile\": printer_profile[\"id\"]",
            "        if printer_profile is not None and \"id\" in printer_profile",
            "        else \"_default\",",
            "    }",
            "",
            "    return jsonify({\"current\": current, \"options\": _get_options()})",
            "",
            "",
            "@api.route(\"/connection\", methods=[\"POST\"])",
            "@no_firstrun_access",
            "@Permissions.CONNECTION.require(403)",
            "def connectionCommand():",
            "    valid_commands = {\"connect\": [], \"disconnect\": [], \"fake_ack\": []}",
            "",
            "    command, data, response = get_json_command_from_request(request, valid_commands)",
            "    if response is not None:",
            "        return response",
            "",
            "    if command == \"connect\":",
            "        connection_options = printer.__class__.get_connection_options()",
            "",
            "        port = None",
            "        baudrate = None",
            "        printerProfile = None",
            "        if \"port\" in data:",
            "            port = data[\"port\"]",
            "            if port not in connection_options[\"ports\"] and port != \"AUTO\":",
            "                return make_response(\"Invalid port\", 400)",
            "        if \"baudrate\" in data:",
            "            baudrate = data[\"baudrate\"]",
            "            if baudrate not in connection_options[\"baudrates\"] and baudrate != 0:",
            "                return make_response(\"Invalid baudrate\", 400)",
            "        if \"printerProfile\" in data:",
            "            printerProfile = data[\"printerProfile\"]",
            "            if not printerProfileManager.exists(printerProfile):",
            "                return make_response(\"Invalid printer profile\", 400)",
            "        if \"save\" in data and data[\"save\"]:",
            "            settings().set([\"serial\", \"port\"], port)",
            "            settings().setInt([\"serial\", \"baudrate\"], baudrate)",
            "            printerProfileManager.set_default(printerProfile)",
            "        if \"autoconnect\" in data:",
            "            settings().setBoolean([\"serial\", \"autoconnect\"], data[\"autoconnect\"])",
            "        settings().save()",
            "        printer.connect(port=port, baudrate=baudrate, profile=printerProfile)",
            "    elif command == \"disconnect\":",
            "        printer.disconnect()",
            "    elif command == \"fake_ack\":",
            "        printer.fake_ack()",
            "",
            "    return NO_CONTENT",
            "",
            "",
            "def _get_options():",
            "    connection_options = printer.__class__.get_connection_options()",
            "    profile_options = printerProfileManager.get_all()",
            "    default_profile = printerProfileManager.get_default()",
            "",
            "    options = {",
            "        \"ports\": connection_options[\"ports\"],",
            "        \"baudrates\": connection_options[\"baudrates\"],",
            "        \"printerProfiles\": [",
            "            {",
            "                \"id\": printer_profile[\"id\"],",
            "                \"name\": printer_profile[\"name\"]",
            "                if \"name\" in printer_profile",
            "                else printer_profile[\"id\"],",
            "            }",
            "            for printer_profile in profile_options.values()",
            "            if \"id\" in printer_profile",
            "        ],",
            "        \"portPreference\": connection_options[\"portPreference\"],",
            "        \"baudratePreference\": connection_options[\"baudratePreference\"],",
            "        \"printerProfilePreference\": default_profile[\"id\"]",
            "        if \"id\" in default_profile",
            "        else None,",
            "    }",
            "",
            "    return options"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "52": [
                "connectionCommand"
            ],
            "56": [
                "connectionCommand"
            ],
            "60": [
                "connectionCommand"
            ]
        },
        "addLocation": []
    }
}