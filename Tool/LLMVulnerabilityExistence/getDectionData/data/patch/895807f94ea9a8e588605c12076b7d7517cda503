{
    "uvicorn/logging.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import http"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import logging"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import sys"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+import urllib"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from copy import copy"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import click"
            },
            "7": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         return \"%s:%d\" % (client[0], client[1])"
            },
            "8": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     def get_path(self, scope):"
            },
            "10": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return scope.get(\"root_path\", \"\") + scope[\"path\"]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        return urllib.parse.quote(scope.get(\"root_path\", \"\") + scope[\"path\"])"
            },
            "12": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     def get_full_path(self, scope):"
            },
            "14": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         path = scope.get(\"root_path\", \"\") + scope[\"path\"]"
            },
            "15": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         query_string = scope.get(\"query_string\", b\"\").decode(\"ascii\")"
            },
            "16": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         if query_string:"
            },
            "17": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return path + \"?\" + query_string"
            },
            "18": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return path"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            return urllib.parse.quote(path) + \"?\" + query_string"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        return urllib.parse.quote(path)"
            },
            "21": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "     def get_status_code(self, record):"
            },
            "23": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         status_code = record.__dict__[\"status_code\"]"
            }
        },
        "frontPatchFile": [
            "import http",
            "import logging",
            "import sys",
            "from copy import copy",
            "",
            "import click",
            "",
            "TRACE_LOG_LEVEL = 5",
            "",
            "",
            "class ColourizedFormatter(logging.Formatter):",
            "    \"\"\"",
            "    A custom log formatter class that:",
            "",
            "    * Outputs the LOG_LEVEL with an appropriate color.",
            "    * If a log call includes an `extras={\"color_message\": ...}` it will be used",
            "      for formatting the output, instead of the plain text message.",
            "    \"\"\"",
            "",
            "    level_name_colors = {",
            "        TRACE_LOG_LEVEL: lambda level_name: click.style(str(level_name), fg=\"blue\"),",
            "        logging.DEBUG: lambda level_name: click.style(str(level_name), fg=\"cyan\"),",
            "        logging.INFO: lambda level_name: click.style(str(level_name), fg=\"green\"),",
            "        logging.WARNING: lambda level_name: click.style(str(level_name), fg=\"yellow\"),",
            "        logging.ERROR: lambda level_name: click.style(str(level_name), fg=\"red\"),",
            "        logging.CRITICAL: lambda level_name: click.style(",
            "            str(level_name), fg=\"bright_red\"",
            "        ),",
            "    }",
            "",
            "    def __init__(self, fmt=None, datefmt=None, style=\"%\", use_colors=None):",
            "        if use_colors in (True, False):",
            "            self.use_colors = use_colors",
            "        else:",
            "            self.use_colors = sys.stdout.isatty()",
            "        super().__init__(fmt=fmt, datefmt=datefmt, style=style)",
            "",
            "    def color_level_name(self, level_name, level_no):",
            "        default = lambda level_name: str(level_name)",
            "        func = self.level_name_colors.get(level_no, default)",
            "        return func(level_name)",
            "",
            "    def should_use_colors(self):",
            "        return True",
            "",
            "    def formatMessage(self, record):",
            "        recordcopy = copy(record)",
            "        levelname = recordcopy.levelname",
            "        seperator = \" \" * (8 - len(recordcopy.levelname))",
            "        if self.use_colors:",
            "            levelname = self.color_level_name(levelname, recordcopy.levelno)",
            "            if \"color_message\" in recordcopy.__dict__:",
            "                recordcopy.msg = recordcopy.__dict__[\"color_message\"]",
            "                recordcopy.__dict__[\"message\"] = recordcopy.getMessage()",
            "        recordcopy.__dict__[\"levelprefix\"] = levelname + \":\" + seperator",
            "        return super().formatMessage(recordcopy)",
            "",
            "",
            "class DefaultFormatter(ColourizedFormatter):",
            "    def should_use_colors(self):",
            "        return sys.stderr.isatty()",
            "",
            "",
            "class AccessFormatter(ColourizedFormatter):",
            "    status_code_colours = {",
            "        1: lambda code: click.style(str(code), fg=\"bright_white\"),",
            "        2: lambda code: click.style(str(code), fg=\"green\"),",
            "        3: lambda code: click.style(str(code), fg=\"yellow\"),",
            "        4: lambda code: click.style(str(code), fg=\"red\"),",
            "        5: lambda code: click.style(str(code), fg=\"bright_red\"),",
            "    }",
            "",
            "    def get_client_addr(self, scope):",
            "        client = scope.get(\"client\")",
            "        if not client:",
            "            return \"\"",
            "        return \"%s:%d\" % (client[0], client[1])",
            "",
            "    def get_path(self, scope):",
            "        return scope.get(\"root_path\", \"\") + scope[\"path\"]",
            "",
            "    def get_full_path(self, scope):",
            "        path = scope.get(\"root_path\", \"\") + scope[\"path\"]",
            "        query_string = scope.get(\"query_string\", b\"\").decode(\"ascii\")",
            "        if query_string:",
            "            return path + \"?\" + query_string",
            "        return path",
            "",
            "    def get_status_code(self, record):",
            "        status_code = record.__dict__[\"status_code\"]",
            "        try:",
            "            status_phrase = http.HTTPStatus(status_code).phrase",
            "        except ValueError:",
            "            status_phrase = \"\"",
            "        status_and_phrase = \"%s %s\" % (status_code, status_phrase)",
            "",
            "        if self.use_colors:",
            "            default = lambda code: status_and_phrase",
            "            func = self.status_code_colours.get(status_code // 100, default)",
            "            return func(status_and_phrase)",
            "        return status_and_phrase",
            "",
            "    def formatMessage(self, record):",
            "        recordcopy = copy(record)",
            "        scope = recordcopy.__dict__[\"scope\"]",
            "        method = scope[\"method\"]",
            "        path = self.get_path(scope)",
            "        full_path = self.get_full_path(scope)",
            "        client_addr = self.get_client_addr(scope)",
            "        status_code = self.get_status_code(recordcopy)",
            "        http_version = scope[\"http_version\"]",
            "        request_line = \"%s %s HTTP/%s\" % (method, full_path, http_version)",
            "        if self.use_colors:",
            "            request_line = click.style(request_line, bold=True)",
            "        recordcopy.__dict__.update(",
            "            {",
            "                \"method\": method,",
            "                \"path\": path,",
            "                \"full_path\": full_path,",
            "                \"client_addr\": client_addr,",
            "                \"request_line\": request_line,",
            "                \"status_code\": status_code,",
            "                \"http_version\": http_version,",
            "            }",
            "        )",
            "        return super().formatMessage(recordcopy)"
        ],
        "afterPatchFile": [
            "import http",
            "import logging",
            "import sys",
            "import urllib",
            "from copy import copy",
            "",
            "import click",
            "",
            "TRACE_LOG_LEVEL = 5",
            "",
            "",
            "class ColourizedFormatter(logging.Formatter):",
            "    \"\"\"",
            "    A custom log formatter class that:",
            "",
            "    * Outputs the LOG_LEVEL with an appropriate color.",
            "    * If a log call includes an `extras={\"color_message\": ...}` it will be used",
            "      for formatting the output, instead of the plain text message.",
            "    \"\"\"",
            "",
            "    level_name_colors = {",
            "        TRACE_LOG_LEVEL: lambda level_name: click.style(str(level_name), fg=\"blue\"),",
            "        logging.DEBUG: lambda level_name: click.style(str(level_name), fg=\"cyan\"),",
            "        logging.INFO: lambda level_name: click.style(str(level_name), fg=\"green\"),",
            "        logging.WARNING: lambda level_name: click.style(str(level_name), fg=\"yellow\"),",
            "        logging.ERROR: lambda level_name: click.style(str(level_name), fg=\"red\"),",
            "        logging.CRITICAL: lambda level_name: click.style(",
            "            str(level_name), fg=\"bright_red\"",
            "        ),",
            "    }",
            "",
            "    def __init__(self, fmt=None, datefmt=None, style=\"%\", use_colors=None):",
            "        if use_colors in (True, False):",
            "            self.use_colors = use_colors",
            "        else:",
            "            self.use_colors = sys.stdout.isatty()",
            "        super().__init__(fmt=fmt, datefmt=datefmt, style=style)",
            "",
            "    def color_level_name(self, level_name, level_no):",
            "        default = lambda level_name: str(level_name)",
            "        func = self.level_name_colors.get(level_no, default)",
            "        return func(level_name)",
            "",
            "    def should_use_colors(self):",
            "        return True",
            "",
            "    def formatMessage(self, record):",
            "        recordcopy = copy(record)",
            "        levelname = recordcopy.levelname",
            "        seperator = \" \" * (8 - len(recordcopy.levelname))",
            "        if self.use_colors:",
            "            levelname = self.color_level_name(levelname, recordcopy.levelno)",
            "            if \"color_message\" in recordcopy.__dict__:",
            "                recordcopy.msg = recordcopy.__dict__[\"color_message\"]",
            "                recordcopy.__dict__[\"message\"] = recordcopy.getMessage()",
            "        recordcopy.__dict__[\"levelprefix\"] = levelname + \":\" + seperator",
            "        return super().formatMessage(recordcopy)",
            "",
            "",
            "class DefaultFormatter(ColourizedFormatter):",
            "    def should_use_colors(self):",
            "        return sys.stderr.isatty()",
            "",
            "",
            "class AccessFormatter(ColourizedFormatter):",
            "    status_code_colours = {",
            "        1: lambda code: click.style(str(code), fg=\"bright_white\"),",
            "        2: lambda code: click.style(str(code), fg=\"green\"),",
            "        3: lambda code: click.style(str(code), fg=\"yellow\"),",
            "        4: lambda code: click.style(str(code), fg=\"red\"),",
            "        5: lambda code: click.style(str(code), fg=\"bright_red\"),",
            "    }",
            "",
            "    def get_client_addr(self, scope):",
            "        client = scope.get(\"client\")",
            "        if not client:",
            "            return \"\"",
            "        return \"%s:%d\" % (client[0], client[1])",
            "",
            "    def get_path(self, scope):",
            "        return urllib.parse.quote(scope.get(\"root_path\", \"\") + scope[\"path\"])",
            "",
            "    def get_full_path(self, scope):",
            "        path = scope.get(\"root_path\", \"\") + scope[\"path\"]",
            "        query_string = scope.get(\"query_string\", b\"\").decode(\"ascii\")",
            "        if query_string:",
            "            return urllib.parse.quote(path) + \"?\" + query_string",
            "        return urllib.parse.quote(path)",
            "",
            "    def get_status_code(self, record):",
            "        status_code = record.__dict__[\"status_code\"]",
            "        try:",
            "            status_phrase = http.HTTPStatus(status_code).phrase",
            "        except ValueError:",
            "            status_phrase = \"\"",
            "        status_and_phrase = \"%s %s\" % (status_code, status_phrase)",
            "",
            "        if self.use_colors:",
            "            default = lambda code: status_and_phrase",
            "            func = self.status_code_colours.get(status_code // 100, default)",
            "            return func(status_and_phrase)",
            "        return status_and_phrase",
            "",
            "    def formatMessage(self, record):",
            "        recordcopy = copy(record)",
            "        scope = recordcopy.__dict__[\"scope\"]",
            "        method = scope[\"method\"]",
            "        path = self.get_path(scope)",
            "        full_path = self.get_full_path(scope)",
            "        client_addr = self.get_client_addr(scope)",
            "        status_code = self.get_status_code(recordcopy)",
            "        http_version = scope[\"http_version\"]",
            "        request_line = \"%s %s HTTP/%s\" % (method, full_path, http_version)",
            "        if self.use_colors:",
            "            request_line = click.style(request_line, bold=True)",
            "        recordcopy.__dict__.update(",
            "            {",
            "                \"method\": method,",
            "                \"path\": path,",
            "                \"full_path\": full_path,",
            "                \"client_addr\": client_addr,",
            "                \"request_line\": request_line,",
            "                \"status_code\": status_code,",
            "                \"http_version\": http_version,",
            "            }",
            "        )",
            "        return super().formatMessage(recordcopy)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "80": [
                "AccessFormatter",
                "get_path"
            ],
            "86": [
                "AccessFormatter",
                "get_full_path"
            ],
            "87": [
                "AccessFormatter",
                "get_full_path"
            ]
        },
        "addLocation": []
    },
    "uvicorn/protocols/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import socket"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import urllib"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " def get_remote_addr(transport):"
            },
            "5": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " def get_path_with_query_string(scope):"
            },
            "8": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    path_with_query_string = scope.get(\"root_path\", \"\") + scope[\"path\"]"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    path_with_query_string = urllib.parse.quote("
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        scope.get(\"root_path\", \"\") + scope[\"path\"]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    )"
            },
            "12": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     if scope[\"query_string\"]:"
            },
            "13": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         path_with_query_string = \"{}?{}\".format("
            },
            "14": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             path_with_query_string, scope[\"query_string\"].decode(\"ascii\")"
            }
        },
        "frontPatchFile": [
            "import socket",
            "",
            "",
            "def get_remote_addr(transport):",
            "    socket_info = transport.get_extra_info(\"socket\")",
            "    if socket_info is not None:",
            "        try:",
            "            info = socket_info.getpeername()",
            "        except OSError:",
            "            # This case appears to inconsistently occur with uvloop",
            "            # bound to a unix domain socket.",
            "            family = None",
            "            info = None",
            "        else:",
            "            family = socket_info.family",
            "",
            "        if family in (socket.AF_INET, socket.AF_INET6):",
            "            return (str(info[0]), int(info[1]))",
            "        return None",
            "    info = transport.get_extra_info(\"peername\")",
            "    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:",
            "        return (str(info[0]), int(info[1]))",
            "    return None",
            "",
            "",
            "def get_local_addr(transport):",
            "    socket_info = transport.get_extra_info(\"socket\")",
            "    if socket_info is not None:",
            "        info = socket_info.getsockname()",
            "        family = socket_info.family",
            "        if family in (socket.AF_INET, socket.AF_INET6):",
            "            return (str(info[0]), int(info[1]))",
            "        return None",
            "    info = transport.get_extra_info(\"sockname\")",
            "    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:",
            "        return (str(info[0]), int(info[1]))",
            "    return None",
            "",
            "",
            "def is_ssl(transport):",
            "    return bool(transport.get_extra_info(\"sslcontext\"))",
            "",
            "",
            "def get_client_addr(scope):",
            "    client = scope.get(\"client\")",
            "    if not client:",
            "        return \"\"",
            "    return \"%s:%d\" % client",
            "",
            "",
            "def get_path_with_query_string(scope):",
            "    path_with_query_string = scope.get(\"root_path\", \"\") + scope[\"path\"]",
            "    if scope[\"query_string\"]:",
            "        path_with_query_string = \"{}?{}\".format(",
            "            path_with_query_string, scope[\"query_string\"].decode(\"ascii\")",
            "        )",
            "    return path_with_query_string"
        ],
        "afterPatchFile": [
            "import socket",
            "import urllib",
            "",
            "",
            "def get_remote_addr(transport):",
            "    socket_info = transport.get_extra_info(\"socket\")",
            "    if socket_info is not None:",
            "        try:",
            "            info = socket_info.getpeername()",
            "        except OSError:",
            "            # This case appears to inconsistently occur with uvloop",
            "            # bound to a unix domain socket.",
            "            family = None",
            "            info = None",
            "        else:",
            "            family = socket_info.family",
            "",
            "        if family in (socket.AF_INET, socket.AF_INET6):",
            "            return (str(info[0]), int(info[1]))",
            "        return None",
            "    info = transport.get_extra_info(\"peername\")",
            "    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:",
            "        return (str(info[0]), int(info[1]))",
            "    return None",
            "",
            "",
            "def get_local_addr(transport):",
            "    socket_info = transport.get_extra_info(\"socket\")",
            "    if socket_info is not None:",
            "        info = socket_info.getsockname()",
            "        family = socket_info.family",
            "        if family in (socket.AF_INET, socket.AF_INET6):",
            "            return (str(info[0]), int(info[1]))",
            "        return None",
            "    info = transport.get_extra_info(\"sockname\")",
            "    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:",
            "        return (str(info[0]), int(info[1]))",
            "    return None",
            "",
            "",
            "def is_ssl(transport):",
            "    return bool(transport.get_extra_info(\"sslcontext\"))",
            "",
            "",
            "def get_client_addr(scope):",
            "    client = scope.get(\"client\")",
            "    if not client:",
            "        return \"\"",
            "    return \"%s:%d\" % client",
            "",
            "",
            "def get_path_with_query_string(scope):",
            "    path_with_query_string = urllib.parse.quote(",
            "        scope.get(\"root_path\", \"\") + scope[\"path\"]",
            "    )",
            "    if scope[\"query_string\"]:",
            "        path_with_query_string = \"{}?{}\".format(",
            "            path_with_query_string, scope[\"query_string\"].decode(\"ascii\")",
            "        )",
            "    return path_with_query_string"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "52": [
                "get_path_with_query_string"
            ]
        },
        "addLocation": []
    }
}