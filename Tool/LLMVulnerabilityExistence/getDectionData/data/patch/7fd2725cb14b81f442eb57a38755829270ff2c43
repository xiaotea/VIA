{
    "neutron/agent/common/ovs_lib.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": 632,
                "PatchRowcode": "                          {'port_id': port_id, 'br_name': self.br_name})"
            },
            "1": {
                "beforePatchRowNumber": 633,
                "afterPatchRowNumber": 633,
                "PatchRowcode": "                 continue"
            },
            "2": {
                "beforePatchRowNumber": 634,
                "afterPatchRowNumber": 634,
                "PatchRowcode": "             pinfo = by_id[port_id]"
            },
            "3": {
                "beforePatchRowNumber": 635,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not self._check_ofport(port_id, pinfo):"
            },
            "4": {
                "beforePatchRowNumber": 636,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                continue"
            },
            "5": {
                "beforePatchRowNumber": 637,
                "afterPatchRowNumber": 635,
                "PatchRowcode": "             mac = pinfo['external_ids'].get('attached-mac')"
            },
            "6": {
                "beforePatchRowNumber": 638,
                "afterPatchRowNumber": 636,
                "PatchRowcode": "             result[port_id] = VifPort(pinfo['name'], pinfo['ofport'],"
            },
            "7": {
                "beforePatchRowNumber": 639,
                "afterPatchRowNumber": 637,
                "PatchRowcode": "                                       port_id, mac, self)"
            },
            "8": {
                "beforePatchRowNumber": 640,
                "afterPatchRowNumber": 638,
                "PatchRowcode": "         return result"
            },
            "9": {
                "beforePatchRowNumber": 641,
                "afterPatchRowNumber": 639,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 642,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @staticmethod"
            },
            "11": {
                "beforePatchRowNumber": 643,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _check_ofport(port_id, port_info):"
            },
            "12": {
                "beforePatchRowNumber": 644,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if port_info['ofport'] in [UNASSIGNED_OFPORT, INVALID_OFPORT]:"
            },
            "13": {
                "beforePatchRowNumber": 645,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            LOG.warning(\"ofport: %(ofport)s for VIF: %(vif)s \""
            },
            "14": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        \"is not a positive integer\","
            },
            "15": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        {'ofport': port_info['ofport'], 'vif': port_id})"
            },
            "16": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return False"
            },
            "17": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return True"
            },
            "18": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "19": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 640,
                "PatchRowcode": "     def get_vif_port_by_id(self, port_id):"
            },
            "20": {
                "beforePatchRowNumber": 652,
                "afterPatchRowNumber": 641,
                "PatchRowcode": "         ports = self.ovsdb.db_find("
            },
            "21": {
                "beforePatchRowNumber": 653,
                "afterPatchRowNumber": 642,
                "PatchRowcode": "             'Interface', ('external_ids', '=', {'iface-id': port_id}),"
            },
            "22": {
                "beforePatchRowNumber": 656,
                "afterPatchRowNumber": 645,
                "PatchRowcode": "         for port in ports:"
            },
            "23": {
                "beforePatchRowNumber": 657,
                "afterPatchRowNumber": 646,
                "PatchRowcode": "             if self.br_name != self.get_bridge_for_iface(port['name']):"
            },
            "24": {
                "beforePatchRowNumber": 658,
                "afterPatchRowNumber": 647,
                "PatchRowcode": "                 continue"
            },
            "25": {
                "beforePatchRowNumber": 659,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not self._check_ofport(port_id, port):"
            },
            "26": {
                "beforePatchRowNumber": 660,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                continue"
            },
            "27": {
                "beforePatchRowNumber": 661,
                "afterPatchRowNumber": 648,
                "PatchRowcode": "             mac = port['external_ids'].get('attached-mac')"
            },
            "28": {
                "beforePatchRowNumber": 662,
                "afterPatchRowNumber": 649,
                "PatchRowcode": "             return VifPort(port['name'], port['ofport'], port_id, mac, self)"
            },
            "29": {
                "beforePatchRowNumber": 663,
                "afterPatchRowNumber": 650,
                "PatchRowcode": "         LOG.info(\"Port %(port_id)s not present in bridge %(br_name)s\","
            }
        },
        "frontPatchFile": [
            "# Copyright 2011 VMware, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import functools",
            "import itertools",
            "import operator",
            "import random",
            "import time",
            "import uuid",
            "",
            "from neutron_lib import constants as p_const",
            "from neutron_lib import exceptions",
            "from neutron_lib.services.qos import constants as qos_constants",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "from oslo_utils import uuidutils",
            "from ovsdbapp.backend.ovs_idl import idlutils",
            "",
            "import debtcollector",
            "import tenacity",
            "",
            "from neutron._i18n import _",
            "from neutron.agent.common import ip_lib",
            "from neutron.agent.common import utils",
            "from neutron.agent.ovsdb import impl_idl",
            "from neutron.common import _constants as common_constants",
            "from neutron.common import utils as common_utils",
            "from neutron.conf.agent import ovs_conf",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common \\",
            "    import constants",
            "",
            "UINT64_BITMASK = (1 << 64) - 1",
            "",
            "# Special return value for an invalid OVS ofport",
            "INVALID_OFPORT = -1",
            "UNASSIGNED_OFPORT = []",
            "",
            "# OVS bridge fail modes",
            "FAILMODE_SECURE = 'secure'",
            "FAILMODE_STANDALONE = 'standalone'",
            "",
            "# special values for cookies",
            "COOKIE_ANY = object()",
            "",
            "ovs_conf.register_ovs_agent_opts()",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "OVS_DEFAULT_CAPS = {",
            "    'datapath_types': [],",
            "    'iface_types': [],",
            "}",
            "",
            "# It's default queue, all packets not tagged with 'set_queue' will go through",
            "# this one",
            "QOS_DEFAULT_QUEUE = 0",
            "",
            "_SENTINEL = object()",
            "",
            "CTRL_RATE_LIMIT_MIN = 100",
            "CTRL_BURST_LIMIT_MIN = 25",
            "",
            "",
            "def _ovsdb_result_pending(result):",
            "    \"\"\"Return True if ovsdb indicates the result is still pending.\"\"\"",
            "    # ovsdb can return '[]' for an ofport that has not yet been assigned",
            "    return result == []",
            "",
            "",
            "def _ovsdb_retry(fn):",
            "    \"\"\"Decorator for retrying when OVS has yet to assign an ofport.",
            "",
            "    The instance's ovsdb_timeout is used as the max waiting time. This relies",
            "    on the fact that instance methods receive self as the first argument.",
            "    \"\"\"",
            "    @functools.wraps(fn)",
            "    def wrapped(*args, **kwargs):",
            "        self = args[0]",
            "        new_fn = tenacity.retry(",
            "            reraise=True,",
            "            retry=tenacity.retry_if_result(_ovsdb_result_pending),",
            "            wait=tenacity.wait_exponential(multiplier=0.02, max=1),",
            "            stop=tenacity.stop_after_delay(",
            "                self.ovsdb_timeout))(fn)",
            "        return new_fn(*args, **kwargs)",
            "    return wrapped",
            "",
            "",
            "class VifPort(object):",
            "    def __init__(self, port_name, ofport, vif_id, vif_mac, switch):",
            "        self.port_name = port_name",
            "        self.ofport = ofport",
            "        self.vif_id = vif_id",
            "        self.vif_mac = vif_mac",
            "        self.switch = switch",
            "",
            "    def __str__(self):",
            "        return (\"iface-id=%s, vif_mac=%s, port_name=%s, ofport=%s, \"",
            "                \"bridge_name=%s\") % (",
            "                    self.vif_id, self.vif_mac,",
            "                    self.port_name, self.ofport,",
            "                    self.switch.br_name)",
            "",
            "",
            "class BaseOVS(object):",
            "",
            "    def __init__(self):",
            "        self.ovsdb = impl_idl.api_factory()",
            "        self._hw_offload = None",
            "",
            "    @property",
            "    def ovsdb_timeout(self):",
            "        return self.ovsdb.ovsdb_connection.timeout",
            "",
            "    def add_bridge(self, bridge_name,",
            "                   datapath_type=constants.OVS_DATAPATH_SYSTEM):",
            "        br = OVSBridge(bridge_name, datapath_type=datapath_type)",
            "        br.create()",
            "        return br",
            "",
            "    def delete_bridge(self, bridge_name):",
            "        self.ovsdb.del_br(bridge_name).execute()",
            "",
            "    def bridge_exists(self, bridge_name):",
            "        return self.ovsdb.br_exists(bridge_name).execute()",
            "",
            "    def port_exists(self, port_name):",
            "        cmd = self.ovsdb.db_get('Port', port_name, 'name')",
            "        return bool(cmd.execute(check_error=False, log_errors=False))",
            "",
            "    def get_bridge_for_iface(self, iface):",
            "        return self.ovsdb.iface_to_br(iface).execute()",
            "",
            "    def get_bridges(self):",
            "        return self.ovsdb.list_br().execute(check_error=True)",
            "",
            "    def get_bridge_external_bridge_id(self, bridge, check_error=False,",
            "                                      log_errors=True):",
            "        return self.ovsdb.br_get_external_id(bridge, 'bridge-id').execute(",
            "            check_error=check_error, log_errors=log_errors)",
            "",
            "    def set_db_attribute(self, table_name, record, column, value,",
            "                         check_error=False, log_errors=True):",
            "        self.ovsdb.db_set(table_name, record, (column, value)).execute(",
            "            check_error=check_error, log_errors=log_errors)",
            "",
            "    def clear_db_attribute(self, table_name, record, column):",
            "        self.ovsdb.db_clear(table_name, record, column).execute()",
            "",
            "    def db_get_val(self, table, record, column, check_error=False,",
            "                   log_errors=True):",
            "        return self.ovsdb.db_get(table, record, column).execute(",
            "            check_error=check_error, log_errors=log_errors)",
            "",
            "    @property",
            "    def config(self):",
            "        \"\"\"A dict containing the only row from the root Open_vSwitch table",
            "",
            "        This row contains several columns describing the Open vSwitch install",
            "        and the system on which it is installed. Useful keys include:",
            "            datapath_types: a list of supported datapath types",
            "            iface_types: a list of supported interface types",
            "            ovs_version: the OVS version",
            "        \"\"\"",
            "        return self.ovsdb.db_list(\"Open_vSwitch\").execute()[0]",
            "",
            "    @property",
            "    def capabilities(self):",
            "        _cfg = self.config",
            "        return {k: _cfg.get(k, OVS_DEFAULT_CAPS[k]) for k in OVS_DEFAULT_CAPS}",
            "",
            "    @property",
            "    def is_hw_offload_enabled(self):",
            "        if self._hw_offload is None:",
            "            self._hw_offload = self.config.get('other_config',",
            "                                   {}).get('hw-offload', '').lower() == 'true'",
            "        return self._hw_offload",
            "",
            "",
            "# Map from version string to on-the-wire protocol version encoding:",
            "OF_PROTOCOL_TO_VERSION = {",
            "    constants.OPENFLOW10: 1,",
            "    constants.OPENFLOW11: 2,",
            "    constants.OPENFLOW12: 3,",
            "    constants.OPENFLOW13: 4,",
            "    constants.OPENFLOW14: 5,",
            "    constants.OPENFLOW15: 6,",
            "}",
            "",
            "",
            "def version_from_protocol(protocol):",
            "    if protocol not in OF_PROTOCOL_TO_VERSION:",
            "        raise Exception(_(\"unknown OVS protocol string, cannot compare: \"",
            "                          \"%(protocol)s, (known: %(known)s)\") %",
            "                        {'protocol': protocol,",
            "                         'known': list(OF_PROTOCOL_TO_VERSION)})",
            "    return OF_PROTOCOL_TO_VERSION[protocol]",
            "",
            "",
            "class OVSBridge(BaseOVS):",
            "    def __init__(self, br_name, datapath_type=constants.OVS_DATAPATH_SYSTEM):",
            "        super(OVSBridge, self).__init__()",
            "        self.br_name = br_name",
            "        self.datapath_type = datapath_type",
            "        self._default_cookie = generate_random_cookie()",
            "        self._highest_protocol_needed = constants.OPENFLOW10",
            "        self._min_bw_qos_id = uuidutils.generate_uuid()",
            "        # TODO(jlibosva): Revert initial_protocols once launchpad bug 1852221",
            "        #                 is fixed and new openvswitch containing the fix is",
            "        #                 released.",
            "        self.initial_protocols = {",
            "            constants.OPENFLOW10, constants.OPENFLOW13, constants.OPENFLOW14}",
            "        self.initial_protocols.add(self._highest_protocol_needed)",
            "",
            "    @property",
            "    def default_cookie(self):",
            "        return self._default_cookie",
            "",
            "    def set_agent_uuid_stamp(self, val):",
            "        self._default_cookie = val",
            "",
            "    def set_controller(self, controllers):",
            "        self.ovsdb.set_controller(self.br_name,",
            "                                  controllers).execute(check_error=True)",
            "",
            "    def del_controller(self):",
            "        self.ovsdb.del_controller(self.br_name).execute(check_error=True)",
            "",
            "    def get_controller(self):",
            "        return self.ovsdb.get_controller(self.br_name).execute(",
            "            check_error=True)",
            "",
            "    def _set_bridge_fail_mode(self, mode):",
            "        self.ovsdb.set_fail_mode(self.br_name, mode).execute(check_error=True)",
            "",
            "    def set_secure_mode(self):",
            "        self._set_bridge_fail_mode(FAILMODE_SECURE)",
            "",
            "    def set_standalone_mode(self):",
            "        self._set_bridge_fail_mode(FAILMODE_STANDALONE)",
            "",
            "    def add_protocols(self, *protocols):",
            "        self.ovsdb.db_add('Bridge', self.br_name,",
            "                          'protocols', *protocols).execute(check_error=True)",
            "",
            "    def use_at_least_protocol(self, protocol):",
            "        \"\"\"Calls to ovs-ofctl will use a protocol version >= 'protocol'\"\"\"",
            "        self.add_protocols(protocol)",
            "        self._highest_protocol_needed = max(self._highest_protocol_needed,",
            "                                            protocol,",
            "                                            key=version_from_protocol)",
            "        self.initial_protocols.add(self._highest_protocol_needed)",
            "",
            "    def set_igmp_snooping_state(self, state):",
            "        state = bool(state)",
            "        other_config = {",
            "            'mcast-snooping-disable-flood-unregistered': str(state)}",
            "        with self.ovsdb.transaction() as txn:",
            "            txn.add(",
            "                self.ovsdb.db_set('Bridge', self.br_name,",
            "                                  ('mcast_snooping_enable', state)))",
            "            txn.add(",
            "                self.ovsdb.db_set('Bridge', self.br_name,",
            "                                  ('other_config', other_config)))",
            "",
            "    def create(self, secure_mode=False):",
            "        other_config = {",
            "            'mac-table-size': str(cfg.CONF.OVS.bridge_mac_table_size)}",
            "        with self.ovsdb.transaction() as txn:",
            "            txn.add(",
            "                self.ovsdb.add_br(self.br_name,",
            "                                  datapath_type=self.datapath_type))",
            "            # the ovs-ofctl commands below in run_ofctl use OF10, so we",
            "            # need to ensure that this version is enabled ; we could reuse",
            "            # add_protocols, but doing ovsdb.db_add avoids doing two",
            "            # transactions",
            "            txn.add(",
            "                self.ovsdb.db_add('Bridge', self.br_name,",
            "                                  'protocols',",
            "                                  *self.initial_protocols))",
            "            txn.add(",
            "                self.ovsdb.db_set('Bridge', self.br_name,",
            "                                  ('other_config', other_config)))",
            "            if secure_mode:",
            "                txn.add(self.ovsdb.set_fail_mode(self.br_name,",
            "                                                 FAILMODE_SECURE))",
            "",
            "    def destroy(self):",
            "        self.delete_bridge(self.br_name)",
            "",
            "    def add_port(self, port_name, *interface_attr_tuples):",
            "        with self.ovsdb.transaction() as txn:",
            "            txn.add(self.ovsdb.add_port(self.br_name, port_name))",
            "            if interface_attr_tuples:",
            "                txn.add(self.ovsdb.db_set('Interface', port_name,",
            "                                          *interface_attr_tuples))",
            "        return self.get_port_ofport(port_name)",
            "",
            "    def replace_port(self, port_name, *interface_attr_tuples):",
            "        \"\"\"Replace existing port or create it, and configure port interface.\"\"\"",
            "",
            "        # NOTE(xiaohhui): If del_port is inside the transaction, there will",
            "        # only be one command for replace_port. This will cause the new port",
            "        # not be found by system, which will lead to Bug #1519926.",
            "        self.ovsdb.del_port(port_name).execute()",
            "        with self.ovsdb.transaction() as txn:",
            "            txn.add(self.ovsdb.add_port(self.br_name, port_name,",
            "                                        may_exist=False))",
            "            # NOTE(mangelajo): Port is added to dead vlan (4095) by default",
            "            # until it's handled by the neutron-openvswitch-agent. Otherwise it",
            "            # becomes a trunk port on br-int (receiving traffic for all vlans),",
            "            # and also triggers issues on ovs-vswitchd related to the",
            "            # datapath flow revalidator thread, see lp#1767422",
            "            txn.add(self.ovsdb.db_set(",
            "                    'Port', port_name, ('tag', constants.DEAD_VLAN_TAG)))",
            "",
            "            # TODO(mangelajo): We could accept attr tuples for the Port too",
            "            # but, that could potentially break usage of this function in",
            "            # stable branches (where we need to backport).",
            "            # https://review.opendev.org/#/c/564825/4/neutron/agent/common/",
            "            # ovs_lib.py@289",
            "            if interface_attr_tuples:",
            "                txn.add(self.ovsdb.db_set('Interface', port_name,",
            "                                          *interface_attr_tuples))",
            "",
            "    def delete_port(self, port_name):",
            "        self.ovsdb.del_port(port_name, self.br_name).execute()",
            "",
            "    def run_ofctl(self, cmd, args, process_input=None):",
            "        debtcollector.deprecate(\"Use of run_ofctl is \"",
            "            \"deprecated\", removal_version='V')",
            "        full_args = [\"ovs-ofctl\", cmd,",
            "                     \"-O\", self._highest_protocol_needed,",
            "                     self.br_name] + args",
            "        # TODO(kevinbenton): This error handling is really brittle and only",
            "        # detects one specific type of failure. The callers of this need to",
            "        # be refactored to expect errors so we can re-raise and they can",
            "        # take appropriate action based on the type of error.",
            "        for i in range(1, 11):",
            "            try:",
            "                return utils.execute(full_args, run_as_root=True,",
            "                                     process_input=process_input)",
            "            except Exception as e:",
            "                if \"failed to connect to socket\" in str(e):",
            "                    LOG.debug(\"Failed to connect to OVS. Retrying \"",
            "                              \"in 1 second. Attempt: %s/10\", i)",
            "                    time.sleep(1)",
            "                    continue",
            "                LOG.error(\"Unable to execute %(cmd)s. Exception: \"",
            "                          \"%(exception)s\",",
            "                          {'cmd': full_args, 'exception': e})",
            "                break",
            "",
            "    def count_flows(self):",
            "        flow_list = self.run_ofctl(\"dump-flows\", []).split(\"\\n\")[1:]",
            "        return len(flow_list) - 1",
            "",
            "    def remove_all_flows(self):",
            "        self.run_ofctl(\"del-flows\", [])",
            "",
            "    @_ovsdb_retry",
            "    def _get_port_val(self, port_name, port_val):",
            "        return self.db_get_val(\"Interface\", port_name, port_val)",
            "",
            "    def get_port_ofport(self, port_name):",
            "        \"\"\"Get the port's assigned ofport, retrying if not yet assigned.\"\"\"",
            "        ofport = INVALID_OFPORT",
            "        try:",
            "            ofport = self._get_port_val(port_name, \"ofport\")",
            "        except tenacity.RetryError:",
            "            LOG.exception(\"Timed out retrieving ofport on port %s.\",",
            "                          port_name)",
            "        return ofport",
            "",
            "    @_ovsdb_retry",
            "    def _get_datapath_id(self):",
            "        return self.db_get_val('Bridge', self.br_name, 'datapath_id')",
            "",
            "    def get_datapath_id(self):",
            "        try:",
            "            return self._get_datapath_id()",
            "        except tenacity.RetryError:",
            "            # if ovs fails to find datapath_id then something is likely to be",
            "            # broken here",
            "            LOG.exception(\"Timed out retrieving datapath_id on bridge %s.\",",
            "                          self.br_name)",
            "            raise RuntimeError(_('No datapath_id on bridge %s') % self.br_name)",
            "",
            "    def do_action_flows(self, action, kwargs_list, use_bundle=False):",
            "        # we can't mix strict and non-strict, so we'll use the first kw",
            "        # and check against other kw being different",
            "        strict = kwargs_list[0].get('strict', False)",
            "",
            "        for kw in kwargs_list:",
            "            if action == 'del':",
            "                if kw.get('cookie') == COOKIE_ANY:",
            "                    # special value COOKIE_ANY was provided, unset",
            "                    # cookie to match flows whatever their cookie is",
            "                    kw.pop('cookie')",
            "                    if kw.get('cookie_mask'):  # non-zero cookie mask",
            "                        raise Exception(_(\"cookie=COOKIE_ANY but cookie_mask \"",
            "                                          \"set to %s\") % kw.get('cookie_mask'))",
            "                elif 'cookie' in kw:",
            "                    # a cookie was specified, use it",
            "                    kw['cookie'] = check_cookie_mask(kw['cookie'])",
            "                else:",
            "                    # nothing was specified about cookies, use default",
            "                    kw['cookie'] = \"%d/-1\" % self._default_cookie",
            "            else:",
            "                if 'cookie' not in kw:",
            "                    kw['cookie'] = self._default_cookie",
            "",
            "            if action in ('mod', 'del'):",
            "                if kw.pop('strict', False) != strict:",
            "                    msg = (\"cannot mix 'strict' and not 'strict' in a batch \"",
            "                           \"call\")",
            "                    raise exceptions.InvalidInput(error_message=msg)",
            "            else:",
            "                if kw.pop('strict', False):",
            "                    msg = \"cannot use 'strict' with 'add' action\"",
            "                    raise exceptions.InvalidInput(error_message=msg)",
            "",
            "        extra_param = [\"--strict\"] if strict else []",
            "",
            "        if action == 'del' and {} in kwargs_list:",
            "            # the 'del' case simplifies itself if kwargs_list has at least",
            "            # one item that matches everything",
            "            self.run_ofctl('%s-flows' % action, [])",
            "        else:",
            "            flow_strs = [_build_flow_expr_str(kw, action, strict)",
            "                         for kw in kwargs_list]",
            "            LOG.debug(\"Processing %d OpenFlow rules.\", len(flow_strs))",
            "            if use_bundle:",
            "                extra_param.append('--bundle')",
            "",
            "            step = common_constants.AGENT_RES_PROCESSING_STEP",
            "            for i in range(0, len(flow_strs), step):",
            "                self.run_ofctl('%s-flows' % action, extra_param + ['-'],",
            "                               '\\n'.join(flow_strs[i:i + step]))",
            "",
            "    def add_flow(self, **kwargs):",
            "        self.do_action_flows('add', [kwargs])",
            "",
            "    def mod_flow(self, **kwargs):",
            "        self.do_action_flows('mod', [kwargs])",
            "",
            "    def delete_flows(self, **kwargs):",
            "        self.do_action_flows('del', [kwargs])",
            "",
            "    def dump_flows_for_table(self, table):",
            "        return self.dump_flows_for(table=table)",
            "",
            "    def dump_flows_for(self, **kwargs):",
            "        retval = None",
            "        if \"cookie\" in kwargs:",
            "            kwargs[\"cookie\"] = check_cookie_mask(str(kwargs[\"cookie\"]))",
            "        flow_str = \",\".join(\"=\".join([key, str(val)])",
            "                            for key, val in kwargs.items())",
            "",
            "        flows = self.run_ofctl(\"dump-flows\", [flow_str])",
            "        if flows:",
            "            retval = '\\n'.join(item for item in flows.splitlines()",
            "                               if is_a_flow_line(item))",
            "        return retval",
            "",
            "    def dump_all_flows(self):",
            "        return [f for f in self.run_ofctl(\"dump-flows\", []).splitlines()",
            "                if is_a_flow_line(f)]",
            "",
            "    def deferred(self, *args, **kwargs):",
            "        return DeferredOVSBridge(self, *args, **kwargs)",
            "",
            "    def add_tunnel_port(self, port_name, remote_ip, local_ip,",
            "                        tunnel_type=p_const.TYPE_GRE,",
            "                        vxlan_udp_port=p_const.VXLAN_UDP_PORT,",
            "                        dont_fragment=True,",
            "                        tunnel_csum=False,",
            "                        tos=None):",
            "        attrs = [('type', tunnel_type)]",
            "        # TODO(twilson) This is an OrderedDict solely to make a test happy",
            "        options = collections.OrderedDict()",
            "        vxlan_uses_custom_udp_port = (",
            "            tunnel_type == p_const.TYPE_VXLAN and",
            "            vxlan_udp_port != p_const.VXLAN_UDP_PORT",
            "        )",
            "        if vxlan_uses_custom_udp_port:",
            "            options['dst_port'] = str(vxlan_udp_port)",
            "        options['df_default'] = str(dont_fragment).lower()",
            "        options['remote_ip'] = remote_ip",
            "        options['local_ip'] = local_ip",
            "        options['in_key'] = 'flow'",
            "        options['out_key'] = 'flow'",
            "        # NOTE(moshele): pkt_mark is not upported when using ovs hw-offload,",
            "        # therefore avoid clear mark on encapsulating packets when it's",
            "        # enabled",
            "        if not self.is_hw_offload_enabled:",
            "            options['egress_pkt_mark'] = '0'",
            "        if tunnel_csum:",
            "            options['csum'] = str(tunnel_csum).lower()",
            "        if tos:",
            "            options['tos'] = str(tos)",
            "        attrs.append(('options', options))",
            "",
            "        return self.add_port(port_name, *attrs)",
            "",
            "    def add_patch_port(self, local_name, remote_name):",
            "        attrs = [('type', 'patch'),",
            "                 ('options', {'peer': remote_name})]",
            "        return self.add_port(local_name, *attrs)",
            "",
            "    def get_iface_name_list(self):",
            "        # get the interface name list for this bridge",
            "        return self.ovsdb.list_ifaces(self.br_name).execute(check_error=True)",
            "",
            "    def get_port_name_list(self):",
            "        # get the port name list for this bridge",
            "        return self.ovsdb.list_ports(self.br_name).execute(check_error=True)",
            "",
            "    def get_port_stats(self, port_name):",
            "        return self.db_get_val(\"Interface\", port_name, \"statistics\")",
            "",
            "    def get_ports_attributes(self, table, columns=None, ports=None,",
            "                             check_error=True, log_errors=True,",
            "                             if_exists=False):",
            "        port_names = ports or self.get_port_name_list()",
            "        if not port_names:",
            "            return []",
            "        return (self.ovsdb.db_list(table, port_names, columns=columns,",
            "                                   if_exists=if_exists).",
            "                execute(check_error=check_error, log_errors=log_errors))",
            "",
            "    # returns a VIF object for each VIF port",
            "    def get_vif_ports(self, ofport_filter=None):",
            "        edge_ports = []",
            "        port_info = self.get_ports_attributes(",
            "            'Interface', columns=['name', 'external_ids', 'ofport'],",
            "            if_exists=True)",
            "        for port in port_info:",
            "            name = port['name']",
            "            external_ids = port['external_ids']",
            "            ofport = port['ofport']",
            "            if ofport_filter and ofport in ofport_filter:",
            "                continue",
            "            if \"iface-id\" in external_ids and \"attached-mac\" in external_ids:",
            "                p = VifPort(name, ofport, external_ids[\"iface-id\"],",
            "                            external_ids[\"attached-mac\"], self)",
            "                edge_ports.append(p)",
            "",
            "        return edge_ports",
            "",
            "    def get_vif_port_to_ofport_map(self):",
            "        results = self.get_ports_attributes(",
            "            'Interface', columns=['name', 'external_ids', 'ofport'],",
            "            if_exists=True)",
            "        port_map = {}",
            "        for r in results:",
            "            # fall back to basic interface name",
            "            key = self.portid_from_external_ids(r['external_ids']) or r['name']",
            "            try:",
            "                port_map[key] = int(r['ofport'])",
            "            except TypeError:",
            "                # port doesn't yet have an ofport entry so we ignore it",
            "                pass",
            "        return port_map",
            "",
            "    def get_vif_port_set(self):",
            "        edge_ports = set()",
            "        results = self.get_ports_attributes(",
            "            'Interface', columns=['name', 'external_ids', 'ofport'],",
            "            if_exists=True)",
            "        for result in results:",
            "            if result['ofport'] == UNASSIGNED_OFPORT:",
            "                LOG.warning(\"Found not yet ready openvswitch port: %s\",",
            "                            result['name'])",
            "            elif result['ofport'] == INVALID_OFPORT:",
            "                LOG.warning(\"Found failed openvswitch port: %s\",",
            "                            result['name'])",
            "            elif 'attached-mac' in result['external_ids']:",
            "                port_id = self.portid_from_external_ids(result['external_ids'])",
            "                if port_id:",
            "                    edge_ports.add(port_id)",
            "        return edge_ports",
            "",
            "    def portid_from_external_ids(self, external_ids):",
            "        if 'iface-id' in external_ids:",
            "            return external_ids['iface-id']",
            "",
            "    def get_port_tag_dict(self):",
            "        \"\"\"Get a dict of port names and associated vlan tags.",
            "",
            "        e.g. the returned dict is of the following form::",
            "",
            "            {u'int-br-eth2': [],",
            "             u'patch-tun': [],",
            "             u'qr-76d9e6b6-21': 1,",
            "             u'tapce5318ff-78': 1,",
            "             u'tape1400310-e6': 1}",
            "",
            "        The TAG ID is only available in the \"Port\" table and is not available",
            "        in the \"Interface\" table queried by the get_vif_port_set() method.",
            "",
            "        \"\"\"",
            "        results = self.get_ports_attributes(",
            "            'Port', columns=['name', 'tag'], if_exists=True)",
            "        return {p['name']: p['tag'] for p in results}",
            "",
            "    def get_vifs_by_ids(self, port_ids):",
            "        interface_info = self.get_ports_attributes(",
            "            \"Interface\", columns=[\"name\", \"external_ids\", \"ofport\"],",
            "            if_exists=True)",
            "        by_id = {x['external_ids'].get('iface-id'): x for x in interface_info}",
            "        result = {}",
            "        for port_id in port_ids:",
            "            result[port_id] = None",
            "            if port_id not in by_id:",
            "                LOG.info(\"Port %(port_id)s not present in bridge \"",
            "                         \"%(br_name)s\",",
            "                         {'port_id': port_id, 'br_name': self.br_name})",
            "                continue",
            "            pinfo = by_id[port_id]",
            "            if not self._check_ofport(port_id, pinfo):",
            "                continue",
            "            mac = pinfo['external_ids'].get('attached-mac')",
            "            result[port_id] = VifPort(pinfo['name'], pinfo['ofport'],",
            "                                      port_id, mac, self)",
            "        return result",
            "",
            "    @staticmethod",
            "    def _check_ofport(port_id, port_info):",
            "        if port_info['ofport'] in [UNASSIGNED_OFPORT, INVALID_OFPORT]:",
            "            LOG.warning(\"ofport: %(ofport)s for VIF: %(vif)s \"",
            "                        \"is not a positive integer\",",
            "                        {'ofport': port_info['ofport'], 'vif': port_id})",
            "            return False",
            "        return True",
            "",
            "    def get_vif_port_by_id(self, port_id):",
            "        ports = self.ovsdb.db_find(",
            "            'Interface', ('external_ids', '=', {'iface-id': port_id}),",
            "            ('external_ids', '!=', {'attached-mac': ''}),",
            "            columns=['external_ids', 'name', 'ofport']).execute()",
            "        for port in ports:",
            "            if self.br_name != self.get_bridge_for_iface(port['name']):",
            "                continue",
            "            if not self._check_ofport(port_id, port):",
            "                continue",
            "            mac = port['external_ids'].get('attached-mac')",
            "            return VifPort(port['name'], port['ofport'], port_id, mac, self)",
            "        LOG.info(\"Port %(port_id)s not present in bridge %(br_name)s\",",
            "                 {'port_id': port_id, 'br_name': self.br_name})",
            "",
            "    def delete_ports(self, all_ports=False):",
            "        if all_ports:",
            "            port_names = self.get_port_name_list()",
            "        else:",
            "            port_names = (port.port_name for port in self.get_vif_ports())",
            "",
            "        for port_name in port_names:",
            "            self.delete_port(port_name)",
            "",
            "    def get_local_port_mac(self):",
            "        \"\"\"Retrieve the mac of the bridge's local port.\"\"\"",
            "        address = ip_lib.IPDevice(self.br_name).link.address",
            "        if address:",
            "            return address",
            "        else:",
            "            msg = _('Unable to determine mac address for %s') % self.br_name",
            "            raise Exception(msg)",
            "",
            "    def set_controllers_connection_mode(self, connection_mode):",
            "        \"\"\"Set bridge controllers connection mode.",
            "",
            "        :param connection_mode: \"out-of-band\" or \"in-band\"",
            "        \"\"\"",
            "        self.set_controller_field('connection_mode', connection_mode)",
            "",
            "    def set_controllers_inactivity_probe(self, interval):",
            "        \"\"\"Set bridge controllers inactivity probe interval.",
            "",
            "        :param interval: inactivity_probe value in seconds.",
            "        \"\"\"",
            "        self.set_controller_field('inactivity_probe', interval * 1000)",
            "",
            "    def _set_egress_bw_limit_for_port(self, port_name, max_kbps,",
            "                                      max_burst_kbps, check_error=True):",
            "        with self.ovsdb.transaction(check_error=check_error) as txn:",
            "            txn.add(self.ovsdb.db_set('Interface', port_name,",
            "                                      ('ingress_policing_rate', max_kbps)))",
            "            txn.add(self.ovsdb.db_set('Interface', port_name,",
            "                                      ('ingress_policing_burst',",
            "                                       max_burst_kbps)))",
            "",
            "    def create_egress_bw_limit_for_port(self, port_name, max_kbps,",
            "                                        max_burst_kbps):",
            "        self._set_egress_bw_limit_for_port(",
            "            port_name, max_kbps, max_burst_kbps)",
            "",
            "    def get_egress_bw_limit_for_port(self, port_name):",
            "",
            "        max_kbps = self.db_get_val('Interface', port_name,",
            "                                   'ingress_policing_rate')",
            "        max_burst_kbps = self.db_get_val('Interface', port_name,",
            "                                         'ingress_policing_burst')",
            "",
            "        max_kbps = max_kbps or None",
            "        max_burst_kbps = max_burst_kbps or None",
            "",
            "        return max_kbps, max_burst_kbps",
            "",
            "    def delete_egress_bw_limit_for_port(self, port_name):",
            "        if not self.port_exists(port_name):",
            "            return",
            "        self._set_egress_bw_limit_for_port(port_name, 0, 0, check_error=False)",
            "",
            "    def find_qos(self, port_name):",
            "        qos = self.ovsdb.db_find(",
            "            'QoS',",
            "            ('external_ids', '=', {'id': port_name}),",
            "            columns=['_uuid', 'other_config']).execute(check_error=True)",
            "        if qos:",
            "            return qos[0]",
            "",
            "    def find_queue(self, port_name, queue_type):",
            "        queues = self.ovsdb.db_find(",
            "            'Queue',",
            "            ('external_ids', '=', {'id': port_name,",
            "                                   'queue_type': str(queue_type)}),",
            "            columns=['_uuid', 'other_config']).execute(check_error=True)",
            "        if queues:",
            "            return queues[0]",
            "",
            "    def _update_bw_limit_queue(self, txn, port_name, queue_uuid, queue_type,",
            "                               other_config):",
            "        if queue_uuid:",
            "            txn.add(self.ovsdb.db_set(",
            "                'Queue', queue_uuid,",
            "                ('other_config', other_config)))",
            "        else:",
            "            external_ids = {'id': port_name,",
            "                            'queue_type': str(queue_type)}",
            "            queue_uuid = txn.add(",
            "                self.ovsdb.db_create(",
            "                    'Queue', external_ids=external_ids,",
            "                    other_config=other_config))",
            "        return queue_uuid",
            "",
            "    def _update_bw_limit_profile(self, txn, port_name, qos_uuid,",
            "                                 queue_uuid, queue_type, qos_other_config):",
            "        queues = {queue_type: queue_uuid}",
            "        if qos_uuid:",
            "            txn.add(self.ovsdb.db_set(",
            "                'QoS', qos_uuid, ('queues', queues)))",
            "            txn.add(self.ovsdb.db_set(",
            "                'QoS', qos_uuid, ('other_config', qos_other_config)))",
            "        else:",
            "            external_ids = {'id': port_name}",
            "            qos_uuid = txn.add(",
            "                self.ovsdb.db_create(",
            "                    'QoS', external_ids=external_ids,",
            "                    type='linux-htb',",
            "                    queues=queues,",
            "                    other_config=qos_other_config))",
            "        return qos_uuid",
            "",
            "    def _update_bw_limit_profile_dpdk(self, txn, port_name, qos_uuid,",
            "                                      other_config):",
            "        if qos_uuid:",
            "            txn.add(self.ovsdb.db_set(",
            "                'QoS', qos_uuid, ('other_config', other_config)))",
            "        else:",
            "            external_ids = {'id': port_name}",
            "            qos_uuid = txn.add(",
            "                self.ovsdb.db_create(",
            "                    'QoS', external_ids=external_ids, type='egress-policer',",
            "                    other_config=other_config))",
            "        return qos_uuid",
            "",
            "    def _update_ingress_bw_limit_for_port(",
            "            self, port_name, max_bw_in_bits, max_burst_in_bits):",
            "        qos_other_config = {",
            "            'max-rate': str(max_bw_in_bits)",
            "        }",
            "        queue_other_config = {",
            "            'max-rate': str(max_bw_in_bits),",
            "            'burst': str(max_burst_in_bits),",
            "        }",
            "        qos = self.find_qos(port_name)",
            "        queue = self.find_queue(port_name, QOS_DEFAULT_QUEUE)",
            "        qos_uuid = qos['_uuid'] if qos else None",
            "        queue_uuid = queue['_uuid'] if queue else None",
            "        with self.ovsdb.transaction(check_error=True) as txn:",
            "            queue_uuid = self._update_bw_limit_queue(",
            "                txn, port_name, queue_uuid, QOS_DEFAULT_QUEUE,",
            "                queue_other_config",
            "            )",
            "",
            "            qos_uuid = self._update_bw_limit_profile(",
            "                txn, port_name, qos_uuid, queue_uuid, QOS_DEFAULT_QUEUE,",
            "                qos_other_config",
            "            )",
            "",
            "            txn.add(self.ovsdb.db_set(",
            "                'Port', port_name, ('qos', qos_uuid)))",
            "",
            "    def _update_ingress_bw_limit_for_dpdk_port(",
            "            self, port_name, max_bw_in_bits, max_burst_in_bits):",
            "        # cir and cbs should be set in bytes instead of bits",
            "        qos_other_config = {",
            "            'cir': str(max_bw_in_bits / 8),",
            "            'cbs': str(max_burst_in_bits / 8)",
            "        }",
            "        qos = self.find_qos(port_name)",
            "        qos_uuid = qos['_uuid'] if qos else None",
            "        with self.ovsdb.transaction(check_error=True) as txn:",
            "            qos_uuid = self._update_bw_limit_profile_dpdk(",
            "                txn, port_name, qos_uuid, qos_other_config)",
            "            txn.add(self.ovsdb.db_set(",
            "                'Port', port_name, ('qos', qos_uuid)))",
            "",
            "    def update_ingress_bw_limit_for_port(self, port_name, max_kbps,",
            "                                         max_burst_kbps):",
            "        max_bw_in_bits = max_kbps * p_const.SI_BASE",
            "        max_burst_in_bits = max_burst_kbps * p_const.SI_BASE",
            "        port_type = self._get_port_val(port_name, \"type\")",
            "        if port_type in constants.OVS_DPDK_PORT_TYPES:",
            "            self._update_ingress_bw_limit_for_dpdk_port(",
            "                port_name, max_bw_in_bits, max_burst_in_bits)",
            "        else:",
            "            self._update_ingress_bw_limit_for_port(",
            "                port_name, max_bw_in_bits, max_burst_in_bits)",
            "",
            "    def get_ingress_bw_limit_for_port(self, port_name):",
            "        max_kbps = None",
            "        qos_max_kbps = None",
            "        queue_max_kbps = None",
            "        max_burst_kbit = None",
            "",
            "        qos_res = self.find_qos(port_name)",
            "        if qos_res:",
            "            other_config = qos_res['other_config']",
            "            max_bw_in_bits = other_config.get('max-rate')",
            "            if max_bw_in_bits is not None:",
            "                qos_max_kbps = int(max_bw_in_bits) / p_const.SI_BASE",
            "",
            "        queue_res = self.find_queue(port_name, QOS_DEFAULT_QUEUE)",
            "        if queue_res:",
            "            other_config = queue_res['other_config']",
            "            max_bw_in_bits = other_config.get('max-rate')",
            "            if max_bw_in_bits is not None:",
            "                queue_max_kbps = int(max_bw_in_bits) / p_const.SI_BASE",
            "            max_burst_in_bits = other_config.get('burst')",
            "            if max_burst_in_bits is not None:",
            "                max_burst_kbit = (",
            "                    int(max_burst_in_bits) / p_const.SI_BASE)",
            "",
            "        if qos_max_kbps == queue_max_kbps:",
            "            max_kbps = qos_max_kbps",
            "        else:",
            "            LOG.warning(\"qos max-rate %(qos_max_kbps)s is not equal to \"",
            "                        \"queue max-rate %(queue_max_kbps)s\",",
            "                        {'qos_max_kbps': qos_max_kbps,",
            "                         'queue_max_kbps': queue_max_kbps})",
            "        return max_kbps, max_burst_kbit",
            "",
            "    def get_ingress_bw_limit_for_dpdk_port(self, port_name):",
            "        max_kbps = None",
            "        max_burst_kbit = None",
            "        res = self.find_qos(port_name)",
            "        if res:",
            "            other_config = res['other_config']",
            "            max_bw_in_bytes = other_config.get(\"cir\")",
            "            if max_bw_in_bytes is not None:",
            "                max_kbps = common_utils.bits_to_kilobits(",
            "                    common_utils.bytes_to_bits(int(float(max_bw_in_bytes))),",
            "                    p_const.SI_BASE)",
            "            max_burst_in_bytes = other_config.get(\"cbs\")",
            "            if max_burst_in_bytes is not None:",
            "                max_burst_kbit = common_utils.bits_to_kilobits(",
            "                    common_utils.bytes_to_bits(int(float(max_burst_in_bytes))),",
            "                    p_const.SI_BASE)",
            "        return max_kbps, max_burst_kbit",
            "",
            "    def delete_ingress_bw_limit_for_port(self, port_name):",
            "        self.ovsdb.db_clear('Port', port_name,",
            "                            'qos').execute(check_error=False)",
            "        qos = self.find_qos(port_name)",
            "        queue = self.find_queue(port_name, QOS_DEFAULT_QUEUE)",
            "        with self.ovsdb.transaction(check_error=True) as txn:",
            "            if qos:",
            "                txn.add(self.ovsdb.db_destroy('QoS', qos['_uuid']))",
            "            if queue:",
            "                txn.add(self.ovsdb.db_destroy('Queue', queue['_uuid']))",
            "",
            "    def set_controller_field(self, field, value):",
            "        attr = [(field, value)]",
            "        controllers = self.db_get_val('Bridge', self.br_name, 'controller')",
            "        controllers = [controllers] if isinstance(",
            "            controllers, uuid.UUID) else controllers",
            "        with self.ovsdb.transaction(check_error=True) as txn:",
            "            for controller_uuid in controllers:",
            "                txn.add(self.ovsdb.db_set(",
            "                    'Controller', controller_uuid, *attr))",
            "",
            "    def set_controller_rate_limit(self, controller_rate_limit):",
            "        \"\"\"Set bridge controller_rate_limit",
            "",
            "        :param controller_rate_limit: at least 100",
            "        \"\"\"",
            "        if controller_rate_limit < CTRL_RATE_LIMIT_MIN:",
            "            LOG.info(\"rate limit's value must be at least 100\")",
            "            controller_rate_limit = CTRL_RATE_LIMIT_MIN",
            "        self.set_controller_field(",
            "            'controller_rate_limit', controller_rate_limit)",
            "",
            "    def set_controller_burst_limit(self, controller_burst_limit):",
            "        \"\"\"Set bridge controller_burst_limit",
            "",
            "        :param controller_burst_limit: at least 25",
            "        \"\"\"",
            "        if controller_burst_limit < CTRL_BURST_LIMIT_MIN:",
            "            LOG.info(\"burst limit's value must be at least 25\")",
            "            controller_burst_limit = CTRL_BURST_LIMIT_MIN",
            "        self.set_controller_field(",
            "            'controller_burst_limit', controller_burst_limit)",
            "",
            "    def set_datapath_id(self, datapath_id):",
            "        dpid_cfg = {'datapath-id': datapath_id}",
            "        self.set_db_attribute('Bridge', self.br_name, 'other_config', dpid_cfg,",
            "                              check_error=True)",
            "",
            "    def get_egress_min_bw_for_port(self, port_id):",
            "        queue = self._find_queue(port_id)",
            "        if not queue:",
            "            return",
            "",
            "        min_bps = queue['other_config'].get('min-rate')",
            "        return int(int(min_bps) / 1000) if min_bps else None",
            "",
            "    def _set_queue_for_minimum_bandwidth(self, queue_num):",
            "        # reg4 is used to memoize if queue was set or not. If it is first visit",
            "        # to table 0 for a packet (i.e. reg4 == 0), set queue and memoize (i.e.",
            "        # load 1 to reg4), then goto table 0 again. The packet will be handled",
            "        # as usual when the second visit to table 0.",
            "        self.add_flow(",
            "            table=constants.LOCAL_SWITCHING,",
            "            in_port=queue_num,",
            "            reg4=0,",
            "            priority=200,",
            "            actions=(\"set_queue:%s,load:1->NXM_NX_REG4[0],\"",
            "                     \"resubmit(,%s)\" % (queue_num, constants.LOCAL_SWITCHING)))",
            "",
            "    def _unset_queue_for_minimum_bandwidth(self, queue_num):",
            "        self.delete_flows(",
            "            table=constants.LOCAL_SWITCHING,",
            "            in_port=queue_num,",
            "            reg4=0)",
            "",
            "    def update_minimum_bandwidth_queue(self, port_id, egress_port_names,",
            "                                       queue_num, min_kbps):",
            "        queue_num = int(queue_num)",
            "        queue_id = self._update_queue(port_id, queue_num, min_kbps=min_kbps)",
            "        qos_id, qos_queues = self._find_qos()",
            "        if qos_queues:",
            "            qos_queues[queue_num] = queue_id",
            "        else:",
            "            qos_queues = {queue_num: queue_id}",
            "        qos_id = self._update_qos(",
            "            qos_id=qos_id, queues=qos_queues)",
            "        for egress_port_name in egress_port_names:",
            "            self._set_port_qos(egress_port_name, qos_id=qos_id)",
            "        self._set_queue_for_minimum_bandwidth(queue_num)",
            "        return qos_id",
            "",
            "    def delete_minimum_bandwidth_queue(self, port_id):",
            "        queue = self._find_queue(port_id)",
            "        if not queue:",
            "            return",
            "        queue_num = int(queue['external_ids']['queue-num'])",
            "        self._unset_queue_for_minimum_bandwidth(queue_num)",
            "        qos_id, qos_queues = self._find_qos()",
            "        if not qos_queues:",
            "            return",
            "        if queue_num in qos_queues.keys():",
            "            qos_queues.pop(queue_num)",
            "            self._update_qos(",
            "                qos_id=qos_id, queues=qos_queues)",
            "            self._delete_queue(queue['_uuid'])",
            "",
            "    def clear_minimum_bandwidth_qos(self):",
            "        qoses = self._list_qos(",
            "            qos_type=qos_constants.RULE_TYPE_MINIMUM_BANDWIDTH)",
            "",
            "        for qos in qoses:",
            "            qos_id = qos['_uuid']",
            "            queues = {num: queue.uuid",
            "                      for num, queue in qos['queues'].items()}",
            "            ports = self.ovsdb.db_find(",
            "                'Port',",
            "                ('qos', '=', qos_id),",
            "                colmuns=['name']).execute(check_error=True)",
            "            for port in ports:",
            "                self._set_port_qos(port['name'])",
            "            self.ovsdb.db_destroy('QoS', qos_id).execute(check_error=True)",
            "            for queue_uuid in queues.values():",
            "                self._delete_queue(queue_uuid)",
            "",
            "    def _update_queue(self, port_id, queue_num, max_kbps=None,",
            "                      max_burst_kbps=None, min_kbps=None):",
            "        other_config = {}",
            "        if max_kbps:",
            "            other_config['max-rate'] = str(max_kbps * 1000)",
            "        if max_burst_kbps:",
            "            other_config['burst'] = str(max_burst_kbps * 1000)",
            "        if min_kbps:",
            "            other_config['min-rate'] = str(min_kbps * 1000)",
            "",
            "        queue = self._find_queue(port_id)",
            "        if queue and queue['_uuid']:",
            "            if queue['other_config'] != other_config:",
            "                self.set_db_attribute('Queue', queue['_uuid'], 'other_config',",
            "                                      other_config, check_error=True)",
            "        else:",
            "            # NOTE(ralonsoh): \"external_ids\" is a map of string-string pairs",
            "            external_ids = {",
            "                'port': str(port_id),",
            "                'type': str(qos_constants.RULE_TYPE_MINIMUM_BANDWIDTH),",
            "                'queue-num': str(queue_num)}",
            "            self.ovsdb.db_create(",
            "                'Queue', other_config=other_config,",
            "                external_ids=external_ids).execute(check_error=True)",
            "            queue = self._find_queue(port_id)",
            "        return queue['_uuid']",
            "",
            "    def _find_queue(self, port_id, _type=None):",
            "        # NOTE(ralonsoh): in ovsdb native library, '{>=}' operator is not",
            "        # implemented yet. This is a workaround: list all queues and compare",
            "        # the external_ids key needed.",
            "        _type = _type or qos_constants.RULE_TYPE_MINIMUM_BANDWIDTH",
            "        queues = self._list_queues(port=port_id, _type=_type)",
            "        if queues:",
            "            return queues[0]",
            "        return None",
            "",
            "    def _list_queues(self, _type=None, port=None):",
            "        queues = self.ovsdb.db_list(",
            "            'Queue',",
            "            columns=['_uuid', 'external_ids', 'other_config']).execute(",
            "            check_error=True)",
            "        if port:",
            "            queues = [queue for queue in queues",
            "                      if queue['external_ids'].get('port') == str(port)]",
            "        if _type:",
            "            queues = [queue for queue in queues",
            "                      if queue['external_ids'].get('type') == str(_type)]",
            "        return queues",
            "",
            "    def _delete_queue(self, queue_id):",
            "        try:",
            "            self.ovsdb.db_destroy('Queue', queue_id).execute(check_error=True)",
            "        except idlutils.RowNotFound:",
            "            LOG.info('OVS Queue %s was already deleted', queue_id)",
            "        except RuntimeError as exc:",
            "            with excutils.save_and_reraise_exception():",
            "                if 'referential integrity violation' not in str(exc):",
            "                    return",
            "                qos_regs = self._list_qos()",
            "                qos_uuids = []",
            "                for qos_reg in qos_regs:",
            "                    queue_nums = [num for num, q in qos_reg['queues'].items()",
            "                                  if q.uuid == queue_id]",
            "                    if queue_nums:",
            "                        qos_uuids.append(str(qos_reg['_uuid']))",
            "                LOG.error('Queue %(queue)s was still in use by the following '",
            "                          'QoS rules: %(qoses)s',",
            "                          {'queue': str(queue_id),",
            "                           'qoses': ', '.join(sorted(qos_uuids))})",
            "",
            "    def _update_qos(self, qos_id=None, queues=None):",
            "        queues = queues or {}",
            "        if not qos_id:",
            "            external_ids = {'id': self._min_bw_qos_id,",
            "                            '_type': qos_constants.RULE_TYPE_MINIMUM_BANDWIDTH}",
            "            self.ovsdb.db_create(",
            "                'QoS',",
            "                type='linux-htb',",
            "                queues=queues,",
            "                external_ids=external_ids).execute(check_error=True)",
            "            qos_id, _ = self._find_qos()",
            "        else:",
            "            self.clear_db_attribute('QoS', qos_id, 'queues')",
            "            if queues:",
            "                self.set_db_attribute('QoS', qos_id, 'queues', queues,",
            "                                      check_error=True)",
            "        return qos_id",
            "",
            "    def _list_qos(self, _id=None, qos_type=None):",
            "        external_ids = {}",
            "        if _id:",
            "            external_ids['id'] = _id",
            "        if qos_type:",
            "            external_ids['_type'] = qos_type",
            "        if external_ids:",
            "            return self.ovsdb.db_find(",
            "                'QoS',",
            "                ('external_ids', '=', external_ids),",
            "                colmuns=['_uuid', 'queues']).execute(check_error=True)",
            "",
            "        return self.ovsdb.db_find(",
            "            'QoS', colmuns=['_uuid', 'queues']).execute(check_error=True)",
            "",
            "    def _find_qos(self):",
            "        qos_regs = self._list_qos(_id=self._min_bw_qos_id)",
            "        if qos_regs:",
            "            queues = {num: queue.uuid",
            "                      for num, queue in qos_regs[0]['queues'].items()}",
            "            return qos_regs[0]['_uuid'], queues",
            "        return None, None",
            "",
            "    def _set_port_qos(self, port_name, qos_id=None):",
            "        if qos_id:",
            "            self.set_db_attribute('Port', port_name, 'qos', qos_id,",
            "                                  check_error=True)",
            "        else:",
            "            self.clear_db_attribute('Port', port_name, 'qos')",
            "",
            "    def get_bridge_ports(self, port_type=None):",
            "        port_names = self.get_port_name_list() + [self.br_name]",
            "        ports = self.get_ports_attributes('Interface',",
            "                                          ports=port_names,",
            "                                          columns=['name', 'type'],",
            "                                          if_exists=True) or []",
            "        if port_type is None:",
            "            return ports",
            "        elif not isinstance(port_type, list):",
            "            port_type = [port_type]",
            "        return [port['name'] for port in ports if port['type'] in port_type]",
            "",
            "    def __enter__(self):",
            "        self.create()",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, exc_tb):",
            "        self.destroy()",
            "",
            "",
            "class DeferredOVSBridge(object):",
            "    '''Deferred OVSBridge.",
            "",
            "    This class wraps add_flow, mod_flow and delete_flows calls to an OVSBridge",
            "    and defers their application until apply_flows call in order to perform",
            "    bulk calls. It wraps also ALLOWED_PASSTHROUGHS calls to avoid mixing",
            "    OVSBridge and DeferredOVSBridge uses.",
            "    This class can be used as a context, in such case apply_flows is called on",
            "    __exit__ except if an exception is raised.",
            "    This class is not thread-safe, that's why for every use a new instance",
            "    must be implemented.",
            "    '''",
            "    ALLOWED_PASSTHROUGHS = 'add_port', 'add_tunnel_port', 'delete_port'",
            "",
            "    def __init__(self, br, full_ordered=False,",
            "                 order=('add', 'mod', 'del'), use_bundle=False):",
            "        '''Constructor.",
            "",
            "        :param br: wrapped bridge",
            "        :param full_ordered: Optional, disable flow reordering (slower)",
            "        :param order: Optional, define in which order flow are applied",
            "        :param use_bundle: Optional, a bool whether --bundle should be passed",
            "                           to all ofctl commands. Default is set to False.",
            "        '''",
            "",
            "        self.br = br",
            "        self.full_ordered = full_ordered",
            "        self.order = order",
            "        if not self.full_ordered:",
            "            self.weights = dict((y, x) for x, y in enumerate(self.order))",
            "        self.action_flow_tuples = []",
            "        self.use_bundle = use_bundle",
            "",
            "    def __getattr__(self, name):",
            "        if name in self.ALLOWED_PASSTHROUGHS:",
            "            return getattr(self.br, name)",
            "        raise AttributeError(name)",
            "",
            "    def add_flow(self, **kwargs):",
            "        self.action_flow_tuples.append(('add', kwargs))",
            "",
            "    def mod_flow(self, **kwargs):",
            "        self.action_flow_tuples.append(('mod', kwargs))",
            "",
            "    def delete_flows(self, **kwargs):",
            "        self.action_flow_tuples.append(('del', kwargs))",
            "",
            "    def apply_flows(self):",
            "        action_flow_tuples = self.action_flow_tuples",
            "        self.action_flow_tuples = []",
            "        if not action_flow_tuples:",
            "            return",
            "",
            "        if not self.full_ordered:",
            "            action_flow_tuples.sort(key=lambda af: self.weights[af[0]])",
            "",
            "        grouped = itertools.groupby(action_flow_tuples,",
            "                                    key=operator.itemgetter(0))",
            "        itemgetter_1 = operator.itemgetter(1)",
            "        for action, action_flow_list in grouped:",
            "            flows = list(map(itemgetter_1, action_flow_list))",
            "            self.br.do_action_flows(action, flows, self.use_bundle)",
            "",
            "    def __enter__(self):",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        if exc_type is None:",
            "            self.apply_flows()",
            "        else:",
            "            LOG.exception(\"OVS flows could not be applied on bridge %s\",",
            "                          self.br.br_name)",
            "",
            "",
            "def _build_flow_expr_str(flow_dict, cmd, strict):",
            "    flow_expr_arr = []",
            "    actions = None",
            "",
            "    if cmd == 'add':",
            "        flow_expr_arr.append(\"hard_timeout=%s\" %",
            "                             flow_dict.pop('hard_timeout', '0'))",
            "        flow_expr_arr.append(\"idle_timeout=%s\" %",
            "                             flow_dict.pop('idle_timeout', '0'))",
            "        flow_expr_arr.append(\"priority=%s\" %",
            "                             flow_dict.pop('priority', '1'))",
            "    elif 'priority' in flow_dict:",
            "        if not strict:",
            "            msg = _(\"Cannot match priority on flow deletion or modification \"",
            "                    \"without 'strict'\")",
            "            raise exceptions.InvalidInput(error_message=msg)",
            "",
            "    if cmd != 'del':",
            "        if \"actions\" not in flow_dict:",
            "            msg = _(\"Must specify one or more actions on flow addition\"",
            "                    \" or modification\")",
            "            raise exceptions.InvalidInput(error_message=msg)",
            "        actions = \"actions=%s\" % flow_dict.pop('actions')",
            "",
            "    for key, value in flow_dict.items():",
            "        if key == 'proto':",
            "            flow_expr_arr.append(value)",
            "        else:",
            "            flow_expr_arr.append(\"%s=%s\" % (key, str(value)))",
            "",
            "    if actions:",
            "        flow_expr_arr.append(actions)",
            "",
            "    return ','.join(flow_expr_arr)",
            "",
            "",
            "def generate_random_cookie():",
            "    # The OpenFlow spec forbids use of -1",
            "    return random.randrange(UINT64_BITMASK)",
            "",
            "",
            "def check_cookie_mask(cookie):",
            "    cookie = str(cookie)",
            "    if '/' not in cookie:",
            "        return cookie + '/-1'",
            "    else:",
            "        return cookie",
            "",
            "",
            "def is_a_flow_line(line):",
            "    # this is used to filter out from ovs-ofctl dump-flows the lines that",
            "    # are not flow descriptions but mere indications of the type of openflow",
            "    # message that was used ; e.g.:",
            "    #",
            "    # # ovs-ofctl dump-flows br-int",
            "    # NXST_FLOW reply (xid=0x4):",
            "    #  cookie=0xb7dff131a697c6a5, duration=2411726.809s, table=0, ...",
            "    #  cookie=0xb7dff131a697c6a5, duration=2411726.786s, table=23, ...",
            "    #  cookie=0xb7dff131a697c6a5, duration=2411726.760s, table=24, ...",
            "    #",
            "    return 'NXST' not in line and 'OFPST' not in line"
        ],
        "afterPatchFile": [
            "# Copyright 2011 VMware, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import functools",
            "import itertools",
            "import operator",
            "import random",
            "import time",
            "import uuid",
            "",
            "from neutron_lib import constants as p_const",
            "from neutron_lib import exceptions",
            "from neutron_lib.services.qos import constants as qos_constants",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "from oslo_utils import uuidutils",
            "from ovsdbapp.backend.ovs_idl import idlutils",
            "",
            "import debtcollector",
            "import tenacity",
            "",
            "from neutron._i18n import _",
            "from neutron.agent.common import ip_lib",
            "from neutron.agent.common import utils",
            "from neutron.agent.ovsdb import impl_idl",
            "from neutron.common import _constants as common_constants",
            "from neutron.common import utils as common_utils",
            "from neutron.conf.agent import ovs_conf",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common \\",
            "    import constants",
            "",
            "UINT64_BITMASK = (1 << 64) - 1",
            "",
            "# Special return value for an invalid OVS ofport",
            "INVALID_OFPORT = -1",
            "UNASSIGNED_OFPORT = []",
            "",
            "# OVS bridge fail modes",
            "FAILMODE_SECURE = 'secure'",
            "FAILMODE_STANDALONE = 'standalone'",
            "",
            "# special values for cookies",
            "COOKIE_ANY = object()",
            "",
            "ovs_conf.register_ovs_agent_opts()",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "OVS_DEFAULT_CAPS = {",
            "    'datapath_types': [],",
            "    'iface_types': [],",
            "}",
            "",
            "# It's default queue, all packets not tagged with 'set_queue' will go through",
            "# this one",
            "QOS_DEFAULT_QUEUE = 0",
            "",
            "_SENTINEL = object()",
            "",
            "CTRL_RATE_LIMIT_MIN = 100",
            "CTRL_BURST_LIMIT_MIN = 25",
            "",
            "",
            "def _ovsdb_result_pending(result):",
            "    \"\"\"Return True if ovsdb indicates the result is still pending.\"\"\"",
            "    # ovsdb can return '[]' for an ofport that has not yet been assigned",
            "    return result == []",
            "",
            "",
            "def _ovsdb_retry(fn):",
            "    \"\"\"Decorator for retrying when OVS has yet to assign an ofport.",
            "",
            "    The instance's ovsdb_timeout is used as the max waiting time. This relies",
            "    on the fact that instance methods receive self as the first argument.",
            "    \"\"\"",
            "    @functools.wraps(fn)",
            "    def wrapped(*args, **kwargs):",
            "        self = args[0]",
            "        new_fn = tenacity.retry(",
            "            reraise=True,",
            "            retry=tenacity.retry_if_result(_ovsdb_result_pending),",
            "            wait=tenacity.wait_exponential(multiplier=0.02, max=1),",
            "            stop=tenacity.stop_after_delay(",
            "                self.ovsdb_timeout))(fn)",
            "        return new_fn(*args, **kwargs)",
            "    return wrapped",
            "",
            "",
            "class VifPort(object):",
            "    def __init__(self, port_name, ofport, vif_id, vif_mac, switch):",
            "        self.port_name = port_name",
            "        self.ofport = ofport",
            "        self.vif_id = vif_id",
            "        self.vif_mac = vif_mac",
            "        self.switch = switch",
            "",
            "    def __str__(self):",
            "        return (\"iface-id=%s, vif_mac=%s, port_name=%s, ofport=%s, \"",
            "                \"bridge_name=%s\") % (",
            "                    self.vif_id, self.vif_mac,",
            "                    self.port_name, self.ofport,",
            "                    self.switch.br_name)",
            "",
            "",
            "class BaseOVS(object):",
            "",
            "    def __init__(self):",
            "        self.ovsdb = impl_idl.api_factory()",
            "        self._hw_offload = None",
            "",
            "    @property",
            "    def ovsdb_timeout(self):",
            "        return self.ovsdb.ovsdb_connection.timeout",
            "",
            "    def add_bridge(self, bridge_name,",
            "                   datapath_type=constants.OVS_DATAPATH_SYSTEM):",
            "        br = OVSBridge(bridge_name, datapath_type=datapath_type)",
            "        br.create()",
            "        return br",
            "",
            "    def delete_bridge(self, bridge_name):",
            "        self.ovsdb.del_br(bridge_name).execute()",
            "",
            "    def bridge_exists(self, bridge_name):",
            "        return self.ovsdb.br_exists(bridge_name).execute()",
            "",
            "    def port_exists(self, port_name):",
            "        cmd = self.ovsdb.db_get('Port', port_name, 'name')",
            "        return bool(cmd.execute(check_error=False, log_errors=False))",
            "",
            "    def get_bridge_for_iface(self, iface):",
            "        return self.ovsdb.iface_to_br(iface).execute()",
            "",
            "    def get_bridges(self):",
            "        return self.ovsdb.list_br().execute(check_error=True)",
            "",
            "    def get_bridge_external_bridge_id(self, bridge, check_error=False,",
            "                                      log_errors=True):",
            "        return self.ovsdb.br_get_external_id(bridge, 'bridge-id').execute(",
            "            check_error=check_error, log_errors=log_errors)",
            "",
            "    def set_db_attribute(self, table_name, record, column, value,",
            "                         check_error=False, log_errors=True):",
            "        self.ovsdb.db_set(table_name, record, (column, value)).execute(",
            "            check_error=check_error, log_errors=log_errors)",
            "",
            "    def clear_db_attribute(self, table_name, record, column):",
            "        self.ovsdb.db_clear(table_name, record, column).execute()",
            "",
            "    def db_get_val(self, table, record, column, check_error=False,",
            "                   log_errors=True):",
            "        return self.ovsdb.db_get(table, record, column).execute(",
            "            check_error=check_error, log_errors=log_errors)",
            "",
            "    @property",
            "    def config(self):",
            "        \"\"\"A dict containing the only row from the root Open_vSwitch table",
            "",
            "        This row contains several columns describing the Open vSwitch install",
            "        and the system on which it is installed. Useful keys include:",
            "            datapath_types: a list of supported datapath types",
            "            iface_types: a list of supported interface types",
            "            ovs_version: the OVS version",
            "        \"\"\"",
            "        return self.ovsdb.db_list(\"Open_vSwitch\").execute()[0]",
            "",
            "    @property",
            "    def capabilities(self):",
            "        _cfg = self.config",
            "        return {k: _cfg.get(k, OVS_DEFAULT_CAPS[k]) for k in OVS_DEFAULT_CAPS}",
            "",
            "    @property",
            "    def is_hw_offload_enabled(self):",
            "        if self._hw_offload is None:",
            "            self._hw_offload = self.config.get('other_config',",
            "                                   {}).get('hw-offload', '').lower() == 'true'",
            "        return self._hw_offload",
            "",
            "",
            "# Map from version string to on-the-wire protocol version encoding:",
            "OF_PROTOCOL_TO_VERSION = {",
            "    constants.OPENFLOW10: 1,",
            "    constants.OPENFLOW11: 2,",
            "    constants.OPENFLOW12: 3,",
            "    constants.OPENFLOW13: 4,",
            "    constants.OPENFLOW14: 5,",
            "    constants.OPENFLOW15: 6,",
            "}",
            "",
            "",
            "def version_from_protocol(protocol):",
            "    if protocol not in OF_PROTOCOL_TO_VERSION:",
            "        raise Exception(_(\"unknown OVS protocol string, cannot compare: \"",
            "                          \"%(protocol)s, (known: %(known)s)\") %",
            "                        {'protocol': protocol,",
            "                         'known': list(OF_PROTOCOL_TO_VERSION)})",
            "    return OF_PROTOCOL_TO_VERSION[protocol]",
            "",
            "",
            "class OVSBridge(BaseOVS):",
            "    def __init__(self, br_name, datapath_type=constants.OVS_DATAPATH_SYSTEM):",
            "        super(OVSBridge, self).__init__()",
            "        self.br_name = br_name",
            "        self.datapath_type = datapath_type",
            "        self._default_cookie = generate_random_cookie()",
            "        self._highest_protocol_needed = constants.OPENFLOW10",
            "        self._min_bw_qos_id = uuidutils.generate_uuid()",
            "        # TODO(jlibosva): Revert initial_protocols once launchpad bug 1852221",
            "        #                 is fixed and new openvswitch containing the fix is",
            "        #                 released.",
            "        self.initial_protocols = {",
            "            constants.OPENFLOW10, constants.OPENFLOW13, constants.OPENFLOW14}",
            "        self.initial_protocols.add(self._highest_protocol_needed)",
            "",
            "    @property",
            "    def default_cookie(self):",
            "        return self._default_cookie",
            "",
            "    def set_agent_uuid_stamp(self, val):",
            "        self._default_cookie = val",
            "",
            "    def set_controller(self, controllers):",
            "        self.ovsdb.set_controller(self.br_name,",
            "                                  controllers).execute(check_error=True)",
            "",
            "    def del_controller(self):",
            "        self.ovsdb.del_controller(self.br_name).execute(check_error=True)",
            "",
            "    def get_controller(self):",
            "        return self.ovsdb.get_controller(self.br_name).execute(",
            "            check_error=True)",
            "",
            "    def _set_bridge_fail_mode(self, mode):",
            "        self.ovsdb.set_fail_mode(self.br_name, mode).execute(check_error=True)",
            "",
            "    def set_secure_mode(self):",
            "        self._set_bridge_fail_mode(FAILMODE_SECURE)",
            "",
            "    def set_standalone_mode(self):",
            "        self._set_bridge_fail_mode(FAILMODE_STANDALONE)",
            "",
            "    def add_protocols(self, *protocols):",
            "        self.ovsdb.db_add('Bridge', self.br_name,",
            "                          'protocols', *protocols).execute(check_error=True)",
            "",
            "    def use_at_least_protocol(self, protocol):",
            "        \"\"\"Calls to ovs-ofctl will use a protocol version >= 'protocol'\"\"\"",
            "        self.add_protocols(protocol)",
            "        self._highest_protocol_needed = max(self._highest_protocol_needed,",
            "                                            protocol,",
            "                                            key=version_from_protocol)",
            "        self.initial_protocols.add(self._highest_protocol_needed)",
            "",
            "    def set_igmp_snooping_state(self, state):",
            "        state = bool(state)",
            "        other_config = {",
            "            'mcast-snooping-disable-flood-unregistered': str(state)}",
            "        with self.ovsdb.transaction() as txn:",
            "            txn.add(",
            "                self.ovsdb.db_set('Bridge', self.br_name,",
            "                                  ('mcast_snooping_enable', state)))",
            "            txn.add(",
            "                self.ovsdb.db_set('Bridge', self.br_name,",
            "                                  ('other_config', other_config)))",
            "",
            "    def create(self, secure_mode=False):",
            "        other_config = {",
            "            'mac-table-size': str(cfg.CONF.OVS.bridge_mac_table_size)}",
            "        with self.ovsdb.transaction() as txn:",
            "            txn.add(",
            "                self.ovsdb.add_br(self.br_name,",
            "                                  datapath_type=self.datapath_type))",
            "            # the ovs-ofctl commands below in run_ofctl use OF10, so we",
            "            # need to ensure that this version is enabled ; we could reuse",
            "            # add_protocols, but doing ovsdb.db_add avoids doing two",
            "            # transactions",
            "            txn.add(",
            "                self.ovsdb.db_add('Bridge', self.br_name,",
            "                                  'protocols',",
            "                                  *self.initial_protocols))",
            "            txn.add(",
            "                self.ovsdb.db_set('Bridge', self.br_name,",
            "                                  ('other_config', other_config)))",
            "            if secure_mode:",
            "                txn.add(self.ovsdb.set_fail_mode(self.br_name,",
            "                                                 FAILMODE_SECURE))",
            "",
            "    def destroy(self):",
            "        self.delete_bridge(self.br_name)",
            "",
            "    def add_port(self, port_name, *interface_attr_tuples):",
            "        with self.ovsdb.transaction() as txn:",
            "            txn.add(self.ovsdb.add_port(self.br_name, port_name))",
            "            if interface_attr_tuples:",
            "                txn.add(self.ovsdb.db_set('Interface', port_name,",
            "                                          *interface_attr_tuples))",
            "        return self.get_port_ofport(port_name)",
            "",
            "    def replace_port(self, port_name, *interface_attr_tuples):",
            "        \"\"\"Replace existing port or create it, and configure port interface.\"\"\"",
            "",
            "        # NOTE(xiaohhui): If del_port is inside the transaction, there will",
            "        # only be one command for replace_port. This will cause the new port",
            "        # not be found by system, which will lead to Bug #1519926.",
            "        self.ovsdb.del_port(port_name).execute()",
            "        with self.ovsdb.transaction() as txn:",
            "            txn.add(self.ovsdb.add_port(self.br_name, port_name,",
            "                                        may_exist=False))",
            "            # NOTE(mangelajo): Port is added to dead vlan (4095) by default",
            "            # until it's handled by the neutron-openvswitch-agent. Otherwise it",
            "            # becomes a trunk port on br-int (receiving traffic for all vlans),",
            "            # and also triggers issues on ovs-vswitchd related to the",
            "            # datapath flow revalidator thread, see lp#1767422",
            "            txn.add(self.ovsdb.db_set(",
            "                    'Port', port_name, ('tag', constants.DEAD_VLAN_TAG)))",
            "",
            "            # TODO(mangelajo): We could accept attr tuples for the Port too",
            "            # but, that could potentially break usage of this function in",
            "            # stable branches (where we need to backport).",
            "            # https://review.opendev.org/#/c/564825/4/neutron/agent/common/",
            "            # ovs_lib.py@289",
            "            if interface_attr_tuples:",
            "                txn.add(self.ovsdb.db_set('Interface', port_name,",
            "                                          *interface_attr_tuples))",
            "",
            "    def delete_port(self, port_name):",
            "        self.ovsdb.del_port(port_name, self.br_name).execute()",
            "",
            "    def run_ofctl(self, cmd, args, process_input=None):",
            "        debtcollector.deprecate(\"Use of run_ofctl is \"",
            "            \"deprecated\", removal_version='V')",
            "        full_args = [\"ovs-ofctl\", cmd,",
            "                     \"-O\", self._highest_protocol_needed,",
            "                     self.br_name] + args",
            "        # TODO(kevinbenton): This error handling is really brittle and only",
            "        # detects one specific type of failure. The callers of this need to",
            "        # be refactored to expect errors so we can re-raise and they can",
            "        # take appropriate action based on the type of error.",
            "        for i in range(1, 11):",
            "            try:",
            "                return utils.execute(full_args, run_as_root=True,",
            "                                     process_input=process_input)",
            "            except Exception as e:",
            "                if \"failed to connect to socket\" in str(e):",
            "                    LOG.debug(\"Failed to connect to OVS. Retrying \"",
            "                              \"in 1 second. Attempt: %s/10\", i)",
            "                    time.sleep(1)",
            "                    continue",
            "                LOG.error(\"Unable to execute %(cmd)s. Exception: \"",
            "                          \"%(exception)s\",",
            "                          {'cmd': full_args, 'exception': e})",
            "                break",
            "",
            "    def count_flows(self):",
            "        flow_list = self.run_ofctl(\"dump-flows\", []).split(\"\\n\")[1:]",
            "        return len(flow_list) - 1",
            "",
            "    def remove_all_flows(self):",
            "        self.run_ofctl(\"del-flows\", [])",
            "",
            "    @_ovsdb_retry",
            "    def _get_port_val(self, port_name, port_val):",
            "        return self.db_get_val(\"Interface\", port_name, port_val)",
            "",
            "    def get_port_ofport(self, port_name):",
            "        \"\"\"Get the port's assigned ofport, retrying if not yet assigned.\"\"\"",
            "        ofport = INVALID_OFPORT",
            "        try:",
            "            ofport = self._get_port_val(port_name, \"ofport\")",
            "        except tenacity.RetryError:",
            "            LOG.exception(\"Timed out retrieving ofport on port %s.\",",
            "                          port_name)",
            "        return ofport",
            "",
            "    @_ovsdb_retry",
            "    def _get_datapath_id(self):",
            "        return self.db_get_val('Bridge', self.br_name, 'datapath_id')",
            "",
            "    def get_datapath_id(self):",
            "        try:",
            "            return self._get_datapath_id()",
            "        except tenacity.RetryError:",
            "            # if ovs fails to find datapath_id then something is likely to be",
            "            # broken here",
            "            LOG.exception(\"Timed out retrieving datapath_id on bridge %s.\",",
            "                          self.br_name)",
            "            raise RuntimeError(_('No datapath_id on bridge %s') % self.br_name)",
            "",
            "    def do_action_flows(self, action, kwargs_list, use_bundle=False):",
            "        # we can't mix strict and non-strict, so we'll use the first kw",
            "        # and check against other kw being different",
            "        strict = kwargs_list[0].get('strict', False)",
            "",
            "        for kw in kwargs_list:",
            "            if action == 'del':",
            "                if kw.get('cookie') == COOKIE_ANY:",
            "                    # special value COOKIE_ANY was provided, unset",
            "                    # cookie to match flows whatever their cookie is",
            "                    kw.pop('cookie')",
            "                    if kw.get('cookie_mask'):  # non-zero cookie mask",
            "                        raise Exception(_(\"cookie=COOKIE_ANY but cookie_mask \"",
            "                                          \"set to %s\") % kw.get('cookie_mask'))",
            "                elif 'cookie' in kw:",
            "                    # a cookie was specified, use it",
            "                    kw['cookie'] = check_cookie_mask(kw['cookie'])",
            "                else:",
            "                    # nothing was specified about cookies, use default",
            "                    kw['cookie'] = \"%d/-1\" % self._default_cookie",
            "            else:",
            "                if 'cookie' not in kw:",
            "                    kw['cookie'] = self._default_cookie",
            "",
            "            if action in ('mod', 'del'):",
            "                if kw.pop('strict', False) != strict:",
            "                    msg = (\"cannot mix 'strict' and not 'strict' in a batch \"",
            "                           \"call\")",
            "                    raise exceptions.InvalidInput(error_message=msg)",
            "            else:",
            "                if kw.pop('strict', False):",
            "                    msg = \"cannot use 'strict' with 'add' action\"",
            "                    raise exceptions.InvalidInput(error_message=msg)",
            "",
            "        extra_param = [\"--strict\"] if strict else []",
            "",
            "        if action == 'del' and {} in kwargs_list:",
            "            # the 'del' case simplifies itself if kwargs_list has at least",
            "            # one item that matches everything",
            "            self.run_ofctl('%s-flows' % action, [])",
            "        else:",
            "            flow_strs = [_build_flow_expr_str(kw, action, strict)",
            "                         for kw in kwargs_list]",
            "            LOG.debug(\"Processing %d OpenFlow rules.\", len(flow_strs))",
            "            if use_bundle:",
            "                extra_param.append('--bundle')",
            "",
            "            step = common_constants.AGENT_RES_PROCESSING_STEP",
            "            for i in range(0, len(flow_strs), step):",
            "                self.run_ofctl('%s-flows' % action, extra_param + ['-'],",
            "                               '\\n'.join(flow_strs[i:i + step]))",
            "",
            "    def add_flow(self, **kwargs):",
            "        self.do_action_flows('add', [kwargs])",
            "",
            "    def mod_flow(self, **kwargs):",
            "        self.do_action_flows('mod', [kwargs])",
            "",
            "    def delete_flows(self, **kwargs):",
            "        self.do_action_flows('del', [kwargs])",
            "",
            "    def dump_flows_for_table(self, table):",
            "        return self.dump_flows_for(table=table)",
            "",
            "    def dump_flows_for(self, **kwargs):",
            "        retval = None",
            "        if \"cookie\" in kwargs:",
            "            kwargs[\"cookie\"] = check_cookie_mask(str(kwargs[\"cookie\"]))",
            "        flow_str = \",\".join(\"=\".join([key, str(val)])",
            "                            for key, val in kwargs.items())",
            "",
            "        flows = self.run_ofctl(\"dump-flows\", [flow_str])",
            "        if flows:",
            "            retval = '\\n'.join(item for item in flows.splitlines()",
            "                               if is_a_flow_line(item))",
            "        return retval",
            "",
            "    def dump_all_flows(self):",
            "        return [f for f in self.run_ofctl(\"dump-flows\", []).splitlines()",
            "                if is_a_flow_line(f)]",
            "",
            "    def deferred(self, *args, **kwargs):",
            "        return DeferredOVSBridge(self, *args, **kwargs)",
            "",
            "    def add_tunnel_port(self, port_name, remote_ip, local_ip,",
            "                        tunnel_type=p_const.TYPE_GRE,",
            "                        vxlan_udp_port=p_const.VXLAN_UDP_PORT,",
            "                        dont_fragment=True,",
            "                        tunnel_csum=False,",
            "                        tos=None):",
            "        attrs = [('type', tunnel_type)]",
            "        # TODO(twilson) This is an OrderedDict solely to make a test happy",
            "        options = collections.OrderedDict()",
            "        vxlan_uses_custom_udp_port = (",
            "            tunnel_type == p_const.TYPE_VXLAN and",
            "            vxlan_udp_port != p_const.VXLAN_UDP_PORT",
            "        )",
            "        if vxlan_uses_custom_udp_port:",
            "            options['dst_port'] = str(vxlan_udp_port)",
            "        options['df_default'] = str(dont_fragment).lower()",
            "        options['remote_ip'] = remote_ip",
            "        options['local_ip'] = local_ip",
            "        options['in_key'] = 'flow'",
            "        options['out_key'] = 'flow'",
            "        # NOTE(moshele): pkt_mark is not upported when using ovs hw-offload,",
            "        # therefore avoid clear mark on encapsulating packets when it's",
            "        # enabled",
            "        if not self.is_hw_offload_enabled:",
            "            options['egress_pkt_mark'] = '0'",
            "        if tunnel_csum:",
            "            options['csum'] = str(tunnel_csum).lower()",
            "        if tos:",
            "            options['tos'] = str(tos)",
            "        attrs.append(('options', options))",
            "",
            "        return self.add_port(port_name, *attrs)",
            "",
            "    def add_patch_port(self, local_name, remote_name):",
            "        attrs = [('type', 'patch'),",
            "                 ('options', {'peer': remote_name})]",
            "        return self.add_port(local_name, *attrs)",
            "",
            "    def get_iface_name_list(self):",
            "        # get the interface name list for this bridge",
            "        return self.ovsdb.list_ifaces(self.br_name).execute(check_error=True)",
            "",
            "    def get_port_name_list(self):",
            "        # get the port name list for this bridge",
            "        return self.ovsdb.list_ports(self.br_name).execute(check_error=True)",
            "",
            "    def get_port_stats(self, port_name):",
            "        return self.db_get_val(\"Interface\", port_name, \"statistics\")",
            "",
            "    def get_ports_attributes(self, table, columns=None, ports=None,",
            "                             check_error=True, log_errors=True,",
            "                             if_exists=False):",
            "        port_names = ports or self.get_port_name_list()",
            "        if not port_names:",
            "            return []",
            "        return (self.ovsdb.db_list(table, port_names, columns=columns,",
            "                                   if_exists=if_exists).",
            "                execute(check_error=check_error, log_errors=log_errors))",
            "",
            "    # returns a VIF object for each VIF port",
            "    def get_vif_ports(self, ofport_filter=None):",
            "        edge_ports = []",
            "        port_info = self.get_ports_attributes(",
            "            'Interface', columns=['name', 'external_ids', 'ofport'],",
            "            if_exists=True)",
            "        for port in port_info:",
            "            name = port['name']",
            "            external_ids = port['external_ids']",
            "            ofport = port['ofport']",
            "            if ofport_filter and ofport in ofport_filter:",
            "                continue",
            "            if \"iface-id\" in external_ids and \"attached-mac\" in external_ids:",
            "                p = VifPort(name, ofport, external_ids[\"iface-id\"],",
            "                            external_ids[\"attached-mac\"], self)",
            "                edge_ports.append(p)",
            "",
            "        return edge_ports",
            "",
            "    def get_vif_port_to_ofport_map(self):",
            "        results = self.get_ports_attributes(",
            "            'Interface', columns=['name', 'external_ids', 'ofport'],",
            "            if_exists=True)",
            "        port_map = {}",
            "        for r in results:",
            "            # fall back to basic interface name",
            "            key = self.portid_from_external_ids(r['external_ids']) or r['name']",
            "            try:",
            "                port_map[key] = int(r['ofport'])",
            "            except TypeError:",
            "                # port doesn't yet have an ofport entry so we ignore it",
            "                pass",
            "        return port_map",
            "",
            "    def get_vif_port_set(self):",
            "        edge_ports = set()",
            "        results = self.get_ports_attributes(",
            "            'Interface', columns=['name', 'external_ids', 'ofport'],",
            "            if_exists=True)",
            "        for result in results:",
            "            if result['ofport'] == UNASSIGNED_OFPORT:",
            "                LOG.warning(\"Found not yet ready openvswitch port: %s\",",
            "                            result['name'])",
            "            elif result['ofport'] == INVALID_OFPORT:",
            "                LOG.warning(\"Found failed openvswitch port: %s\",",
            "                            result['name'])",
            "            elif 'attached-mac' in result['external_ids']:",
            "                port_id = self.portid_from_external_ids(result['external_ids'])",
            "                if port_id:",
            "                    edge_ports.add(port_id)",
            "        return edge_ports",
            "",
            "    def portid_from_external_ids(self, external_ids):",
            "        if 'iface-id' in external_ids:",
            "            return external_ids['iface-id']",
            "",
            "    def get_port_tag_dict(self):",
            "        \"\"\"Get a dict of port names and associated vlan tags.",
            "",
            "        e.g. the returned dict is of the following form::",
            "",
            "            {u'int-br-eth2': [],",
            "             u'patch-tun': [],",
            "             u'qr-76d9e6b6-21': 1,",
            "             u'tapce5318ff-78': 1,",
            "             u'tape1400310-e6': 1}",
            "",
            "        The TAG ID is only available in the \"Port\" table and is not available",
            "        in the \"Interface\" table queried by the get_vif_port_set() method.",
            "",
            "        \"\"\"",
            "        results = self.get_ports_attributes(",
            "            'Port', columns=['name', 'tag'], if_exists=True)",
            "        return {p['name']: p['tag'] for p in results}",
            "",
            "    def get_vifs_by_ids(self, port_ids):",
            "        interface_info = self.get_ports_attributes(",
            "            \"Interface\", columns=[\"name\", \"external_ids\", \"ofport\"],",
            "            if_exists=True)",
            "        by_id = {x['external_ids'].get('iface-id'): x for x in interface_info}",
            "        result = {}",
            "        for port_id in port_ids:",
            "            result[port_id] = None",
            "            if port_id not in by_id:",
            "                LOG.info(\"Port %(port_id)s not present in bridge \"",
            "                         \"%(br_name)s\",",
            "                         {'port_id': port_id, 'br_name': self.br_name})",
            "                continue",
            "            pinfo = by_id[port_id]",
            "            mac = pinfo['external_ids'].get('attached-mac')",
            "            result[port_id] = VifPort(pinfo['name'], pinfo['ofport'],",
            "                                      port_id, mac, self)",
            "        return result",
            "",
            "    def get_vif_port_by_id(self, port_id):",
            "        ports = self.ovsdb.db_find(",
            "            'Interface', ('external_ids', '=', {'iface-id': port_id}),",
            "            ('external_ids', '!=', {'attached-mac': ''}),",
            "            columns=['external_ids', 'name', 'ofport']).execute()",
            "        for port in ports:",
            "            if self.br_name != self.get_bridge_for_iface(port['name']):",
            "                continue",
            "            mac = port['external_ids'].get('attached-mac')",
            "            return VifPort(port['name'], port['ofport'], port_id, mac, self)",
            "        LOG.info(\"Port %(port_id)s not present in bridge %(br_name)s\",",
            "                 {'port_id': port_id, 'br_name': self.br_name})",
            "",
            "    def delete_ports(self, all_ports=False):",
            "        if all_ports:",
            "            port_names = self.get_port_name_list()",
            "        else:",
            "            port_names = (port.port_name for port in self.get_vif_ports())",
            "",
            "        for port_name in port_names:",
            "            self.delete_port(port_name)",
            "",
            "    def get_local_port_mac(self):",
            "        \"\"\"Retrieve the mac of the bridge's local port.\"\"\"",
            "        address = ip_lib.IPDevice(self.br_name).link.address",
            "        if address:",
            "            return address",
            "        else:",
            "            msg = _('Unable to determine mac address for %s') % self.br_name",
            "            raise Exception(msg)",
            "",
            "    def set_controllers_connection_mode(self, connection_mode):",
            "        \"\"\"Set bridge controllers connection mode.",
            "",
            "        :param connection_mode: \"out-of-band\" or \"in-band\"",
            "        \"\"\"",
            "        self.set_controller_field('connection_mode', connection_mode)",
            "",
            "    def set_controllers_inactivity_probe(self, interval):",
            "        \"\"\"Set bridge controllers inactivity probe interval.",
            "",
            "        :param interval: inactivity_probe value in seconds.",
            "        \"\"\"",
            "        self.set_controller_field('inactivity_probe', interval * 1000)",
            "",
            "    def _set_egress_bw_limit_for_port(self, port_name, max_kbps,",
            "                                      max_burst_kbps, check_error=True):",
            "        with self.ovsdb.transaction(check_error=check_error) as txn:",
            "            txn.add(self.ovsdb.db_set('Interface', port_name,",
            "                                      ('ingress_policing_rate', max_kbps)))",
            "            txn.add(self.ovsdb.db_set('Interface', port_name,",
            "                                      ('ingress_policing_burst',",
            "                                       max_burst_kbps)))",
            "",
            "    def create_egress_bw_limit_for_port(self, port_name, max_kbps,",
            "                                        max_burst_kbps):",
            "        self._set_egress_bw_limit_for_port(",
            "            port_name, max_kbps, max_burst_kbps)",
            "",
            "    def get_egress_bw_limit_for_port(self, port_name):",
            "",
            "        max_kbps = self.db_get_val('Interface', port_name,",
            "                                   'ingress_policing_rate')",
            "        max_burst_kbps = self.db_get_val('Interface', port_name,",
            "                                         'ingress_policing_burst')",
            "",
            "        max_kbps = max_kbps or None",
            "        max_burst_kbps = max_burst_kbps or None",
            "",
            "        return max_kbps, max_burst_kbps",
            "",
            "    def delete_egress_bw_limit_for_port(self, port_name):",
            "        if not self.port_exists(port_name):",
            "            return",
            "        self._set_egress_bw_limit_for_port(port_name, 0, 0, check_error=False)",
            "",
            "    def find_qos(self, port_name):",
            "        qos = self.ovsdb.db_find(",
            "            'QoS',",
            "            ('external_ids', '=', {'id': port_name}),",
            "            columns=['_uuid', 'other_config']).execute(check_error=True)",
            "        if qos:",
            "            return qos[0]",
            "",
            "    def find_queue(self, port_name, queue_type):",
            "        queues = self.ovsdb.db_find(",
            "            'Queue',",
            "            ('external_ids', '=', {'id': port_name,",
            "                                   'queue_type': str(queue_type)}),",
            "            columns=['_uuid', 'other_config']).execute(check_error=True)",
            "        if queues:",
            "            return queues[0]",
            "",
            "    def _update_bw_limit_queue(self, txn, port_name, queue_uuid, queue_type,",
            "                               other_config):",
            "        if queue_uuid:",
            "            txn.add(self.ovsdb.db_set(",
            "                'Queue', queue_uuid,",
            "                ('other_config', other_config)))",
            "        else:",
            "            external_ids = {'id': port_name,",
            "                            'queue_type': str(queue_type)}",
            "            queue_uuid = txn.add(",
            "                self.ovsdb.db_create(",
            "                    'Queue', external_ids=external_ids,",
            "                    other_config=other_config))",
            "        return queue_uuid",
            "",
            "    def _update_bw_limit_profile(self, txn, port_name, qos_uuid,",
            "                                 queue_uuid, queue_type, qos_other_config):",
            "        queues = {queue_type: queue_uuid}",
            "        if qos_uuid:",
            "            txn.add(self.ovsdb.db_set(",
            "                'QoS', qos_uuid, ('queues', queues)))",
            "            txn.add(self.ovsdb.db_set(",
            "                'QoS', qos_uuid, ('other_config', qos_other_config)))",
            "        else:",
            "            external_ids = {'id': port_name}",
            "            qos_uuid = txn.add(",
            "                self.ovsdb.db_create(",
            "                    'QoS', external_ids=external_ids,",
            "                    type='linux-htb',",
            "                    queues=queues,",
            "                    other_config=qos_other_config))",
            "        return qos_uuid",
            "",
            "    def _update_bw_limit_profile_dpdk(self, txn, port_name, qos_uuid,",
            "                                      other_config):",
            "        if qos_uuid:",
            "            txn.add(self.ovsdb.db_set(",
            "                'QoS', qos_uuid, ('other_config', other_config)))",
            "        else:",
            "            external_ids = {'id': port_name}",
            "            qos_uuid = txn.add(",
            "                self.ovsdb.db_create(",
            "                    'QoS', external_ids=external_ids, type='egress-policer',",
            "                    other_config=other_config))",
            "        return qos_uuid",
            "",
            "    def _update_ingress_bw_limit_for_port(",
            "            self, port_name, max_bw_in_bits, max_burst_in_bits):",
            "        qos_other_config = {",
            "            'max-rate': str(max_bw_in_bits)",
            "        }",
            "        queue_other_config = {",
            "            'max-rate': str(max_bw_in_bits),",
            "            'burst': str(max_burst_in_bits),",
            "        }",
            "        qos = self.find_qos(port_name)",
            "        queue = self.find_queue(port_name, QOS_DEFAULT_QUEUE)",
            "        qos_uuid = qos['_uuid'] if qos else None",
            "        queue_uuid = queue['_uuid'] if queue else None",
            "        with self.ovsdb.transaction(check_error=True) as txn:",
            "            queue_uuid = self._update_bw_limit_queue(",
            "                txn, port_name, queue_uuid, QOS_DEFAULT_QUEUE,",
            "                queue_other_config",
            "            )",
            "",
            "            qos_uuid = self._update_bw_limit_profile(",
            "                txn, port_name, qos_uuid, queue_uuid, QOS_DEFAULT_QUEUE,",
            "                qos_other_config",
            "            )",
            "",
            "            txn.add(self.ovsdb.db_set(",
            "                'Port', port_name, ('qos', qos_uuid)))",
            "",
            "    def _update_ingress_bw_limit_for_dpdk_port(",
            "            self, port_name, max_bw_in_bits, max_burst_in_bits):",
            "        # cir and cbs should be set in bytes instead of bits",
            "        qos_other_config = {",
            "            'cir': str(max_bw_in_bits / 8),",
            "            'cbs': str(max_burst_in_bits / 8)",
            "        }",
            "        qos = self.find_qos(port_name)",
            "        qos_uuid = qos['_uuid'] if qos else None",
            "        with self.ovsdb.transaction(check_error=True) as txn:",
            "            qos_uuid = self._update_bw_limit_profile_dpdk(",
            "                txn, port_name, qos_uuid, qos_other_config)",
            "            txn.add(self.ovsdb.db_set(",
            "                'Port', port_name, ('qos', qos_uuid)))",
            "",
            "    def update_ingress_bw_limit_for_port(self, port_name, max_kbps,",
            "                                         max_burst_kbps):",
            "        max_bw_in_bits = max_kbps * p_const.SI_BASE",
            "        max_burst_in_bits = max_burst_kbps * p_const.SI_BASE",
            "        port_type = self._get_port_val(port_name, \"type\")",
            "        if port_type in constants.OVS_DPDK_PORT_TYPES:",
            "            self._update_ingress_bw_limit_for_dpdk_port(",
            "                port_name, max_bw_in_bits, max_burst_in_bits)",
            "        else:",
            "            self._update_ingress_bw_limit_for_port(",
            "                port_name, max_bw_in_bits, max_burst_in_bits)",
            "",
            "    def get_ingress_bw_limit_for_port(self, port_name):",
            "        max_kbps = None",
            "        qos_max_kbps = None",
            "        queue_max_kbps = None",
            "        max_burst_kbit = None",
            "",
            "        qos_res = self.find_qos(port_name)",
            "        if qos_res:",
            "            other_config = qos_res['other_config']",
            "            max_bw_in_bits = other_config.get('max-rate')",
            "            if max_bw_in_bits is not None:",
            "                qos_max_kbps = int(max_bw_in_bits) / p_const.SI_BASE",
            "",
            "        queue_res = self.find_queue(port_name, QOS_DEFAULT_QUEUE)",
            "        if queue_res:",
            "            other_config = queue_res['other_config']",
            "            max_bw_in_bits = other_config.get('max-rate')",
            "            if max_bw_in_bits is not None:",
            "                queue_max_kbps = int(max_bw_in_bits) / p_const.SI_BASE",
            "            max_burst_in_bits = other_config.get('burst')",
            "            if max_burst_in_bits is not None:",
            "                max_burst_kbit = (",
            "                    int(max_burst_in_bits) / p_const.SI_BASE)",
            "",
            "        if qos_max_kbps == queue_max_kbps:",
            "            max_kbps = qos_max_kbps",
            "        else:",
            "            LOG.warning(\"qos max-rate %(qos_max_kbps)s is not equal to \"",
            "                        \"queue max-rate %(queue_max_kbps)s\",",
            "                        {'qos_max_kbps': qos_max_kbps,",
            "                         'queue_max_kbps': queue_max_kbps})",
            "        return max_kbps, max_burst_kbit",
            "",
            "    def get_ingress_bw_limit_for_dpdk_port(self, port_name):",
            "        max_kbps = None",
            "        max_burst_kbit = None",
            "        res = self.find_qos(port_name)",
            "        if res:",
            "            other_config = res['other_config']",
            "            max_bw_in_bytes = other_config.get(\"cir\")",
            "            if max_bw_in_bytes is not None:",
            "                max_kbps = common_utils.bits_to_kilobits(",
            "                    common_utils.bytes_to_bits(int(float(max_bw_in_bytes))),",
            "                    p_const.SI_BASE)",
            "            max_burst_in_bytes = other_config.get(\"cbs\")",
            "            if max_burst_in_bytes is not None:",
            "                max_burst_kbit = common_utils.bits_to_kilobits(",
            "                    common_utils.bytes_to_bits(int(float(max_burst_in_bytes))),",
            "                    p_const.SI_BASE)",
            "        return max_kbps, max_burst_kbit",
            "",
            "    def delete_ingress_bw_limit_for_port(self, port_name):",
            "        self.ovsdb.db_clear('Port', port_name,",
            "                            'qos').execute(check_error=False)",
            "        qos = self.find_qos(port_name)",
            "        queue = self.find_queue(port_name, QOS_DEFAULT_QUEUE)",
            "        with self.ovsdb.transaction(check_error=True) as txn:",
            "            if qos:",
            "                txn.add(self.ovsdb.db_destroy('QoS', qos['_uuid']))",
            "            if queue:",
            "                txn.add(self.ovsdb.db_destroy('Queue', queue['_uuid']))",
            "",
            "    def set_controller_field(self, field, value):",
            "        attr = [(field, value)]",
            "        controllers = self.db_get_val('Bridge', self.br_name, 'controller')",
            "        controllers = [controllers] if isinstance(",
            "            controllers, uuid.UUID) else controllers",
            "        with self.ovsdb.transaction(check_error=True) as txn:",
            "            for controller_uuid in controllers:",
            "                txn.add(self.ovsdb.db_set(",
            "                    'Controller', controller_uuid, *attr))",
            "",
            "    def set_controller_rate_limit(self, controller_rate_limit):",
            "        \"\"\"Set bridge controller_rate_limit",
            "",
            "        :param controller_rate_limit: at least 100",
            "        \"\"\"",
            "        if controller_rate_limit < CTRL_RATE_LIMIT_MIN:",
            "            LOG.info(\"rate limit's value must be at least 100\")",
            "            controller_rate_limit = CTRL_RATE_LIMIT_MIN",
            "        self.set_controller_field(",
            "            'controller_rate_limit', controller_rate_limit)",
            "",
            "    def set_controller_burst_limit(self, controller_burst_limit):",
            "        \"\"\"Set bridge controller_burst_limit",
            "",
            "        :param controller_burst_limit: at least 25",
            "        \"\"\"",
            "        if controller_burst_limit < CTRL_BURST_LIMIT_MIN:",
            "            LOG.info(\"burst limit's value must be at least 25\")",
            "            controller_burst_limit = CTRL_BURST_LIMIT_MIN",
            "        self.set_controller_field(",
            "            'controller_burst_limit', controller_burst_limit)",
            "",
            "    def set_datapath_id(self, datapath_id):",
            "        dpid_cfg = {'datapath-id': datapath_id}",
            "        self.set_db_attribute('Bridge', self.br_name, 'other_config', dpid_cfg,",
            "                              check_error=True)",
            "",
            "    def get_egress_min_bw_for_port(self, port_id):",
            "        queue = self._find_queue(port_id)",
            "        if not queue:",
            "            return",
            "",
            "        min_bps = queue['other_config'].get('min-rate')",
            "        return int(int(min_bps) / 1000) if min_bps else None",
            "",
            "    def _set_queue_for_minimum_bandwidth(self, queue_num):",
            "        # reg4 is used to memoize if queue was set or not. If it is first visit",
            "        # to table 0 for a packet (i.e. reg4 == 0), set queue and memoize (i.e.",
            "        # load 1 to reg4), then goto table 0 again. The packet will be handled",
            "        # as usual when the second visit to table 0.",
            "        self.add_flow(",
            "            table=constants.LOCAL_SWITCHING,",
            "            in_port=queue_num,",
            "            reg4=0,",
            "            priority=200,",
            "            actions=(\"set_queue:%s,load:1->NXM_NX_REG4[0],\"",
            "                     \"resubmit(,%s)\" % (queue_num, constants.LOCAL_SWITCHING)))",
            "",
            "    def _unset_queue_for_minimum_bandwidth(self, queue_num):",
            "        self.delete_flows(",
            "            table=constants.LOCAL_SWITCHING,",
            "            in_port=queue_num,",
            "            reg4=0)",
            "",
            "    def update_minimum_bandwidth_queue(self, port_id, egress_port_names,",
            "                                       queue_num, min_kbps):",
            "        queue_num = int(queue_num)",
            "        queue_id = self._update_queue(port_id, queue_num, min_kbps=min_kbps)",
            "        qos_id, qos_queues = self._find_qos()",
            "        if qos_queues:",
            "            qos_queues[queue_num] = queue_id",
            "        else:",
            "            qos_queues = {queue_num: queue_id}",
            "        qos_id = self._update_qos(",
            "            qos_id=qos_id, queues=qos_queues)",
            "        for egress_port_name in egress_port_names:",
            "            self._set_port_qos(egress_port_name, qos_id=qos_id)",
            "        self._set_queue_for_minimum_bandwidth(queue_num)",
            "        return qos_id",
            "",
            "    def delete_minimum_bandwidth_queue(self, port_id):",
            "        queue = self._find_queue(port_id)",
            "        if not queue:",
            "            return",
            "        queue_num = int(queue['external_ids']['queue-num'])",
            "        self._unset_queue_for_minimum_bandwidth(queue_num)",
            "        qos_id, qos_queues = self._find_qos()",
            "        if not qos_queues:",
            "            return",
            "        if queue_num in qos_queues.keys():",
            "            qos_queues.pop(queue_num)",
            "            self._update_qos(",
            "                qos_id=qos_id, queues=qos_queues)",
            "            self._delete_queue(queue['_uuid'])",
            "",
            "    def clear_minimum_bandwidth_qos(self):",
            "        qoses = self._list_qos(",
            "            qos_type=qos_constants.RULE_TYPE_MINIMUM_BANDWIDTH)",
            "",
            "        for qos in qoses:",
            "            qos_id = qos['_uuid']",
            "            queues = {num: queue.uuid",
            "                      for num, queue in qos['queues'].items()}",
            "            ports = self.ovsdb.db_find(",
            "                'Port',",
            "                ('qos', '=', qos_id),",
            "                colmuns=['name']).execute(check_error=True)",
            "            for port in ports:",
            "                self._set_port_qos(port['name'])",
            "            self.ovsdb.db_destroy('QoS', qos_id).execute(check_error=True)",
            "            for queue_uuid in queues.values():",
            "                self._delete_queue(queue_uuid)",
            "",
            "    def _update_queue(self, port_id, queue_num, max_kbps=None,",
            "                      max_burst_kbps=None, min_kbps=None):",
            "        other_config = {}",
            "        if max_kbps:",
            "            other_config['max-rate'] = str(max_kbps * 1000)",
            "        if max_burst_kbps:",
            "            other_config['burst'] = str(max_burst_kbps * 1000)",
            "        if min_kbps:",
            "            other_config['min-rate'] = str(min_kbps * 1000)",
            "",
            "        queue = self._find_queue(port_id)",
            "        if queue and queue['_uuid']:",
            "            if queue['other_config'] != other_config:",
            "                self.set_db_attribute('Queue', queue['_uuid'], 'other_config',",
            "                                      other_config, check_error=True)",
            "        else:",
            "            # NOTE(ralonsoh): \"external_ids\" is a map of string-string pairs",
            "            external_ids = {",
            "                'port': str(port_id),",
            "                'type': str(qos_constants.RULE_TYPE_MINIMUM_BANDWIDTH),",
            "                'queue-num': str(queue_num)}",
            "            self.ovsdb.db_create(",
            "                'Queue', other_config=other_config,",
            "                external_ids=external_ids).execute(check_error=True)",
            "            queue = self._find_queue(port_id)",
            "        return queue['_uuid']",
            "",
            "    def _find_queue(self, port_id, _type=None):",
            "        # NOTE(ralonsoh): in ovsdb native library, '{>=}' operator is not",
            "        # implemented yet. This is a workaround: list all queues and compare",
            "        # the external_ids key needed.",
            "        _type = _type or qos_constants.RULE_TYPE_MINIMUM_BANDWIDTH",
            "        queues = self._list_queues(port=port_id, _type=_type)",
            "        if queues:",
            "            return queues[0]",
            "        return None",
            "",
            "    def _list_queues(self, _type=None, port=None):",
            "        queues = self.ovsdb.db_list(",
            "            'Queue',",
            "            columns=['_uuid', 'external_ids', 'other_config']).execute(",
            "            check_error=True)",
            "        if port:",
            "            queues = [queue for queue in queues",
            "                      if queue['external_ids'].get('port') == str(port)]",
            "        if _type:",
            "            queues = [queue for queue in queues",
            "                      if queue['external_ids'].get('type') == str(_type)]",
            "        return queues",
            "",
            "    def _delete_queue(self, queue_id):",
            "        try:",
            "            self.ovsdb.db_destroy('Queue', queue_id).execute(check_error=True)",
            "        except idlutils.RowNotFound:",
            "            LOG.info('OVS Queue %s was already deleted', queue_id)",
            "        except RuntimeError as exc:",
            "            with excutils.save_and_reraise_exception():",
            "                if 'referential integrity violation' not in str(exc):",
            "                    return",
            "                qos_regs = self._list_qos()",
            "                qos_uuids = []",
            "                for qos_reg in qos_regs:",
            "                    queue_nums = [num for num, q in qos_reg['queues'].items()",
            "                                  if q.uuid == queue_id]",
            "                    if queue_nums:",
            "                        qos_uuids.append(str(qos_reg['_uuid']))",
            "                LOG.error('Queue %(queue)s was still in use by the following '",
            "                          'QoS rules: %(qoses)s',",
            "                          {'queue': str(queue_id),",
            "                           'qoses': ', '.join(sorted(qos_uuids))})",
            "",
            "    def _update_qos(self, qos_id=None, queues=None):",
            "        queues = queues or {}",
            "        if not qos_id:",
            "            external_ids = {'id': self._min_bw_qos_id,",
            "                            '_type': qos_constants.RULE_TYPE_MINIMUM_BANDWIDTH}",
            "            self.ovsdb.db_create(",
            "                'QoS',",
            "                type='linux-htb',",
            "                queues=queues,",
            "                external_ids=external_ids).execute(check_error=True)",
            "            qos_id, _ = self._find_qos()",
            "        else:",
            "            self.clear_db_attribute('QoS', qos_id, 'queues')",
            "            if queues:",
            "                self.set_db_attribute('QoS', qos_id, 'queues', queues,",
            "                                      check_error=True)",
            "        return qos_id",
            "",
            "    def _list_qos(self, _id=None, qos_type=None):",
            "        external_ids = {}",
            "        if _id:",
            "            external_ids['id'] = _id",
            "        if qos_type:",
            "            external_ids['_type'] = qos_type",
            "        if external_ids:",
            "            return self.ovsdb.db_find(",
            "                'QoS',",
            "                ('external_ids', '=', external_ids),",
            "                colmuns=['_uuid', 'queues']).execute(check_error=True)",
            "",
            "        return self.ovsdb.db_find(",
            "            'QoS', colmuns=['_uuid', 'queues']).execute(check_error=True)",
            "",
            "    def _find_qos(self):",
            "        qos_regs = self._list_qos(_id=self._min_bw_qos_id)",
            "        if qos_regs:",
            "            queues = {num: queue.uuid",
            "                      for num, queue in qos_regs[0]['queues'].items()}",
            "            return qos_regs[0]['_uuid'], queues",
            "        return None, None",
            "",
            "    def _set_port_qos(self, port_name, qos_id=None):",
            "        if qos_id:",
            "            self.set_db_attribute('Port', port_name, 'qos', qos_id,",
            "                                  check_error=True)",
            "        else:",
            "            self.clear_db_attribute('Port', port_name, 'qos')",
            "",
            "    def get_bridge_ports(self, port_type=None):",
            "        port_names = self.get_port_name_list() + [self.br_name]",
            "        ports = self.get_ports_attributes('Interface',",
            "                                          ports=port_names,",
            "                                          columns=['name', 'type'],",
            "                                          if_exists=True) or []",
            "        if port_type is None:",
            "            return ports",
            "        elif not isinstance(port_type, list):",
            "            port_type = [port_type]",
            "        return [port['name'] for port in ports if port['type'] in port_type]",
            "",
            "    def __enter__(self):",
            "        self.create()",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, exc_tb):",
            "        self.destroy()",
            "",
            "",
            "class DeferredOVSBridge(object):",
            "    '''Deferred OVSBridge.",
            "",
            "    This class wraps add_flow, mod_flow and delete_flows calls to an OVSBridge",
            "    and defers their application until apply_flows call in order to perform",
            "    bulk calls. It wraps also ALLOWED_PASSTHROUGHS calls to avoid mixing",
            "    OVSBridge and DeferredOVSBridge uses.",
            "    This class can be used as a context, in such case apply_flows is called on",
            "    __exit__ except if an exception is raised.",
            "    This class is not thread-safe, that's why for every use a new instance",
            "    must be implemented.",
            "    '''",
            "    ALLOWED_PASSTHROUGHS = 'add_port', 'add_tunnel_port', 'delete_port'",
            "",
            "    def __init__(self, br, full_ordered=False,",
            "                 order=('add', 'mod', 'del'), use_bundle=False):",
            "        '''Constructor.",
            "",
            "        :param br: wrapped bridge",
            "        :param full_ordered: Optional, disable flow reordering (slower)",
            "        :param order: Optional, define in which order flow are applied",
            "        :param use_bundle: Optional, a bool whether --bundle should be passed",
            "                           to all ofctl commands. Default is set to False.",
            "        '''",
            "",
            "        self.br = br",
            "        self.full_ordered = full_ordered",
            "        self.order = order",
            "        if not self.full_ordered:",
            "            self.weights = dict((y, x) for x, y in enumerate(self.order))",
            "        self.action_flow_tuples = []",
            "        self.use_bundle = use_bundle",
            "",
            "    def __getattr__(self, name):",
            "        if name in self.ALLOWED_PASSTHROUGHS:",
            "            return getattr(self.br, name)",
            "        raise AttributeError(name)",
            "",
            "    def add_flow(self, **kwargs):",
            "        self.action_flow_tuples.append(('add', kwargs))",
            "",
            "    def mod_flow(self, **kwargs):",
            "        self.action_flow_tuples.append(('mod', kwargs))",
            "",
            "    def delete_flows(self, **kwargs):",
            "        self.action_flow_tuples.append(('del', kwargs))",
            "",
            "    def apply_flows(self):",
            "        action_flow_tuples = self.action_flow_tuples",
            "        self.action_flow_tuples = []",
            "        if not action_flow_tuples:",
            "            return",
            "",
            "        if not self.full_ordered:",
            "            action_flow_tuples.sort(key=lambda af: self.weights[af[0]])",
            "",
            "        grouped = itertools.groupby(action_flow_tuples,",
            "                                    key=operator.itemgetter(0))",
            "        itemgetter_1 = operator.itemgetter(1)",
            "        for action, action_flow_list in grouped:",
            "            flows = list(map(itemgetter_1, action_flow_list))",
            "            self.br.do_action_flows(action, flows, self.use_bundle)",
            "",
            "    def __enter__(self):",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        if exc_type is None:",
            "            self.apply_flows()",
            "        else:",
            "            LOG.exception(\"OVS flows could not be applied on bridge %s\",",
            "                          self.br.br_name)",
            "",
            "",
            "def _build_flow_expr_str(flow_dict, cmd, strict):",
            "    flow_expr_arr = []",
            "    actions = None",
            "",
            "    if cmd == 'add':",
            "        flow_expr_arr.append(\"hard_timeout=%s\" %",
            "                             flow_dict.pop('hard_timeout', '0'))",
            "        flow_expr_arr.append(\"idle_timeout=%s\" %",
            "                             flow_dict.pop('idle_timeout', '0'))",
            "        flow_expr_arr.append(\"priority=%s\" %",
            "                             flow_dict.pop('priority', '1'))",
            "    elif 'priority' in flow_dict:",
            "        if not strict:",
            "            msg = _(\"Cannot match priority on flow deletion or modification \"",
            "                    \"without 'strict'\")",
            "            raise exceptions.InvalidInput(error_message=msg)",
            "",
            "    if cmd != 'del':",
            "        if \"actions\" not in flow_dict:",
            "            msg = _(\"Must specify one or more actions on flow addition\"",
            "                    \" or modification\")",
            "            raise exceptions.InvalidInput(error_message=msg)",
            "        actions = \"actions=%s\" % flow_dict.pop('actions')",
            "",
            "    for key, value in flow_dict.items():",
            "        if key == 'proto':",
            "            flow_expr_arr.append(value)",
            "        else:",
            "            flow_expr_arr.append(\"%s=%s\" % (key, str(value)))",
            "",
            "    if actions:",
            "        flow_expr_arr.append(actions)",
            "",
            "    return ','.join(flow_expr_arr)",
            "",
            "",
            "def generate_random_cookie():",
            "    # The OpenFlow spec forbids use of -1",
            "    return random.randrange(UINT64_BITMASK)",
            "",
            "",
            "def check_cookie_mask(cookie):",
            "    cookie = str(cookie)",
            "    if '/' not in cookie:",
            "        return cookie + '/-1'",
            "    else:",
            "        return cookie",
            "",
            "",
            "def is_a_flow_line(line):",
            "    # this is used to filter out from ovs-ofctl dump-flows the lines that",
            "    # are not flow descriptions but mere indications of the type of openflow",
            "    # message that was used ; e.g.:",
            "    #",
            "    # # ovs-ofctl dump-flows br-int",
            "    # NXST_FLOW reply (xid=0x4):",
            "    #  cookie=0xb7dff131a697c6a5, duration=2411726.809s, table=0, ...",
            "    #  cookie=0xb7dff131a697c6a5, duration=2411726.786s, table=23, ...",
            "    #  cookie=0xb7dff131a697c6a5, duration=2411726.760s, table=24, ...",
            "    #",
            "    return 'NXST' not in line and 'OFPST' not in line"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "635": [
                "OVSBridge",
                "get_vifs_by_ids"
            ],
            "636": [
                "OVSBridge",
                "get_vifs_by_ids"
            ],
            "642": [
                "OVSBridge"
            ],
            "643": [
                "OVSBridge",
                "_check_ofport"
            ],
            "644": [
                "OVSBridge",
                "_check_ofport"
            ],
            "645": [
                "OVSBridge",
                "_check_ofport"
            ],
            "646": [
                "OVSBridge",
                "_check_ofport"
            ],
            "647": [
                "OVSBridge",
                "_check_ofport"
            ],
            "648": [
                "OVSBridge",
                "_check_ofport"
            ],
            "649": [
                "OVSBridge",
                "_check_ofport"
            ],
            "650": [
                "OVSBridge"
            ],
            "659": [
                "OVSBridge",
                "get_vif_port_by_id"
            ],
            "660": [
                "OVSBridge",
                "get_vif_port_by_id"
            ]
        },
        "addLocation": []
    },
    "neutron/plugins/ml2/drivers/openvswitch/agent/ovs_dvr_neutron_agent.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from oslo_utils import excutils"
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from osprofiler import profiler"
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+from neutron.agent.common import ovs_lib"
            },
            "4": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from neutron.agent.linux.openvswitch_firewall import firewall as ovs_firewall"
            },
            "5": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from neutron.common import utils as n_utils"
            },
            "6": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants"
            },
            "7": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 425,
                "PatchRowcode": "                   local_compute_ports)"
            },
            "8": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": 426,
                "PatchRowcode": "         vif_by_id = self.int_br.get_vifs_by_ids("
            },
            "9": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": 427,
                "PatchRowcode": "             [local_port['id'] for local_port in local_compute_ports])"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 428,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+        # A router port has an OVS interface with type internal. Once the"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 430,
                "PatchRowcode": "+        # interface is created, a valid ofport will be assigned."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 431,
                "PatchRowcode": "+        vif_by_id = {k: v for k, v in vif_by_id.items()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 432,
                "PatchRowcode": "+                     if not v or v.ofport not in"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 433,
                "PatchRowcode": "+                     (ovs_lib.INVALID_OFPORT, ovs_lib.UNASSIGNED_OFPORT)}"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 434,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "         for local_port in local_compute_ports:"
            },
            "18": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "             vif = vif_by_id.get(local_port['id'])"
            },
            "19": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "             if not vif:"
            },
            "20": {
                "beforePatchRowNumber": 605,
                "afterPatchRowNumber": 613,
                "PatchRowcode": "                      \"%(ofport)s, rebinding.\","
            },
            "21": {
                "beforePatchRowNumber": 606,
                "afterPatchRowNumber": 614,
                "PatchRowcode": "                      {'vif': port.vif_id, 'ofport': port.ofport})"
            },
            "22": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": 615,
                "PatchRowcode": "             self.unbind_port_from_dvr(port, local_vlan_map)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+            if port.ofport in (ovs_lib.INVALID_OFPORT,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 617,
                "PatchRowcode": "+                               ovs_lib.UNASSIGNED_OFPORT):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+                return"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 619,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": 620,
                "PatchRowcode": "         if device_owner == n_const.DEVICE_OWNER_DVR_INTERFACE:"
            },
            "28": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 621,
                "PatchRowcode": "             self._bind_distributed_router_interface_port(port,"
            },
            "29": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": 622,
                "PatchRowcode": "                                                          local_vlan_map,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014, Hewlett-Packard Development Company, L.P.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import sys",
            "",
            "import netaddr",
            "from neutron_lib import constants as n_const",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "import oslo_messaging",
            "from oslo_utils import excutils",
            "from osprofiler import profiler",
            "",
            "from neutron.agent.linux.openvswitch_firewall import firewall as ovs_firewall",
            "from neutron.common import utils as n_utils",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "# A class to represent a DVR-hosted subnet including vif_ports resident on",
            "# that subnet",
            "class LocalDVRSubnetMapping(object):",
            "    def __init__(self, subnet, csnat_ofport=constants.OFPORT_INVALID):",
            "        # set of compute ports on this dvr subnet",
            "        self.compute_ports = {}",
            "        self.subnet = subnet",
            "        self.csnat_ofport = csnat_ofport",
            "        self.dvr_owned = False",
            "",
            "    def __str__(self):",
            "        return (\"subnet = %s compute_ports = %s csnat_port = %s\"",
            "                \" is_dvr_owned = %s\" %",
            "                (self.subnet, self.get_compute_ofports(),",
            "                 self.get_csnat_ofport(), self.is_dvr_owned()))",
            "",
            "    def get_subnet_info(self):",
            "        return self.subnet",
            "",
            "    def set_dvr_owned(self, owned):",
            "        self.dvr_owned = owned",
            "",
            "    def is_dvr_owned(self):",
            "        return self.dvr_owned",
            "",
            "    def add_compute_ofport(self, vif_id, ofport):",
            "        self.compute_ports[vif_id] = ofport",
            "",
            "    def remove_compute_ofport(self, vif_id):",
            "        self.compute_ports.pop(vif_id, 0)",
            "",
            "    def remove_all_compute_ofports(self):",
            "        self.compute_ports.clear()",
            "",
            "    def get_compute_ofports(self):",
            "        return self.compute_ports",
            "",
            "    def set_csnat_ofport(self, ofport):",
            "        self.csnat_ofport = ofport",
            "",
            "    def get_csnat_ofport(self):",
            "        return self.csnat_ofport",
            "",
            "",
            "class OVSPort(object):",
            "    def __init__(self, id, ofport, mac, device_owner):",
            "        self.id = id",
            "        self.mac = mac",
            "        self.ofport = ofport",
            "        self.subnets = set()",
            "        self.device_owner = device_owner",
            "",
            "    def __str__(self):",
            "        return (\"OVSPort: id = %s, ofport = %s, mac = %s, \"",
            "                \"device_owner = %s, subnets = %s\" %",
            "                (self.id, self.ofport, self.mac,",
            "                 self.device_owner, self.subnets))",
            "",
            "    def add_subnet(self, subnet_id):",
            "        self.subnets.add(subnet_id)",
            "",
            "    def remove_subnet(self, subnet_id):",
            "        self.subnets.remove(subnet_id)",
            "",
            "    def remove_all_subnets(self):",
            "        self.subnets.clear()",
            "",
            "    def get_subnets(self):",
            "        return self.subnets",
            "",
            "    def get_device_owner(self):",
            "        return self.device_owner",
            "",
            "    def get_mac(self):",
            "        return self.mac",
            "",
            "    def get_ofport(self):",
            "        return self.ofport",
            "",
            "",
            "@profiler.trace_cls(\"ovs_dvr_agent\")",
            "class OVSDVRNeutronAgent(object):",
            "    '''Implements OVS-based DVR (Distributed Virtual Router) agent'''",
            "    # history",
            "    #   1.0 Initial version",
            "",
            "    def __init__(self, context, plugin_rpc, integ_br, tun_br,",
            "                 bridge_mappings, phys_brs, int_ofports, phys_ofports,",
            "                 patch_int_ofport=constants.OFPORT_INVALID,",
            "                 patch_tun_ofport=constants.OFPORT_INVALID,",
            "                 host=None, enable_tunneling=False,",
            "                 enable_distributed_routing=False):",
            "        self.context = context",
            "        self.plugin_rpc = plugin_rpc",
            "        self.host = host",
            "        self.enable_tunneling = enable_tunneling",
            "        self.enable_distributed_routing = enable_distributed_routing",
            "        self.bridge_mappings = bridge_mappings",
            "        self.int_ofports = int_ofports",
            "        self.phys_ofports = phys_ofports",
            "        self.reset_ovs_parameters(integ_br, tun_br, phys_brs,",
            "                                  patch_int_ofport, patch_tun_ofport)",
            "        self.reset_dvr_parameters()",
            "        self.dvr_mac_address = None",
            "        if self.enable_distributed_routing:",
            "            self.get_dvr_mac_address()",
            "        self.conf = cfg.CONF",
            "        self.firewall = None",
            "",
            "    def set_firewall(self, firewall=None):",
            "        self.firewall = firewall",
            "",
            "    def setup_dvr_flows(self, bridge_mappings=None):",
            "        bridge_mappings = bridge_mappings or self.bridge_mappings",
            "        self.setup_dvr_flows_on_integ_br()",
            "        self.setup_dvr_flows_on_tun_br()",
            "        self.setup_dvr_flows_on_phys_br(bridge_mappings)",
            "        self.setup_dvr_mac_flows_on_all_brs()",
            "",
            "    def reset_ovs_parameters(self, integ_br, tun_br, phys_brs,",
            "                             patch_int_ofport, patch_tun_ofport):",
            "        '''Reset the openvswitch parameters'''",
            "        self.int_br = integ_br",
            "        self.tun_br = tun_br",
            "        self.phys_brs = phys_brs",
            "        self.patch_int_ofport = patch_int_ofport",
            "        self.patch_tun_ofport = patch_tun_ofport",
            "",
            "    def reset_dvr_parameters(self):",
            "        '''Reset the DVR parameters'''",
            "        self.local_dvr_map = {}",
            "        self.local_csnat_map = {}",
            "        self.local_ports = {}",
            "        self.registered_dvr_macs = set()",
            "",
            "    def reset_dvr_flows(self, integ_br, tun_br, phys_brs,",
            "                        patch_int_ofport, patch_tun_ofport,",
            "                        bridge_mappings=None):",
            "        '''Reset the openvswitch and DVR parameters and DVR flows'''",
            "        self.reset_ovs_parameters(",
            "            integ_br, tun_br, phys_brs, patch_int_ofport, patch_tun_ofport)",
            "        self.reset_dvr_parameters()",
            "        self.setup_dvr_flows(bridge_mappings)",
            "",
            "    def get_dvr_mac_address(self):",
            "        try:",
            "            self.get_dvr_mac_address_with_retry()",
            "        except oslo_messaging.RemoteError as e:",
            "            LOG.error('L2 agent could not get DVR MAC address at '",
            "                      'startup due to RPC error.  It happens when the '",
            "                      'server does not support this RPC API.  Detailed '",
            "                      'message: %s', e)",
            "        except oslo_messaging.MessagingTimeout:",
            "            LOG.error('DVR: Failed to obtain a valid local '",
            "                      'DVR MAC address')",
            "",
            "        if not self.in_distributed_mode():",
            "            sys.exit(1)",
            "",
            "    def get_dvr_mac_address_with_retry(self):",
            "        # Get the local DVR MAC Address from the Neutron Server.",
            "        # This is the first place where we contact the server on startup",
            "        # so retry in case it's not ready to respond",
            "        for retry_count in reversed(range(5)):",
            "            try:",
            "                details = self.plugin_rpc.get_dvr_mac_address_by_host(",
            "                    self.context, self.host)",
            "            except oslo_messaging.MessagingTimeout as e:",
            "                with excutils.save_and_reraise_exception() as ctx:",
            "                    if retry_count > 0:",
            "                        ctx.reraise = False",
            "                        LOG.warning('L2 agent could not get DVR MAC '",
            "                                    'address from server. Retrying. '",
            "                                    'Detailed message: %s', e)",
            "            else:",
            "                LOG.debug(\"L2 Agent DVR: Received response for \"",
            "                          \"get_dvr_mac_address_by_host() from \"",
            "                          \"plugin: %r\", details)",
            "                self.dvr_mac_address = (",
            "                    netaddr.EUI(details['mac_address'],",
            "                                dialect=netaddr.mac_unix_expanded))",
            "                return",
            "",
            "    def setup_dvr_flows_on_integ_br(self):",
            "        '''Setup up initial dvr flows into br-int'''",
            "",
            "        LOG.info(\"L2 Agent operating in DVR Mode with MAC %s\",",
            "                 self.dvr_mac_address)",
            "        # Add a canary flow to int_br to track OVS restarts",
            "        self.int_br.setup_canary_table()",
            "",
            "        # Insert 'drop' action as the default for Table DVR_TO_SRC_MAC",
            "        self.int_br.install_drop(table_id=constants.DVR_TO_SRC_MAC, priority=1)",
            "",
            "        self.int_br.install_drop(table_id=constants.DVR_TO_SRC_MAC_PHYSICAL,",
            "                                 priority=1)",
            "",
            "        for physical_network in self.bridge_mappings:",
            "            self.int_br.install_drop(table_id=constants.LOCAL_SWITCHING,",
            "                                     priority=2,",
            "                                     in_port=self.int_ofports[",
            "                                         physical_network])",
            "",
            "    def setup_dvr_flows_on_tun_br(self):",
            "        '''Setup up initial dvr flows into br-tun'''",
            "        if not self.enable_tunneling:",
            "            return",
            "",
            "        self.tun_br.install_goto(dest_table_id=constants.DVR_PROCESS,",
            "                                 priority=1,",
            "                                 in_port=self.patch_int_ofport)",
            "",
            "        # table-miss should be sent to learning table",
            "        self.tun_br.install_goto(table_id=constants.DVR_NOT_LEARN,",
            "                                 dest_table_id=constants.LEARN_FROM_TUN)",
            "",
            "        self.tun_br.install_goto(table_id=constants.DVR_PROCESS,",
            "                                 dest_table_id=constants.PATCH_LV_TO_TUN)",
            "",
            "    def setup_dvr_flows_on_phys_br(self, bridge_mappings=None):",
            "        '''Setup up initial dvr flows into br-phys'''",
            "        bridge_mappings = bridge_mappings or self.bridge_mappings",
            "        for physical_network in bridge_mappings:",
            "            self.phys_brs[physical_network].install_goto(",
            "                in_port=self.phys_ofports[physical_network],",
            "                priority=2,",
            "                dest_table_id=constants.DVR_PROCESS_PHYSICAL)",
            "            self.phys_brs[physical_network].install_goto(",
            "                priority=1,",
            "                dest_table_id=constants.DVR_NOT_LEARN_PHYSICAL)",
            "            self.phys_brs[physical_network].install_goto(",
            "                table_id=constants.DVR_PROCESS_PHYSICAL,",
            "                priority=0,",
            "                dest_table_id=constants.LOCAL_VLAN_TRANSLATION)",
            "            self.phys_brs[physical_network].install_drop(",
            "                table_id=constants.LOCAL_VLAN_TRANSLATION,",
            "                in_port=self.phys_ofports[physical_network],",
            "                priority=2)",
            "            self.phys_brs[physical_network].install_normal(",
            "                table_id=constants.DVR_NOT_LEARN_PHYSICAL,",
            "                priority=1)",
            "",
            "    def _add_dvr_mac_for_phys_br(self, physical_network, mac):",
            "        self.int_br.add_dvr_mac_physical(",
            "            mac=mac, port=self.int_ofports[physical_network])",
            "        phys_br = self.phys_brs[physical_network]",
            "        phys_br.add_dvr_mac_physical(",
            "            mac=mac, port=self.phys_ofports[physical_network])",
            "",
            "    def _add_arp_dvr_mac_for_phys_br(self, physical_network, mac):",
            "        self.int_br.add_dvr_gateway_mac_arp_vlan(",
            "                mac=mac, port=self.int_ofports[physical_network])",
            "",
            "    def _remove_dvr_mac_for_phys_br(self, physical_network, mac):",
            "        # REVISIT(yamamoto): match in_port as well?",
            "        self.int_br.remove_dvr_mac_vlan(mac=mac)",
            "        phys_br = self.phys_brs[physical_network]",
            "        # REVISIT(yamamoto): match in_port as well?",
            "        phys_br.remove_dvr_mac_vlan(mac=mac)",
            "",
            "    def _add_dvr_mac_for_tun_br(self, mac):",
            "        self.int_br.add_dvr_mac_tun(mac=mac, port=self.patch_tun_ofport)",
            "        self.tun_br.add_dvr_mac_tun(mac=mac, port=self.patch_int_ofport)",
            "",
            "    def _add_arp_dvr_mac_for_tun_br(self, mac):",
            "        self.int_br.add_dvr_gateway_mac_arp_tun(",
            "                mac=mac, port=self.patch_tun_ofport)",
            "",
            "    def _remove_dvr_mac_for_tun_br(self, mac):",
            "        self.int_br.remove_dvr_mac_tun(mac=mac, port=self.patch_tun_ofport)",
            "        # REVISIT(yamamoto): match in_port as well?",
            "        self.tun_br.remove_dvr_mac_tun(mac=mac)",
            "",
            "    def _add_dvr_mac(self, mac):",
            "        for physical_network in self.bridge_mappings:",
            "            self._add_dvr_mac_for_phys_br(physical_network, mac)",
            "        if self.enable_tunneling:",
            "            self._add_dvr_mac_for_tun_br(mac)",
            "        LOG.debug(\"Added DVR MAC flow for %s\", mac)",
            "        self.registered_dvr_macs.add(mac)",
            "",
            "    def _add_dvr_mac_for_arp(self, mac):",
            "        for physical_network in self.bridge_mappings:",
            "            self._add_arp_dvr_mac_for_phys_br(physical_network, mac)",
            "        if self.enable_tunneling:",
            "            self._add_arp_dvr_mac_for_tun_br(mac)",
            "        LOG.debug(\"Added ARP DVR MAC flow for %s\", mac)",
            "",
            "    def _remove_dvr_mac(self, mac):",
            "        for physical_network in self.bridge_mappings:",
            "            self._remove_dvr_mac_for_phys_br(physical_network, mac)",
            "        if self.enable_tunneling:",
            "            self._remove_dvr_mac_for_tun_br(mac)",
            "        LOG.debug(\"Removed DVR MAC flow for %s\", mac)",
            "        self.registered_dvr_macs.remove(mac)",
            "",
            "    def setup_dvr_mac_flows_on_all_brs(self):",
            "        dvr_macs = self.plugin_rpc.get_dvr_mac_address_list(self.context)",
            "        LOG.debug(\"L2 Agent DVR: Received these MACs: %r\", dvr_macs)",
            "        for mac in dvr_macs:",
            "            c_mac = netaddr.EUI(mac['mac_address'],",
            "                                dialect=netaddr.mac_unix_expanded)",
            "            if c_mac == self.dvr_mac_address:",
            "                self._add_dvr_mac_for_arp(c_mac)",
            "                LOG.debug(\"Added the DVR MAC rule for ARP %s\", c_mac)",
            "                continue",
            "            self._add_dvr_mac(c_mac)",
            "",
            "    def dvr_mac_address_update(self, dvr_macs):",
            "        if not self.dvr_mac_address:",
            "            LOG.debug(\"Self mac unknown, ignoring this \"",
            "                      \"dvr_mac_address_update() \")",
            "            return",
            "",
            "        dvr_host_macs = set()",
            "        for entry in dvr_macs:",
            "            e_mac = netaddr.EUI(entry['mac_address'],",
            "                                dialect=netaddr.mac_unix_expanded)",
            "            if e_mac == self.dvr_mac_address:",
            "                continue",
            "            dvr_host_macs.add(e_mac)",
            "",
            "        if dvr_host_macs == self.registered_dvr_macs:",
            "            LOG.debug(\"DVR Mac address already up to date\")",
            "            return",
            "",
            "        dvr_macs_added = dvr_host_macs - self.registered_dvr_macs",
            "        dvr_macs_removed = self.registered_dvr_macs - dvr_host_macs",
            "",
            "        for oldmac in dvr_macs_removed:",
            "            self._remove_dvr_mac(oldmac)",
            "",
            "        for newmac in dvr_macs_added:",
            "            self._add_dvr_mac(newmac)",
            "",
            "    def in_distributed_mode(self):",
            "        return self.dvr_mac_address is not None",
            "",
            "    def process_tunneled_network(self, network_type, lvid, segmentation_id):",
            "        self.tun_br.provision_local_vlan(",
            "            network_type=network_type,",
            "            lvid=lvid,",
            "            segmentation_id=segmentation_id,",
            "            distributed=self.in_distributed_mode())",
            "",
            "    def _bind_distributed_router_interface_port(self, port, lvm,",
            "                                                fixed_ips, device_owner):",
            "        # since distributed router port must have only one fixed",
            "        # IP, directly use fixed_ips[0]",
            "        fixed_ip = fixed_ips[0]",
            "        subnet_uuid = fixed_ip['subnet_id']",
            "        if subnet_uuid in self.local_dvr_map:",
            "            ldm = self.local_dvr_map[subnet_uuid]",
            "        else:",
            "            # set up LocalDVRSubnetMapping available for this subnet",
            "            subnet_info = self.plugin_rpc.get_subnet_for_dvr(",
            "                self.context, subnet_uuid, fixed_ips=fixed_ips)",
            "            if not subnet_info:",
            "                LOG.warning(\"DVR: Unable to retrieve subnet information \"",
            "                            \"for subnet_id %s. The subnet or the gateway \"",
            "                            \"may have already been deleted\", subnet_uuid)",
            "                return",
            "            LOG.debug(\"get_subnet_for_dvr for subnet %(uuid)s \"",
            "                      \"returned with %(info)s\",",
            "                      {\"uuid\": subnet_uuid, \"info\": subnet_info})",
            "            ldm = LocalDVRSubnetMapping(subnet_info)",
            "            self.local_dvr_map[subnet_uuid] = ldm",
            "",
            "        # DVR takes over",
            "        ldm.set_dvr_owned(True)",
            "",
            "        vlan_to_use = lvm.vlan",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            vlan_to_use = lvm.segmentation_id",
            "",
            "        subnet_info = ldm.get_subnet_info()",
            "        ip_version = subnet_info['ip_version']",
            "",
            "        if self.firewall and isinstance(self.firewall,",
            "                                        ovs_firewall.OVSFirewallDriver):",
            "            tunnel_direct_info = {\"network_type\": lvm.network_type,",
            "                                  \"physical_network\": lvm.physical_network}",
            "            self.firewall.install_accepted_egress_direct_flow(",
            "                subnet_info['gateway_mac'], lvm.vlan, port.ofport,",
            "                tunnel_direct_info=tunnel_direct_info)",
            "",
            "        local_compute_ports = (",
            "            self.plugin_rpc.get_ports_on_host_by_subnet(",
            "                self.context, self.host, subnet_uuid))",
            "        LOG.debug(\"DVR: List of ports received from \"",
            "                  \"get_ports_on_host_by_subnet %s\",",
            "                  local_compute_ports)",
            "        vif_by_id = self.int_br.get_vifs_by_ids(",
            "            [local_port['id'] for local_port in local_compute_ports])",
            "        for local_port in local_compute_ports:",
            "            vif = vif_by_id.get(local_port['id'])",
            "            if not vif:",
            "                continue",
            "            ldm.add_compute_ofport(vif.vif_id, vif.ofport)",
            "            if vif.vif_id in self.local_ports:",
            "                # ensure if a compute port is already on",
            "                # a different dvr routed subnet",
            "                # if yes, queue this subnet to that port",
            "                comp_ovsport = self.local_ports[vif.vif_id]",
            "                comp_ovsport.add_subnet(subnet_uuid)",
            "            else:",
            "                # the compute port is discovered first here that its on",
            "                # a dvr routed subnet queue this subnet to that port",
            "                comp_ovsport = OVSPort(vif.vif_id, vif.ofport,",
            "                                       vif.vif_mac, local_port['device_owner'])",
            "                comp_ovsport.add_subnet(subnet_uuid)",
            "                self.local_ports[vif.vif_id] = comp_ovsport",
            "            # create rule for just this vm port",
            "            self.int_br.install_dvr_to_src_mac(",
            "                network_type=lvm.network_type,",
            "                vlan_tag=vlan_to_use,",
            "                gateway_mac=subnet_info['gateway_mac'],",
            "                dst_mac=comp_ovsport.get_mac(),",
            "                dst_port=comp_ovsport.get_ofport())",
            "        self.int_br.install_dvr_dst_mac_for_arp(",
            "            lvm.network_type,",
            "            vlan_tag=lvm.vlan,",
            "            gateway_mac=port.vif_mac,",
            "            dvr_mac=self.dvr_mac_address,",
            "            rtr_port=port.ofport)",
            "",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            # TODO(vivek) remove the IPv6 related flows once SNAT is not",
            "            # used for IPv6 DVR.",
            "            br = self.phys_brs[lvm.physical_network]",
            "        if lvm.network_type in constants.TUNNEL_NETWORK_TYPES:",
            "            br = self.tun_br",
            "        # TODO(vivek) remove the IPv6 related flows once SNAT is not",
            "        # used for IPv6 DVR.",
            "        if ip_version == 4:",
            "            br.install_dvr_process_ipv4(",
            "                vlan_tag=lvm.vlan, gateway_ip=fixed_ip['ip_address'])",
            "        else:",
            "            br.install_dvr_process_ipv6(",
            "                vlan_tag=lvm.vlan, gateway_mac=port.vif_mac)",
            "        br.install_dvr_process(",
            "            vlan_tag=lvm.vlan, vif_mac=port.vif_mac,",
            "            dvr_mac_address=self.dvr_mac_address)",
            "",
            "        # the dvr router interface is itself a port, so capture it",
            "        # queue this subnet to that port. A subnet appears only once as",
            "        # a router interface on any given router",
            "        ovsport = OVSPort(port.vif_id, port.ofport,",
            "                          port.vif_mac, device_owner)",
            "        ovsport.add_subnet(subnet_uuid)",
            "        self.local_ports[port.vif_id] = ovsport",
            "",
            "    def _bind_port_on_dvr_subnet(self, port, lvm, fixed_ips,",
            "                                 device_owner):",
            "        # Handle new compute port added use-case",
            "        subnet_uuid = None",
            "        for ips in fixed_ips:",
            "            if ips['subnet_id'] not in self.local_dvr_map:",
            "                continue",
            "            subnet_uuid = ips['subnet_id']",
            "            ldm = self.local_dvr_map[subnet_uuid]",
            "            if not ldm.is_dvr_owned():",
            "                # well this is CSNAT stuff, let dvr come in",
            "                # and do plumbing for this vm later",
            "                continue",
            "",
            "            # This confirms that this compute port belongs",
            "            # to a dvr hosted subnet.",
            "            # Accommodate this VM Port into the existing rule in",
            "            # the integration bridge",
            "            LOG.debug(\"DVR: Plumbing compute port %s\", port.vif_id)",
            "            subnet_info = ldm.get_subnet_info()",
            "            ldm.add_compute_ofport(port.vif_id, port.ofport)",
            "            if port.vif_id in self.local_ports:",
            "                # ensure if a compute port is already on a different",
            "                # dvr routed subnet",
            "                # if yes, queue this subnet to that port",
            "                ovsport = self.local_ports[port.vif_id]",
            "                ovsport.add_subnet(subnet_uuid)",
            "            else:",
            "                # the compute port is discovered first here that its",
            "                # on a dvr routed subnet, queue this subnet to that port",
            "                ovsport = OVSPort(port.vif_id, port.ofport,",
            "                                  port.vif_mac, device_owner)",
            "                ovsport.add_subnet(subnet_uuid)",
            "                self.local_ports[port.vif_id] = ovsport",
            "            vlan_to_use = lvm.vlan",
            "            if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "                vlan_to_use = lvm.segmentation_id",
            "            # create a rule for this vm port",
            "            self.int_br.install_dvr_to_src_mac(",
            "                network_type=lvm.network_type,",
            "                vlan_tag=vlan_to_use,",
            "                gateway_mac=subnet_info['gateway_mac'],",
            "                dst_mac=ovsport.get_mac(),",
            "                dst_port=ovsport.get_ofport())",
            "",
            "    def _bind_centralized_snat_port_on_dvr_subnet(self, port, lvm,",
            "                                                  fixed_ips, device_owner):",
            "        # We only pass the subnet uuid so the server code will correctly",
            "        # use the gateway_ip value from the subnet when looking up the",
            "        # centralized-SNAT (CSNAT) port, get it early from the first fixed_ip.",
            "        subnet_uuid = fixed_ips[0]['subnet_id']",
            "        if port.vif_id in self.local_ports:",
            "            # throw an error if CSNAT port is already on a different",
            "            # dvr routed subnet",
            "            ovsport = self.local_ports[port.vif_id]",
            "            subs = list(ovsport.get_subnets())",
            "            if subs[0] == subnet_uuid:",
            "                return",
            "            LOG.error(\"Centralized-SNAT port %(port)s on subnet \"",
            "                      \"%(port_subnet)s already seen on a different \"",
            "                      \"subnet %(orig_subnet)s\", {",
            "                          \"port\": port.vif_id,",
            "                          \"port_subnet\": subnet_uuid,",
            "                          \"orig_subnet\": subs[0],",
            "                      })",
            "            return",
            "        ldm = None",
            "        subnet_info = None",
            "        if subnet_uuid not in self.local_dvr_map:",
            "            # no csnat ports seen on this subnet - create csnat state",
            "            # for this subnet",
            "            subnet_info = self.plugin_rpc.get_subnet_for_dvr(",
            "                self.context, subnet_uuid, fixed_ips=None)",
            "            if not subnet_info:",
            "                LOG.warning(\"DVR: Unable to retrieve subnet information \"",
            "                            \"for subnet_id %s. The subnet or the gateway \"",
            "                            \"may have already been deleted\", subnet_uuid)",
            "                return",
            "            LOG.debug(\"get_subnet_for_dvr for subnet %(uuid)s \"",
            "                      \"returned with %(info)s\",",
            "                      {\"uuid\": subnet_uuid, \"info\": subnet_info})",
            "            ldm = LocalDVRSubnetMapping(subnet_info, port.ofport)",
            "            self.local_dvr_map[subnet_uuid] = ldm",
            "        else:",
            "            ldm = self.local_dvr_map[subnet_uuid]",
            "            subnet_info = ldm.get_subnet_info()",
            "            # Store csnat OF Port in the existing DVRSubnetMap",
            "            ldm.set_csnat_ofport(port.ofport)",
            "",
            "        # create ovsPort footprint for csnat port",
            "        ovsport = OVSPort(port.vif_id, port.ofport,",
            "                          port.vif_mac, device_owner)",
            "        ovsport.add_subnet(subnet_uuid)",
            "        self.local_ports[port.vif_id] = ovsport",
            "        vlan_to_use = lvm.vlan",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            vlan_to_use = lvm.segmentation_id",
            "        self.int_br.install_dvr_to_src_mac(",
            "            network_type=lvm.network_type,",
            "            vlan_tag=vlan_to_use,",
            "            gateway_mac=subnet_info['gateway_mac'],",
            "            dst_mac=ovsport.get_mac(),",
            "            dst_port=ovsport.get_ofport())",
            "",
            "    def bind_port_to_dvr(self, port, local_vlan_map,",
            "                         fixed_ips, device_owner):",
            "        if not self.in_distributed_mode():",
            "            return",
            "",
            "        if (local_vlan_map.network_type not in",
            "                (constants.TUNNEL_NETWORK_TYPES +",
            "                 constants.DVR_PHYSICAL_NETWORK_TYPES)):",
            "            LOG.debug(\"DVR: Port %s is with network_type %s not supported\"",
            "                      \" for dvr plumbing\", port.vif_id,",
            "                      local_vlan_map.network_type)",
            "            return",
            "",
            "        if (port.vif_id in self.local_ports and",
            "                self.local_ports[port.vif_id].ofport != port.ofport):",
            "            LOG.info(\"DVR: Port %(vif)s changed port number to \"",
            "                     \"%(ofport)s, rebinding.\",",
            "                     {'vif': port.vif_id, 'ofport': port.ofport})",
            "            self.unbind_port_from_dvr(port, local_vlan_map)",
            "        if device_owner == n_const.DEVICE_OWNER_DVR_INTERFACE:",
            "            self._bind_distributed_router_interface_port(port,",
            "                                                         local_vlan_map,",
            "                                                         fixed_ips,",
            "                                                         device_owner)",
            "",
            "        if device_owner and n_utils.is_dvr_serviced(device_owner):",
            "            self._bind_port_on_dvr_subnet(port, local_vlan_map,",
            "                                          fixed_ips,",
            "                                          device_owner)",
            "",
            "        if device_owner == n_const.DEVICE_OWNER_ROUTER_SNAT:",
            "            self._bind_centralized_snat_port_on_dvr_subnet(port,",
            "                                                           local_vlan_map,",
            "                                                           fixed_ips,",
            "                                                           device_owner)",
            "",
            "    def _unbind_distributed_router_interface_port(self, port, lvm):",
            "        ovsport = self.local_ports[port.vif_id]",
            "        # removal of distributed router interface",
            "        subnet_ids = ovsport.get_subnets()",
            "        subnet_set = set(subnet_ids)",
            "        network_type = lvm.network_type",
            "        physical_network = lvm.physical_network",
            "        vlan_to_use = lvm.vlan",
            "        if network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            vlan_to_use = lvm.segmentation_id",
            "        # ensure we process for all the subnets laid on this removed port",
            "        for sub_uuid in subnet_set:",
            "            if sub_uuid not in self.local_dvr_map:",
            "                continue",
            "            ldm = self.local_dvr_map[sub_uuid]",
            "            subnet_info = ldm.get_subnet_info()",
            "            ip_version = subnet_info['ip_version']",
            "            # DVR is no more owner",
            "            ldm.set_dvr_owned(False)",
            "            # remove all vm rules for this dvr subnet",
            "            # clear of compute_ports altogether",
            "            compute_ports = ldm.get_compute_ofports()",
            "            for vif_id in compute_ports:",
            "                comp_port = self.local_ports[vif_id]",
            "                self.int_br.delete_dvr_to_src_mac(",
            "                    network_type=network_type,",
            "                    vlan_tag=vlan_to_use, dst_mac=comp_port.get_mac())",
            "            ldm.remove_all_compute_ofports()",
            "            self.int_br.delete_dvr_dst_mac_for_arp(",
            "                network_type=network_type,",
            "                vlan_tag=vlan_to_use,",
            "                gateway_mac=port.vif_mac,",
            "                dvr_mac=self.dvr_mac_address,",
            "                rtr_port=port.ofport)",
            "            if ldm.get_csnat_ofport() == constants.OFPORT_INVALID:",
            "                # if there is no csnat port for this subnet, remove",
            "                # this subnet from local_dvr_map, as no dvr (or) csnat",
            "                # ports available on this agent anymore",
            "                self.local_dvr_map.pop(sub_uuid, None)",
            "            if network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "                br = self.phys_brs[physical_network]",
            "            if network_type in constants.TUNNEL_NETWORK_TYPES:",
            "                br = self.tun_br",
            "            if ip_version == 4:",
            "                if subnet_info['gateway_ip']:",
            "                    br.delete_dvr_process_ipv4(",
            "                        vlan_tag=lvm.vlan,",
            "                        gateway_ip=subnet_info['gateway_ip'])",
            "            else:",
            "                br.delete_dvr_process_ipv6(",
            "                    vlan_tag=lvm.vlan, gateway_mac=subnet_info['gateway_mac'])",
            "            ovsport.remove_subnet(sub_uuid)",
            "",
            "            if self.firewall and isinstance(self.firewall,",
            "                                            ovs_firewall.OVSFirewallDriver):",
            "                self.firewall.delete_accepted_egress_direct_flow(",
            "                    subnet_info['gateway_mac'], lvm.vlan)",
            "",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            br = self.phys_brs[physical_network]",
            "        if lvm.network_type in constants.TUNNEL_NETWORK_TYPES:",
            "            br = self.tun_br",
            "        br.delete_dvr_process(vlan_tag=lvm.vlan, vif_mac=port.vif_mac)",
            "",
            "        # release port state",
            "        self.local_ports.pop(port.vif_id, None)",
            "",
            "    def _unbind_port_on_dvr_subnet(self, port, lvm):",
            "        ovsport = self.local_ports[port.vif_id]",
            "        # This confirms that this compute port being removed belonged",
            "        # to a dvr hosted subnet.",
            "        LOG.debug(\"DVR: Removing plumbing for compute port %s\", port)",
            "        subnet_ids = ovsport.get_subnets()",
            "        # ensure we process for all the subnets laid on this port",
            "        for sub_uuid in subnet_ids:",
            "            if sub_uuid not in self.local_dvr_map:",
            "                continue",
            "            ldm = self.local_dvr_map[sub_uuid]",
            "            ldm.remove_compute_ofport(port.vif_id)",
            "            vlan_to_use = lvm.vlan",
            "            if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "                vlan_to_use = lvm.segmentation_id",
            "            # first remove this vm port rule",
            "            self.int_br.delete_dvr_to_src_mac(",
            "                network_type=lvm.network_type,",
            "                vlan_tag=vlan_to_use, dst_mac=ovsport.get_mac())",
            "        # release port state",
            "        self.local_ports.pop(port.vif_id, None)",
            "",
            "    def _unbind_centralized_snat_port_on_dvr_subnet(self, port, lvm):",
            "        ovsport = self.local_ports[port.vif_id]",
            "        # This confirms that this compute port being removed belonged",
            "        # to a dvr hosted subnet.",
            "        LOG.debug(\"DVR: Removing plumbing for csnat port %s\", port)",
            "        sub_uuid = list(ovsport.get_subnets())[0]",
            "        # ensure we process for all the subnets laid on this port",
            "        if sub_uuid not in self.local_dvr_map:",
            "            return",
            "        ldm = self.local_dvr_map[sub_uuid]",
            "        ldm.set_csnat_ofport(constants.OFPORT_INVALID)",
            "        vlan_to_use = lvm.vlan",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            vlan_to_use = lvm.segmentation_id",
            "        # then remove csnat port rule",
            "        self.int_br.delete_dvr_to_src_mac(",
            "            network_type=lvm.network_type,",
            "            vlan_tag=vlan_to_use, dst_mac=ovsport.get_mac())",
            "        if not ldm.is_dvr_owned():",
            "            # if not owned by DVR (only used for csnat), remove this",
            "            # subnet state altogether",
            "            self.local_dvr_map.pop(sub_uuid, None)",
            "        # release port state",
            "        self.local_ports.pop(port.vif_id, None)",
            "",
            "    def unbind_port_from_dvr(self, vif_port, local_vlan_map):",
            "        if not self.in_distributed_mode():",
            "            return",
            "        # Handle port removed use-case",
            "        if vif_port and vif_port.vif_id not in self.local_ports:",
            "            LOG.debug(\"DVR: Non distributed port, ignoring %s\", vif_port)",
            "            return",
            "",
            "        ovsport = self.local_ports[vif_port.vif_id]",
            "        device_owner = ovsport.get_device_owner()",
            "",
            "        if device_owner == n_const.DEVICE_OWNER_DVR_INTERFACE:",
            "            self._unbind_distributed_router_interface_port(vif_port,",
            "                                                           local_vlan_map)",
            "",
            "        if device_owner and n_utils.is_dvr_serviced(device_owner):",
            "            self._unbind_port_on_dvr_subnet(vif_port,",
            "                                            local_vlan_map)",
            "",
            "        if device_owner == n_const.DEVICE_OWNER_ROUTER_SNAT:",
            "            self._unbind_centralized_snat_port_on_dvr_subnet(vif_port,",
            "                                                             local_vlan_map)"
        ],
        "afterPatchFile": [
            "# Copyright 2014, Hewlett-Packard Development Company, L.P.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import sys",
            "",
            "import netaddr",
            "from neutron_lib import constants as n_const",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "import oslo_messaging",
            "from oslo_utils import excutils",
            "from osprofiler import profiler",
            "",
            "from neutron.agent.common import ovs_lib",
            "from neutron.agent.linux.openvswitch_firewall import firewall as ovs_firewall",
            "from neutron.common import utils as n_utils",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "# A class to represent a DVR-hosted subnet including vif_ports resident on",
            "# that subnet",
            "class LocalDVRSubnetMapping(object):",
            "    def __init__(self, subnet, csnat_ofport=constants.OFPORT_INVALID):",
            "        # set of compute ports on this dvr subnet",
            "        self.compute_ports = {}",
            "        self.subnet = subnet",
            "        self.csnat_ofport = csnat_ofport",
            "        self.dvr_owned = False",
            "",
            "    def __str__(self):",
            "        return (\"subnet = %s compute_ports = %s csnat_port = %s\"",
            "                \" is_dvr_owned = %s\" %",
            "                (self.subnet, self.get_compute_ofports(),",
            "                 self.get_csnat_ofport(), self.is_dvr_owned()))",
            "",
            "    def get_subnet_info(self):",
            "        return self.subnet",
            "",
            "    def set_dvr_owned(self, owned):",
            "        self.dvr_owned = owned",
            "",
            "    def is_dvr_owned(self):",
            "        return self.dvr_owned",
            "",
            "    def add_compute_ofport(self, vif_id, ofport):",
            "        self.compute_ports[vif_id] = ofport",
            "",
            "    def remove_compute_ofport(self, vif_id):",
            "        self.compute_ports.pop(vif_id, 0)",
            "",
            "    def remove_all_compute_ofports(self):",
            "        self.compute_ports.clear()",
            "",
            "    def get_compute_ofports(self):",
            "        return self.compute_ports",
            "",
            "    def set_csnat_ofport(self, ofport):",
            "        self.csnat_ofport = ofport",
            "",
            "    def get_csnat_ofport(self):",
            "        return self.csnat_ofport",
            "",
            "",
            "class OVSPort(object):",
            "    def __init__(self, id, ofport, mac, device_owner):",
            "        self.id = id",
            "        self.mac = mac",
            "        self.ofport = ofport",
            "        self.subnets = set()",
            "        self.device_owner = device_owner",
            "",
            "    def __str__(self):",
            "        return (\"OVSPort: id = %s, ofport = %s, mac = %s, \"",
            "                \"device_owner = %s, subnets = %s\" %",
            "                (self.id, self.ofport, self.mac,",
            "                 self.device_owner, self.subnets))",
            "",
            "    def add_subnet(self, subnet_id):",
            "        self.subnets.add(subnet_id)",
            "",
            "    def remove_subnet(self, subnet_id):",
            "        self.subnets.remove(subnet_id)",
            "",
            "    def remove_all_subnets(self):",
            "        self.subnets.clear()",
            "",
            "    def get_subnets(self):",
            "        return self.subnets",
            "",
            "    def get_device_owner(self):",
            "        return self.device_owner",
            "",
            "    def get_mac(self):",
            "        return self.mac",
            "",
            "    def get_ofport(self):",
            "        return self.ofport",
            "",
            "",
            "@profiler.trace_cls(\"ovs_dvr_agent\")",
            "class OVSDVRNeutronAgent(object):",
            "    '''Implements OVS-based DVR (Distributed Virtual Router) agent'''",
            "    # history",
            "    #   1.0 Initial version",
            "",
            "    def __init__(self, context, plugin_rpc, integ_br, tun_br,",
            "                 bridge_mappings, phys_brs, int_ofports, phys_ofports,",
            "                 patch_int_ofport=constants.OFPORT_INVALID,",
            "                 patch_tun_ofport=constants.OFPORT_INVALID,",
            "                 host=None, enable_tunneling=False,",
            "                 enable_distributed_routing=False):",
            "        self.context = context",
            "        self.plugin_rpc = plugin_rpc",
            "        self.host = host",
            "        self.enable_tunneling = enable_tunneling",
            "        self.enable_distributed_routing = enable_distributed_routing",
            "        self.bridge_mappings = bridge_mappings",
            "        self.int_ofports = int_ofports",
            "        self.phys_ofports = phys_ofports",
            "        self.reset_ovs_parameters(integ_br, tun_br, phys_brs,",
            "                                  patch_int_ofport, patch_tun_ofport)",
            "        self.reset_dvr_parameters()",
            "        self.dvr_mac_address = None",
            "        if self.enable_distributed_routing:",
            "            self.get_dvr_mac_address()",
            "        self.conf = cfg.CONF",
            "        self.firewall = None",
            "",
            "    def set_firewall(self, firewall=None):",
            "        self.firewall = firewall",
            "",
            "    def setup_dvr_flows(self, bridge_mappings=None):",
            "        bridge_mappings = bridge_mappings or self.bridge_mappings",
            "        self.setup_dvr_flows_on_integ_br()",
            "        self.setup_dvr_flows_on_tun_br()",
            "        self.setup_dvr_flows_on_phys_br(bridge_mappings)",
            "        self.setup_dvr_mac_flows_on_all_brs()",
            "",
            "    def reset_ovs_parameters(self, integ_br, tun_br, phys_brs,",
            "                             patch_int_ofport, patch_tun_ofport):",
            "        '''Reset the openvswitch parameters'''",
            "        self.int_br = integ_br",
            "        self.tun_br = tun_br",
            "        self.phys_brs = phys_brs",
            "        self.patch_int_ofport = patch_int_ofport",
            "        self.patch_tun_ofport = patch_tun_ofport",
            "",
            "    def reset_dvr_parameters(self):",
            "        '''Reset the DVR parameters'''",
            "        self.local_dvr_map = {}",
            "        self.local_csnat_map = {}",
            "        self.local_ports = {}",
            "        self.registered_dvr_macs = set()",
            "",
            "    def reset_dvr_flows(self, integ_br, tun_br, phys_brs,",
            "                        patch_int_ofport, patch_tun_ofport,",
            "                        bridge_mappings=None):",
            "        '''Reset the openvswitch and DVR parameters and DVR flows'''",
            "        self.reset_ovs_parameters(",
            "            integ_br, tun_br, phys_brs, patch_int_ofport, patch_tun_ofport)",
            "        self.reset_dvr_parameters()",
            "        self.setup_dvr_flows(bridge_mappings)",
            "",
            "    def get_dvr_mac_address(self):",
            "        try:",
            "            self.get_dvr_mac_address_with_retry()",
            "        except oslo_messaging.RemoteError as e:",
            "            LOG.error('L2 agent could not get DVR MAC address at '",
            "                      'startup due to RPC error.  It happens when the '",
            "                      'server does not support this RPC API.  Detailed '",
            "                      'message: %s', e)",
            "        except oslo_messaging.MessagingTimeout:",
            "            LOG.error('DVR: Failed to obtain a valid local '",
            "                      'DVR MAC address')",
            "",
            "        if not self.in_distributed_mode():",
            "            sys.exit(1)",
            "",
            "    def get_dvr_mac_address_with_retry(self):",
            "        # Get the local DVR MAC Address from the Neutron Server.",
            "        # This is the first place where we contact the server on startup",
            "        # so retry in case it's not ready to respond",
            "        for retry_count in reversed(range(5)):",
            "            try:",
            "                details = self.plugin_rpc.get_dvr_mac_address_by_host(",
            "                    self.context, self.host)",
            "            except oslo_messaging.MessagingTimeout as e:",
            "                with excutils.save_and_reraise_exception() as ctx:",
            "                    if retry_count > 0:",
            "                        ctx.reraise = False",
            "                        LOG.warning('L2 agent could not get DVR MAC '",
            "                                    'address from server. Retrying. '",
            "                                    'Detailed message: %s', e)",
            "            else:",
            "                LOG.debug(\"L2 Agent DVR: Received response for \"",
            "                          \"get_dvr_mac_address_by_host() from \"",
            "                          \"plugin: %r\", details)",
            "                self.dvr_mac_address = (",
            "                    netaddr.EUI(details['mac_address'],",
            "                                dialect=netaddr.mac_unix_expanded))",
            "                return",
            "",
            "    def setup_dvr_flows_on_integ_br(self):",
            "        '''Setup up initial dvr flows into br-int'''",
            "",
            "        LOG.info(\"L2 Agent operating in DVR Mode with MAC %s\",",
            "                 self.dvr_mac_address)",
            "        # Add a canary flow to int_br to track OVS restarts",
            "        self.int_br.setup_canary_table()",
            "",
            "        # Insert 'drop' action as the default for Table DVR_TO_SRC_MAC",
            "        self.int_br.install_drop(table_id=constants.DVR_TO_SRC_MAC, priority=1)",
            "",
            "        self.int_br.install_drop(table_id=constants.DVR_TO_SRC_MAC_PHYSICAL,",
            "                                 priority=1)",
            "",
            "        for physical_network in self.bridge_mappings:",
            "            self.int_br.install_drop(table_id=constants.LOCAL_SWITCHING,",
            "                                     priority=2,",
            "                                     in_port=self.int_ofports[",
            "                                         physical_network])",
            "",
            "    def setup_dvr_flows_on_tun_br(self):",
            "        '''Setup up initial dvr flows into br-tun'''",
            "        if not self.enable_tunneling:",
            "            return",
            "",
            "        self.tun_br.install_goto(dest_table_id=constants.DVR_PROCESS,",
            "                                 priority=1,",
            "                                 in_port=self.patch_int_ofport)",
            "",
            "        # table-miss should be sent to learning table",
            "        self.tun_br.install_goto(table_id=constants.DVR_NOT_LEARN,",
            "                                 dest_table_id=constants.LEARN_FROM_TUN)",
            "",
            "        self.tun_br.install_goto(table_id=constants.DVR_PROCESS,",
            "                                 dest_table_id=constants.PATCH_LV_TO_TUN)",
            "",
            "    def setup_dvr_flows_on_phys_br(self, bridge_mappings=None):",
            "        '''Setup up initial dvr flows into br-phys'''",
            "        bridge_mappings = bridge_mappings or self.bridge_mappings",
            "        for physical_network in bridge_mappings:",
            "            self.phys_brs[physical_network].install_goto(",
            "                in_port=self.phys_ofports[physical_network],",
            "                priority=2,",
            "                dest_table_id=constants.DVR_PROCESS_PHYSICAL)",
            "            self.phys_brs[physical_network].install_goto(",
            "                priority=1,",
            "                dest_table_id=constants.DVR_NOT_LEARN_PHYSICAL)",
            "            self.phys_brs[physical_network].install_goto(",
            "                table_id=constants.DVR_PROCESS_PHYSICAL,",
            "                priority=0,",
            "                dest_table_id=constants.LOCAL_VLAN_TRANSLATION)",
            "            self.phys_brs[physical_network].install_drop(",
            "                table_id=constants.LOCAL_VLAN_TRANSLATION,",
            "                in_port=self.phys_ofports[physical_network],",
            "                priority=2)",
            "            self.phys_brs[physical_network].install_normal(",
            "                table_id=constants.DVR_NOT_LEARN_PHYSICAL,",
            "                priority=1)",
            "",
            "    def _add_dvr_mac_for_phys_br(self, physical_network, mac):",
            "        self.int_br.add_dvr_mac_physical(",
            "            mac=mac, port=self.int_ofports[physical_network])",
            "        phys_br = self.phys_brs[physical_network]",
            "        phys_br.add_dvr_mac_physical(",
            "            mac=mac, port=self.phys_ofports[physical_network])",
            "",
            "    def _add_arp_dvr_mac_for_phys_br(self, physical_network, mac):",
            "        self.int_br.add_dvr_gateway_mac_arp_vlan(",
            "                mac=mac, port=self.int_ofports[physical_network])",
            "",
            "    def _remove_dvr_mac_for_phys_br(self, physical_network, mac):",
            "        # REVISIT(yamamoto): match in_port as well?",
            "        self.int_br.remove_dvr_mac_vlan(mac=mac)",
            "        phys_br = self.phys_brs[physical_network]",
            "        # REVISIT(yamamoto): match in_port as well?",
            "        phys_br.remove_dvr_mac_vlan(mac=mac)",
            "",
            "    def _add_dvr_mac_for_tun_br(self, mac):",
            "        self.int_br.add_dvr_mac_tun(mac=mac, port=self.patch_tun_ofport)",
            "        self.tun_br.add_dvr_mac_tun(mac=mac, port=self.patch_int_ofport)",
            "",
            "    def _add_arp_dvr_mac_for_tun_br(self, mac):",
            "        self.int_br.add_dvr_gateway_mac_arp_tun(",
            "                mac=mac, port=self.patch_tun_ofport)",
            "",
            "    def _remove_dvr_mac_for_tun_br(self, mac):",
            "        self.int_br.remove_dvr_mac_tun(mac=mac, port=self.patch_tun_ofport)",
            "        # REVISIT(yamamoto): match in_port as well?",
            "        self.tun_br.remove_dvr_mac_tun(mac=mac)",
            "",
            "    def _add_dvr_mac(self, mac):",
            "        for physical_network in self.bridge_mappings:",
            "            self._add_dvr_mac_for_phys_br(physical_network, mac)",
            "        if self.enable_tunneling:",
            "            self._add_dvr_mac_for_tun_br(mac)",
            "        LOG.debug(\"Added DVR MAC flow for %s\", mac)",
            "        self.registered_dvr_macs.add(mac)",
            "",
            "    def _add_dvr_mac_for_arp(self, mac):",
            "        for physical_network in self.bridge_mappings:",
            "            self._add_arp_dvr_mac_for_phys_br(physical_network, mac)",
            "        if self.enable_tunneling:",
            "            self._add_arp_dvr_mac_for_tun_br(mac)",
            "        LOG.debug(\"Added ARP DVR MAC flow for %s\", mac)",
            "",
            "    def _remove_dvr_mac(self, mac):",
            "        for physical_network in self.bridge_mappings:",
            "            self._remove_dvr_mac_for_phys_br(physical_network, mac)",
            "        if self.enable_tunneling:",
            "            self._remove_dvr_mac_for_tun_br(mac)",
            "        LOG.debug(\"Removed DVR MAC flow for %s\", mac)",
            "        self.registered_dvr_macs.remove(mac)",
            "",
            "    def setup_dvr_mac_flows_on_all_brs(self):",
            "        dvr_macs = self.plugin_rpc.get_dvr_mac_address_list(self.context)",
            "        LOG.debug(\"L2 Agent DVR: Received these MACs: %r\", dvr_macs)",
            "        for mac in dvr_macs:",
            "            c_mac = netaddr.EUI(mac['mac_address'],",
            "                                dialect=netaddr.mac_unix_expanded)",
            "            if c_mac == self.dvr_mac_address:",
            "                self._add_dvr_mac_for_arp(c_mac)",
            "                LOG.debug(\"Added the DVR MAC rule for ARP %s\", c_mac)",
            "                continue",
            "            self._add_dvr_mac(c_mac)",
            "",
            "    def dvr_mac_address_update(self, dvr_macs):",
            "        if not self.dvr_mac_address:",
            "            LOG.debug(\"Self mac unknown, ignoring this \"",
            "                      \"dvr_mac_address_update() \")",
            "            return",
            "",
            "        dvr_host_macs = set()",
            "        for entry in dvr_macs:",
            "            e_mac = netaddr.EUI(entry['mac_address'],",
            "                                dialect=netaddr.mac_unix_expanded)",
            "            if e_mac == self.dvr_mac_address:",
            "                continue",
            "            dvr_host_macs.add(e_mac)",
            "",
            "        if dvr_host_macs == self.registered_dvr_macs:",
            "            LOG.debug(\"DVR Mac address already up to date\")",
            "            return",
            "",
            "        dvr_macs_added = dvr_host_macs - self.registered_dvr_macs",
            "        dvr_macs_removed = self.registered_dvr_macs - dvr_host_macs",
            "",
            "        for oldmac in dvr_macs_removed:",
            "            self._remove_dvr_mac(oldmac)",
            "",
            "        for newmac in dvr_macs_added:",
            "            self._add_dvr_mac(newmac)",
            "",
            "    def in_distributed_mode(self):",
            "        return self.dvr_mac_address is not None",
            "",
            "    def process_tunneled_network(self, network_type, lvid, segmentation_id):",
            "        self.tun_br.provision_local_vlan(",
            "            network_type=network_type,",
            "            lvid=lvid,",
            "            segmentation_id=segmentation_id,",
            "            distributed=self.in_distributed_mode())",
            "",
            "    def _bind_distributed_router_interface_port(self, port, lvm,",
            "                                                fixed_ips, device_owner):",
            "        # since distributed router port must have only one fixed",
            "        # IP, directly use fixed_ips[0]",
            "        fixed_ip = fixed_ips[0]",
            "        subnet_uuid = fixed_ip['subnet_id']",
            "        if subnet_uuid in self.local_dvr_map:",
            "            ldm = self.local_dvr_map[subnet_uuid]",
            "        else:",
            "            # set up LocalDVRSubnetMapping available for this subnet",
            "            subnet_info = self.plugin_rpc.get_subnet_for_dvr(",
            "                self.context, subnet_uuid, fixed_ips=fixed_ips)",
            "            if not subnet_info:",
            "                LOG.warning(\"DVR: Unable to retrieve subnet information \"",
            "                            \"for subnet_id %s. The subnet or the gateway \"",
            "                            \"may have already been deleted\", subnet_uuid)",
            "                return",
            "            LOG.debug(\"get_subnet_for_dvr for subnet %(uuid)s \"",
            "                      \"returned with %(info)s\",",
            "                      {\"uuid\": subnet_uuid, \"info\": subnet_info})",
            "            ldm = LocalDVRSubnetMapping(subnet_info)",
            "            self.local_dvr_map[subnet_uuid] = ldm",
            "",
            "        # DVR takes over",
            "        ldm.set_dvr_owned(True)",
            "",
            "        vlan_to_use = lvm.vlan",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            vlan_to_use = lvm.segmentation_id",
            "",
            "        subnet_info = ldm.get_subnet_info()",
            "        ip_version = subnet_info['ip_version']",
            "",
            "        if self.firewall and isinstance(self.firewall,",
            "                                        ovs_firewall.OVSFirewallDriver):",
            "            tunnel_direct_info = {\"network_type\": lvm.network_type,",
            "                                  \"physical_network\": lvm.physical_network}",
            "            self.firewall.install_accepted_egress_direct_flow(",
            "                subnet_info['gateway_mac'], lvm.vlan, port.ofport,",
            "                tunnel_direct_info=tunnel_direct_info)",
            "",
            "        local_compute_ports = (",
            "            self.plugin_rpc.get_ports_on_host_by_subnet(",
            "                self.context, self.host, subnet_uuid))",
            "        LOG.debug(\"DVR: List of ports received from \"",
            "                  \"get_ports_on_host_by_subnet %s\",",
            "                  local_compute_ports)",
            "        vif_by_id = self.int_br.get_vifs_by_ids(",
            "            [local_port['id'] for local_port in local_compute_ports])",
            "",
            "        # A router port has an OVS interface with type internal. Once the",
            "        # interface is created, a valid ofport will be assigned.",
            "        vif_by_id = {k: v for k, v in vif_by_id.items()",
            "                     if not v or v.ofport not in",
            "                     (ovs_lib.INVALID_OFPORT, ovs_lib.UNASSIGNED_OFPORT)}",
            "",
            "        for local_port in local_compute_ports:",
            "            vif = vif_by_id.get(local_port['id'])",
            "            if not vif:",
            "                continue",
            "            ldm.add_compute_ofport(vif.vif_id, vif.ofport)",
            "            if vif.vif_id in self.local_ports:",
            "                # ensure if a compute port is already on",
            "                # a different dvr routed subnet",
            "                # if yes, queue this subnet to that port",
            "                comp_ovsport = self.local_ports[vif.vif_id]",
            "                comp_ovsport.add_subnet(subnet_uuid)",
            "            else:",
            "                # the compute port is discovered first here that its on",
            "                # a dvr routed subnet queue this subnet to that port",
            "                comp_ovsport = OVSPort(vif.vif_id, vif.ofport,",
            "                                       vif.vif_mac, local_port['device_owner'])",
            "                comp_ovsport.add_subnet(subnet_uuid)",
            "                self.local_ports[vif.vif_id] = comp_ovsport",
            "            # create rule for just this vm port",
            "            self.int_br.install_dvr_to_src_mac(",
            "                network_type=lvm.network_type,",
            "                vlan_tag=vlan_to_use,",
            "                gateway_mac=subnet_info['gateway_mac'],",
            "                dst_mac=comp_ovsport.get_mac(),",
            "                dst_port=comp_ovsport.get_ofport())",
            "        self.int_br.install_dvr_dst_mac_for_arp(",
            "            lvm.network_type,",
            "            vlan_tag=lvm.vlan,",
            "            gateway_mac=port.vif_mac,",
            "            dvr_mac=self.dvr_mac_address,",
            "            rtr_port=port.ofport)",
            "",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            # TODO(vivek) remove the IPv6 related flows once SNAT is not",
            "            # used for IPv6 DVR.",
            "            br = self.phys_brs[lvm.physical_network]",
            "        if lvm.network_type in constants.TUNNEL_NETWORK_TYPES:",
            "            br = self.tun_br",
            "        # TODO(vivek) remove the IPv6 related flows once SNAT is not",
            "        # used for IPv6 DVR.",
            "        if ip_version == 4:",
            "            br.install_dvr_process_ipv4(",
            "                vlan_tag=lvm.vlan, gateway_ip=fixed_ip['ip_address'])",
            "        else:",
            "            br.install_dvr_process_ipv6(",
            "                vlan_tag=lvm.vlan, gateway_mac=port.vif_mac)",
            "        br.install_dvr_process(",
            "            vlan_tag=lvm.vlan, vif_mac=port.vif_mac,",
            "            dvr_mac_address=self.dvr_mac_address)",
            "",
            "        # the dvr router interface is itself a port, so capture it",
            "        # queue this subnet to that port. A subnet appears only once as",
            "        # a router interface on any given router",
            "        ovsport = OVSPort(port.vif_id, port.ofport,",
            "                          port.vif_mac, device_owner)",
            "        ovsport.add_subnet(subnet_uuid)",
            "        self.local_ports[port.vif_id] = ovsport",
            "",
            "    def _bind_port_on_dvr_subnet(self, port, lvm, fixed_ips,",
            "                                 device_owner):",
            "        # Handle new compute port added use-case",
            "        subnet_uuid = None",
            "        for ips in fixed_ips:",
            "            if ips['subnet_id'] not in self.local_dvr_map:",
            "                continue",
            "            subnet_uuid = ips['subnet_id']",
            "            ldm = self.local_dvr_map[subnet_uuid]",
            "            if not ldm.is_dvr_owned():",
            "                # well this is CSNAT stuff, let dvr come in",
            "                # and do plumbing for this vm later",
            "                continue",
            "",
            "            # This confirms that this compute port belongs",
            "            # to a dvr hosted subnet.",
            "            # Accommodate this VM Port into the existing rule in",
            "            # the integration bridge",
            "            LOG.debug(\"DVR: Plumbing compute port %s\", port.vif_id)",
            "            subnet_info = ldm.get_subnet_info()",
            "            ldm.add_compute_ofport(port.vif_id, port.ofport)",
            "            if port.vif_id in self.local_ports:",
            "                # ensure if a compute port is already on a different",
            "                # dvr routed subnet",
            "                # if yes, queue this subnet to that port",
            "                ovsport = self.local_ports[port.vif_id]",
            "                ovsport.add_subnet(subnet_uuid)",
            "            else:",
            "                # the compute port is discovered first here that its",
            "                # on a dvr routed subnet, queue this subnet to that port",
            "                ovsport = OVSPort(port.vif_id, port.ofport,",
            "                                  port.vif_mac, device_owner)",
            "                ovsport.add_subnet(subnet_uuid)",
            "                self.local_ports[port.vif_id] = ovsport",
            "            vlan_to_use = lvm.vlan",
            "            if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "                vlan_to_use = lvm.segmentation_id",
            "            # create a rule for this vm port",
            "            self.int_br.install_dvr_to_src_mac(",
            "                network_type=lvm.network_type,",
            "                vlan_tag=vlan_to_use,",
            "                gateway_mac=subnet_info['gateway_mac'],",
            "                dst_mac=ovsport.get_mac(),",
            "                dst_port=ovsport.get_ofport())",
            "",
            "    def _bind_centralized_snat_port_on_dvr_subnet(self, port, lvm,",
            "                                                  fixed_ips, device_owner):",
            "        # We only pass the subnet uuid so the server code will correctly",
            "        # use the gateway_ip value from the subnet when looking up the",
            "        # centralized-SNAT (CSNAT) port, get it early from the first fixed_ip.",
            "        subnet_uuid = fixed_ips[0]['subnet_id']",
            "        if port.vif_id in self.local_ports:",
            "            # throw an error if CSNAT port is already on a different",
            "            # dvr routed subnet",
            "            ovsport = self.local_ports[port.vif_id]",
            "            subs = list(ovsport.get_subnets())",
            "            if subs[0] == subnet_uuid:",
            "                return",
            "            LOG.error(\"Centralized-SNAT port %(port)s on subnet \"",
            "                      \"%(port_subnet)s already seen on a different \"",
            "                      \"subnet %(orig_subnet)s\", {",
            "                          \"port\": port.vif_id,",
            "                          \"port_subnet\": subnet_uuid,",
            "                          \"orig_subnet\": subs[0],",
            "                      })",
            "            return",
            "        ldm = None",
            "        subnet_info = None",
            "        if subnet_uuid not in self.local_dvr_map:",
            "            # no csnat ports seen on this subnet - create csnat state",
            "            # for this subnet",
            "            subnet_info = self.plugin_rpc.get_subnet_for_dvr(",
            "                self.context, subnet_uuid, fixed_ips=None)",
            "            if not subnet_info:",
            "                LOG.warning(\"DVR: Unable to retrieve subnet information \"",
            "                            \"for subnet_id %s. The subnet or the gateway \"",
            "                            \"may have already been deleted\", subnet_uuid)",
            "                return",
            "            LOG.debug(\"get_subnet_for_dvr for subnet %(uuid)s \"",
            "                      \"returned with %(info)s\",",
            "                      {\"uuid\": subnet_uuid, \"info\": subnet_info})",
            "            ldm = LocalDVRSubnetMapping(subnet_info, port.ofport)",
            "            self.local_dvr_map[subnet_uuid] = ldm",
            "        else:",
            "            ldm = self.local_dvr_map[subnet_uuid]",
            "            subnet_info = ldm.get_subnet_info()",
            "            # Store csnat OF Port in the existing DVRSubnetMap",
            "            ldm.set_csnat_ofport(port.ofport)",
            "",
            "        # create ovsPort footprint for csnat port",
            "        ovsport = OVSPort(port.vif_id, port.ofport,",
            "                          port.vif_mac, device_owner)",
            "        ovsport.add_subnet(subnet_uuid)",
            "        self.local_ports[port.vif_id] = ovsport",
            "        vlan_to_use = lvm.vlan",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            vlan_to_use = lvm.segmentation_id",
            "        self.int_br.install_dvr_to_src_mac(",
            "            network_type=lvm.network_type,",
            "            vlan_tag=vlan_to_use,",
            "            gateway_mac=subnet_info['gateway_mac'],",
            "            dst_mac=ovsport.get_mac(),",
            "            dst_port=ovsport.get_ofport())",
            "",
            "    def bind_port_to_dvr(self, port, local_vlan_map,",
            "                         fixed_ips, device_owner):",
            "        if not self.in_distributed_mode():",
            "            return",
            "",
            "        if (local_vlan_map.network_type not in",
            "                (constants.TUNNEL_NETWORK_TYPES +",
            "                 constants.DVR_PHYSICAL_NETWORK_TYPES)):",
            "            LOG.debug(\"DVR: Port %s is with network_type %s not supported\"",
            "                      \" for dvr plumbing\", port.vif_id,",
            "                      local_vlan_map.network_type)",
            "            return",
            "",
            "        if (port.vif_id in self.local_ports and",
            "                self.local_ports[port.vif_id].ofport != port.ofport):",
            "            LOG.info(\"DVR: Port %(vif)s changed port number to \"",
            "                     \"%(ofport)s, rebinding.\",",
            "                     {'vif': port.vif_id, 'ofport': port.ofport})",
            "            self.unbind_port_from_dvr(port, local_vlan_map)",
            "            if port.ofport in (ovs_lib.INVALID_OFPORT,",
            "                               ovs_lib.UNASSIGNED_OFPORT):",
            "                return",
            "",
            "        if device_owner == n_const.DEVICE_OWNER_DVR_INTERFACE:",
            "            self._bind_distributed_router_interface_port(port,",
            "                                                         local_vlan_map,",
            "                                                         fixed_ips,",
            "                                                         device_owner)",
            "",
            "        if device_owner and n_utils.is_dvr_serviced(device_owner):",
            "            self._bind_port_on_dvr_subnet(port, local_vlan_map,",
            "                                          fixed_ips,",
            "                                          device_owner)",
            "",
            "        if device_owner == n_const.DEVICE_OWNER_ROUTER_SNAT:",
            "            self._bind_centralized_snat_port_on_dvr_subnet(port,",
            "                                                           local_vlan_map,",
            "                                                           fixed_ips,",
            "                                                           device_owner)",
            "",
            "    def _unbind_distributed_router_interface_port(self, port, lvm):",
            "        ovsport = self.local_ports[port.vif_id]",
            "        # removal of distributed router interface",
            "        subnet_ids = ovsport.get_subnets()",
            "        subnet_set = set(subnet_ids)",
            "        network_type = lvm.network_type",
            "        physical_network = lvm.physical_network",
            "        vlan_to_use = lvm.vlan",
            "        if network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            vlan_to_use = lvm.segmentation_id",
            "        # ensure we process for all the subnets laid on this removed port",
            "        for sub_uuid in subnet_set:",
            "            if sub_uuid not in self.local_dvr_map:",
            "                continue",
            "            ldm = self.local_dvr_map[sub_uuid]",
            "            subnet_info = ldm.get_subnet_info()",
            "            ip_version = subnet_info['ip_version']",
            "            # DVR is no more owner",
            "            ldm.set_dvr_owned(False)",
            "            # remove all vm rules for this dvr subnet",
            "            # clear of compute_ports altogether",
            "            compute_ports = ldm.get_compute_ofports()",
            "            for vif_id in compute_ports:",
            "                comp_port = self.local_ports[vif_id]",
            "                self.int_br.delete_dvr_to_src_mac(",
            "                    network_type=network_type,",
            "                    vlan_tag=vlan_to_use, dst_mac=comp_port.get_mac())",
            "            ldm.remove_all_compute_ofports()",
            "            self.int_br.delete_dvr_dst_mac_for_arp(",
            "                network_type=network_type,",
            "                vlan_tag=vlan_to_use,",
            "                gateway_mac=port.vif_mac,",
            "                dvr_mac=self.dvr_mac_address,",
            "                rtr_port=port.ofport)",
            "            if ldm.get_csnat_ofport() == constants.OFPORT_INVALID:",
            "                # if there is no csnat port for this subnet, remove",
            "                # this subnet from local_dvr_map, as no dvr (or) csnat",
            "                # ports available on this agent anymore",
            "                self.local_dvr_map.pop(sub_uuid, None)",
            "            if network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "                br = self.phys_brs[physical_network]",
            "            if network_type in constants.TUNNEL_NETWORK_TYPES:",
            "                br = self.tun_br",
            "            if ip_version == 4:",
            "                if subnet_info['gateway_ip']:",
            "                    br.delete_dvr_process_ipv4(",
            "                        vlan_tag=lvm.vlan,",
            "                        gateway_ip=subnet_info['gateway_ip'])",
            "            else:",
            "                br.delete_dvr_process_ipv6(",
            "                    vlan_tag=lvm.vlan, gateway_mac=subnet_info['gateway_mac'])",
            "            ovsport.remove_subnet(sub_uuid)",
            "",
            "            if self.firewall and isinstance(self.firewall,",
            "                                            ovs_firewall.OVSFirewallDriver):",
            "                self.firewall.delete_accepted_egress_direct_flow(",
            "                    subnet_info['gateway_mac'], lvm.vlan)",
            "",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            br = self.phys_brs[physical_network]",
            "        if lvm.network_type in constants.TUNNEL_NETWORK_TYPES:",
            "            br = self.tun_br",
            "        br.delete_dvr_process(vlan_tag=lvm.vlan, vif_mac=port.vif_mac)",
            "",
            "        # release port state",
            "        self.local_ports.pop(port.vif_id, None)",
            "",
            "    def _unbind_port_on_dvr_subnet(self, port, lvm):",
            "        ovsport = self.local_ports[port.vif_id]",
            "        # This confirms that this compute port being removed belonged",
            "        # to a dvr hosted subnet.",
            "        LOG.debug(\"DVR: Removing plumbing for compute port %s\", port)",
            "        subnet_ids = ovsport.get_subnets()",
            "        # ensure we process for all the subnets laid on this port",
            "        for sub_uuid in subnet_ids:",
            "            if sub_uuid not in self.local_dvr_map:",
            "                continue",
            "            ldm = self.local_dvr_map[sub_uuid]",
            "            ldm.remove_compute_ofport(port.vif_id)",
            "            vlan_to_use = lvm.vlan",
            "            if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "                vlan_to_use = lvm.segmentation_id",
            "            # first remove this vm port rule",
            "            self.int_br.delete_dvr_to_src_mac(",
            "                network_type=lvm.network_type,",
            "                vlan_tag=vlan_to_use, dst_mac=ovsport.get_mac())",
            "        # release port state",
            "        self.local_ports.pop(port.vif_id, None)",
            "",
            "    def _unbind_centralized_snat_port_on_dvr_subnet(self, port, lvm):",
            "        ovsport = self.local_ports[port.vif_id]",
            "        # This confirms that this compute port being removed belonged",
            "        # to a dvr hosted subnet.",
            "        LOG.debug(\"DVR: Removing plumbing for csnat port %s\", port)",
            "        sub_uuid = list(ovsport.get_subnets())[0]",
            "        # ensure we process for all the subnets laid on this port",
            "        if sub_uuid not in self.local_dvr_map:",
            "            return",
            "        ldm = self.local_dvr_map[sub_uuid]",
            "        ldm.set_csnat_ofport(constants.OFPORT_INVALID)",
            "        vlan_to_use = lvm.vlan",
            "        if lvm.network_type in constants.DVR_PHYSICAL_NETWORK_TYPES:",
            "            vlan_to_use = lvm.segmentation_id",
            "        # then remove csnat port rule",
            "        self.int_br.delete_dvr_to_src_mac(",
            "            network_type=lvm.network_type,",
            "            vlan_tag=vlan_to_use, dst_mac=ovsport.get_mac())",
            "        if not ldm.is_dvr_owned():",
            "            # if not owned by DVR (only used for csnat), remove this",
            "            # subnet state altogether",
            "            self.local_dvr_map.pop(sub_uuid, None)",
            "        # release port state",
            "        self.local_ports.pop(port.vif_id, None)",
            "",
            "    def unbind_port_from_dvr(self, vif_port, local_vlan_map):",
            "        if not self.in_distributed_mode():",
            "            return",
            "        # Handle port removed use-case",
            "        if vif_port and vif_port.vif_id not in self.local_ports:",
            "            LOG.debug(\"DVR: Non distributed port, ignoring %s\", vif_port)",
            "            return",
            "",
            "        ovsport = self.local_ports[vif_port.vif_id]",
            "        device_owner = ovsport.get_device_owner()",
            "",
            "        if device_owner == n_const.DEVICE_OWNER_DVR_INTERFACE:",
            "            self._unbind_distributed_router_interface_port(vif_port,",
            "                                                           local_vlan_map)",
            "",
            "        if device_owner and n_utils.is_dvr_serviced(device_owner):",
            "            self._unbind_port_on_dvr_subnet(vif_port,",
            "                                            local_vlan_map)",
            "",
            "        if device_owner == n_const.DEVICE_OWNER_ROUTER_SNAT:",
            "            self._unbind_centralized_snat_port_on_dvr_subnet(vif_port,",
            "                                                             local_vlan_map)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "neutron.plugins.ml2.drivers.openvswitch.agent.ovs_dvr_neutron_agent.OVSDVRNeutronAgent.bind_port_to_dvr",
            "neutron.plugins.ml2.drivers.openvswitch.agent.ovs_dvr_neutron_agent.OVSDVRNeutronAgent._bind_distributed_router_interface_port.tunnel_direct_info",
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs"
        ]
    },
    "neutron/plugins/ml2/drivers/openvswitch/agent/ovs_neutron_agent.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1911,
                "afterPatchRowNumber": 1911,
                "PatchRowcode": "         devices = devices_details_list.get('devices')"
            },
            "1": {
                "beforePatchRowNumber": 1912,
                "afterPatchRowNumber": 1912,
                "PatchRowcode": "         vif_by_id = self.int_br.get_vifs_by_ids("
            },
            "2": {
                "beforePatchRowNumber": 1913,
                "afterPatchRowNumber": 1913,
                "PatchRowcode": "             [vif['device'] for vif in devices])"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1914,
                "PatchRowcode": "+        devices_not_in_datapath = set()"
            },
            "4": {
                "beforePatchRowNumber": 1914,
                "afterPatchRowNumber": 1915,
                "PatchRowcode": "         for details in devices:"
            },
            "5": {
                "beforePatchRowNumber": 1915,
                "afterPatchRowNumber": 1916,
                "PatchRowcode": "             device = details['device']"
            },
            "6": {
                "beforePatchRowNumber": 1916,
                "afterPatchRowNumber": 1917,
                "PatchRowcode": "             LOG.debug(\"Processing port: %s\", device)"
            },
            "7": {
                "beforePatchRowNumber": 1923,
                "afterPatchRowNumber": 1924,
                "PatchRowcode": "                 skipped_devices.append(device)"
            },
            "8": {
                "beforePatchRowNumber": 1924,
                "afterPatchRowNumber": 1925,
                "PatchRowcode": "                 continue"
            },
            "9": {
                "beforePatchRowNumber": 1925,
                "afterPatchRowNumber": 1926,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1927,
                "PatchRowcode": "+            if not port.ofport or port.ofport == ovs_lib.INVALID_OFPORT:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1928,
                "PatchRowcode": "+                devices_not_in_datapath.add(device)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1929,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 1926,
                "afterPatchRowNumber": 1930,
                "PatchRowcode": "             if 'port_id' in details:"
            },
            "14": {
                "beforePatchRowNumber": 1927,
                "afterPatchRowNumber": 1931,
                "PatchRowcode": "                 LOG.info(\"Port %(device)s updated. Details: %(details)s\","
            },
            "15": {
                "beforePatchRowNumber": 1928,
                "afterPatchRowNumber": 1932,
                "PatchRowcode": "                          {'device': device, 'details': details})"
            },
            "16": {
                "beforePatchRowNumber": 1942,
                "afterPatchRowNumber": 1946,
                "PatchRowcode": "                                           details['network_id'])"
            },
            "17": {
                "beforePatchRowNumber": 1943,
                "afterPatchRowNumber": 1947,
                "PatchRowcode": "                 if details['device'] in re_added:"
            },
            "18": {
                "beforePatchRowNumber": 1944,
                "afterPatchRowNumber": 1948,
                "PatchRowcode": "                     self.ext_manager.delete_port(self.context, details)"
            },
            "19": {
                "beforePatchRowNumber": 1945,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.ext_manager.handle_port(self.context, details)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1949,
                "PatchRowcode": "+                if device not in devices_not_in_datapath:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1950,
                "PatchRowcode": "+                    self.ext_manager.handle_port(self.context, details)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1951,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 1946,
                "afterPatchRowNumber": 1952,
                "PatchRowcode": "             else:"
            },
            "24": {
                "beforePatchRowNumber": 1947,
                "afterPatchRowNumber": 1953,
                "PatchRowcode": "                 if n_const.NO_ACTIVE_BINDING in details:"
            },
            "25": {
                "beforePatchRowNumber": 1948,
                "afterPatchRowNumber": 1954,
                "PatchRowcode": "                     # Port was added to the bridge, but its binding in this"
            },
            "26": {
                "beforePatchRowNumber": 1958,
                "afterPatchRowNumber": 1964,
                "PatchRowcode": "                 if (port and port.ofport != -1):"
            },
            "27": {
                "beforePatchRowNumber": 1959,
                "afterPatchRowNumber": 1965,
                "PatchRowcode": "                     self.port_dead(port)"
            },
            "28": {
                "beforePatchRowNumber": 1960,
                "afterPatchRowNumber": 1966,
                "PatchRowcode": "         return (skipped_devices, binding_no_activated_devices,"
            },
            "29": {
                "beforePatchRowNumber": 1961,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                need_binding_devices, failed_devices)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1967,
                "PatchRowcode": "+                need_binding_devices, failed_devices, devices_not_in_datapath)"
            },
            "31": {
                "beforePatchRowNumber": 1962,
                "afterPatchRowNumber": 1968,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 1963,
                "afterPatchRowNumber": 1969,
                "PatchRowcode": "     def _update_port_network(self, port_id, network_id):"
            },
            "33": {
                "beforePatchRowNumber": 1964,
                "afterPatchRowNumber": 1970,
                "PatchRowcode": "         self._clean_network_ports(port_id)"
            },
            "34": {
                "beforePatchRowNumber": 2051,
                "afterPatchRowNumber": 2057,
                "PatchRowcode": "         need_binding_devices = []"
            },
            "35": {
                "beforePatchRowNumber": 2052,
                "afterPatchRowNumber": 2058,
                "PatchRowcode": "         skipped_devices = set()"
            },
            "36": {
                "beforePatchRowNumber": 2053,
                "afterPatchRowNumber": 2059,
                "PatchRowcode": "         binding_no_activated_devices = set()"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2060,
                "PatchRowcode": "+        devices_not_in_datapath = set()"
            },
            "38": {
                "beforePatchRowNumber": 2054,
                "afterPatchRowNumber": 2061,
                "PatchRowcode": "         start = time.time()"
            },
            "39": {
                "beforePatchRowNumber": 2055,
                "afterPatchRowNumber": 2062,
                "PatchRowcode": "         if devices_added_updated:"
            },
            "40": {
                "beforePatchRowNumber": 2056,
                "afterPatchRowNumber": 2063,
                "PatchRowcode": "             (skipped_devices, binding_no_activated_devices,"
            },
            "41": {
                "beforePatchRowNumber": 2057,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-             need_binding_devices, failed_devices['added']) = ("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2064,
                "PatchRowcode": "+             need_binding_devices, failed_devices['added'],"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2065,
                "PatchRowcode": "+             devices_not_in_datapath) = ("
            },
            "44": {
                "beforePatchRowNumber": 2058,
                "afterPatchRowNumber": 2066,
                "PatchRowcode": "                 self.treat_devices_added_or_updated("
            },
            "45": {
                "beforePatchRowNumber": 2059,
                "afterPatchRowNumber": 2067,
                "PatchRowcode": "                     devices_added_updated, provisioning_needed, re_added))"
            },
            "46": {
                "beforePatchRowNumber": 2060,
                "afterPatchRowNumber": 2068,
                "PatchRowcode": "             LOG.info(\"process_network_ports - iteration:%(iter_num)d - \""
            },
            "47": {
                "beforePatchRowNumber": 2079,
                "afterPatchRowNumber": 2087,
                "PatchRowcode": "         added_ports = (port_info.get('added', set()) - skipped_devices -"
            },
            "48": {
                "beforePatchRowNumber": 2080,
                "afterPatchRowNumber": 2088,
                "PatchRowcode": "                        binding_no_activated_devices)"
            },
            "49": {
                "beforePatchRowNumber": 2081,
                "afterPatchRowNumber": 2089,
                "PatchRowcode": "         self._add_port_tag_info(need_binding_devices)"
            },
            "50": {
                "beforePatchRowNumber": 2082,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "51": {
                "beforePatchRowNumber": 2083,
                "afterPatchRowNumber": 2090,
                "PatchRowcode": "         self.process_install_ports_egress_flows(need_binding_devices)"
            },
            "52": {
                "beforePatchRowNumber": 2084,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "53": {
                "beforePatchRowNumber": 2085,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.sg_agent.setup_port_filters(added_ports,"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2091,
                "PatchRowcode": "+        added_to_datapath = added_ports - devices_not_in_datapath"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2092,
                "PatchRowcode": "+        self.sg_agent.setup_port_filters(added_to_datapath,"
            },
            "56": {
                "beforePatchRowNumber": 2086,
                "afterPatchRowNumber": 2093,
                "PatchRowcode": "                                          port_info.get('updated', set()))"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2094,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": 2087,
                "afterPatchRowNumber": 2095,
                "PatchRowcode": "         LOG.info(\"process_network_ports - iteration:%(iter_num)d - \""
            },
            "59": {
                "beforePatchRowNumber": 2088,
                "afterPatchRowNumber": 2096,
                "PatchRowcode": "                  \"agent port security group processed in %(elapsed).3f\","
            },
            "60": {
                "beforePatchRowNumber": 2089,
                "afterPatchRowNumber": 2097,
                "PatchRowcode": "                  {'iter_num': self.iter_num,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2011 VMware, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import collections",
            "import functools",
            "import hashlib",
            "import signal",
            "import sys",
            "import time",
            "",
            "import eventlet",
            "import netaddr",
            "from neutron_lib.agent import constants as agent_consts",
            "from neutron_lib.agent import topics",
            "from neutron_lib.api.definitions import portbindings",
            "from neutron_lib.api.definitions import provider_net",
            "from neutron_lib.callbacks import events as callback_events",
            "from neutron_lib.callbacks import registry",
            "from neutron_lib.callbacks import resources as callback_resources",
            "from neutron_lib import constants as n_const",
            "from neutron_lib import context",
            "from neutron_lib.placement import utils as place_utils",
            "from neutron_lib.plugins import utils as plugin_utils",
            "from neutron_lib.utils import helpers",
            "import os_vif",
            "from os_vif.objects import instance_info as vif_instance_object",
            "from os_vif.objects import network as vif_network_object",
            "from os_vif.objects import vif as vif_obj",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "import oslo_messaging",
            "from oslo_service import loopingcall",
            "from oslo_service import systemd",
            "from oslo_utils import netutils",
            "from osprofiler import profiler",
            "from ovsdbapp import exceptions as ovs_exceptions",
            "",
            "from neutron._i18n import _",
            "from neutron.agent.common import ip_lib",
            "from neutron.agent.common import ovs_lib",
            "from neutron.agent.common import polling",
            "from neutron.agent.common import utils",
            "from neutron.agent import firewall as agent_firewall",
            "from neutron.agent.l2 import l2_agent_extensions_manager as ext_manager",
            "from neutron.agent.linux import xenapi_root_helper",
            "from neutron.agent import rpc as agent_rpc",
            "from neutron.agent import securitygroups_rpc as agent_sg_rpc",
            "from neutron.api.rpc.callbacks import resources",
            "from neutron.api.rpc.handlers import dvr_rpc",
            "from neutron.api.rpc.handlers import securitygroups_rpc as sg_rpc",
            "from neutron.common import config",
            "from neutron.common import utils as n_utils",
            "from neutron.conf.agent import common as agent_config",
            "from neutron.conf.agent import xenapi_conf",
            "from neutron.conf import service as service_conf",
            "from neutron.plugins.ml2.drivers.agent import capabilities",
            "from neutron.plugins.ml2.drivers.l2pop.rpc_manager import l2population_rpc",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common \\",
            "    import constants",
            "from neutron.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_agent_extension_api as ovs_ext_api",
            "from neutron.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_capabilities",
            "from neutron.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_dvr_neutron_agent",
            "from neutron.plugins.ml2.drivers.openvswitch.agent import vlanmanager",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "cfg.CONF.import_group('AGENT', 'neutron.plugins.ml2.drivers.openvswitch.'",
            "                      'agent.common.config')",
            "cfg.CONF.import_group('OVS', 'neutron.plugins.ml2.drivers.openvswitch.agent.'",
            "                      'common.config')",
            "",
            "INIT_MAX_TRIES = 3",
            "",
            "",
            "class _mac_mydialect(netaddr.mac_unix):",
            "    word_fmt = '%.2x'",
            "",
            "",
            "class OVSPluginApi(agent_rpc.CacheBackedPluginApi):",
            "    pass",
            "",
            "",
            "class PortInfo(collections.UserDict):",
            "    def __init__(self, current=None, added=None, removed=None, updated=None,",
            "                 re_added=None):",
            "        _dict = {'current': current or set(),",
            "                 'added': added or set(),",
            "                 'removed': removed or set(),",
            "                 'updated': updated or set(),",
            "                 're_added': re_added or set()}",
            "        super(PortInfo, self).__init__(_dict)",
            "",
            "",
            "def has_zero_prefixlen_address(ip_addresses):",
            "    return any(netaddr.IPNetwork(ip).prefixlen == 0 for ip in ip_addresses)",
            "",
            "",
            "class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,",
            "                      dvr_rpc.DVRAgentRpcCallbackMixin):",
            "    '''Implements OVS-based tunneling, VLANs and flat networks.",
            "",
            "    Two local bridges are created: an integration bridge (defaults to",
            "    'br-int') and a tunneling bridge (defaults to 'br-tun'). An",
            "    additional bridge is created for each physical network interface",
            "    used for VLANs and/or flat networks.",
            "",
            "    All VM VIFs are plugged into the integration bridge. VM VIFs on a",
            "    given virtual network share a common \"local\" VLAN (i.e. not",
            "    propagated externally). The VLAN id of this local VLAN is mapped",
            "    to the physical networking details realizing that virtual network.",
            "",
            "    For virtual networks realized as GRE tunnels, a Logical Switch",
            "    (LS) identifier is used to differentiate tenant traffic on",
            "    inter-HV tunnels. A mesh of tunnels is created to other",
            "    Hypervisors in the cloud. These tunnels originate and terminate on",
            "    the tunneling bridge of each hypervisor. Port patching is done to",
            "    connect local VLANs on the integration bridge to inter-hypervisor",
            "    tunnels on the tunnel bridge.",
            "",
            "    For each virtual network realized as a VLAN or flat network, a",
            "    veth or a pair of patch ports is used to connect the local VLAN on",
            "    the integration bridge with the physical network bridge, with flow",
            "    rules adding, modifying, or stripping VLAN tags as necessary.",
            "    '''",
            "",
            "    # history",
            "    #   1.0 Initial version",
            "    #   1.1 Support Security Group RPC",
            "    #   1.2 Support DVR (Distributed Virtual Router) RPC",
            "    #   1.3 Added param devices_to_update to security_groups_provider_updated",
            "    #   1.4 Added support for network_update",
            "    #   1.5 Added binding_activate and binding_deactivate",
            "    #   1.7 Add support for smartnic ports",
            "    target = oslo_messaging.Target(version='1.7')",
            "",
            "    def __init__(self, bridge_classes, ext_manager, conf=None):",
            "        '''Constructor.",
            "",
            "        :param bridge_classes: a dict for bridge classes.",
            "        :param conf: an instance of ConfigOpts",
            "        '''",
            "        super(OVSNeutronAgent, self).__init__()",
            "        self.conf = conf or cfg.CONF",
            "        self.ovs = ovs_lib.BaseOVS()",
            "        self.ext_manager = ext_manager",
            "        agent_conf = self.conf.AGENT",
            "        ovs_conf = self.conf.OVS",
            "",
            "        self.fullsync = False",
            "        # init bridge classes with configured datapath type.",
            "        self.br_int_cls, self.br_phys_cls, self.br_tun_cls = (",
            "            functools.partial(bridge_classes[b],",
            "                              datapath_type=ovs_conf.datapath_type)",
            "            for b in ('br_int', 'br_phys', 'br_tun'))",
            "",
            "        self.use_veth_interconnection = ovs_conf.use_veth_interconnection",
            "        if self.use_veth_interconnection:",
            "            LOG.warning(\"Usage of veth instead of patch ports for bridges \"",
            "                        \"interconnection is deprecated in Victoria and will \"",
            "                        \"be removed in W release. Please use patch ports \"",
            "                        \"instead.\")",
            "        self.veth_mtu = agent_conf.veth_mtu",
            "        self.available_local_vlans = set(range(n_const.MIN_VLAN_TAG,",
            "                                               n_const.MAX_VLAN_TAG + 1))",
            "        self.tunnel_types = agent_conf.tunnel_types or []",
            "        self.enable_tunneling = bool(self.tunnel_types)",
            "        self.l2_pop = agent_conf.l2_population",
            "        # TODO(ethuleau): Change ARP responder so it's not dependent on the",
            "        #                 ML2 l2 population mechanism driver.",
            "        self.enable_distributed_routing = agent_conf.enable_distributed_routing",
            "        self.arp_responder_enabled = agent_conf.arp_responder and self.l2_pop",
            "        if (self.enable_distributed_routing and self.enable_tunneling and",
            "                not self.arp_responder_enabled):",
            "            LOG.warning(\"ARP responder was not enabled but is required since \"",
            "                        \"DVR and tunneling are enabled, setting to True.\")",
            "            self.arp_responder_enabled = True",
            "",
            "        host = self.conf.host",
            "        self.agent_id = 'ovs-agent-%s' % host",
            "",
            "        # Validate agent configurations",
            "        self._check_agent_configurations()",
            "",
            "        # Keep track of int_br's device count for use by _report_state()",
            "        self.int_br_device_count = 0",
            "",
            "        self.int_br = self.br_int_cls(ovs_conf.integration_bridge)",
            "        self.setup_integration_br()",
            "        # Stores port update notifications for processing in main rpc loop",
            "        self.updated_ports = set()",
            "        # Stores port delete notifications",
            "        self.deleted_ports = set()",
            "        # Stores the port IDs whose binding has been deactivated",
            "        self.deactivated_bindings = set()",
            "        # Stores the port IDs whose binding has been activated",
            "        self.activated_bindings = set()",
            "        # Stores smartnic ports update/remove",
            "        self.updated_smartnic_ports = list()",
            "        # Stores integration bridge smartnic ports data",
            "        self.current_smartnic_ports_map = {}",
            "",
            "        self.network_ports = collections.defaultdict(set)",
            "        # keeps association between ports and ofports to detect ofport change",
            "        self.vifname_to_ofport_map = {}",
            "        # Stores newly created bridges",
            "        self.added_bridges = list()",
            "        self.bridge_mappings = self._parse_bridge_mappings(",
            "            ovs_conf.bridge_mappings)",
            "        self.rp_bandwidths = place_utils.parse_rp_bandwidths(",
            "            ovs_conf.resource_provider_bandwidths)",
            "",
            "        br_set = set(self.bridge_mappings.values())",
            "        n_utils.validate_rp_bandwidth(self.rp_bandwidths,",
            "                                      br_set)",
            "        self.rp_inventory_defaults = place_utils.parse_rp_inventory_defaults(",
            "            ovs_conf.resource_provider_inventory_defaults)",
            "        self.rp_hypervisors = utils.default_rp_hypervisors(",
            "            ovs_conf.resource_provider_hypervisors,",
            "            {k: [v] for k, v in self.bridge_mappings.items()}",
            "        )",
            "",
            "        self.setup_physical_bridges(self.bridge_mappings)",
            "        self.vlan_manager = vlanmanager.LocalVlanManager()",
            "",
            "        self._reset_tunnel_ofports()",
            "",
            "        self.polling_interval = agent_conf.polling_interval",
            "        self.minimize_polling = agent_conf.minimize_polling",
            "        self.ovsdb_monitor_respawn_interval = (",
            "            agent_conf.ovsdb_monitor_respawn_interval or",
            "            constants.DEFAULT_OVSDBMON_RESPAWN)",
            "        self.local_ip = ovs_conf.local_ip",
            "        self.tunnel_count = 0",
            "        self.vxlan_udp_port = agent_conf.vxlan_udp_port",
            "        self.dont_fragment = agent_conf.dont_fragment",
            "        self.tunnel_csum = agent_conf.tunnel_csum",
            "        self.tos = ('inherit'",
            "                    if agent_conf.dscp_inherit",
            "                    else (int(agent_conf.dscp) << 2",
            "                          if agent_conf.dscp",
            "                          else None))",
            "        self.tun_br = None",
            "        self.patch_int_ofport = constants.OFPORT_INVALID",
            "        self.patch_tun_ofport = constants.OFPORT_INVALID",
            "        if self.enable_tunneling:",
            "            # The patch_int_ofport and patch_tun_ofport are updated",
            "            # here inside the call to setup_tunnel_br()",
            "            self.setup_tunnel_br(ovs_conf.tunnel_bridge)",
            "            self.setup_tunnel_br_flows()",
            "",
            "        self.setup_rpc()",
            "",
            "        self.dvr_agent = ovs_dvr_neutron_agent.OVSDVRNeutronAgent(",
            "            self.context,",
            "            self.dvr_plugin_rpc,",
            "            self.int_br,",
            "            self.tun_br,",
            "            self.bridge_mappings,",
            "            self.phys_brs,",
            "            self.int_ofports,",
            "            self.phys_ofports,",
            "            self.patch_int_ofport,",
            "            self.patch_tun_ofport,",
            "            host,",
            "            self.enable_tunneling,",
            "            self.enable_distributed_routing)",
            "",
            "        if self.enable_distributed_routing:",
            "            self.dvr_agent.setup_dvr_flows()",
            "",
            "        # Collect additional bridges to monitor",
            "        self.ancillary_brs = self.setup_ancillary_bridges(",
            "            ovs_conf.integration_bridge, ovs_conf.tunnel_bridge)",
            "",
            "        agent_api = ovs_ext_api.OVSAgentExtensionAPI(self.int_br,",
            "                                                     self.tun_br,",
            "                                                     self.phys_brs)",
            "        self.ext_manager.initialize(",
            "            self.connection, constants.EXTENSION_DRIVER_TYPE, agent_api)",
            "",
            "        # In order to keep existed device's local vlan unchanged,",
            "        # restore local vlan mapping at start",
            "        self._restore_local_vlan_map()",
            "",
            "        # Security group agent support",
            "        self.sg_agent = agent_sg_rpc.SecurityGroupAgentRpc(",
            "            self.context, self.sg_plugin_rpc, defer_refresh_firewall=True,",
            "            integration_bridge=self.int_br)",
            "        self.sg_plugin_rpc.register_legacy_sg_notification_callbacks(",
            "            self.sg_agent)",
            "",
            "        self.sg_agent.init_ovs_dvr_firewall(self.dvr_agent)",
            "",
            "        # we default to False to provide backward compat with out of tree",
            "        # firewall drivers that expect the logic that existed on the Neutron",
            "        # server which only enabled hybrid plugging based on the use of the",
            "        # hybrid driver.",
            "        hybrid_plug = getattr(self.sg_agent.firewall,",
            "                              'OVS_HYBRID_PLUG_REQUIRED', False)",
            "        self.prevent_arp_spoofing = (",
            "            not self.sg_agent.firewall.provides_arp_spoofing_protection)",
            "",
            "        self.failed_report_state = False",
            "        # TODO(mangelajo): optimize resource_versions to only report",
            "        #                  versions about resources which are common,",
            "        #                  or which are used by specific extensions.",
            "        self.agent_state = {",
            "            'binary': n_const.AGENT_PROCESS_OVS,",
            "            'host': host,",
            "            'topic': n_const.L2_AGENT_TOPIC,",
            "            'configurations': {'bridge_mappings': self.bridge_mappings,",
            "                               n_const.RP_BANDWIDTHS: self.rp_bandwidths,",
            "                               n_const.RP_INVENTORY_DEFAULTS:",
            "                                   self.rp_inventory_defaults,",
            "                               'resource_provider_hypervisors':",
            "                               self.rp_hypervisors,",
            "                               'integration_bridge':",
            "                               ovs_conf.integration_bridge,",
            "                               'tunnel_types': self.tunnel_types,",
            "                               'tunneling_ip': self.local_ip,",
            "                               'l2_population': self.l2_pop,",
            "                               'arp_responder_enabled':",
            "                               self.arp_responder_enabled,",
            "                               'enable_distributed_routing':",
            "                               self.enable_distributed_routing,",
            "                               'log_agent_heartbeats':",
            "                               agent_conf.log_agent_heartbeats,",
            "                               'extensions': self.ext_manager.names(),",
            "                               'datapath_type': ovs_conf.datapath_type,",
            "                               'ovs_capabilities': self.ovs.capabilities,",
            "                               'vhostuser_socket_dir':",
            "                               ovs_conf.vhostuser_socket_dir,",
            "                               portbindings.OVS_HYBRID_PLUG: hybrid_plug,",
            "                               'baremetal_smartnic':",
            "                               self.conf.AGENT.baremetal_smartnic},",
            "            'resource_versions': resources.LOCAL_RESOURCE_VERSIONS,",
            "            'agent_type': n_const.AGENT_TYPE_OVS,",
            "            'start_flag': True}",
            "",
            "        report_interval = agent_conf.report_interval",
            "        if report_interval:",
            "            heartbeat = loopingcall.FixedIntervalLoopingCall(",
            "                self._report_state)",
            "            heartbeat.start(interval=report_interval)",
            "        # Initialize iteration counter",
            "        self.iter_num = 0",
            "        self.run_daemon_loop = True",
            "",
            "        self.catch_sigterm = False",
            "        self.catch_sighup = False",
            "",
            "        if self.conf.AGENT.baremetal_smartnic:",
            "            os_vif.initialize()",
            "",
            "        # The initialization is complete; we can start receiving messages",
            "        self.connection.consume_in_threads()",
            "",
            "        self.quitting_rpc_timeout = agent_conf.quitting_rpc_timeout",
            "",
            "    def _parse_bridge_mappings(self, bridge_mappings):",
            "        try:",
            "            return helpers.parse_mappings(bridge_mappings)",
            "        except ValueError as e:",
            "            raise ValueError(_(\"Parsing bridge_mappings failed: %s.\") % e)",
            "",
            "    def _report_state(self):",
            "        # How many devices are likely used by a VM",
            "        self.agent_state.get('configurations')['devices'] = (",
            "            self.int_br_device_count)",
            "        self.agent_state.get('configurations')['in_distributed_mode'] = (",
            "            self.dvr_agent.in_distributed_mode())",
            "",
            "        try:",
            "            agent_status = self.state_rpc.report_state(self.context,",
            "                                                       self.agent_state,",
            "                                                       True)",
            "            if agent_status == agent_consts.AGENT_REVIVED:",
            "                LOG.info('Agent has just been revived. '",
            "                         'Doing a full sync.')",
            "                self.fullsync = True",
            "",
            "            # we only want to update resource versions on startup",
            "            if self.agent_state.pop('resource_versions', None):",
            "                # On initial start, we notify systemd after initialization",
            "                # is complete.",
            "                systemd.notify_once()",
            "",
            "            if self.iter_num > 0:",
            "                # agent is considered started after",
            "                # initial sync with server (iter 0) is done",
            "                self.agent_state.pop('start_flag', None)",
            "",
            "        except Exception:",
            "            self.failed_report_state = True",
            "            LOG.exception(\"Failed reporting state!\")",
            "            return",
            "        if self.failed_report_state:",
            "            self.failed_report_state = False",
            "            LOG.info(\"Successfully reported state after a previous failure.\")",
            "",
            "    def _restore_local_vlan_map(self):",
            "        self._local_vlan_hints = {}",
            "        # skip INVALID and UNASSIGNED to match scan_ports behavior",
            "        ofport_filter = (ovs_lib.INVALID_OFPORT, ovs_lib.UNASSIGNED_OFPORT)",
            "        cur_ports = self.int_br.get_vif_ports(ofport_filter)",
            "        port_names = [p.port_name for p in cur_ports]",
            "        port_info = self.int_br.get_ports_attributes(",
            "            \"Port\", columns=[\"name\", \"other_config\", \"tag\"], ports=port_names)",
            "        by_name = {x['name']: x for x in port_info}",
            "        for port in cur_ports:",
            "            # if a port was deleted between get_vif_ports and",
            "            # get_ports_attributes, we",
            "            # will get a KeyError",
            "            try:",
            "                local_vlan_map = by_name[port.port_name]['other_config']",
            "                local_vlan = by_name[port.port_name]['tag']",
            "            except KeyError:",
            "                continue",
            "            if not local_vlan:",
            "                continue",
            "            net_uuid = local_vlan_map.get('net_uuid')",
            "            if (net_uuid and net_uuid not in self._local_vlan_hints and",
            "                    local_vlan != constants.DEAD_VLAN_TAG):",
            "                self.available_local_vlans.remove(local_vlan)",
            "                self._local_vlan_hints[local_vlan_map['net_uuid']] = local_vlan",
            "",
            "    def _dispose_local_vlan_hints(self):",
            "        self.available_local_vlans.update(self._local_vlan_hints.values())",
            "        self._local_vlan_hints = {}",
            "",
            "    def _reset_tunnel_ofports(self):",
            "        self.tun_br_ofports = {n_const.TYPE_GENEVE: {},",
            "                               n_const.TYPE_GRE: {},",
            "                               n_const.TYPE_VXLAN: {}}",
            "",
            "    def _update_network_segmentation_id(self, network):",
            "        if network.get(provider_net.NETWORK_TYPE) != n_const.TYPE_VLAN:",
            "            return",
            "",
            "        try:",
            "            lvm = self.vlan_manager.get(network['id'])",
            "        except vlanmanager.MappingNotFound:",
            "            return",
            "",
            "        segmentation_id_old = lvm.segmentation_id",
            "        if segmentation_id_old == network[provider_net.SEGMENTATION_ID]:",
            "            return",
            "        self.vlan_manager.update_segmentation_id(",
            "            network['id'], network[provider_net.SEGMENTATION_ID])",
            "",
            "        lvid = lvm.vlan",
            "        physical_network = network[provider_net.PHYSICAL_NETWORK]",
            "        phys_br = self.phys_brs[physical_network]",
            "        phys_port = self.phys_ofports[physical_network]",
            "        int_port = self.int_ofports[physical_network]",
            "        phys_br.reclaim_local_vlan(port=phys_port, lvid=lvid)",
            "        phys_br.provision_local_vlan(",
            "            port=phys_port, lvid=lvid,",
            "            segmentation_id=network[provider_net.SEGMENTATION_ID],",
            "            distributed=self.enable_distributed_routing)",
            "        self.int_br.reclaim_local_vlan(port=int_port,",
            "                                       segmentation_id=segmentation_id_old)",
            "        self.int_br.provision_local_vlan(",
            "            port=int_port, lvid=lvid,",
            "            segmentation_id=network[provider_net.SEGMENTATION_ID])",
            "",
            "    def setup_rpc(self):",
            "        self.plugin_rpc = OVSPluginApi(topics.PLUGIN)",
            "        # allow us to receive port_update/delete callbacks from the cache",
            "        self.plugin_rpc.register_legacy_notification_callbacks(self)",
            "        self.sg_plugin_rpc = sg_rpc.SecurityGroupServerAPIShim(",
            "            self.plugin_rpc.remote_resource_cache)",
            "        self.dvr_plugin_rpc = dvr_rpc.DVRServerRpcApi(topics.PLUGIN)",
            "        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.REPORTS)",
            "",
            "        # RPC network init",
            "        self.context = context.get_admin_context_without_session()",
            "        # Made a simple RPC call to Neutron Server.",
            "        while True:",
            "            try:",
            "                self.state_rpc.has_alive_neutron_server(self.context)",
            "            except oslo_messaging.MessagingTimeout as e:",
            "                LOG.warning('l2-agent cannot contact neutron server. '",
            "                            'Check connectivity to neutron server. '",
            "                            'Retrying... '",
            "                            'Detailed message: %(msg)s.', {'msg': e})",
            "                continue",
            "            break",
            "",
            "        # Define the listening consumers for the agent",
            "        consumers = [[constants.TUNNEL, topics.UPDATE],",
            "                     [constants.TUNNEL, topics.DELETE],",
            "                     [topics.DVR, topics.UPDATE]]",
            "        if self.l2_pop:",
            "            consumers.append([topics.L2POPULATION, topics.UPDATE])",
            "        self.connection = agent_rpc.create_consumers([self],",
            "                                                     topics.AGENT,",
            "                                                     consumers,",
            "                                                     start_listening=False)",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def port_update(self, context, **kwargs):",
            "        port = kwargs.get('port')",
            "        agent_restarted = kwargs.pop(\"agent_restarted\", False)",
            "        # Put the port identifier in the updated_ports set.",
            "        # Even if full port details might be provided to this call,",
            "        # they are not used since there is no guarantee the notifications",
            "        # are processed in the same order as the relevant API requests",
            "        if not agent_restarted:",
            "            # When ovs-agent is just restarted, the first RPC loop will",
            "            # process all the port as 'added'. And all of these ports will",
            "            # send a port_update notification after that processing. This",
            "            # will cause all these ports to be processed again in next RPC",
            "            # loop as 'updated'. So here we just ignore such local update",
            "            # notification.",
            "            self.updated_ports.add(port['id'])",
            "",
            "        if not self.conf.AGENT.baremetal_smartnic:",
            "            return",
            "        # In case of smart-nic port, add smart-nic representor port to",
            "        # the integration bridge.",
            "        port_data = (self.plugin_rpc.remote_resource_cache",
            "                     .get_resource_by_id(resources.PORT, port['id']))",
            "        if not port_data:",
            "            LOG.warning('Failed to get port details, port id: %s', port['id'])",
            "            return",
            "        for port_binding in port_data.get('bindings', []):",
            "            if port_binding['vnic_type'] == portbindings.VNIC_SMARTNIC:",
            "                if port_binding['host'] == self.conf.host:",
            "                    local_link = (port_binding['profile']",
            "                                  ['local_link_information'])",
            "                    if local_link:",
            "                        self._add_port_to_updated_smartnic_ports(",
            "                            port_data['mac_address'],",
            "                            local_link[0]['port_id'],",
            "                            port_data['id'],",
            "                            port_binding['vif_type'],",
            "                            port_data['device_id'])",
            "                elif (not port_binding['host'] and port_binding['vif_type'] ==",
            "                      portbindings.VIF_TYPE_UNBOUND and port['id'] in",
            "                      self.current_smartnic_ports_map.keys()):",
            "                    smartnic_port = self.current_smartnic_ports_map[",
            "                        port['id']]",
            "                    self._add_port_to_updated_smartnic_ports(",
            "                        smartnic_port['vif_mac'], smartnic_port['vif_name'],",
            "                        port['id'], portbindings.VIF_TYPE_UNBOUND)",
            "",
            "                else:",
            "                    # The port doesn't belong to this Smart NIC,",
            "                    # the reason for this could be multi Smart NIC",
            "                    # setup.",
            "                    LOG.info(\"Smart NIC port %(port_id)s does not belong \"",
            "                             \"to host %(host)s\",",
            "                             {'port_id': port['id'],",
            "                              'host': self.conf.host})",
            "",
            "    def treat_smartnic_port(self, smartnic_port_data):",
            "        mac = smartnic_port_data['mac']",
            "        vm_uuid = smartnic_port_data['vm_uuid']",
            "        rep_port = smartnic_port_data['vif_name']",
            "        iface_id = smartnic_port_data['iface_id']",
            "        vif_type = smartnic_port_data['vif_type']",
            "",
            "        instance_info = vif_instance_object.InstanceInfo(uuid=vm_uuid)",
            "        vif = self._get_vif_object(iface_id, rep_port, mac)",
            "        try:",
            "            if vif_type == portbindings.VIF_TYPE_OVS:",
            "                os_vif.plug(vif, instance_info)",
            "                self.current_smartnic_ports_map[iface_id] = (",
            "                    self.create_smartnic_port_map_entry_data(mac, rep_port))",
            "",
            "            elif vif_type == portbindings.VIF_TYPE_UNBOUND:",
            "                os_vif.unplug(vif, instance_info)",
            "                self.current_smartnic_ports_map.pop(iface_id, None)",
            "",
            "            else:",
            "                LOG.error(\"Unexpected vif_type:%(vif_type)s for \"",
            "                          \"%(vnic_type)s port:%(port_id)s\",",
            "                          {'vnic_type': portbindings.VNIC_SMARTNIC,",
            "                           'vif_type': vif_type,",
            "                           'port_id': iface_id})",
            "",
            "        except Exception as e:",
            "            LOG.error(\"Failed to treat %(vnic_type)s port:%(port_id)s , \"",
            "                      \"error:%(error)s\",",
            "                      {'vnic_type': portbindings.VNIC_SMARTNIC,",
            "                       'port_id': iface_id,",
            "                       'error': e})",
            "",
            "    def _get_vif_object(self, iface_id, rep_port, mac):",
            "        network = vif_network_object.Network(",
            "            bridge=self.conf.OVS.integration_bridge)",
            "        port_profile = vif_obj.VIFPortProfileOpenVSwitch(",
            "            interface_id=iface_id, create_port=True)",
            "        return vif_obj.VIFOpenVSwitch(",
            "            vif_name=rep_port, plugin='ovs', port_profile=port_profile,",
            "            network=network, address=str(mac))",
            "",
            "    def _add_port_to_updated_smartnic_ports(self, mac, vif_name, iface_id,",
            "                                            vif_type, vm_uuid=''):",
            "        self.updated_smartnic_ports.append({",
            "            'mac': mac,",
            "            'vm_uuid': vm_uuid,",
            "            'vif_name': vif_name,",
            "            'iface_id': iface_id,",
            "            'vif_type': vif_type})",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def port_delete(self, context, **kwargs):",
            "        port_id = kwargs.get('port_id')",
            "        self.deleted_ports.add(port_id)",
            "        self.updated_ports.discard(port_id)",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def network_update(self, context, **kwargs):",
            "        network_id = kwargs['network']['id']",
            "        network = self.plugin_rpc.get_network_details(",
            "            self.context, network_id, self.agent_id, self.conf.host)",
            "        self._update_network_segmentation_id(network)",
            "        for port_id in self.network_ports[network_id]:",
            "            # notifications could arrive out of order, if the port is deleted",
            "            # we don't want to update it anymore",
            "            if port_id not in self.deleted_ports:",
            "                self.updated_ports.add(port_id)",
            "        LOG.debug(\"network_update message processed for network \"",
            "                  \"%(network_id)s, with ports: %(ports)s\",",
            "                  {'network_id': network_id,",
            "                   'ports': self.network_ports[network_id]})",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def binding_deactivate(self, context, **kwargs):",
            "        if kwargs.get('host') != self.conf.host:",
            "            return",
            "        port_id = kwargs.get('port_id')",
            "        self.deactivated_bindings.add(port_id)",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def binding_activate(self, context, **kwargs):",
            "        if kwargs.get('host') != self.conf.host:",
            "            return",
            "        port_id = kwargs.get('port_id')",
            "        self.activated_bindings.add(port_id)",
            "",
            "    def _clean_network_ports(self, port_id):",
            "        for port_set in self.network_ports.values():",
            "            if port_id in port_set:",
            "                port_set.remove(port_id)",
            "                break",
            "",
            "    def _get_port_local_vlan(self, port_id):",
            "        for network_id, port_set in self.network_ports.items():",
            "            if port_id in port_set:",
            "                lvm = self.vlan_manager.get(network_id)",
            "                return lvm.vlan",
            "",
            "    def process_deleted_ports(self, port_info):",
            "        # don't try to process removed ports as deleted ports since",
            "        # they are already gone",
            "        if 'removed' in port_info:",
            "            self.deleted_ports -= port_info['removed']",
            "        deleted_ports = list(self.deleted_ports)",
            "",
            "        with self.int_br.deferred(full_ordered=True,",
            "                                  use_bundle=True) as int_br:",
            "            while self.deleted_ports:",
            "                port_id = self.deleted_ports.pop()",
            "                port = self.int_br.get_vif_port_by_id(port_id)",
            "",
            "                if (isinstance(self.sg_agent.firewall,",
            "                               agent_firewall.NoopFirewallDriver) or",
            "                        not agent_sg_rpc.is_firewall_enabled()):",
            "                    try:",
            "                        self.delete_accepted_egress_direct_flow(",
            "                            int_br,",
            "                            port.ofport,",
            "                            port.mac, self._get_port_local_vlan(port_id))",
            "                    except Exception as err:",
            "                        LOG.debug(\"Failed to remove accepted egress flows \"",
            "                                  \"for port %s, error: %s\", port_id, err)",
            "",
            "                self._clean_network_ports(port_id)",
            "                self.ext_manager.delete_port(self.context,",
            "                                             {\"vif_port\": port,",
            "                                              \"port_id\": port_id})",
            "                # move to dead VLAN so deleted ports no",
            "                # longer have access to the network",
            "                if port:",
            "                    # don't log errors since there is a chance someone will be",
            "                    # removing the port from the bridge at the same time",
            "                    self.port_dead(port, log_errors=False)",
            "                self.port_unbound(port_id)",
            "",
            "        # Flush firewall rules after ports are put on dead VLAN to be",
            "        # more secure",
            "        self.sg_agent.remove_devices_filter(deleted_ports)",
            "",
            "    def create_smartnic_port_map_entry_data(self, vif_mac, vif_name):",
            "        return {\"vif_mac\": vif_mac, \"vif_name\": vif_name}",
            "",
            "    def process_smartnic_ports(self):",
            "        smartnic_ports = self.plugin_rpc.get_ports_by_vnic_type_and_host(",
            "            self.context, portbindings.VNIC_SMARTNIC, self.conf.host)",
            "        smartnic_ports_map = {smartnic_port['id']: smartnic_port",
            "                              for smartnic_port in smartnic_ports}",
            "        smartnic_port_ids = set(smartnic_ports_map.keys())",
            "",
            "        ofport_filter = (ovs_lib.INVALID_OFPORT, ovs_lib.UNASSIGNED_OFPORT)",
            "        cur_smartnic_ports = self.int_br.get_vif_ports(ofport_filter)",
            "        self.current_smartnic_ports_map = {",
            "            port.vif_id: self.create_smartnic_port_map_entry_data(",
            "                port.vif_mac, port.port_name) for port in cur_smartnic_ports}",
            "        cur_smartnic_port_ids = set(self.current_smartnic_ports_map.keys())",
            "",
            "        removed_ports = [{'vif_id': vif_id, **self.current_smartnic_ports_map[",
            "            vif_id]} for vif_id in cur_smartnic_port_ids - smartnic_port_ids]",
            "        added_ports = [smartnic_ports_map[port_id] for port_id in",
            "                       smartnic_port_ids - cur_smartnic_port_ids]",
            "",
            "        def _process_added_ports(smartnic_added_ports):",
            "            for smartnic_port in smartnic_added_ports:",
            "                local_link = (smartnic_port['binding:profile']",
            "                              ['local_link_information'])",
            "                if local_link:",
            "                    self._add_port_to_updated_smartnic_ports(",
            "                        smartnic_port['mac_address'],",
            "                        local_link[0]['port_id'],",
            "                        smartnic_port['id'],",
            "                        smartnic_port['binding:vif_type'],",
            "                        smartnic_port['device_id'])",
            "",
            "        def _process_removed_ports(removed_ports):",
            "            for ovs_port in removed_ports:",
            "                self._add_port_to_updated_smartnic_ports(",
            "                        ovs_port['vif_mac'],",
            "                        ovs_port['vif_name'],",
            "                        ovs_port['vif_id'],",
            "                        portbindings.VIF_TYPE_UNBOUND)",
            "",
            "        _process_removed_ports(removed_ports)",
            "        _process_added_ports(added_ports)",
            "",
            "    def process_deactivated_bindings(self, port_info):",
            "        # don't try to deactivate bindings for removed ports since they are",
            "        # already gone",
            "        if 'removed' in port_info:",
            "            self.deactivated_bindings -= port_info['removed']",
            "        while self.deactivated_bindings:",
            "            port_id = self.deactivated_bindings.pop()",
            "            port = self.int_br.get_vif_port_by_id(port_id)",
            "            if not port:",
            "                continue",
            "            self.int_br.delete_port(port.port_name)",
            "            LOG.debug((\"Port id %s unplugged from integration bridge because \"",
            "                       \"its binding was de-activated\"), port_id)",
            "",
            "    def process_activated_bindings(self, port_info, activated_bindings_copy):",
            "        # Compute which ports for activated bindings are still present...",
            "        activated_bindings_copy &= port_info['current']",
            "        # ...and treat them as just added",
            "        port_info['added'] |= activated_bindings_copy",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def tunnel_update(self, context, **kwargs):",
            "        LOG.debug(\"tunnel_update received\")",
            "        if not self.enable_tunneling:",
            "            return",
            "        tunnel_ip = kwargs.get('tunnel_ip')",
            "        tunnel_type = kwargs.get('tunnel_type')",
            "        if not tunnel_type:",
            "            LOG.error(\"No tunnel_type specified, cannot create tunnels\")",
            "            return",
            "        if tunnel_type not in self.tunnel_types:",
            "            LOG.error(\"tunnel_type %s not supported by agent\",",
            "                      tunnel_type)",
            "            return",
            "        if tunnel_ip == self.local_ip:",
            "            return",
            "        tun_name = self.get_tunnel_name(tunnel_type, self.local_ip, tunnel_ip)",
            "        if tun_name is None:",
            "            return",
            "        if not self.l2_pop:",
            "            self._setup_tunnel_port(self.tun_br, tun_name, tunnel_ip,",
            "                                    tunnel_type)",
            "            self._setup_tunnel_flood_flow(self.tun_br, tunnel_type)",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def tunnel_delete(self, context, **kwargs):",
            "        LOG.debug(\"tunnel_delete received\")",
            "        if not self.enable_tunneling:",
            "            return",
            "        tunnel_ip = kwargs.get('tunnel_ip')",
            "        if not tunnel_ip:",
            "            LOG.error(\"No tunnel_ip specified, cannot delete tunnels\")",
            "            return",
            "        tunnel_type = kwargs.get('tunnel_type')",
            "        if not tunnel_type:",
            "            LOG.error(\"No tunnel_type specified, cannot delete tunnels\")",
            "            return",
            "        if tunnel_type not in self.tunnel_types:",
            "            LOG.error(\"tunnel_type %s not supported by agent\",",
            "                      tunnel_type)",
            "            return",
            "        ofport = self.tun_br_ofports[tunnel_type].get(tunnel_ip)",
            "        self.cleanup_tunnel_port(self.tun_br, ofport, tunnel_type)",
            "",
            "    def _tunnel_port_lookup(self, network_type, remote_ip):",
            "        return self.tun_br_ofports[network_type].get(remote_ip)",
            "",
            "    def fdb_add(self, context, fdb_entries):",
            "        LOG.debug(\"fdb_add received\")",
            "        for lvm, agent_ports in self.get_agent_ports(fdb_entries):",
            "            agent_ports.pop(self.local_ip, None)",
            "            if len(agent_ports):",
            "                self.fdb_add_tun(context, self.tun_br, lvm,",
            "                                 agent_ports, self._tunnel_port_lookup)",
            "",
            "    def fdb_remove(self, context, fdb_entries):",
            "        LOG.debug(\"fdb_remove received\")",
            "        for lvm, agent_ports in self.get_agent_ports(fdb_entries):",
            "            agent_ports.pop(self.local_ip, None)",
            "            if len(agent_ports):",
            "                self.fdb_remove_tun(context, self.tun_br, lvm,",
            "                                    agent_ports,",
            "                                    self._tunnel_port_lookup)",
            "",
            "    def add_fdb_flow(self, br, port_info, remote_ip, lvm, ofport):",
            "        if port_info == n_const.FLOODING_ENTRY:",
            "            lvm.tun_ofports.add(ofport)",
            "            br.install_flood_to_tun(lvm.vlan, lvm.segmentation_id,",
            "                                    lvm.tun_ofports)",
            "        else:",
            "            self.setup_entry_for_arp_reply(br, 'add', lvm.vlan,",
            "                                           port_info.mac_address,",
            "                                           port_info.ip_address)",
            "            br.install_unicast_to_tun(lvm.vlan,",
            "                                      lvm.segmentation_id,",
            "                                      ofport,",
            "                                      port_info.mac_address)",
            "",
            "    def del_fdb_flow(self, br, port_info, remote_ip, lvm, ofport):",
            "        if port_info == n_const.FLOODING_ENTRY:",
            "            if ofport not in lvm.tun_ofports:",
            "                LOG.debug(\"attempt to remove a non-existent port %s\", ofport)",
            "                return",
            "            lvm.tun_ofports.remove(ofport)",
            "            if len(lvm.tun_ofports) > 0:",
            "                br.install_flood_to_tun(lvm.vlan, lvm.segmentation_id,",
            "                                        lvm.tun_ofports)",
            "            else:",
            "                # This local vlan doesn't require any more tunneling",
            "                br.delete_flood_to_tun(lvm.vlan)",
            "        else:",
            "            self.setup_entry_for_arp_reply(br, 'remove', lvm.vlan,",
            "                                           port_info.mac_address,",
            "                                           port_info.ip_address)",
            "            br.delete_unicast_to_tun(lvm.vlan, port_info.mac_address)",
            "",
            "    def _fdb_chg_ip(self, context, fdb_entries):",
            "        LOG.debug(\"update chg_ip received\")",
            "        self.fdb_chg_ip_tun(context, self.tun_br, fdb_entries, self.local_ip)",
            "",
            "    def setup_entry_for_arp_reply(self, br, action, local_vid, mac_address,",
            "                                  ip_address):",
            "        '''Set the ARP respond entry.",
            "",
            "        When the l2 population mechanism driver and OVS supports to edit ARP",
            "        fields, a table (ARP_RESPONDER) to resolve ARP locally is added to the",
            "        tunnel bridge.",
            "        '''",
            "        if not self.arp_responder_enabled:",
            "            return",
            "",
            "        ip = netaddr.IPAddress(ip_address)",
            "        if ip.version == 6:",
            "            return",
            "",
            "        ip = str(ip)",
            "        mac = str(netaddr.EUI(mac_address, dialect=_mac_mydialect))",
            "",
            "        if action == 'add':",
            "            br.install_arp_responder(local_vid, ip, mac)",
            "        elif action == 'remove':",
            "            br.delete_arp_responder(local_vid, ip)",
            "        else:",
            "            LOG.warning('Action %s not supported', action)",
            "",
            "    def _local_vlan_for_physical(self, lvid, physical_network,",
            "                                 segmentation_id=None):",
            "        distributed = self.enable_distributed_routing",
            "        phys_br = self.phys_brs[physical_network]",
            "        phys_port = self.phys_ofports[physical_network]",
            "        int_br = self.int_br",
            "        int_port = self.int_ofports[physical_network]",
            "        phys_br.provision_local_vlan(port=phys_port, lvid=lvid,",
            "                                     segmentation_id=segmentation_id,",
            "                                     distributed=distributed)",
            "        int_br.provision_local_vlan(port=int_port, lvid=lvid,",
            "                                    segmentation_id=segmentation_id)",
            "",
            "    def _add_local_vlan(self, net_uuid, network_type, physical_network,",
            "                        segmentation_id):",
            "        \"\"\"Add a network to the local VLAN manager",
            "",
            "        On a restart or crash of OVS, the network associated with this VLAN",
            "        will already be assigned, so check for that here before assigning a",
            "        new one. If the VLAN tag is not used, check if there are local VLAN",
            "        tags available.",
            "        \"\"\"",
            "        try:",
            "            lvm = self.vlan_manager.get(net_uuid)",
            "        except vlanmanager.MappingNotFound:",
            "            lvid = self._local_vlan_hints.pop(net_uuid, None)",
            "            if lvid is None:",
            "                if not self.available_local_vlans:",
            "                    LOG.error(\"No local VLAN available for net-id=%s\",",
            "                              net_uuid)",
            "                    return",
            "                lvid = self.available_local_vlans.pop()",
            "            self.vlan_manager.add(",
            "                net_uuid, lvid, network_type, physical_network,",
            "                segmentation_id)",
            "            lvm = self.vlan_manager.get(net_uuid)",
            "            LOG.info(",
            "                \"Assigning %(vlan_id)s as local vlan for net-id=%(net_uuid)s\",",
            "                {'vlan_id': lvm.vlan, 'net_uuid': net_uuid})",
            "",
            "        return lvm",
            "",
            "    def provision_local_vlan(self, net_uuid, network_type, physical_network,",
            "                             segmentation_id):",
            "        '''Provisions a local VLAN.",
            "",
            "        :param net_uuid: the uuid of the network associated with this vlan.",
            "        :param network_type: the network type ('gre', 'vxlan', 'vlan', 'flat',",
            "                                               'local', 'geneve')",
            "        :param physical_network: the physical network for 'vlan' or 'flat'",
            "        :param segmentation_id: the VID for 'vlan' or tunnel ID for 'tunnel'",
            "        '''",
            "        lvm = self._add_local_vlan(net_uuid, network_type, physical_network,",
            "                                   segmentation_id)",
            "        if not lvm or not lvm.vlan:",
            "            return",
            "",
            "        lvid = lvm.vlan",
            "        if network_type in constants.TUNNEL_NETWORK_TYPES:",
            "            if self.enable_tunneling:",
            "                # outbound broadcast/multicast",
            "                ofports = list(self.tun_br_ofports[network_type].values())",
            "                if ofports:",
            "                    self.tun_br.install_flood_to_tun(lvid,",
            "                                                     segmentation_id,",
            "                                                     ofports)",
            "                # inbound from tunnels: set lvid in the right table",
            "                # and resubmit to Table LEARN_FROM_TUN for mac learning",
            "                if self.enable_distributed_routing:",
            "                    self.dvr_agent.process_tunneled_network(",
            "                        network_type, lvid, segmentation_id)",
            "                else:",
            "                    self.tun_br.provision_local_vlan(",
            "                        network_type=network_type, lvid=lvid,",
            "                        segmentation_id=segmentation_id)",
            "            else:",
            "                LOG.error(\"Cannot provision %(network_type)s network for \"",
            "                          \"net-id=%(net_uuid)s - tunneling disabled\",",
            "                          {'network_type': network_type,",
            "                           'net_uuid': net_uuid})",
            "        elif network_type == n_const.TYPE_FLAT:",
            "            if physical_network in self.phys_brs:",
            "                self._local_vlan_for_physical(lvid, physical_network)",
            "            else:",
            "                LOG.error(\"Cannot provision flat network for \"",
            "                          \"net-id=%(net_uuid)s - no bridge for \"",
            "                          \"physical_network %(physical_network)s\",",
            "                          {'net_uuid': net_uuid,",
            "                           'physical_network': physical_network})",
            "        elif network_type == n_const.TYPE_VLAN:",
            "            if physical_network in self.phys_brs:",
            "                self._local_vlan_for_physical(lvid, physical_network,",
            "                                              segmentation_id)",
            "            else:",
            "                LOG.error(\"Cannot provision VLAN network for \"",
            "                          \"net-id=%(net_uuid)s - no bridge for \"",
            "                          \"physical_network %(physical_network)s\",",
            "                          {'net_uuid': net_uuid,",
            "                           'physical_network': physical_network})",
            "        elif network_type == n_const.TYPE_LOCAL:",
            "            # no flows needed for local networks",
            "            pass",
            "        else:",
            "            LOG.error(\"Cannot provision unknown network type \"",
            "                      \"%(network_type)s for net-id=%(net_uuid)s\",",
            "                      {'network_type': network_type,",
            "                       'net_uuid': net_uuid})",
            "",
            "    def reclaim_local_vlan(self, net_uuid):",
            "        '''Reclaim a local VLAN.",
            "",
            "        :param net_uuid: the network uuid associated with this vlan.",
            "        '''",
            "        try:",
            "            lvm = vlanmanager.LocalVlanManager().pop(net_uuid)",
            "        except KeyError:",
            "            LOG.debug(\"Network %s not used on agent.\", net_uuid)",
            "            return",
            "",
            "        LOG.info(\"Reclaiming vlan = %(vlan_id)s from \"",
            "                 \"net-id = %(net_uuid)s\",",
            "                 {'vlan_id': lvm.vlan, 'net_uuid': net_uuid})",
            "",
            "        if lvm.network_type in constants.TUNNEL_NETWORK_TYPES:",
            "            if self.enable_tunneling:",
            "                self.tun_br.reclaim_local_vlan(",
            "                    network_type=lvm.network_type,",
            "                    segmentation_id=lvm.segmentation_id)",
            "                self.tun_br.delete_flood_to_tun(lvm.vlan)",
            "                self.tun_br.delete_unicast_to_tun(lvm.vlan, None)",
            "                self.tun_br.delete_arp_responder(lvm.vlan, None)",
            "                if self.l2_pop:",
            "                    # Try to remove tunnel ports if not used by other networks",
            "                    for ofport in lvm.tun_ofports:",
            "                        self.cleanup_tunnel_port(self.tun_br, ofport,",
            "                                                 lvm.network_type)",
            "        elif lvm.network_type == n_const.TYPE_FLAT:",
            "            if lvm.physical_network in self.phys_brs:",
            "                # outbound",
            "                br = self.phys_brs[lvm.physical_network]",
            "                br.reclaim_local_vlan(",
            "                    port=self.phys_ofports[lvm.physical_network],",
            "                    lvid=lvm.vlan)",
            "                # inbound",
            "                br = self.int_br",
            "                br.reclaim_local_vlan(",
            "                    port=self.int_ofports[lvm.physical_network],",
            "                    segmentation_id=None)",
            "        elif lvm.network_type == n_const.TYPE_VLAN:",
            "            if lvm.physical_network in self.phys_brs:",
            "                # outbound",
            "                br = self.phys_brs[lvm.physical_network]",
            "                br.reclaim_local_vlan(",
            "                    port=self.phys_ofports[lvm.physical_network],",
            "                    lvid=lvm.vlan)",
            "                # inbound",
            "                br = self.int_br",
            "                br.reclaim_local_vlan(",
            "                    port=self.int_ofports[lvm.physical_network],",
            "                    segmentation_id=lvm.segmentation_id)",
            "        elif lvm.network_type == n_const.TYPE_LOCAL:",
            "            # no flows needed for local networks",
            "            pass",
            "        else:",
            "            LOG.error(\"Cannot reclaim unknown network type \"",
            "                      \"%(network_type)s for net-id=%(net_uuid)s\",",
            "                      {'network_type': lvm.network_type,",
            "                       'net_uuid': net_uuid})",
            "",
            "        self.available_local_vlans.add(lvm.vlan)",
            "",
            "    def port_bound(self, port, net_uuid,",
            "                   network_type, physical_network,",
            "                   segmentation_id, fixed_ips, device_owner,",
            "                   provisioning_needed):",
            "        '''Bind port to net_uuid/lsw_id and install flow for inbound traffic",
            "        to vm.",
            "",
            "        :param port: an ovs_lib.VifPort object.",
            "        :param net_uuid: the net_uuid this port is to be associated with.",
            "        :param network_type: the network type ('gre', 'vlan', 'flat', 'local')",
            "        :param physical_network: the physical network for 'vlan' or 'flat'",
            "        :param segmentation_id: the VID for 'vlan' or tunnel ID for 'tunnel'",
            "        :param fixed_ips: the ip addresses assigned to this port",
            "        :param device_owner: the string indicative of owner of this port",
            "        :param provisioning_needed: indicates if this is called for an OVS",
            "                                    restart or recreated physical bridges",
            "                                    and requires to do local vlan provisioning",
            "        '''",
            "        if net_uuid not in self.vlan_manager or provisioning_needed:",
            "            self.provision_local_vlan(net_uuid, network_type,",
            "                                      physical_network, segmentation_id)",
            "        lvm = self.vlan_manager.get(net_uuid)",
            "        lvm.vif_ports[port.vif_id] = port",
            "",
            "        self.dvr_agent.bind_port_to_dvr(port, lvm,",
            "                                        fixed_ips,",
            "                                        device_owner)",
            "        port_other_config = self.int_br.db_get_val(\"Port\", port.port_name,",
            "                                                   \"other_config\")",
            "        if port_other_config is None:",
            "            if port.vif_id in self.deleted_ports:",
            "                LOG.debug(\"Port %s deleted concurrently\", port.vif_id)",
            "            elif port.vif_id in self.updated_ports:",
            "                LOG.error(\"Expected port %s not found\", port.vif_id)",
            "            else:",
            "                LOG.debug(\"Unable to get config for port %s\", port.vif_id)",
            "            return False",
            "",
            "        vlan_mapping = {'net_uuid': net_uuid,",
            "                        'network_type': network_type,",
            "                        'physical_network': str(physical_network)}",
            "        if segmentation_id is not None:",
            "            vlan_mapping['segmentation_id'] = str(segmentation_id)",
            "        port_other_config.update(vlan_mapping)",
            "        self.int_br.set_db_attribute(\"Port\", port.port_name, \"other_config\",",
            "                                     port_other_config)",
            "        return True",
            "",
            "    def _add_port_tag_info(self, need_binding_ports):",
            "        port_names = [p['vif_port'].port_name for p in need_binding_ports]",
            "        port_info = self.int_br.get_ports_attributes(",
            "            \"Port\", columns=[\"name\", \"tag\", \"other_config\"],",
            "            ports=port_names, if_exists=True)",
            "        info_by_port = {",
            "            x['name']: {",
            "                'tag': x['tag'],",
            "                'other_config': x['other_config'] or {}",
            "            }",
            "            for x in port_info",
            "        }",
            "        for port_detail in need_binding_ports:",
            "            try:",
            "                lvm = self.vlan_manager.get(port_detail['network_id'])",
            "            except vlanmanager.MappingNotFound:",
            "                continue",
            "            port = port_detail['vif_port']",
            "            try:",
            "                cur_info = info_by_port[port.port_name]",
            "            except KeyError:",
            "                continue",
            "            str_vlan = str(lvm.vlan)",
            "            other_config = cur_info['other_config']",
            "            if (cur_info['tag'] != lvm.vlan or",
            "                    other_config.get('tag') != str_vlan):",
            "                other_config['tag'] = str_vlan",
            "                self.int_br.set_db_attribute(",
            "                    \"Port\", port.port_name, \"other_config\", other_config)",
            "                # Uninitialized port has tag set to []",
            "                if cur_info['tag']:",
            "                    LOG.warning(\"Uninstall flows of ofport %s due to \"",
            "                                \"local vlan change.\", port.ofport)",
            "                    self.int_br.uninstall_flows(in_port=port.ofport)",
            "",
            "    def _bind_devices(self, need_binding_ports):",
            "        devices_up = []",
            "        devices_down = []",
            "        failed_devices = []",
            "        tunnels_missing = False",
            "        port_names = [p['vif_port'].port_name for p in need_binding_ports]",
            "        port_info = self.int_br.get_ports_attributes(",
            "            \"Port\", columns=[\"name\", \"tag\"], ports=port_names, if_exists=True)",
            "        tags_by_name = {x['name']: x['tag'] for x in port_info}",
            "        for port_detail in need_binding_ports:",
            "            try:",
            "                lvm = self.vlan_manager.get(port_detail['network_id'])",
            "            except vlanmanager.MappingNotFound:",
            "                # network for port was deleted. skip this port since it",
            "                # will need to be handled as a DEAD port in the next scan",
            "                continue",
            "            port = port_detail['vif_port']",
            "            device = port_detail['device']",
            "            # Do not bind a port if it's already bound",
            "            cur_tag = tags_by_name.get(port.port_name)",
            "            if cur_tag is None:",
            "                LOG.debug(\"Port %s was deleted concurrently, skipping it\",",
            "                          port.port_name)",
            "                continue",
            "            if self.prevent_arp_spoofing:",
            "                self.setup_arp_spoofing_protection(self.int_br,",
            "                                                   port, port_detail)",
            "            if cur_tag != lvm.vlan:",
            "                self.int_br.set_db_attribute(",
            "                    \"Port\", port.port_name, \"tag\", lvm.vlan)",
            "",
            "            # update plugin about port status",
            "            # FIXME(salv-orlando): Failures while updating device status",
            "            # must be handled appropriately. Otherwise this might prevent",
            "            # neutron server from sending network-vif-* events to the nova",
            "            # API server, thus possibly preventing instance spawn.",
            "            if port_detail.get('admin_state_up'):",
            "                LOG.debug(\"Setting status for %s to UP\", device)",
            "                devices_up.append(device)",
            "                if (not tunnels_missing and",
            "                        lvm.network_type in constants.TUNNEL_NETWORK_TYPES and",
            "                        len(lvm.tun_ofports) == 0):",
            "                    tunnels_missing = True",
            "            else:",
            "                LOG.debug(\"Setting status for %s to DOWN\", device)",
            "                devices_down.append(device)",
            "        if devices_up or devices_down:",
            "            # When the iter_num == 0, that indicate the ovs-agent is doing",
            "            # the initialization work. L2 pop needs this precise knowledge",
            "            # to notify the agent to refresh the tunnel related flows.",
            "            # Otherwise, these flows will be cleaned as stale due to the",
            "            # different cookie id. We also set refresh_tunnels if the agent",
            "            # has not received a notification and is missing tunnels.",
            "            refresh_tunnels = (self.iter_num == 0) or tunnels_missing",
            "            devices_set = self.plugin_rpc.update_device_list(",
            "                self.context, devices_up, devices_down, self.agent_id,",
            "                self.conf.host, refresh_tunnels=refresh_tunnels)",
            "            failed_devices = (devices_set.get('failed_devices_up') +",
            "                              devices_set.get('failed_devices_down'))",
            "            if failed_devices:",
            "                LOG.error(\"Configuration for devices %s failed!\",",
            "                          failed_devices)",
            "        LOG.info(\"Configuration for devices up %(up)s and devices \"",
            "                 \"down %(down)s completed.\",",
            "                 {'up': devices_up, 'down': devices_down})",
            "        return set(failed_devices)",
            "",
            "    @staticmethod",
            "    def setup_arp_spoofing_protection(bridge, vif, port_details):",
            "        if not port_details.get('port_security_enabled', True):",
            "            LOG.info(\"Skipping ARP spoofing rules for port '%s' because \"",
            "                     \"it has port security disabled\", vif.port_name)",
            "            bridge.delete_arp_spoofing_protection(port=vif.ofport)",
            "            bridge.set_allowed_macs_for_port(port=vif.ofport, allow_all=True)",
            "            return",
            "        if port_details['device_owner'].startswith(",
            "                n_const.DEVICE_OWNER_NETWORK_PREFIX):",
            "            LOG.debug(\"Skipping ARP spoofing rules for network owned port \"",
            "                      \"'%s'.\", vif.port_name)",
            "            bridge.delete_arp_spoofing_protection(port=vif.ofport)",
            "            bridge.set_allowed_macs_for_port(port=vif.ofport, allow_all=True)",
            "            return",
            "        # clear any previous flows related to this port in our ARP table",
            "        bridge.delete_arp_spoofing_allow_rules(port=vif.ofport)",
            "        # collect all of the addresses and cidrs that belong to the port",
            "        addresses = {f['ip_address'] for f in port_details['fixed_ips']}",
            "        mac_addresses = {vif.vif_mac}",
            "        if port_details.get('allowed_address_pairs'):",
            "            addresses |= {p['ip_address']",
            "                          for p in port_details['allowed_address_pairs']}",
            "            mac_addresses |= {p['mac_address']",
            "                              for p in port_details['allowed_address_pairs']",
            "                              if p.get('mac_address')}",
            "",
            "        bridge.set_allowed_macs_for_port(vif.ofport, mac_addresses)",
            "        ipv6_addresses = {ip for ip in addresses",
            "                          if netaddr.IPNetwork(ip).version == 6}",
            "        # Allow neighbor advertisements for LLA address.",
            "        ipv6_addresses |= {str(netutils.get_ipv6_addr_by_EUI64(",
            "                               n_const.IPv6_LLA_PREFIX, mac))",
            "                           for mac in mac_addresses}",
            "        if not has_zero_prefixlen_address(ipv6_addresses):",
            "            # Install protection only when prefix is not zero because a /0",
            "            # prefix allows any address anyway and the nd_target can only",
            "            # match on /1 or more.",
            "            bridge.install_icmpv6_na_spoofing_protection(",
            "                port=vif.ofport, ip_addresses=ipv6_addresses)",
            "",
            "        ipv4_addresses = {ip for ip in addresses",
            "                          if netaddr.IPNetwork(ip).version == 4}",
            "        if not has_zero_prefixlen_address(ipv4_addresses):",
            "            # Install protection only when prefix is not zero because a /0",
            "            # prefix allows any address anyway and the ARP_SPA can only",
            "            # match on /1 or more.",
            "            bridge.install_arp_spoofing_protection(port=vif.ofport,",
            "                                                   ip_addresses=ipv4_addresses)",
            "        else:",
            "            bridge.delete_arp_spoofing_protection(port=vif.ofport)",
            "",
            "    def port_unbound(self, vif_id, net_uuid=None):",
            "        '''Unbind port.",
            "",
            "        Removes corresponding local vlan mapping object if this is its last",
            "        VIF.",
            "",
            "        :param vif_id: the id of the vif",
            "        :param net_uuid: the net_uuid this port is associated with.",
            "        '''",
            "        try:",
            "            net_uuid = net_uuid or self.vlan_manager.get_net_uuid(vif_id)",
            "        except vlanmanager.VifIdNotFound:",
            "            LOG.info(",
            "                'port_unbound(): net_uuid %s not managed by VLAN manager',",
            "                net_uuid)",
            "            return",
            "",
            "        lvm = self.vlan_manager.get(net_uuid)",
            "",
            "        if vif_id in lvm.vif_ports:",
            "            vif_port = lvm.vif_ports[vif_id]",
            "            self.dvr_agent.unbind_port_from_dvr(vif_port, lvm)",
            "        lvm.vif_ports.pop(vif_id, None)",
            "",
            "        if not lvm.vif_ports:",
            "            self.reclaim_local_vlan(net_uuid)",
            "",
            "    def port_dead(self, port, log_errors=True):",
            "        '''Once a port has no binding, put it on the \"dead vlan\".",
            "",
            "        :param port: an ovs_lib.VifPort object.",
            "        '''",
            "        # Don't kill a port if it's already dead",
            "        cur_tag = self.int_br.db_get_val(\"Port\", port.port_name, \"tag\",",
            "                                         log_errors=log_errors)",
            "        if cur_tag and cur_tag != constants.DEAD_VLAN_TAG:",
            "            self.int_br.set_db_attribute(\"Port\", port.port_name, \"tag\",",
            "                                         constants.DEAD_VLAN_TAG,",
            "                                         log_errors=log_errors)",
            "            self.int_br.drop_port(in_port=port.ofport)",
            "",
            "    def setup_integration_br(self):",
            "        '''Setup the integration bridge.",
            "",
            "        '''",
            "        # Ensure the integration bridge is created.",
            "        # ovs_lib.OVSBridge.create() will run the equivalent of",
            "        #   ovs-vsctl -- --may-exist add-br BRIDGE_NAME",
            "        # which does nothing if bridge already exists.",
            "        self.int_br.create()",
            "        self.int_br.set_secure_mode()",
            "        self.int_br.setup_controllers(self.conf)",
            "        self.int_br.set_igmp_snooping_state(self.conf.OVS.igmp_snooping_enable)",
            "",
            "        if self.conf.AGENT.drop_flows_on_start:",
            "            # Delete the patch port between br-int and br-tun if we're deleting",
            "            # the flows on br-int, so that traffic doesn't get flooded over",
            "            # while flows are missing.",
            "            self.int_br.delete_port(self.conf.OVS.int_peer_patch_port)",
            "            self.int_br.uninstall_flows(cookie=ovs_lib.COOKIE_ANY)",
            "        self.int_br.setup_default_table()",
            "",
            "    def setup_ancillary_bridges(self, integ_br, tun_br):",
            "        '''Setup ancillary bridges - for example br-ex.'''",
            "        ovs = ovs_lib.BaseOVS()",
            "        ovs_bridges = set(ovs.get_bridges())",
            "        # Remove all known bridges",
            "        ovs_bridges.remove(integ_br)",
            "        if self.enable_tunneling:",
            "            ovs_bridges.remove(tun_br)",
            "        br_names = [self.phys_brs[physical_network].br_name for",
            "                    physical_network in self.phys_brs]",
            "        ovs_bridges.difference_update(br_names)",
            "        # Filter list of bridges to those that have external",
            "        # bridge-id's configured",
            "        br_names = []",
            "        for bridge in ovs_bridges:",
            "            bridge_id = ovs.get_bridge_external_bridge_id(bridge,",
            "                                                          log_errors=False)",
            "            if bridge_id != bridge:",
            "                br_names.append(bridge)",
            "        ovs_bridges.difference_update(br_names)",
            "        ancillary_bridges = []",
            "        for bridge in ovs_bridges:",
            "            br = ovs_lib.OVSBridge(bridge)",
            "            LOG.info('Adding %s to list of bridges.', bridge)",
            "            ancillary_bridges.append(br)",
            "        return ancillary_bridges",
            "",
            "    def setup_tunnel_br(self, tun_br_name=None):",
            "        '''(re)initialize the tunnel bridge.",
            "",
            "        Creates tunnel bridge, and links it to the integration bridge",
            "        using a patch port.",
            "",
            "        :param tun_br_name: the name of the tunnel bridge.",
            "        '''",
            "        if not self.tun_br:",
            "            self.tun_br = self.br_tun_cls(tun_br_name)",
            "",
            "        # tun_br.create() won't recreate bridge if it exists, but will handle",
            "        # cases where something like datapath_type has changed",
            "        self.tun_br.create(secure_mode=True)",
            "        self.tun_br.setup_controllers(self.conf)",
            "        if (not self.int_br.port_exists(self.conf.OVS.int_peer_patch_port) or",
            "                self.patch_tun_ofport == ovs_lib.INVALID_OFPORT):",
            "            self.patch_tun_ofport = self.int_br.add_patch_port(",
            "                self.conf.OVS.int_peer_patch_port,",
            "                self.conf.OVS.tun_peer_patch_port)",
            "        if (not self.tun_br.port_exists(self.conf.OVS.tun_peer_patch_port) or",
            "                self.patch_int_ofport == ovs_lib.INVALID_OFPORT):",
            "            self.patch_int_ofport = self.tun_br.add_patch_port(",
            "                self.conf.OVS.tun_peer_patch_port,",
            "                self.conf.OVS.int_peer_patch_port)",
            "        if ovs_lib.INVALID_OFPORT in (self.patch_tun_ofport,",
            "                                      self.patch_int_ofport):",
            "            LOG.error(\"Failed to create OVS patch port. Cannot have \"",
            "                      \"tunneling enabled on this agent, since this \"",
            "                      \"version of OVS does not support tunnels or patch \"",
            "                      \"ports. Agent terminated!\")",
            "            sys.exit(1)",
            "        if self.conf.AGENT.drop_flows_on_start:",
            "            self.tun_br.uninstall_flows(cookie=ovs_lib.COOKIE_ANY)",
            "",
            "    def setup_tunnel_br_flows(self):",
            "        '''Setup the tunnel bridge.",
            "",
            "        Add all flows to the tunnel bridge.",
            "        '''",
            "        self.tun_br.setup_default_table(self.patch_int_ofport,",
            "                                        self.arp_responder_enabled)",
            "",
            "    def _reconfigure_physical_bridges(self, bridges):",
            "        try:",
            "            sync = self._do_reconfigure_physical_bridges(bridges)",
            "            self.added_bridges = []",
            "        except RuntimeError:",
            "            # If there was error and bridges aren't properly reconfigured,",
            "            # there is no need to do full sync once again. It will be done when",
            "            # reconfiguration of physical bridges will be finished without",
            "            # errors",
            "            sync = False",
            "            self.added_bridges = bridges",
            "            LOG.warning(\"RuntimeError during setup of physical bridges: %s\",",
            "                        bridges)",
            "        return sync",
            "",
            "    def _do_reconfigure_physical_bridges(self, bridges):",
            "        sync = False",
            "        bridge_mappings = {}",
            "        for bridge in bridges:",
            "            LOG.info(\"Physical bridge %s was just re-created.\", bridge)",
            "            for phys_net, phys_br in self.bridge_mappings.items():",
            "                if bridge == phys_br:",
            "                    bridge_mappings[phys_net] = bridge",
            "        if bridge_mappings:",
            "            sync = True",
            "            self.setup_physical_bridges(bridge_mappings)",
            "            if self.enable_distributed_routing:",
            "                self.dvr_agent.reset_dvr_flows(",
            "                    self.int_br, self.tun_br, self.phys_brs,",
            "                    self.patch_int_ofport, self.patch_tun_ofport,",
            "                    bridge_mappings)",
            "        return sync",
            "",
            "    def _check_bridge_datapath_id(self, bridge, datapath_ids_set):",
            "        \"\"\"Check for bridges with duplicate datapath-id",
            "",
            "        Bottom 48 bits auto-derived from MAC of NIC. Upper 12 bits free,",
            "        so we OR it with (bridge # << 48) to create a unique ID",
            "        It must be exactly 64 bits, else OVS will reject it - zfill",
            "",
            "        :param bridge: (OVSPhysicalBridge) bridge",
            "        :param datapath_ids_set: (set) used datapath ids in OVS",
            "        \"\"\"",
            "        dpid = int(bridge.get_datapath_id(), 16)",
            "        dpid_hex = format(dpid, '0x').zfill(16)",
            "        if dpid_hex in datapath_ids_set:",
            "            dpid_hex = format(",
            "                dpid + (len(datapath_ids_set) << 48), '0x').zfill(16)",
            "            bridge.set_datapath_id(dpid_hex)",
            "        LOG.info('Bridge %s datapath-id = 0x%s', bridge.br_name, dpid_hex)",
            "        datapath_ids_set.add(dpid_hex)",
            "",
            "    def setup_physical_bridges(self, bridge_mappings):",
            "        '''Setup the physical network bridges.",
            "",
            "        Creates physical network bridges and links them to the",
            "        integration bridge using veths or patch ports.",
            "",
            "        :param bridge_mappings: map physical network names to bridge names.",
            "        '''",
            "        self.phys_brs = {}",
            "        self.int_ofports = {}",
            "        self.phys_ofports = {}",
            "        datapath_ids_set = set()",
            "        ip_wrapper = ip_lib.IPWrapper()",
            "        ovs = ovs_lib.BaseOVS()",
            "        ovs_bridges = ovs.get_bridges()",
            "        for physical_network, bridge in bridge_mappings.items():",
            "            LOG.info(\"Mapping physical network %(physical_network)s to \"",
            "                     \"bridge %(bridge)s\",",
            "                     {'physical_network': physical_network,",
            "                      'bridge': bridge})",
            "            # setup physical bridge",
            "            if bridge not in ovs_bridges:",
            "                LOG.error(\"Bridge %(bridge)s for physical network \"",
            "                          \"%(physical_network)s does not exist. Agent \"",
            "                          \"terminated!\",",
            "                          {'physical_network': physical_network,",
            "                           'bridge': bridge})",
            "                sys.exit(1)",
            "            br = self.br_phys_cls(bridge)",
            "            self._check_bridge_datapath_id(br, datapath_ids_set)",
            "",
            "            # The bridge already exists, so create won't recreate it, but will",
            "            # handle things like changing the datapath_type",
            "            br.create()",
            "            br.set_secure_mode()",
            "            br.setup_controllers(self.conf)",
            "            if cfg.CONF.AGENT.drop_flows_on_start:",
            "                br.uninstall_flows(cookie=ovs_lib.COOKIE_ANY)",
            "            br.setup_default_table()",
            "            self.phys_brs[physical_network] = br",
            "",
            "            # interconnect physical and integration bridges using veth/patches",
            "            int_if_name = plugin_utils.get_interface_name(",
            "                bridge, prefix=constants.PEER_INTEGRATION_PREFIX)",
            "            phys_if_name = plugin_utils.get_interface_name(",
            "                bridge, prefix=constants.PEER_PHYSICAL_PREFIX)",
            "            # Interface type of port for physical and integration bridges must",
            "            # be same, so check only one of them.",
            "            # Not logging error here, as the interface may not exist yet.",
            "            # Type check is done to cleanup wrong interface if any.",
            "            int_type = self.int_br.db_get_val(\"Interface\", int_if_name, \"type\",",
            "                                              log_errors=False)",
            "            if self.use_veth_interconnection:",
            "                # Drop ports if the interface types doesn't match the",
            "                # configuration value.",
            "                if int_type == 'patch':",
            "                    self.int_br.delete_port(int_if_name)",
            "                    br.delete_port(phys_if_name)",
            "                device = ip_lib.IPDevice(int_if_name)",
            "                if device.exists():",
            "                    device.link.delete()",
            "                    # Give udev a chance to process its rules here, to avoid",
            "                    # race conditions between commands launched by udev rules",
            "                    # and the subsequent call to ip_wrapper.add_veth",
            "                    utils.execute(['udevadm', 'settle', '--timeout=10'])",
            "                int_veth, phys_veth = ip_wrapper.add_veth(int_if_name,",
            "                                                          phys_if_name)",
            "                int_ofport = self.int_br.add_port(int_if_name)",
            "                phys_ofport = br.add_port(phys_if_name)",
            "            else:",
            "                # Drop ports if the interface type doesn't match the",
            "                # configuration value",
            "                if int_type == 'veth':",
            "                    self.int_br.delete_port(int_if_name)",
            "                    br.delete_port(phys_if_name)",
            "",
            "                # Setup int_br to physical bridge patches.  If they already",
            "                # exist we leave them alone, otherwise we create them but don't",
            "                # connect them until after the drop rules are in place.",
            "                if self.int_br.port_exists(int_if_name):",
            "                    int_ofport = self.int_br.get_port_ofport(int_if_name)",
            "                else:",
            "                    int_ofport = self.int_br.add_patch_port(",
            "                        int_if_name, constants.NONEXISTENT_PEER)",
            "                if br.port_exists(phys_if_name):",
            "                    phys_ofport = br.get_port_ofport(phys_if_name)",
            "                else:",
            "                    phys_ofport = br.add_patch_port(",
            "                        phys_if_name, constants.NONEXISTENT_PEER)",
            "",
            "            self.int_ofports[physical_network] = int_ofport",
            "            self.phys_ofports[physical_network] = phys_ofport",
            "",
            "            # Drop packets from physical bridges that have not matched a higher",
            "            # priority flow to set a local vlan. This prevents these stray",
            "            # packets from being forwarded to other physical bridges which",
            "            # could cause a network loop in the physical network.",
            "            self.int_br.drop_port(in_port=int_ofport)",
            "",
            "            if not self.enable_distributed_routing:",
            "                br.drop_port(in_port=phys_ofport)",
            "",
            "            if self.use_veth_interconnection:",
            "                # enable veth to pass traffic",
            "                int_veth.link.set_up()",
            "                phys_veth.link.set_up()",
            "                if self.veth_mtu:",
            "                    # set up mtu size for veth interfaces",
            "                    int_veth.link.set_mtu(self.veth_mtu)",
            "                    phys_veth.link.set_mtu(self.veth_mtu)",
            "            else:",
            "                # associate patch ports to pass traffic",
            "                self.int_br.set_db_attribute('Interface', int_if_name,",
            "                                             'options', {'peer': phys_if_name})",
            "                br.set_db_attribute('Interface', phys_if_name,",
            "                                    'options', {'peer': int_if_name})",
            "",
            "    def update_stale_ofport_rules(self):",
            "        # ARP spoofing rules and drop-flow upon port-delete",
            "        # use ofport-based rules",
            "        previous = self.vifname_to_ofport_map",
            "        current = self.int_br.get_vif_port_to_ofport_map()",
            "",
            "        # if any ofport numbers have changed, re-process the devices as",
            "        # added ports so any rules based on ofport numbers are updated.",
            "        moved_ports = self._get_ofport_moves(current, previous)",
            "",
            "        # delete any stale rules based on removed ofports",
            "        ofports_deleted = set(previous.values()) - set(current.values())",
            "        for ofport in ofports_deleted:",
            "            if self.prevent_arp_spoofing:",
            "                self.int_br.delete_arp_spoofing_protection(port=ofport)",
            "            self.int_br.uninstall_flows(in_port=ofport)",
            "        # store map for next iteration",
            "        self.vifname_to_ofport_map = current",
            "        return moved_ports",
            "",
            "    @staticmethod",
            "    def _get_ofport_moves(current, previous):",
            "        \"\"\"Returns a list of moved ports.",
            "",
            "        Takes two port->ofport maps and returns a list ports that moved to a",
            "        different ofport. Deleted ports are not included.",
            "        \"\"\"",
            "        port_moves = []",
            "        for name, ofport in previous.items():",
            "            if name not in current:",
            "                continue",
            "            current_ofport = current[name]",
            "            if ofport != current_ofport:",
            "                port_moves.append(name)",
            "        return port_moves",
            "",
            "    def _get_port_info(self, registered_ports, cur_ports,",
            "                       readd_registered_ports):",
            "        port_info = PortInfo(current=cur_ports)",
            "        # FIXME(salv-orlando): It's not really necessary to return early",
            "        # if nothing has changed.",
            "        if not readd_registered_ports and cur_ports == registered_ports:",
            "            return port_info",
            "",
            "        if readd_registered_ports:",
            "            port_info['added'] = cur_ports",
            "        else:",
            "            port_info['added'] = cur_ports - registered_ports",
            "        # Update port_info with ports not found on the integration bridge",
            "        port_info['removed'] = registered_ports - cur_ports",
            "        return port_info",
            "",
            "    def _update_port_info_failed_devices_stats(self, port_info,",
            "                                               failed_devices):",
            "        # remove failed devices that don't need to be retried",
            "        failed_devices['added'] -= port_info['removed']",
            "        failed_devices['removed'] -= port_info['added']",
            "",
            "        # Disregard devices that were never noticed by the agent",
            "        port_info['removed'] &= port_info['current']",
            "        # retry failed devices",
            "        port_info['added'] |= failed_devices['added']",
            "        if failed_devices['added']:",
            "            LOG.debug(\"retrying failed devices %s\", failed_devices['added'])",
            "        port_info['removed'] |= failed_devices['removed']",
            "        # Update current ports",
            "        port_info['current'] |= port_info['added']",
            "        port_info['current'] -= port_info['removed']",
            "",
            "    def process_ports_events(self, events, registered_ports, ancillary_ports,",
            "                             old_ports_not_ready, failed_devices,",
            "                             failed_ancillary_devices, updated_ports=None):",
            "        port_info = PortInfo(current=registered_ports)",
            "        ancillary_port_info = PortInfo(current=ancillary_ports)",
            "",
            "        ports_not_ready_yet = set()",
            "        if updated_ports is None:",
            "            updated_ports = set()",
            "",
            "        # if a port was added and then removed or viceversa since the agent",
            "        # can't know the order of the operations, check the status of the port",
            "        # to determine if the port was added or deleted",
            "        added_ports = {p['name'] for p in events['added']}",
            "        removed_ports = {p['name'] for p in events['removed']}",
            "        updated_ports.update({p['name'] for p in events['modified']})",
            "",
            "        ports_re_added = added_ports & removed_ports",
            "        ports_re_added = [p for p in ports_re_added if",
            "                          ovs_lib.BaseOVS().port_exists(p)]",
            "        events['re_added'] = [e for e in events['removed']",
            "                              if e['name'] in ports_re_added]",
            "        events['removed'] = [e for e in events['removed'] if e['name']",
            "                             not in ports_re_added]",
            "        ports_removed = [p['name'] for p in events['removed']]",
            "        events['added'] = [e for e in events['added'] if e['name'] not in",
            "                           ports_removed]",
            "",
            "        # TODO(rossella_s): scanning the ancillary bridge won't be needed",
            "        # anymore when https://review.opendev.org/#/c/203381 since the bridge",
            "        # id stored in external_ids will be used to identify the bridge the",
            "        # port belongs to",
            "        cur_ancillary_ports = set()",
            "        for bridge in self.ancillary_brs:",
            "            cur_ancillary_ports |= bridge.get_vif_port_set()",
            "        cur_ancillary_ports |= ancillary_port_info['current']",
            "",
            "        def _process_port(port, ports, ancillary_ports):",
            "            # check 'iface-id' is set otherwise is not a port",
            "            # the agent should care about",
            "            if 'attached-mac' in port.get('external_ids', []):",
            "                iface_id = self.int_br.portid_from_external_ids(",
            "                    port['external_ids'])",
            "                if iface_id:",
            "                    if port['ofport'] == ovs_lib.UNASSIGNED_OFPORT:",
            "                        LOG.debug(\"Port %s not ready yet on the bridge\",",
            "                                  iface_id)",
            "                        ports_not_ready_yet.add(port['name'])",
            "                        return",
            "                    # check if port belongs to ancillary bridge",
            "                    if iface_id in cur_ancillary_ports:",
            "                        ancillary_ports.add(iface_id)",
            "                    else:",
            "                        ports.add(iface_id)",
            "        if old_ports_not_ready:",
            "            old_ports_not_ready_attrs = self.int_br.get_ports_attributes(",
            "                'Interface', columns=['name', 'external_ids', 'ofport'],",
            "                ports=old_ports_not_ready, if_exists=True)",
            "            now_ready_ports = set(",
            "                [p['name'] for p in old_ports_not_ready_attrs])",
            "            LOG.debug(\"Ports %s are now ready\", now_ready_ports)",
            "            old_ports_not_ready_yet = old_ports_not_ready - now_ready_ports",
            "            removed_ports = set([p['name'] for p in events['removed']])",
            "            old_ports_not_ready_yet -= removed_ports",
            "            LOG.debug(\"Ports %s were not ready at last iteration and are not \"",
            "                      \"ready yet\", old_ports_not_ready_yet)",
            "            ports_not_ready_yet |= old_ports_not_ready_yet",
            "            events['added'].extend(old_ports_not_ready_attrs)",
            "",
            "        for event_type in ('added', 'removed', 're_added'):",
            "            for port in events.get(event_type, []):",
            "                _process_port(port, port_info[event_type],",
            "                              ancillary_port_info[event_type])",
            "",
            "        self._update_port_info_failed_devices_stats(port_info, failed_devices)",
            "        self._update_port_info_failed_devices_stats(ancillary_port_info,",
            "                                                    failed_ancillary_devices)",
            "",
            "        updated_ports.update(self.check_changed_vlans())",
            "",
            "        if updated_ports:",
            "            # Some updated ports might have been removed in the",
            "            # meanwhile, and therefore should not be processed.",
            "            # In this case the updated port won't be found among",
            "            # current ports.",
            "            updated_ports &= port_info['current']",
            "            port_info['updated'] = updated_ports",
            "        return port_info, ancillary_port_info, ports_not_ready_yet",
            "",
            "    def scan_ports(self, registered_ports, sync, updated_ports=None):",
            "        cur_ports = self.int_br.get_vif_port_set()",
            "        self.int_br_device_count = len(cur_ports)",
            "        port_info = self._get_port_info(registered_ports, cur_ports, sync)",
            "        if updated_ports is None:",
            "            updated_ports = set()",
            "        updated_ports.update(self.check_changed_vlans())",
            "        if updated_ports:",
            "            # Some updated ports might have been removed in the",
            "            # meanwhile, and therefore should not be processed.",
            "            # In this case the updated port won't be found among",
            "            # current ports.",
            "            updated_ports &= cur_ports",
            "            if updated_ports:",
            "                port_info['updated'] = updated_ports",
            "        return port_info",
            "",
            "    def scan_ancillary_ports(self, registered_ports, sync):",
            "        cur_ports = set()",
            "        for bridge in self.ancillary_brs:",
            "            cur_ports |= bridge.get_vif_port_set()",
            "        return self._get_port_info(registered_ports, cur_ports, sync)",
            "",
            "    def check_changed_vlans(self):",
            "        \"\"\"Check for changed VLAN tags. If changes, notify server and return.",
            "",
            "        The returned value is a set of port ids of the ports concerned by a",
            "        vlan tag loss.",
            "        \"\"\"",
            "        port_tags = self.int_br.get_port_tag_dict()",
            "        changed_ports = set()",
            "        for lvm in self.vlan_manager:",
            "            for port in lvm.vif_ports.values():",
            "                if (",
            "                    port.port_name in port_tags and",
            "                    port_tags[port.port_name] != lvm.vlan",
            "                ):",
            "                    LOG.info(",
            "                        \"Port '%(port_name)s' has lost \"",
            "                        \"its vlan tag '%(vlan_tag)d'! \"",
            "                        \"Current vlan tag on this port is '%(new_vlan_tag)d'.\",",
            "                        {'port_name': port.port_name,",
            "                         'vlan_tag': lvm.vlan,",
            "                         'new_vlan_tag': port_tags[port.port_name]}",
            "                    )",
            "                    changed_ports.add(port.vif_id)",
            "        if changed_ports:",
            "            # explicitly mark these DOWN on the server since they have been",
            "            # manipulated (likely a nova unplug/replug) and need to be rewired",
            "            devices_down = self.plugin_rpc.update_device_list(self.context,",
            "                                                              [],",
            "                                                              changed_ports,",
            "                                                              self.agent_id,",
            "                                                              self.conf.host)",
            "            failed_devices = set(devices_down.get('failed_devices_down'))",
            "            if failed_devices:",
            "                LOG.debug(\"Status updated failed for %s\", failed_devices)",
            "",
            "        return changed_ports",
            "",
            "    def treat_vif_port(self, vif_port, port_id, network_id, network_type,",
            "                       physical_network, segmentation_id, admin_state_up,",
            "                       fixed_ips, device_owner, provisioning_needed):",
            "        # When this function is called for a port, the port should have",
            "        # an OVS ofport configured, as only these ports were considered",
            "        # for being treated. If that does not happen, it is a potential",
            "        # error condition of which operators should be aware",
            "        port_needs_binding = True",
            "        if not vif_port.ofport:",
            "            LOG.warning(\"VIF port: %s has no ofport configured, \"",
            "                        \"and might not be able to transmit\",",
            "                        vif_port.vif_id)",
            "        if vif_port:",
            "            if admin_state_up:",
            "                port_needs_binding = self.port_bound(",
            "                    vif_port, network_id, network_type,",
            "                    physical_network, segmentation_id,",
            "                    fixed_ips, device_owner, provisioning_needed)",
            "            else:",
            "                LOG.info(\"VIF port: %s admin state up disabled, \"",
            "                         \"putting on the dead VLAN\", vif_port.vif_id)",
            "",
            "                self.port_dead(vif_port)",
            "                self.plugin_rpc.update_device_down(",
            "                    self.context, port_id, self.agent_id,",
            "                    self.conf.host)",
            "                port_needs_binding = False",
            "        else:",
            "            LOG.debug(\"No VIF port for port %s defined on agent.\", port_id)",
            "        return port_needs_binding",
            "",
            "    def _setup_tunnel_port(self, br, port_name, remote_ip, tunnel_type):",
            "        try:",
            "            if (netaddr.IPAddress(self.local_ip).version !=",
            "                    netaddr.IPAddress(remote_ip).version):",
            "                LOG.error(\"IP version mismatch, cannot create tunnel: \"",
            "                          \"local_ip=%(lip)s remote_ip=%(rip)s\",",
            "                          {'lip': self.local_ip, 'rip': remote_ip})",
            "                return 0",
            "        except Exception:",
            "            LOG.error(\"Invalid local or remote IP, cannot create tunnel: \"",
            "                      \"local_ip=%(lip)s remote_ip=%(rip)s\",",
            "                      {'lip': self.local_ip, 'rip': remote_ip})",
            "            return 0",
            "        ofport = br.add_tunnel_port(port_name,",
            "                                    remote_ip,",
            "                                    self.local_ip,",
            "                                    tunnel_type,",
            "                                    self.vxlan_udp_port,",
            "                                    self.dont_fragment,",
            "                                    self.tunnel_csum,",
            "                                    self.tos)",
            "        if ofport == ovs_lib.INVALID_OFPORT:",
            "            LOG.error(\"Failed to set-up %(type)s tunnel port to %(ip)s\",",
            "                      {'type': tunnel_type, 'ip': remote_ip})",
            "            return 0",
            "",
            "        self.tun_br_ofports[tunnel_type][remote_ip] = ofport",
            "        # Add flow in default table to resubmit to the right",
            "        # tunneling table (lvid will be set in the latter)",
            "        br.setup_tunnel_port(tunnel_type, ofport)",
            "        return ofport",
            "",
            "    def _setup_tunnel_flood_flow(self, br, tunnel_type):",
            "        ofports = self.tun_br_ofports[tunnel_type].values()",
            "        if ofports and not self.l2_pop:",
            "            # Update flooding flows to include the new tunnel",
            "            for vlan_mapping in self.vlan_manager:",
            "                if vlan_mapping.network_type == tunnel_type:",
            "                    br.install_flood_to_tun(vlan_mapping.vlan,",
            "                                            vlan_mapping.segmentation_id,",
            "                                            ofports)",
            "",
            "    def setup_tunnel_port(self, br, remote_ip, network_type):",
            "        port_name = self.get_tunnel_name(",
            "            network_type, self.local_ip, remote_ip)",
            "        if port_name is None:",
            "            return 0",
            "        ofport = self._setup_tunnel_port(br,",
            "                                         port_name,",
            "                                         remote_ip,",
            "                                         network_type)",
            "        self._setup_tunnel_flood_flow(br, network_type)",
            "        return ofport",
            "",
            "    def cleanup_tunnel_port(self, br, tun_ofport, tunnel_type):",
            "        # Check if this tunnel port is still used",
            "        for lvm in self.vlan_manager:",
            "            if tun_ofport in lvm.tun_ofports:",
            "                break",
            "        # If not, remove it",
            "        else:",
            "            items = list(self.tun_br_ofports[tunnel_type].items())",
            "            for remote_ip, ofport in items:",
            "                if ofport == tun_ofport:",
            "                    port_name = self.get_tunnel_name(",
            "                        tunnel_type, self.local_ip, remote_ip)",
            "                    br.delete_port(port_name)",
            "                    br.cleanup_tunnel_port(ofport)",
            "                    self.tun_br_ofports[tunnel_type].pop(remote_ip, None)",
            "",
            "    def treat_devices_added_or_updated(self, devices, provisioning_needed,",
            "                                       re_added):",
            "        skipped_devices = []",
            "        need_binding_devices = []",
            "        binding_no_activated_devices = set()",
            "        agent_restarted = self.iter_num == 0",
            "        devices_details_list = (",
            "            self.plugin_rpc.get_devices_details_list_and_failed_devices(",
            "                self.context,",
            "                devices,",
            "                self.agent_id,",
            "                self.conf.host,",
            "                agent_restarted))",
            "        failed_devices = set(devices_details_list.get('failed_devices'))",
            "",
            "        devices = devices_details_list.get('devices')",
            "        vif_by_id = self.int_br.get_vifs_by_ids(",
            "            [vif['device'] for vif in devices])",
            "        for details in devices:",
            "            device = details['device']",
            "            LOG.debug(\"Processing port: %s\", device)",
            "            port = vif_by_id.get(device)",
            "            if not port:",
            "                # The port disappeared and cannot be processed",
            "                LOG.info(\"Port %s was not found on the integration bridge \"",
            "                         \"and will therefore not be processed\", device)",
            "                self.ext_manager.delete_port(self.context, {'port_id': device})",
            "                skipped_devices.append(device)",
            "                continue",
            "",
            "            if 'port_id' in details:",
            "                LOG.info(\"Port %(device)s updated. Details: %(details)s\",",
            "                         {'device': device, 'details': details})",
            "                details['vif_port'] = port",
            "                need_binding = self.treat_vif_port(port, details['port_id'],",
            "                                                   details['network_id'],",
            "                                                   details['network_type'],",
            "                                                   details['physical_network'],",
            "                                                   details['segmentation_id'],",
            "                                                   details['admin_state_up'],",
            "                                                   details['fixed_ips'],",
            "                                                   details['device_owner'],",
            "                                                   provisioning_needed)",
            "                if need_binding:",
            "                    need_binding_devices.append(details)",
            "                self._update_port_network(details['port_id'],",
            "                                          details['network_id'])",
            "                if details['device'] in re_added:",
            "                    self.ext_manager.delete_port(self.context, details)",
            "                self.ext_manager.handle_port(self.context, details)",
            "            else:",
            "                if n_const.NO_ACTIVE_BINDING in details:",
            "                    # Port was added to the bridge, but its binding in this",
            "                    # agent hasn't been activated yet. It will be treated as",
            "                    # added when binding is activated",
            "                    binding_no_activated_devices.add(device)",
            "                    LOG.debug(\"Device %s has no active binding in host\",",
            "                              device)",
            "                else:",
            "                    LOG.warning(",
            "                        \"Device %s not defined on plugin or binding failed\",",
            "                        device)",
            "                if (port and port.ofport != -1):",
            "                    self.port_dead(port)",
            "        return (skipped_devices, binding_no_activated_devices,",
            "                need_binding_devices, failed_devices)",
            "",
            "    def _update_port_network(self, port_id, network_id):",
            "        self._clean_network_ports(port_id)",
            "        self.network_ports[network_id].add(port_id)",
            "",
            "    def treat_ancillary_devices_added(self, devices):",
            "        devices_details_list = (",
            "            self.plugin_rpc.get_devices_details_list_and_failed_devices(",
            "                self.context,",
            "                devices,",
            "                self.agent_id,",
            "                self.conf.host))",
            "        failed_devices = set(devices_details_list.get('failed_devices'))",
            "        devices_added = [",
            "            d['device'] for d in devices_details_list.get('devices')]",
            "",
            "        # update plugin about port status",
            "        devices_set_up = (",
            "            self.plugin_rpc.update_device_list(self.context,",
            "                                               devices_added,",
            "                                               [],",
            "                                               self.agent_id,",
            "                                               self.conf.host))",
            "        failed_devices |= set(devices_set_up.get('failed_devices_up'))",
            "        LOG.info(\"Ancillary Ports %(added)s added, failed devices \"",
            "                 \"%(failed)s\", {'added': devices, 'failed': failed_devices})",
            "        return failed_devices",
            "",
            "    def treat_devices_removed(self, devices):",
            "        self.sg_agent.remove_devices_filter(devices)",
            "        LOG.info(\"Ports %s removed\", devices)",
            "        devices_down = self.plugin_rpc.update_device_list(self.context,",
            "                                                          [],",
            "                                                          devices,",
            "                                                          self.agent_id,",
            "                                                          self.conf.host)",
            "        failed_devices = set(devices_down.get('failed_devices_down'))",
            "        LOG.debug(\"Port removal failed for %s\", failed_devices)",
            "        for device in devices:",
            "            self.ext_manager.delete_port(self.context, {'port_id': device})",
            "            self.port_unbound(device)",
            "        return failed_devices",
            "",
            "    def treat_ancillary_devices_removed(self, devices):",
            "        LOG.info(\"Ancillary ports %s removed\", devices)",
            "        devices_down = self.plugin_rpc.update_device_list(self.context,",
            "                                                          [],",
            "                                                          devices,",
            "                                                          self.agent_id,",
            "                                                          self.conf.host)",
            "        LOG.info(\"Devices down  %s \", devices_down)",
            "        failed_devices = set(devices_down.get('failed_devices_down'))",
            "        if failed_devices:",
            "            LOG.debug(\"Port removal failed for %s\", failed_devices)",
            "        for detail in devices_down.get('devices_down'):",
            "            if detail['exists']:",
            "                LOG.info(\"Port %s updated.\", detail['device'])",
            "                # Nothing to do regarding local networking",
            "            else:",
            "                LOG.debug(\"Device %s not defined on plugin\", detail['device'])",
            "        return failed_devices",
            "",
            "    def treat_devices_skipped(self, devices):",
            "        LOG.info(\"Ports %s skipped, changing status to down\", devices)",
            "        devices_down = self.plugin_rpc.update_device_list(self.context,",
            "                                                          [],",
            "                                                          devices,",
            "                                                          self.agent_id,",
            "                                                          self.conf.host)",
            "        failed_devices = set(devices_down.get('failed_devices_down'))",
            "        if failed_devices:",
            "            LOG.debug(\"Port down failed for %s\", failed_devices)",
            "",
            "    def process_network_ports(self, port_info, provisioning_needed):",
            "        failed_devices = {'added': set(), 'removed': set()}",
            "        # TODO(salv-orlando): consider a solution for ensuring notifications",
            "        # are processed exactly in the same order in which they were",
            "        # received. This is tricky because there are two notification",
            "        # sources: the neutron server, and the ovs db monitor process",
            "        # If there is an exception while processing security groups ports",
            "        # will not be wired anyway, and a resync will be triggered",
            "        # VIF wiring needs to be performed always for 'new' devices.",
            "        # For updated ports, re-wiring is not needed in most cases, but needs",
            "        # to be performed anyway when the admin state of a device is changed.",
            "        # A device might be both in the 'added' and 'updated'",
            "        # list at the same time; avoid processing it twice.",
            "        devices_added_updated = (port_info.get('added', set()) |",
            "                                 port_info.get('updated', set()))",
            "        re_added = port_info.get('re_added', set())",
            "        need_binding_devices = []",
            "        skipped_devices = set()",
            "        binding_no_activated_devices = set()",
            "        start = time.time()",
            "        if devices_added_updated:",
            "            (skipped_devices, binding_no_activated_devices,",
            "             need_binding_devices, failed_devices['added']) = (",
            "                self.treat_devices_added_or_updated(",
            "                    devices_added_updated, provisioning_needed, re_added))",
            "            LOG.info(\"process_network_ports - iteration:%(iter_num)d - \"",
            "                     \"treat_devices_added_or_updated completed. \"",
            "                     \"Skipped %(num_skipped)d and no activated binding \"",
            "                     \"devices %(num_no_active_binding)d of %(num_current)d \"",
            "                     \"devices currently available. \"",
            "                     \"Time elapsed: %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'num_skipped': len(skipped_devices),",
            "                      'num_no_active_binding':",
            "                          len(binding_no_activated_devices),",
            "                      'num_current': len(port_info['current']),",
            "                      'elapsed': time.time() - start})",
            "            # Update the list of current ports storing only those which",
            "            # have been actually processed.",
            "            skipped_devices = set(skipped_devices)",
            "            port_info['current'] = (port_info['current'] - skipped_devices)",
            "",
            "        # TODO(salv-orlando): Optimize avoiding applying filters",
            "        # unnecessarily, (eg: when there are no IP address changes)",
            "        added_ports = (port_info.get('added', set()) - skipped_devices -",
            "                       binding_no_activated_devices)",
            "        self._add_port_tag_info(need_binding_devices)",
            "",
            "        self.process_install_ports_egress_flows(need_binding_devices)",
            "",
            "        self.sg_agent.setup_port_filters(added_ports,",
            "                                         port_info.get('updated', set()))",
            "        LOG.info(\"process_network_ports - iteration:%(iter_num)d - \"",
            "                 \"agent port security group processed in %(elapsed).3f\",",
            "                 {'iter_num': self.iter_num,",
            "                  'elapsed': time.time() - start})",
            "        failed_devices['added'] |= self._bind_devices(need_binding_devices)",
            "",
            "        if 'removed' in port_info and port_info['removed']:",
            "            start = time.time()",
            "            failed_devices['removed'] |= self.treat_devices_removed(",
            "                port_info['removed'])",
            "            LOG.info(\"process_network_ports - iteration:%(iter_num)d - \"",
            "                     \"treat_devices_removed completed in %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'elapsed': time.time() - start})",
            "        if skipped_devices:",
            "            start = time.time()",
            "            self.treat_devices_skipped(skipped_devices)",
            "            LOG.info(\"process_network_ports - iteration:%(iter_num)d - \"",
            "                     \"treat_devices_skipped completed in %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'elapsed': time.time() - start})",
            "        return failed_devices",
            "",
            "    def process_install_ports_egress_flows(self, ports):",
            "        if not self.conf.AGENT.explicitly_egress_direct:",
            "            return",
            "",
            "        if (isinstance(self.sg_agent.firewall,",
            "                       agent_firewall.NoopFirewallDriver) or",
            "                not agent_sg_rpc.is_firewall_enabled()):",
            "            with self.int_br.deferred(full_ordered=True,",
            "                                      use_bundle=True) as int_br:",
            "                for port in ports:",
            "                    try:",
            "                        self.install_accepted_egress_direct_flow(port, int_br)",
            "                        # give other coroutines a chance to run",
            "                        eventlet.sleep(0)",
            "                    except Exception as err:",
            "                        LOG.debug(\"Failed to install accepted egress flows \"",
            "                                  \"for port %s, error: %s\",",
            "                                  port['port_id'], err)",
            "",
            "    def install_accepted_egress_direct_flow(self, port_detail, br_int):",
            "        lvm = self.vlan_manager.get(port_detail['network_id'])",
            "        port = port_detail['vif_port']",
            "",
            "        br_int.add_flow(",
            "            table=constants.TRANSIENT_TABLE,",
            "            priority=9,",
            "            in_port=port.ofport,",
            "            dl_src=port_detail['mac_address'],",
            "            actions='resubmit(,{:d})'.format(",
            "                constants.TRANSIENT_EGRESS_TABLE))",
            "",
            "        br_int.add_flow(",
            "            table=constants.TRANSIENT_EGRESS_TABLE,",
            "            priority=12,",
            "            dl_dst=port_detail['mac_address'],",
            "            actions='output:{:d}'.format(port.ofport))",
            "",
            "        patch_ofport = None",
            "        if lvm.network_type in (",
            "                n_const.TYPE_VXLAN, n_const.TYPE_GRE,",
            "                n_const.TYPE_GENEVE):",
            "            port_name = self.conf.OVS.int_peer_patch_port",
            "            patch_ofport = self.int_br.get_port_ofport(port_name)",
            "        elif lvm.network_type == n_const.TYPE_VLAN:",
            "            bridge = self.bridge_mappings.get(lvm.physical_network)",
            "            port_name = plugin_utils.get_interface_name(",
            "                bridge, prefix=constants.PEER_INTEGRATION_PREFIX)",
            "            patch_ofport = self.int_br.get_port_ofport(port_name)",
            "        if patch_ofport is not None:",
            "            br_int.add_flow(",
            "                table=constants.TRANSIENT_EGRESS_TABLE,",
            "                priority=10,",
            "                dl_src=port_detail['mac_address'],",
            "                dl_dst=\"00:00:00:00:00:00/01:00:00:00:00:00\",",
            "                in_port=port.ofport,",
            "                actions='mod_vlan_vid:{:d},'",
            "                        'output:{:d}'.format(",
            "                            lvm.vlan,",
            "                            patch_ofport))",
            "",
            "    def delete_accepted_egress_direct_flow(self, br_int, ofport, mac, vlan):",
            "        if not self.conf.AGENT.explicitly_egress_direct:",
            "            return",
            "",
            "        br_int.delete_flows(",
            "            table=constants.TRANSIENT_TABLE,",
            "            in_port=ofport,",
            "            dl_src=mac)",
            "        self.delete_flows(",
            "            table=constants.TRANSIENT_EGRESS_TABLE,",
            "            dl_dst=mac)",
            "",
            "        self.delete_flows(",
            "            table=constants.TRANSIENT_EGRESS_TABLE,",
            "            dl_src=mac,",
            "            in_port=ofport)",
            "",
            "    def process_ancillary_network_ports(self, port_info):",
            "        failed_devices = {'added': set(), 'removed': set()}",
            "        if 'added' in port_info and port_info['added']:",
            "            start = time.time()",
            "            failed_added = self.treat_ancillary_devices_added(",
            "                port_info['added'])",
            "            LOG.info(\"process_ancillary_network_ports - iteration: \"",
            "                     \"%(iter_num)d - treat_ancillary_devices_added \"",
            "                     \"completed in %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'elapsed': time.time() - start})",
            "            failed_devices['added'] = failed_added",
            "",
            "        if 'removed' in port_info and port_info['removed']:",
            "            start = time.time()",
            "            failed_removed = self.treat_ancillary_devices_removed(",
            "                port_info['removed'])",
            "            failed_devices['removed'] = failed_removed",
            "",
            "            LOG.info(\"process_ancillary_network_ports - iteration: \"",
            "                     \"%(iter_num)d - treat_ancillary_devices_removed \"",
            "                     \"completed in %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'elapsed': time.time() - start})",
            "        return failed_devices",
            "",
            "    @classmethod",
            "    def get_tunnel_hash(cls, ip_address, hashlen):",
            "        try:",
            "            addr = netaddr.IPAddress(ip_address)",
            "            if addr.version == n_const.IP_VERSION_4:",
            "                # We cannot change this from 8, since it could break",
            "                # backwards-compatibility",
            "                return '%08x' % addr",
            "            else:",
            "                # Create 32-bit Base32 encoded hash",
            "                sha1 = hashlib.sha1(ip_address.encode())",
            "                iphash = base64.b32encode(sha1.digest())",
            "                return iphash[:hashlen].decode().lower()",
            "        except Exception:",
            "            LOG.warning(\"Invalid remote IP: %s\", ip_address)",
            "            return",
            "",
            "    def tunnel_sync(self):",
            "        LOG.debug(\"Configuring tunnel endpoints to other OVS agents\")",
            "",
            "        try:",
            "            for tunnel_type in self.tunnel_types:",
            "                details = self.plugin_rpc.tunnel_sync(self.context,",
            "                                                      self.local_ip,",
            "                                                      tunnel_type,",
            "                                                      self.conf.host)",
            "                if not self.l2_pop:",
            "                    tunnels = details['tunnels']",
            "                    for tunnel in tunnels:",
            "                        if self.local_ip != tunnel['ip_address']:",
            "                            remote_ip = tunnel['ip_address']",
            "                            tun_name = self.get_tunnel_name(",
            "                                tunnel_type, self.local_ip, remote_ip)",
            "                            if tun_name is None:",
            "                                continue",
            "                            self._setup_tunnel_port(self.tun_br,",
            "                                                    tun_name,",
            "                                                    tunnel['ip_address'],",
            "                                                    tunnel_type)",
            "                    self._setup_tunnel_flood_flow(self.tun_br, tunnel_type)",
            "        except Exception as e:",
            "            LOG.debug(\"Unable to sync tunnel IP %(local_ip)s: %(e)s\",",
            "                      {'local_ip': self.local_ip, 'e': e})",
            "            return True",
            "        return False",
            "",
            "    @classmethod",
            "    def get_tunnel_name(cls, network_type, local_ip, remote_ip):",
            "        # This string is used to build port and interface names in OVS.",
            "        # Port and interface names can be max 16 characters long,",
            "        # including NULL, and must be unique per table per host.",
            "        # We make the name as long as possible given the network_type,",
            "        # for example, 'vxlan-012345678' or 'geneve-01234567'.",
            "",
            "        # Remove length of network type and dash",
            "        hashlen = n_const.DEVICE_NAME_MAX_LEN - len(network_type) - 1",
            "        remote_tunnel_hash = cls.get_tunnel_hash(remote_ip, hashlen)",
            "        if not remote_tunnel_hash:",
            "            return None",
            "        return '%s-%s' % (network_type, remote_tunnel_hash)",
            "",
            "    def _agent_has_updates(self, polling_manager):",
            "        return (polling_manager.is_polling_required or",
            "                self.updated_ports or",
            "                self.deleted_ports or",
            "                self.deactivated_bindings or",
            "                self.activated_bindings or",
            "                self.updated_smartnic_ports or",
            "                self.sg_agent.firewall_refresh_needed())",
            "",
            "    def _port_info_has_changes(self, port_info):",
            "        return (port_info.get('added') or",
            "                port_info.get('removed') or",
            "                port_info.get('updated'))",
            "",
            "    def check_ovs_status(self):",
            "        try:",
            "            # Check for the canary flow",
            "            status = self.int_br.check_canary_table()",
            "        except Exception:",
            "            LOG.exception(\"Failure while checking for the canary flow\")",
            "            status = constants.OVS_DEAD",
            "        if status == constants.OVS_RESTARTED:",
            "            LOG.warning(\"OVS is restarted. OVSNeutronAgent will reset \"",
            "                        \"bridges and recover ports.\")",
            "        elif status == constants.OVS_DEAD:",
            "            LOG.warning(\"OVS is dead. OVSNeutronAgent will keep running \"",
            "                        \"and checking OVS status periodically.\")",
            "        return status",
            "",
            "    def loop_count_and_wait(self, start_time, port_stats):",
            "        # sleep till end of polling interval",
            "        elapsed = time.time() - start_time",
            "        LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d \"",
            "                 \"completed. Processed ports statistics: \"",
            "                 \"%(port_stats)s. Elapsed:%(elapsed).3f\",",
            "                 {'iter_num': self.iter_num,",
            "                  'port_stats': port_stats,",
            "                  'elapsed': elapsed})",
            "        if elapsed < self.polling_interval:",
            "            time.sleep(self.polling_interval - elapsed)",
            "        else:",
            "            LOG.debug(\"Loop iteration exceeded interval \"",
            "                      \"(%(polling_interval)s vs. %(elapsed)s)!\",",
            "                      {'polling_interval': self.polling_interval,",
            "                       'elapsed': elapsed})",
            "        self.iter_num = self.iter_num + 1",
            "",
            "    def get_port_stats(self, port_info, ancillary_port_info):",
            "        port_stats = {",
            "            'regular': {",
            "                'added': len(port_info.get('added', [])),",
            "                'updated': len(port_info.get('updated', [])),",
            "                'removed': len(port_info.get('removed', []))}}",
            "        if self.ancillary_brs:",
            "            port_stats['ancillary'] = {",
            "                'added': len(ancillary_port_info.get('added', [])),",
            "                'removed': len(ancillary_port_info.get('removed', []))}",
            "        return port_stats",
            "",
            "    def cleanup_stale_flows(self):",
            "        LOG.info(\"Cleaning stale %s flows\", self.int_br.br_name)",
            "        self.int_br.cleanup_flows()",
            "        for pby_br in self.phys_brs.values():",
            "            LOG.info(\"Cleaning stale %s flows\", pby_br.br_name)",
            "            pby_br.cleanup_flows()",
            "",
            "        if self.enable_tunneling:",
            "            LOG.info(\"Cleaning stale %s flows\", self.tun_br.br_name)",
            "            self.tun_br.cleanup_flows()",
            "",
            "    def process_port_info(self, start, polling_manager, sync, ovs_restarted,",
            "                          ports, ancillary_ports, updated_ports_copy,",
            "                          consecutive_resyncs, ports_not_ready_yet,",
            "                          failed_devices, failed_ancillary_devices):",
            "        # There are polling managers that don't have get_events, e.g.",
            "        # AlwaysPoll used by windows implementations",
            "        # REVISIT (rossella_s) This needs to be reworked to hide implementation",
            "        # details regarding polling in BasePollingManager subclasses",
            "        if sync or not (hasattr(polling_manager, 'get_events')):",
            "            if sync:",
            "                LOG.info(\"Agent out of sync with plugin!\")",
            "                consecutive_resyncs = consecutive_resyncs + 1",
            "                if (consecutive_resyncs >=",
            "                        constants.MAX_DEVICE_RETRIES):",
            "                    LOG.warning(",
            "                        \"Clearing cache of registered ports,\"",
            "                        \" retries to resync were > %s\",",
            "                        constants.MAX_DEVICE_RETRIES)",
            "                    ports.clear()",
            "                    ancillary_ports.clear()",
            "                    consecutive_resyncs = 0",
            "            else:",
            "                consecutive_resyncs = 0",
            "                # TODO(rossella_s): For implementations that use AlwaysPoll",
            "                # resync if a device failed. This can be improved in future",
            "                sync = (any(failed_devices.values()) or",
            "                        any(failed_ancillary_devices.values()))",
            "",
            "            # NOTE(rossella_s) don't empty the queue of events",
            "            # calling polling_manager.get_events() since",
            "            # the agent might miss some event (for example a port",
            "            # deletion)",
            "            reg_ports = (set() if ovs_restarted else ports)",
            "            port_info = self.scan_ports(reg_ports, sync,",
            "                                        updated_ports_copy)",
            "            # Treat ancillary devices if they exist",
            "            if self.ancillary_brs:",
            "                ancillary_port_info = self.scan_ancillary_ports(",
            "                    ancillary_ports, sync)",
            "                LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d\"",
            "                         \" - ancillary port info retrieved. \"",
            "                         \"Elapsed:%(elapsed).3f\",",
            "                         {'iter_num': self.iter_num,",
            "                          'elapsed': time.time() - start})",
            "            else:",
            "                ancillary_port_info = {}",
            "",
            "        else:",
            "            consecutive_resyncs = 0",
            "            events = polling_manager.get_events()",
            "            port_info, ancillary_port_info, ports_not_ready_yet = (",
            "                self.process_ports_events(events, ports, ancillary_ports,",
            "                                          ports_not_ready_yet,",
            "                                          failed_devices,",
            "                                          failed_ancillary_devices,",
            "                                          updated_ports_copy))",
            "            registry.notify(",
            "                constants.OVSDB_RESOURCE,",
            "                callback_events.AFTER_READ,",
            "                self,",
            "                ovsdb_events=events)",
            "",
            "        return (port_info, ancillary_port_info, consecutive_resyncs,",
            "                ports_not_ready_yet)",
            "",
            "    def _remove_devices_not_to_retry(self, failed_devices,",
            "                                     failed_ancillary_devices,",
            "                                     devices_not_to_retry,",
            "                                     ancillary_devices_not_to_retry):",
            "        \"\"\"This method removes the devices that exceeded the number of retries",
            "           from failed_devices and failed_ancillary_devices",
            "",
            "        \"\"\"",
            "        for event in ['added', 'removed']:",
            "            failed_devices[event] = (",
            "                failed_devices[event] - devices_not_to_retry[event])",
            "            failed_ancillary_devices[event] = (",
            "                failed_ancillary_devices[event] -",
            "                ancillary_devices_not_to_retry[event])",
            "",
            "    def _get_devices_not_to_retry(self, failed_devices,",
            "                                  failed_ancillary_devices,",
            "                                  failed_devices_retries_map):",
            "        \"\"\"Return the devices not to retry and update the retries map\"\"\"",
            "        new_failed_devices_retries_map = {}",
            "        devices_not_to_retry = {}",
            "        ancillary_devices_not_to_retry = {}",
            "",
            "        def _increase_retries(devices_set):",
            "            devices_not_to_retry = set()",
            "            for dev in devices_set:",
            "                retries = failed_devices_retries_map.get(dev, 0)",
            "                if retries >= constants.MAX_DEVICE_RETRIES:",
            "                    devices_not_to_retry.add(dev)",
            "                    LOG.warning(",
            "                        \"Device %(dev)s failed for %(times)s times and won't \"",
            "                        \"be retried anymore\", {",
            "                            'dev': dev, 'times': constants.MAX_DEVICE_RETRIES})",
            "                else:",
            "                    new_failed_devices_retries_map[dev] = retries + 1",
            "            return devices_not_to_retry",
            "",
            "        for event in ['added', 'removed']:",
            "            devices_not_to_retry[event] = _increase_retries(",
            "                failed_devices[event])",
            "            ancillary_devices_not_to_retry[event] = _increase_retries(",
            "                failed_ancillary_devices[event])",
            "",
            "        return (new_failed_devices_retries_map, devices_not_to_retry,",
            "                ancillary_devices_not_to_retry)",
            "",
            "    def update_retries_map_and_remove_devs_not_to_retry(",
            "            self, failed_devices, failed_ancillary_devices,",
            "            failed_devices_retries_map):",
            "        (new_failed_devices_retries_map, devices_not_to_retry,",
            "         ancillary_devices_not_to_retry) = self._get_devices_not_to_retry(",
            "            failed_devices, failed_ancillary_devices,",
            "            failed_devices_retries_map)",
            "        self._remove_devices_not_to_retry(",
            "            failed_devices, failed_ancillary_devices, devices_not_to_retry,",
            "            ancillary_devices_not_to_retry)",
            "        return new_failed_devices_retries_map",
            "",
            "    def _handle_ovs_restart(self, polling_manager):",
            "        self.setup_integration_br()",
            "        self.setup_physical_bridges(self.bridge_mappings)",
            "        if self.enable_tunneling:",
            "            self._reset_tunnel_ofports()",
            "            self.setup_tunnel_br()",
            "            self.setup_tunnel_br_flows()",
            "            self.agent_state['start_flag'] = True",
            "            # Force state report to avoid race condition",
            "            # with l2pop fdb entries update",
            "            self._report_state()",
            "        if self.enable_distributed_routing:",
            "            self.dvr_agent.reset_dvr_flows(",
            "                self.int_br, self.tun_br, self.phys_brs,",
            "                self.patch_int_ofport, self.patch_tun_ofport)",
            "        # notify that OVS has restarted",
            "        registry.publish(",
            "            callback_resources.AGENT,",
            "            callback_events.OVS_RESTARTED,",
            "            self, payload=None)",
            "        # restart the polling manager so that it will signal as added",
            "        # all the current ports",
            "        # REVISIT (rossella_s) Define a method \"reset\" in",
            "        # BasePollingManager that will be implemented by AlwaysPoll as",
            "        # no action and by InterfacePollingMinimizer as start/stop",
            "        if isinstance(polling_manager, polling.InterfacePollingMinimizer):",
            "            polling_manager.stop()",
            "            polling_manager.start()",
            "",
            "    def rpc_loop(self, polling_manager):",
            "        idl_monitor = self.ovs.ovsdb.idl_monitor",
            "        sync = False",
            "        ports = set()",
            "        updated_ports_copy = set()",
            "        activated_bindings_copy = set()",
            "        ancillary_ports = set()",
            "        tunnel_sync = True",
            "        ovs_restarted = False",
            "        consecutive_resyncs = 0",
            "        need_clean_stale_flow = True",
            "        ports_not_ready_yet = set()",
            "        failed_devices = {'added': set(), 'removed': set()}",
            "        failed_ancillary_devices = {'added': set(), 'removed': set()}",
            "        failed_devices_retries_map = {}",
            "        while self._check_and_handle_signal():",
            "            if self.fullsync:",
            "                LOG.info(\"rpc_loop doing a full sync.\")",
            "                sync = True",
            "                self.fullsync = False",
            "            port_info = {}",
            "            ancillary_port_info = {}",
            "            start = time.time()",
            "            LOG.info(\"Agent rpc_loop - iteration:%d started\",",
            "                     self.iter_num)",
            "            ovs_status = self.check_ovs_status()",
            "            bridges_recreated = False",
            "            if ovs_status == constants.OVS_RESTARTED:",
            "                self._handle_ovs_restart(polling_manager)",
            "                tunnel_sync = self.enable_tunneling or tunnel_sync",
            "            elif ovs_status == constants.OVS_DEAD:",
            "                # Agent doesn't apply any operations when ovs is dead, to",
            "                # prevent unexpected failure or crash. Sleep and continue",
            "                # loop in which ovs status will be checked periodically.",
            "                port_stats = self.get_port_stats({}, {})",
            "                self.loop_count_and_wait(start, port_stats)",
            "                continue",
            "            else:",
            "                # Check if any physical bridge wasn't recreated recently,",
            "                # in case when openvswitch was restarted, it's not needed",
            "                added_bridges = idl_monitor.bridges_added + self.added_bridges",
            "                bridges_recreated = self._reconfigure_physical_bridges(",
            "                    added_bridges)",
            "                if bridges_recreated:",
            "                    # In case when any bridge was \"re-created\", we need to",
            "                    # ensure that there is no any stale flows in bridges left",
            "                    need_clean_stale_flow = True",
            "                sync |= bridges_recreated",
            "            # Notify the plugin of tunnel IP",
            "            if self.enable_tunneling and tunnel_sync:",
            "                try:",
            "                    tunnel_sync = self.tunnel_sync()",
            "                except Exception:",
            "                    LOG.exception(\"Error while configuring tunnel endpoints\")",
            "                    tunnel_sync = True",
            "            ovs_restarted |= (ovs_status == constants.OVS_RESTARTED)",
            "            devices_need_retry = (any(failed_devices.values()) or",
            "                                  any(failed_ancillary_devices.values()) or",
            "                                  ports_not_ready_yet)",
            "            if (self._agent_has_updates(polling_manager) or sync or",
            "                    devices_need_retry):",
            "                try:",
            "                    LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d - \"",
            "                             \"starting polling. Elapsed:%(elapsed).3f\",",
            "                             {'iter_num': self.iter_num,",
            "                              'elapsed': time.time() - start})",
            "",
            "                    if self.conf.AGENT.baremetal_smartnic:",
            "                        if sync:",
            "                            self.process_smartnic_ports()",
            "                        updated_smartnic_ports_copy = (",
            "                            self.updated_smartnic_ports)",
            "                        self.updated_smartnic_ports = list()",
            "                        for port_data in updated_smartnic_ports_copy:",
            "                            self.treat_smartnic_port(port_data)",
            "",
            "                    # Save updated ports dict to perform rollback in",
            "                    # case resync would be needed, and then clear",
            "                    # self.updated_ports. As the greenthread should not yield",
            "                    # between these two statements, this will be thread-safe",
            "                    updated_ports_copy = self.updated_ports",
            "                    self.updated_ports = set()",
            "                    activated_bindings_copy = self.activated_bindings",
            "                    self.activated_bindings = set()",
            "                    (port_info, ancillary_port_info, consecutive_resyncs,",
            "                     ports_not_ready_yet) = (self.process_port_info(",
            "                            start, polling_manager, sync, ovs_restarted,",
            "                            ports, ancillary_ports, updated_ports_copy,",
            "                            consecutive_resyncs, ports_not_ready_yet,",
            "                            failed_devices, failed_ancillary_devices))",
            "                    sync = False",
            "                    self.process_deleted_ports(port_info)",
            "                    self.process_deactivated_bindings(port_info)",
            "                    self.process_activated_bindings(port_info,",
            "                                                    activated_bindings_copy)",
            "                    ofport_changed_ports = self.update_stale_ofport_rules()",
            "                    if ofport_changed_ports:",
            "                        port_info.setdefault('updated', set()).update(",
            "                            ofport_changed_ports)",
            "                    LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d - \"",
            "                             \"port information retrieved. \"",
            "                             \"Elapsed:%(elapsed).3f\",",
            "                             {'iter_num': self.iter_num,",
            "                              'elapsed': time.time() - start})",
            "                    # Secure and wire/unwire VIFs and update their status",
            "                    # on Neutron server",
            "                    if (self._port_info_has_changes(port_info) or",
            "                            self.sg_agent.firewall_refresh_needed() or",
            "                            ovs_restarted):",
            "                        LOG.debug(\"Starting to process devices in:%s\",",
            "                                  port_info)",
            "                        provisioning_needed = (",
            "                                ovs_restarted or bridges_recreated)",
            "                        failed_devices = self.process_network_ports(",
            "                            port_info, provisioning_needed)",
            "                        LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d - \"",
            "                                 \"ports processed. Elapsed:%(elapsed).3f\",",
            "                                 {'iter_num': self.iter_num,",
            "                                  'elapsed': time.time() - start})",
            "",
            "                    if need_clean_stale_flow:",
            "                        self.cleanup_stale_flows()",
            "                        need_clean_stale_flow = False",
            "                        LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d - \"",
            "                                 \"cleanup stale flows. Elapsed:%(elapsed).3f\",",
            "                                 {'iter_num': self.iter_num,",
            "                                  'elapsed': time.time() - start})",
            "",
            "                    ports = port_info['current']",
            "",
            "                    if self.ancillary_brs:",
            "                        failed_ancillary_devices = (",
            "                            self.process_ancillary_network_ports(",
            "                                ancillary_port_info))",
            "                        LOG.info(\"Agent rpc_loop - iteration: \"",
            "                                 \"%(iter_num)d - ancillary ports \"",
            "                                 \"processed. Elapsed:%(elapsed).3f\",",
            "                                 {'iter_num': self.iter_num,",
            "                                  'elapsed': time.time() - start})",
            "                        ancillary_ports = ancillary_port_info['current']",
            "",
            "                    polling_manager.polling_completed()",
            "                    failed_devices_retries_map = (",
            "                        self.update_retries_map_and_remove_devs_not_to_retry(",
            "                            failed_devices, failed_ancillary_devices,",
            "                            failed_devices_retries_map))",
            "                    # Keep this flag in the last line of \"try\" block,",
            "                    # so we can sure that no other Exception occurred.",
            "                    ovs_restarted = False",
            "                    self._dispose_local_vlan_hints()",
            "                except Exception:",
            "                    LOG.exception(\"Error while processing VIF ports\")",
            "                    # Put the ports back in self.updated_port",
            "                    self.updated_ports |= updated_ports_copy",
            "                    self.activated_bindings |= activated_bindings_copy",
            "                    sync = True",
            "            port_stats = self.get_port_stats(port_info, ancillary_port_info)",
            "            self.loop_count_and_wait(start, port_stats)",
            "",
            "    def daemon_loop(self):",
            "        # Start everything.",
            "        LOG.info(\"Agent initialized successfully, now running... \")",
            "        signal.signal(signal.SIGTERM, self._handle_sigterm)",
            "        if hasattr(signal, 'SIGHUP'):",
            "            signal.signal(signal.SIGHUP, self._handle_sighup)",
            "        br_names = [br.br_name for br in self.phys_brs.values()]",
            "",
            "        self.ovs.ovsdb.idl_monitor.start_bridge_monitor(br_names)",
            "        with polling.get_polling_manager(",
            "                self.minimize_polling,",
            "                self.ovsdb_monitor_respawn_interval) as pm:",
            "            self.rpc_loop(polling_manager=pm)",
            "",
            "    def _handle_sigterm(self, signum, frame):",
            "        self.catch_sigterm = True",
            "        if self.quitting_rpc_timeout:",
            "            LOG.info(",
            "                'SIGTERM received, capping RPC timeout by %d seconds.',",
            "                self.quitting_rpc_timeout)",
            "            self.set_rpc_timeout(self.quitting_rpc_timeout)",
            "",
            "    def _handle_sighup(self, signum, frame):",
            "        self.catch_sighup = True",
            "",
            "    def _check_and_handle_signal(self):",
            "        if self.catch_sigterm:",
            "            LOG.info(\"Agent caught SIGTERM, quitting daemon loop.\")",
            "            self.run_daemon_loop = False",
            "            self.catch_sigterm = False",
            "        if self.catch_sighup:",
            "            LOG.info(\"Agent caught SIGHUP, resetting.\")",
            "            self.conf.mutate_config_files()",
            "            config.setup_logging()",
            "            LOG.debug('Full set of CONF:')",
            "            self.conf.log_opt_values(LOG, logging.DEBUG)",
            "            self.catch_sighup = False",
            "        return self.run_daemon_loop",
            "",
            "    def set_rpc_timeout(self, timeout):",
            "        for rpc_api in (self.plugin_rpc, self.sg_plugin_rpc,",
            "                        self.dvr_plugin_rpc, self.state_rpc):",
            "            rpc_api.client.set_max_timeout(timeout)",
            "",
            "    def _check_agent_configurations(self):",
            "        if (self.enable_distributed_routing and self.enable_tunneling and",
            "                not self.l2_pop):",
            "",
            "            raise ValueError(_(\"DVR deployments for VXLAN/GRE/Geneve \"",
            "                               \"underlays require L2-pop to be enabled, \"",
            "                               \"in both the Agent and Server side.\"))",
            "",
            "",
            "def validate_local_ip(local_ip):",
            "    \"\"\"Verify if the ip exists on the agent's host.\"\"\"",
            "    if not ip_lib.IPWrapper().get_device_by_ip(local_ip):",
            "        LOG.error(\"Tunneling can't be enabled with invalid local_ip '%s'.\"",
            "                  \" IP couldn't be found on this host's interfaces.\",",
            "                  local_ip)",
            "        raise SystemExit(1)",
            "",
            "",
            "def validate_tunnel_config(tunnel_types, local_ip):",
            "    \"\"\"Verify local ip and tunnel config if tunneling is enabled.\"\"\"",
            "    if not tunnel_types:",
            "        return",
            "",
            "    validate_local_ip(local_ip)",
            "    for tun in tunnel_types:",
            "        if tun not in constants.TUNNEL_NETWORK_TYPES:",
            "            LOG.error('Invalid tunnel type specified: %s', tun)",
            "            raise SystemExit(1)",
            "",
            "",
            "def prepare_xen_compute():",
            "    is_xen_compute_host = 'rootwrap-xen-dom0' in cfg.CONF.AGENT.root_helper \\",
            "        or xenapi_root_helper.ROOT_HELPER_DAEMON_TOKEN == \\",
            "        cfg.CONF.AGENT.root_helper_daemon",
            "    if is_xen_compute_host:",
            "        xenapi_conf.register_xenapi_opts()",
            "        # Force ip_lib to always use the root helper to ensure that ip",
            "        # commands target xen dom0 rather than domU.",
            "        cfg.CONF.register_opts(ip_lib.OPTS)",
            "        cfg.CONF.set_default('ip_lib_force_root', True)",
            "",
            "",
            "def main(bridge_classes):",
            "    prepare_xen_compute()",
            "    ovs_capabilities.register()",
            "    ext_manager.register_opts(cfg.CONF)",
            "    agent_config.setup_privsep()",
            "    service_conf.register_service_opts(service_conf.RPC_EXTRA_OPTS, cfg.CONF)",
            "",
            "    ext_mgr = ext_manager.L2AgentExtensionsManager(cfg.CONF)",
            "",
            "    # now that all extensions registered their options, we can log them",
            "    n_utils.log_opt_values(LOG)",
            "",
            "    validate_tunnel_config(cfg.CONF.AGENT.tunnel_types, cfg.CONF.OVS.local_ip)",
            "",
            "    init_try = 1",
            "    while True:",
            "        try:",
            "            agent = OVSNeutronAgent(bridge_classes, ext_mgr, cfg.CONF)",
            "            capabilities.notify_init_event(n_const.AGENT_TYPE_OVS, agent)",
            "            break",
            "        except ovs_exceptions.TimeoutException as e:",
            "            if init_try < INIT_MAX_TRIES:",
            "                LOG.warning(\"Ovsdb command timeout!\")",
            "                init_try += 1",
            "            else:",
            "                LOG.error(\"%(err)s agent terminated after %(attempts)s \"",
            "                          \"initialization attempts!\",",
            "                          {'err': e, 'attempts': init_try})",
            "                sys.exit(1)",
            "        except (RuntimeError, ValueError) as e:",
            "            LOG.error(\"%s agent terminated!\", e)",
            "            sys.exit(1)",
            "    agent.daemon_loop()"
        ],
        "afterPatchFile": [
            "# Copyright 2011 VMware, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import collections",
            "import functools",
            "import hashlib",
            "import signal",
            "import sys",
            "import time",
            "",
            "import eventlet",
            "import netaddr",
            "from neutron_lib.agent import constants as agent_consts",
            "from neutron_lib.agent import topics",
            "from neutron_lib.api.definitions import portbindings",
            "from neutron_lib.api.definitions import provider_net",
            "from neutron_lib.callbacks import events as callback_events",
            "from neutron_lib.callbacks import registry",
            "from neutron_lib.callbacks import resources as callback_resources",
            "from neutron_lib import constants as n_const",
            "from neutron_lib import context",
            "from neutron_lib.placement import utils as place_utils",
            "from neutron_lib.plugins import utils as plugin_utils",
            "from neutron_lib.utils import helpers",
            "import os_vif",
            "from os_vif.objects import instance_info as vif_instance_object",
            "from os_vif.objects import network as vif_network_object",
            "from os_vif.objects import vif as vif_obj",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "import oslo_messaging",
            "from oslo_service import loopingcall",
            "from oslo_service import systemd",
            "from oslo_utils import netutils",
            "from osprofiler import profiler",
            "from ovsdbapp import exceptions as ovs_exceptions",
            "",
            "from neutron._i18n import _",
            "from neutron.agent.common import ip_lib",
            "from neutron.agent.common import ovs_lib",
            "from neutron.agent.common import polling",
            "from neutron.agent.common import utils",
            "from neutron.agent import firewall as agent_firewall",
            "from neutron.agent.l2 import l2_agent_extensions_manager as ext_manager",
            "from neutron.agent.linux import xenapi_root_helper",
            "from neutron.agent import rpc as agent_rpc",
            "from neutron.agent import securitygroups_rpc as agent_sg_rpc",
            "from neutron.api.rpc.callbacks import resources",
            "from neutron.api.rpc.handlers import dvr_rpc",
            "from neutron.api.rpc.handlers import securitygroups_rpc as sg_rpc",
            "from neutron.common import config",
            "from neutron.common import utils as n_utils",
            "from neutron.conf.agent import common as agent_config",
            "from neutron.conf.agent import xenapi_conf",
            "from neutron.conf import service as service_conf",
            "from neutron.plugins.ml2.drivers.agent import capabilities",
            "from neutron.plugins.ml2.drivers.l2pop.rpc_manager import l2population_rpc",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common \\",
            "    import constants",
            "from neutron.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_agent_extension_api as ovs_ext_api",
            "from neutron.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_capabilities",
            "from neutron.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_dvr_neutron_agent",
            "from neutron.plugins.ml2.drivers.openvswitch.agent import vlanmanager",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "cfg.CONF.import_group('AGENT', 'neutron.plugins.ml2.drivers.openvswitch.'",
            "                      'agent.common.config')",
            "cfg.CONF.import_group('OVS', 'neutron.plugins.ml2.drivers.openvswitch.agent.'",
            "                      'common.config')",
            "",
            "INIT_MAX_TRIES = 3",
            "",
            "",
            "class _mac_mydialect(netaddr.mac_unix):",
            "    word_fmt = '%.2x'",
            "",
            "",
            "class OVSPluginApi(agent_rpc.CacheBackedPluginApi):",
            "    pass",
            "",
            "",
            "class PortInfo(collections.UserDict):",
            "    def __init__(self, current=None, added=None, removed=None, updated=None,",
            "                 re_added=None):",
            "        _dict = {'current': current or set(),",
            "                 'added': added or set(),",
            "                 'removed': removed or set(),",
            "                 'updated': updated or set(),",
            "                 're_added': re_added or set()}",
            "        super(PortInfo, self).__init__(_dict)",
            "",
            "",
            "def has_zero_prefixlen_address(ip_addresses):",
            "    return any(netaddr.IPNetwork(ip).prefixlen == 0 for ip in ip_addresses)",
            "",
            "",
            "class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,",
            "                      dvr_rpc.DVRAgentRpcCallbackMixin):",
            "    '''Implements OVS-based tunneling, VLANs and flat networks.",
            "",
            "    Two local bridges are created: an integration bridge (defaults to",
            "    'br-int') and a tunneling bridge (defaults to 'br-tun'). An",
            "    additional bridge is created for each physical network interface",
            "    used for VLANs and/or flat networks.",
            "",
            "    All VM VIFs are plugged into the integration bridge. VM VIFs on a",
            "    given virtual network share a common \"local\" VLAN (i.e. not",
            "    propagated externally). The VLAN id of this local VLAN is mapped",
            "    to the physical networking details realizing that virtual network.",
            "",
            "    For virtual networks realized as GRE tunnels, a Logical Switch",
            "    (LS) identifier is used to differentiate tenant traffic on",
            "    inter-HV tunnels. A mesh of tunnels is created to other",
            "    Hypervisors in the cloud. These tunnels originate and terminate on",
            "    the tunneling bridge of each hypervisor. Port patching is done to",
            "    connect local VLANs on the integration bridge to inter-hypervisor",
            "    tunnels on the tunnel bridge.",
            "",
            "    For each virtual network realized as a VLAN or flat network, a",
            "    veth or a pair of patch ports is used to connect the local VLAN on",
            "    the integration bridge with the physical network bridge, with flow",
            "    rules adding, modifying, or stripping VLAN tags as necessary.",
            "    '''",
            "",
            "    # history",
            "    #   1.0 Initial version",
            "    #   1.1 Support Security Group RPC",
            "    #   1.2 Support DVR (Distributed Virtual Router) RPC",
            "    #   1.3 Added param devices_to_update to security_groups_provider_updated",
            "    #   1.4 Added support for network_update",
            "    #   1.5 Added binding_activate and binding_deactivate",
            "    #   1.7 Add support for smartnic ports",
            "    target = oslo_messaging.Target(version='1.7')",
            "",
            "    def __init__(self, bridge_classes, ext_manager, conf=None):",
            "        '''Constructor.",
            "",
            "        :param bridge_classes: a dict for bridge classes.",
            "        :param conf: an instance of ConfigOpts",
            "        '''",
            "        super(OVSNeutronAgent, self).__init__()",
            "        self.conf = conf or cfg.CONF",
            "        self.ovs = ovs_lib.BaseOVS()",
            "        self.ext_manager = ext_manager",
            "        agent_conf = self.conf.AGENT",
            "        ovs_conf = self.conf.OVS",
            "",
            "        self.fullsync = False",
            "        # init bridge classes with configured datapath type.",
            "        self.br_int_cls, self.br_phys_cls, self.br_tun_cls = (",
            "            functools.partial(bridge_classes[b],",
            "                              datapath_type=ovs_conf.datapath_type)",
            "            for b in ('br_int', 'br_phys', 'br_tun'))",
            "",
            "        self.use_veth_interconnection = ovs_conf.use_veth_interconnection",
            "        if self.use_veth_interconnection:",
            "            LOG.warning(\"Usage of veth instead of patch ports for bridges \"",
            "                        \"interconnection is deprecated in Victoria and will \"",
            "                        \"be removed in W release. Please use patch ports \"",
            "                        \"instead.\")",
            "        self.veth_mtu = agent_conf.veth_mtu",
            "        self.available_local_vlans = set(range(n_const.MIN_VLAN_TAG,",
            "                                               n_const.MAX_VLAN_TAG + 1))",
            "        self.tunnel_types = agent_conf.tunnel_types or []",
            "        self.enable_tunneling = bool(self.tunnel_types)",
            "        self.l2_pop = agent_conf.l2_population",
            "        # TODO(ethuleau): Change ARP responder so it's not dependent on the",
            "        #                 ML2 l2 population mechanism driver.",
            "        self.enable_distributed_routing = agent_conf.enable_distributed_routing",
            "        self.arp_responder_enabled = agent_conf.arp_responder and self.l2_pop",
            "        if (self.enable_distributed_routing and self.enable_tunneling and",
            "                not self.arp_responder_enabled):",
            "            LOG.warning(\"ARP responder was not enabled but is required since \"",
            "                        \"DVR and tunneling are enabled, setting to True.\")",
            "            self.arp_responder_enabled = True",
            "",
            "        host = self.conf.host",
            "        self.agent_id = 'ovs-agent-%s' % host",
            "",
            "        # Validate agent configurations",
            "        self._check_agent_configurations()",
            "",
            "        # Keep track of int_br's device count for use by _report_state()",
            "        self.int_br_device_count = 0",
            "",
            "        self.int_br = self.br_int_cls(ovs_conf.integration_bridge)",
            "        self.setup_integration_br()",
            "        # Stores port update notifications for processing in main rpc loop",
            "        self.updated_ports = set()",
            "        # Stores port delete notifications",
            "        self.deleted_ports = set()",
            "        # Stores the port IDs whose binding has been deactivated",
            "        self.deactivated_bindings = set()",
            "        # Stores the port IDs whose binding has been activated",
            "        self.activated_bindings = set()",
            "        # Stores smartnic ports update/remove",
            "        self.updated_smartnic_ports = list()",
            "        # Stores integration bridge smartnic ports data",
            "        self.current_smartnic_ports_map = {}",
            "",
            "        self.network_ports = collections.defaultdict(set)",
            "        # keeps association between ports and ofports to detect ofport change",
            "        self.vifname_to_ofport_map = {}",
            "        # Stores newly created bridges",
            "        self.added_bridges = list()",
            "        self.bridge_mappings = self._parse_bridge_mappings(",
            "            ovs_conf.bridge_mappings)",
            "        self.rp_bandwidths = place_utils.parse_rp_bandwidths(",
            "            ovs_conf.resource_provider_bandwidths)",
            "",
            "        br_set = set(self.bridge_mappings.values())",
            "        n_utils.validate_rp_bandwidth(self.rp_bandwidths,",
            "                                      br_set)",
            "        self.rp_inventory_defaults = place_utils.parse_rp_inventory_defaults(",
            "            ovs_conf.resource_provider_inventory_defaults)",
            "        self.rp_hypervisors = utils.default_rp_hypervisors(",
            "            ovs_conf.resource_provider_hypervisors,",
            "            {k: [v] for k, v in self.bridge_mappings.items()}",
            "        )",
            "",
            "        self.setup_physical_bridges(self.bridge_mappings)",
            "        self.vlan_manager = vlanmanager.LocalVlanManager()",
            "",
            "        self._reset_tunnel_ofports()",
            "",
            "        self.polling_interval = agent_conf.polling_interval",
            "        self.minimize_polling = agent_conf.minimize_polling",
            "        self.ovsdb_monitor_respawn_interval = (",
            "            agent_conf.ovsdb_monitor_respawn_interval or",
            "            constants.DEFAULT_OVSDBMON_RESPAWN)",
            "        self.local_ip = ovs_conf.local_ip",
            "        self.tunnel_count = 0",
            "        self.vxlan_udp_port = agent_conf.vxlan_udp_port",
            "        self.dont_fragment = agent_conf.dont_fragment",
            "        self.tunnel_csum = agent_conf.tunnel_csum",
            "        self.tos = ('inherit'",
            "                    if agent_conf.dscp_inherit",
            "                    else (int(agent_conf.dscp) << 2",
            "                          if agent_conf.dscp",
            "                          else None))",
            "        self.tun_br = None",
            "        self.patch_int_ofport = constants.OFPORT_INVALID",
            "        self.patch_tun_ofport = constants.OFPORT_INVALID",
            "        if self.enable_tunneling:",
            "            # The patch_int_ofport and patch_tun_ofport are updated",
            "            # here inside the call to setup_tunnel_br()",
            "            self.setup_tunnel_br(ovs_conf.tunnel_bridge)",
            "            self.setup_tunnel_br_flows()",
            "",
            "        self.setup_rpc()",
            "",
            "        self.dvr_agent = ovs_dvr_neutron_agent.OVSDVRNeutronAgent(",
            "            self.context,",
            "            self.dvr_plugin_rpc,",
            "            self.int_br,",
            "            self.tun_br,",
            "            self.bridge_mappings,",
            "            self.phys_brs,",
            "            self.int_ofports,",
            "            self.phys_ofports,",
            "            self.patch_int_ofport,",
            "            self.patch_tun_ofport,",
            "            host,",
            "            self.enable_tunneling,",
            "            self.enable_distributed_routing)",
            "",
            "        if self.enable_distributed_routing:",
            "            self.dvr_agent.setup_dvr_flows()",
            "",
            "        # Collect additional bridges to monitor",
            "        self.ancillary_brs = self.setup_ancillary_bridges(",
            "            ovs_conf.integration_bridge, ovs_conf.tunnel_bridge)",
            "",
            "        agent_api = ovs_ext_api.OVSAgentExtensionAPI(self.int_br,",
            "                                                     self.tun_br,",
            "                                                     self.phys_brs)",
            "        self.ext_manager.initialize(",
            "            self.connection, constants.EXTENSION_DRIVER_TYPE, agent_api)",
            "",
            "        # In order to keep existed device's local vlan unchanged,",
            "        # restore local vlan mapping at start",
            "        self._restore_local_vlan_map()",
            "",
            "        # Security group agent support",
            "        self.sg_agent = agent_sg_rpc.SecurityGroupAgentRpc(",
            "            self.context, self.sg_plugin_rpc, defer_refresh_firewall=True,",
            "            integration_bridge=self.int_br)",
            "        self.sg_plugin_rpc.register_legacy_sg_notification_callbacks(",
            "            self.sg_agent)",
            "",
            "        self.sg_agent.init_ovs_dvr_firewall(self.dvr_agent)",
            "",
            "        # we default to False to provide backward compat with out of tree",
            "        # firewall drivers that expect the logic that existed on the Neutron",
            "        # server which only enabled hybrid plugging based on the use of the",
            "        # hybrid driver.",
            "        hybrid_plug = getattr(self.sg_agent.firewall,",
            "                              'OVS_HYBRID_PLUG_REQUIRED', False)",
            "        self.prevent_arp_spoofing = (",
            "            not self.sg_agent.firewall.provides_arp_spoofing_protection)",
            "",
            "        self.failed_report_state = False",
            "        # TODO(mangelajo): optimize resource_versions to only report",
            "        #                  versions about resources which are common,",
            "        #                  or which are used by specific extensions.",
            "        self.agent_state = {",
            "            'binary': n_const.AGENT_PROCESS_OVS,",
            "            'host': host,",
            "            'topic': n_const.L2_AGENT_TOPIC,",
            "            'configurations': {'bridge_mappings': self.bridge_mappings,",
            "                               n_const.RP_BANDWIDTHS: self.rp_bandwidths,",
            "                               n_const.RP_INVENTORY_DEFAULTS:",
            "                                   self.rp_inventory_defaults,",
            "                               'resource_provider_hypervisors':",
            "                               self.rp_hypervisors,",
            "                               'integration_bridge':",
            "                               ovs_conf.integration_bridge,",
            "                               'tunnel_types': self.tunnel_types,",
            "                               'tunneling_ip': self.local_ip,",
            "                               'l2_population': self.l2_pop,",
            "                               'arp_responder_enabled':",
            "                               self.arp_responder_enabled,",
            "                               'enable_distributed_routing':",
            "                               self.enable_distributed_routing,",
            "                               'log_agent_heartbeats':",
            "                               agent_conf.log_agent_heartbeats,",
            "                               'extensions': self.ext_manager.names(),",
            "                               'datapath_type': ovs_conf.datapath_type,",
            "                               'ovs_capabilities': self.ovs.capabilities,",
            "                               'vhostuser_socket_dir':",
            "                               ovs_conf.vhostuser_socket_dir,",
            "                               portbindings.OVS_HYBRID_PLUG: hybrid_plug,",
            "                               'baremetal_smartnic':",
            "                               self.conf.AGENT.baremetal_smartnic},",
            "            'resource_versions': resources.LOCAL_RESOURCE_VERSIONS,",
            "            'agent_type': n_const.AGENT_TYPE_OVS,",
            "            'start_flag': True}",
            "",
            "        report_interval = agent_conf.report_interval",
            "        if report_interval:",
            "            heartbeat = loopingcall.FixedIntervalLoopingCall(",
            "                self._report_state)",
            "            heartbeat.start(interval=report_interval)",
            "        # Initialize iteration counter",
            "        self.iter_num = 0",
            "        self.run_daemon_loop = True",
            "",
            "        self.catch_sigterm = False",
            "        self.catch_sighup = False",
            "",
            "        if self.conf.AGENT.baremetal_smartnic:",
            "            os_vif.initialize()",
            "",
            "        # The initialization is complete; we can start receiving messages",
            "        self.connection.consume_in_threads()",
            "",
            "        self.quitting_rpc_timeout = agent_conf.quitting_rpc_timeout",
            "",
            "    def _parse_bridge_mappings(self, bridge_mappings):",
            "        try:",
            "            return helpers.parse_mappings(bridge_mappings)",
            "        except ValueError as e:",
            "            raise ValueError(_(\"Parsing bridge_mappings failed: %s.\") % e)",
            "",
            "    def _report_state(self):",
            "        # How many devices are likely used by a VM",
            "        self.agent_state.get('configurations')['devices'] = (",
            "            self.int_br_device_count)",
            "        self.agent_state.get('configurations')['in_distributed_mode'] = (",
            "            self.dvr_agent.in_distributed_mode())",
            "",
            "        try:",
            "            agent_status = self.state_rpc.report_state(self.context,",
            "                                                       self.agent_state,",
            "                                                       True)",
            "            if agent_status == agent_consts.AGENT_REVIVED:",
            "                LOG.info('Agent has just been revived. '",
            "                         'Doing a full sync.')",
            "                self.fullsync = True",
            "",
            "            # we only want to update resource versions on startup",
            "            if self.agent_state.pop('resource_versions', None):",
            "                # On initial start, we notify systemd after initialization",
            "                # is complete.",
            "                systemd.notify_once()",
            "",
            "            if self.iter_num > 0:",
            "                # agent is considered started after",
            "                # initial sync with server (iter 0) is done",
            "                self.agent_state.pop('start_flag', None)",
            "",
            "        except Exception:",
            "            self.failed_report_state = True",
            "            LOG.exception(\"Failed reporting state!\")",
            "            return",
            "        if self.failed_report_state:",
            "            self.failed_report_state = False",
            "            LOG.info(\"Successfully reported state after a previous failure.\")",
            "",
            "    def _restore_local_vlan_map(self):",
            "        self._local_vlan_hints = {}",
            "        # skip INVALID and UNASSIGNED to match scan_ports behavior",
            "        ofport_filter = (ovs_lib.INVALID_OFPORT, ovs_lib.UNASSIGNED_OFPORT)",
            "        cur_ports = self.int_br.get_vif_ports(ofport_filter)",
            "        port_names = [p.port_name for p in cur_ports]",
            "        port_info = self.int_br.get_ports_attributes(",
            "            \"Port\", columns=[\"name\", \"other_config\", \"tag\"], ports=port_names)",
            "        by_name = {x['name']: x for x in port_info}",
            "        for port in cur_ports:",
            "            # if a port was deleted between get_vif_ports and",
            "            # get_ports_attributes, we",
            "            # will get a KeyError",
            "            try:",
            "                local_vlan_map = by_name[port.port_name]['other_config']",
            "                local_vlan = by_name[port.port_name]['tag']",
            "            except KeyError:",
            "                continue",
            "            if not local_vlan:",
            "                continue",
            "            net_uuid = local_vlan_map.get('net_uuid')",
            "            if (net_uuid and net_uuid not in self._local_vlan_hints and",
            "                    local_vlan != constants.DEAD_VLAN_TAG):",
            "                self.available_local_vlans.remove(local_vlan)",
            "                self._local_vlan_hints[local_vlan_map['net_uuid']] = local_vlan",
            "",
            "    def _dispose_local_vlan_hints(self):",
            "        self.available_local_vlans.update(self._local_vlan_hints.values())",
            "        self._local_vlan_hints = {}",
            "",
            "    def _reset_tunnel_ofports(self):",
            "        self.tun_br_ofports = {n_const.TYPE_GENEVE: {},",
            "                               n_const.TYPE_GRE: {},",
            "                               n_const.TYPE_VXLAN: {}}",
            "",
            "    def _update_network_segmentation_id(self, network):",
            "        if network.get(provider_net.NETWORK_TYPE) != n_const.TYPE_VLAN:",
            "            return",
            "",
            "        try:",
            "            lvm = self.vlan_manager.get(network['id'])",
            "        except vlanmanager.MappingNotFound:",
            "            return",
            "",
            "        segmentation_id_old = lvm.segmentation_id",
            "        if segmentation_id_old == network[provider_net.SEGMENTATION_ID]:",
            "            return",
            "        self.vlan_manager.update_segmentation_id(",
            "            network['id'], network[provider_net.SEGMENTATION_ID])",
            "",
            "        lvid = lvm.vlan",
            "        physical_network = network[provider_net.PHYSICAL_NETWORK]",
            "        phys_br = self.phys_brs[physical_network]",
            "        phys_port = self.phys_ofports[physical_network]",
            "        int_port = self.int_ofports[physical_network]",
            "        phys_br.reclaim_local_vlan(port=phys_port, lvid=lvid)",
            "        phys_br.provision_local_vlan(",
            "            port=phys_port, lvid=lvid,",
            "            segmentation_id=network[provider_net.SEGMENTATION_ID],",
            "            distributed=self.enable_distributed_routing)",
            "        self.int_br.reclaim_local_vlan(port=int_port,",
            "                                       segmentation_id=segmentation_id_old)",
            "        self.int_br.provision_local_vlan(",
            "            port=int_port, lvid=lvid,",
            "            segmentation_id=network[provider_net.SEGMENTATION_ID])",
            "",
            "    def setup_rpc(self):",
            "        self.plugin_rpc = OVSPluginApi(topics.PLUGIN)",
            "        # allow us to receive port_update/delete callbacks from the cache",
            "        self.plugin_rpc.register_legacy_notification_callbacks(self)",
            "        self.sg_plugin_rpc = sg_rpc.SecurityGroupServerAPIShim(",
            "            self.plugin_rpc.remote_resource_cache)",
            "        self.dvr_plugin_rpc = dvr_rpc.DVRServerRpcApi(topics.PLUGIN)",
            "        self.state_rpc = agent_rpc.PluginReportStateAPI(topics.REPORTS)",
            "",
            "        # RPC network init",
            "        self.context = context.get_admin_context_without_session()",
            "        # Made a simple RPC call to Neutron Server.",
            "        while True:",
            "            try:",
            "                self.state_rpc.has_alive_neutron_server(self.context)",
            "            except oslo_messaging.MessagingTimeout as e:",
            "                LOG.warning('l2-agent cannot contact neutron server. '",
            "                            'Check connectivity to neutron server. '",
            "                            'Retrying... '",
            "                            'Detailed message: %(msg)s.', {'msg': e})",
            "                continue",
            "            break",
            "",
            "        # Define the listening consumers for the agent",
            "        consumers = [[constants.TUNNEL, topics.UPDATE],",
            "                     [constants.TUNNEL, topics.DELETE],",
            "                     [topics.DVR, topics.UPDATE]]",
            "        if self.l2_pop:",
            "            consumers.append([topics.L2POPULATION, topics.UPDATE])",
            "        self.connection = agent_rpc.create_consumers([self],",
            "                                                     topics.AGENT,",
            "                                                     consumers,",
            "                                                     start_listening=False)",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def port_update(self, context, **kwargs):",
            "        port = kwargs.get('port')",
            "        agent_restarted = kwargs.pop(\"agent_restarted\", False)",
            "        # Put the port identifier in the updated_ports set.",
            "        # Even if full port details might be provided to this call,",
            "        # they are not used since there is no guarantee the notifications",
            "        # are processed in the same order as the relevant API requests",
            "        if not agent_restarted:",
            "            # When ovs-agent is just restarted, the first RPC loop will",
            "            # process all the port as 'added'. And all of these ports will",
            "            # send a port_update notification after that processing. This",
            "            # will cause all these ports to be processed again in next RPC",
            "            # loop as 'updated'. So here we just ignore such local update",
            "            # notification.",
            "            self.updated_ports.add(port['id'])",
            "",
            "        if not self.conf.AGENT.baremetal_smartnic:",
            "            return",
            "        # In case of smart-nic port, add smart-nic representor port to",
            "        # the integration bridge.",
            "        port_data = (self.plugin_rpc.remote_resource_cache",
            "                     .get_resource_by_id(resources.PORT, port['id']))",
            "        if not port_data:",
            "            LOG.warning('Failed to get port details, port id: %s', port['id'])",
            "            return",
            "        for port_binding in port_data.get('bindings', []):",
            "            if port_binding['vnic_type'] == portbindings.VNIC_SMARTNIC:",
            "                if port_binding['host'] == self.conf.host:",
            "                    local_link = (port_binding['profile']",
            "                                  ['local_link_information'])",
            "                    if local_link:",
            "                        self._add_port_to_updated_smartnic_ports(",
            "                            port_data['mac_address'],",
            "                            local_link[0]['port_id'],",
            "                            port_data['id'],",
            "                            port_binding['vif_type'],",
            "                            port_data['device_id'])",
            "                elif (not port_binding['host'] and port_binding['vif_type'] ==",
            "                      portbindings.VIF_TYPE_UNBOUND and port['id'] in",
            "                      self.current_smartnic_ports_map.keys()):",
            "                    smartnic_port = self.current_smartnic_ports_map[",
            "                        port['id']]",
            "                    self._add_port_to_updated_smartnic_ports(",
            "                        smartnic_port['vif_mac'], smartnic_port['vif_name'],",
            "                        port['id'], portbindings.VIF_TYPE_UNBOUND)",
            "",
            "                else:",
            "                    # The port doesn't belong to this Smart NIC,",
            "                    # the reason for this could be multi Smart NIC",
            "                    # setup.",
            "                    LOG.info(\"Smart NIC port %(port_id)s does not belong \"",
            "                             \"to host %(host)s\",",
            "                             {'port_id': port['id'],",
            "                              'host': self.conf.host})",
            "",
            "    def treat_smartnic_port(self, smartnic_port_data):",
            "        mac = smartnic_port_data['mac']",
            "        vm_uuid = smartnic_port_data['vm_uuid']",
            "        rep_port = smartnic_port_data['vif_name']",
            "        iface_id = smartnic_port_data['iface_id']",
            "        vif_type = smartnic_port_data['vif_type']",
            "",
            "        instance_info = vif_instance_object.InstanceInfo(uuid=vm_uuid)",
            "        vif = self._get_vif_object(iface_id, rep_port, mac)",
            "        try:",
            "            if vif_type == portbindings.VIF_TYPE_OVS:",
            "                os_vif.plug(vif, instance_info)",
            "                self.current_smartnic_ports_map[iface_id] = (",
            "                    self.create_smartnic_port_map_entry_data(mac, rep_port))",
            "",
            "            elif vif_type == portbindings.VIF_TYPE_UNBOUND:",
            "                os_vif.unplug(vif, instance_info)",
            "                self.current_smartnic_ports_map.pop(iface_id, None)",
            "",
            "            else:",
            "                LOG.error(\"Unexpected vif_type:%(vif_type)s for \"",
            "                          \"%(vnic_type)s port:%(port_id)s\",",
            "                          {'vnic_type': portbindings.VNIC_SMARTNIC,",
            "                           'vif_type': vif_type,",
            "                           'port_id': iface_id})",
            "",
            "        except Exception as e:",
            "            LOG.error(\"Failed to treat %(vnic_type)s port:%(port_id)s , \"",
            "                      \"error:%(error)s\",",
            "                      {'vnic_type': portbindings.VNIC_SMARTNIC,",
            "                       'port_id': iface_id,",
            "                       'error': e})",
            "",
            "    def _get_vif_object(self, iface_id, rep_port, mac):",
            "        network = vif_network_object.Network(",
            "            bridge=self.conf.OVS.integration_bridge)",
            "        port_profile = vif_obj.VIFPortProfileOpenVSwitch(",
            "            interface_id=iface_id, create_port=True)",
            "        return vif_obj.VIFOpenVSwitch(",
            "            vif_name=rep_port, plugin='ovs', port_profile=port_profile,",
            "            network=network, address=str(mac))",
            "",
            "    def _add_port_to_updated_smartnic_ports(self, mac, vif_name, iface_id,",
            "                                            vif_type, vm_uuid=''):",
            "        self.updated_smartnic_ports.append({",
            "            'mac': mac,",
            "            'vm_uuid': vm_uuid,",
            "            'vif_name': vif_name,",
            "            'iface_id': iface_id,",
            "            'vif_type': vif_type})",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def port_delete(self, context, **kwargs):",
            "        port_id = kwargs.get('port_id')",
            "        self.deleted_ports.add(port_id)",
            "        self.updated_ports.discard(port_id)",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def network_update(self, context, **kwargs):",
            "        network_id = kwargs['network']['id']",
            "        network = self.plugin_rpc.get_network_details(",
            "            self.context, network_id, self.agent_id, self.conf.host)",
            "        self._update_network_segmentation_id(network)",
            "        for port_id in self.network_ports[network_id]:",
            "            # notifications could arrive out of order, if the port is deleted",
            "            # we don't want to update it anymore",
            "            if port_id not in self.deleted_ports:",
            "                self.updated_ports.add(port_id)",
            "        LOG.debug(\"network_update message processed for network \"",
            "                  \"%(network_id)s, with ports: %(ports)s\",",
            "                  {'network_id': network_id,",
            "                   'ports': self.network_ports[network_id]})",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def binding_deactivate(self, context, **kwargs):",
            "        if kwargs.get('host') != self.conf.host:",
            "            return",
            "        port_id = kwargs.get('port_id')",
            "        self.deactivated_bindings.add(port_id)",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def binding_activate(self, context, **kwargs):",
            "        if kwargs.get('host') != self.conf.host:",
            "            return",
            "        port_id = kwargs.get('port_id')",
            "        self.activated_bindings.add(port_id)",
            "",
            "    def _clean_network_ports(self, port_id):",
            "        for port_set in self.network_ports.values():",
            "            if port_id in port_set:",
            "                port_set.remove(port_id)",
            "                break",
            "",
            "    def _get_port_local_vlan(self, port_id):",
            "        for network_id, port_set in self.network_ports.items():",
            "            if port_id in port_set:",
            "                lvm = self.vlan_manager.get(network_id)",
            "                return lvm.vlan",
            "",
            "    def process_deleted_ports(self, port_info):",
            "        # don't try to process removed ports as deleted ports since",
            "        # they are already gone",
            "        if 'removed' in port_info:",
            "            self.deleted_ports -= port_info['removed']",
            "        deleted_ports = list(self.deleted_ports)",
            "",
            "        with self.int_br.deferred(full_ordered=True,",
            "                                  use_bundle=True) as int_br:",
            "            while self.deleted_ports:",
            "                port_id = self.deleted_ports.pop()",
            "                port = self.int_br.get_vif_port_by_id(port_id)",
            "",
            "                if (isinstance(self.sg_agent.firewall,",
            "                               agent_firewall.NoopFirewallDriver) or",
            "                        not agent_sg_rpc.is_firewall_enabled()):",
            "                    try:",
            "                        self.delete_accepted_egress_direct_flow(",
            "                            int_br,",
            "                            port.ofport,",
            "                            port.mac, self._get_port_local_vlan(port_id))",
            "                    except Exception as err:",
            "                        LOG.debug(\"Failed to remove accepted egress flows \"",
            "                                  \"for port %s, error: %s\", port_id, err)",
            "",
            "                self._clean_network_ports(port_id)",
            "                self.ext_manager.delete_port(self.context,",
            "                                             {\"vif_port\": port,",
            "                                              \"port_id\": port_id})",
            "                # move to dead VLAN so deleted ports no",
            "                # longer have access to the network",
            "                if port:",
            "                    # don't log errors since there is a chance someone will be",
            "                    # removing the port from the bridge at the same time",
            "                    self.port_dead(port, log_errors=False)",
            "                self.port_unbound(port_id)",
            "",
            "        # Flush firewall rules after ports are put on dead VLAN to be",
            "        # more secure",
            "        self.sg_agent.remove_devices_filter(deleted_ports)",
            "",
            "    def create_smartnic_port_map_entry_data(self, vif_mac, vif_name):",
            "        return {\"vif_mac\": vif_mac, \"vif_name\": vif_name}",
            "",
            "    def process_smartnic_ports(self):",
            "        smartnic_ports = self.plugin_rpc.get_ports_by_vnic_type_and_host(",
            "            self.context, portbindings.VNIC_SMARTNIC, self.conf.host)",
            "        smartnic_ports_map = {smartnic_port['id']: smartnic_port",
            "                              for smartnic_port in smartnic_ports}",
            "        smartnic_port_ids = set(smartnic_ports_map.keys())",
            "",
            "        ofport_filter = (ovs_lib.INVALID_OFPORT, ovs_lib.UNASSIGNED_OFPORT)",
            "        cur_smartnic_ports = self.int_br.get_vif_ports(ofport_filter)",
            "        self.current_smartnic_ports_map = {",
            "            port.vif_id: self.create_smartnic_port_map_entry_data(",
            "                port.vif_mac, port.port_name) for port in cur_smartnic_ports}",
            "        cur_smartnic_port_ids = set(self.current_smartnic_ports_map.keys())",
            "",
            "        removed_ports = [{'vif_id': vif_id, **self.current_smartnic_ports_map[",
            "            vif_id]} for vif_id in cur_smartnic_port_ids - smartnic_port_ids]",
            "        added_ports = [smartnic_ports_map[port_id] for port_id in",
            "                       smartnic_port_ids - cur_smartnic_port_ids]",
            "",
            "        def _process_added_ports(smartnic_added_ports):",
            "            for smartnic_port in smartnic_added_ports:",
            "                local_link = (smartnic_port['binding:profile']",
            "                              ['local_link_information'])",
            "                if local_link:",
            "                    self._add_port_to_updated_smartnic_ports(",
            "                        smartnic_port['mac_address'],",
            "                        local_link[0]['port_id'],",
            "                        smartnic_port['id'],",
            "                        smartnic_port['binding:vif_type'],",
            "                        smartnic_port['device_id'])",
            "",
            "        def _process_removed_ports(removed_ports):",
            "            for ovs_port in removed_ports:",
            "                self._add_port_to_updated_smartnic_ports(",
            "                        ovs_port['vif_mac'],",
            "                        ovs_port['vif_name'],",
            "                        ovs_port['vif_id'],",
            "                        portbindings.VIF_TYPE_UNBOUND)",
            "",
            "        _process_removed_ports(removed_ports)",
            "        _process_added_ports(added_ports)",
            "",
            "    def process_deactivated_bindings(self, port_info):",
            "        # don't try to deactivate bindings for removed ports since they are",
            "        # already gone",
            "        if 'removed' in port_info:",
            "            self.deactivated_bindings -= port_info['removed']",
            "        while self.deactivated_bindings:",
            "            port_id = self.deactivated_bindings.pop()",
            "            port = self.int_br.get_vif_port_by_id(port_id)",
            "            if not port:",
            "                continue",
            "            self.int_br.delete_port(port.port_name)",
            "            LOG.debug((\"Port id %s unplugged from integration bridge because \"",
            "                       \"its binding was de-activated\"), port_id)",
            "",
            "    def process_activated_bindings(self, port_info, activated_bindings_copy):",
            "        # Compute which ports for activated bindings are still present...",
            "        activated_bindings_copy &= port_info['current']",
            "        # ...and treat them as just added",
            "        port_info['added'] |= activated_bindings_copy",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def tunnel_update(self, context, **kwargs):",
            "        LOG.debug(\"tunnel_update received\")",
            "        if not self.enable_tunneling:",
            "            return",
            "        tunnel_ip = kwargs.get('tunnel_ip')",
            "        tunnel_type = kwargs.get('tunnel_type')",
            "        if not tunnel_type:",
            "            LOG.error(\"No tunnel_type specified, cannot create tunnels\")",
            "            return",
            "        if tunnel_type not in self.tunnel_types:",
            "            LOG.error(\"tunnel_type %s not supported by agent\",",
            "                      tunnel_type)",
            "            return",
            "        if tunnel_ip == self.local_ip:",
            "            return",
            "        tun_name = self.get_tunnel_name(tunnel_type, self.local_ip, tunnel_ip)",
            "        if tun_name is None:",
            "            return",
            "        if not self.l2_pop:",
            "            self._setup_tunnel_port(self.tun_br, tun_name, tunnel_ip,",
            "                                    tunnel_type)",
            "            self._setup_tunnel_flood_flow(self.tun_br, tunnel_type)",
            "",
            "    @profiler.trace(\"rpc\")",
            "    def tunnel_delete(self, context, **kwargs):",
            "        LOG.debug(\"tunnel_delete received\")",
            "        if not self.enable_tunneling:",
            "            return",
            "        tunnel_ip = kwargs.get('tunnel_ip')",
            "        if not tunnel_ip:",
            "            LOG.error(\"No tunnel_ip specified, cannot delete tunnels\")",
            "            return",
            "        tunnel_type = kwargs.get('tunnel_type')",
            "        if not tunnel_type:",
            "            LOG.error(\"No tunnel_type specified, cannot delete tunnels\")",
            "            return",
            "        if tunnel_type not in self.tunnel_types:",
            "            LOG.error(\"tunnel_type %s not supported by agent\",",
            "                      tunnel_type)",
            "            return",
            "        ofport = self.tun_br_ofports[tunnel_type].get(tunnel_ip)",
            "        self.cleanup_tunnel_port(self.tun_br, ofport, tunnel_type)",
            "",
            "    def _tunnel_port_lookup(self, network_type, remote_ip):",
            "        return self.tun_br_ofports[network_type].get(remote_ip)",
            "",
            "    def fdb_add(self, context, fdb_entries):",
            "        LOG.debug(\"fdb_add received\")",
            "        for lvm, agent_ports in self.get_agent_ports(fdb_entries):",
            "            agent_ports.pop(self.local_ip, None)",
            "            if len(agent_ports):",
            "                self.fdb_add_tun(context, self.tun_br, lvm,",
            "                                 agent_ports, self._tunnel_port_lookup)",
            "",
            "    def fdb_remove(self, context, fdb_entries):",
            "        LOG.debug(\"fdb_remove received\")",
            "        for lvm, agent_ports in self.get_agent_ports(fdb_entries):",
            "            agent_ports.pop(self.local_ip, None)",
            "            if len(agent_ports):",
            "                self.fdb_remove_tun(context, self.tun_br, lvm,",
            "                                    agent_ports,",
            "                                    self._tunnel_port_lookup)",
            "",
            "    def add_fdb_flow(self, br, port_info, remote_ip, lvm, ofport):",
            "        if port_info == n_const.FLOODING_ENTRY:",
            "            lvm.tun_ofports.add(ofport)",
            "            br.install_flood_to_tun(lvm.vlan, lvm.segmentation_id,",
            "                                    lvm.tun_ofports)",
            "        else:",
            "            self.setup_entry_for_arp_reply(br, 'add', lvm.vlan,",
            "                                           port_info.mac_address,",
            "                                           port_info.ip_address)",
            "            br.install_unicast_to_tun(lvm.vlan,",
            "                                      lvm.segmentation_id,",
            "                                      ofport,",
            "                                      port_info.mac_address)",
            "",
            "    def del_fdb_flow(self, br, port_info, remote_ip, lvm, ofport):",
            "        if port_info == n_const.FLOODING_ENTRY:",
            "            if ofport not in lvm.tun_ofports:",
            "                LOG.debug(\"attempt to remove a non-existent port %s\", ofport)",
            "                return",
            "            lvm.tun_ofports.remove(ofport)",
            "            if len(lvm.tun_ofports) > 0:",
            "                br.install_flood_to_tun(lvm.vlan, lvm.segmentation_id,",
            "                                        lvm.tun_ofports)",
            "            else:",
            "                # This local vlan doesn't require any more tunneling",
            "                br.delete_flood_to_tun(lvm.vlan)",
            "        else:",
            "            self.setup_entry_for_arp_reply(br, 'remove', lvm.vlan,",
            "                                           port_info.mac_address,",
            "                                           port_info.ip_address)",
            "            br.delete_unicast_to_tun(lvm.vlan, port_info.mac_address)",
            "",
            "    def _fdb_chg_ip(self, context, fdb_entries):",
            "        LOG.debug(\"update chg_ip received\")",
            "        self.fdb_chg_ip_tun(context, self.tun_br, fdb_entries, self.local_ip)",
            "",
            "    def setup_entry_for_arp_reply(self, br, action, local_vid, mac_address,",
            "                                  ip_address):",
            "        '''Set the ARP respond entry.",
            "",
            "        When the l2 population mechanism driver and OVS supports to edit ARP",
            "        fields, a table (ARP_RESPONDER) to resolve ARP locally is added to the",
            "        tunnel bridge.",
            "        '''",
            "        if not self.arp_responder_enabled:",
            "            return",
            "",
            "        ip = netaddr.IPAddress(ip_address)",
            "        if ip.version == 6:",
            "            return",
            "",
            "        ip = str(ip)",
            "        mac = str(netaddr.EUI(mac_address, dialect=_mac_mydialect))",
            "",
            "        if action == 'add':",
            "            br.install_arp_responder(local_vid, ip, mac)",
            "        elif action == 'remove':",
            "            br.delete_arp_responder(local_vid, ip)",
            "        else:",
            "            LOG.warning('Action %s not supported', action)",
            "",
            "    def _local_vlan_for_physical(self, lvid, physical_network,",
            "                                 segmentation_id=None):",
            "        distributed = self.enable_distributed_routing",
            "        phys_br = self.phys_brs[physical_network]",
            "        phys_port = self.phys_ofports[physical_network]",
            "        int_br = self.int_br",
            "        int_port = self.int_ofports[physical_network]",
            "        phys_br.provision_local_vlan(port=phys_port, lvid=lvid,",
            "                                     segmentation_id=segmentation_id,",
            "                                     distributed=distributed)",
            "        int_br.provision_local_vlan(port=int_port, lvid=lvid,",
            "                                    segmentation_id=segmentation_id)",
            "",
            "    def _add_local_vlan(self, net_uuid, network_type, physical_network,",
            "                        segmentation_id):",
            "        \"\"\"Add a network to the local VLAN manager",
            "",
            "        On a restart or crash of OVS, the network associated with this VLAN",
            "        will already be assigned, so check for that here before assigning a",
            "        new one. If the VLAN tag is not used, check if there are local VLAN",
            "        tags available.",
            "        \"\"\"",
            "        try:",
            "            lvm = self.vlan_manager.get(net_uuid)",
            "        except vlanmanager.MappingNotFound:",
            "            lvid = self._local_vlan_hints.pop(net_uuid, None)",
            "            if lvid is None:",
            "                if not self.available_local_vlans:",
            "                    LOG.error(\"No local VLAN available for net-id=%s\",",
            "                              net_uuid)",
            "                    return",
            "                lvid = self.available_local_vlans.pop()",
            "            self.vlan_manager.add(",
            "                net_uuid, lvid, network_type, physical_network,",
            "                segmentation_id)",
            "            lvm = self.vlan_manager.get(net_uuid)",
            "            LOG.info(",
            "                \"Assigning %(vlan_id)s as local vlan for net-id=%(net_uuid)s\",",
            "                {'vlan_id': lvm.vlan, 'net_uuid': net_uuid})",
            "",
            "        return lvm",
            "",
            "    def provision_local_vlan(self, net_uuid, network_type, physical_network,",
            "                             segmentation_id):",
            "        '''Provisions a local VLAN.",
            "",
            "        :param net_uuid: the uuid of the network associated with this vlan.",
            "        :param network_type: the network type ('gre', 'vxlan', 'vlan', 'flat',",
            "                                               'local', 'geneve')",
            "        :param physical_network: the physical network for 'vlan' or 'flat'",
            "        :param segmentation_id: the VID for 'vlan' or tunnel ID for 'tunnel'",
            "        '''",
            "        lvm = self._add_local_vlan(net_uuid, network_type, physical_network,",
            "                                   segmentation_id)",
            "        if not lvm or not lvm.vlan:",
            "            return",
            "",
            "        lvid = lvm.vlan",
            "        if network_type in constants.TUNNEL_NETWORK_TYPES:",
            "            if self.enable_tunneling:",
            "                # outbound broadcast/multicast",
            "                ofports = list(self.tun_br_ofports[network_type].values())",
            "                if ofports:",
            "                    self.tun_br.install_flood_to_tun(lvid,",
            "                                                     segmentation_id,",
            "                                                     ofports)",
            "                # inbound from tunnels: set lvid in the right table",
            "                # and resubmit to Table LEARN_FROM_TUN for mac learning",
            "                if self.enable_distributed_routing:",
            "                    self.dvr_agent.process_tunneled_network(",
            "                        network_type, lvid, segmentation_id)",
            "                else:",
            "                    self.tun_br.provision_local_vlan(",
            "                        network_type=network_type, lvid=lvid,",
            "                        segmentation_id=segmentation_id)",
            "            else:",
            "                LOG.error(\"Cannot provision %(network_type)s network for \"",
            "                          \"net-id=%(net_uuid)s - tunneling disabled\",",
            "                          {'network_type': network_type,",
            "                           'net_uuid': net_uuid})",
            "        elif network_type == n_const.TYPE_FLAT:",
            "            if physical_network in self.phys_brs:",
            "                self._local_vlan_for_physical(lvid, physical_network)",
            "            else:",
            "                LOG.error(\"Cannot provision flat network for \"",
            "                          \"net-id=%(net_uuid)s - no bridge for \"",
            "                          \"physical_network %(physical_network)s\",",
            "                          {'net_uuid': net_uuid,",
            "                           'physical_network': physical_network})",
            "        elif network_type == n_const.TYPE_VLAN:",
            "            if physical_network in self.phys_brs:",
            "                self._local_vlan_for_physical(lvid, physical_network,",
            "                                              segmentation_id)",
            "            else:",
            "                LOG.error(\"Cannot provision VLAN network for \"",
            "                          \"net-id=%(net_uuid)s - no bridge for \"",
            "                          \"physical_network %(physical_network)s\",",
            "                          {'net_uuid': net_uuid,",
            "                           'physical_network': physical_network})",
            "        elif network_type == n_const.TYPE_LOCAL:",
            "            # no flows needed for local networks",
            "            pass",
            "        else:",
            "            LOG.error(\"Cannot provision unknown network type \"",
            "                      \"%(network_type)s for net-id=%(net_uuid)s\",",
            "                      {'network_type': network_type,",
            "                       'net_uuid': net_uuid})",
            "",
            "    def reclaim_local_vlan(self, net_uuid):",
            "        '''Reclaim a local VLAN.",
            "",
            "        :param net_uuid: the network uuid associated with this vlan.",
            "        '''",
            "        try:",
            "            lvm = vlanmanager.LocalVlanManager().pop(net_uuid)",
            "        except KeyError:",
            "            LOG.debug(\"Network %s not used on agent.\", net_uuid)",
            "            return",
            "",
            "        LOG.info(\"Reclaiming vlan = %(vlan_id)s from \"",
            "                 \"net-id = %(net_uuid)s\",",
            "                 {'vlan_id': lvm.vlan, 'net_uuid': net_uuid})",
            "",
            "        if lvm.network_type in constants.TUNNEL_NETWORK_TYPES:",
            "            if self.enable_tunneling:",
            "                self.tun_br.reclaim_local_vlan(",
            "                    network_type=lvm.network_type,",
            "                    segmentation_id=lvm.segmentation_id)",
            "                self.tun_br.delete_flood_to_tun(lvm.vlan)",
            "                self.tun_br.delete_unicast_to_tun(lvm.vlan, None)",
            "                self.tun_br.delete_arp_responder(lvm.vlan, None)",
            "                if self.l2_pop:",
            "                    # Try to remove tunnel ports if not used by other networks",
            "                    for ofport in lvm.tun_ofports:",
            "                        self.cleanup_tunnel_port(self.tun_br, ofport,",
            "                                                 lvm.network_type)",
            "        elif lvm.network_type == n_const.TYPE_FLAT:",
            "            if lvm.physical_network in self.phys_brs:",
            "                # outbound",
            "                br = self.phys_brs[lvm.physical_network]",
            "                br.reclaim_local_vlan(",
            "                    port=self.phys_ofports[lvm.physical_network],",
            "                    lvid=lvm.vlan)",
            "                # inbound",
            "                br = self.int_br",
            "                br.reclaim_local_vlan(",
            "                    port=self.int_ofports[lvm.physical_network],",
            "                    segmentation_id=None)",
            "        elif lvm.network_type == n_const.TYPE_VLAN:",
            "            if lvm.physical_network in self.phys_brs:",
            "                # outbound",
            "                br = self.phys_brs[lvm.physical_network]",
            "                br.reclaim_local_vlan(",
            "                    port=self.phys_ofports[lvm.physical_network],",
            "                    lvid=lvm.vlan)",
            "                # inbound",
            "                br = self.int_br",
            "                br.reclaim_local_vlan(",
            "                    port=self.int_ofports[lvm.physical_network],",
            "                    segmentation_id=lvm.segmentation_id)",
            "        elif lvm.network_type == n_const.TYPE_LOCAL:",
            "            # no flows needed for local networks",
            "            pass",
            "        else:",
            "            LOG.error(\"Cannot reclaim unknown network type \"",
            "                      \"%(network_type)s for net-id=%(net_uuid)s\",",
            "                      {'network_type': lvm.network_type,",
            "                       'net_uuid': net_uuid})",
            "",
            "        self.available_local_vlans.add(lvm.vlan)",
            "",
            "    def port_bound(self, port, net_uuid,",
            "                   network_type, physical_network,",
            "                   segmentation_id, fixed_ips, device_owner,",
            "                   provisioning_needed):",
            "        '''Bind port to net_uuid/lsw_id and install flow for inbound traffic",
            "        to vm.",
            "",
            "        :param port: an ovs_lib.VifPort object.",
            "        :param net_uuid: the net_uuid this port is to be associated with.",
            "        :param network_type: the network type ('gre', 'vlan', 'flat', 'local')",
            "        :param physical_network: the physical network for 'vlan' or 'flat'",
            "        :param segmentation_id: the VID for 'vlan' or tunnel ID for 'tunnel'",
            "        :param fixed_ips: the ip addresses assigned to this port",
            "        :param device_owner: the string indicative of owner of this port",
            "        :param provisioning_needed: indicates if this is called for an OVS",
            "                                    restart or recreated physical bridges",
            "                                    and requires to do local vlan provisioning",
            "        '''",
            "        if net_uuid not in self.vlan_manager or provisioning_needed:",
            "            self.provision_local_vlan(net_uuid, network_type,",
            "                                      physical_network, segmentation_id)",
            "        lvm = self.vlan_manager.get(net_uuid)",
            "        lvm.vif_ports[port.vif_id] = port",
            "",
            "        self.dvr_agent.bind_port_to_dvr(port, lvm,",
            "                                        fixed_ips,",
            "                                        device_owner)",
            "        port_other_config = self.int_br.db_get_val(\"Port\", port.port_name,",
            "                                                   \"other_config\")",
            "        if port_other_config is None:",
            "            if port.vif_id in self.deleted_ports:",
            "                LOG.debug(\"Port %s deleted concurrently\", port.vif_id)",
            "            elif port.vif_id in self.updated_ports:",
            "                LOG.error(\"Expected port %s not found\", port.vif_id)",
            "            else:",
            "                LOG.debug(\"Unable to get config for port %s\", port.vif_id)",
            "            return False",
            "",
            "        vlan_mapping = {'net_uuid': net_uuid,",
            "                        'network_type': network_type,",
            "                        'physical_network': str(physical_network)}",
            "        if segmentation_id is not None:",
            "            vlan_mapping['segmentation_id'] = str(segmentation_id)",
            "        port_other_config.update(vlan_mapping)",
            "        self.int_br.set_db_attribute(\"Port\", port.port_name, \"other_config\",",
            "                                     port_other_config)",
            "        return True",
            "",
            "    def _add_port_tag_info(self, need_binding_ports):",
            "        port_names = [p['vif_port'].port_name for p in need_binding_ports]",
            "        port_info = self.int_br.get_ports_attributes(",
            "            \"Port\", columns=[\"name\", \"tag\", \"other_config\"],",
            "            ports=port_names, if_exists=True)",
            "        info_by_port = {",
            "            x['name']: {",
            "                'tag': x['tag'],",
            "                'other_config': x['other_config'] or {}",
            "            }",
            "            for x in port_info",
            "        }",
            "        for port_detail in need_binding_ports:",
            "            try:",
            "                lvm = self.vlan_manager.get(port_detail['network_id'])",
            "            except vlanmanager.MappingNotFound:",
            "                continue",
            "            port = port_detail['vif_port']",
            "            try:",
            "                cur_info = info_by_port[port.port_name]",
            "            except KeyError:",
            "                continue",
            "            str_vlan = str(lvm.vlan)",
            "            other_config = cur_info['other_config']",
            "            if (cur_info['tag'] != lvm.vlan or",
            "                    other_config.get('tag') != str_vlan):",
            "                other_config['tag'] = str_vlan",
            "                self.int_br.set_db_attribute(",
            "                    \"Port\", port.port_name, \"other_config\", other_config)",
            "                # Uninitialized port has tag set to []",
            "                if cur_info['tag']:",
            "                    LOG.warning(\"Uninstall flows of ofport %s due to \"",
            "                                \"local vlan change.\", port.ofport)",
            "                    self.int_br.uninstall_flows(in_port=port.ofport)",
            "",
            "    def _bind_devices(self, need_binding_ports):",
            "        devices_up = []",
            "        devices_down = []",
            "        failed_devices = []",
            "        tunnels_missing = False",
            "        port_names = [p['vif_port'].port_name for p in need_binding_ports]",
            "        port_info = self.int_br.get_ports_attributes(",
            "            \"Port\", columns=[\"name\", \"tag\"], ports=port_names, if_exists=True)",
            "        tags_by_name = {x['name']: x['tag'] for x in port_info}",
            "        for port_detail in need_binding_ports:",
            "            try:",
            "                lvm = self.vlan_manager.get(port_detail['network_id'])",
            "            except vlanmanager.MappingNotFound:",
            "                # network for port was deleted. skip this port since it",
            "                # will need to be handled as a DEAD port in the next scan",
            "                continue",
            "            port = port_detail['vif_port']",
            "            device = port_detail['device']",
            "            # Do not bind a port if it's already bound",
            "            cur_tag = tags_by_name.get(port.port_name)",
            "            if cur_tag is None:",
            "                LOG.debug(\"Port %s was deleted concurrently, skipping it\",",
            "                          port.port_name)",
            "                continue",
            "            if self.prevent_arp_spoofing:",
            "                self.setup_arp_spoofing_protection(self.int_br,",
            "                                                   port, port_detail)",
            "            if cur_tag != lvm.vlan:",
            "                self.int_br.set_db_attribute(",
            "                    \"Port\", port.port_name, \"tag\", lvm.vlan)",
            "",
            "            # update plugin about port status",
            "            # FIXME(salv-orlando): Failures while updating device status",
            "            # must be handled appropriately. Otherwise this might prevent",
            "            # neutron server from sending network-vif-* events to the nova",
            "            # API server, thus possibly preventing instance spawn.",
            "            if port_detail.get('admin_state_up'):",
            "                LOG.debug(\"Setting status for %s to UP\", device)",
            "                devices_up.append(device)",
            "                if (not tunnels_missing and",
            "                        lvm.network_type in constants.TUNNEL_NETWORK_TYPES and",
            "                        len(lvm.tun_ofports) == 0):",
            "                    tunnels_missing = True",
            "            else:",
            "                LOG.debug(\"Setting status for %s to DOWN\", device)",
            "                devices_down.append(device)",
            "        if devices_up or devices_down:",
            "            # When the iter_num == 0, that indicate the ovs-agent is doing",
            "            # the initialization work. L2 pop needs this precise knowledge",
            "            # to notify the agent to refresh the tunnel related flows.",
            "            # Otherwise, these flows will be cleaned as stale due to the",
            "            # different cookie id. We also set refresh_tunnels if the agent",
            "            # has not received a notification and is missing tunnels.",
            "            refresh_tunnels = (self.iter_num == 0) or tunnels_missing",
            "            devices_set = self.plugin_rpc.update_device_list(",
            "                self.context, devices_up, devices_down, self.agent_id,",
            "                self.conf.host, refresh_tunnels=refresh_tunnels)",
            "            failed_devices = (devices_set.get('failed_devices_up') +",
            "                              devices_set.get('failed_devices_down'))",
            "            if failed_devices:",
            "                LOG.error(\"Configuration for devices %s failed!\",",
            "                          failed_devices)",
            "        LOG.info(\"Configuration for devices up %(up)s and devices \"",
            "                 \"down %(down)s completed.\",",
            "                 {'up': devices_up, 'down': devices_down})",
            "        return set(failed_devices)",
            "",
            "    @staticmethod",
            "    def setup_arp_spoofing_protection(bridge, vif, port_details):",
            "        if not port_details.get('port_security_enabled', True):",
            "            LOG.info(\"Skipping ARP spoofing rules for port '%s' because \"",
            "                     \"it has port security disabled\", vif.port_name)",
            "            bridge.delete_arp_spoofing_protection(port=vif.ofport)",
            "            bridge.set_allowed_macs_for_port(port=vif.ofport, allow_all=True)",
            "            return",
            "        if port_details['device_owner'].startswith(",
            "                n_const.DEVICE_OWNER_NETWORK_PREFIX):",
            "            LOG.debug(\"Skipping ARP spoofing rules for network owned port \"",
            "                      \"'%s'.\", vif.port_name)",
            "            bridge.delete_arp_spoofing_protection(port=vif.ofport)",
            "            bridge.set_allowed_macs_for_port(port=vif.ofport, allow_all=True)",
            "            return",
            "        # clear any previous flows related to this port in our ARP table",
            "        bridge.delete_arp_spoofing_allow_rules(port=vif.ofport)",
            "        # collect all of the addresses and cidrs that belong to the port",
            "        addresses = {f['ip_address'] for f in port_details['fixed_ips']}",
            "        mac_addresses = {vif.vif_mac}",
            "        if port_details.get('allowed_address_pairs'):",
            "            addresses |= {p['ip_address']",
            "                          for p in port_details['allowed_address_pairs']}",
            "            mac_addresses |= {p['mac_address']",
            "                              for p in port_details['allowed_address_pairs']",
            "                              if p.get('mac_address')}",
            "",
            "        bridge.set_allowed_macs_for_port(vif.ofport, mac_addresses)",
            "        ipv6_addresses = {ip for ip in addresses",
            "                          if netaddr.IPNetwork(ip).version == 6}",
            "        # Allow neighbor advertisements for LLA address.",
            "        ipv6_addresses |= {str(netutils.get_ipv6_addr_by_EUI64(",
            "                               n_const.IPv6_LLA_PREFIX, mac))",
            "                           for mac in mac_addresses}",
            "        if not has_zero_prefixlen_address(ipv6_addresses):",
            "            # Install protection only when prefix is not zero because a /0",
            "            # prefix allows any address anyway and the nd_target can only",
            "            # match on /1 or more.",
            "            bridge.install_icmpv6_na_spoofing_protection(",
            "                port=vif.ofport, ip_addresses=ipv6_addresses)",
            "",
            "        ipv4_addresses = {ip for ip in addresses",
            "                          if netaddr.IPNetwork(ip).version == 4}",
            "        if not has_zero_prefixlen_address(ipv4_addresses):",
            "            # Install protection only when prefix is not zero because a /0",
            "            # prefix allows any address anyway and the ARP_SPA can only",
            "            # match on /1 or more.",
            "            bridge.install_arp_spoofing_protection(port=vif.ofport,",
            "                                                   ip_addresses=ipv4_addresses)",
            "        else:",
            "            bridge.delete_arp_spoofing_protection(port=vif.ofport)",
            "",
            "    def port_unbound(self, vif_id, net_uuid=None):",
            "        '''Unbind port.",
            "",
            "        Removes corresponding local vlan mapping object if this is its last",
            "        VIF.",
            "",
            "        :param vif_id: the id of the vif",
            "        :param net_uuid: the net_uuid this port is associated with.",
            "        '''",
            "        try:",
            "            net_uuid = net_uuid or self.vlan_manager.get_net_uuid(vif_id)",
            "        except vlanmanager.VifIdNotFound:",
            "            LOG.info(",
            "                'port_unbound(): net_uuid %s not managed by VLAN manager',",
            "                net_uuid)",
            "            return",
            "",
            "        lvm = self.vlan_manager.get(net_uuid)",
            "",
            "        if vif_id in lvm.vif_ports:",
            "            vif_port = lvm.vif_ports[vif_id]",
            "            self.dvr_agent.unbind_port_from_dvr(vif_port, lvm)",
            "        lvm.vif_ports.pop(vif_id, None)",
            "",
            "        if not lvm.vif_ports:",
            "            self.reclaim_local_vlan(net_uuid)",
            "",
            "    def port_dead(self, port, log_errors=True):",
            "        '''Once a port has no binding, put it on the \"dead vlan\".",
            "",
            "        :param port: an ovs_lib.VifPort object.",
            "        '''",
            "        # Don't kill a port if it's already dead",
            "        cur_tag = self.int_br.db_get_val(\"Port\", port.port_name, \"tag\",",
            "                                         log_errors=log_errors)",
            "        if cur_tag and cur_tag != constants.DEAD_VLAN_TAG:",
            "            self.int_br.set_db_attribute(\"Port\", port.port_name, \"tag\",",
            "                                         constants.DEAD_VLAN_TAG,",
            "                                         log_errors=log_errors)",
            "            self.int_br.drop_port(in_port=port.ofport)",
            "",
            "    def setup_integration_br(self):",
            "        '''Setup the integration bridge.",
            "",
            "        '''",
            "        # Ensure the integration bridge is created.",
            "        # ovs_lib.OVSBridge.create() will run the equivalent of",
            "        #   ovs-vsctl -- --may-exist add-br BRIDGE_NAME",
            "        # which does nothing if bridge already exists.",
            "        self.int_br.create()",
            "        self.int_br.set_secure_mode()",
            "        self.int_br.setup_controllers(self.conf)",
            "        self.int_br.set_igmp_snooping_state(self.conf.OVS.igmp_snooping_enable)",
            "",
            "        if self.conf.AGENT.drop_flows_on_start:",
            "            # Delete the patch port between br-int and br-tun if we're deleting",
            "            # the flows on br-int, so that traffic doesn't get flooded over",
            "            # while flows are missing.",
            "            self.int_br.delete_port(self.conf.OVS.int_peer_patch_port)",
            "            self.int_br.uninstall_flows(cookie=ovs_lib.COOKIE_ANY)",
            "        self.int_br.setup_default_table()",
            "",
            "    def setup_ancillary_bridges(self, integ_br, tun_br):",
            "        '''Setup ancillary bridges - for example br-ex.'''",
            "        ovs = ovs_lib.BaseOVS()",
            "        ovs_bridges = set(ovs.get_bridges())",
            "        # Remove all known bridges",
            "        ovs_bridges.remove(integ_br)",
            "        if self.enable_tunneling:",
            "            ovs_bridges.remove(tun_br)",
            "        br_names = [self.phys_brs[physical_network].br_name for",
            "                    physical_network in self.phys_brs]",
            "        ovs_bridges.difference_update(br_names)",
            "        # Filter list of bridges to those that have external",
            "        # bridge-id's configured",
            "        br_names = []",
            "        for bridge in ovs_bridges:",
            "            bridge_id = ovs.get_bridge_external_bridge_id(bridge,",
            "                                                          log_errors=False)",
            "            if bridge_id != bridge:",
            "                br_names.append(bridge)",
            "        ovs_bridges.difference_update(br_names)",
            "        ancillary_bridges = []",
            "        for bridge in ovs_bridges:",
            "            br = ovs_lib.OVSBridge(bridge)",
            "            LOG.info('Adding %s to list of bridges.', bridge)",
            "            ancillary_bridges.append(br)",
            "        return ancillary_bridges",
            "",
            "    def setup_tunnel_br(self, tun_br_name=None):",
            "        '''(re)initialize the tunnel bridge.",
            "",
            "        Creates tunnel bridge, and links it to the integration bridge",
            "        using a patch port.",
            "",
            "        :param tun_br_name: the name of the tunnel bridge.",
            "        '''",
            "        if not self.tun_br:",
            "            self.tun_br = self.br_tun_cls(tun_br_name)",
            "",
            "        # tun_br.create() won't recreate bridge if it exists, but will handle",
            "        # cases where something like datapath_type has changed",
            "        self.tun_br.create(secure_mode=True)",
            "        self.tun_br.setup_controllers(self.conf)",
            "        if (not self.int_br.port_exists(self.conf.OVS.int_peer_patch_port) or",
            "                self.patch_tun_ofport == ovs_lib.INVALID_OFPORT):",
            "            self.patch_tun_ofport = self.int_br.add_patch_port(",
            "                self.conf.OVS.int_peer_patch_port,",
            "                self.conf.OVS.tun_peer_patch_port)",
            "        if (not self.tun_br.port_exists(self.conf.OVS.tun_peer_patch_port) or",
            "                self.patch_int_ofport == ovs_lib.INVALID_OFPORT):",
            "            self.patch_int_ofport = self.tun_br.add_patch_port(",
            "                self.conf.OVS.tun_peer_patch_port,",
            "                self.conf.OVS.int_peer_patch_port)",
            "        if ovs_lib.INVALID_OFPORT in (self.patch_tun_ofport,",
            "                                      self.patch_int_ofport):",
            "            LOG.error(\"Failed to create OVS patch port. Cannot have \"",
            "                      \"tunneling enabled on this agent, since this \"",
            "                      \"version of OVS does not support tunnels or patch \"",
            "                      \"ports. Agent terminated!\")",
            "            sys.exit(1)",
            "        if self.conf.AGENT.drop_flows_on_start:",
            "            self.tun_br.uninstall_flows(cookie=ovs_lib.COOKIE_ANY)",
            "",
            "    def setup_tunnel_br_flows(self):",
            "        '''Setup the tunnel bridge.",
            "",
            "        Add all flows to the tunnel bridge.",
            "        '''",
            "        self.tun_br.setup_default_table(self.patch_int_ofport,",
            "                                        self.arp_responder_enabled)",
            "",
            "    def _reconfigure_physical_bridges(self, bridges):",
            "        try:",
            "            sync = self._do_reconfigure_physical_bridges(bridges)",
            "            self.added_bridges = []",
            "        except RuntimeError:",
            "            # If there was error and bridges aren't properly reconfigured,",
            "            # there is no need to do full sync once again. It will be done when",
            "            # reconfiguration of physical bridges will be finished without",
            "            # errors",
            "            sync = False",
            "            self.added_bridges = bridges",
            "            LOG.warning(\"RuntimeError during setup of physical bridges: %s\",",
            "                        bridges)",
            "        return sync",
            "",
            "    def _do_reconfigure_physical_bridges(self, bridges):",
            "        sync = False",
            "        bridge_mappings = {}",
            "        for bridge in bridges:",
            "            LOG.info(\"Physical bridge %s was just re-created.\", bridge)",
            "            for phys_net, phys_br in self.bridge_mappings.items():",
            "                if bridge == phys_br:",
            "                    bridge_mappings[phys_net] = bridge",
            "        if bridge_mappings:",
            "            sync = True",
            "            self.setup_physical_bridges(bridge_mappings)",
            "            if self.enable_distributed_routing:",
            "                self.dvr_agent.reset_dvr_flows(",
            "                    self.int_br, self.tun_br, self.phys_brs,",
            "                    self.patch_int_ofport, self.patch_tun_ofport,",
            "                    bridge_mappings)",
            "        return sync",
            "",
            "    def _check_bridge_datapath_id(self, bridge, datapath_ids_set):",
            "        \"\"\"Check for bridges with duplicate datapath-id",
            "",
            "        Bottom 48 bits auto-derived from MAC of NIC. Upper 12 bits free,",
            "        so we OR it with (bridge # << 48) to create a unique ID",
            "        It must be exactly 64 bits, else OVS will reject it - zfill",
            "",
            "        :param bridge: (OVSPhysicalBridge) bridge",
            "        :param datapath_ids_set: (set) used datapath ids in OVS",
            "        \"\"\"",
            "        dpid = int(bridge.get_datapath_id(), 16)",
            "        dpid_hex = format(dpid, '0x').zfill(16)",
            "        if dpid_hex in datapath_ids_set:",
            "            dpid_hex = format(",
            "                dpid + (len(datapath_ids_set) << 48), '0x').zfill(16)",
            "            bridge.set_datapath_id(dpid_hex)",
            "        LOG.info('Bridge %s datapath-id = 0x%s', bridge.br_name, dpid_hex)",
            "        datapath_ids_set.add(dpid_hex)",
            "",
            "    def setup_physical_bridges(self, bridge_mappings):",
            "        '''Setup the physical network bridges.",
            "",
            "        Creates physical network bridges and links them to the",
            "        integration bridge using veths or patch ports.",
            "",
            "        :param bridge_mappings: map physical network names to bridge names.",
            "        '''",
            "        self.phys_brs = {}",
            "        self.int_ofports = {}",
            "        self.phys_ofports = {}",
            "        datapath_ids_set = set()",
            "        ip_wrapper = ip_lib.IPWrapper()",
            "        ovs = ovs_lib.BaseOVS()",
            "        ovs_bridges = ovs.get_bridges()",
            "        for physical_network, bridge in bridge_mappings.items():",
            "            LOG.info(\"Mapping physical network %(physical_network)s to \"",
            "                     \"bridge %(bridge)s\",",
            "                     {'physical_network': physical_network,",
            "                      'bridge': bridge})",
            "            # setup physical bridge",
            "            if bridge not in ovs_bridges:",
            "                LOG.error(\"Bridge %(bridge)s for physical network \"",
            "                          \"%(physical_network)s does not exist. Agent \"",
            "                          \"terminated!\",",
            "                          {'physical_network': physical_network,",
            "                           'bridge': bridge})",
            "                sys.exit(1)",
            "            br = self.br_phys_cls(bridge)",
            "            self._check_bridge_datapath_id(br, datapath_ids_set)",
            "",
            "            # The bridge already exists, so create won't recreate it, but will",
            "            # handle things like changing the datapath_type",
            "            br.create()",
            "            br.set_secure_mode()",
            "            br.setup_controllers(self.conf)",
            "            if cfg.CONF.AGENT.drop_flows_on_start:",
            "                br.uninstall_flows(cookie=ovs_lib.COOKIE_ANY)",
            "            br.setup_default_table()",
            "            self.phys_brs[physical_network] = br",
            "",
            "            # interconnect physical and integration bridges using veth/patches",
            "            int_if_name = plugin_utils.get_interface_name(",
            "                bridge, prefix=constants.PEER_INTEGRATION_PREFIX)",
            "            phys_if_name = plugin_utils.get_interface_name(",
            "                bridge, prefix=constants.PEER_PHYSICAL_PREFIX)",
            "            # Interface type of port for physical and integration bridges must",
            "            # be same, so check only one of them.",
            "            # Not logging error here, as the interface may not exist yet.",
            "            # Type check is done to cleanup wrong interface if any.",
            "            int_type = self.int_br.db_get_val(\"Interface\", int_if_name, \"type\",",
            "                                              log_errors=False)",
            "            if self.use_veth_interconnection:",
            "                # Drop ports if the interface types doesn't match the",
            "                # configuration value.",
            "                if int_type == 'patch':",
            "                    self.int_br.delete_port(int_if_name)",
            "                    br.delete_port(phys_if_name)",
            "                device = ip_lib.IPDevice(int_if_name)",
            "                if device.exists():",
            "                    device.link.delete()",
            "                    # Give udev a chance to process its rules here, to avoid",
            "                    # race conditions between commands launched by udev rules",
            "                    # and the subsequent call to ip_wrapper.add_veth",
            "                    utils.execute(['udevadm', 'settle', '--timeout=10'])",
            "                int_veth, phys_veth = ip_wrapper.add_veth(int_if_name,",
            "                                                          phys_if_name)",
            "                int_ofport = self.int_br.add_port(int_if_name)",
            "                phys_ofport = br.add_port(phys_if_name)",
            "            else:",
            "                # Drop ports if the interface type doesn't match the",
            "                # configuration value",
            "                if int_type == 'veth':",
            "                    self.int_br.delete_port(int_if_name)",
            "                    br.delete_port(phys_if_name)",
            "",
            "                # Setup int_br to physical bridge patches.  If they already",
            "                # exist we leave them alone, otherwise we create them but don't",
            "                # connect them until after the drop rules are in place.",
            "                if self.int_br.port_exists(int_if_name):",
            "                    int_ofport = self.int_br.get_port_ofport(int_if_name)",
            "                else:",
            "                    int_ofport = self.int_br.add_patch_port(",
            "                        int_if_name, constants.NONEXISTENT_PEER)",
            "                if br.port_exists(phys_if_name):",
            "                    phys_ofport = br.get_port_ofport(phys_if_name)",
            "                else:",
            "                    phys_ofport = br.add_patch_port(",
            "                        phys_if_name, constants.NONEXISTENT_PEER)",
            "",
            "            self.int_ofports[physical_network] = int_ofport",
            "            self.phys_ofports[physical_network] = phys_ofport",
            "",
            "            # Drop packets from physical bridges that have not matched a higher",
            "            # priority flow to set a local vlan. This prevents these stray",
            "            # packets from being forwarded to other physical bridges which",
            "            # could cause a network loop in the physical network.",
            "            self.int_br.drop_port(in_port=int_ofport)",
            "",
            "            if not self.enable_distributed_routing:",
            "                br.drop_port(in_port=phys_ofport)",
            "",
            "            if self.use_veth_interconnection:",
            "                # enable veth to pass traffic",
            "                int_veth.link.set_up()",
            "                phys_veth.link.set_up()",
            "                if self.veth_mtu:",
            "                    # set up mtu size for veth interfaces",
            "                    int_veth.link.set_mtu(self.veth_mtu)",
            "                    phys_veth.link.set_mtu(self.veth_mtu)",
            "            else:",
            "                # associate patch ports to pass traffic",
            "                self.int_br.set_db_attribute('Interface', int_if_name,",
            "                                             'options', {'peer': phys_if_name})",
            "                br.set_db_attribute('Interface', phys_if_name,",
            "                                    'options', {'peer': int_if_name})",
            "",
            "    def update_stale_ofport_rules(self):",
            "        # ARP spoofing rules and drop-flow upon port-delete",
            "        # use ofport-based rules",
            "        previous = self.vifname_to_ofport_map",
            "        current = self.int_br.get_vif_port_to_ofport_map()",
            "",
            "        # if any ofport numbers have changed, re-process the devices as",
            "        # added ports so any rules based on ofport numbers are updated.",
            "        moved_ports = self._get_ofport_moves(current, previous)",
            "",
            "        # delete any stale rules based on removed ofports",
            "        ofports_deleted = set(previous.values()) - set(current.values())",
            "        for ofport in ofports_deleted:",
            "            if self.prevent_arp_spoofing:",
            "                self.int_br.delete_arp_spoofing_protection(port=ofport)",
            "            self.int_br.uninstall_flows(in_port=ofport)",
            "        # store map for next iteration",
            "        self.vifname_to_ofport_map = current",
            "        return moved_ports",
            "",
            "    @staticmethod",
            "    def _get_ofport_moves(current, previous):",
            "        \"\"\"Returns a list of moved ports.",
            "",
            "        Takes two port->ofport maps and returns a list ports that moved to a",
            "        different ofport. Deleted ports are not included.",
            "        \"\"\"",
            "        port_moves = []",
            "        for name, ofport in previous.items():",
            "            if name not in current:",
            "                continue",
            "            current_ofport = current[name]",
            "            if ofport != current_ofport:",
            "                port_moves.append(name)",
            "        return port_moves",
            "",
            "    def _get_port_info(self, registered_ports, cur_ports,",
            "                       readd_registered_ports):",
            "        port_info = PortInfo(current=cur_ports)",
            "        # FIXME(salv-orlando): It's not really necessary to return early",
            "        # if nothing has changed.",
            "        if not readd_registered_ports and cur_ports == registered_ports:",
            "            return port_info",
            "",
            "        if readd_registered_ports:",
            "            port_info['added'] = cur_ports",
            "        else:",
            "            port_info['added'] = cur_ports - registered_ports",
            "        # Update port_info with ports not found on the integration bridge",
            "        port_info['removed'] = registered_ports - cur_ports",
            "        return port_info",
            "",
            "    def _update_port_info_failed_devices_stats(self, port_info,",
            "                                               failed_devices):",
            "        # remove failed devices that don't need to be retried",
            "        failed_devices['added'] -= port_info['removed']",
            "        failed_devices['removed'] -= port_info['added']",
            "",
            "        # Disregard devices that were never noticed by the agent",
            "        port_info['removed'] &= port_info['current']",
            "        # retry failed devices",
            "        port_info['added'] |= failed_devices['added']",
            "        if failed_devices['added']:",
            "            LOG.debug(\"retrying failed devices %s\", failed_devices['added'])",
            "        port_info['removed'] |= failed_devices['removed']",
            "        # Update current ports",
            "        port_info['current'] |= port_info['added']",
            "        port_info['current'] -= port_info['removed']",
            "",
            "    def process_ports_events(self, events, registered_ports, ancillary_ports,",
            "                             old_ports_not_ready, failed_devices,",
            "                             failed_ancillary_devices, updated_ports=None):",
            "        port_info = PortInfo(current=registered_ports)",
            "        ancillary_port_info = PortInfo(current=ancillary_ports)",
            "",
            "        ports_not_ready_yet = set()",
            "        if updated_ports is None:",
            "            updated_ports = set()",
            "",
            "        # if a port was added and then removed or viceversa since the agent",
            "        # can't know the order of the operations, check the status of the port",
            "        # to determine if the port was added or deleted",
            "        added_ports = {p['name'] for p in events['added']}",
            "        removed_ports = {p['name'] for p in events['removed']}",
            "        updated_ports.update({p['name'] for p in events['modified']})",
            "",
            "        ports_re_added = added_ports & removed_ports",
            "        ports_re_added = [p for p in ports_re_added if",
            "                          ovs_lib.BaseOVS().port_exists(p)]",
            "        events['re_added'] = [e for e in events['removed']",
            "                              if e['name'] in ports_re_added]",
            "        events['removed'] = [e for e in events['removed'] if e['name']",
            "                             not in ports_re_added]",
            "        ports_removed = [p['name'] for p in events['removed']]",
            "        events['added'] = [e for e in events['added'] if e['name'] not in",
            "                           ports_removed]",
            "",
            "        # TODO(rossella_s): scanning the ancillary bridge won't be needed",
            "        # anymore when https://review.opendev.org/#/c/203381 since the bridge",
            "        # id stored in external_ids will be used to identify the bridge the",
            "        # port belongs to",
            "        cur_ancillary_ports = set()",
            "        for bridge in self.ancillary_brs:",
            "            cur_ancillary_ports |= bridge.get_vif_port_set()",
            "        cur_ancillary_ports |= ancillary_port_info['current']",
            "",
            "        def _process_port(port, ports, ancillary_ports):",
            "            # check 'iface-id' is set otherwise is not a port",
            "            # the agent should care about",
            "            if 'attached-mac' in port.get('external_ids', []):",
            "                iface_id = self.int_br.portid_from_external_ids(",
            "                    port['external_ids'])",
            "                if iface_id:",
            "                    if port['ofport'] == ovs_lib.UNASSIGNED_OFPORT:",
            "                        LOG.debug(\"Port %s not ready yet on the bridge\",",
            "                                  iface_id)",
            "                        ports_not_ready_yet.add(port['name'])",
            "                        return",
            "                    # check if port belongs to ancillary bridge",
            "                    if iface_id in cur_ancillary_ports:",
            "                        ancillary_ports.add(iface_id)",
            "                    else:",
            "                        ports.add(iface_id)",
            "        if old_ports_not_ready:",
            "            old_ports_not_ready_attrs = self.int_br.get_ports_attributes(",
            "                'Interface', columns=['name', 'external_ids', 'ofport'],",
            "                ports=old_ports_not_ready, if_exists=True)",
            "            now_ready_ports = set(",
            "                [p['name'] for p in old_ports_not_ready_attrs])",
            "            LOG.debug(\"Ports %s are now ready\", now_ready_ports)",
            "            old_ports_not_ready_yet = old_ports_not_ready - now_ready_ports",
            "            removed_ports = set([p['name'] for p in events['removed']])",
            "            old_ports_not_ready_yet -= removed_ports",
            "            LOG.debug(\"Ports %s were not ready at last iteration and are not \"",
            "                      \"ready yet\", old_ports_not_ready_yet)",
            "            ports_not_ready_yet |= old_ports_not_ready_yet",
            "            events['added'].extend(old_ports_not_ready_attrs)",
            "",
            "        for event_type in ('added', 'removed', 're_added'):",
            "            for port in events.get(event_type, []):",
            "                _process_port(port, port_info[event_type],",
            "                              ancillary_port_info[event_type])",
            "",
            "        self._update_port_info_failed_devices_stats(port_info, failed_devices)",
            "        self._update_port_info_failed_devices_stats(ancillary_port_info,",
            "                                                    failed_ancillary_devices)",
            "",
            "        updated_ports.update(self.check_changed_vlans())",
            "",
            "        if updated_ports:",
            "            # Some updated ports might have been removed in the",
            "            # meanwhile, and therefore should not be processed.",
            "            # In this case the updated port won't be found among",
            "            # current ports.",
            "            updated_ports &= port_info['current']",
            "            port_info['updated'] = updated_ports",
            "        return port_info, ancillary_port_info, ports_not_ready_yet",
            "",
            "    def scan_ports(self, registered_ports, sync, updated_ports=None):",
            "        cur_ports = self.int_br.get_vif_port_set()",
            "        self.int_br_device_count = len(cur_ports)",
            "        port_info = self._get_port_info(registered_ports, cur_ports, sync)",
            "        if updated_ports is None:",
            "            updated_ports = set()",
            "        updated_ports.update(self.check_changed_vlans())",
            "        if updated_ports:",
            "            # Some updated ports might have been removed in the",
            "            # meanwhile, and therefore should not be processed.",
            "            # In this case the updated port won't be found among",
            "            # current ports.",
            "            updated_ports &= cur_ports",
            "            if updated_ports:",
            "                port_info['updated'] = updated_ports",
            "        return port_info",
            "",
            "    def scan_ancillary_ports(self, registered_ports, sync):",
            "        cur_ports = set()",
            "        for bridge in self.ancillary_brs:",
            "            cur_ports |= bridge.get_vif_port_set()",
            "        return self._get_port_info(registered_ports, cur_ports, sync)",
            "",
            "    def check_changed_vlans(self):",
            "        \"\"\"Check for changed VLAN tags. If changes, notify server and return.",
            "",
            "        The returned value is a set of port ids of the ports concerned by a",
            "        vlan tag loss.",
            "        \"\"\"",
            "        port_tags = self.int_br.get_port_tag_dict()",
            "        changed_ports = set()",
            "        for lvm in self.vlan_manager:",
            "            for port in lvm.vif_ports.values():",
            "                if (",
            "                    port.port_name in port_tags and",
            "                    port_tags[port.port_name] != lvm.vlan",
            "                ):",
            "                    LOG.info(",
            "                        \"Port '%(port_name)s' has lost \"",
            "                        \"its vlan tag '%(vlan_tag)d'! \"",
            "                        \"Current vlan tag on this port is '%(new_vlan_tag)d'.\",",
            "                        {'port_name': port.port_name,",
            "                         'vlan_tag': lvm.vlan,",
            "                         'new_vlan_tag': port_tags[port.port_name]}",
            "                    )",
            "                    changed_ports.add(port.vif_id)",
            "        if changed_ports:",
            "            # explicitly mark these DOWN on the server since they have been",
            "            # manipulated (likely a nova unplug/replug) and need to be rewired",
            "            devices_down = self.plugin_rpc.update_device_list(self.context,",
            "                                                              [],",
            "                                                              changed_ports,",
            "                                                              self.agent_id,",
            "                                                              self.conf.host)",
            "            failed_devices = set(devices_down.get('failed_devices_down'))",
            "            if failed_devices:",
            "                LOG.debug(\"Status updated failed for %s\", failed_devices)",
            "",
            "        return changed_ports",
            "",
            "    def treat_vif_port(self, vif_port, port_id, network_id, network_type,",
            "                       physical_network, segmentation_id, admin_state_up,",
            "                       fixed_ips, device_owner, provisioning_needed):",
            "        # When this function is called for a port, the port should have",
            "        # an OVS ofport configured, as only these ports were considered",
            "        # for being treated. If that does not happen, it is a potential",
            "        # error condition of which operators should be aware",
            "        port_needs_binding = True",
            "        if not vif_port.ofport:",
            "            LOG.warning(\"VIF port: %s has no ofport configured, \"",
            "                        \"and might not be able to transmit\",",
            "                        vif_port.vif_id)",
            "        if vif_port:",
            "            if admin_state_up:",
            "                port_needs_binding = self.port_bound(",
            "                    vif_port, network_id, network_type,",
            "                    physical_network, segmentation_id,",
            "                    fixed_ips, device_owner, provisioning_needed)",
            "            else:",
            "                LOG.info(\"VIF port: %s admin state up disabled, \"",
            "                         \"putting on the dead VLAN\", vif_port.vif_id)",
            "",
            "                self.port_dead(vif_port)",
            "                self.plugin_rpc.update_device_down(",
            "                    self.context, port_id, self.agent_id,",
            "                    self.conf.host)",
            "                port_needs_binding = False",
            "        else:",
            "            LOG.debug(\"No VIF port for port %s defined on agent.\", port_id)",
            "        return port_needs_binding",
            "",
            "    def _setup_tunnel_port(self, br, port_name, remote_ip, tunnel_type):",
            "        try:",
            "            if (netaddr.IPAddress(self.local_ip).version !=",
            "                    netaddr.IPAddress(remote_ip).version):",
            "                LOG.error(\"IP version mismatch, cannot create tunnel: \"",
            "                          \"local_ip=%(lip)s remote_ip=%(rip)s\",",
            "                          {'lip': self.local_ip, 'rip': remote_ip})",
            "                return 0",
            "        except Exception:",
            "            LOG.error(\"Invalid local or remote IP, cannot create tunnel: \"",
            "                      \"local_ip=%(lip)s remote_ip=%(rip)s\",",
            "                      {'lip': self.local_ip, 'rip': remote_ip})",
            "            return 0",
            "        ofport = br.add_tunnel_port(port_name,",
            "                                    remote_ip,",
            "                                    self.local_ip,",
            "                                    tunnel_type,",
            "                                    self.vxlan_udp_port,",
            "                                    self.dont_fragment,",
            "                                    self.tunnel_csum,",
            "                                    self.tos)",
            "        if ofport == ovs_lib.INVALID_OFPORT:",
            "            LOG.error(\"Failed to set-up %(type)s tunnel port to %(ip)s\",",
            "                      {'type': tunnel_type, 'ip': remote_ip})",
            "            return 0",
            "",
            "        self.tun_br_ofports[tunnel_type][remote_ip] = ofport",
            "        # Add flow in default table to resubmit to the right",
            "        # tunneling table (lvid will be set in the latter)",
            "        br.setup_tunnel_port(tunnel_type, ofport)",
            "        return ofport",
            "",
            "    def _setup_tunnel_flood_flow(self, br, tunnel_type):",
            "        ofports = self.tun_br_ofports[tunnel_type].values()",
            "        if ofports and not self.l2_pop:",
            "            # Update flooding flows to include the new tunnel",
            "            for vlan_mapping in self.vlan_manager:",
            "                if vlan_mapping.network_type == tunnel_type:",
            "                    br.install_flood_to_tun(vlan_mapping.vlan,",
            "                                            vlan_mapping.segmentation_id,",
            "                                            ofports)",
            "",
            "    def setup_tunnel_port(self, br, remote_ip, network_type):",
            "        port_name = self.get_tunnel_name(",
            "            network_type, self.local_ip, remote_ip)",
            "        if port_name is None:",
            "            return 0",
            "        ofport = self._setup_tunnel_port(br,",
            "                                         port_name,",
            "                                         remote_ip,",
            "                                         network_type)",
            "        self._setup_tunnel_flood_flow(br, network_type)",
            "        return ofport",
            "",
            "    def cleanup_tunnel_port(self, br, tun_ofport, tunnel_type):",
            "        # Check if this tunnel port is still used",
            "        for lvm in self.vlan_manager:",
            "            if tun_ofport in lvm.tun_ofports:",
            "                break",
            "        # If not, remove it",
            "        else:",
            "            items = list(self.tun_br_ofports[tunnel_type].items())",
            "            for remote_ip, ofport in items:",
            "                if ofport == tun_ofport:",
            "                    port_name = self.get_tunnel_name(",
            "                        tunnel_type, self.local_ip, remote_ip)",
            "                    br.delete_port(port_name)",
            "                    br.cleanup_tunnel_port(ofport)",
            "                    self.tun_br_ofports[tunnel_type].pop(remote_ip, None)",
            "",
            "    def treat_devices_added_or_updated(self, devices, provisioning_needed,",
            "                                       re_added):",
            "        skipped_devices = []",
            "        need_binding_devices = []",
            "        binding_no_activated_devices = set()",
            "        agent_restarted = self.iter_num == 0",
            "        devices_details_list = (",
            "            self.plugin_rpc.get_devices_details_list_and_failed_devices(",
            "                self.context,",
            "                devices,",
            "                self.agent_id,",
            "                self.conf.host,",
            "                agent_restarted))",
            "        failed_devices = set(devices_details_list.get('failed_devices'))",
            "",
            "        devices = devices_details_list.get('devices')",
            "        vif_by_id = self.int_br.get_vifs_by_ids(",
            "            [vif['device'] for vif in devices])",
            "        devices_not_in_datapath = set()",
            "        for details in devices:",
            "            device = details['device']",
            "            LOG.debug(\"Processing port: %s\", device)",
            "            port = vif_by_id.get(device)",
            "            if not port:",
            "                # The port disappeared and cannot be processed",
            "                LOG.info(\"Port %s was not found on the integration bridge \"",
            "                         \"and will therefore not be processed\", device)",
            "                self.ext_manager.delete_port(self.context, {'port_id': device})",
            "                skipped_devices.append(device)",
            "                continue",
            "",
            "            if not port.ofport or port.ofport == ovs_lib.INVALID_OFPORT:",
            "                devices_not_in_datapath.add(device)",
            "",
            "            if 'port_id' in details:",
            "                LOG.info(\"Port %(device)s updated. Details: %(details)s\",",
            "                         {'device': device, 'details': details})",
            "                details['vif_port'] = port",
            "                need_binding = self.treat_vif_port(port, details['port_id'],",
            "                                                   details['network_id'],",
            "                                                   details['network_type'],",
            "                                                   details['physical_network'],",
            "                                                   details['segmentation_id'],",
            "                                                   details['admin_state_up'],",
            "                                                   details['fixed_ips'],",
            "                                                   details['device_owner'],",
            "                                                   provisioning_needed)",
            "                if need_binding:",
            "                    need_binding_devices.append(details)",
            "                self._update_port_network(details['port_id'],",
            "                                          details['network_id'])",
            "                if details['device'] in re_added:",
            "                    self.ext_manager.delete_port(self.context, details)",
            "                if device not in devices_not_in_datapath:",
            "                    self.ext_manager.handle_port(self.context, details)",
            "",
            "            else:",
            "                if n_const.NO_ACTIVE_BINDING in details:",
            "                    # Port was added to the bridge, but its binding in this",
            "                    # agent hasn't been activated yet. It will be treated as",
            "                    # added when binding is activated",
            "                    binding_no_activated_devices.add(device)",
            "                    LOG.debug(\"Device %s has no active binding in host\",",
            "                              device)",
            "                else:",
            "                    LOG.warning(",
            "                        \"Device %s not defined on plugin or binding failed\",",
            "                        device)",
            "                if (port and port.ofport != -1):",
            "                    self.port_dead(port)",
            "        return (skipped_devices, binding_no_activated_devices,",
            "                need_binding_devices, failed_devices, devices_not_in_datapath)",
            "",
            "    def _update_port_network(self, port_id, network_id):",
            "        self._clean_network_ports(port_id)",
            "        self.network_ports[network_id].add(port_id)",
            "",
            "    def treat_ancillary_devices_added(self, devices):",
            "        devices_details_list = (",
            "            self.plugin_rpc.get_devices_details_list_and_failed_devices(",
            "                self.context,",
            "                devices,",
            "                self.agent_id,",
            "                self.conf.host))",
            "        failed_devices = set(devices_details_list.get('failed_devices'))",
            "        devices_added = [",
            "            d['device'] for d in devices_details_list.get('devices')]",
            "",
            "        # update plugin about port status",
            "        devices_set_up = (",
            "            self.plugin_rpc.update_device_list(self.context,",
            "                                               devices_added,",
            "                                               [],",
            "                                               self.agent_id,",
            "                                               self.conf.host))",
            "        failed_devices |= set(devices_set_up.get('failed_devices_up'))",
            "        LOG.info(\"Ancillary Ports %(added)s added, failed devices \"",
            "                 \"%(failed)s\", {'added': devices, 'failed': failed_devices})",
            "        return failed_devices",
            "",
            "    def treat_devices_removed(self, devices):",
            "        self.sg_agent.remove_devices_filter(devices)",
            "        LOG.info(\"Ports %s removed\", devices)",
            "        devices_down = self.plugin_rpc.update_device_list(self.context,",
            "                                                          [],",
            "                                                          devices,",
            "                                                          self.agent_id,",
            "                                                          self.conf.host)",
            "        failed_devices = set(devices_down.get('failed_devices_down'))",
            "        LOG.debug(\"Port removal failed for %s\", failed_devices)",
            "        for device in devices:",
            "            self.ext_manager.delete_port(self.context, {'port_id': device})",
            "            self.port_unbound(device)",
            "        return failed_devices",
            "",
            "    def treat_ancillary_devices_removed(self, devices):",
            "        LOG.info(\"Ancillary ports %s removed\", devices)",
            "        devices_down = self.plugin_rpc.update_device_list(self.context,",
            "                                                          [],",
            "                                                          devices,",
            "                                                          self.agent_id,",
            "                                                          self.conf.host)",
            "        LOG.info(\"Devices down  %s \", devices_down)",
            "        failed_devices = set(devices_down.get('failed_devices_down'))",
            "        if failed_devices:",
            "            LOG.debug(\"Port removal failed for %s\", failed_devices)",
            "        for detail in devices_down.get('devices_down'):",
            "            if detail['exists']:",
            "                LOG.info(\"Port %s updated.\", detail['device'])",
            "                # Nothing to do regarding local networking",
            "            else:",
            "                LOG.debug(\"Device %s not defined on plugin\", detail['device'])",
            "        return failed_devices",
            "",
            "    def treat_devices_skipped(self, devices):",
            "        LOG.info(\"Ports %s skipped, changing status to down\", devices)",
            "        devices_down = self.plugin_rpc.update_device_list(self.context,",
            "                                                          [],",
            "                                                          devices,",
            "                                                          self.agent_id,",
            "                                                          self.conf.host)",
            "        failed_devices = set(devices_down.get('failed_devices_down'))",
            "        if failed_devices:",
            "            LOG.debug(\"Port down failed for %s\", failed_devices)",
            "",
            "    def process_network_ports(self, port_info, provisioning_needed):",
            "        failed_devices = {'added': set(), 'removed': set()}",
            "        # TODO(salv-orlando): consider a solution for ensuring notifications",
            "        # are processed exactly in the same order in which they were",
            "        # received. This is tricky because there are two notification",
            "        # sources: the neutron server, and the ovs db monitor process",
            "        # If there is an exception while processing security groups ports",
            "        # will not be wired anyway, and a resync will be triggered",
            "        # VIF wiring needs to be performed always for 'new' devices.",
            "        # For updated ports, re-wiring is not needed in most cases, but needs",
            "        # to be performed anyway when the admin state of a device is changed.",
            "        # A device might be both in the 'added' and 'updated'",
            "        # list at the same time; avoid processing it twice.",
            "        devices_added_updated = (port_info.get('added', set()) |",
            "                                 port_info.get('updated', set()))",
            "        re_added = port_info.get('re_added', set())",
            "        need_binding_devices = []",
            "        skipped_devices = set()",
            "        binding_no_activated_devices = set()",
            "        devices_not_in_datapath = set()",
            "        start = time.time()",
            "        if devices_added_updated:",
            "            (skipped_devices, binding_no_activated_devices,",
            "             need_binding_devices, failed_devices['added'],",
            "             devices_not_in_datapath) = (",
            "                self.treat_devices_added_or_updated(",
            "                    devices_added_updated, provisioning_needed, re_added))",
            "            LOG.info(\"process_network_ports - iteration:%(iter_num)d - \"",
            "                     \"treat_devices_added_or_updated completed. \"",
            "                     \"Skipped %(num_skipped)d and no activated binding \"",
            "                     \"devices %(num_no_active_binding)d of %(num_current)d \"",
            "                     \"devices currently available. \"",
            "                     \"Time elapsed: %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'num_skipped': len(skipped_devices),",
            "                      'num_no_active_binding':",
            "                          len(binding_no_activated_devices),",
            "                      'num_current': len(port_info['current']),",
            "                      'elapsed': time.time() - start})",
            "            # Update the list of current ports storing only those which",
            "            # have been actually processed.",
            "            skipped_devices = set(skipped_devices)",
            "            port_info['current'] = (port_info['current'] - skipped_devices)",
            "",
            "        # TODO(salv-orlando): Optimize avoiding applying filters",
            "        # unnecessarily, (eg: when there are no IP address changes)",
            "        added_ports = (port_info.get('added', set()) - skipped_devices -",
            "                       binding_no_activated_devices)",
            "        self._add_port_tag_info(need_binding_devices)",
            "        self.process_install_ports_egress_flows(need_binding_devices)",
            "        added_to_datapath = added_ports - devices_not_in_datapath",
            "        self.sg_agent.setup_port_filters(added_to_datapath,",
            "                                         port_info.get('updated', set()))",
            "",
            "        LOG.info(\"process_network_ports - iteration:%(iter_num)d - \"",
            "                 \"agent port security group processed in %(elapsed).3f\",",
            "                 {'iter_num': self.iter_num,",
            "                  'elapsed': time.time() - start})",
            "        failed_devices['added'] |= self._bind_devices(need_binding_devices)",
            "",
            "        if 'removed' in port_info and port_info['removed']:",
            "            start = time.time()",
            "            failed_devices['removed'] |= self.treat_devices_removed(",
            "                port_info['removed'])",
            "            LOG.info(\"process_network_ports - iteration:%(iter_num)d - \"",
            "                     \"treat_devices_removed completed in %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'elapsed': time.time() - start})",
            "        if skipped_devices:",
            "            start = time.time()",
            "            self.treat_devices_skipped(skipped_devices)",
            "            LOG.info(\"process_network_ports - iteration:%(iter_num)d - \"",
            "                     \"treat_devices_skipped completed in %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'elapsed': time.time() - start})",
            "        return failed_devices",
            "",
            "    def process_install_ports_egress_flows(self, ports):",
            "        if not self.conf.AGENT.explicitly_egress_direct:",
            "            return",
            "",
            "        if (isinstance(self.sg_agent.firewall,",
            "                       agent_firewall.NoopFirewallDriver) or",
            "                not agent_sg_rpc.is_firewall_enabled()):",
            "            with self.int_br.deferred(full_ordered=True,",
            "                                      use_bundle=True) as int_br:",
            "                for port in ports:",
            "                    try:",
            "                        self.install_accepted_egress_direct_flow(port, int_br)",
            "                        # give other coroutines a chance to run",
            "                        eventlet.sleep(0)",
            "                    except Exception as err:",
            "                        LOG.debug(\"Failed to install accepted egress flows \"",
            "                                  \"for port %s, error: %s\",",
            "                                  port['port_id'], err)",
            "",
            "    def install_accepted_egress_direct_flow(self, port_detail, br_int):",
            "        lvm = self.vlan_manager.get(port_detail['network_id'])",
            "        port = port_detail['vif_port']",
            "",
            "        br_int.add_flow(",
            "            table=constants.TRANSIENT_TABLE,",
            "            priority=9,",
            "            in_port=port.ofport,",
            "            dl_src=port_detail['mac_address'],",
            "            actions='resubmit(,{:d})'.format(",
            "                constants.TRANSIENT_EGRESS_TABLE))",
            "",
            "        br_int.add_flow(",
            "            table=constants.TRANSIENT_EGRESS_TABLE,",
            "            priority=12,",
            "            dl_dst=port_detail['mac_address'],",
            "            actions='output:{:d}'.format(port.ofport))",
            "",
            "        patch_ofport = None",
            "        if lvm.network_type in (",
            "                n_const.TYPE_VXLAN, n_const.TYPE_GRE,",
            "                n_const.TYPE_GENEVE):",
            "            port_name = self.conf.OVS.int_peer_patch_port",
            "            patch_ofport = self.int_br.get_port_ofport(port_name)",
            "        elif lvm.network_type == n_const.TYPE_VLAN:",
            "            bridge = self.bridge_mappings.get(lvm.physical_network)",
            "            port_name = plugin_utils.get_interface_name(",
            "                bridge, prefix=constants.PEER_INTEGRATION_PREFIX)",
            "            patch_ofport = self.int_br.get_port_ofport(port_name)",
            "        if patch_ofport is not None:",
            "            br_int.add_flow(",
            "                table=constants.TRANSIENT_EGRESS_TABLE,",
            "                priority=10,",
            "                dl_src=port_detail['mac_address'],",
            "                dl_dst=\"00:00:00:00:00:00/01:00:00:00:00:00\",",
            "                in_port=port.ofport,",
            "                actions='mod_vlan_vid:{:d},'",
            "                        'output:{:d}'.format(",
            "                            lvm.vlan,",
            "                            patch_ofport))",
            "",
            "    def delete_accepted_egress_direct_flow(self, br_int, ofport, mac, vlan):",
            "        if not self.conf.AGENT.explicitly_egress_direct:",
            "            return",
            "",
            "        br_int.delete_flows(",
            "            table=constants.TRANSIENT_TABLE,",
            "            in_port=ofport,",
            "            dl_src=mac)",
            "        self.delete_flows(",
            "            table=constants.TRANSIENT_EGRESS_TABLE,",
            "            dl_dst=mac)",
            "",
            "        self.delete_flows(",
            "            table=constants.TRANSIENT_EGRESS_TABLE,",
            "            dl_src=mac,",
            "            in_port=ofport)",
            "",
            "    def process_ancillary_network_ports(self, port_info):",
            "        failed_devices = {'added': set(), 'removed': set()}",
            "        if 'added' in port_info and port_info['added']:",
            "            start = time.time()",
            "            failed_added = self.treat_ancillary_devices_added(",
            "                port_info['added'])",
            "            LOG.info(\"process_ancillary_network_ports - iteration: \"",
            "                     \"%(iter_num)d - treat_ancillary_devices_added \"",
            "                     \"completed in %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'elapsed': time.time() - start})",
            "            failed_devices['added'] = failed_added",
            "",
            "        if 'removed' in port_info and port_info['removed']:",
            "            start = time.time()",
            "            failed_removed = self.treat_ancillary_devices_removed(",
            "                port_info['removed'])",
            "            failed_devices['removed'] = failed_removed",
            "",
            "            LOG.info(\"process_ancillary_network_ports - iteration: \"",
            "                     \"%(iter_num)d - treat_ancillary_devices_removed \"",
            "                     \"completed in %(elapsed).3f\",",
            "                     {'iter_num': self.iter_num,",
            "                      'elapsed': time.time() - start})",
            "        return failed_devices",
            "",
            "    @classmethod",
            "    def get_tunnel_hash(cls, ip_address, hashlen):",
            "        try:",
            "            addr = netaddr.IPAddress(ip_address)",
            "            if addr.version == n_const.IP_VERSION_4:",
            "                # We cannot change this from 8, since it could break",
            "                # backwards-compatibility",
            "                return '%08x' % addr",
            "            else:",
            "                # Create 32-bit Base32 encoded hash",
            "                sha1 = hashlib.sha1(ip_address.encode())",
            "                iphash = base64.b32encode(sha1.digest())",
            "                return iphash[:hashlen].decode().lower()",
            "        except Exception:",
            "            LOG.warning(\"Invalid remote IP: %s\", ip_address)",
            "            return",
            "",
            "    def tunnel_sync(self):",
            "        LOG.debug(\"Configuring tunnel endpoints to other OVS agents\")",
            "",
            "        try:",
            "            for tunnel_type in self.tunnel_types:",
            "                details = self.plugin_rpc.tunnel_sync(self.context,",
            "                                                      self.local_ip,",
            "                                                      tunnel_type,",
            "                                                      self.conf.host)",
            "                if not self.l2_pop:",
            "                    tunnels = details['tunnels']",
            "                    for tunnel in tunnels:",
            "                        if self.local_ip != tunnel['ip_address']:",
            "                            remote_ip = tunnel['ip_address']",
            "                            tun_name = self.get_tunnel_name(",
            "                                tunnel_type, self.local_ip, remote_ip)",
            "                            if tun_name is None:",
            "                                continue",
            "                            self._setup_tunnel_port(self.tun_br,",
            "                                                    tun_name,",
            "                                                    tunnel['ip_address'],",
            "                                                    tunnel_type)",
            "                    self._setup_tunnel_flood_flow(self.tun_br, tunnel_type)",
            "        except Exception as e:",
            "            LOG.debug(\"Unable to sync tunnel IP %(local_ip)s: %(e)s\",",
            "                      {'local_ip': self.local_ip, 'e': e})",
            "            return True",
            "        return False",
            "",
            "    @classmethod",
            "    def get_tunnel_name(cls, network_type, local_ip, remote_ip):",
            "        # This string is used to build port and interface names in OVS.",
            "        # Port and interface names can be max 16 characters long,",
            "        # including NULL, and must be unique per table per host.",
            "        # We make the name as long as possible given the network_type,",
            "        # for example, 'vxlan-012345678' or 'geneve-01234567'.",
            "",
            "        # Remove length of network type and dash",
            "        hashlen = n_const.DEVICE_NAME_MAX_LEN - len(network_type) - 1",
            "        remote_tunnel_hash = cls.get_tunnel_hash(remote_ip, hashlen)",
            "        if not remote_tunnel_hash:",
            "            return None",
            "        return '%s-%s' % (network_type, remote_tunnel_hash)",
            "",
            "    def _agent_has_updates(self, polling_manager):",
            "        return (polling_manager.is_polling_required or",
            "                self.updated_ports or",
            "                self.deleted_ports or",
            "                self.deactivated_bindings or",
            "                self.activated_bindings or",
            "                self.updated_smartnic_ports or",
            "                self.sg_agent.firewall_refresh_needed())",
            "",
            "    def _port_info_has_changes(self, port_info):",
            "        return (port_info.get('added') or",
            "                port_info.get('removed') or",
            "                port_info.get('updated'))",
            "",
            "    def check_ovs_status(self):",
            "        try:",
            "            # Check for the canary flow",
            "            status = self.int_br.check_canary_table()",
            "        except Exception:",
            "            LOG.exception(\"Failure while checking for the canary flow\")",
            "            status = constants.OVS_DEAD",
            "        if status == constants.OVS_RESTARTED:",
            "            LOG.warning(\"OVS is restarted. OVSNeutronAgent will reset \"",
            "                        \"bridges and recover ports.\")",
            "        elif status == constants.OVS_DEAD:",
            "            LOG.warning(\"OVS is dead. OVSNeutronAgent will keep running \"",
            "                        \"and checking OVS status periodically.\")",
            "        return status",
            "",
            "    def loop_count_and_wait(self, start_time, port_stats):",
            "        # sleep till end of polling interval",
            "        elapsed = time.time() - start_time",
            "        LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d \"",
            "                 \"completed. Processed ports statistics: \"",
            "                 \"%(port_stats)s. Elapsed:%(elapsed).3f\",",
            "                 {'iter_num': self.iter_num,",
            "                  'port_stats': port_stats,",
            "                  'elapsed': elapsed})",
            "        if elapsed < self.polling_interval:",
            "            time.sleep(self.polling_interval - elapsed)",
            "        else:",
            "            LOG.debug(\"Loop iteration exceeded interval \"",
            "                      \"(%(polling_interval)s vs. %(elapsed)s)!\",",
            "                      {'polling_interval': self.polling_interval,",
            "                       'elapsed': elapsed})",
            "        self.iter_num = self.iter_num + 1",
            "",
            "    def get_port_stats(self, port_info, ancillary_port_info):",
            "        port_stats = {",
            "            'regular': {",
            "                'added': len(port_info.get('added', [])),",
            "                'updated': len(port_info.get('updated', [])),",
            "                'removed': len(port_info.get('removed', []))}}",
            "        if self.ancillary_brs:",
            "            port_stats['ancillary'] = {",
            "                'added': len(ancillary_port_info.get('added', [])),",
            "                'removed': len(ancillary_port_info.get('removed', []))}",
            "        return port_stats",
            "",
            "    def cleanup_stale_flows(self):",
            "        LOG.info(\"Cleaning stale %s flows\", self.int_br.br_name)",
            "        self.int_br.cleanup_flows()",
            "        for pby_br in self.phys_brs.values():",
            "            LOG.info(\"Cleaning stale %s flows\", pby_br.br_name)",
            "            pby_br.cleanup_flows()",
            "",
            "        if self.enable_tunneling:",
            "            LOG.info(\"Cleaning stale %s flows\", self.tun_br.br_name)",
            "            self.tun_br.cleanup_flows()",
            "",
            "    def process_port_info(self, start, polling_manager, sync, ovs_restarted,",
            "                          ports, ancillary_ports, updated_ports_copy,",
            "                          consecutive_resyncs, ports_not_ready_yet,",
            "                          failed_devices, failed_ancillary_devices):",
            "        # There are polling managers that don't have get_events, e.g.",
            "        # AlwaysPoll used by windows implementations",
            "        # REVISIT (rossella_s) This needs to be reworked to hide implementation",
            "        # details regarding polling in BasePollingManager subclasses",
            "        if sync or not (hasattr(polling_manager, 'get_events')):",
            "            if sync:",
            "                LOG.info(\"Agent out of sync with plugin!\")",
            "                consecutive_resyncs = consecutive_resyncs + 1",
            "                if (consecutive_resyncs >=",
            "                        constants.MAX_DEVICE_RETRIES):",
            "                    LOG.warning(",
            "                        \"Clearing cache of registered ports,\"",
            "                        \" retries to resync were > %s\",",
            "                        constants.MAX_DEVICE_RETRIES)",
            "                    ports.clear()",
            "                    ancillary_ports.clear()",
            "                    consecutive_resyncs = 0",
            "            else:",
            "                consecutive_resyncs = 0",
            "                # TODO(rossella_s): For implementations that use AlwaysPoll",
            "                # resync if a device failed. This can be improved in future",
            "                sync = (any(failed_devices.values()) or",
            "                        any(failed_ancillary_devices.values()))",
            "",
            "            # NOTE(rossella_s) don't empty the queue of events",
            "            # calling polling_manager.get_events() since",
            "            # the agent might miss some event (for example a port",
            "            # deletion)",
            "            reg_ports = (set() if ovs_restarted else ports)",
            "            port_info = self.scan_ports(reg_ports, sync,",
            "                                        updated_ports_copy)",
            "            # Treat ancillary devices if they exist",
            "            if self.ancillary_brs:",
            "                ancillary_port_info = self.scan_ancillary_ports(",
            "                    ancillary_ports, sync)",
            "                LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d\"",
            "                         \" - ancillary port info retrieved. \"",
            "                         \"Elapsed:%(elapsed).3f\",",
            "                         {'iter_num': self.iter_num,",
            "                          'elapsed': time.time() - start})",
            "            else:",
            "                ancillary_port_info = {}",
            "",
            "        else:",
            "            consecutive_resyncs = 0",
            "            events = polling_manager.get_events()",
            "            port_info, ancillary_port_info, ports_not_ready_yet = (",
            "                self.process_ports_events(events, ports, ancillary_ports,",
            "                                          ports_not_ready_yet,",
            "                                          failed_devices,",
            "                                          failed_ancillary_devices,",
            "                                          updated_ports_copy))",
            "            registry.notify(",
            "                constants.OVSDB_RESOURCE,",
            "                callback_events.AFTER_READ,",
            "                self,",
            "                ovsdb_events=events)",
            "",
            "        return (port_info, ancillary_port_info, consecutive_resyncs,",
            "                ports_not_ready_yet)",
            "",
            "    def _remove_devices_not_to_retry(self, failed_devices,",
            "                                     failed_ancillary_devices,",
            "                                     devices_not_to_retry,",
            "                                     ancillary_devices_not_to_retry):",
            "        \"\"\"This method removes the devices that exceeded the number of retries",
            "           from failed_devices and failed_ancillary_devices",
            "",
            "        \"\"\"",
            "        for event in ['added', 'removed']:",
            "            failed_devices[event] = (",
            "                failed_devices[event] - devices_not_to_retry[event])",
            "            failed_ancillary_devices[event] = (",
            "                failed_ancillary_devices[event] -",
            "                ancillary_devices_not_to_retry[event])",
            "",
            "    def _get_devices_not_to_retry(self, failed_devices,",
            "                                  failed_ancillary_devices,",
            "                                  failed_devices_retries_map):",
            "        \"\"\"Return the devices not to retry and update the retries map\"\"\"",
            "        new_failed_devices_retries_map = {}",
            "        devices_not_to_retry = {}",
            "        ancillary_devices_not_to_retry = {}",
            "",
            "        def _increase_retries(devices_set):",
            "            devices_not_to_retry = set()",
            "            for dev in devices_set:",
            "                retries = failed_devices_retries_map.get(dev, 0)",
            "                if retries >= constants.MAX_DEVICE_RETRIES:",
            "                    devices_not_to_retry.add(dev)",
            "                    LOG.warning(",
            "                        \"Device %(dev)s failed for %(times)s times and won't \"",
            "                        \"be retried anymore\", {",
            "                            'dev': dev, 'times': constants.MAX_DEVICE_RETRIES})",
            "                else:",
            "                    new_failed_devices_retries_map[dev] = retries + 1",
            "            return devices_not_to_retry",
            "",
            "        for event in ['added', 'removed']:",
            "            devices_not_to_retry[event] = _increase_retries(",
            "                failed_devices[event])",
            "            ancillary_devices_not_to_retry[event] = _increase_retries(",
            "                failed_ancillary_devices[event])",
            "",
            "        return (new_failed_devices_retries_map, devices_not_to_retry,",
            "                ancillary_devices_not_to_retry)",
            "",
            "    def update_retries_map_and_remove_devs_not_to_retry(",
            "            self, failed_devices, failed_ancillary_devices,",
            "            failed_devices_retries_map):",
            "        (new_failed_devices_retries_map, devices_not_to_retry,",
            "         ancillary_devices_not_to_retry) = self._get_devices_not_to_retry(",
            "            failed_devices, failed_ancillary_devices,",
            "            failed_devices_retries_map)",
            "        self._remove_devices_not_to_retry(",
            "            failed_devices, failed_ancillary_devices, devices_not_to_retry,",
            "            ancillary_devices_not_to_retry)",
            "        return new_failed_devices_retries_map",
            "",
            "    def _handle_ovs_restart(self, polling_manager):",
            "        self.setup_integration_br()",
            "        self.setup_physical_bridges(self.bridge_mappings)",
            "        if self.enable_tunneling:",
            "            self._reset_tunnel_ofports()",
            "            self.setup_tunnel_br()",
            "            self.setup_tunnel_br_flows()",
            "            self.agent_state['start_flag'] = True",
            "            # Force state report to avoid race condition",
            "            # with l2pop fdb entries update",
            "            self._report_state()",
            "        if self.enable_distributed_routing:",
            "            self.dvr_agent.reset_dvr_flows(",
            "                self.int_br, self.tun_br, self.phys_brs,",
            "                self.patch_int_ofport, self.patch_tun_ofport)",
            "        # notify that OVS has restarted",
            "        registry.publish(",
            "            callback_resources.AGENT,",
            "            callback_events.OVS_RESTARTED,",
            "            self, payload=None)",
            "        # restart the polling manager so that it will signal as added",
            "        # all the current ports",
            "        # REVISIT (rossella_s) Define a method \"reset\" in",
            "        # BasePollingManager that will be implemented by AlwaysPoll as",
            "        # no action and by InterfacePollingMinimizer as start/stop",
            "        if isinstance(polling_manager, polling.InterfacePollingMinimizer):",
            "            polling_manager.stop()",
            "            polling_manager.start()",
            "",
            "    def rpc_loop(self, polling_manager):",
            "        idl_monitor = self.ovs.ovsdb.idl_monitor",
            "        sync = False",
            "        ports = set()",
            "        updated_ports_copy = set()",
            "        activated_bindings_copy = set()",
            "        ancillary_ports = set()",
            "        tunnel_sync = True",
            "        ovs_restarted = False",
            "        consecutive_resyncs = 0",
            "        need_clean_stale_flow = True",
            "        ports_not_ready_yet = set()",
            "        failed_devices = {'added': set(), 'removed': set()}",
            "        failed_ancillary_devices = {'added': set(), 'removed': set()}",
            "        failed_devices_retries_map = {}",
            "        while self._check_and_handle_signal():",
            "            if self.fullsync:",
            "                LOG.info(\"rpc_loop doing a full sync.\")",
            "                sync = True",
            "                self.fullsync = False",
            "            port_info = {}",
            "            ancillary_port_info = {}",
            "            start = time.time()",
            "            LOG.info(\"Agent rpc_loop - iteration:%d started\",",
            "                     self.iter_num)",
            "            ovs_status = self.check_ovs_status()",
            "            bridges_recreated = False",
            "            if ovs_status == constants.OVS_RESTARTED:",
            "                self._handle_ovs_restart(polling_manager)",
            "                tunnel_sync = self.enable_tunneling or tunnel_sync",
            "            elif ovs_status == constants.OVS_DEAD:",
            "                # Agent doesn't apply any operations when ovs is dead, to",
            "                # prevent unexpected failure or crash. Sleep and continue",
            "                # loop in which ovs status will be checked periodically.",
            "                port_stats = self.get_port_stats({}, {})",
            "                self.loop_count_and_wait(start, port_stats)",
            "                continue",
            "            else:",
            "                # Check if any physical bridge wasn't recreated recently,",
            "                # in case when openvswitch was restarted, it's not needed",
            "                added_bridges = idl_monitor.bridges_added + self.added_bridges",
            "                bridges_recreated = self._reconfigure_physical_bridges(",
            "                    added_bridges)",
            "                if bridges_recreated:",
            "                    # In case when any bridge was \"re-created\", we need to",
            "                    # ensure that there is no any stale flows in bridges left",
            "                    need_clean_stale_flow = True",
            "                sync |= bridges_recreated",
            "            # Notify the plugin of tunnel IP",
            "            if self.enable_tunneling and tunnel_sync:",
            "                try:",
            "                    tunnel_sync = self.tunnel_sync()",
            "                except Exception:",
            "                    LOG.exception(\"Error while configuring tunnel endpoints\")",
            "                    tunnel_sync = True",
            "            ovs_restarted |= (ovs_status == constants.OVS_RESTARTED)",
            "            devices_need_retry = (any(failed_devices.values()) or",
            "                                  any(failed_ancillary_devices.values()) or",
            "                                  ports_not_ready_yet)",
            "            if (self._agent_has_updates(polling_manager) or sync or",
            "                    devices_need_retry):",
            "                try:",
            "                    LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d - \"",
            "                             \"starting polling. Elapsed:%(elapsed).3f\",",
            "                             {'iter_num': self.iter_num,",
            "                              'elapsed': time.time() - start})",
            "",
            "                    if self.conf.AGENT.baremetal_smartnic:",
            "                        if sync:",
            "                            self.process_smartnic_ports()",
            "                        updated_smartnic_ports_copy = (",
            "                            self.updated_smartnic_ports)",
            "                        self.updated_smartnic_ports = list()",
            "                        for port_data in updated_smartnic_ports_copy:",
            "                            self.treat_smartnic_port(port_data)",
            "",
            "                    # Save updated ports dict to perform rollback in",
            "                    # case resync would be needed, and then clear",
            "                    # self.updated_ports. As the greenthread should not yield",
            "                    # between these two statements, this will be thread-safe",
            "                    updated_ports_copy = self.updated_ports",
            "                    self.updated_ports = set()",
            "                    activated_bindings_copy = self.activated_bindings",
            "                    self.activated_bindings = set()",
            "                    (port_info, ancillary_port_info, consecutive_resyncs,",
            "                     ports_not_ready_yet) = (self.process_port_info(",
            "                            start, polling_manager, sync, ovs_restarted,",
            "                            ports, ancillary_ports, updated_ports_copy,",
            "                            consecutive_resyncs, ports_not_ready_yet,",
            "                            failed_devices, failed_ancillary_devices))",
            "                    sync = False",
            "                    self.process_deleted_ports(port_info)",
            "                    self.process_deactivated_bindings(port_info)",
            "                    self.process_activated_bindings(port_info,",
            "                                                    activated_bindings_copy)",
            "                    ofport_changed_ports = self.update_stale_ofport_rules()",
            "                    if ofport_changed_ports:",
            "                        port_info.setdefault('updated', set()).update(",
            "                            ofport_changed_ports)",
            "                    LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d - \"",
            "                             \"port information retrieved. \"",
            "                             \"Elapsed:%(elapsed).3f\",",
            "                             {'iter_num': self.iter_num,",
            "                              'elapsed': time.time() - start})",
            "                    # Secure and wire/unwire VIFs and update their status",
            "                    # on Neutron server",
            "                    if (self._port_info_has_changes(port_info) or",
            "                            self.sg_agent.firewall_refresh_needed() or",
            "                            ovs_restarted):",
            "                        LOG.debug(\"Starting to process devices in:%s\",",
            "                                  port_info)",
            "                        provisioning_needed = (",
            "                                ovs_restarted or bridges_recreated)",
            "                        failed_devices = self.process_network_ports(",
            "                            port_info, provisioning_needed)",
            "                        LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d - \"",
            "                                 \"ports processed. Elapsed:%(elapsed).3f\",",
            "                                 {'iter_num': self.iter_num,",
            "                                  'elapsed': time.time() - start})",
            "",
            "                    if need_clean_stale_flow:",
            "                        self.cleanup_stale_flows()",
            "                        need_clean_stale_flow = False",
            "                        LOG.info(\"Agent rpc_loop - iteration:%(iter_num)d - \"",
            "                                 \"cleanup stale flows. Elapsed:%(elapsed).3f\",",
            "                                 {'iter_num': self.iter_num,",
            "                                  'elapsed': time.time() - start})",
            "",
            "                    ports = port_info['current']",
            "",
            "                    if self.ancillary_brs:",
            "                        failed_ancillary_devices = (",
            "                            self.process_ancillary_network_ports(",
            "                                ancillary_port_info))",
            "                        LOG.info(\"Agent rpc_loop - iteration: \"",
            "                                 \"%(iter_num)d - ancillary ports \"",
            "                                 \"processed. Elapsed:%(elapsed).3f\",",
            "                                 {'iter_num': self.iter_num,",
            "                                  'elapsed': time.time() - start})",
            "                        ancillary_ports = ancillary_port_info['current']",
            "",
            "                    polling_manager.polling_completed()",
            "                    failed_devices_retries_map = (",
            "                        self.update_retries_map_and_remove_devs_not_to_retry(",
            "                            failed_devices, failed_ancillary_devices,",
            "                            failed_devices_retries_map))",
            "                    # Keep this flag in the last line of \"try\" block,",
            "                    # so we can sure that no other Exception occurred.",
            "                    ovs_restarted = False",
            "                    self._dispose_local_vlan_hints()",
            "                except Exception:",
            "                    LOG.exception(\"Error while processing VIF ports\")",
            "                    # Put the ports back in self.updated_port",
            "                    self.updated_ports |= updated_ports_copy",
            "                    self.activated_bindings |= activated_bindings_copy",
            "                    sync = True",
            "            port_stats = self.get_port_stats(port_info, ancillary_port_info)",
            "            self.loop_count_and_wait(start, port_stats)",
            "",
            "    def daemon_loop(self):",
            "        # Start everything.",
            "        LOG.info(\"Agent initialized successfully, now running... \")",
            "        signal.signal(signal.SIGTERM, self._handle_sigterm)",
            "        if hasattr(signal, 'SIGHUP'):",
            "            signal.signal(signal.SIGHUP, self._handle_sighup)",
            "        br_names = [br.br_name for br in self.phys_brs.values()]",
            "",
            "        self.ovs.ovsdb.idl_monitor.start_bridge_monitor(br_names)",
            "        with polling.get_polling_manager(",
            "                self.minimize_polling,",
            "                self.ovsdb_monitor_respawn_interval) as pm:",
            "            self.rpc_loop(polling_manager=pm)",
            "",
            "    def _handle_sigterm(self, signum, frame):",
            "        self.catch_sigterm = True",
            "        if self.quitting_rpc_timeout:",
            "            LOG.info(",
            "                'SIGTERM received, capping RPC timeout by %d seconds.',",
            "                self.quitting_rpc_timeout)",
            "            self.set_rpc_timeout(self.quitting_rpc_timeout)",
            "",
            "    def _handle_sighup(self, signum, frame):",
            "        self.catch_sighup = True",
            "",
            "    def _check_and_handle_signal(self):",
            "        if self.catch_sigterm:",
            "            LOG.info(\"Agent caught SIGTERM, quitting daemon loop.\")",
            "            self.run_daemon_loop = False",
            "            self.catch_sigterm = False",
            "        if self.catch_sighup:",
            "            LOG.info(\"Agent caught SIGHUP, resetting.\")",
            "            self.conf.mutate_config_files()",
            "            config.setup_logging()",
            "            LOG.debug('Full set of CONF:')",
            "            self.conf.log_opt_values(LOG, logging.DEBUG)",
            "            self.catch_sighup = False",
            "        return self.run_daemon_loop",
            "",
            "    def set_rpc_timeout(self, timeout):",
            "        for rpc_api in (self.plugin_rpc, self.sg_plugin_rpc,",
            "                        self.dvr_plugin_rpc, self.state_rpc):",
            "            rpc_api.client.set_max_timeout(timeout)",
            "",
            "    def _check_agent_configurations(self):",
            "        if (self.enable_distributed_routing and self.enable_tunneling and",
            "                not self.l2_pop):",
            "",
            "            raise ValueError(_(\"DVR deployments for VXLAN/GRE/Geneve \"",
            "                               \"underlays require L2-pop to be enabled, \"",
            "                               \"in both the Agent and Server side.\"))",
            "",
            "",
            "def validate_local_ip(local_ip):",
            "    \"\"\"Verify if the ip exists on the agent's host.\"\"\"",
            "    if not ip_lib.IPWrapper().get_device_by_ip(local_ip):",
            "        LOG.error(\"Tunneling can't be enabled with invalid local_ip '%s'.\"",
            "                  \" IP couldn't be found on this host's interfaces.\",",
            "                  local_ip)",
            "        raise SystemExit(1)",
            "",
            "",
            "def validate_tunnel_config(tunnel_types, local_ip):",
            "    \"\"\"Verify local ip and tunnel config if tunneling is enabled.\"\"\"",
            "    if not tunnel_types:",
            "        return",
            "",
            "    validate_local_ip(local_ip)",
            "    for tun in tunnel_types:",
            "        if tun not in constants.TUNNEL_NETWORK_TYPES:",
            "            LOG.error('Invalid tunnel type specified: %s', tun)",
            "            raise SystemExit(1)",
            "",
            "",
            "def prepare_xen_compute():",
            "    is_xen_compute_host = 'rootwrap-xen-dom0' in cfg.CONF.AGENT.root_helper \\",
            "        or xenapi_root_helper.ROOT_HELPER_DAEMON_TOKEN == \\",
            "        cfg.CONF.AGENT.root_helper_daemon",
            "    if is_xen_compute_host:",
            "        xenapi_conf.register_xenapi_opts()",
            "        # Force ip_lib to always use the root helper to ensure that ip",
            "        # commands target xen dom0 rather than domU.",
            "        cfg.CONF.register_opts(ip_lib.OPTS)",
            "        cfg.CONF.set_default('ip_lib_force_root', True)",
            "",
            "",
            "def main(bridge_classes):",
            "    prepare_xen_compute()",
            "    ovs_capabilities.register()",
            "    ext_manager.register_opts(cfg.CONF)",
            "    agent_config.setup_privsep()",
            "    service_conf.register_service_opts(service_conf.RPC_EXTRA_OPTS, cfg.CONF)",
            "",
            "    ext_mgr = ext_manager.L2AgentExtensionsManager(cfg.CONF)",
            "",
            "    # now that all extensions registered their options, we can log them",
            "    n_utils.log_opt_values(LOG)",
            "",
            "    validate_tunnel_config(cfg.CONF.AGENT.tunnel_types, cfg.CONF.OVS.local_ip)",
            "",
            "    init_try = 1",
            "    while True:",
            "        try:",
            "            agent = OVSNeutronAgent(bridge_classes, ext_mgr, cfg.CONF)",
            "            capabilities.notify_init_event(n_const.AGENT_TYPE_OVS, agent)",
            "            break",
            "        except ovs_exceptions.TimeoutException as e:",
            "            if init_try < INIT_MAX_TRIES:",
            "                LOG.warning(\"Ovsdb command timeout!\")",
            "                init_try += 1",
            "            else:",
            "                LOG.error(\"%(err)s agent terminated after %(attempts)s \"",
            "                          \"initialization attempts!\",",
            "                          {'err': e, 'attempts': init_try})",
            "                sys.exit(1)",
            "        except (RuntimeError, ValueError) as e:",
            "            LOG.error(\"%s agent terminated!\", e)",
            "            sys.exit(1)",
            "    agent.daemon_loop()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1945": [
                "OVSNeutronAgent",
                "treat_devices_added_or_updated"
            ],
            "1961": [
                "OVSNeutronAgent",
                "treat_devices_added_or_updated"
            ],
            "2057": [
                "OVSNeutronAgent",
                "process_network_ports"
            ],
            "2082": [
                "OVSNeutronAgent",
                "process_network_ports"
            ],
            "2084": [
                "OVSNeutronAgent",
                "process_network_ports"
            ],
            "2085": [
                "OVSNeutronAgent",
                "process_network_ports"
            ]
        },
        "addLocation": [
            "neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent.test_ovs_neutron_agent.TestOvsNeutronAgent.test_agent_type_ovs",
            "neutron.plugins.ml2.drivers.openvswitch.agent.ovs_neutron_agent.OVSNeutronAgent.treat_devices_added_or_updated.skipped_devices",
            "neutron.plugins.ml2.drivers.openvswitch.agent.ovs_neutron_agent.OVSNeutronAgent.treat_devices_added_or_updated.need_binding_devices",
            "neutron.plugins.ml2.drivers.openvswitch.agent.ovs_neutron_agent.OVSNeutronAgent.process_network_ports"
        ]
    },
    "neutron/tests/unit/agent/common/test_ovs_lib.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": 498,
                "PatchRowcode": "         self.br.ovsdb.list_ports.return_value.execute.return_value = ["
            },
            "1": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": 499,
                "PatchRowcode": "             'qvo1', 'qvo2', 'qvo4']"
            },
            "2": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": 500,
                "PatchRowcode": "         by_id = self.br.get_vifs_by_ids(['pid1', 'pid2', 'pid3', 'pid4'])"
            },
            "3": {
                "beforePatchRowNumber": 501,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # pid3 isn't on bridge and pid4 doesn't have a valid ofport"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+        # pid3 isn't on bridge"
            },
            "5": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": 502,
                "PatchRowcode": "         self.assertIsNone(by_id['pid3'])"
            },
            "6": {
                "beforePatchRowNumber": 503,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertIsNone(by_id['pid4'])"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 503,
                "PatchRowcode": "+        self.assertEqual(-1, by_id['pid4'].ofport)"
            },
            "8": {
                "beforePatchRowNumber": 504,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "         self.assertEqual('pid1', by_id['pid1'].vif_id)"
            },
            "9": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": 505,
                "PatchRowcode": "         self.assertEqual('qvo1', by_id['pid1'].port_name)"
            },
            "10": {
                "beforePatchRowNumber": 506,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "         self.assertEqual(1, by_id['pid1'].ofport)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012, VMware, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "from unittest import mock",
            "",
            "from neutron_lib import exceptions",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import uuidutils",
            "import tenacity",
            "import testtools",
            "",
            "from neutron.agent.common import ovs_lib",
            "from neutron.agent.common import utils",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common \\",
            "    import constants as p_const",
            "from neutron.tests import base",
            "",
            "",
            "class OFCTLParamListMatcher(object):",
            "",
            "    def _parse(self, params):",
            "        actions_pos = params.find('actions')",
            "        return set(params[:actions_pos].split(',')), params[actions_pos:]",
            "",
            "    def __init__(self, params):",
            "        self.expected = self._parse(params)",
            "",
            "    def __eq__(self, other):",
            "        return self.expected == self._parse(other)",
            "",
            "    def __str__(self):",
            "        return 'ovs-ofctl parameters: %s, \"%s\"' % self.expected",
            "",
            "    __repr__ = __str__",
            "",
            "",
            "class StringSetMatcher(object):",
            "    \"\"\"A helper object for unordered CSV strings",
            "",
            "    Will compare equal if both strings, when read as a comma-separated set",
            "    of values, represent the same set.",
            "",
            "    Example: \"a,b,45\" == \"b,45,a\"",
            "    \"\"\"",
            "    def __init__(self, string, separator=','):",
            "        self.separator = separator",
            "        self.set = set(string.split(self.separator))",
            "",
            "    def __eq__(self, other):",
            "        return self.set == set(other.split(self.separator))",
            "",
            "    def __ne__(self, other):",
            "        return self.set != set(other.split(self.separator))",
            "",
            "    def __repr__(self):",
            "        sep = '' if self.separator == ',' else \" on %s\" % self.separator",
            "        return '<comma-separated string for %s%s>' % (self.set, sep)",
            "",
            "",
            "class OVS_Lib_Test(base.BaseTestCase):",
            "    \"\"\"A test suite to exercise the OVS libraries shared by Neutron agents.",
            "",
            "    Note: these tests do not actually execute ovs-* utilities, and thus",
            "    can run on any system.  That does, however, limit their scope.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(OVS_Lib_Test, self).setUp()",
            "        self.BR_NAME = \"br-int\"",
            "",
            "        # Don't attempt to connect to ovsdb",
            "        mock.patch('neutron.agent.ovsdb.impl_idl.api_factory').start()",
            "        self.br = ovs_lib.OVSBridge(self.BR_NAME)",
            "        self.execute = mock.patch.object(",
            "            utils, \"execute\", spec=utils.execute).start()",
            "",
            "    def test_vifport(self):",
            "        \"\"\"Create and stringify vif port, confirm no exceptions.\"\"\"",
            "",
            "        pname = \"vif1.0\"",
            "        ofport = 5",
            "        vif_id = uuidutils.generate_uuid()",
            "        mac = \"ca:fe:de:ad:be:ef\"",
            "",
            "        # test __init__",
            "        port = ovs_lib.VifPort(pname, ofport, vif_id, mac, self.br)",
            "        self.assertEqual(port.port_name, pname)",
            "        self.assertEqual(port.ofport, ofport)",
            "        self.assertEqual(port.vif_id, vif_id)",
            "        self.assertEqual(port.vif_mac, mac)",
            "        self.assertEqual(port.switch.br_name, self.BR_NAME)",
            "",
            "        # test __str__",
            "        str(port)",
            "",
            "    def test_add_flow(self):",
            "        ofport = \"99\"",
            "        vid = 4000",
            "        lsw_id = 18",
            "        cidr = '192.168.1.0/24'",
            "",
            "        flow_dict_1 = collections.OrderedDict([",
            "            ('cookie', 1234),",
            "            ('priority', 2),",
            "            ('dl_src', 'ca:fe:de:ad:be:ef'),",
            "            ('actions', 'strip_vlan,output:0')])",
            "        flow_dict_2 = collections.OrderedDict([",
            "            ('cookie', 1254),",
            "            ('priority', 1),",
            "            ('actions', 'normal')])",
            "        flow_dict_3 = collections.OrderedDict([",
            "            ('cookie', 1257),",
            "            ('priority', 2),",
            "            ('actions', 'drop')])",
            "        flow_dict_4 = collections.OrderedDict([",
            "            ('cookie', 1274),",
            "            ('priority', 2),",
            "            ('in_port', ofport),",
            "            ('actions', 'drop')])",
            "        flow_dict_5 = collections.OrderedDict([",
            "            ('cookie', 1284),",
            "            ('priority', 4),",
            "            ('in_port', ofport),",
            "            ('dl_vlan', vid),",
            "            ('actions', \"strip_vlan,set_tunnel:%s,normal\" % (lsw_id))])",
            "        flow_dict_6 = collections.OrderedDict([",
            "            ('cookie', 1754),",
            "            ('priority', 3),",
            "            ('tun_id', lsw_id),",
            "            ('actions', \"mod_vlan_vid:%s,output:%s\" % (vid, ofport))])",
            "        flow_dict_7 = collections.OrderedDict([",
            "            ('cookie', 1256),",
            "            ('priority', 4),",
            "            ('nw_src', cidr),",
            "            ('proto', 'arp'),",
            "            ('actions', 'drop')])",
            "",
            "        self.br.add_flow(**flow_dict_1)",
            "        self.br.add_flow(**flow_dict_2)",
            "        self.br.add_flow(**flow_dict_3)",
            "        self.br.add_flow(**flow_dict_4)",
            "        self.br.add_flow(**flow_dict_5)",
            "        self.br.add_flow(**flow_dict_6)",
            "        self.br.add_flow(**flow_dict_7)",
            "        expected_calls = [",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1234,\"",
            "                                 \"priority=2,dl_src=ca:fe:de:ad:be:ef,\"",
            "                                 \"actions=strip_vlan,output:0\")),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1254,\"",
            "                                 \"priority=1,actions=normal\")),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1257,\"",
            "                                 \"priority=2,actions=drop\")),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1274,\"",
            "                                 \"priority=2,in_port=%s,actions=drop\" % ofport",
            "                             )),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1284,\"",
            "                                 \"priority=4,dl_vlan=%s,in_port=%s,\"",
            "                                 \"actions=strip_vlan,set_tunnel:%s,normal\" %",
            "                                 (vid, ofport, lsw_id))),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1754,\"",
            "                                 \"priority=3,\"",
            "                                 \"tun_id=%s,actions=mod_vlan_vid:%s,output:%s\"",
            "                                 % (lsw_id, vid, ofport))),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1256,\"",
            "                                 \"priority=4,nw_src=%s,arp,actions=drop\"",
            "                                 % cidr)),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def _ofctl_args(self, cmd, *args):",
            "        cmd = ['ovs-ofctl', cmd, '-O', self.br._highest_protocol_needed]",
            "        cmd += args",
            "        return cmd",
            "",
            "    def _ofctl_mock(self, cmd, *args, **kwargs):",
            "        cmd = self._ofctl_args(cmd, *args)",
            "        return mock.call(cmd, run_as_root=True, **kwargs)",
            "",
            "    def _verify_ofctl_mock(self, cmd, *args, **kwargs):",
            "        cmd = self._ofctl_args(cmd, *args)",
            "        return self.execute.assert_called_once_with(cmd, run_as_root=True,",
            "                                                    **kwargs)",
            "",
            "    def test_add_flow_timeout_set(self):",
            "        flow_dict = collections.OrderedDict([",
            "            ('cookie', 1234),",
            "            ('priority', 1),",
            "            ('hard_timeout', 1000),",
            "            ('idle_timeout', 2000),",
            "            ('actions', 'normal')])",
            "",
            "        self.br.add_flow(**flow_dict)",
            "        self._verify_ofctl_mock(",
            "            \"add-flows\", self.BR_NAME, '-',",
            "            process_input=\"hard_timeout=1000,idle_timeout=2000,\"",
            "                          \"priority=1,cookie=1234,actions=normal\")",
            "",
            "    def test_add_flow_default_priority(self):",
            "        flow_dict = collections.OrderedDict([('actions', 'normal'),",
            "                                             ('cookie', 1234)])",
            "",
            "        self.br.add_flow(**flow_dict)",
            "        self._verify_ofctl_mock(",
            "            \"add-flows\", self.BR_NAME, '-',",
            "            process_input=\"hard_timeout=0,idle_timeout=0,priority=1,\"",
            "                          \"cookie=1234,actions=normal\")",
            "",
            "    def test_default_datapath(self):",
            "        # verify kernel datapath is default",
            "        expected = p_const.OVS_DATAPATH_SYSTEM",
            "        self.assertEqual(expected, self.br.datapath_type)",
            "",
            "    def test_non_default_datapath(self):",
            "        expected = p_const.OVS_DATAPATH_NETDEV",
            "        self.br = ovs_lib.OVSBridge(self.BR_NAME, datapath_type=expected)",
            "        br2 = self.br.add_bridge('another-br', datapath_type=expected)",
            "        self.assertEqual(expected, self.br.datapath_type)",
            "        self.assertEqual(expected, br2.datapath_type)",
            "",
            "    def test_count_flows(self):",
            "        self.execute.return_value = 'ignore\\nflow-1\\n'",
            "        # counts the number of flows as total lines of output - 2",
            "        self.assertEqual(self.br.count_flows(), 1)",
            "        self._verify_ofctl_mock(\"dump-flows\", self.BR_NAME, process_input=None)",
            "",
            "    def test_delete_flow(self):",
            "        ofport = 5",
            "        lsw_id = 40",
            "        vid = 39",
            "        self.br.delete_flows(in_port=ofport)",
            "        self.br.delete_flows(tun_id=lsw_id)",
            "        self.br.delete_flows(dl_vlan=vid)",
            "        self.br.delete_flows()",
            "        cookie_spec = \"cookie=%s/-1\" % self.br._default_cookie",
            "        expected_calls = [",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s,in_port=%d\" % (cookie_spec, ofport))),",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s,tun_id=%s\" % (cookie_spec, lsw_id))),",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s,dl_vlan=%s\" % (cookie_spec, vid))),",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=\"%s\" % cookie_spec),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def test_delete_flows_cookie_nomask(self):",
            "        self.br.delete_flows(cookie=42)",
            "        self.execute.assert_has_calls([",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=\"cookie=42/-1\"),",
            "        ])",
            "",
            "    def test_do_action_flows_delete_flows(self):",
            "        # test what the deferred bridge implementation calls, in the case of a",
            "        # delete_flows(cookie=ovs_lib.COOKIE_ANY) among calls to",
            "        # delete_flows(foo=bar)",
            "        self.br.do_action_flows('del', [{'in_port': 5},",
            "                                        {'cookie': ovs_lib.COOKIE_ANY}])",
            "        expected_calls = [",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME,",
            "                             process_input=None),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def test_delete_flows_any_cookie(self):",
            "        self.br.delete_flows(in_port=5, cookie=ovs_lib.COOKIE_ANY)",
            "        self.br.delete_flows(cookie=ovs_lib.COOKIE_ANY)",
            "        expected_calls = [",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=\"in_port=5\"),",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME,",
            "                             process_input=None),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def test_mod_delete_flows_strict(self):",
            "        self.br.delete_flows(in_port=5, priority=1, strict=True)",
            "        self.br.mod_flow(in_port=5, priority=1, strict=True, actions='drop')",
            "        cookie_spec = \"cookie=%s\" % self.br._default_cookie",
            "        expected_calls = [",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '--strict', '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s/-1,in_port=5,priority=1\" % cookie_spec)),",
            "            self._ofctl_mock(\"mod-flows\", self.BR_NAME, '--strict', '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s,in_port=5,priority=1,actions=drop\" %",
            "                                 cookie_spec)),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def test_mod_delete_flows_priority_without_strict(self):",
            "        self.assertRaises(exceptions.InvalidInput,",
            "                          self.br.delete_flows,",
            "                          in_port=5, priority=1)",
            "",
            "    def test_mod_delete_flows_mixed_strict(self):",
            "        deferred_br = self.br.deferred()",
            "        deferred_br.delete_flows(in_port=5)",
            "        deferred_br.delete_flows(in_port=5, priority=1, strict=True)",
            "        self.assertRaises(exceptions.InvalidInput,",
            "                          deferred_br.apply_flows)",
            "",
            "    def test_dump_flows(self):",
            "        table = 23",
            "        nxst_flow = \"NXST_FLOW reply (xid=0x4):\"",
            "        flows = \"\\n\".join([\" cookie=0x0, duration=18042.514s, table=0, \"",
            "                           \"n_packets=6, n_bytes=468, \"",
            "                           \"priority=2,in_port=1 actions=drop\",",
            "                           \" cookie=0x0, duration=18027.562s, table=0, \"",
            "                           \"n_packets=0, n_bytes=0, \"",
            "                           \"priority=3,in_port=1,dl_vlan=100 \"",
            "                           \"actions=mod_vlan_vid:1,NORMAL\",",
            "                           \" cookie=0x0, duration=18044.351s, table=0, \"",
            "                           \"n_packets=9, n_bytes=594, priority=1 \"",
            "                           \"actions=NORMAL\", \" cookie=0x0, \"",
            "                           \"duration=18044.211s, table=23, n_packets=0, \"",
            "                           \"n_bytes=0, priority=0 actions=drop\"])",
            "        flow_args = '\\n'.join([nxst_flow, flows])",
            "        run_ofctl = mock.patch.object(self.br, 'run_ofctl').start()",
            "        run_ofctl.side_effect = [flow_args]",
            "        retflows = self.br.dump_flows_for_table(table)",
            "        self.assertEqual(flows, retflows)",
            "",
            "    def test_dump_flows_ovs_dead(self):",
            "        table = 23",
            "        run_ofctl = mock.patch.object(self.br, 'run_ofctl').start()",
            "        run_ofctl.side_effect = ['']",
            "        retflows = self.br.dump_flows_for_table(table)",
            "        self.assertIsNone(retflows)",
            "",
            "    def test_mod_flow_with_priority_set(self):",
            "        params = {'in_port': '1',",
            "                  'priority': '1'}",
            "",
            "        self.assertRaises(exceptions.InvalidInput,",
            "                          self.br.mod_flow,",
            "                          **params)",
            "",
            "    def test_mod_flow_no_actions_set(self):",
            "        params = {'in_port': '1'}",
            "",
            "        self.assertRaises(exceptions.InvalidInput,",
            "                          self.br.mod_flow,",
            "                          **params)",
            "",
            "    def test_run_ofctl_retry_on_socket_error(self):",
            "        err = RuntimeError('failed to connect to socket')",
            "        self.execute.side_effect = [err] * 5",
            "        with mock.patch('time.sleep') as sleep:",
            "            self.br.run_ofctl('add-flows', [])",
            "        self.assertEqual(5, sleep.call_count)",
            "        self.assertEqual(6, self.execute.call_count)",
            "        # a regular exception fails right away",
            "        self.execute.side_effect = RuntimeError('garbage')",
            "        self.execute.reset_mock()",
            "        with mock.patch('time.sleep') as sleep:",
            "            self.br.run_ofctl('add-flows', [])",
            "        self.assertEqual(0, sleep.call_count)",
            "        self.assertEqual(1, self.execute.call_count)",
            "",
            "    def _encode_ovs_json(self, headings, data):",
            "        # See man ovs-vsctl(8) for the encoding details.",
            "        r = {\"data\": [],",
            "             \"headings\": headings}",
            "        for row in data:",
            "            ovs_row = []",
            "            r[\"data\"].append(ovs_row)",
            "            for cell in row:",
            "                if isinstance(cell, (str, int, list)):",
            "                    ovs_row.append(cell)",
            "                elif isinstance(cell, dict):",
            "                    ovs_row.append([\"map\", cell.items()])",
            "                elif isinstance(cell, set):",
            "                    ovs_row.append([\"set\", cell])",
            "                else:",
            "                    raise TypeError('%r not int, str, list, set or dict' %",
            "                                    type(cell))",
            "        return jsonutils.dumps(r)",
            "",
            "    def test_get_vif_ports(self):",
            "        pname = \"tap99\"",
            "        ofport = 6",
            "        vif_id = uuidutils.generate_uuid()",
            "        mac = \"ca:fe:de:ad:be:ef\"",
            "        id_field = 'iface-id'",
            "        external_ids = {\"attached-mac\": mac, id_field: vif_id}",
            "        self.br.get_ports_attributes = mock.Mock(return_value=[{",
            "            'name': pname, 'ofport': ofport, 'external_ids': external_ids}])",
            "",
            "        ports = self.br.get_vif_ports()",
            "        self.assertEqual(1, len(ports))",
            "        self.assertEqual(ports[0].port_name, pname)",
            "        self.assertEqual(ports[0].ofport, ofport)",
            "        self.assertEqual(ports[0].vif_id, vif_id)",
            "        self.assertEqual(ports[0].vif_mac, mac)",
            "        self.assertEqual(ports[0].switch.br_name, self.BR_NAME)",
            "        self.br.get_ports_attributes.assert_called_once_with(",
            "            'Interface',",
            "            columns=['name', 'external_ids', 'ofport'],",
            "            if_exists=True)",
            "",
            "    def test_delete_all_ports(self):",
            "        with mock.patch.object(self.br, 'get_port_name_list',",
            "                               return_value=['port1']) as get_port:",
            "            with mock.patch.object(self.br, 'delete_port') as delete_port:",
            "                self.br.delete_ports(all_ports=True)",
            "        get_port.assert_called_once_with()",
            "        delete_port.assert_called_once_with('port1')",
            "",
            "    def test_delete_neutron_ports(self):",
            "        port1 = ovs_lib.VifPort('tap1234', 1, uuidutils.generate_uuid(),",
            "                                'ca:fe:de:ad:be:ef', 'br')",
            "        port2 = ovs_lib.VifPort('tap5678', 2, uuidutils.generate_uuid(),",
            "                                'ca:ee:de:ad:be:ef', 'br')",
            "        with mock.patch.object(self.br, 'get_vif_ports',",
            "                               return_value=[port1, port2]) as get_ports:",
            "            with mock.patch.object(self.br, 'delete_port') as delete_port:",
            "                self.br.delete_ports(all_ports=False)",
            "        get_ports.assert_called_once_with()",
            "        delete_port.assert_has_calls([",
            "            mock.call('tap1234'),",
            "            mock.call('tap5678')",
            "        ])",
            "",
            "    def test_get_local_port_mac_succeeds(self):",
            "        with mock.patch('neutron.agent.linux.ip_lib.IpLinkCommand',",
            "                        return_value=mock.Mock(address='foo')):",
            "            self.assertEqual('foo', self.br.get_local_port_mac())",
            "",
            "    def test_get_local_port_mac_raises_exception_for_missing_mac(self):",
            "        with mock.patch('neutron.agent.linux.ip_lib.IpLinkCommand',",
            "                        return_value=mock.Mock(address=None)):",
            "            with testtools.ExpectedException(Exception):",
            "                self.br.get_local_port_mac()",
            "",
            "    def test_delete_egress_bw_limit_for_port(self):",
            "        with mock.patch.object(",
            "            self.br, \"_set_egress_bw_limit_for_port\"",
            "        ) as set_egress_mock, mock.patch.object(",
            "            self.br, \"port_exists\", return_value=True",
            "        ) as port_exists_mock:",
            "            self.br.delete_egress_bw_limit_for_port(\"test_port\")",
            "            port_exists_mock.assert_called_once_with(\"test_port\")",
            "            set_egress_mock.assert_called_once_with(\"test_port\", 0, 0,",
            "                                                    check_error=False)",
            "",
            "    def test_delete_egress_bw_limit_for_port_port_not_exists(self):",
            "        with mock.patch.object(",
            "            self.br, \"_set_egress_bw_limit_for_port\"",
            "        ) as set_egress_mock, mock.patch.object(",
            "            self.br, \"port_exists\", return_value=False",
            "        ) as port_exists_mock:",
            "            self.br.delete_egress_bw_limit_for_port(\"test_port\")",
            "            port_exists_mock.assert_called_once_with(\"test_port\")",
            "            set_egress_mock.assert_not_called()",
            "",
            "    def test_get_vifs_by_ids(self):",
            "        db_list_res = [",
            "            {'name': 'qvo1', 'ofport': 1,",
            "             'external_ids': {'iface-id': 'pid1', 'attached-mac': '11'}},",
            "            {'name': 'qvo2', 'ofport': 2,",
            "             'external_ids': {'iface-id': 'pid2', 'attached-mac': '22'}},",
            "            {'name': 'qvo4', 'ofport': -1,",
            "             'external_ids': {'iface-id': 'pid4', 'attached-mac': '44'}},",
            "        ]",
            "        self.br.get_ports_attributes = mock.Mock(return_value=db_list_res)",
            "        self.br.ovsdb = mock.Mock()",
            "        self.br.ovsdb.list_ports.return_value.execute.return_value = [",
            "            'qvo1', 'qvo2', 'qvo4']",
            "        by_id = self.br.get_vifs_by_ids(['pid1', 'pid2', 'pid3', 'pid4'])",
            "        # pid3 isn't on bridge and pid4 doesn't have a valid ofport",
            "        self.assertIsNone(by_id['pid3'])",
            "        self.assertIsNone(by_id['pid4'])",
            "        self.assertEqual('pid1', by_id['pid1'].vif_id)",
            "        self.assertEqual('qvo1', by_id['pid1'].port_name)",
            "        self.assertEqual(1, by_id['pid1'].ofport)",
            "        self.assertEqual('pid2', by_id['pid2'].vif_id)",
            "        self.assertEqual('qvo2', by_id['pid2'].port_name)",
            "        self.assertEqual(2, by_id['pid2'].ofport)",
            "        self.br.get_ports_attributes.assert_has_calls(",
            "            [mock.call('Interface', columns=['name', 'external_ids', 'ofport'],",
            "                       if_exists=True)])",
            "",
            "    def test_get_port_ofport_retry(self):",
            "        # Increase this value to avoid a timeout during the test execution",
            "        self.br.ovsdb.ovsdb_connection.timeout = 10",
            "        with mock.patch.object(",
            "                self.br, 'db_get_val',",
            "                side_effect=[[], [], [], [], 1]):",
            "            self.assertEqual(1, self.br._get_port_val('1', 'ofport'))",
            "",
            "    def test_get_port_ofport_retry_fails(self):",
            "        # reduce timeout for faster execution",
            "        self.br.ovsdb.ovsdb_connection.timeout = 1",
            "        # after 7 calls the retry will timeout and raise",
            "        with mock.patch.object(",
            "                self.br, 'db_get_val',",
            "                side_effect=[[] for _ in range(7)]):",
            "            self.assertRaises(tenacity.RetryError,",
            "                              self.br._get_port_val, '1', 'ofport')",
            "",
            "    def test_set_controller_rate_limit(self):",
            "        with mock.patch.object(",
            "                self.br, \"set_controller_field\"",
            "        ) as set_ctrl_field_mock:",
            "            self.br.set_controller_rate_limit(200)",
            "            set_ctrl_field_mock.assert_called_once_with(",
            "                'controller_rate_limit', 200)",
            "",
            "    def test_set_controller_rate_limit_with_value_less_than_min(self):",
            "        with mock.patch.object(",
            "                self.br, \"set_controller_field\"",
            "        ) as set_ctrl_field_mock:",
            "            self.br.set_controller_rate_limit(50)",
            "            set_ctrl_field_mock.assert_called_once_with(",
            "                'controller_rate_limit', ovs_lib.CTRL_RATE_LIMIT_MIN)",
            "",
            "    def test_set_controller_burst_limit(self):",
            "        with mock.patch.object(",
            "                self.br, \"set_controller_field\"",
            "        ) as set_ctrl_field_mock:",
            "            self.br.set_controller_burst_limit(100)",
            "            set_ctrl_field_mock.assert_called_once_with(",
            "                'controller_burst_limit', 100)",
            "",
            "    def test_set_controller_burst_limit_with_value_less_than_min(self):",
            "        with mock.patch.object(",
            "                self.br, \"set_controller_field\"",
            "        ) as set_ctrl_field_mock:",
            "            self.br.set_controller_burst_limit(10)",
            "            set_ctrl_field_mock.assert_called_once_with(",
            "                'controller_burst_limit', ovs_lib.CTRL_BURST_LIMIT_MIN)",
            "",
            "    def test_hw_offload_enabled_false(self):",
            "        config_mock1 = mock.PropertyMock(return_value={\"other_config\": {}})",
            "        config_mock2 = mock.PropertyMock(",
            "            return_value={\"other_config\": {\"hw-offload\": \"false\"}})",
            "        config_mock3 = mock.PropertyMock(",
            "            return_value={\"other_config\": {\"hw-offload\": \"False\"}})",
            "        for config_mock in (config_mock1, config_mock2, config_mock3):",
            "            with mock.patch(\"neutron.agent.common.ovs_lib.OVSBridge.config\",",
            "                            new_callable=config_mock):",
            "                self.assertFalse(self.br.is_hw_offload_enabled)",
            "",
            "    def test_hw_offload_enabled_true(self):",
            "        config_mock1 = mock.PropertyMock(",
            "            return_value={\"other_config\": {\"hw-offload\": \"true\"}})",
            "        config_mock2 = mock.PropertyMock(",
            "            return_value={\"other_config\": {\"hw-offload\": \"True\"}})",
            "        for config_mock in (config_mock1, config_mock2):",
            "            with mock.patch(\"neutron.agent.common.ovs_lib.OVSBridge.config\",",
            "                            new_callable=config_mock):",
            "                self.assertTrue(self.br.is_hw_offload_enabled)",
            "",
            "",
            "class TestDeferredOVSBridge(base.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestDeferredOVSBridge, self).setUp()",
            "",
            "        self.br = mock.Mock()",
            "        self.mocked_do_action_flows = mock.patch.object(",
            "            self.br, 'do_action_flows').start()",
            "",
            "        self.add_flow_dict1 = dict(in_port=11, actions='drop')",
            "        self.add_flow_dict2 = dict(in_port=12, actions='drop')",
            "        self.mod_flow_dict1 = dict(in_port=21, actions='drop')",
            "        self.mod_flow_dict2 = dict(in_port=22, actions='drop')",
            "        self.del_flow_dict1 = dict(in_port=31)",
            "        self.del_flow_dict2 = dict(in_port=32)",
            "",
            "    def test_right_allowed_passthroughs(self):",
            "        expected_passthroughs = ('add_port', 'add_tunnel_port', 'delete_port')",
            "        self.assertEqual(expected_passthroughs,",
            "                         ovs_lib.DeferredOVSBridge.ALLOWED_PASSTHROUGHS)",
            "",
            "    def _verify_mock_call(self, expected_calls):",
            "        self.mocked_do_action_flows.assert_has_calls(expected_calls)",
            "        self.assertEqual(len(expected_calls),",
            "                         len(self.mocked_do_action_flows.mock_calls))",
            "",
            "    def test_apply_on_exit(self):",
            "        expected_calls = [",
            "            mock.call('add', [self.add_flow_dict1], False),",
            "            mock.call('mod', [self.mod_flow_dict1], False),",
            "            mock.call('del', [self.del_flow_dict1], False),",
            "        ]",
            "",
            "        with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "            deferred_br.add_flow(**self.add_flow_dict1)",
            "            deferred_br.mod_flow(**self.mod_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict1)",
            "            self._verify_mock_call([])",
            "        self._verify_mock_call(expected_calls)",
            "",
            "    def test_apply_on_exit_with_errors(self):",
            "        try:",
            "            with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "                deferred_br.add_flow(**self.add_flow_dict1)",
            "                deferred_br.mod_flow(**self.mod_flow_dict1)",
            "                deferred_br.delete_flows(**self.del_flow_dict1)",
            "                raise Exception()",
            "        except Exception:",
            "            self._verify_mock_call([])",
            "        else:",
            "            self.fail('Exception would be reraised')",
            "",
            "    def test_apply(self):",
            "        expected_calls = [",
            "            mock.call('add', [self.add_flow_dict1], False),",
            "            mock.call('mod', [self.mod_flow_dict1], False),",
            "            mock.call('del', [self.del_flow_dict1], False),",
            "        ]",
            "",
            "        with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "            deferred_br.add_flow(**self.add_flow_dict1)",
            "            deferred_br.mod_flow(**self.mod_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict1)",
            "            self._verify_mock_call([])",
            "            deferred_br.apply_flows()",
            "            self._verify_mock_call(expected_calls)",
            "        self._verify_mock_call(expected_calls)",
            "",
            "    def test_apply_order(self):",
            "        expected_calls = [",
            "            mock.call(",
            "                'del', [self.del_flow_dict1, self.del_flow_dict2], False),",
            "            mock.call(",
            "                'mod', [self.mod_flow_dict1, self.mod_flow_dict2], False),",
            "            mock.call(",
            "                'add', [self.add_flow_dict1, self.add_flow_dict2], False),",
            "        ]",
            "",
            "        order = 'del', 'mod', 'add'",
            "        with ovs_lib.DeferredOVSBridge(self.br, order=order) as deferred_br:",
            "            deferred_br.add_flow(**self.add_flow_dict1)",
            "            deferred_br.mod_flow(**self.mod_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict2)",
            "            deferred_br.add_flow(**self.add_flow_dict2)",
            "            deferred_br.mod_flow(**self.mod_flow_dict2)",
            "        self._verify_mock_call(expected_calls)",
            "",
            "    def test_apply_full_ordered(self):",
            "        expected_calls = [",
            "            mock.call('add', [self.add_flow_dict1], False),",
            "            mock.call('mod', [self.mod_flow_dict1], False),",
            "            mock.call(",
            "                'del', [self.del_flow_dict1, self.del_flow_dict2], False),",
            "            mock.call('add', [self.add_flow_dict2], False),",
            "            mock.call('mod', [self.mod_flow_dict2], False),",
            "        ]",
            "",
            "        with ovs_lib.DeferredOVSBridge(self.br,",
            "                                       full_ordered=True) as deferred_br:",
            "            deferred_br.add_flow(**self.add_flow_dict1)",
            "            deferred_br.mod_flow(**self.mod_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict2)",
            "            deferred_br.add_flow(**self.add_flow_dict2)",
            "            deferred_br.mod_flow(**self.mod_flow_dict2)",
            "        self._verify_mock_call(expected_calls)",
            "",
            "    def test_getattr_unallowed_attr(self):",
            "        with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "            self.assertEqual(self.br.add_port, deferred_br.add_port)",
            "",
            "    def test_getattr_unallowed_attr_failure(self):",
            "        with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "            self.assertRaises(AttributeError, getattr, deferred_br, 'failure')"
        ],
        "afterPatchFile": [
            "# Copyright 2012, VMware, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "from unittest import mock",
            "",
            "from neutron_lib import exceptions",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import uuidutils",
            "import tenacity",
            "import testtools",
            "",
            "from neutron.agent.common import ovs_lib",
            "from neutron.agent.common import utils",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common \\",
            "    import constants as p_const",
            "from neutron.tests import base",
            "",
            "",
            "class OFCTLParamListMatcher(object):",
            "",
            "    def _parse(self, params):",
            "        actions_pos = params.find('actions')",
            "        return set(params[:actions_pos].split(',')), params[actions_pos:]",
            "",
            "    def __init__(self, params):",
            "        self.expected = self._parse(params)",
            "",
            "    def __eq__(self, other):",
            "        return self.expected == self._parse(other)",
            "",
            "    def __str__(self):",
            "        return 'ovs-ofctl parameters: %s, \"%s\"' % self.expected",
            "",
            "    __repr__ = __str__",
            "",
            "",
            "class StringSetMatcher(object):",
            "    \"\"\"A helper object for unordered CSV strings",
            "",
            "    Will compare equal if both strings, when read as a comma-separated set",
            "    of values, represent the same set.",
            "",
            "    Example: \"a,b,45\" == \"b,45,a\"",
            "    \"\"\"",
            "    def __init__(self, string, separator=','):",
            "        self.separator = separator",
            "        self.set = set(string.split(self.separator))",
            "",
            "    def __eq__(self, other):",
            "        return self.set == set(other.split(self.separator))",
            "",
            "    def __ne__(self, other):",
            "        return self.set != set(other.split(self.separator))",
            "",
            "    def __repr__(self):",
            "        sep = '' if self.separator == ',' else \" on %s\" % self.separator",
            "        return '<comma-separated string for %s%s>' % (self.set, sep)",
            "",
            "",
            "class OVS_Lib_Test(base.BaseTestCase):",
            "    \"\"\"A test suite to exercise the OVS libraries shared by Neutron agents.",
            "",
            "    Note: these tests do not actually execute ovs-* utilities, and thus",
            "    can run on any system.  That does, however, limit their scope.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(OVS_Lib_Test, self).setUp()",
            "        self.BR_NAME = \"br-int\"",
            "",
            "        # Don't attempt to connect to ovsdb",
            "        mock.patch('neutron.agent.ovsdb.impl_idl.api_factory').start()",
            "        self.br = ovs_lib.OVSBridge(self.BR_NAME)",
            "        self.execute = mock.patch.object(",
            "            utils, \"execute\", spec=utils.execute).start()",
            "",
            "    def test_vifport(self):",
            "        \"\"\"Create and stringify vif port, confirm no exceptions.\"\"\"",
            "",
            "        pname = \"vif1.0\"",
            "        ofport = 5",
            "        vif_id = uuidutils.generate_uuid()",
            "        mac = \"ca:fe:de:ad:be:ef\"",
            "",
            "        # test __init__",
            "        port = ovs_lib.VifPort(pname, ofport, vif_id, mac, self.br)",
            "        self.assertEqual(port.port_name, pname)",
            "        self.assertEqual(port.ofport, ofport)",
            "        self.assertEqual(port.vif_id, vif_id)",
            "        self.assertEqual(port.vif_mac, mac)",
            "        self.assertEqual(port.switch.br_name, self.BR_NAME)",
            "",
            "        # test __str__",
            "        str(port)",
            "",
            "    def test_add_flow(self):",
            "        ofport = \"99\"",
            "        vid = 4000",
            "        lsw_id = 18",
            "        cidr = '192.168.1.0/24'",
            "",
            "        flow_dict_1 = collections.OrderedDict([",
            "            ('cookie', 1234),",
            "            ('priority', 2),",
            "            ('dl_src', 'ca:fe:de:ad:be:ef'),",
            "            ('actions', 'strip_vlan,output:0')])",
            "        flow_dict_2 = collections.OrderedDict([",
            "            ('cookie', 1254),",
            "            ('priority', 1),",
            "            ('actions', 'normal')])",
            "        flow_dict_3 = collections.OrderedDict([",
            "            ('cookie', 1257),",
            "            ('priority', 2),",
            "            ('actions', 'drop')])",
            "        flow_dict_4 = collections.OrderedDict([",
            "            ('cookie', 1274),",
            "            ('priority', 2),",
            "            ('in_port', ofport),",
            "            ('actions', 'drop')])",
            "        flow_dict_5 = collections.OrderedDict([",
            "            ('cookie', 1284),",
            "            ('priority', 4),",
            "            ('in_port', ofport),",
            "            ('dl_vlan', vid),",
            "            ('actions', \"strip_vlan,set_tunnel:%s,normal\" % (lsw_id))])",
            "        flow_dict_6 = collections.OrderedDict([",
            "            ('cookie', 1754),",
            "            ('priority', 3),",
            "            ('tun_id', lsw_id),",
            "            ('actions', \"mod_vlan_vid:%s,output:%s\" % (vid, ofport))])",
            "        flow_dict_7 = collections.OrderedDict([",
            "            ('cookie', 1256),",
            "            ('priority', 4),",
            "            ('nw_src', cidr),",
            "            ('proto', 'arp'),",
            "            ('actions', 'drop')])",
            "",
            "        self.br.add_flow(**flow_dict_1)",
            "        self.br.add_flow(**flow_dict_2)",
            "        self.br.add_flow(**flow_dict_3)",
            "        self.br.add_flow(**flow_dict_4)",
            "        self.br.add_flow(**flow_dict_5)",
            "        self.br.add_flow(**flow_dict_6)",
            "        self.br.add_flow(**flow_dict_7)",
            "        expected_calls = [",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1234,\"",
            "                                 \"priority=2,dl_src=ca:fe:de:ad:be:ef,\"",
            "                                 \"actions=strip_vlan,output:0\")),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1254,\"",
            "                                 \"priority=1,actions=normal\")),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1257,\"",
            "                                 \"priority=2,actions=drop\")),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1274,\"",
            "                                 \"priority=2,in_port=%s,actions=drop\" % ofport",
            "                             )),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1284,\"",
            "                                 \"priority=4,dl_vlan=%s,in_port=%s,\"",
            "                                 \"actions=strip_vlan,set_tunnel:%s,normal\" %",
            "                                 (vid, ofport, lsw_id))),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1754,\"",
            "                                 \"priority=3,\"",
            "                                 \"tun_id=%s,actions=mod_vlan_vid:%s,output:%s\"",
            "                                 % (lsw_id, vid, ofport))),",
            "            self._ofctl_mock(\"add-flows\", self.BR_NAME, '-',",
            "                             process_input=OFCTLParamListMatcher(",
            "                                 \"hard_timeout=0,idle_timeout=0,cookie=1256,\"",
            "                                 \"priority=4,nw_src=%s,arp,actions=drop\"",
            "                                 % cidr)),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def _ofctl_args(self, cmd, *args):",
            "        cmd = ['ovs-ofctl', cmd, '-O', self.br._highest_protocol_needed]",
            "        cmd += args",
            "        return cmd",
            "",
            "    def _ofctl_mock(self, cmd, *args, **kwargs):",
            "        cmd = self._ofctl_args(cmd, *args)",
            "        return mock.call(cmd, run_as_root=True, **kwargs)",
            "",
            "    def _verify_ofctl_mock(self, cmd, *args, **kwargs):",
            "        cmd = self._ofctl_args(cmd, *args)",
            "        return self.execute.assert_called_once_with(cmd, run_as_root=True,",
            "                                                    **kwargs)",
            "",
            "    def test_add_flow_timeout_set(self):",
            "        flow_dict = collections.OrderedDict([",
            "            ('cookie', 1234),",
            "            ('priority', 1),",
            "            ('hard_timeout', 1000),",
            "            ('idle_timeout', 2000),",
            "            ('actions', 'normal')])",
            "",
            "        self.br.add_flow(**flow_dict)",
            "        self._verify_ofctl_mock(",
            "            \"add-flows\", self.BR_NAME, '-',",
            "            process_input=\"hard_timeout=1000,idle_timeout=2000,\"",
            "                          \"priority=1,cookie=1234,actions=normal\")",
            "",
            "    def test_add_flow_default_priority(self):",
            "        flow_dict = collections.OrderedDict([('actions', 'normal'),",
            "                                             ('cookie', 1234)])",
            "",
            "        self.br.add_flow(**flow_dict)",
            "        self._verify_ofctl_mock(",
            "            \"add-flows\", self.BR_NAME, '-',",
            "            process_input=\"hard_timeout=0,idle_timeout=0,priority=1,\"",
            "                          \"cookie=1234,actions=normal\")",
            "",
            "    def test_default_datapath(self):",
            "        # verify kernel datapath is default",
            "        expected = p_const.OVS_DATAPATH_SYSTEM",
            "        self.assertEqual(expected, self.br.datapath_type)",
            "",
            "    def test_non_default_datapath(self):",
            "        expected = p_const.OVS_DATAPATH_NETDEV",
            "        self.br = ovs_lib.OVSBridge(self.BR_NAME, datapath_type=expected)",
            "        br2 = self.br.add_bridge('another-br', datapath_type=expected)",
            "        self.assertEqual(expected, self.br.datapath_type)",
            "        self.assertEqual(expected, br2.datapath_type)",
            "",
            "    def test_count_flows(self):",
            "        self.execute.return_value = 'ignore\\nflow-1\\n'",
            "        # counts the number of flows as total lines of output - 2",
            "        self.assertEqual(self.br.count_flows(), 1)",
            "        self._verify_ofctl_mock(\"dump-flows\", self.BR_NAME, process_input=None)",
            "",
            "    def test_delete_flow(self):",
            "        ofport = 5",
            "        lsw_id = 40",
            "        vid = 39",
            "        self.br.delete_flows(in_port=ofport)",
            "        self.br.delete_flows(tun_id=lsw_id)",
            "        self.br.delete_flows(dl_vlan=vid)",
            "        self.br.delete_flows()",
            "        cookie_spec = \"cookie=%s/-1\" % self.br._default_cookie",
            "        expected_calls = [",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s,in_port=%d\" % (cookie_spec, ofport))),",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s,tun_id=%s\" % (cookie_spec, lsw_id))),",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s,dl_vlan=%s\" % (cookie_spec, vid))),",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=\"%s\" % cookie_spec),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def test_delete_flows_cookie_nomask(self):",
            "        self.br.delete_flows(cookie=42)",
            "        self.execute.assert_has_calls([",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=\"cookie=42/-1\"),",
            "        ])",
            "",
            "    def test_do_action_flows_delete_flows(self):",
            "        # test what the deferred bridge implementation calls, in the case of a",
            "        # delete_flows(cookie=ovs_lib.COOKIE_ANY) among calls to",
            "        # delete_flows(foo=bar)",
            "        self.br.do_action_flows('del', [{'in_port': 5},",
            "                                        {'cookie': ovs_lib.COOKIE_ANY}])",
            "        expected_calls = [",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME,",
            "                             process_input=None),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def test_delete_flows_any_cookie(self):",
            "        self.br.delete_flows(in_port=5, cookie=ovs_lib.COOKIE_ANY)",
            "        self.br.delete_flows(cookie=ovs_lib.COOKIE_ANY)",
            "        expected_calls = [",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '-',",
            "                             process_input=\"in_port=5\"),",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME,",
            "                             process_input=None),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def test_mod_delete_flows_strict(self):",
            "        self.br.delete_flows(in_port=5, priority=1, strict=True)",
            "        self.br.mod_flow(in_port=5, priority=1, strict=True, actions='drop')",
            "        cookie_spec = \"cookie=%s\" % self.br._default_cookie",
            "        expected_calls = [",
            "            self._ofctl_mock(\"del-flows\", self.BR_NAME, '--strict', '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s/-1,in_port=5,priority=1\" % cookie_spec)),",
            "            self._ofctl_mock(\"mod-flows\", self.BR_NAME, '--strict', '-',",
            "                             process_input=StringSetMatcher(",
            "                                 \"%s,in_port=5,priority=1,actions=drop\" %",
            "                                 cookie_spec)),",
            "        ]",
            "        self.execute.assert_has_calls(expected_calls)",
            "",
            "    def test_mod_delete_flows_priority_without_strict(self):",
            "        self.assertRaises(exceptions.InvalidInput,",
            "                          self.br.delete_flows,",
            "                          in_port=5, priority=1)",
            "",
            "    def test_mod_delete_flows_mixed_strict(self):",
            "        deferred_br = self.br.deferred()",
            "        deferred_br.delete_flows(in_port=5)",
            "        deferred_br.delete_flows(in_port=5, priority=1, strict=True)",
            "        self.assertRaises(exceptions.InvalidInput,",
            "                          deferred_br.apply_flows)",
            "",
            "    def test_dump_flows(self):",
            "        table = 23",
            "        nxst_flow = \"NXST_FLOW reply (xid=0x4):\"",
            "        flows = \"\\n\".join([\" cookie=0x0, duration=18042.514s, table=0, \"",
            "                           \"n_packets=6, n_bytes=468, \"",
            "                           \"priority=2,in_port=1 actions=drop\",",
            "                           \" cookie=0x0, duration=18027.562s, table=0, \"",
            "                           \"n_packets=0, n_bytes=0, \"",
            "                           \"priority=3,in_port=1,dl_vlan=100 \"",
            "                           \"actions=mod_vlan_vid:1,NORMAL\",",
            "                           \" cookie=0x0, duration=18044.351s, table=0, \"",
            "                           \"n_packets=9, n_bytes=594, priority=1 \"",
            "                           \"actions=NORMAL\", \" cookie=0x0, \"",
            "                           \"duration=18044.211s, table=23, n_packets=0, \"",
            "                           \"n_bytes=0, priority=0 actions=drop\"])",
            "        flow_args = '\\n'.join([nxst_flow, flows])",
            "        run_ofctl = mock.patch.object(self.br, 'run_ofctl').start()",
            "        run_ofctl.side_effect = [flow_args]",
            "        retflows = self.br.dump_flows_for_table(table)",
            "        self.assertEqual(flows, retflows)",
            "",
            "    def test_dump_flows_ovs_dead(self):",
            "        table = 23",
            "        run_ofctl = mock.patch.object(self.br, 'run_ofctl').start()",
            "        run_ofctl.side_effect = ['']",
            "        retflows = self.br.dump_flows_for_table(table)",
            "        self.assertIsNone(retflows)",
            "",
            "    def test_mod_flow_with_priority_set(self):",
            "        params = {'in_port': '1',",
            "                  'priority': '1'}",
            "",
            "        self.assertRaises(exceptions.InvalidInput,",
            "                          self.br.mod_flow,",
            "                          **params)",
            "",
            "    def test_mod_flow_no_actions_set(self):",
            "        params = {'in_port': '1'}",
            "",
            "        self.assertRaises(exceptions.InvalidInput,",
            "                          self.br.mod_flow,",
            "                          **params)",
            "",
            "    def test_run_ofctl_retry_on_socket_error(self):",
            "        err = RuntimeError('failed to connect to socket')",
            "        self.execute.side_effect = [err] * 5",
            "        with mock.patch('time.sleep') as sleep:",
            "            self.br.run_ofctl('add-flows', [])",
            "        self.assertEqual(5, sleep.call_count)",
            "        self.assertEqual(6, self.execute.call_count)",
            "        # a regular exception fails right away",
            "        self.execute.side_effect = RuntimeError('garbage')",
            "        self.execute.reset_mock()",
            "        with mock.patch('time.sleep') as sleep:",
            "            self.br.run_ofctl('add-flows', [])",
            "        self.assertEqual(0, sleep.call_count)",
            "        self.assertEqual(1, self.execute.call_count)",
            "",
            "    def _encode_ovs_json(self, headings, data):",
            "        # See man ovs-vsctl(8) for the encoding details.",
            "        r = {\"data\": [],",
            "             \"headings\": headings}",
            "        for row in data:",
            "            ovs_row = []",
            "            r[\"data\"].append(ovs_row)",
            "            for cell in row:",
            "                if isinstance(cell, (str, int, list)):",
            "                    ovs_row.append(cell)",
            "                elif isinstance(cell, dict):",
            "                    ovs_row.append([\"map\", cell.items()])",
            "                elif isinstance(cell, set):",
            "                    ovs_row.append([\"set\", cell])",
            "                else:",
            "                    raise TypeError('%r not int, str, list, set or dict' %",
            "                                    type(cell))",
            "        return jsonutils.dumps(r)",
            "",
            "    def test_get_vif_ports(self):",
            "        pname = \"tap99\"",
            "        ofport = 6",
            "        vif_id = uuidutils.generate_uuid()",
            "        mac = \"ca:fe:de:ad:be:ef\"",
            "        id_field = 'iface-id'",
            "        external_ids = {\"attached-mac\": mac, id_field: vif_id}",
            "        self.br.get_ports_attributes = mock.Mock(return_value=[{",
            "            'name': pname, 'ofport': ofport, 'external_ids': external_ids}])",
            "",
            "        ports = self.br.get_vif_ports()",
            "        self.assertEqual(1, len(ports))",
            "        self.assertEqual(ports[0].port_name, pname)",
            "        self.assertEqual(ports[0].ofport, ofport)",
            "        self.assertEqual(ports[0].vif_id, vif_id)",
            "        self.assertEqual(ports[0].vif_mac, mac)",
            "        self.assertEqual(ports[0].switch.br_name, self.BR_NAME)",
            "        self.br.get_ports_attributes.assert_called_once_with(",
            "            'Interface',",
            "            columns=['name', 'external_ids', 'ofport'],",
            "            if_exists=True)",
            "",
            "    def test_delete_all_ports(self):",
            "        with mock.patch.object(self.br, 'get_port_name_list',",
            "                               return_value=['port1']) as get_port:",
            "            with mock.patch.object(self.br, 'delete_port') as delete_port:",
            "                self.br.delete_ports(all_ports=True)",
            "        get_port.assert_called_once_with()",
            "        delete_port.assert_called_once_with('port1')",
            "",
            "    def test_delete_neutron_ports(self):",
            "        port1 = ovs_lib.VifPort('tap1234', 1, uuidutils.generate_uuid(),",
            "                                'ca:fe:de:ad:be:ef', 'br')",
            "        port2 = ovs_lib.VifPort('tap5678', 2, uuidutils.generate_uuid(),",
            "                                'ca:ee:de:ad:be:ef', 'br')",
            "        with mock.patch.object(self.br, 'get_vif_ports',",
            "                               return_value=[port1, port2]) as get_ports:",
            "            with mock.patch.object(self.br, 'delete_port') as delete_port:",
            "                self.br.delete_ports(all_ports=False)",
            "        get_ports.assert_called_once_with()",
            "        delete_port.assert_has_calls([",
            "            mock.call('tap1234'),",
            "            mock.call('tap5678')",
            "        ])",
            "",
            "    def test_get_local_port_mac_succeeds(self):",
            "        with mock.patch('neutron.agent.linux.ip_lib.IpLinkCommand',",
            "                        return_value=mock.Mock(address='foo')):",
            "            self.assertEqual('foo', self.br.get_local_port_mac())",
            "",
            "    def test_get_local_port_mac_raises_exception_for_missing_mac(self):",
            "        with mock.patch('neutron.agent.linux.ip_lib.IpLinkCommand',",
            "                        return_value=mock.Mock(address=None)):",
            "            with testtools.ExpectedException(Exception):",
            "                self.br.get_local_port_mac()",
            "",
            "    def test_delete_egress_bw_limit_for_port(self):",
            "        with mock.patch.object(",
            "            self.br, \"_set_egress_bw_limit_for_port\"",
            "        ) as set_egress_mock, mock.patch.object(",
            "            self.br, \"port_exists\", return_value=True",
            "        ) as port_exists_mock:",
            "            self.br.delete_egress_bw_limit_for_port(\"test_port\")",
            "            port_exists_mock.assert_called_once_with(\"test_port\")",
            "            set_egress_mock.assert_called_once_with(\"test_port\", 0, 0,",
            "                                                    check_error=False)",
            "",
            "    def test_delete_egress_bw_limit_for_port_port_not_exists(self):",
            "        with mock.patch.object(",
            "            self.br, \"_set_egress_bw_limit_for_port\"",
            "        ) as set_egress_mock, mock.patch.object(",
            "            self.br, \"port_exists\", return_value=False",
            "        ) as port_exists_mock:",
            "            self.br.delete_egress_bw_limit_for_port(\"test_port\")",
            "            port_exists_mock.assert_called_once_with(\"test_port\")",
            "            set_egress_mock.assert_not_called()",
            "",
            "    def test_get_vifs_by_ids(self):",
            "        db_list_res = [",
            "            {'name': 'qvo1', 'ofport': 1,",
            "             'external_ids': {'iface-id': 'pid1', 'attached-mac': '11'}},",
            "            {'name': 'qvo2', 'ofport': 2,",
            "             'external_ids': {'iface-id': 'pid2', 'attached-mac': '22'}},",
            "            {'name': 'qvo4', 'ofport': -1,",
            "             'external_ids': {'iface-id': 'pid4', 'attached-mac': '44'}},",
            "        ]",
            "        self.br.get_ports_attributes = mock.Mock(return_value=db_list_res)",
            "        self.br.ovsdb = mock.Mock()",
            "        self.br.ovsdb.list_ports.return_value.execute.return_value = [",
            "            'qvo1', 'qvo2', 'qvo4']",
            "        by_id = self.br.get_vifs_by_ids(['pid1', 'pid2', 'pid3', 'pid4'])",
            "        # pid3 isn't on bridge",
            "        self.assertIsNone(by_id['pid3'])",
            "        self.assertEqual(-1, by_id['pid4'].ofport)",
            "        self.assertEqual('pid1', by_id['pid1'].vif_id)",
            "        self.assertEqual('qvo1', by_id['pid1'].port_name)",
            "        self.assertEqual(1, by_id['pid1'].ofport)",
            "        self.assertEqual('pid2', by_id['pid2'].vif_id)",
            "        self.assertEqual('qvo2', by_id['pid2'].port_name)",
            "        self.assertEqual(2, by_id['pid2'].ofport)",
            "        self.br.get_ports_attributes.assert_has_calls(",
            "            [mock.call('Interface', columns=['name', 'external_ids', 'ofport'],",
            "                       if_exists=True)])",
            "",
            "    def test_get_port_ofport_retry(self):",
            "        # Increase this value to avoid a timeout during the test execution",
            "        self.br.ovsdb.ovsdb_connection.timeout = 10",
            "        with mock.patch.object(",
            "                self.br, 'db_get_val',",
            "                side_effect=[[], [], [], [], 1]):",
            "            self.assertEqual(1, self.br._get_port_val('1', 'ofport'))",
            "",
            "    def test_get_port_ofport_retry_fails(self):",
            "        # reduce timeout for faster execution",
            "        self.br.ovsdb.ovsdb_connection.timeout = 1",
            "        # after 7 calls the retry will timeout and raise",
            "        with mock.patch.object(",
            "                self.br, 'db_get_val',",
            "                side_effect=[[] for _ in range(7)]):",
            "            self.assertRaises(tenacity.RetryError,",
            "                              self.br._get_port_val, '1', 'ofport')",
            "",
            "    def test_set_controller_rate_limit(self):",
            "        with mock.patch.object(",
            "                self.br, \"set_controller_field\"",
            "        ) as set_ctrl_field_mock:",
            "            self.br.set_controller_rate_limit(200)",
            "            set_ctrl_field_mock.assert_called_once_with(",
            "                'controller_rate_limit', 200)",
            "",
            "    def test_set_controller_rate_limit_with_value_less_than_min(self):",
            "        with mock.patch.object(",
            "                self.br, \"set_controller_field\"",
            "        ) as set_ctrl_field_mock:",
            "            self.br.set_controller_rate_limit(50)",
            "            set_ctrl_field_mock.assert_called_once_with(",
            "                'controller_rate_limit', ovs_lib.CTRL_RATE_LIMIT_MIN)",
            "",
            "    def test_set_controller_burst_limit(self):",
            "        with mock.patch.object(",
            "                self.br, \"set_controller_field\"",
            "        ) as set_ctrl_field_mock:",
            "            self.br.set_controller_burst_limit(100)",
            "            set_ctrl_field_mock.assert_called_once_with(",
            "                'controller_burst_limit', 100)",
            "",
            "    def test_set_controller_burst_limit_with_value_less_than_min(self):",
            "        with mock.patch.object(",
            "                self.br, \"set_controller_field\"",
            "        ) as set_ctrl_field_mock:",
            "            self.br.set_controller_burst_limit(10)",
            "            set_ctrl_field_mock.assert_called_once_with(",
            "                'controller_burst_limit', ovs_lib.CTRL_BURST_LIMIT_MIN)",
            "",
            "    def test_hw_offload_enabled_false(self):",
            "        config_mock1 = mock.PropertyMock(return_value={\"other_config\": {}})",
            "        config_mock2 = mock.PropertyMock(",
            "            return_value={\"other_config\": {\"hw-offload\": \"false\"}})",
            "        config_mock3 = mock.PropertyMock(",
            "            return_value={\"other_config\": {\"hw-offload\": \"False\"}})",
            "        for config_mock in (config_mock1, config_mock2, config_mock3):",
            "            with mock.patch(\"neutron.agent.common.ovs_lib.OVSBridge.config\",",
            "                            new_callable=config_mock):",
            "                self.assertFalse(self.br.is_hw_offload_enabled)",
            "",
            "    def test_hw_offload_enabled_true(self):",
            "        config_mock1 = mock.PropertyMock(",
            "            return_value={\"other_config\": {\"hw-offload\": \"true\"}})",
            "        config_mock2 = mock.PropertyMock(",
            "            return_value={\"other_config\": {\"hw-offload\": \"True\"}})",
            "        for config_mock in (config_mock1, config_mock2):",
            "            with mock.patch(\"neutron.agent.common.ovs_lib.OVSBridge.config\",",
            "                            new_callable=config_mock):",
            "                self.assertTrue(self.br.is_hw_offload_enabled)",
            "",
            "",
            "class TestDeferredOVSBridge(base.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestDeferredOVSBridge, self).setUp()",
            "",
            "        self.br = mock.Mock()",
            "        self.mocked_do_action_flows = mock.patch.object(",
            "            self.br, 'do_action_flows').start()",
            "",
            "        self.add_flow_dict1 = dict(in_port=11, actions='drop')",
            "        self.add_flow_dict2 = dict(in_port=12, actions='drop')",
            "        self.mod_flow_dict1 = dict(in_port=21, actions='drop')",
            "        self.mod_flow_dict2 = dict(in_port=22, actions='drop')",
            "        self.del_flow_dict1 = dict(in_port=31)",
            "        self.del_flow_dict2 = dict(in_port=32)",
            "",
            "    def test_right_allowed_passthroughs(self):",
            "        expected_passthroughs = ('add_port', 'add_tunnel_port', 'delete_port')",
            "        self.assertEqual(expected_passthroughs,",
            "                         ovs_lib.DeferredOVSBridge.ALLOWED_PASSTHROUGHS)",
            "",
            "    def _verify_mock_call(self, expected_calls):",
            "        self.mocked_do_action_flows.assert_has_calls(expected_calls)",
            "        self.assertEqual(len(expected_calls),",
            "                         len(self.mocked_do_action_flows.mock_calls))",
            "",
            "    def test_apply_on_exit(self):",
            "        expected_calls = [",
            "            mock.call('add', [self.add_flow_dict1], False),",
            "            mock.call('mod', [self.mod_flow_dict1], False),",
            "            mock.call('del', [self.del_flow_dict1], False),",
            "        ]",
            "",
            "        with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "            deferred_br.add_flow(**self.add_flow_dict1)",
            "            deferred_br.mod_flow(**self.mod_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict1)",
            "            self._verify_mock_call([])",
            "        self._verify_mock_call(expected_calls)",
            "",
            "    def test_apply_on_exit_with_errors(self):",
            "        try:",
            "            with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "                deferred_br.add_flow(**self.add_flow_dict1)",
            "                deferred_br.mod_flow(**self.mod_flow_dict1)",
            "                deferred_br.delete_flows(**self.del_flow_dict1)",
            "                raise Exception()",
            "        except Exception:",
            "            self._verify_mock_call([])",
            "        else:",
            "            self.fail('Exception would be reraised')",
            "",
            "    def test_apply(self):",
            "        expected_calls = [",
            "            mock.call('add', [self.add_flow_dict1], False),",
            "            mock.call('mod', [self.mod_flow_dict1], False),",
            "            mock.call('del', [self.del_flow_dict1], False),",
            "        ]",
            "",
            "        with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "            deferred_br.add_flow(**self.add_flow_dict1)",
            "            deferred_br.mod_flow(**self.mod_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict1)",
            "            self._verify_mock_call([])",
            "            deferred_br.apply_flows()",
            "            self._verify_mock_call(expected_calls)",
            "        self._verify_mock_call(expected_calls)",
            "",
            "    def test_apply_order(self):",
            "        expected_calls = [",
            "            mock.call(",
            "                'del', [self.del_flow_dict1, self.del_flow_dict2], False),",
            "            mock.call(",
            "                'mod', [self.mod_flow_dict1, self.mod_flow_dict2], False),",
            "            mock.call(",
            "                'add', [self.add_flow_dict1, self.add_flow_dict2], False),",
            "        ]",
            "",
            "        order = 'del', 'mod', 'add'",
            "        with ovs_lib.DeferredOVSBridge(self.br, order=order) as deferred_br:",
            "            deferred_br.add_flow(**self.add_flow_dict1)",
            "            deferred_br.mod_flow(**self.mod_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict2)",
            "            deferred_br.add_flow(**self.add_flow_dict2)",
            "            deferred_br.mod_flow(**self.mod_flow_dict2)",
            "        self._verify_mock_call(expected_calls)",
            "",
            "    def test_apply_full_ordered(self):",
            "        expected_calls = [",
            "            mock.call('add', [self.add_flow_dict1], False),",
            "            mock.call('mod', [self.mod_flow_dict1], False),",
            "            mock.call(",
            "                'del', [self.del_flow_dict1, self.del_flow_dict2], False),",
            "            mock.call('add', [self.add_flow_dict2], False),",
            "            mock.call('mod', [self.mod_flow_dict2], False),",
            "        ]",
            "",
            "        with ovs_lib.DeferredOVSBridge(self.br,",
            "                                       full_ordered=True) as deferred_br:",
            "            deferred_br.add_flow(**self.add_flow_dict1)",
            "            deferred_br.mod_flow(**self.mod_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict1)",
            "            deferred_br.delete_flows(**self.del_flow_dict2)",
            "            deferred_br.add_flow(**self.add_flow_dict2)",
            "            deferred_br.mod_flow(**self.mod_flow_dict2)",
            "        self._verify_mock_call(expected_calls)",
            "",
            "    def test_getattr_unallowed_attr(self):",
            "        with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "            self.assertEqual(self.br.add_port, deferred_br.add_port)",
            "",
            "    def test_getattr_unallowed_attr_failure(self):",
            "        with ovs_lib.DeferredOVSBridge(self.br) as deferred_br:",
            "            self.assertRaises(AttributeError, getattr, deferred_br, 'failure')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "501": [
                "OVS_Lib_Test",
                "test_get_vifs_by_ids"
            ],
            "503": [
                "OVS_Lib_Test",
                "test_get_vifs_by_ids"
            ]
        },
        "addLocation": []
    },
    "neutron/tests/unit/plugins/ml2/drivers/openvswitch/agent/test_ovs_neutron_agent.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 882,
                "afterPatchRowNumber": 882,
                "PatchRowcode": "                     'get_port_tag_dict',"
            },
            "1": {
                "beforePatchRowNumber": 883,
                "afterPatchRowNumber": 883,
                "PatchRowcode": "                     return_value={}),\\"
            },
            "2": {
                "beforePatchRowNumber": 884,
                "afterPatchRowNumber": 884,
                "PatchRowcode": "                 mock.patch.object(self.agent, func_name) as func:"
            },
            "3": {
                "beforePatchRowNumber": 885,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            skip_devs, _, need_bound_devices, _ = ("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 885,
                "PatchRowcode": "+            skip_devs, _, need_bound_devices, _, _ = ("
            },
            "5": {
                "beforePatchRowNumber": 886,
                "afterPatchRowNumber": 886,
                "PatchRowcode": "                 self.agent.treat_devices_added_or_updated([], False, set()))"
            },
            "6": {
                "beforePatchRowNumber": 887,
                "afterPatchRowNumber": 887,
                "PatchRowcode": "             # The function should not raise"
            },
            "7": {
                "beforePatchRowNumber": 888,
                "afterPatchRowNumber": 888,
                "PatchRowcode": "             self.assertFalse(skip_devs)"
            },
            "8": {
                "beforePatchRowNumber": 900,
                "afterPatchRowNumber": 900,
                "PatchRowcode": "                                   'get_vifs_by_ids',"
            },
            "9": {
                "beforePatchRowNumber": 901,
                "afterPatchRowNumber": 901,
                "PatchRowcode": "                                   return_value={details['device']: port}),\\"
            },
            "10": {
                "beforePatchRowNumber": 902,
                "afterPatchRowNumber": 902,
                "PatchRowcode": "                 mock.patch.object(self.agent, 'port_dead') as func:"
            },
            "11": {
                "beforePatchRowNumber": 903,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            skip_devs, binding_no_activated_devices, _, _ = ("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 903,
                "PatchRowcode": "+            skip_devs, binding_no_activated_devices, _, _, _ = ("
            },
            "13": {
                "beforePatchRowNumber": 904,
                "afterPatchRowNumber": 904,
                "PatchRowcode": "                 self.agent.treat_devices_added_or_updated([], False, set()))"
            },
            "14": {
                "beforePatchRowNumber": 905,
                "afterPatchRowNumber": 905,
                "PatchRowcode": "             self.assertFalse(skip_devs)"
            },
            "15": {
                "beforePatchRowNumber": 906,
                "afterPatchRowNumber": 906,
                "PatchRowcode": "             self.assertTrue(func.called)"
            },
            "16": {
                "beforePatchRowNumber": 977,
                "afterPatchRowNumber": 977,
                "PatchRowcode": "                 [], False, set())"
            },
            "17": {
                "beforePatchRowNumber": 978,
                "afterPatchRowNumber": 978,
                "PatchRowcode": "             # The function should return False for resync and no device"
            },
            "18": {
                "beforePatchRowNumber": 979,
                "afterPatchRowNumber": 979,
                "PatchRowcode": "             # processed"
            },
            "19": {
                "beforePatchRowNumber": 980,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertEqual((['the_skipped_one'], set(), [], set()),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 980,
                "PatchRowcode": "+            self.assertEqual((['the_skipped_one'], set(), [], set(), set()),"
            },
            "21": {
                "beforePatchRowNumber": 981,
                "afterPatchRowNumber": 981,
                "PatchRowcode": "                              skip_devs)"
            },
            "22": {
                "beforePatchRowNumber": 982,
                "afterPatchRowNumber": 982,
                "PatchRowcode": "             ext_mgr_delete_port.assert_called_once_with("
            },
            "23": {
                "beforePatchRowNumber": 983,
                "afterPatchRowNumber": 983,
                "PatchRowcode": "                 self.agent.context, {'port_id': 'the_skipped_one'})"
            },
            "24": {
                "beforePatchRowNumber": 995,
                "afterPatchRowNumber": 995,
                "PatchRowcode": "                 mock.patch.object(self.agent,"
            },
            "25": {
                "beforePatchRowNumber": 996,
                "afterPatchRowNumber": 996,
                "PatchRowcode": "                                   'treat_vif_port') as treat_vif_port:"
            },
            "26": {
                "beforePatchRowNumber": 997,
                "afterPatchRowNumber": 997,
                "PatchRowcode": "             failed_devices = {'added': set(), 'removed': set()}"
            },
            "27": {
                "beforePatchRowNumber": 998,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            (_, _, _, failed_devices['added']) = ("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 998,
                "PatchRowcode": "+            (_, _, _, failed_devices['added'], _) = ("
            },
            "29": {
                "beforePatchRowNumber": 999,
                "afterPatchRowNumber": 999,
                "PatchRowcode": "                 self.agent.treat_devices_added_or_updated([], False, set()))"
            },
            "30": {
                "beforePatchRowNumber": 1000,
                "afterPatchRowNumber": 1000,
                "PatchRowcode": "             # The function should return False for resync and no device"
            },
            "31": {
                "beforePatchRowNumber": 1001,
                "afterPatchRowNumber": 1001,
                "PatchRowcode": "             # processed"
            },
            "32": {
                "beforePatchRowNumber": 1026,
                "afterPatchRowNumber": 1026,
                "PatchRowcode": "                                   return_value={}),\\"
            },
            "33": {
                "beforePatchRowNumber": 1027,
                "afterPatchRowNumber": 1027,
                "PatchRowcode": "                 mock.patch.object(self.agent,"
            },
            "34": {
                "beforePatchRowNumber": 1028,
                "afterPatchRowNumber": 1028,
                "PatchRowcode": "                                   'treat_vif_port') as treat_vif_port:"
            },
            "35": {
                "beforePatchRowNumber": 1029,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            skip_devs, _, need_bound_devices, _ = ("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1029,
                "PatchRowcode": "+            skip_devs, _, need_bound_devices, _, _ = ("
            },
            "37": {
                "beforePatchRowNumber": 1030,
                "afterPatchRowNumber": 1030,
                "PatchRowcode": "                 self.agent.treat_devices_added_or_updated([], False, set()))"
            },
            "38": {
                "beforePatchRowNumber": 1031,
                "afterPatchRowNumber": 1031,
                "PatchRowcode": "             # The function should return False for resync"
            },
            "39": {
                "beforePatchRowNumber": 1032,
                "afterPatchRowNumber": 1032,
                "PatchRowcode": "             self.assertFalse(skip_devs)"
            },
            "40": {
                "beforePatchRowNumber": 1135,
                "afterPatchRowNumber": 1135,
                "PatchRowcode": "                     self.agent, \"treat_devices_added_or_updated\","
            },
            "41": {
                "beforePatchRowNumber": 1136,
                "afterPatchRowNumber": 1136,
                "PatchRowcode": "                     return_value=("
            },
            "42": {
                "beforePatchRowNumber": 1137,
                "afterPatchRowNumber": 1137,
                "PatchRowcode": "                         skipped_devices, binding_no_activated_devices, [],"
            },
            "43": {
                "beforePatchRowNumber": 1138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        failed_devices['added'])) as device_added_updated,\\"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1138,
                "PatchRowcode": "+                        failed_devices['added'],"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "+                        set())) as device_added_updated,\\"
            },
            "46": {
                "beforePatchRowNumber": 1139,
                "afterPatchRowNumber": 1140,
                "PatchRowcode": "                 mock.patch.object(self.agent.int_br, \"get_ports_attributes\","
            },
            "47": {
                "beforePatchRowNumber": 1140,
                "afterPatchRowNumber": 1141,
                "PatchRowcode": "                                   return_value=[]),\\"
            },
            "48": {
                "beforePatchRowNumber": 1141,
                "afterPatchRowNumber": 1142,
                "PatchRowcode": "                 mock.patch.object(self.agent,"
            },
            "49": {
                "beforePatchRowNumber": 3157,
                "afterPatchRowNumber": 3158,
                "PatchRowcode": "                 ),"
            },
            "50": {
                "beforePatchRowNumber": 3158,
                "afterPatchRowNumber": 3159,
                "PatchRowcode": "             ] + self._expected_port_bound(self._port, lvid,"
            },
            "51": {
                "beforePatchRowNumber": 3159,
                "afterPatchRowNumber": 3160,
                "PatchRowcode": "                                           network_type=network_type)"
            },
            "52": {
                "beforePatchRowNumber": 3160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            int_br.assert_has_calls(expected_on_int_br)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3161,
                "PatchRowcode": "+            int_br.assert_has_calls(expected_on_int_br, any_order=True)"
            },
            "54": {
                "beforePatchRowNumber": 3161,
                "afterPatchRowNumber": 3162,
                "PatchRowcode": "             tun_br.assert_not_called()"
            },
            "55": {
                "beforePatchRowNumber": 3162,
                "afterPatchRowNumber": 3163,
                "PatchRowcode": "             phys_br.assert_has_calls(expected_on_phys_br)"
            },
            "56": {
                "beforePatchRowNumber": 3163,
                "afterPatchRowNumber": 3164,
                "PatchRowcode": "             int_br.reset_mock()"
            },
            "57": {
                "beforePatchRowNumber": 3241,
                "afterPatchRowNumber": 3242,
                "PatchRowcode": "                 lvid=lvid,"
            },
            "58": {
                "beforePatchRowNumber": 3242,
                "afterPatchRowNumber": 3243,
                "PatchRowcode": "                 ip_version=ip_version,"
            },
            "59": {
                "beforePatchRowNumber": 3243,
                "afterPatchRowNumber": 3244,
                "PatchRowcode": "                 gateway_ip=gateway_ip)"
            },
            "60": {
                "beforePatchRowNumber": 3244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            int_br.assert_has_calls(expected_on_int_br)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3245,
                "PatchRowcode": "+            int_br.assert_has_calls(expected_on_int_br, any_order=True)"
            },
            "62": {
                "beforePatchRowNumber": 3245,
                "afterPatchRowNumber": 3246,
                "PatchRowcode": "             tun_br.assert_has_calls(expected_on_tun_br)"
            },
            "63": {
                "beforePatchRowNumber": 3246,
                "afterPatchRowNumber": 3247,
                "PatchRowcode": "             phys_br.assert_not_called()"
            },
            "64": {
                "beforePatchRowNumber": 3247,
                "afterPatchRowNumber": 3248,
                "PatchRowcode": "             int_br.reset_mock()"
            },
            "65": {
                "beforePatchRowNumber": 3489,
                "afterPatchRowNumber": 3490,
                "PatchRowcode": "                     False)"
            },
            "66": {
                "beforePatchRowNumber": 3490,
                "afterPatchRowNumber": 3491,
                "PatchRowcode": "                 lvid = self.agent.vlan_manager.get(self._net_uuid).vlan"
            },
            "67": {
                "beforePatchRowNumber": 3491,
                "afterPatchRowNumber": 3492,
                "PatchRowcode": "                 int_br.assert_has_calls("
            },
            "68": {
                "beforePatchRowNumber": 3492,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    self._expected_port_bound(self._port, lvid))"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3493,
                "PatchRowcode": "+                    self._expected_port_bound(self._port, lvid),"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3494,
                "PatchRowcode": "+                    any_order=True)"
            },
            "71": {
                "beforePatchRowNumber": 3493,
                "afterPatchRowNumber": 3495,
                "PatchRowcode": "                 expected_on_tun_br = ["
            },
            "72": {
                "beforePatchRowNumber": 3494,
                "afterPatchRowNumber": 3496,
                "PatchRowcode": "                     mock.call.provision_local_vlan(network_type='vxlan',"
            },
            "73": {
                "beforePatchRowNumber": 3495,
                "afterPatchRowNumber": 3497,
                "PatchRowcode": "                         lvid=lvid, segmentation_id=None, distributed=True),"
            },
            "74": {
                "beforePatchRowNumber": 3594,
                "afterPatchRowNumber": 3596,
                "PatchRowcode": "                 False)"
            },
            "75": {
                "beforePatchRowNumber": 3595,
                "afterPatchRowNumber": 3597,
                "PatchRowcode": "             lvid = self.agent.vlan_manager.get(self._net_uuid).vlan"
            },
            "76": {
                "beforePatchRowNumber": 3596,
                "afterPatchRowNumber": 3598,
                "PatchRowcode": "             int_br.assert_has_calls("
            },
            "77": {
                "beforePatchRowNumber": 3597,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self._expected_port_bound(self._port, lvid))"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3599,
                "PatchRowcode": "+                self._expected_port_bound(self._port, lvid), any_order=True)"
            },
            "79": {
                "beforePatchRowNumber": 3598,
                "afterPatchRowNumber": 3600,
                "PatchRowcode": "             expected_on_tun_br = ["
            },
            "80": {
                "beforePatchRowNumber": 3599,
                "afterPatchRowNumber": 3601,
                "PatchRowcode": "                 mock.call.provision_local_vlan("
            },
            "81": {
                "beforePatchRowNumber": 3600,
                "afterPatchRowNumber": 3602,
                "PatchRowcode": "                     network_type='vxlan',"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2012 OpenStack Foundation.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import contextlib",
            "import sys",
            "import time",
            "from unittest import mock",
            "",
            "import netaddr",
            "from neutron_lib.agent import constants as agent_consts",
            "from neutron_lib.api.definitions import portbindings",
            "from neutron_lib.api.definitions import provider_net",
            "from neutron_lib import constants as n_const",
            "from neutron_lib import rpc as n_rpc",
            "import os_vif",
            "from os_vif.objects import instance_info as vif_instance_object",
            "from oslo_config import cfg",
            "from oslo_log import log",
            "import oslo_messaging",
            "import testtools",
            "",
            "from neutron._i18n import _",
            "from neutron.agent.common import async_process",
            "from neutron.agent.common import ovs_lib",
            "from neutron.agent.common import polling",
            "from neutron.agent.common import utils",
            "from neutron.agent.linux import ip_lib",
            "from neutron.agent.linux import utils as linux_utils",
            "from neutron.api.rpc.callbacks import resources",
            "from neutron.objects.ports import Port",
            "from neutron.objects.ports import PortBinding",
            "from neutron.plugins.ml2.drivers.l2pop import rpc as l2pop_rpc",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants",
            "from neutron.plugins.ml2.drivers.openvswitch.agent import ovs_neutron_agent \\",
            "    as ovs_agent",
            "from neutron.tests import base",
            "from neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_test_base",
            "from neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent \\",
            "    import test_vlanmanager",
            "",
            "",
            "NOTIFIER = 'neutron.plugins.ml2.rpc.AgentNotifierApi'",
            "PULLAPI = 'neutron.api.rpc.handlers.resources_rpc.ResourcesPullRpcApi'",
            "OVS_LINUX_KERN_VERS_WITHOUT_VXLAN = \"3.12.0\"",
            "",
            "FAKE_MAC = '00:11:22:33:44:55'",
            "FAKE_IP1 = '10.0.0.1'",
            "FAKE_IP2 = '10.0.0.2'",
            "FAKE_IP6 = '2001:db8:42:42::10'",
            "",
            "TEST_PORT_ID1 = 'port-id-1'",
            "TEST_PORT_ID2 = 'port-id-2'",
            "TEST_PORT_ID3 = 'port-id-3'",
            "",
            "TEST_NETWORK_ID1 = 'net-id-1'",
            "TEST_NETWORK_ID2 = 'net-id-2'",
            "",
            "DEVICE_OWNER_COMPUTE = n_const.DEVICE_OWNER_COMPUTE_PREFIX + 'fake'",
            "",
            "",
            "class FakeVif(object):",
            "    ofport = 99",
            "    port_name = 'name'",
            "    vif_mac = 'aa:bb:cc:11:22:33'",
            "",
            "",
            "class MockFixedIntervalLoopingCall(object):",
            "    def __init__(self, f):",
            "        self.f = f",
            "",
            "    def start(self, interval=0):",
            "        self.f()",
            "",
            "",
            "class ValidateTunnelTypes(ovs_test_base.OVSAgentConfigTestBase):",
            "",
            "    def setUp(self):",
            "        super(ValidateTunnelTypes, self).setUp()",
            "        self.mock_validate_local_ip = mock.patch.object(",
            "            self.mod_agent, 'validate_local_ip').start()",
            "",
            "    def test_validate_tunnel_types_succeeds(self):",
            "        cfg.CONF.set_override('local_ip', '10.10.10.10', group='OVS')",
            "        cfg.CONF.set_override('tunnel_types', [n_const.TYPE_GRE],",
            "                              group='AGENT')",
            "        self.mod_agent.validate_tunnel_config(cfg.CONF.AGENT.tunnel_types,",
            "                                              cfg.CONF.OVS.local_ip)",
            "        self.mock_validate_local_ip.assert_called_once_with('10.10.10.10')",
            "",
            "    def test_validate_tunnel_types_fails_for_invalid_tunnel_type(self):",
            "        cfg.CONF.set_override('local_ip', '10.10.10.10', group='OVS')",
            "        cfg.CONF.set_override('tunnel_types', ['foobar'], group='AGENT')",
            "        with testtools.ExpectedException(SystemExit):",
            "            self.mod_agent.validate_tunnel_config(cfg.CONF.AGENT.tunnel_types,",
            "                                                  cfg.CONF.OVS.local_ip)",
            "",
            "",
            "class TestOvsNeutronAgent(object):",
            "",
            "    def setUp(self):",
            "        super(TestOvsNeutronAgent, self).setUp()",
            "        self.useFixture(test_vlanmanager.LocalVlanManagerFixture())",
            "        mock.patch(PULLAPI).start()",
            "        notifier_p = mock.patch(NOTIFIER)",
            "        notifier_cls = notifier_p.start()",
            "        self.notifier = mock.Mock()",
            "        notifier_cls.return_value = self.notifier",
            "        systemd_patch = mock.patch('oslo_service.systemd.notify_once')",
            "        self.systemd_notify = systemd_patch.start()",
            "",
            "        cfg.CONF.set_default('firewall_driver',",
            "                             'neutron.agent.firewall.NoopFirewallDriver',",
            "                             group='SECURITYGROUP')",
            "        cfg.CONF.set_default('quitting_rpc_timeout', 10, 'AGENT')",
            "        cfg.CONF.set_default('local_ip', '127.0.0.1', 'OVS')",
            "        cfg.CONF.set_default('host', 'host')",
            "        mock.patch(",
            "            'neutron.agent.ovsdb.native.helpers.enable_connection_uri').start()",
            "        mock.patch(",
            "            'neutron.agent.common.ovs_lib.OVSBridge.get_ports_attributes',",
            "            return_value=[]).start()",
            "",
            "        mock.patch('neutron.agent.common.ovs_lib.BaseOVS.config',",
            "                   new_callable=mock.PropertyMock,",
            "                   return_value={}).start()",
            "        mock.patch('neutron.agent.ovsdb.impl_idl._connection').start()",
            "        self.agent = self._make_agent()",
            "        self.agent.sg_agent = mock.Mock()",
            "",
            "    def _make_agent(self):",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'),\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_ancillary_bridges',",
            "                                  return_value=[]),\\",
            "                mock.patch('neutron.agent.linux.ip_lib.get_device_mac',",
            "                           return_value='00:00:00:00:00:01'),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.BaseOVS.get_bridges'),\\",
            "                mock.patch('oslo_service.loopingcall.FixedIntervalLoopingCall',",
            "                           new=MockFixedIntervalLoopingCall),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.' 'get_vif_ports',",
            "                    return_value=[]),\\",
            "                mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                           'has_alive_neutron_server'):",
            "            ext_manager = mock.Mock()",
            "            agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                   ext_manager, cfg.CONF)",
            "            agent.tun_br = self.br_tun_cls(br_name='br-tun')",
            "            return agent",
            "",
            "    def _mock_port_bound(self, ofport=None, new_local_vlan=None,",
            "                         old_local_vlan=None, db_get_val=None):",
            "        port = mock.Mock()",
            "        port.ofport = ofport",
            "        net_uuid = 'my-net-uuid'",
            "        fixed_ips = [{'subnet_id': 'my-subnet-uuid',",
            "                      'ip_address': '1.1.1.1'}]",
            "        if old_local_vlan is not None:",
            "            self.agent.vlan_manager.add(",
            "                net_uuid, old_local_vlan, None, None, None)",
            "        with mock.patch.object(self.agent, 'int_br', autospec=True) as int_br:",
            "            int_br.db_get_val.return_value = db_get_val",
            "            int_br.set_db_attribute.return_value = True",
            "            needs_binding = self.agent.port_bound(",
            "                port, net_uuid, 'local', None, None,",
            "                fixed_ips, DEVICE_OWNER_COMPUTE, False)",
            "        if db_get_val is None:",
            "            int_br.assert_not_called()",
            "            self.assertFalse(needs_binding)",
            "        else:",
            "            vlan_mapping = {'net_uuid': net_uuid,",
            "                            'network_type': 'local',",
            "                            'physical_network': 'None'}",
            "            int_br.set_db_attribute.assert_called_once_with(",
            "                \"Port\", mock.ANY, \"other_config\", vlan_mapping)",
            "            self.assertTrue(needs_binding)",
            "",
            "    def test_setup_physical_bridges_during_agent_initialization(self):",
            "        with mock.patch.object(",
            "            self.mod_agent.OVSNeutronAgent,",
            "            'setup_physical_bridges') as setup_physical_bridges,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent, 'setup_rpc') as setup_rpc:",
            "            setup_rpc.side_effect = oslo_messaging.MessagingException(",
            "                \"Test communication failure\")",
            "            try:",
            "                self._make_agent()",
            "            except oslo_messaging.MessagingException:",
            "                pass",
            "            setup_physical_bridges.assert_called_once_with(mock.ANY)",
            "",
            "    def test_datapath_type_system(self):",
            "        # verify kernel datapath is default",
            "        expected = constants.OVS_DATAPATH_SYSTEM",
            "        self.assertEqual(expected, self.agent.int_br.datapath_type)",
            "",
            "    def test_datapath_type_netdev(self):",
            "",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'), \\",
            "            mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                           'setup_ancillary_bridges',",
            "                           return_value=[]), \\",
            "            mock.patch('neutron.agent.linux.ip_lib.get_device_mac',",
            "                    return_value='00:00:00:00:00:01'), \\",
            "            mock.patch(",
            "                'neutron.agent.common.ovs_lib.BaseOVS.get_bridges'), \\",
            "            mock.patch('oslo_service.loopingcall.FixedIntervalLoopingCall',",
            "                       new=MockFixedIntervalLoopingCall), \\",
            "            mock.patch(",
            "                'neutron.agent.common.ovs_lib.OVSBridge.' 'get_vif_ports',",
            "                return_value=[]), \\",
            "            mock.patch('neutron.agent.common.ovs_lib.BaseOVS.config',",
            "                       new_callable=mock.PropertyMock,",
            "                       return_value={'datapath_types': ['netdev']}),\\",
            "            mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                       'has_alive_neutron_server'):",
            "            # validate setting non default datapath",
            "            expected = constants.OVS_DATAPATH_NETDEV",
            "            cfg.CONF.set_override('datapath_type',",
            "                                  expected,",
            "                                  group='OVS')",
            "            ext_manager = mock.Mock()",
            "            self.agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                        ext_manager, cfg.CONF)",
            "            self.assertEqual(expected, self.agent.int_br.datapath_type)",
            "",
            "    def test_agent_type_ovs(self):",
            "        # verify agent_type is default",
            "        expected = n_const.AGENT_TYPE_OVS",
            "        self.assertEqual(expected,",
            "                         self.agent.agent_state['agent_type'])",
            "",
            "    def test_agent_available_local_vlans(self):",
            "        expected = [n_const.MIN_VLAN_TAG,",
            "                    n_const.MIN_VLAN_TAG + 1,",
            "                    n_const.MAX_VLAN_TAG - 1,",
            "                    n_const.MAX_VLAN_TAG]",
            "        exception = [n_const.MIN_VLAN_TAG - 1,",
            "                     n_const.MAX_VLAN_TAG + 1,",
            "                     n_const.MAX_VLAN_TAG + 2]",
            "        available_vlan = self.agent.available_local_vlans",
            "        for tag in expected:",
            "            self.assertIn(tag, available_vlan)",
            "        for tag in exception:",
            "            self.assertNotIn(tag, available_vlan)",
            "",
            "    def _test_restore_local_vlan_maps(self, tag, segmentation_id='1'):",
            "        port = mock.Mock()",
            "        port.port_name = 'fake_port'",
            "        net_uuid = 'fake_network_id'",
            "        local_vlan_map = {'net_uuid': net_uuid,",
            "                          'network_type': 'vlan',",
            "                          'physical_network': 'fake_network'}",
            "        if segmentation_id is not None:",
            "            local_vlan_map['segmentation_id'] = segmentation_id",
            "",
            "        # this is for the call inside get_vif_ports()",
            "        get_interfaces = [{'name': port.port_name,",
            "                           'ofport': '1',",
            "                           'external_ids': {",
            "                               'iface-id': '1',",
            "                               'attached-mac': 'mac1'}},",
            "                          {'name': 'invalid',",
            "                           'ofport': ovs_lib.INVALID_OFPORT,",
            "                           'external_ids': {",
            "                               'iface-id': '2',",
            "                               'attached-mac': 'mac2'}},",
            "                          {'name': 'unassigned',",
            "                           'ofport': ovs_lib.UNASSIGNED_OFPORT,",
            "                           'external_ids': {",
            "                               'iface-id': '3',",
            "                               'attached-mac': 'mac3'}}]",
            "        # this is for the call inside _restore_local_vlan_map()",
            "        get_ports = [{'name': port.port_name,",
            "                      'other_config': local_vlan_map,",
            "                      'tag': tag}]",
            "",
            "        with mock.patch.object(self.agent.int_br,",
            "                               'get_ports_attributes',",
            "                               side_effect=[get_interfaces, get_ports]) as gpa:",
            "            self.agent._restore_local_vlan_map()",
            "            expected_hints = {}",
            "            if tag:",
            "                expected_hints[net_uuid] = tag",
            "            self.assertEqual(expected_hints, self.agent._local_vlan_hints)",
            "            # make sure invalid and unassigned ports were skipped",
            "            gpa.assert_has_calls([",
            "                mock.call('Interface', columns=mock.ANY, if_exists=True),",
            "                mock.call('Port', columns=mock.ANY, ports=['fake_port'])",
            "            ])",
            "",
            "    def test_restore_local_vlan_map_with_device_has_tag(self):",
            "        self._test_restore_local_vlan_maps(2)",
            "",
            "    def test_restore_local_vlan_map_with_device_no_tag(self):",
            "        self._test_restore_local_vlan_maps([])",
            "",
            "    def test_restore_local_vlan_map_no_segmentation_id(self):",
            "        self._test_restore_local_vlan_maps(2, segmentation_id=None)",
            "",
            "    def test_restore_local_vlan_map_segmentation_id_compat(self):",
            "        self._test_restore_local_vlan_maps(2, segmentation_id='None')",
            "",
            "    def test_check_agent_configurations_for_dvr_raises(self):",
            "        self.agent.enable_distributed_routing = True",
            "        self.agent.enable_tunneling = True",
            "        self.agent.l2_pop = False",
            "        self.assertRaises(ValueError,",
            "                          self.agent._check_agent_configurations)",
            "",
            "    def test_check_agent_configurations_for_dvr(self):",
            "        self.agent.enable_distributed_routing = True",
            "        self.agent.enable_tunneling = True",
            "        self.agent.l2_pop = True",
            "        self.assertIsNone(self.agent._check_agent_configurations())",
            "",
            "    def test_check_agent_configurations_for_dvr_with_vlan(self):",
            "        self.agent.enable_distributed_routing = True",
            "        self.agent.enable_tunneling = False",
            "        self.agent.l2_pop = False",
            "        self.assertIsNone(self.agent._check_agent_configurations())",
            "",
            "    def test_port_bound_deletes_flows_for_valid_ofport(self):",
            "        self._mock_port_bound(ofport=1, new_local_vlan=1, db_get_val={})",
            "",
            "    def test_port_bound_ignores_flows_for_invalid_ofport(self):",
            "        self._mock_port_bound(ofport=-1, new_local_vlan=1, db_get_val={})",
            "",
            "    def test_port_bound_does_not_rewire_if_already_bound(self):",
            "        self._mock_port_bound(",
            "            ofport=-1, new_local_vlan=1, old_local_vlan=1, db_get_val={})",
            "",
            "    def test_port_bound_not_found(self):",
            "        self._mock_port_bound(ofport=1, new_local_vlan=1, db_get_val=None)",
            "",
            "    def _test_port_dead(self, cur_tag=None):",
            "        port = mock.Mock()",
            "        port.ofport = 1",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.db_get_val.return_value = cur_tag",
            "            self.agent.port_dead(port)",
            "        if cur_tag is None or cur_tag == constants.DEAD_VLAN_TAG:",
            "            self.assertFalse(int_br.set_db_attribute.called)",
            "            self.assertFalse(int_br.drop_port.called)",
            "        else:",
            "            int_br.assert_has_calls([",
            "                mock.call.set_db_attribute(\"Port\", mock.ANY, \"tag\",",
            "                                           constants.DEAD_VLAN_TAG,",
            "                                           log_errors=True),",
            "                mock.call.drop_port(in_port=port.ofport),",
            "            ])",
            "",
            "    def test_port_dead(self):",
            "        self._test_port_dead()",
            "",
            "    def test_port_dead_with_port_already_dead(self):",
            "        self._test_port_dead(constants.DEAD_VLAN_TAG)",
            "",
            "    def test_port_dead_with_valid_tag(self):",
            "        self._test_port_dead(cur_tag=1)",
            "",
            "    def mock_scan_ports(self, vif_port_set=None, registered_ports=None,",
            "                        updated_ports=None, port_tags_dict=None, sync=False):",
            "        if port_tags_dict is None:  # Because empty dicts evaluate as False.",
            "            port_tags_dict = {}",
            "        with mock.patch.object(self.agent.int_br,",
            "                               'get_vif_port_set',",
            "                               return_value=vif_port_set),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_port_tag_dict',",
            "                                  return_value=port_tags_dict):",
            "            return self.agent.scan_ports(registered_ports, sync, updated_ports)",
            "",
            "    def test_scan_ports_returns_current_only_for_unchanged_ports(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 3])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set)",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ports_returns_port_changes(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added=set([3]),",
            "                                      removed=set([2]))",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ports_returns_port_changes_with_sync(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added=vif_port_set,",
            "                                      removed=set([2]))",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports,",
            "                                      sync=True)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def _test_scan_ports_with_updated_ports(self, updated_ports):",
            "        vif_port_set = set([1, 3, 4])",
            "        registered_ports = set([1, 2, 4])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added={3},",
            "                                      removed={2}, updated={4})",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports,",
            "                                      updated_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ports_finds_known_updated_ports(self):",
            "        self._test_scan_ports_with_updated_ports(set([4]))",
            "",
            "    def test_scan_ports_ignores_unknown_updated_ports(self):",
            "        # the port '5' was not seen on current ports. Hence it has either",
            "        # never been wired or already removed and should be ignored",
            "        self._test_scan_ports_with_updated_ports(set([4, 5]))",
            "",
            "    def test_scan_ports_ignores_updated_port_if_removed(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        updated_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added=set([3]),",
            "                                      removed=set([2]), updated=set([1]))",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports,",
            "                                      updated_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ports_no_vif_changes_returns_updated_port_only(self):",
            "        vif_port_set = set([1, 2, 3])",
            "        registered_ports = set([1, 2, 3])",
            "        updated_ports = set([2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, updated=set([2]))",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports,",
            "                                      updated_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def _test_process_ports_events(self, events, registered_ports,",
            "                                   ancillary_ports, expected_ports,",
            "                                   expected_ancillary, updated_ports=None,",
            "                                   ):",
            "        with mock.patch.object(self.agent, 'check_changed_vlans',",
            "                               return_value=set()):",
            "            devices_not_ready_yet = set()",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {",
            "                'added': set(), 'removed': set()}",
            "            actual = self.agent.process_ports_events(",
            "                events, registered_ports, ancillary_ports,",
            "                devices_not_ready_yet, failed_devices,",
            "                failed_ancillary_devices, updated_ports)",
            "            self.assertEqual(",
            "                (expected_ports, expected_ancillary, devices_not_ready_yet),",
            "                actual)",
            "",
            "    def test_process_ports_events_port_removed_and_added(self):",
            "        port_id_one = 'f6f104bd-37c7-4f7b-9d70-53a6bb42728f'",
            "        port_id_two = 'fbaf42ef-ab63-4cda-81d2-37ee55daac3a'",
            "        events = {",
            "            'removed':",
            "                [{'ofport': 1,",
            "                  'external_ids': {'iface-id': port_id_one,",
            "                                   'attached-mac': 'fa:16:3e:f6:1b:fb'},",
            "                  'name': 'qvof6f104bd-37'},",
            "                 {'ofport': 2,",
            "                  'external_ids': {'iface-id': port_id_two,",
            "                                   'attached-mac': 'fa:16:3e:a4:42:6e'},",
            "                  'name': 'qvofbaf42ef-ab'}],",
            "            'added':",
            "                [{'ofport': 3,",
            "                  'external_ids': {'iface-id': port_id_one,",
            "                                   'attached-mac': 'fa:16:3e:f6:1b:fb'},",
            "                  'name': 'qvof6f104bd-37'},",
            "                 {'ofport': 4,",
            "                  'external_ids': {'iface-id': port_id_two,",
            "                                   'attached-mac': 'fa:16:3e:a4:42:6e'},",
            "                  'name': 'qvofbaf42ef-ab'}],",
            "            'modified': []",
            "        }",
            "        registered_ports = {port_id_one, port_id_two}",
            "        expected_ancillary = ovs_agent.PortInfo()",
            "",
            "        # port was removed and then added",
            "        expected_ports = ovs_agent.PortInfo(",
            "            added={port_id_one, port_id_two},",
            "            current={port_id_one, port_id_two},",
            "            re_added={port_id_one, port_id_two}",
            "        )",
            "        with mock.patch.object(ovs_lib.BaseOVS, \"port_exists\",",
            "                               return_value=True):",
            "            self._test_process_ports_events(events.copy(), registered_ports,",
            "                                            set(), expected_ports,",
            "                                            expected_ancillary)",
            "",
            "        # port was added and then removed",
            "        expected_ports = ovs_agent.PortInfo(removed={port_id_one, port_id_two})",
            "        with mock.patch.object(ovs_lib.BaseOVS, \"port_exists\",",
            "                               return_value=False):",
            "            self._test_process_ports_events(events.copy(), registered_ports,",
            "                                            set(), expected_ports,",
            "                                            expected_ancillary)",
            "",
            "    def test_process_ports_events_returns_current_for_unchanged_ports(self):",
            "        events = {'added': [], 'removed': [], 'modified': []}",
            "        registered_ports = {1, 3}",
            "        ancillary_ports = {2, 5}",
            "        expected_ports = ovs_agent.PortInfo(current=registered_ports)",
            "        expected_ancillary = ovs_agent.PortInfo(current=ancillary_ports)",
            "        self._test_process_ports_events(events, registered_ports,",
            "                                        ancillary_ports, expected_ports,",
            "                                        expected_ancillary)",
            "",
            "    def test_process_port_events_no_vif_changes_return_updated_port_only(self):",
            "        events = {'added': [], 'removed': [], 'modified': []}",
            "        registered_ports = {1, 2, 3}",
            "        updated_ports = {2}",
            "        expected_ports = ovs_agent.PortInfo(current=registered_ports,",
            "                                            updated={2})",
            "        expected_ancillary = ovs_agent.PortInfo()",
            "        self._test_process_ports_events(events, registered_ports,",
            "                                        set(), expected_ports,",
            "                                        expected_ancillary, updated_ports)",
            "",
            "    def test_process_port_events_ignores_removed_port_if_never_added(self):",
            "        events = {'added': [], 'modified': [],",
            "                  'removed': [{'name': 'port2', 'ofport': 2,",
            "                               'external_ids': {'attached-mac': 'test-mac'}}]}",
            "        registered_ports = {1}",
            "        expected_ports = ovs_agent.PortInfo(current=registered_ports)",
            "        expected_ancillary = ovs_agent.PortInfo()",
            "        devices_not_ready_yet = set()",
            "        with mock.patch.object(self.agent.int_br, 'portid_from_external_ids',",
            "                               side_effect=[2]), \\",
            "            mock.patch.object(self.agent, 'check_changed_vlans',",
            "                              return_value=set()):",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {",
            "                'added': set(), 'removed': set()}",
            "            ports_not_ready_yet = set()",
            "            actual = self.agent.process_ports_events(",
            "                events, registered_ports, set(), ports_not_ready_yet,",
            "                failed_devices, failed_ancillary_devices)",
            "            self.assertEqual(",
            "                (expected_ports, expected_ancillary, devices_not_ready_yet),",
            "                actual)",
            "",
            "    def test_process_port_events_port_not_ready_yet(self):",
            "        events = {'added': [{'name': 'port5', 'ofport': [],",
            "                  'external_ids': {'attached-mac': 'test-mac'}}],",
            "                  'removed': [], 'modified': []}",
            "        old_devices_not_ready = {'port4'}",
            "        registered_ports = {1, 2, 3}",
            "        expected_ports = ovs_agent.PortInfo(current={1, 2, 3, 4}, added={4},",
            "                                            removed=set())",
            "        self.agent.ancillary_brs = []",
            "        expected_ancillary = ovs_agent.PortInfo()",
            "        with mock.patch.object(self.agent.int_br, 'portid_from_external_ids',",
            "                               side_effect=[5, 4]), \\",
            "            mock.patch.object(self.agent, 'check_changed_vlans',",
            "                              return_value=set()), \\",
            "            mock.patch.object(self.agent.int_br, 'get_ports_attributes',",
            "                              return_value=[{'name': 'port4', 'ofport': 4,",
            "                                             'external_ids': {",
            "                                                 'attached-mac': 'mac4'}}]):",
            "            expected_devices_not_ready = {'port5'}",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {",
            "                'added': set(), 'removed': set()}",
            "            actual = self.agent.process_ports_events(",
            "                events, registered_ports, set(), old_devices_not_ready,",
            "                failed_devices, failed_ancillary_devices)",
            "            self.assertEqual(",
            "                (expected_ports, expected_ancillary,",
            "                 expected_devices_not_ready), actual)",
            "",
            "    def _test_process_port_events_with_updated_ports(self, updated_ports):",
            "        events = {'added': [{'name': 'port3', 'ofport': 3,",
            "                            'external_ids': {'attached-mac': 'test-mac'}},",
            "                            {'name': 'qg-port2', 'ofport': 6,",
            "                             'external_ids': {'attached-mac': 'test-mac'}}],",
            "                  'removed': [{'name': 'port2', 'ofport': 2,",
            "                               'external_ids': {'attached-mac': 'test-mac'}},",
            "                              {'name': 'qg-port1', 'ofport': 5,",
            "                               'external_ids': {'attached-mac': 'test-mac'}}],",
            "                  'modified': []}",
            "        registered_ports = {1, 2, 4}",
            "        ancillary_ports = {5, 8}",
            "        expected_ports = ovs_agent.PortInfo(current={1, 3, 4}, added={3},",
            "                                            removed={2}, updated=updated_ports)",
            "        expected_ancillary = ovs_agent.PortInfo(current={6, 8}, added={6},",
            "                                                removed={5})",
            "        ancillary_bridge = mock.Mock()",
            "        ancillary_bridge.get_vif_port_set.return_value = {5, 6, 8}",
            "        self.agent.ancillary_brs = [ancillary_bridge]",
            "        with mock.patch.object(self.agent.int_br, 'portid_from_external_ids',",
            "                              side_effect=[3, 6, 2, 5]), \\",
            "            mock.patch.object(self.agent, 'check_changed_vlans',",
            "                              return_value=set()):",
            "",
            "            devices_not_ready_yet = set()",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {",
            "                'added': set(), 'removed': set()}",
            "            actual = self.agent.process_ports_events(",
            "                events, registered_ports, ancillary_ports,",
            "                devices_not_ready_yet, failed_devices,",
            "                failed_ancillary_devices, updated_ports)",
            "            self.assertEqual(",
            "                (expected_ports, expected_ancillary, devices_not_ready_yet),",
            "                actual)",
            "",
            "    def test_process_port_events_returns_port_changes(self):",
            "        self._test_process_port_events_with_updated_ports(set())",
            "",
            "    def test_process_port_events_finds_known_updated_ports(self):",
            "        self._test_process_port_events_with_updated_ports({4})",
            "",
            "    def test_process_port_events_ignores_unknown_updated_ports(self):",
            "        # the port '10' was not seen on current ports. Hence it has either",
            "        # never been wired or already removed and should be ignored",
            "        self._test_process_port_events_with_updated_ports({4, 10})",
            "",
            "    def test_process_port_events_ignores_updated_port_if_removed(self):",
            "        self._test_process_port_events_with_updated_ports({4, 5})",
            "",
            "    def test_update_ports_returns_changed_vlan(self):",
            "        br = self.br_int_cls('br-int')",
            "        mac = \"ca:fe:de:ad:be:ef\"",
            "        port = ovs_lib.VifPort(1, 1, 1, mac, br)",
            "        self.agent.vlan_manager.add(",
            "            '1', 1, '1', None, 1, {port.vif_id: port})",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        port_tags_dict = {1: []}",
            "        expected = ovs_agent.PortInfo(added={3}, current=vif_port_set,",
            "                                      removed={2}, updated={1})",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True), \\",
            "                mock.patch.object(self.agent.plugin_rpc,",
            "                                  'update_device_list') as upd_l:",
            "            actual = self.mock_scan_ports(",
            "                vif_port_set, registered_ports, port_tags_dict=port_tags_dict)",
            "        self.assertEqual(expected, actual)",
            "        upd_l.assert_called_once_with(mock.ANY, [], set([1]),",
            "                                      self.agent.agent_id,",
            "                                      self.agent.conf.host)",
            "",
            "    def test_update_retries_map_and_remove_devs_not_to_retry(self):",
            "        failed_devices_retries_map = {",
            "            'device_not_to_retry': constants.MAX_DEVICE_RETRIES,",
            "            'device_to_retry': 2,",
            "            'ancillary_not_to_retry': constants.MAX_DEVICE_RETRIES,",
            "            'ancillary_to_retry': 1}",
            "        failed_devices = {",
            "            'added': set(['device_not_to_retry']),",
            "            'removed': set(['device_to_retry', 'new_device'])}",
            "        failed_ancillary_devices = {'added': set(['ancillary_to_retry']),",
            "                                    'removed': set(['ancillary_not_to_retry'])}",
            "        expected_failed_devices_retries_map = {",
            "            'device_to_retry': 3, 'new_device': 1, 'ancillary_to_retry': 2}",
            "        (new_failed_devices_retries_map, devices_not_to_retry,",
            "         ancillary_devices_not_t_retry) = self.agent._get_devices_not_to_retry(",
            "            failed_devices, failed_ancillary_devices,",
            "            failed_devices_retries_map)",
            "        self.agent._remove_devices_not_to_retry(",
            "            failed_devices, failed_ancillary_devices, devices_not_to_retry,",
            "            ancillary_devices_not_t_retry)",
            "        self.assertIn('device_to_retry', failed_devices['removed'])",
            "        self.assertNotIn('device_not_to_retry', failed_devices['added'])",
            "        self.assertEqual(",
            "            expected_failed_devices_retries_map,",
            "            new_failed_devices_retries_map)",
            "",
            "    def test_add_port_tag_info(self):",
            "        lvm = mock.Mock()",
            "        lvm.vlan = 1",
            "        self.agent.vlan_manager.mapping[\"net1\"] = lvm",
            "        ovs_db_list = [{'name': 'tap1',",
            "                        'tag': [],",
            "                        'other_config': {'segmentation_id': '1'}},",
            "                       {'name': 'tap2',",
            "                        'tag': [],",
            "                        'other_config': {}},",
            "                       {'name': 'tap3',",
            "                        'tag': [],",
            "                        'other_config': None}]",
            "        vif_port1 = mock.Mock()",
            "        vif_port1.port_name = 'tap1'",
            "        vif_port2 = mock.Mock()",
            "        vif_port2.port_name = 'tap2'",
            "        vif_port3 = mock.Mock()",
            "        vif_port3.port_name = 'tap3'",
            "        port_details = [",
            "            {'network_id': 'net1', 'vif_port': vif_port1},",
            "            {'network_id': 'net1', 'vif_port': vif_port2},",
            "            {'network_id': 'net1', 'vif_port': vif_port3}]",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list",
            "            self.agent._add_port_tag_info(port_details)",
            "            set_db_attribute_calls = \\",
            "                [mock.call.set_db_attribute(\"Port\", \"tap1\",",
            "                    \"other_config\", {\"segmentation_id\": \"1\", \"tag\": \"1\"}),",
            "                 mock.call.set_db_attribute(\"Port\", \"tap2\",",
            "                    \"other_config\", {\"tag\": \"1\"}),",
            "                 mock.call.set_db_attribute(\"Port\", \"tap3\",",
            "                    \"other_config\", {\"tag\": \"1\"})]",
            "            int_br.assert_has_calls(set_db_attribute_calls, any_order=True)",
            "",
            "    def test_add_port_tag_info_with_tagged_ports(self):",
            "        lvm = mock.Mock()",
            "        lvm.vlan = 1",
            "        self.agent.vlan_manager.mapping[\"net1\"] = lvm",
            "        ovs_db_list1 = [{'name': 'tap1',",
            "                         'tag': 1,",
            "                         'other_config': {'segmentation_id': '1', 'tag': '1'}}]",
            "        ovs_db_list2 = [{'name': 'tap2',",
            "                         'tag': 2,",
            "                         'other_config': {'segmentation_id': '1', 'tag': '1'}},",
            "                        {'name': 'tap3',",
            "                         'tag': 1,",
            "                         'other_config': {'segmentation_id': '2', 'tag': '2'}}]",
            "        vif_port1 = mock.Mock()",
            "        vif_port1.port_name = 'tap1'",
            "        vif_port2 = mock.Mock()",
            "        vif_port2.port_name = 'tap2'",
            "        vif_port2.ofport = 7",
            "        vif_port3 = mock.Mock()",
            "        vif_port3.port_name = 'tap3'",
            "        vif_port3.ofport = 8",
            "        port_details1 = [{'network_id': 'net1', 'vif_port': vif_port1}]",
            "        port_details2 = [{'network_id': 'net1', 'vif_port': vif_port2},",
            "                         {'network_id': 'net1', 'vif_port': vif_port3}]",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list1",
            "            self.agent._add_port_tag_info(port_details1)",
            "            int_br.set_db_attribute.assert_not_called()",
            "            # Reset mock to check port with changed tag",
            "            int_br.reset_mock()",
            "            int_br.get_ports_attributes.return_value = ovs_db_list2",
            "            self.agent._add_port_tag_info(port_details2)",
            "            expected_calls = \\",
            "                [mock.call.set_db_attribute(\"Port\", \"tap2\",",
            "                    \"other_config\", {'segmentation_id': '1', 'tag': '1'}),",
            "                 mock.call.uninstall_flows(in_port=7),",
            "                 mock.call.set_db_attribute(\"Port\", \"tap3\",",
            "                     \"other_config\", {'segmentation_id': '2', 'tag': '1'}),",
            "                 mock.call.uninstall_flows(in_port=8)]",
            "            int_br.assert_has_calls(expected_calls)",
            "",
            "    def test_bind_devices(self):",
            "        devices_up = ['tap1']",
            "        devices_down = ['tap2']",
            "        self.agent.vlan_manager.mapping[\"net1\"] = mock.Mock()",
            "        ovs_db_list = [{'name': 'tap1', 'tag': []},",
            "                       {'name': 'tap2', 'tag': []}]",
            "        vif_port1 = mock.Mock()",
            "        vif_port1.port_name = 'tap1'",
            "        vif_port2 = mock.Mock()",
            "        vif_port2.port_name = 'tap2'",
            "        port_details = [",
            "            {'network_id': 'net1', 'vif_port': vif_port1,",
            "             'device': devices_up[0],",
            "             'device_owner': 'network:dhcp',",
            "             'admin_state_up': True},",
            "            {'network_id': 'net1', 'vif_port': vif_port2,",
            "             'device': devices_down[0],",
            "             'device_owner': 'network:dhcp',",
            "             'admin_state_up': False}]",
            "        with mock.patch.object(",
            "            self.agent.plugin_rpc, 'update_device_list',",
            "            return_value={'devices_up': devices_up,",
            "                          'devices_down': devices_down,",
            "                          'failed_devices_up': [],",
            "                          'failed_devices_down': []}) as update_devices, \\",
            "                mock.patch.object(self.agent,",
            "                                  'int_br') as int_br:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list",
            "            self.agent._bind_devices(port_details)",
            "            update_devices.assert_called_once_with(mock.ANY, devices_up,",
            "                                                   devices_down,",
            "                                                   mock.ANY, mock.ANY,",
            "                                                   refresh_tunnels=True)",
            "",
            "    def _test_bind_devices_sets_refresh_tunnels(self, tun_ofports, expected):",
            "        self.agent.iter_num = 3",
            "        self.agent.prevent_arp_spoofing = False",
            "        self.agent.vlan_manager.add('fake_network', 1,",
            "                                    n_const.TYPE_VXLAN, None, 1)",
            "        ovs_db_list = [{'name': 'fake_device', 'tag': []}]",
            "        self.agent.vlan_manager.get('fake_network').tun_ofports = tun_ofports",
            "        vif_port = mock.Mock()",
            "        vif_port.port_name = 'fake_device'",
            "        vif_port.ofport = 1",
            "        need_binding_ports = [{'network_id': 'fake_network',",
            "                               'vif_port': vif_port,",
            "                               'device': 'fake_device',",
            "                               'admin_state_up': True}]",
            "        with mock.patch.object(",
            "            self.agent.plugin_rpc, 'update_device_list',",
            "            return_value={'devices_up': [],",
            "                          'devices_down': [],",
            "                          'failed_devices_up': [],",
            "                          'failed_devices_down': []}) as update_devices, \\",
            "                mock.patch.object(self.agent,",
            "                                  'int_br') as int_br:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list",
            "            self.agent._bind_devices(need_binding_ports)",
            "            update_devices.assert_called_once_with(mock.ANY, ['fake_device'],",
            "                                                   [], mock.ANY, mock.ANY,",
            "                                                   refresh_tunnels=expected)",
            "",
            "    def test_bind_devices_sets_refresh_tunnels_if_tunnels_missing(self):",
            "        self._test_bind_devices_sets_refresh_tunnels([], True)",
            "",
            "    def test_bind_devices_does_not_set_refresh_tunnels_if_tunnels_exist(self):",
            "        self._test_bind_devices_sets_refresh_tunnels([1, 2, 3], False)",
            "",
            "    def _test_arp_spoofing(self, enable_prevent_arp_spoofing):",
            "        self.agent.prevent_arp_spoofing = enable_prevent_arp_spoofing",
            "",
            "        ovs_db_list = [{'name': 'fake_device', 'tag': []}]",
            "        self.agent.vlan_manager.add('fake_network', 1, None, None, 1)",
            "        vif_port = mock.Mock()",
            "        vif_port.port_name = 'fake_device'",
            "        vif_port.ofport = 1",
            "        need_binding_ports = [{'network_id': 'fake_network',",
            "                               'vif_port': vif_port,",
            "                               'device': 'fake_device',",
            "                               'admin_state_up': True}]",
            "        with mock.patch.object(",
            "            self.agent.plugin_rpc, 'update_device_list',",
            "            return_value={'devices_up': [],",
            "                          'devices_down': [],",
            "                          'failed_devices_up': [],",
            "                          'failed_devices_down': []}), \\",
            "                mock.patch.object(self.agent,",
            "                                  'int_br') as int_br, \\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    'setup_arp_spoofing_protection') as setup_arp:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list",
            "            self.agent._bind_devices(need_binding_ports)",
            "            self.assertEqual(enable_prevent_arp_spoofing, setup_arp.called)",
            "",
            "    def test_setup_arp_spoofing_protection_enable(self):",
            "        self._test_arp_spoofing(True)",
            "",
            "    def test_setup_arp_spoofing_protection_disabled(self):",
            "        self._test_arp_spoofing(False)",
            "",
            "    def _mock_treat_devices_added_updated(self, details, port, func_name):",
            "        \"\"\"Mock treat devices added or updated.",
            "",
            "        :param details: the details to return for the device",
            "        :param port: the port that get_vif_port_by_id should return",
            "        :param func_name: the function that should be called",
            "        :returns: whether the named function was called",
            "        \"\"\"",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [details],",
            "                                             'failed_devices': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={details['device']: port}),\\",
            "                mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={'devices_up': [],",
            "                                                'devices_down': details,",
            "                                                'failed_devices_up': [],",
            "                                                'failed_devices_down': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                    'get_port_tag_dict',",
            "                    return_value={}),\\",
            "                mock.patch.object(self.agent, func_name) as func:",
            "            skip_devs, _, need_bound_devices, _ = (",
            "                self.agent.treat_devices_added_or_updated([], False, set()))",
            "            # The function should not raise",
            "            self.assertFalse(skip_devs)",
            "            return func.called",
            "",
            "    def test_treat_devices_added_updated_no_active_binding(self):",
            "        details = {'device': 'id',",
            "                   n_const.NO_ACTIVE_BINDING: True}",
            "        port = mock.Mock()",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [details],",
            "                                             'failed_devices': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={details['device']: port}),\\",
            "                mock.patch.object(self.agent, 'port_dead') as func:",
            "            skip_devs, binding_no_activated_devices, _, _ = (",
            "                self.agent.treat_devices_added_or_updated([], False, set()))",
            "            self.assertFalse(skip_devs)",
            "            self.assertTrue(func.called)",
            "            self.assertIn('id', binding_no_activated_devices)",
            "",
            "    def test_treat_devices_added_updated_ignores_invalid_ofport(self):",
            "        port = mock.Mock()",
            "        port.ofport = -1",
            "        self.assertFalse(self._mock_treat_devices_added_updated(",
            "            mock.MagicMock(), port, 'port_dead'))",
            "",
            "    def test_treat_devices_added_updated_marks_unknown_port_as_dead(self):",
            "        port = mock.Mock()",
            "        port.ofport = 1",
            "        self.assertTrue(self._mock_treat_devices_added_updated(",
            "            mock.MagicMock(), port, 'port_dead'))",
            "",
            "    def test_treat_devices_added_does_not_process_missing_port(self):",
            "        with mock.patch.object(",
            "            self.agent.plugin_rpc,",
            "            'get_devices_details_list_and_failed_devices') as get_dev_fn,\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=None):",
            "            get_dev_fn.assert_not_called()",
            "",
            "    def test_treat_devices_added_updated_updates_known_port(self):",
            "        details = mock.MagicMock()",
            "        details.__contains__.side_effect = lambda x: True",
            "        self.assertTrue(self._mock_treat_devices_added_updated(",
            "            details, mock.Mock(), 'treat_vif_port'))",
            "",
            "    def test_treat_devices_added_updated_sends_vif_port_into_extension_manager(",
            "            self, *args):",
            "        details = mock.MagicMock()",
            "        details.__contains__.side_effect = lambda x: True",
            "        port = mock.MagicMock()",
            "",
            "        def fake_handle_port(context, port):",
            "            self.assertIn('vif_port', port)",
            "",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [details],",
            "                                             'failed_devices': []}),\\",
            "            mock.patch.object(self.agent.ext_manager,",
            "                              'handle_port', new=fake_handle_port),\\",
            "            mock.patch.object(self.agent.int_br,",
            "                              'get_vifs_by_ids',",
            "                              return_value={details['device']: port}),\\",
            "            mock.patch.object(self.agent, 'treat_vif_port',",
            "                              return_value=False):",
            "",
            "            self.agent.treat_devices_added_or_updated([], False, set())",
            "",
            "    def test_treat_devices_added_updated_skips_if_port_not_found(self):",
            "        dev_mock = mock.MagicMock()",
            "        dev_mock.__getitem__.return_value = 'the_skipped_one'",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [dev_mock],",
            "                                             'failed_devices': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                    'get_port_tag_dict',",
            "                    return_value={}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={}),\\",
            "                mock.patch.object(self.agent.ext_manager,",
            "                                  \"delete_port\") as ext_mgr_delete_port,\\",
            "                mock.patch.object(self.agent,",
            "                                  'treat_vif_port') as treat_vif_port:",
            "            skip_devs = self.agent.treat_devices_added_or_updated(",
            "                [], False, set())",
            "            # The function should return False for resync and no device",
            "            # processed",
            "            self.assertEqual((['the_skipped_one'], set(), [], set()),",
            "                             skip_devs)",
            "            ext_mgr_delete_port.assert_called_once_with(",
            "                self.agent.context, {'port_id': 'the_skipped_one'})",
            "            treat_vif_port.assert_not_called()",
            "",
            "    def test_treat_devices_added_failed_devices(self):",
            "        dev_mock = 'the_failed_one'",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [],",
            "                                             'failed_devices': [dev_mock]}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={}),\\",
            "                mock.patch.object(self.agent,",
            "                                  'treat_vif_port') as treat_vif_port:",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            (_, _, _, failed_devices['added']) = (",
            "                self.agent.treat_devices_added_or_updated([], False, set()))",
            "            # The function should return False for resync and no device",
            "            # processed",
            "            self.assertEqual(set([dev_mock]), failed_devices.get('added'))",
            "            treat_vif_port.assert_not_called()",
            "",
            "    def test_treat_devices_added_updated_put_port_down(self):",
            "        fake_details_dict = {'admin_state_up': False,",
            "                             'port_id': 'xxx',",
            "                             'device': 'xxx',",
            "                             'network_id': 'yyy',",
            "                             'physical_network': 'foo',",
            "                             'segmentation_id': 'bar',",
            "                             'network_type': 'baz',",
            "                             'fixed_ips': [{'subnet_id': 'my-subnet-uuid',",
            "                                            'ip_address': '1.1.1.1'}],",
            "                             'device_owner': DEVICE_OWNER_COMPUTE",
            "                             }",
            "",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [fake_details_dict],",
            "                                             'failed_devices': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={'xxx': mock.MagicMock()}),\\",
            "                mock.patch.object(self.agent.int_br, 'get_port_tag_dict',",
            "                                  return_value={}),\\",
            "                mock.patch.object(self.agent,",
            "                                  'treat_vif_port') as treat_vif_port:",
            "            skip_devs, _, need_bound_devices, _ = (",
            "                self.agent.treat_devices_added_or_updated([], False, set()))",
            "            # The function should return False for resync",
            "            self.assertFalse(skip_devs)",
            "            self.assertTrue(treat_vif_port.called)",
            "",
            "    def _mock_treat_devices_removed(self, port_exists):",
            "        details = dict(exists=port_exists)",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'update_device_list',",
            "                               return_value={'devices_up': [],",
            "                                             'devices_down': details,",
            "                                             'failed_devices_up': [],",
            "                                             'failed_devices_down': []}):",
            "            with mock.patch.object(self.agent, 'port_unbound') as port_unbound:",
            "                with mock.patch.object(self.agent.int_br,",
            "                                       'get_vif_port_by_id',",
            "                                       return_value=None):",
            "                    self.assertFalse(self.agent.treat_devices_removed([{}]))",
            "        self.assertTrue(port_unbound.called)",
            "",
            "    def test_treat_devices_removed_unbinds_port(self):",
            "        self._mock_treat_devices_removed(True)",
            "",
            "    def test_treat_devices_removed_ignores_missing_port(self):",
            "        self._mock_treat_devices_removed(False)",
            "",
            "    def test_treat_devices_removed_failed_devices(self):",
            "        dev_mock = 'the_failed_one'",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'update_device_list',",
            "                               return_value={'devices_up': [],",
            "                                             'devices_down': [],",
            "                                             'failed_devices_up': [],",
            "                                             'failed_devices_down': [",
            "                                                 dev_mock]}):",
            "            with mock.patch.object(self.agent.int_br,",
            "                                   'get_vif_port_by_id',",
            "                                   return_value=None):",
            "                failed_devices = {'added': set(), 'removed': set()}",
            "                failed_devices['removed'] = \\",
            "                    self.agent.treat_devices_removed([{}])",
            "                self.assertEqual(set([dev_mock]),",
            "                                 failed_devices.get('removed'))",
            "",
            "    def test_treat_devices_removed_ext_delete_port(self):",
            "        port_id = 'fake-id'",
            "",
            "        m_delete = mock.patch.object(self.agent.ext_manager, 'delete_port')",
            "        m_rpc = mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={'devices_up': [],",
            "                                                'devices_down': [],",
            "                                                'failed_devices_up': [],",
            "                                                'failed_devices_down': []})",
            "        m_unbound = mock.patch.object(self.agent, 'port_unbound')",
            "        with m_delete as delete, m_rpc, m_unbound:",
            "            with mock.patch.object(self.agent.int_br,",
            "                                   'get_vif_port_by_id',",
            "                                   return_value=None):",
            "                self.agent.treat_devices_removed([port_id])",
            "                delete.assert_called_with(mock.ANY, {'port_id': port_id})",
            "",
            "    def test_treat_vif_port_shut_down_port(self):",
            "        details = mock.MagicMock()",
            "        vif_port = type('vif_port', (object,), {",
            "            \"vif_id\": \"12\",",
            "            \"iface-id\": \"407a79e0-e0be-4b7d-92a6-513b2161011b\",",
            "            \"vif_mac\": \"fa:16:3e:68:46:7b\",",
            "            \"port_name\": \"qr-407a79e0-e0\",",
            "            \"ofport\": -1,",
            "            \"bridge_name\": \"br-int\"})",
            "        with mock.patch.object(",
            "                self.agent.plugin_rpc, 'update_device_down'",
            "        ) as update_device_down, mock.patch.object(",
            "            self.agent, \"port_dead\"",
            "        ) as port_dead:",
            "            port_needs_binding = self.agent.treat_vif_port(",
            "                vif_port, details['port_id'],",
            "                details['network_id'],",
            "                details['network_type'],",
            "                details['physical_network'],",
            "                details['segmentation_id'],",
            "                False,",
            "                details['fixed_ips'],",
            "                details['device_owner'], False)",
            "        self.assertFalse(port_needs_binding)",
            "        port_dead.assert_called_once_with(vif_port)",
            "        update_device_down.assert_called_once_with(",
            "            self.agent.context, details['port_id'], self.agent.agent_id,",
            "            self.agent.conf.host)",
            "",
            "    def test_bind_port_with_missing_network(self):",
            "        vif_port = mock.Mock()",
            "        vif_port.name.return_value = 'port'",
            "        self.agent._bind_devices([{'network_id': 'non-existent',",
            "                                   'vif_port': vif_port}])",
            "",
            "    def _test_process_network_ports(self, port_info, skipped_devices=None,",
            "                                    binding_no_activated_devices=None):",
            "        failed_devices = {'added': set(), 'removed': set()}",
            "        skipped_devices = skipped_devices or []",
            "        binding_no_activated_devices = binding_no_activated_devices or set()",
            "        added_devices = port_info.get('added', set())",
            "        with mock.patch.object(self.agent.sg_agent,",
            "                               \"setup_port_filters\") as setup_port_filters,\\",
            "                mock.patch.object(",
            "                    self.agent, \"treat_devices_added_or_updated\",",
            "                    return_value=(",
            "                        skipped_devices, binding_no_activated_devices, [],",
            "                        failed_devices['added'])) as device_added_updated,\\",
            "                mock.patch.object(self.agent.int_br, \"get_ports_attributes\",",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent,",
            "                                  \"treat_devices_removed\",",
            "                                  return_value=(",
            "                                      failed_devices[",
            "                                          'removed'])) as device_removed,\\",
            "                mock.patch.object(self.agent,",
            "                                  \"treat_devices_skipped\",",
            "                                  return_value=(",
            "                                      skipped_devices)) as device_skipped:",
            "            self.assertEqual(",
            "                failed_devices,",
            "                self.agent.process_network_ports(port_info, False))",
            "            setup_port_filters.assert_called_once_with(",
            "                (added_devices - set(skipped_devices) -",
            "                    binding_no_activated_devices),",
            "                port_info.get('updated', set()))",
            "            devices_added_updated = (added_devices |",
            "                                     port_info.get('updated', set()))",
            "            if devices_added_updated:",
            "                device_added_updated.assert_called_once_with(",
            "                    devices_added_updated, False, set())",
            "            if port_info.get('removed', set()):",
            "                device_removed.assert_called_once_with(port_info['removed'])",
            "            if skipped_devices:",
            "                device_skipped.assert_called_once_with(set(skipped_devices))",
            "",
            "    def test_process_network_ports(self):",
            "        self._test_process_network_ports(",
            "            {'current': set(['tap0']),",
            "             'removed': set(['eth0']),",
            "             'added': set(['eth1'])})",
            "",
            "    def test_process_network_port_with_updated_ports(self):",
            "        self._test_process_network_ports(",
            "            {'current': set(['tap0', 'tap1']),",
            "             'updated': set(['tap1', 'eth1']),",
            "             'removed': set(['eth0']),",
            "             'added': set(['eth1'])})",
            "",
            "    def test_process_network_port_with_skipped_ports(self):",
            "        port_info = {'current': set(['tap0', 'tap1']),",
            "                     'removed': set(['eth0']),",
            "                     'added': set(['eth1', 'eth2'])}",
            "        self._test_process_network_ports(port_info, skipped_devices=['eth1'])",
            "",
            "    def test_process_network_port_with_binding_no_activated_devices(self):",
            "        port_info = {'current': set(['tap0', 'tap1']),",
            "                     'removed': set(['eth0']),",
            "                     'added': set(['eth1', 'eth2', 'eth3'])}",
            "        self._test_process_network_ports(",
            "            port_info, skipped_devices=['eth1'],",
            "            binding_no_activated_devices=set(['eth3']))",
            "",
            "    def test_process_network_port_with_empty_port(self):",
            "        self._test_process_network_ports({})",
            "",
            "    @mock.patch.object(linux_utils, 'execute', return_value=False)",
            "    def test_hybrid_plug_flag_based_on_firewall(self, *args):",
            "        cfg.CONF.set_default(",
            "            'firewall_driver',",
            "            'neutron.agent.firewall.NoopFirewallDriver',",
            "            group='SECURITYGROUP')",
            "        agt = self._make_agent()",
            "        self.assertFalse(agt.agent_state['configurations']['ovs_hybrid_plug'])",
            "        cfg.CONF.set_default(",
            "            'firewall_driver',",
            "            'neutron.agent.linux.openvswitch_firewall.OVSFirewallDriver',",
            "            group='SECURITYGROUP')",
            "        with mock.patch('neutron.agent.linux.openvswitch_firewall.'",
            "                        'OVSFirewallDriver.initialize_bridge'):",
            "            agt = self._make_agent()",
            "        self.assertFalse(agt.agent_state['configurations']['ovs_hybrid_plug'])",
            "        cfg.CONF.set_default(",
            "            'firewall_driver',",
            "            'neutron.agent.linux.iptables_firewall.'",
            "            'OVSHybridIptablesFirewallDriver',",
            "            group='SECURITYGROUP')",
            "        with mock.patch('neutron.agent.linux.ip_conntrack.'",
            "                        'IpConntrackManager._populate_initial_zone_map'):",
            "            agt = self._make_agent()",
            "        self.assertTrue(agt.agent_state['configurations']['ovs_hybrid_plug'])",
            "",
            "    def test_report_state(self):",
            "        with mock.patch.object(self.agent.state_rpc,",
            "                               \"report_state\") as report_st:",
            "            self.agent.int_br_device_count = 5",
            "            self.systemd_notify.assert_not_called()",
            "            self.agent._report_state()",
            "            report_st.assert_called_with(self.agent.context,",
            "                                         self.agent.agent_state, True)",
            "            self.systemd_notify.assert_called_once_with()",
            "            self.systemd_notify.reset_mock()",
            "            # agent keeps sending \"start_flag\" while iter 0 not completed",
            "            self.assertIn(\"start_flag\", self.agent.agent_state)",
            "            self.assertEqual(",
            "                self.agent.agent_state[\"configurations\"][\"devices\"],",
            "                self.agent.int_br_device_count",
            "            )",
            "            self.agent._report_state()",
            "            report_st.assert_called_with(self.agent.context,",
            "                                         self.agent.agent_state, True)",
            "            self.systemd_notify.assert_not_called()",
            "",
            "    def test_report_state_fail(self):",
            "        with mock.patch.object(self.agent.state_rpc,",
            "                               \"report_state\") as report_st:",
            "            report_st.side_effect = Exception()",
            "            self.agent._report_state()",
            "            report_st.assert_called_with(self.agent.context,",
            "                                         self.agent.agent_state, True)",
            "            self.agent._report_state()",
            "            report_st.assert_called_with(self.agent.context,",
            "                                         self.agent.agent_state, True)",
            "            self.systemd_notify.assert_not_called()",
            "",
            "    def test_report_state_revived(self):",
            "        with mock.patch.object(self.agent.state_rpc,",
            "                               \"report_state\") as report_st:",
            "            report_st.return_value = agent_consts.AGENT_REVIVED",
            "            self.agent._report_state()",
            "            self.assertTrue(self.agent.fullsync)",
            "",
            "    def test_port_update(self):",
            "        port_arg = {\"id\": TEST_PORT_ID1}",
            "        with mock.patch.object(self.agent.plugin_rpc.remote_resource_cache,",
            "                               \"get_resource_by_id\") as mocked_resource:",
            "            port = Port()",
            "            port['mac_address'] = netaddr.EUI(FAKE_MAC)",
            "            port['device_id'] = '0'",
            "            port_bind = PortBinding()",
            "            port_bind['host'] = 'host'",
            "            port_bind['vnic_type'] = 'normal'",
            "            port.bindings = [port_bind]",
            "            mocked_resource.return_value = port",
            "            self.agent.port_update(\"unused_context\",",
            "                                   port=port_arg,",
            "                                   network_type=\"vlan\",",
            "                                   segmentation_id=\"1\",",
            "                                   physical_network=\"physnet\")",
            "            self.assertEqual(set([TEST_PORT_ID1]), self.agent.updated_ports)",
            "            self.assertEqual([], self.agent.updated_smartnic_ports)",
            "",
            "    def test_port_update_smartnic(self):",
            "        cfg.CONF.set_default('baremetal_smartnic', True, group='AGENT')",
            "        port_arg = {\"id\": TEST_PORT_ID1}",
            "        with mock.patch.object(self.agent.plugin_rpc.remote_resource_cache,",
            "                               \"get_resource_by_id\") as mocked_resource:",
            "            port = Port()",
            "            port['id'] = 'd850ed99-5f46-47bc-8c06-86d9d519c46a'",
            "            port['mac_address'] = netaddr.EUI(FAKE_MAC)",
            "            port['device_id'] = '0'",
            "            bindings_data = PortBinding()",
            "            bindings_data['host'] = 'host'",
            "            bindings_data['vnic_type'] = portbindings.VNIC_SMARTNIC",
            "            bindings_data['vif_type'] = portbindings.VIF_TYPE_OVS",
            "            bindings_data['profile'] = {",
            "                'local_link_information': [{'port_id': 'rep_port'}]}",
            "            port.bindings = [bindings_data]",
            "            mocked_resource.return_value = port",
            "            self.agent.port_update(\"unused_context\",",
            "                                   port=port_arg)",
            "            expected_smartnic_port_data = {",
            "                'mac': port['mac_address'],",
            "                'vm_uuid': port['device_id'],",
            "                'vif_name': 'rep_port',",
            "                'iface_id': port['id'],",
            "                'vif_type': bindings_data['vif_type']",
            "            }",
            "            self.assertEqual({TEST_PORT_ID1}, self.agent.updated_ports)",
            "            self.assertEqual([expected_smartnic_port_data],",
            "                             self.agent.updated_smartnic_ports)",
            "",
            "    def test_port_update_unbound_smartnic_port(self):",
            "        cfg.CONF.set_default('baremetal_smartnic', True, group='AGENT')",
            "        port_arg = {\"id\": 'd850ed99-5f46-47bc-8c06-86d9d519c46a'}",
            "        vif_name = \"rep0-0\"",
            "        vif_id = port_arg[\"id\"]",
            "        vif_mac = FAKE_MAC",
            "        self.agent.current_smartnic_ports_map = {",
            "            vif_id: {",
            "                'vif_mac': vif_mac,",
            "                'vif_name': vif_name}}",
            "",
            "        with mock.patch.object(self.agent.plugin_rpc.remote_resource_cache,",
            "                               \"get_resource_by_id\") as mocked_resource:",
            "            port = Port()",
            "            port['id'] = port_arg[\"id\"]",
            "            port['mac_address'] = netaddr.EUI(FAKE_MAC)",
            "            port['device_id'] = '0'",
            "            bindings_data = PortBinding()",
            "            bindings_data['host'] = ''",
            "            bindings_data['vnic_type'] = portbindings.VNIC_SMARTNIC",
            "            bindings_data['vif_type'] = portbindings.VIF_TYPE_UNBOUND",
            "            bindings_data['profile'] = {}",
            "            port.bindings = [bindings_data]",
            "            mocked_resource.return_value = port",
            "            self.agent.port_update(\"unused_context\",",
            "                                   port=port_arg)",
            "            expected_smartnic_port_data = [{",
            "                'mac': port['mac_address'],",
            "                'vm_uuid': '',",
            "                'vif_name': 'rep0-0',",
            "                'iface_id': port['id'],",
            "                'vif_type': portbindings.VIF_TYPE_UNBOUND",
            "            }]",
            "            mocked_resource.assert_called_with(resources.PORT, port['id'])",
            "            self.assertEqual({port['id']}, self.agent.updated_ports)",
            "            self.assertEqual(expected_smartnic_port_data,",
            "                             self.agent.updated_smartnic_ports)",
            "",
            "    def test_port_update_unbound_smartnic_port_not_belong_to_the_agent(self):",
            "        cfg.CONF.set_default('baremetal_smartnic', True, group='AGENT')",
            "        port_arg = {\"id\": 'd850ed99-5f46-47bc-8c06-86d9d519c46a'}",
            "        vif_name = \"rep0-0\"",
            "        vif_id = 'd850ed99-5f46-47bc-8c06-86d9d519c46b'",
            "        vif_mac = FAKE_MAC",
            "        self.agent.current_smartnic_ports_map = {",
            "            vif_id: {",
            "                'vif_mac': vif_mac,",
            "                'vif_name': vif_name}}",
            "",
            "        with mock.patch.object(self.agent.plugin_rpc.remote_resource_cache,",
            "                               \"get_resource_by_id\") as mocked_resource:",
            "            port = Port()",
            "            port['id'] = port_arg[\"id\"]",
            "            port['mac_address'] = netaddr.EUI(FAKE_MAC)",
            "            port['device_id'] = '0'",
            "            bindings_data = PortBinding()",
            "            bindings_data['host'] = ''",
            "            bindings_data['vnic_type'] = portbindings.VNIC_SMARTNIC",
            "            bindings_data['vif_type'] = portbindings.VIF_TYPE_UNBOUND",
            "            bindings_data['profile'] = {}",
            "            port.bindings = [bindings_data]",
            "            mocked_resource.return_value = port",
            "            self.agent.port_update(\"unused_context\",",
            "                                   port=port_arg)",
            "            mocked_resource.assert_called_with(resources.PORT, port['id'])",
            "            self.assertEqual({port['id']}, self.agent.updated_ports)",
            "            self.assertEqual([], self.agent.updated_smartnic_ports)",
            "",
            "    def test_port_delete_after_update(self):",
            "        \"\"\"Make sure a port is not marked for delete and update.\"\"\"",
            "        port = {'id': TEST_PORT_ID1}",
            "",
            "        self.agent.port_update(context=None, port=port)",
            "        self.agent.port_delete(context=None, port_id=port['id'])",
            "        self.assertEqual(set(), self.agent.updated_ports)",
            "        self.assertEqual(set([port['id']]), self.agent.deleted_ports)",
            "",
            "    def test_process_deleted_ports_cleans_network_ports(self):",
            "        self.agent._update_port_network(TEST_PORT_ID1, TEST_NETWORK_ID1)",
            "        self.agent.port_delete(context=None, port_id=TEST_PORT_ID1)",
            "        self.agent.sg_agent = mock.Mock()",
            "        self.agent.int_br = mock.Mock()",
            "",
            "        @contextlib.contextmanager",
            "        def bridge_deferred(*args, **kwargs):",
            "            yield",
            "",
            "        self.agent.int_br.deferred = mock.Mock(side_effect=bridge_deferred)",
            "        self.agent.process_deleted_ports(port_info={})",
            "        self.assertEqual(set(), self.agent.network_ports[TEST_NETWORK_ID1])",
            "",
            "    def test_network_update(self):",
            "        \"\"\"Network update marks port for update. \"\"\"",
            "        network = {'id': TEST_NETWORK_ID1}",
            "        port = {'id': TEST_PORT_ID1, 'network_id': network['id']}",
            "",
            "        self.agent._update_port_network(port['id'], port['network_id'])",
            "        with mock.patch.object(self.agent.plugin_rpc, 'get_network_details'), \\",
            "                mock.patch.object(self.agent,",
            "                                  '_update_network_segmentation_id'):",
            "            self.agent.network_update(context=None, network=network)",
            "        self.assertEqual(set([port['id']]), self.agent.updated_ports)",
            "",
            "    def test_network_update_outoforder(self):",
            "        \"\"\"Network update arrives later than port_delete.",
            "",
            "        But the main agent loop still didn't process the ports,",
            "        so we ensure the port is not marked for update.",
            "        \"\"\"",
            "        network = {'id': TEST_NETWORK_ID1}",
            "        port = {'id': TEST_PORT_ID1, 'network_id': network['id']}",
            "",
            "        self.agent._update_port_network(port['id'], port['network_id'])",
            "        self.agent.port_delete(context=None, port_id=port['id'])",
            "        with mock.patch.object(self.agent.plugin_rpc, 'get_network_details'), \\",
            "                mock.patch.object(self.agent,",
            "                                  '_update_network_segmentation_id'):",
            "            self.agent.network_update(context=None, network=network)",
            "        self.assertEqual(set(), self.agent.updated_ports)",
            "",
            "    def test_update_port_network(self):",
            "        \"\"\"Ensure ports are associated and moved across networks correctly.\"\"\"",
            "        self.agent._update_port_network(TEST_PORT_ID1, TEST_NETWORK_ID1)",
            "        self.agent._update_port_network(TEST_PORT_ID2, TEST_NETWORK_ID1)",
            "        self.agent._update_port_network(TEST_PORT_ID3, TEST_NETWORK_ID2)",
            "        self.agent._update_port_network(TEST_PORT_ID1, TEST_NETWORK_ID2)",
            "",
            "        self.assertEqual(set([TEST_PORT_ID2]),",
            "                         self.agent.network_ports[TEST_NETWORK_ID1])",
            "        self.assertEqual(set([TEST_PORT_ID1, TEST_PORT_ID3]),",
            "                         self.agent.network_ports[TEST_NETWORK_ID2])",
            "",
            "    def test_port_delete(self):",
            "        vif = FakeVif()",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.get_vif_by_port_id.return_value = vif.port_name",
            "            int_br.get_vif_port_by_id.return_value = vif",
            "            self.agent.port_delete(\"unused_context\",",
            "                                   port_id='id')",
            "            self.agent.process_deleted_ports(port_info={})",
            "            # the main things we care about are that it gets put in the",
            "            # dead vlan and gets blocked",
            "            int_br.set_db_attribute.assert_any_call(",
            "                'Port', vif.port_name, 'tag', constants.DEAD_VLAN_TAG,",
            "                log_errors=False)",
            "            int_br.drop_port.assert_called_once_with(in_port=vif.ofport)",
            "",
            "    def test_port_delete_removed_port(self):",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            self.agent.port_delete(\"unused_context\",",
            "                                   port_id='id')",
            "            # if it was removed from the bridge, we shouldn't be processing it",
            "            self.agent.process_deleted_ports(port_info={'removed': {'id', }})",
            "            int_br.set_db_attribute.assert_not_called()",
            "            int_br.drop_port.assert_not_called()",
            "",
            "    def test_binding_deactivate_not_for_host(self):",
            "        self.agent.binding_deactivate('unused_context', port_id='id',",
            "                                      host='other_host')",
            "        self.assertEqual(set(), self.agent.deactivated_bindings)",
            "",
            "    def test_binding_deactivate(self):",
            "        vif = FakeVif()",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.get_vif_port_by_id.return_value = vif",
            "            self.agent.binding_deactivate('unused_context', port_id='id',",
            "                                          host='host')",
            "            self.assertEqual(set(['id']), self.agent.deactivated_bindings)",
            "            self.agent.process_deactivated_bindings(port_info={})",
            "            int_br.get_vif_port_by_id.assert_called_once_with('id')",
            "            int_br.delete_port.assert_called_once_with(vif.port_name)",
            "            self.assertEqual(set(), self.agent.deactivated_bindings)",
            "",
            "    def test_binding_deactivate_removed_port(self):",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            self.agent.binding_deactivate('unused_context', port_id='id',",
            "                                          host='host')",
            "            self.assertEqual(set(['id']), self.agent.deactivated_bindings)",
            "            self.agent.process_deactivated_bindings(",
            "                port_info={'removed': {'id', }})",
            "            int_br.get_vif_port_by_id.assert_not_called()",
            "            int_br.delete_port.assert_not_called()",
            "            self.assertEqual(set(), self.agent.deactivated_bindings)",
            "",
            "    def test_binding_activate(self):",
            "        self.agent.binding_activate('context', port_id='id', host='host')",
            "        self.assertIn('id', self.agent.activated_bindings)",
            "",
            "    def test_binding_activate_not_for_host(self):",
            "        self.agent.binding_activate('context', port_id='id', host='other-host')",
            "        self.assertEqual(set(), self.agent.activated_bindings)",
            "",
            "    def test_process_activated_bindings(self):",
            "        port_info = {}",
            "        port_info['added'] = set(['added_port_id'])",
            "        port_info['current'] = set(['activated_port_id'])",
            "        self.agent.process_activated_bindings(port_info,",
            "                                              set(['activated_port_id']))",
            "        self.assertIn('added_port_id', port_info['added'])",
            "        self.assertIn('activated_port_id', port_info['added'])",
            "",
            "    def test_process_activated_bindings_activated_port_not_present(self):",
            "        port_info = {}",
            "        port_info['added'] = set(['added_port_id'])",
            "        port_info['current'] = set()",
            "        self.agent.process_activated_bindings(port_info,",
            "                                              set(['activated_port_id']))",
            "        self.assertIn('added_port_id', port_info['added'])",
            "        self.assertNotIn('activated_port_id', port_info['added'])",
            "",
            "    def _test_setup_physical_bridges(self, port_exists=False,",
            "                                     dvr_enabled=False):",
            "        self.agent.enable_distributed_routing = dvr_enabled",
            "        with mock.patch.object(ip_lib.IPDevice, \"exists\") as devex_fn,\\",
            "                mock.patch.object(sys, \"exit\"),\\",
            "                mock.patch.object(self.agent, 'br_phys_cls') as phys_br_cls,\\",
            "                mock.patch.object(self.agent, 'int_br') as int_br,\\",
            "                mock.patch.object(self.agent, '_check_bridge_datapath_id'),\\",
            "                mock.patch.object(ovs_lib.BaseOVS, 'get_bridges'):",
            "            devex_fn.return_value = True",
            "            parent = mock.MagicMock()",
            "            phys_br = phys_br_cls()",
            "            parent.attach_mock(phys_br_cls, 'phys_br_cls')",
            "            parent.attach_mock(phys_br, 'phys_br')",
            "            parent.attach_mock(int_br, 'int_br')",
            "            if port_exists:",
            "                phys_br.get_port_ofport.return_value = \"phy_ofport\"",
            "                int_br.get_port_ofport.return_value = \"int_ofport\"",
            "            else:",
            "                phys_br.add_patch_port.return_value = \"phy_ofport\"",
            "                int_br.add_patch_port.return_value = \"int_ofport\"",
            "            phys_br.port_exists.return_value = port_exists",
            "            int_br.port_exists.return_value = port_exists",
            "            self.agent.setup_physical_bridges({\"physnet1\": \"br-eth\"})",
            "            expected_calls = [",
            "                mock.call.phys_br_cls('br-eth'),",
            "                mock.call.phys_br.create(),",
            "                mock.call.phys_br.set_secure_mode(),",
            "                mock.call.phys_br.setup_controllers(mock.ANY),",
            "                mock.call.phys_br.setup_default_table(),",
            "                mock.call.int_br.db_get_val('Interface', 'int-br-eth',",
            "                                            'type', log_errors=False),",
            "                # Have to use __getattr__ here to avoid mock._Call.__eq__",
            "                # method being called",
            "                mock.call.int_br.db_get_val().__getattr__('__eq__')('veth'),",
            "                mock.call.int_br.port_exists('int-br-eth'),",
            "            ]",
            "            if port_exists:",
            "                expected_calls += [",
            "                    mock.call.int_br.get_port_ofport('int-br-eth'),",
            "                ]",
            "            else:",
            "                expected_calls += [",
            "                    mock.call.int_br.add_patch_port(",
            "                        'int-br-eth', constants.NONEXISTENT_PEER),",
            "                ]",
            "            expected_calls += [",
            "                mock.call.phys_br.port_exists('phy-br-eth'),",
            "            ]",
            "            if port_exists:",
            "                expected_calls += [",
            "                    mock.call.phys_br.get_port_ofport('phy-br-eth'),",
            "                ]",
            "            else:",
            "                expected_calls += [",
            "                    mock.call.phys_br.add_patch_port(",
            "                        'phy-br-eth', constants.NONEXISTENT_PEER),",
            "                ]",
            "            expected_calls += [",
            "                    mock.call.int_br.drop_port(in_port='int_ofport')",
            "            ]",
            "            if not dvr_enabled:",
            "                expected_calls += [",
            "                        mock.call.phys_br.drop_port(in_port='phy_ofport')",
            "                ]",
            "            expected_calls += [",
            "                mock.call.int_br.set_db_attribute('Interface', 'int-br-eth',",
            "                                                  'options',",
            "                                                  {'peer': 'phy-br-eth'}),",
            "                mock.call.phys_br.set_db_attribute('Interface', 'phy-br-eth',",
            "                                                   'options',",
            "                                                   {'peer': 'int-br-eth'}),",
            "            ]",
            "            parent.assert_has_calls(expected_calls)",
            "            self.assertEqual(\"int_ofport\",",
            "                             self.agent.int_ofports[\"physnet1\"])",
            "            self.assertEqual(\"phy_ofport\",",
            "                             self.agent.phys_ofports[\"physnet1\"])",
            "",
            "    def test_setup_physical_bridges(self):",
            "        self._test_setup_physical_bridges()",
            "",
            "    def test_setup_physical_bridges_port_exists(self):",
            "        self._test_setup_physical_bridges(port_exists=True)",
            "",
            "    def test_setup_physical_bridges_dvr_enabled(self):",
            "        self._test_setup_physical_bridges(dvr_enabled=True)",
            "",
            "    def test_setup_physical_bridges_using_veth_interconnection(self):",
            "        self.agent.use_veth_interconnection = True",
            "        with mock.patch.object(ip_lib.IPDevice, \"exists\") as devex_fn,\\",
            "                mock.patch.object(sys, \"exit\"),\\",
            "                mock.patch.object(utils, \"execute\") as utilsexec_fn,\\",
            "                mock.patch.object(self.agent, 'br_phys_cls') as phys_br_cls,\\",
            "                mock.patch.object(self.agent, 'int_br') as int_br,\\",
            "                mock.patch.object(self.agent, '_check_bridge_datapath_id'),\\",
            "                mock.patch.object(ip_lib.IPWrapper, \"add_veth\") as addveth_fn,\\",
            "                mock.patch.object(ip_lib.IpLinkCommand,",
            "                                  \"delete\") as linkdel_fn,\\",
            "                mock.patch.object(ip_lib.IpLinkCommand, \"set_up\"),\\",
            "                mock.patch.object(ip_lib.IpLinkCommand, \"set_mtu\"),\\",
            "                mock.patch.object(ovs_lib.BaseOVS, \"get_bridges\") as get_br_fn:",
            "            devex_fn.return_value = True",
            "            parent = mock.MagicMock()",
            "            parent.attach_mock(utilsexec_fn, 'utils_execute')",
            "            parent.attach_mock(linkdel_fn, 'link_delete')",
            "            parent.attach_mock(addveth_fn, 'add_veth')",
            "            addveth_fn.return_value = (ip_lib.IPDevice(\"int-br-eth1\"),",
            "                                       ip_lib.IPDevice(\"phy-br-eth1\"))",
            "            phys_br = phys_br_cls()",
            "            phys_br.add_port.return_value = \"phys_veth_ofport\"",
            "            int_br.add_port.return_value = \"int_veth_ofport\"",
            "            get_br_fn.return_value = [\"br-eth\"]",
            "            self.agent.setup_physical_bridges({\"physnet1\": \"br-eth\"})",
            "            expected_calls = [mock.call.link_delete(),",
            "                              mock.call.utils_execute(['udevadm',",
            "                                                       'settle',",
            "                                                       '--timeout=10']),",
            "                              mock.call.add_veth('int-br-eth',",
            "                                                 'phy-br-eth')]",
            "            parent.assert_has_calls(expected_calls, any_order=False)",
            "            self.assertEqual(\"int_veth_ofport\",",
            "                             self.agent.int_ofports[\"physnet1\"])",
            "            self.assertEqual(\"phys_veth_ofport\",",
            "                             self.agent.phys_ofports[\"physnet1\"])",
            "            int_br.add_port.assert_called_with(\"int-br-eth\")",
            "            phys_br.add_port.assert_called_with(\"phy-br-eth\")",
            "",
            "    def _test_setup_physical_bridges_change_from_veth_to_patch_conf(",
            "            self, port_exists=False):",
            "        with mock.patch.object(sys, \"exit\"),\\",
            "                mock.patch.object(self.agent, 'br_phys_cls') as phys_br_cls,\\",
            "                mock.patch.object(self.agent, 'int_br') as int_br,\\",
            "                mock.patch.object(self.agent.int_br, 'db_get_val',",
            "                                  return_value='veth'), \\",
            "                mock.patch.object(self.agent, '_check_bridge_datapath_id'), \\",
            "                mock.patch.object(ovs_lib.BaseOVS, 'get_bridges'):",
            "            phys_br = phys_br_cls()",
            "            parent = mock.MagicMock()",
            "            parent.attach_mock(phys_br_cls, 'phys_br_cls')",
            "            parent.attach_mock(phys_br, 'phys_br')",
            "            parent.attach_mock(int_br, 'int_br')",
            "            if port_exists:",
            "                phys_br.get_port_ofport.return_value = \"phy_ofport\"",
            "                int_br.get_port_ofport.return_value = \"int_ofport\"",
            "            else:",
            "                phys_br.add_patch_port.return_value = \"phy_ofport\"",
            "                int_br.add_patch_port.return_value = \"int_ofport\"",
            "            phys_br.port_exists.return_value = port_exists",
            "            int_br.port_exists.return_value = port_exists",
            "            self.agent.setup_physical_bridges({\"physnet1\": \"br-eth\"})",
            "            expected_calls = [",
            "                mock.call.phys_br_cls('br-eth'),",
            "                mock.call.phys_br.create(),",
            "                mock.call.phys_br.set_secure_mode(),",
            "                mock.call.phys_br.setup_controllers(mock.ANY),",
            "                mock.call.phys_br.setup_default_table(),",
            "                mock.call.int_br.delete_port('int-br-eth'),",
            "                mock.call.phys_br.delete_port('phy-br-eth'),",
            "                mock.call.int_br.port_exists('int-br-eth'),",
            "            ]",
            "            if port_exists:",
            "                expected_calls += [",
            "                    mock.call.int_br.get_port_ofport('int-br-eth'),",
            "                ]",
            "            else:",
            "                expected_calls += [",
            "                    mock.call.int_br.add_patch_port(",
            "                        'int-br-eth', constants.NONEXISTENT_PEER),",
            "                ]",
            "            expected_calls += [",
            "                mock.call.phys_br.port_exists('phy-br-eth'),",
            "            ]",
            "            if port_exists:",
            "                expected_calls += [",
            "                    mock.call.phys_br.get_port_ofport('phy-br-eth'),",
            "                ]",
            "            else:",
            "                expected_calls += [",
            "                    mock.call.phys_br.add_patch_port(",
            "                        'phy-br-eth', constants.NONEXISTENT_PEER),",
            "                ]",
            "            expected_calls += [",
            "                mock.call.int_br.drop_port(in_port='int_ofport'),",
            "                mock.call.phys_br.drop_port(in_port='phy_ofport'),",
            "                mock.call.int_br.set_db_attribute('Interface', 'int-br-eth',",
            "                                                  'options',",
            "                                                  {'peer': 'phy-br-eth'}),",
            "                mock.call.phys_br.set_db_attribute('Interface', 'phy-br-eth',",
            "                                                   'options',",
            "                                                   {'peer': 'int-br-eth'}),",
            "            ]",
            "            parent.assert_has_calls(expected_calls)",
            "            self.assertEqual(\"int_ofport\",",
            "                             self.agent.int_ofports[\"physnet1\"])",
            "            self.assertEqual(\"phy_ofport\",",
            "                             self.agent.phys_ofports[\"physnet1\"])",
            "",
            "    def test_setup_physical_bridges_change_from_veth_to_patch_conf(self):",
            "        self._test_setup_physical_bridges_change_from_veth_to_patch_conf()",
            "",
            "    def test_setup_physical_bridges_change_from_veth_to_patch_conf_port_exists(",
            "            self):",
            "        self._test_setup_physical_bridges_change_from_veth_to_patch_conf(",
            "            port_exists=True)",
            "",
            "    def test_setup_tunnel_br(self):",
            "        self.tun_br = mock.Mock()",
            "        with mock.patch.object(self.agent.int_br,",
            "                               \"add_patch_port\",",
            "                               return_value=1) as int_patch_port,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  \"add_patch_port\",",
            "                                  return_value=1) as tun_patch_port,\\",
            "                mock.patch.object(self.agent.tun_br, 'bridge_exists',",
            "                                  return_value=False),\\",
            "                mock.patch.object(self.agent.tun_br, 'create') as create_tun,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  'setup_controllers') as setup_controllers,\\",
            "                mock.patch.object(self.agent.tun_br, 'port_exists',",
            "                                  return_value=False),\\",
            "                mock.patch.object(self.agent.int_br, 'port_exists',",
            "                                  return_value=False),\\",
            "                mock.patch.object(sys, \"exit\"):",
            "            self.agent.setup_tunnel_br(None)",
            "            self.agent.setup_tunnel_br()",
            "            self.assertTrue(create_tun.called)",
            "            self.assertTrue(setup_controllers.called)",
            "            self.assertTrue(int_patch_port.called)",
            "            self.assertTrue(tun_patch_port.called)",
            "",
            "    def test_setup_tunnel_br_ports_exits_drop_flows(self):",
            "        cfg.CONF.set_override('drop_flows_on_start', True, 'AGENT')",
            "        with mock.patch.object(self.agent.tun_br, 'port_exists',",
            "                               return_value=True),\\",
            "                mock.patch.object(self.agent, 'tun_br'),\\",
            "                mock.patch.object(self.agent.int_br, 'port_exists',",
            "                                  return_value=True),\\",
            "                mock.patch.object(self.agent.tun_br, 'setup_controllers'),\\",
            "                mock.patch.object(self.agent, 'patch_tun_ofport', new=2),\\",
            "                mock.patch.object(self.agent, 'patch_int_ofport', new=2),\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  'uninstall_flows') as delete,\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  \"add_patch_port\") as int_patch_port,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  \"add_patch_port\") as tun_patch_port,\\",
            "                mock.patch.object(sys, \"exit\"):",
            "            self.agent.setup_tunnel_br(None)",
            "            self.agent.setup_tunnel_br()",
            "            int_patch_port.assert_not_called()",
            "            tun_patch_port.assert_not_called()",
            "            self.assertTrue(delete.called)",
            "",
            "    def test_setup_tunnel_port(self):",
            "        self.agent.tun_br = mock.Mock()",
            "        self.agent.l2_pop = False",
            "        self.agent.udp_vxlan_port = 8472",
            "        self.agent.tun_br_ofports['vxlan'] = {}",
            "        self.agent.local_ip = '2.3.4.5'",
            "        with mock.patch.object(self.agent.tun_br,",
            "                               \"add_tunnel_port\",",
            "                               return_value='6') as add_tun_port_fn,\\",
            "                mock.patch.object(self.agent.tun_br, \"add_flow\"):",
            "            self.agent._setup_tunnel_port(self.agent.tun_br, 'portname',",
            "                                          '1.2.3.4', 'vxlan')",
            "            self.assertTrue(add_tun_port_fn.called)",
            "",
            "    def test_port_unbound(self):",
            "        with mock.patch.object(self.agent, \"reclaim_local_vlan\") as reclvl_fn:",
            "            self.agent.enable_tunneling = True",
            "            lvm = mock.Mock()",
            "            lvm.network_type = \"gre\"",
            "            lvm.vif_ports = {\"vif1\": mock.Mock()}",
            "            self.agent.vlan_manager.mapping[\"netuid12345\"] = lvm",
            "            self.agent.port_unbound(\"vif1\", \"netuid12345\")",
            "            self.assertTrue(reclvl_fn.called)",
            "",
            "            lvm.vif_ports = {}",
            "            self.agent.port_unbound(\"vif1\", \"netuid12345\")",
            "            self.assertEqual(2, reclvl_fn.call_count)",
            "",
            "            lvm.vif_ports = {\"vif1\": mock.Mock()}",
            "            self.agent.port_unbound(\"vif3\", \"netuid12345\")",
            "            self.assertEqual(2, reclvl_fn.call_count)",
            "",
            "    def _prepare_l2_pop_ofports(self):",
            "        lvm1 = mock.Mock()",
            "        lvm1.network_type = 'gre'",
            "        lvm1.vlan = 'vlan1'",
            "        lvm1.segmentation_id = 'seg1'",
            "        lvm1.tun_ofports = set(['1'])",
            "        lvm2 = mock.Mock()",
            "        lvm2.network_type = 'gre'",
            "        lvm2.vlan = 'vlan2'",
            "        lvm2.segmentation_id = 'seg2'",
            "        lvm2.tun_ofports = set(['1', '2'])",
            "        self.agent.vlan_manager.mapping = {'net1': lvm1, 'net2': lvm2}",
            "        self.agent.tun_br_ofports = {'gre':",
            "                                     {'1.1.1.1': '1', '2.2.2.2': '2'}}",
            "        self.agent.arp_responder_enabled = True",
            "",
            "    def test_fdb_ignore_network(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net3': {}}",
            "        with mock.patch.object(self.agent.tun_br, 'add_flow') as add_flow_fn,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  'uninstall_flows') as del_flow_fn,\\",
            "                mock.patch.object(self.agent,",
            "                                  '_setup_tunnel_port') as add_tun_fn,\\",
            "                mock.patch.object(self.agent,",
            "                                  'cleanup_tunnel_port') as clean_tun_fn:",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            add_flow_fn.assert_not_called()",
            "            add_tun_fn.assert_not_called()",
            "            self.agent.fdb_remove(None, fdb_entry)",
            "            del_flow_fn.assert_not_called()",
            "            clean_tun_fn.assert_not_called()",
            "",
            "    def test_fdb_ignore_self(self):",
            "        self._prepare_l2_pop_ofports()",
            "        self.agent.local_ip = 'agent_ip'",
            "        fdb_entry = {'net2':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun2',",
            "                      'ports':",
            "                      {'agent_ip':",
            "                       [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1),",
            "                        n_const.FLOODING_ENTRY]}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            tun_br.add_port.assert_not_called()",
            "",
            "            self.agent.fdb_remove(None, fdb_entry)",
            "            tun_br.delete_port.assert_not_called()",
            "",
            "    def test_fdb_add_flows(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net1':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun1',",
            "                      'ports':",
            "                      {'2.2.2.2':",
            "                       [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1),",
            "                        n_const.FLOODING_ENTRY]}}}",
            "",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br,\\",
            "                mock.patch.object(self.agent,",
            "                                  '_setup_tunnel_port',",
            "                                  autospec=True) as add_tun_fn:",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            add_tun_fn.assert_not_called()",
            "            expected_calls = [",
            "                mock.call.install_arp_responder('vlan1', FAKE_IP1, FAKE_MAC),",
            "                mock.call.install_unicast_to_tun('vlan1', 'seg1', '2',",
            "                                                 FAKE_MAC),",
            "                mock.call.install_flood_to_tun('vlan1', 'seg1',",
            "                                               set(['1', '2'])),",
            "            ]",
            "            tun_br.assert_has_calls(expected_calls)",
            "",
            "    def test_fdb_del_flows(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net2':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun2',",
            "                      'ports':",
            "                      {'2.2.2.2':",
            "                       [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1),",
            "                        n_const.FLOODING_ENTRY]}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as br_tun:",
            "            self.agent.fdb_remove(None, fdb_entry)",
            "            expected_calls = [",
            "                mock.call.delete_arp_responder('vlan2', FAKE_IP1),",
            "                mock.call.delete_unicast_to_tun('vlan2', FAKE_MAC),",
            "                mock.call.install_flood_to_tun('vlan2', 'seg2', set(['1'])),",
            "                mock.call.delete_port('gre-02020202'),",
            "                mock.call.cleanup_tunnel_port('2'),",
            "            ]",
            "            br_tun.assert_has_calls(expected_calls)",
            "",
            "    def test_fdb_add_port(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net1':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun1',",
            "                      'ports': {'1.1.1.1': [l2pop_rpc.PortInfo(FAKE_MAC,",
            "                                                               FAKE_IP1)]}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br,\\",
            "                mock.patch.object(self.agent,",
            "                                  '_setup_tunnel_port') as add_tun_fn:",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            add_tun_fn.assert_not_called()",
            "            fdb_entry['net1']['ports']['10.10.10.10'] = [",
            "                l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1)]",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            add_tun_fn.assert_called_with(",
            "                tun_br, 'gre-0a0a0a0a', '10.10.10.10', 'gre')",
            "",
            "    def test_fdb_del_port(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net2':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun2',",
            "                      'ports': {'2.2.2.2': [n_const.FLOODING_ENTRY]}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.fdb_remove(None, fdb_entry)",
            "            tun_br.delete_port.assert_called_once_with('gre-02020202')",
            "",
            "    def test_fdb_update_chg_ip(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entries = {'chg_ip':",
            "                       {'net1':",
            "                        {'agent_ip':",
            "                         {'before': [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1)],",
            "                          'after': [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP2)]}}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.fdb_update(None, fdb_entries)",
            "            tun_br.assert_has_calls([",
            "                mock.call.install_arp_responder('vlan1', FAKE_IP2, FAKE_MAC),",
            "                mock.call.delete_arp_responder('vlan1', FAKE_IP1)",
            "            ])",
            "",
            "    def test_del_fdb_flow_idempotency(self):",
            "        lvm = mock.Mock()",
            "        lvm.network_type = 'gre'",
            "        lvm.vlan = 'vlan1'",
            "        lvm.segmentation_id = 'seg1'",
            "        lvm.tun_ofports = set(['1', '2'])",
            "        with mock.patch.object(self.agent.tun_br, 'mod_flow') as mod_flow_fn,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  'uninstall_flows') as uninstall_flows_fn:",
            "            self.agent.del_fdb_flow(self.agent.tun_br, n_const.FLOODING_ENTRY,",
            "                                    '1.1.1.1', lvm, '3')",
            "            mod_flow_fn.assert_not_called()",
            "            uninstall_flows_fn.assert_not_called()",
            "",
            "    def test_recl_lv_port_to_preserve(self):",
            "        self._prepare_l2_pop_ofports()",
            "        self.agent.l2_pop = True",
            "        self.agent.enable_tunneling = True",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.reclaim_local_vlan('net1')",
            "            tun_br.cleanup_tunnel_port.assert_not_called()",
            "",
            "    def test_recl_lv_port_to_remove(self):",
            "        self._prepare_l2_pop_ofports()",
            "        self.agent.l2_pop = True",
            "        self.agent.enable_tunneling = True",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.reclaim_local_vlan('net2')",
            "            tun_br.delete_port.assert_called_once_with('gre-02020202')",
            "",
            "    def _test_ext_br_recreated(self, setup_bridges_side_effect):",
            "        bridge_mappings = {'physnet0': 'br-ex0',",
            "                           'physnet1': 'br-ex1'}",
            "        ex_br_mocks = [mock.Mock(br_name='br-ex0'),",
            "                       mock.Mock(br_name='br-ex1')]",
            "        phys_bridges = {'physnet0': ex_br_mocks[0],",
            "                        'physnet1': ex_br_mocks[1]},",
            "        bridges_added = ['br-ex0']",
            "        expected_added_bridges = (",
            "            bridges_added if setup_bridges_side_effect else [])",
            "        with mock.patch.object(self.agent, 'check_ovs_status',",
            "                               return_value=constants.OVS_NORMAL), \\",
            "                mock.patch.object(self.agent, '_agent_has_updates',",
            "                                  side_effect=TypeError('loop exit')), \\",
            "                mock.patch.dict(self.agent.bridge_mappings, bridge_mappings,",
            "                                clear=True), \\",
            "                mock.patch.dict(self.agent.phys_brs, phys_bridges,",
            "                                clear=True), \\",
            "                mock.patch.object(self.agent, 'setup_physical_bridges') as \\",
            "                setup_physical_bridges, \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor') as \\",
            "                mock_idl_monitor:",
            "            mock_idl_monitor.bridges_added = bridges_added",
            "            setup_physical_bridges.side_effect = setup_bridges_side_effect",
            "            try:",
            "                self.agent.rpc_loop(polling_manager=mock.Mock())",
            "            except TypeError:",
            "                pass",
            "        # Setup bridges should be called once even if it will raise Runtime",
            "        # Error because there is raised TypeError in _agent_has_updates to stop",
            "        # agent after first loop iteration",
            "        setup_physical_bridges.assert_called_once_with({'physnet0': 'br-ex0'})",
            "        self.assertEqual(expected_added_bridges, self.agent.added_bridges)",
            "",
            "    def test_ext_br_recreated(self):",
            "        self._test_ext_br_recreated(setup_bridges_side_effect=None)",
            "",
            "    def test_ext_br_recreated_fail_setup_physical_bridge(self):",
            "        self._test_ext_br_recreated(setup_bridges_side_effect=RuntimeError)",
            "",
            "    def test_daemon_loop_uses_polling_manager(self):",
            "        ex_br_mock = mock.Mock(br_name=\"br-ex0\")",
            "        with mock.patch.object(polling, 'get_polling_manager') as \\",
            "                mock_get_pm, \\",
            "                mock.patch.object(self.agent, 'rpc_loop') as mock_loop, \\",
            "                mock.patch.dict(self.agent.phys_brs, {'physnet0': ex_br_mock},",
            "                                clear=True), \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor') as \\",
            "                mock_idl_monitor:",
            "            self.agent.daemon_loop()",
            "        mock_get_pm.assert_called_with(True,",
            "                                       constants.DEFAULT_OVSDBMON_RESPAWN)",
            "        mock_loop.assert_called_once_with(polling_manager=mock.ANY)",
            "        mock_idl_monitor.start_bridge_monitor.assert_called()",
            "",
            "    def test_setup_tunnel_port_invalid_ofport(self):",
            "        remote_ip = '1.2.3.4'",
            "        with mock.patch.object(",
            "            self.agent.tun_br,",
            "            'add_tunnel_port',",
            "            return_value=ovs_lib.INVALID_OFPORT) as add_tunnel_port_fn,\\",
            "                mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.local_ip = '1.2.3.4'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            add_tunnel_port_fn.assert_called_once_with(",
            "                'gre-1', remote_ip, self.agent.local_ip, n_const.TYPE_GRE,",
            "                self.agent.vxlan_udp_port, self.agent.dont_fragment,",
            "                self.agent.tunnel_csum, self.agent.tos)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Failed to set-up %(type)s tunnel port to %(ip)s\"),",
            "                {'type': n_const.TYPE_GRE, 'ip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_invalid_address_mismatch(self):",
            "        remote_ip = '2001:db8::2'",
            "        with mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.local_ip = '1.2.3.4'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"IP version mismatch, cannot create tunnel: \"",
            "                  \"local_ip=%(lip)s remote_ip=%(rip)s\"),",
            "                {'lip': self.agent.local_ip, 'rip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_invalid_netaddr_exception(self):",
            "        remote_ip = '2001:db8::2'",
            "        with mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.local_ip = '1.2.3.4.5'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Invalid local or remote IP, cannot create tunnel: \"",
            "                  \"local_ip=%(lip)s remote_ip=%(rip)s\"),",
            "                {'lip': self.agent.local_ip, 'rip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_error_negative_df_disabled(self):",
            "        remote_ip = '1.2.3.4'",
            "        with mock.patch.object(",
            "            self.agent.tun_br,",
            "            'add_tunnel_port',",
            "            return_value=ovs_lib.INVALID_OFPORT) as add_tunnel_port_fn,\\",
            "                mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.dont_fragment = False",
            "            self.agent.tunnel_csum = False",
            "            self.agent.local_ip = '2.3.4.5'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            add_tunnel_port_fn.assert_called_once_with(",
            "                'gre-1', remote_ip, self.agent.local_ip, n_const.TYPE_GRE,",
            "                self.agent.vxlan_udp_port, self.agent.dont_fragment,",
            "                self.agent.tunnel_csum, self.agent.tos)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Failed to set-up %(type)s tunnel port to %(ip)s\"),",
            "                {'type': n_const.TYPE_GRE, 'ip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_error_negative_tunnel_csum(self):",
            "        remote_ip = '1.2.3.4'",
            "        with mock.patch.object(",
            "            self.agent.tun_br,",
            "            'add_tunnel_port',",
            "            return_value=ovs_lib.INVALID_OFPORT) as add_tunnel_port_fn,\\",
            "                mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.dont_fragment = True",
            "            self.agent.tunnel_csum = True",
            "            self.agent.local_ip = '2.3.4.5'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            add_tunnel_port_fn.assert_called_once_with(",
            "                'gre-1', remote_ip, self.agent.local_ip, n_const.TYPE_GRE,",
            "                self.agent.vxlan_udp_port, self.agent.dont_fragment,",
            "                self.agent.tunnel_csum, self.agent.tos)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Failed to set-up %(type)s tunnel port to %(ip)s\"),",
            "                {'type': n_const.TYPE_GRE, 'ip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_error_negative_tos_inherit(self):",
            "        remote_ip = '1.2.3.4'",
            "        with mock.patch.object(",
            "            self.agent.tun_br,",
            "            'add_tunnel_port',",
            "            return_value=ovs_lib.INVALID_OFPORT) as add_tunnel_port_fn,\\",
            "                mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.tos = 'inherit'",
            "            self.agent.local_ip = '2.3.4.5'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            add_tunnel_port_fn.assert_called_once_with(",
            "                'gre-1', remote_ip, self.agent.local_ip, n_const.TYPE_GRE,",
            "                self.agent.vxlan_udp_port, self.agent.dont_fragment,",
            "                self.agent.tunnel_csum, self.agent.tos)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Failed to set-up %(type)s tunnel port to %(ip)s\"),",
            "                {'type': n_const.TYPE_GRE, 'ip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_tunnel_sync_with_ml2_plugin(self):",
            "        fake_tunnel_details = {'tunnels': [{'ip_address': '100.101.31.15'}]}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'tunnel_sync',",
            "                               return_value=fake_tunnel_details),\\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    '_setup_tunnel_port') as _setup_tunnel_port_fn,\\",
            "                mock.patch.object(self.agent,",
            "                                  'cleanup_stale_flows') as cleanup:",
            "            self.agent.tunnel_types = ['vxlan']",
            "            self.agent.tunnel_sync()",
            "            expected_calls = [mock.call(self.agent.tun_br, 'vxlan-64651f0f',",
            "                                        '100.101.31.15', 'vxlan')]",
            "            _setup_tunnel_port_fn.assert_has_calls(expected_calls)",
            "            cleanup.assert_not_called()",
            "",
            "    def test_tunnel_sync_invalid_ip_address(self):",
            "        fake_tunnel_details = {'tunnels': [{'ip_address': '300.300.300.300'},",
            "                                           {'ip_address': '100.100.100.100'}]}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'tunnel_sync',",
            "                               return_value=fake_tunnel_details),\\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    '_setup_tunnel_port') as _setup_tunnel_port_fn,\\",
            "                mock.patch.object(self.agent,",
            "                                  'cleanup_stale_flows') as cleanup:",
            "            self.agent.tunnel_types = ['vxlan']",
            "            self.agent.tunnel_sync()",
            "            _setup_tunnel_port_fn.assert_called_once_with(self.agent.tun_br,",
            "                                                          'vxlan-64646464',",
            "                                                          '100.100.100.100',",
            "                                                          'vxlan')",
            "            cleanup.assert_not_called()",
            "",
            "    def test_tunnel_sync_setup_tunnel_flood_flow_once(self):",
            "        fake_tunnel_details = {'tunnels': [{'ip_address': '200.200.200.200'},",
            "                                           {'ip_address': '100.100.100.100'}]}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'tunnel_sync',",
            "                               return_value=fake_tunnel_details),\\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    '_setup_tunnel_port') as _setup_tunnel_port_fn,\\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    '_setup_tunnel_flood_flow') as _setup_tunnel_flood_flow:",
            "            self.agent.tunnel_types = ['vxlan']",
            "            self.agent.tunnel_sync()",
            "            expected_calls = [mock.call(self.agent.tun_br, 'vxlan-c8c8c8c8',",
            "                                        '200.200.200.200', 'vxlan'),",
            "                              mock.call(self.agent.tun_br, 'vxlan-64646464',",
            "                                        '100.100.100.100', 'vxlan')]",
            "            _setup_tunnel_port_fn.assert_has_calls(expected_calls)",
            "            _setup_tunnel_flood_flow.assert_called_once_with(self.agent.tun_br,",
            "                                                             'vxlan')",
            "",
            "    def test_tunnel_update(self):",
            "        kwargs = {'tunnel_ip': '10.10.10.10',",
            "                  'tunnel_type': 'gre'}",
            "        self.agent._setup_tunnel_port = mock.Mock()",
            "        self.agent.enable_tunneling = True",
            "        self.agent.tunnel_types = ['gre']",
            "        self.agent.l2_pop = False",
            "        self.agent.tunnel_update(context=None, **kwargs)",
            "        expected_calls = [",
            "            mock.call(self.agent.tun_br, 'gre-0a0a0a0a', '10.10.10.10', 'gre')]",
            "        self.agent._setup_tunnel_port.assert_has_calls(expected_calls)",
            "",
            "    def test_tunnel_delete(self):",
            "        kwargs = {'tunnel_ip': '10.10.10.10',",
            "                  'tunnel_type': 'gre'}",
            "        self.agent.enable_tunneling = True",
            "        self.agent.tunnel_types = ['gre']",
            "        self.agent.tun_br_ofports = {'gre': {'10.10.10.10': '1'}}",
            "        with mock.patch.object(",
            "            self.agent, 'cleanup_tunnel_port'",
            "        ) as clean_tun_fn:",
            "            self.agent.tunnel_delete(context=None, **kwargs)",
            "            self.assertTrue(clean_tun_fn.called)",
            "",
            "    def test_reset_tunnel_ofports(self):",
            "        tunnel_handles = self.agent.tun_br_ofports",
            "        self.agent.tun_br_ofports = {'gre': {'10.10.10.10': '1'}}",
            "        self.agent._reset_tunnel_ofports()",
            "        self.assertEqual(self.agent.tun_br_ofports, tunnel_handles)",
            "",
            "    def _test_ovs_status(self, *args):",
            "        reply2 = {'current': set(['tap0']),",
            "                  'added': set(['tap2']),",
            "                  'removed': set([])}",
            "",
            "        reply3 = {'current': set(['tap2']),",
            "                  'added': set([]),",
            "                  'removed': set(['tap0'])}",
            "",
            "        reply_ancillary = {'current': set([]),",
            "                           'added': set([]),",
            "                           'removed': set([])}",
            "",
            "        self.agent.enable_tunneling = True",
            "",
            "        with mock.patch.object(async_process.AsyncProcess, \"_spawn\"),\\",
            "                mock.patch.object(async_process.AsyncProcess, \"start\"),\\",
            "                mock.patch.object(async_process.AsyncProcess,",
            "                                  \"is_active\", return_value=True),\\",
            "                mock.patch.object(async_process.AsyncProcess, \"stop\"),\\",
            "                mock.patch.object(log.KeywordArgumentAdapter,",
            "                                  'exception') as log_exception,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'process_ports_events') as process_p_events,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'process_network_ports') as process_network_ports,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'check_ovs_status') as check_ovs_status,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_integration_br') as setup_int_br,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_physical_bridges') as setup_phys_br,\\",
            "                mock.patch.object(time, 'sleep'),\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'update_stale_ofport_rules') as update_stale, \\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'cleanup_stale_flows') as cleanup, \\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_tunnel_br') as setup_tunnel_br,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'setup_tunnel_br_flows') as setup_tunnel_br_flows,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    '_reset_tunnel_ofports') as reset_tunnel_ofports, \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor'),\\",
            "                mock.patch.object(self.agent.state_rpc,",
            "                                  'report_state') as report_st:",
            "            log_exception.side_effect = Exception(",
            "                'Fake exception to get out of the loop')",
            "            devices_not_ready = set()",
            "            process_p_events.side_effect = [(reply2, reply_ancillary,",
            "                                             devices_not_ready),",
            "                                            (reply3, reply_ancillary,",
            "                                             devices_not_ready)]",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {'added': set(), 'removed': set()}",
            "            process_network_ports.side_effect = [",
            "                failed_devices,",
            "                Exception('Fake exception to get out of the loop')]",
            "            check_ovs_status.side_effect = args",
            "",
            "            if self.agent.enable_tunneling:",
            "                self.agent.agent_state.pop(\"start_flag\")",
            "",
            "            try:",
            "                self.agent.daemon_loop()",
            "            except Exception:",
            "                pass",
            "",
            "            process_p_events.assert_has_calls([",
            "                mock.call({'removed': [], 'added': [], 'modified': []},",
            "                          set(), set(), set(),",
            "                          failed_devices, failed_ancillary_devices,",
            "                          set()),",
            "                mock.call({'removed': [], 'added': [], 'modified': []},",
            "                          set(['tap0']), set(),",
            "                          set(), failed_devices, failed_ancillary_devices,",
            "                          set())",
            "            ])",
            "",
            "            process_network_ports.assert_has_calls([",
            "                mock.call(reply2, False),",
            "                mock.call(reply3, True)",
            "            ])",
            "            cleanup.assert_called_once_with()",
            "            self.assertTrue(update_stale.called)",
            "            # Verify the OVS restart we triggered in the loop",
            "            # re-setup the bridges",
            "            setup_int_br.assert_has_calls([mock.call()])",
            "            setup_phys_br.assert_has_calls([mock.call({})])",
            "            # Ensure that tunnel handles are reset and bridge",
            "            # and flows reconfigured.",
            "            self.assertTrue(reset_tunnel_ofports.called)",
            "            self.assertTrue(setup_tunnel_br_flows.called)",
            "            self.assertTrue(setup_tunnel_br.called)",
            "            if self.agent.enable_tunneling:",
            "                self.agent.agent_state['start_flag'] = True",
            "                report_st.assert_called_once_with(",
            "                    self.agent.context, self.agent.agent_state, True)",
            "",
            "    def test_ovs_status(self):",
            "        self._test_ovs_status(constants.OVS_NORMAL,",
            "                              constants.OVS_DEAD,",
            "                              constants.OVS_RESTARTED)",
            "        # OVS will not DEAD in some exception, like DBConnectionError.",
            "        self._test_ovs_status(constants.OVS_NORMAL,",
            "                              constants.OVS_RESTARTED)",
            "",
            "    def test_rpc_loop_fail_to_process_network_ports_keep_flows(self):",
            "        with mock.patch.object(async_process.AsyncProcess, \"_spawn\"),\\",
            "                mock.patch.object(async_process.AsyncProcess, \"start\"),\\",
            "                mock.patch.object(async_process.AsyncProcess,",
            "                                  \"is_active\", return_value=True),\\",
            "                mock.patch.object(async_process.AsyncProcess, \"stop\"),\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'process_network_ports') as process_network_ports,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'check_ovs_status') as check_ovs_status,\\",
            "                mock.patch.object(time, 'sleep'),\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'update_stale_ofport_rules') as update_stale, \\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'cleanup_stale_flows') as cleanup,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    '_check_and_handle_signal') as check_and_handle_signal, \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor'):",
            "            process_network_ports.side_effect = Exception(\"Trigger resync\")",
            "            check_ovs_status.return_value = constants.OVS_NORMAL",
            "            check_and_handle_signal.side_effect = [True, False]",
            "            self.agent.daemon_loop()",
            "            self.assertTrue(update_stale.called)",
            "            cleanup.assert_not_called()",
            "",
            "    def test_set_rpc_timeout(self):",
            "        with mock.patch.object(n_rpc.BackingOffClient,",
            "                               'set_max_timeout') as smt:",
            "            self.agent._handle_sigterm(None, None)",
            "            for rpc_client in (self.agent.plugin_rpc.client,",
            "                               self.agent.sg_plugin_rpc.client,",
            "                               self.agent.dvr_plugin_rpc.client,",
            "                               self.agent.state_rpc.client):",
            "                smt.assert_called_with(10)",
            "",
            "    def test_set_rpc_timeout_no_value(self):",
            "        self.agent.quitting_rpc_timeout = None",
            "        with mock.patch.object(self.agent, 'set_rpc_timeout') as mock_set_rpc:",
            "            self.agent._handle_sigterm(None, None)",
            "        mock_set_rpc.assert_not_called()",
            "",
            "    def test_arp_spoofing_network_port(self):",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(",
            "            int_br, FakeVif(),",
            "            {'device_owner': n_const.DEVICE_OWNER_ROUTER_INTF})",
            "        self.assertTrue(int_br.delete_arp_spoofing_protection.called)",
            "        int_br.install_arp_spoofing_protection.assert_not_called()",
            "",
            "    def test_arp_spoofing_port_security_disabled(self):",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(",
            "            int_br, FakeVif(), {'port_security_enabled': False})",
            "        self.assertTrue(int_br.delete_arp_spoofing_protection.called)",
            "        int_br.install_arp_spoofing_protection.assert_not_called()",
            "",
            "    def test_arp_spoofing_basic_rule_setup(self):",
            "        vif = FakeVif()",
            "        fake_details = {'fixed_ips': [], 'device_owner': 'nobody'}",
            "        self.agent.prevent_arp_spoofing = True",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(int_br, vif, fake_details)",
            "        int_br.delete_arp_spoofing_allow_rules.assert_has_calls(",
            "            [mock.call(port=vif.ofport)])",
            "        int_br.install_arp_spoofing_protection.assert_has_calls(",
            "            [mock.call(ip_addresses=set(), port=vif.ofport)])",
            "",
            "    def test_arp_spoofing_basic_rule_setup_fixed_ipv6(self):",
            "        vif = FakeVif()",
            "        fake_details = {'fixed_ips': [{'ip_address': 'fdf8:f53b:82e4::1'}],",
            "                        'device_owner': 'nobody'}",
            "        self.agent.prevent_arp_spoofing = True",
            "        br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(br, vif, fake_details)",
            "        br.delete_arp_spoofing_allow_rules.assert_has_calls(",
            "            [mock.call(port=vif.ofport)])",
            "        self.assertTrue(br.install_icmpv6_na_spoofing_protection.called)",
            "",
            "    def test_arp_spoofing_fixed_and_allowed_addresses(self):",
            "        vif = FakeVif()",
            "        fake_details = {",
            "            'device_owner': 'nobody',",
            "            'fixed_ips': [{'ip_address': '192.168.44.100'},",
            "                          {'ip_address': '192.168.44.101'}],",
            "            'allowed_address_pairs': [{'ip_address': '192.168.44.102/32'},",
            "                                      {'ip_address': '192.168.44.103/32'}]",
            "        }",
            "        self.agent.prevent_arp_spoofing = True",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(int_br, vif, fake_details)",
            "        # make sure all addresses are allowed",
            "        addresses = {'192.168.44.100', '192.168.44.101', '192.168.44.102/32',",
            "                     '192.168.44.103/32'}",
            "        int_br.install_arp_spoofing_protection.assert_has_calls(",
            "            [mock.call(port=vif.ofport, ip_addresses=addresses)])",
            "",
            "    def test_arp_spoofing_fixed_and_allowed_addresses_ipv6(self):",
            "        vif = FakeVif()",
            "        fake_details = {",
            "            'device_owner': 'nobody',",
            "            'fixed_ips': [{'ip_address': '2001:db8::1'},",
            "                          {'ip_address': '2001:db8::2'}],",
            "            'allowed_address_pairs': [{'ip_address': '2001:db8::200',",
            "                                       'mac_address': 'aa:22:33:44:55:66'}]",
            "        }",
            "        self.agent.prevent_arp_spoofing = True",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(int_br, vif, fake_details)",
            "        # make sure all addresses are allowed including ipv6 LLAs",
            "        addresses = {'2001:db8::1', '2001:db8::2', '2001:db8::200',",
            "                     'fe80::a822:33ff:fe44:5566', 'fe80::a8bb:ccff:fe11:2233'}",
            "        int_br.install_icmpv6_na_spoofing_protection.assert_has_calls(",
            "            [mock.call(port=vif.ofport, ip_addresses=addresses)])",
            "",
            "    def test__get_ofport_moves(self):",
            "        previous = {'port1': 1, 'port2': 2}",
            "        current = {'port1': 5, 'port2': 2}",
            "        # we expect it to tell us port1 moved",
            "        expected = ['port1']",
            "        self.assertEqual(expected,",
            "                         self.agent._get_ofport_moves(current, previous))",
            "",
            "    def test_update_stale_ofport_rules_clears_old(self):",
            "        self.agent.prevent_arp_spoofing = True",
            "        self.agent.vifname_to_ofport_map = {'port1': 1, 'port2': 2}",
            "        self.agent.int_br = mock.Mock()",
            "        # simulate port1 was removed",
            "        newmap = {'port2': 2}",
            "        self.agent.int_br.get_vif_port_to_ofport_map.return_value = newmap",
            "        self.agent.update_stale_ofport_rules()",
            "        # rules matching port 1 should have been deleted",
            "        self.agent.int_br.delete_arp_spoofing_protection.assert_has_calls(",
            "            [mock.call(port=1)])",
            "        # make sure the state was updated with the new map",
            "        self.assertEqual(newmap, self.agent.vifname_to_ofport_map)",
            "",
            "    def test_update_stale_ofport_rules_treats_moved(self):",
            "        self.agent.prevent_arp_spoofing = True",
            "        self.agent.vifname_to_ofport_map = {'port1': 1, 'port2': 2}",
            "        self.agent.treat_devices_added_or_updated = mock.Mock()",
            "        self.agent.int_br = mock.Mock()",
            "        # simulate port1 was moved",
            "        newmap = {'port2': 2, 'port1': 90}",
            "        self.agent.int_br.get_vif_port_to_ofport_map.return_value = newmap",
            "        ofport_changed_ports = self.agent.update_stale_ofport_rules()",
            "        self.assertEqual(['port1'], ofport_changed_ports)",
            "",
            "    def test_update_stale_ofport_rules_removes_drop_flow(self):",
            "        self.agent.prevent_arp_spoofing = False",
            "        self.agent.vifname_to_ofport_map = {'port1': 1, 'port2': 2}",
            "        self.agent.int_br = mock.Mock()",
            "        # simulate port1 was removed",
            "        newmap = {'port2': 2}",
            "        self.agent.int_br.get_vif_port_to_ofport_map.return_value = newmap",
            "        self.agent.update_stale_ofport_rules()",
            "        # drop flow rule matching port 1 should have been deleted",
            "        ofport_changed_ports = self.agent.update_stale_ofport_rules()",
            "        expected = [",
            "            mock.call(in_port=1)",
            "        ]",
            "        self.agent.int_br.uninstall_flows.assert_has_calls(expected)",
            "        self.assertEqual(newmap, self.agent.vifname_to_ofport_map)",
            "        self.agent.int_br.delete_arp_spoofing_protection.assert_not_called()",
            "        self.assertEqual([], ofport_changed_ports)",
            "",
            "    def test__setup_tunnel_port_while_new_mapping_is_added(self):",
            "        \"\"\"Test setup_tunnel_port while adding a new mapping",
            "",
            "        Test that _setup_tunnel_port doesn't fail if new vlan mapping is",
            "        added in a different coroutine while iterating over existing mappings.",
            "        See bug 1449944 for more info.",
            "        \"\"\"",
            "",
            "        def add_new_vlan_mapping(*args, **kwargs):",
            "            self.agent.vlan_manager.add('bar', 1, 2, 3, 4)",
            "        bridge = mock.Mock()",
            "        tunnel_type = 'vxlan'",
            "        self.agent.tun_br_ofports = {tunnel_type: dict()}",
            "        self.agent.l2_pop = False",
            "        self.agent.vlan_manager.add('foo', 4, tunnel_type, 2, 1)",
            "        self.agent.local_ip = '2.3.4.5'",
            "        bridge.install_flood_to_tun.side_effect = add_new_vlan_mapping",
            "        self.agent._setup_tunnel_port(bridge, 1, '1.2.3.4',",
            "                                      tunnel_type=tunnel_type)",
            "        self.agent._setup_tunnel_flood_flow(bridge, tunnel_type)",
            "        self.assertIn('bar', self.agent.vlan_manager)",
            "",
            "    def test_setup_entry_for_arp_reply_ignores_ipv6_addresses(self):",
            "        self.agent.arp_responder_enabled = True",
            "        ip = '2001:db8::1'",
            "        br = mock.Mock()",
            "        self.agent.setup_entry_for_arp_reply(",
            "            br, 'add', mock.Mock(), mock.Mock(), ip)",
            "        br.install_arp_responder.assert_not_called()",
            "",
            "    def test_configurations_has_rp_bandwidth(self):",
            "        self.assertIn(n_const.RP_BANDWIDTHS,",
            "                      self.agent.agent_state['configurations'])",
            "",
            "    def test_configurations_has_rp_default_inventory(self):",
            "        self.assertIn(n_const.RP_INVENTORY_DEFAULTS,",
            "                      self.agent.agent_state['configurations'])",
            "        rp_inv_defaults = \\",
            "            self.agent.agent_state['configurations'][",
            "                n_const.RP_INVENTORY_DEFAULTS]",
            "        self.assertListEqual(",
            "            sorted(['reserved', 'min_unit', 'allocation_ratio', 'step_size']),",
            "            sorted(list(rp_inv_defaults)))",
            "        self.assertEqual(1.0, rp_inv_defaults['allocation_ratio'])",
            "        self.assertEqual(1, rp_inv_defaults['min_unit'])",
            "        self.assertEqual(1, rp_inv_defaults['step_size'])",
            "        self.assertEqual(0, rp_inv_defaults['reserved'])",
            "",
            "    def test__validate_rp_bandwidth_bridges(self):",
            "        cfg.CONF.set_override('bridge_mappings', [], 'OVS')",
            "        cfg.CONF.set_override(n_const.RP_BANDWIDTHS,",
            "                              ['no_such_br_in_bridge_mappings:1:1'],",
            "                              'OVS')",
            "        self.assertRaises(ValueError, self._make_agent)",
            "",
            "    def test__check_bridge_datapath_id(self):",
            "        datapath_id = u'0000622486fa3f42'",
            "        datapath_ids_set = set()",
            "        for i in range(5):",
            "            dpid = format((i << 48) + int(datapath_id, 16), '0x').zfill(16)",
            "            bridge = mock.Mock()",
            "            bridge.br_name = 'bridge_%s' % i",
            "            bridge.get_datapath_id = mock.Mock(return_value=datapath_id)",
            "            self.agent._check_bridge_datapath_id(bridge, datapath_ids_set)",
            "            self.assertEqual(i + 1, len(datapath_ids_set))",
            "            self.assertIn(dpid, datapath_ids_set)",
            "            if i == 0:",
            "                bridge.set_datapath_id.assert_not_called()",
            "            else:",
            "                bridge.set_datapath_id.assert_called_once_with(dpid)",
            "",
            "    def test__update_network_segmentation_id(self):",
            "        network = {'id': 'my-net-uuid',",
            "                   provider_net.SEGMENTATION_ID: 1005,",
            "                   provider_net.PHYSICAL_NETWORK: 'provider_net',",
            "                   provider_net.NETWORK_TYPE: n_const.TYPE_VLAN}",
            "        self.agent.vlan_manager.add('my-net-uuid', 5, n_const.TYPE_VLAN,",
            "                                    'provider_net', 1004, None)",
            "        mock_phys_br = mock.Mock()",
            "        self.agent.phys_brs['provider_net'] = mock_phys_br",
            "        self.agent.phys_ofports['provider_net'] = 'phy_ofport'",
            "        self.agent.int_ofports['provider_net'] = 'int_ofport'",
            "",
            "        with mock.patch.object(self.agent.int_br, 'reclaim_local_vlan') \\",
            "                as mock_reclaim_local_vlan, \\",
            "                mock.patch.object(self.agent.int_br, 'provision_local_vlan') \\",
            "                as mock_provision_local_vlan:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_reclaim_local_vlan.assert_called_once_with(",
            "                port='int_ofport', segmentation_id=1004)",
            "            mock_provision_local_vlan.assert_called_once_with(",
            "                port='int_ofport', lvid=5, segmentation_id=1005)",
            "        mock_phys_br.reclaim_local_vlan.assert_called_once_with(",
            "            port='phy_ofport', lvid=5)",
            "",
            "    def test__update_network_segmentation_id_not_vlan(self):",
            "        network = {provider_net.NETWORK_TYPE: 'not_vlan'}",
            "        with mock.patch.object(self.agent.vlan_manager, 'get') as mock_get:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_get.assert_not_called()",
            "",
            "    def test__update_network_segmentation_id_vlan_not_found(self):",
            "        network = {'id': 'my-net-uuid',",
            "                   provider_net.SEGMENTATION_ID: 1005,",
            "                   provider_net.NETWORK_TYPE: n_const.TYPE_VLAN,",
            "                   provider_net.PHYSICAL_NETWORK: 'default_network'}",
            "        with mock.patch.object(self.agent.vlan_manager,",
            "                               'update_segmentation_id') as mock_update_segid:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_update_segid.assert_not_called()",
            "",
            "    def test__update_network_segmentation_id_segmentation_id_not_updated(self):",
            "        network = {'id': 'my-net-uuid',",
            "                   provider_net.SEGMENTATION_ID: 1005,",
            "                   provider_net.NETWORK_TYPE: n_const.TYPE_VLAN,",
            "                   provider_net.PHYSICAL_NETWORK: 'default_network'}",
            "        self.agent.vlan_manager.add('my-net-uuid', 5, n_const.TYPE_VLAN,",
            "                                    'provider_net', 1005, None)",
            "        with mock.patch.object(self.agent.vlan_manager,",
            "                               'update_segmentation_id') as mock_update_segid:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_update_segid.assert_not_called()",
            "",
            "    def test__update_network_segmentation_id_multisegments(self):",
            "        network = {'id': 'my-net-uuid',",
            "                   'segments': [mock.ANY]}",
            "        with mock.patch.object(self.agent.vlan_manager,",
            "                               'get') as mock_get:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_get.assert_not_called()",
            "",
            "    def _test_treat_smartnic_port(self, vif_type):",
            "        vm_uuid = \"407a79e0-e0be-4b7d-92a6-513b2161011b\"",
            "        iface_id = \"407a79e0-e0be-4b7d-92a6-513b2161011c\"",
            "        rep_port = 'rep0-0'",
            "        mac = FAKE_MAC",
            "        smartnic_data = {",
            "            'mac': mac,",
            "            'vm_uuid': vm_uuid,",
            "            'vif_name': rep_port,",
            "            'iface_id': iface_id,",
            "            'vif_type': vif_type}",
            "",
            "        cfg.CONF.set_default('baremetal_smartnic', True, group='AGENT')",
            "        agent = self._make_agent()",
            "        instance_info = vif_instance_object.InstanceInfo(uuid=vm_uuid)",
            "        vif = agent._get_vif_object(iface_id, rep_port, mac)",
            "        with mock.patch.object(os_vif, 'plug') as plug_mock, \\",
            "                mock.patch.object(os_vif, 'unplug') as unplug_mock, \\",
            "                mock.patch('os_vif.objects.instance_info.InstanceInfo',",
            "                           return_value=instance_info), \\",
            "                mock.patch.object(agent, '_get_vif_object',",
            "                                  return_value=vif):",
            "",
            "            agent.treat_smartnic_port(smartnic_data)",
            "",
            "            if vif_type == portbindings.VIF_TYPE_OVS:",
            "                plug_mock.assert_called_once_with(vif, instance_info)",
            "            else:",
            "                unplug_mock.assert_called_once_with(vif, instance_info)",
            "",
            "    def test_treat_smartnic_port_add(self):",
            "        self._test_treat_smartnic_port('ovs')",
            "",
            "    def test_treat_smartnic_port_remove(self):",
            "        self._test_treat_smartnic_port('unbound')",
            "",
            "    def test_process_smartnic_ports_remove(self):",
            "        port_id = \"407a79e0-e0be-4b7d-92a6-513b2161011a\"",
            "        rep_port = 'rep0-0'",
            "        mac = FAKE_MAC",
            "        ovs_port = mock.Mock()",
            "        ovs_port.vif_mac = mac",
            "        ovs_port.port_name = rep_port",
            "        ovs_port.vif_id = port_id",
            "        ports_int_br = [ovs_port]",
            "        expected_smartnic_ports_processed_list = [",
            "            {'iface_id': port_id,",
            "             'vif_name': rep_port,",
            "             'mac': mac,",
            "             'vif_type': portbindings.VIF_TYPE_UNBOUND,",
            "             'vm_uuid': ''}]",
            "        expected_current_smartnic_ports_map = {",
            "            port_id: {",
            "                'vif_mac': mac,",
            "                'vif_name': rep_port}}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               \"get_ports_by_vnic_type_and_host\",",
            "                               return_value=[]),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  \"get_vif_ports\",",
            "                                  return_value=ports_int_br):",
            "            self.agent.process_smartnic_ports()",
            "            self.assertEqual(expected_smartnic_ports_processed_list,",
            "                             self.agent.updated_smartnic_ports)",
            "            self.assertEqual(expected_current_smartnic_ports_map,",
            "                             self.agent.current_smartnic_ports_map)",
            "",
            "    def test_process_smartnic_ports(self):",
            "        port_id = \"407a79e0-e0be-4b7d-92a6-513b2161011a\"",
            "        rep_port = 'rep0-0'",
            "        mac = FAKE_MAC",
            "        ovs_port = mock.Mock()",
            "        ovs_port.vif_mac = mac",
            "        ovs_port.port_name = rep_port",
            "        ovs_port.vif_id = port_id",
            "        ports_int_br = [ovs_port]",
            "",
            "        PORT_TO_PROCESS = {",
            "            'binding:profile': {'local_link_information': [",
            "                {'hostname': 'host1', 'port_id': rep_port}]},",
            "            'mac_address': FAKE_MAC,",
            "            'device_id': \"407a79e0-e0be-4b7d-92a6-513b2161011e\",",
            "            'id': \"407a79e0-e0be-4b7d-92a6-513b2161011c\",",
            "            'binding:vif_type': portbindings.VIF_TYPE_OVS",
            "        }",
            "        expected_smartnic_ports_processed_list = [",
            "            {'iface_id': port_id,",
            "             'vif_name': rep_port,",
            "             'mac': mac,",
            "             'vif_type': portbindings.VIF_TYPE_UNBOUND,",
            "             'vm_uuid': ''},",
            "            {'iface_id': \"407a79e0-e0be-4b7d-92a6-513b2161011c\",",
            "             'vif_name': rep_port,",
            "             'mac': mac,",
            "             'vif_type': portbindings.VIF_TYPE_OVS,",
            "             'vm_uuid': \"407a79e0-e0be-4b7d-92a6-513b2161011e\"}]",
            "        expected_current_smartnic_ports_map = {",
            "            port_id: {",
            "                'vif_mac': mac,",
            "                'vif_name': rep_port}}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               \"get_ports_by_vnic_type_and_host\",",
            "                               return_value=[PORT_TO_PROCESS]),\\",
            "            mock.patch.object(self.agent.int_br,",
            "                              \"get_vif_ports\",",
            "                              return_value=ports_int_br):",
            "            self.agent.process_smartnic_ports()",
            "            self.assertEqual(expected_smartnic_ports_processed_list,",
            "                             self.agent.updated_smartnic_ports)",
            "            self.assertEqual(expected_current_smartnic_ports_map,",
            "                             self.agent.current_smartnic_ports_map)",
            "",
            "    def test_add_bound_port_to_updated_smartnic_ports(self):",
            "        mac = FAKE_MAC",
            "        vm_uuid = \"407a79e0-e0be-4b7d-92a6-513b2161011b\"",
            "        rep_port = 'rep0-0'",
            "        iface_id = \"407a79e0-e0be-4b7d-92a6-513b2161011c\"",
            "        self.agent._add_port_to_updated_smartnic_ports(",
            "            mac,",
            "            rep_port,",
            "            iface_id,",
            "            portbindings.VIF_TYPE_OVS,",
            "            vm_uuid,)",
            "",
            "        smartnic_data = {",
            "            'mac': mac,",
            "            'vm_uuid': vm_uuid,",
            "            'vif_name': rep_port,",
            "            'iface_id': iface_id,",
            "            'vif_type': portbindings.VIF_TYPE_OVS}",
            "        self.assertEqual([smartnic_data],",
            "                         self.agent.updated_smartnic_ports)",
            "",
            "    def test_add_unbound_port_to_updated_smartnic_ports(self):",
            "        vif_mac = FAKE_MAC",
            "        vif_name = 'rep0-0'",
            "        vif_id = \"407a79e0-e0be-4b7d-92a6-513b2161011a\"",
            "        self.agent._add_port_to_updated_smartnic_ports(",
            "            vif_mac,",
            "            vif_name,",
            "            vif_id,",
            "            portbindings.VIF_TYPE_UNBOUND)",
            "        smartnic_data = {",
            "            'mac': vif_mac,",
            "            'vm_uuid': '',",
            "            'vif_name': vif_name,",
            "            'iface_id': vif_id,",
            "            'vif_type': portbindings.VIF_TYPE_UNBOUND}",
            "        self.assertEqual([smartnic_data],",
            "                         self.agent.updated_smartnic_ports)",
            "",
            "    def test_create_smartnic_port_map_entry_data(self):",
            "        mac = FAKE_MAC",
            "        rep_port = 'rep0-0'",
            "        expected_return_value = {\"vif_mac\": mac,",
            "                                 \"vif_name\": rep_port}",
            "        int_br_smartnic_port_map =\\",
            "            self.agent.create_smartnic_port_map_entry_data(mac, rep_port)",
            "        self.assertEqual(int_br_smartnic_port_map, expected_return_value)",
            "",
            "",
            "class TestOvsNeutronAgentOSKen(TestOvsNeutronAgent,",
            "                               ovs_test_base.OVSOSKenTestBase):",
            "    def test_cleanup_stale_flows(self):",
            "        uint64_max = (1 << 64) - 1",
            "        with mock.patch.object(self.agent.int_br,",
            "                               'dump_flows') as dump_flows,\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'uninstall_flows') as uninstall_flows:",
            "            self.agent.int_br.set_agent_uuid_stamp(1234)",
            "            fake_flows = [",
            "                # mock os_ken.ofproto.ofproto_v1_3_parser.OFPFlowStats",
            "                mock.Mock(cookie=1234, table_id=0),",
            "                mock.Mock(cookie=17185, table_id=2),",
            "                mock.Mock(cookie=9029, table_id=2),",
            "                mock.Mock(cookie=1234, table_id=3),",
            "            ]",
            "            dump_flows.return_value = fake_flows",
            "            self.agent.iter_num = 3",
            "            self.agent.cleanup_stale_flows()",
            "",
            "            dump_flows_expected = [",
            "                mock.call(tid) for tid in constants.INT_BR_ALL_TABLES]",
            "            dump_flows.assert_has_calls(dump_flows_expected)",
            "",
            "            expected = [mock.call(cookie=17185,",
            "                                  cookie_mask=uint64_max),",
            "                        mock.call(cookie=9029,",
            "                                  cookie_mask=uint64_max)]",
            "            uninstall_flows.assert_has_calls(expected, any_order=True)",
            "            self.assertEqual(len(constants.INT_BR_ALL_TABLES) * len(expected),",
            "                             len(uninstall_flows.mock_calls))",
            "",
            "",
            "class AncillaryBridgesTest(object):",
            "",
            "    def setUp(self):",
            "        super(AncillaryBridgesTest, self).setUp()",
            "        conn_patcher = mock.patch(",
            "            'neutron.agent.ovsdb.impl_idl._connection')",
            "        conn_patcher.start()",
            "        self.addCleanup(conn_patcher.stop)",
            "        mock.patch(PULLAPI).start()",
            "        notifier_p = mock.patch(NOTIFIER)",
            "        notifier_cls = notifier_p.start()",
            "        self.notifier = mock.Mock()",
            "        notifier_cls.return_value = self.notifier",
            "        cfg.CONF.set_default('firewall_driver',",
            "                             'neutron.agent.firewall.NoopFirewallDriver',",
            "                             group='SECURITYGROUP')",
            "        cfg.CONF.set_override('report_interval', 0, 'AGENT')",
            "        mock.patch('neutron.agent.common.ovs_lib.BaseOVS.config',",
            "                   new_callable=mock.PropertyMock,",
            "                   return_value={}).start()",
            "",
            "    def _test_ancillary_bridges(self, bridges, ancillary):",
            "        device_ids = ancillary[:]",
            "",
            "        def pullup_side_effect(*args, **kwargs):",
            "            # Check that the device_id exists, if it does return it",
            "            # if it does not return None",
            "            try:",
            "                device_ids.remove(args[0])",
            "                return args[0]",
            "            except Exception:",
            "                return None",
            "",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'),\\",
            "                mock.patch('neutron.agent.linux.ip_lib.get_device_mac',",
            "                           return_value='00:00:00:00:00:01'),\\",
            "                mock.patch('neutron.agent.common.ovs_lib.BaseOVS.get_bridges',",
            "                           return_value=bridges),\\",
            "                mock.patch('neutron.agent.common.ovs_lib.BaseOVS.'",
            "                           'get_bridge_external_bridge_id',",
            "                           side_effect=pullup_side_effect),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.'",
            "                    'get_ports_attributes',",
            "                    return_value=[]),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.' 'get_vif_ports',",
            "                    return_value=[]),\\",
            "                mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                           'has_alive_neutron_server'):",
            "            ext_manager = mock.Mock()",
            "            self.agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                        ext_manager, cfg.CONF)",
            "            self.assertEqual(len(ancillary), len(self.agent.ancillary_brs))",
            "            if ancillary:",
            "                bridges = [br.br_name for br in self.agent.ancillary_brs]",
            "                for br in ancillary:",
            "                    self.assertIn(br, bridges)",
            "",
            "    def test_ancillary_bridges_single(self):",
            "        bridges = ['br-int', 'br-ex']",
            "        self._test_ancillary_bridges(bridges, ['br-ex'])",
            "",
            "    def test_ancillary_bridges_none(self):",
            "        bridges = ['br-int']",
            "        self._test_ancillary_bridges(bridges, [])",
            "",
            "    def test_ancillary_bridges_multiple(self):",
            "        bridges = ['br-int', 'br-ex1', 'br-ex2']",
            "        self._test_ancillary_bridges(bridges, ['br-ex1', 'br-ex2'])",
            "",
            "    def mock_scan_ancillary_ports(self, vif_port_set=None,",
            "                                  registered_ports=None, sync=False):",
            "        bridges = ['br-int', 'br-ex']",
            "        ancillary = ['br-ex']",
            "",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'), \\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  '_restore_local_vlan_map'), \\",
            "                mock.patch('neutron.agent.common.ovs_lib.BaseOVS.get_bridges',",
            "                           return_value=bridges), \\",
            "                mock.patch('neutron.agent.common.ovs_lib.BaseOVS.'",
            "                           'get_bridge_external_bridge_id',",
            "                           side_effect=ancillary), \\",
            "                mock.patch('neutron.agent.common.ovs_lib.OVSBridge.'",
            "                           'get_vif_port_set',",
            "                           return_value=vif_port_set),\\",
            "                mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                           'has_alive_neutron_server'):",
            "            ext_manager = mock.Mock()",
            "            self.agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                        ext_manager, cfg.CONF)",
            "            return self.agent.scan_ancillary_ports(registered_ports, sync)",
            "",
            "    def test_scan_ancillary_ports_returns_cur_only_for_unchanged_ports(self):",
            "        vif_port_set = set([1, 2])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set)",
            "        actual = self.mock_scan_ancillary_ports(vif_port_set, registered_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ancillary_ports_returns_port_changes(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added={3},",
            "                                      removed={2})",
            "        actual = self.mock_scan_ancillary_ports(vif_port_set, registered_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ancillary_ports_returns_port_changes_with_sync(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added=vif_port_set,",
            "                                      removed={2})",
            "        actual = self.mock_scan_ancillary_ports(vif_port_set, registered_ports,",
            "                                                sync=True)",
            "        self.assertEqual(expected, actual)",
            "",
            "",
            "class AncillaryBridgesTestOSKen(AncillaryBridgesTest,",
            "                              ovs_test_base.OVSOSKenTestBase):",
            "    pass",
            "",
            "",
            "class TestOvsDvrNeutronAgent(object):",
            "",
            "    def setUp(self):",
            "        super(TestOvsDvrNeutronAgent, self).setUp()",
            "        mock.patch(PULLAPI).start()",
            "        notifier_p = mock.patch(NOTIFIER)",
            "        notifier_cls = notifier_p.start()",
            "        self.notifier = mock.Mock()",
            "        notifier_cls.return_value = self.notifier",
            "        cfg.CONF.set_default('firewall_driver',",
            "                             'neutron.agent.firewall.NoopFirewallDriver',",
            "                             group='SECURITYGROUP')",
            "",
            "        mock.patch('neutron.agent.common.ovs_lib.BaseOVS.config',",
            "                   new_callable=mock.PropertyMock,",
            "                   return_value={}).start()",
            "        mock.patch('neutron.agent.ovsdb.impl_idl._connection').start()",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'),\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_ancillary_bridges',",
            "                                  return_value=[]),\\",
            "                mock.patch('neutron.agent.linux.ip_lib.get_device_mac',",
            "                           return_value='00:00:00:00:00:01'),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.BaseOVS.get_bridges'),\\",
            "                mock.patch('oslo_service.loopingcall.'",
            "                           'FixedIntervalLoopingCall',",
            "                           new=MockFixedIntervalLoopingCall),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.'",
            "                    'get_ports_attributes',",
            "                    return_value=[]),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.' 'get_vif_ports',",
            "                    return_value=[]),\\",
            "                mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                           'has_alive_neutron_server'):",
            "            ext_manager = mock.Mock()",
            "            self.agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                       ext_manager, cfg.CONF)",
            "            self.agent.tun_br = self.br_tun_cls(br_name='br-tun')",
            "        self.agent.sg_agent = mock.Mock()",
            "",
            "    def _setup_for_dvr_test(self):",
            "        self._port = mock.Mock()",
            "        self._port.ofport = 10",
            "        self._port.vif_id = \"1234-5678-90\"",
            "        self._physical_network = 'physeth1'",
            "        self._old_local_vlan = None",
            "        self._segmentation_id = 2001",
            "        self.agent.enable_distributed_routing = True",
            "        self.agent.enable_tunneling = True",
            "        self.agent.patch_tun_ofport = 1",
            "        self.agent.patch_int_ofport = 2",
            "        self.agent.dvr_agent.local_ports = {}",
            "        self.agent.vlan_manager = self.useFixture(",
            "            test_vlanmanager.LocalVlanManagerFixture()).manager",
            "        self.agent.dvr_agent.enable_distributed_routing = True",
            "        self.agent.dvr_agent.enable_tunneling = True",
            "        self.agent.dvr_agent.patch_tun_ofport = 1",
            "        self.agent.dvr_agent.patch_int_ofport = 2",
            "        self.agent.dvr_agent.tun_br = mock.Mock()",
            "        self.agent.dvr_agent.phys_brs[self._physical_network] = mock.Mock()",
            "        self.agent.dvr_agent.bridge_mappings = {self._physical_network:",
            "                                                'br-eth1'}",
            "        self.agent.dvr_agent.int_ofports[self._physical_network] = 30",
            "        self.agent.dvr_agent.phys_ofports[self._physical_network] = 40",
            "        self.agent.dvr_agent.local_dvr_map = {}",
            "        self.agent.dvr_agent.registered_dvr_macs = set()",
            "        self.agent.dvr_agent.dvr_mac_address = 'aa:22:33:44:55:66'",
            "        self._net_uuid = 'my-net-uuid'",
            "        self._fixed_ips = [{'subnet_id': 'my-subnet-uuid',",
            "                            'ip_address': '1.1.1.1'}]",
            "        self._compute_port = mock.Mock()",
            "        self._compute_port.ofport = 20",
            "        self._compute_port.vif_id = \"1234-5678-91\"",
            "        self._compute_fixed_ips = [{'subnet_id': 'my-subnet-uuid',",
            "                                    'ip_address': '1.1.1.3'}]",
            "",
            "    @staticmethod",
            "    def _expected_port_bound(port, lvid, is_dvr=True,",
            "                             network_type=n_const.TYPE_VXLAN):",
            "        resp = [",
            "            mock.call.db_get_val('Port', port.port_name, 'other_config'),",
            "            mock.call.set_db_attribute('Port', port.port_name, 'other_config',",
            "                                       mock.ANY),",
            "        ]",
            "        if is_dvr:",
            "            resp = [",
            "                mock.call.get_vifs_by_ids([]),",
            "                mock.call.install_dvr_dst_mac_for_arp(",
            "                    network_type,",
            "                    dvr_mac=port.dvr_mac,",
            "                    gateway_mac=port.vif_mac,",
            "                    rtr_port=port.ofport,",
            "                    vlan_tag=lvid)",
            "            ] + resp",
            "        return resp",
            "",
            "    @staticmethod",
            "    def _expected_port_unbound(port, lvid, is_dvr=True,",
            "                               network_type=n_const.TYPE_VXLAN):",
            "        resp = []",
            "        if is_dvr:",
            "            resp = [",
            "                mock.call.delete_dvr_dst_mac_for_arp(",
            "                    network_type=network_type,",
            "                    dvr_mac=port.dvr_mac,",
            "                    gateway_mac=port.vif_mac,",
            "                    rtr_port=port.ofport,",
            "                    vlan_tag=lvid)",
            "            ]",
            "        return resp",
            "",
            "    def _expected_install_dvr_process(self, lvid, port, ip_version,",
            "                                      gateway_ip):",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            ipvx_calls = [",
            "                mock.call.install_dvr_process_ipv4(",
            "                    vlan_tag=lvid,",
            "                    gateway_ip=gateway_ip),",
            "            ]",
            "        else:",
            "            ipvx_calls = [",
            "                mock.call.install_dvr_process_ipv6(",
            "                    vlan_tag=lvid,",
            "                    gateway_mac=port.vif_mac),",
            "            ]",
            "        return ipvx_calls + [",
            "            mock.call.install_dvr_process(",
            "                vlan_tag=lvid,",
            "                dvr_mac_address=self.agent.dvr_agent.dvr_mac_address,",
            "                vif_mac=port.vif_mac,",
            "            ),",
            "        ]",
            "",
            "    def _test_port_bound_for_dvr_on_physical_network(",
            "            self, device_owner, network_type, ip_version=n_const.IP_VERSION_4):",
            "        self._setup_for_dvr_test()",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            gateway_ip = '1.1.1.10'",
            "            cidr = '1.1.1.0/24'",
            "        else:",
            "            gateway_ip = '2001:100::1'",
            "            cidr = '2001:100::0/64'",
            "        self._port.vif_mac = 'aa:bb:cc:11:22:33'",
            "        self._port.dvr_mac = self.agent.dvr_agent.dvr_mac_address",
            "        gateway_mac = 'aa:bb:cc:66:66:66'",
            "        self._compute_port.vif_mac = '77:88:99:00:11:22'",
            "        physical_network = self._physical_network",
            "        segmentation_id = self._segmentation_id",
            "        if network_type == n_const.TYPE_FLAT:",
            "            segmentation_id = None",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        phys_br = mock.create_autospec(self.br_phys_cls('br-phys'))",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': gateway_ip,",
            "                                             'cidr': cidr,",
            "                                             'ip_version': ip_version,",
            "                                             'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {physical_network: phys_br}):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, network_type,",
            "                physical_network, segmentation_id, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_DVR_INTERFACE, False)",
            "            phy_ofp = self.agent.dvr_agent.phys_ofports[physical_network]",
            "            int_ofp = self.agent.dvr_agent.int_ofports[physical_network]",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            expected_on_phys_br = [",
            "                mock.call.provision_local_vlan(",
            "                    port=phy_ofp,",
            "                    lvid=lvid,",
            "                    segmentation_id=segmentation_id,",
            "                    distributed=True,",
            "                ),",
            "            ] + self._expected_install_dvr_process(",
            "                port=self._port,",
            "                lvid=lvid,",
            "                ip_version=ip_version,",
            "                gateway_ip=self._fixed_ips[0]['ip_address'])",
            "            expected_on_int_br = [",
            "                mock.call.provision_local_vlan(",
            "                    port=int_ofp,",
            "                    lvid=lvid,",
            "                    segmentation_id=segmentation_id,",
            "                ),",
            "            ] + self._expected_port_bound(self._port, lvid,",
            "                                          network_type=network_type)",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "            phys_br.assert_has_calls(expected_on_phys_br)",
            "            int_br.reset_mock()",
            "            tun_br.reset_mock()",
            "            phys_br.reset_mock()",
            "            self.agent.port_bound(self._compute_port, self._net_uuid,",
            "                                  network_type, physical_network,",
            "                                  segmentation_id,",
            "                                  self._compute_fixed_ips,",
            "                                  device_owner, False)",
            "            expected_on_int_br = [",
            "                mock.call.install_dvr_to_src_mac(",
            "                    network_type=network_type,",
            "                    gateway_mac=gateway_mac,",
            "                    dst_mac=self._compute_port.vif_mac,",
            "                    dst_port=self._compute_port.ofport,",
            "                    vlan_tag=segmentation_id,",
            "                ),",
            "            ] + self._expected_port_bound(self._compute_port, lvid,",
            "                                          is_dvr=False,",
            "                                          network_type=network_type)",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "            phys_br.assert_not_called()",
            "",
            "    def _test_port_bound_for_dvr_on_vxlan_network(",
            "            self, device_owner, ip_version=n_const.IP_VERSION_4):",
            "        self._setup_for_dvr_test()",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            gateway_ip = '1.1.1.1'",
            "            cidr = '1.1.1.0/24'",
            "        else:",
            "            gateway_ip = '2001:100::1'",
            "            cidr = '2001:100::0/64'",
            "        network_type = n_const.TYPE_VXLAN",
            "        self._port.vif_mac = gateway_mac = 'aa:bb:cc:11:22:33'",
            "        self._port.dvr_mac = self.agent.dvr_agent.dvr_mac_address",
            "        self._compute_port.vif_mac = '77:88:99:00:11:22'",
            "        physical_network = self._physical_network",
            "        segmentation_id = self._segmentation_id",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        phys_br = mock.create_autospec(self.br_phys_cls('br-phys'))",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': gateway_ip,",
            "                                             'cidr': cidr,",
            "                                             'ip_version': ip_version,",
            "                                             'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {physical_network: phys_br}):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, network_type,",
            "                physical_network, segmentation_id, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_DVR_INTERFACE, False)",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            expected_on_int_br = self._expected_port_bound(",
            "                self._port, lvid)",
            "            expected_on_tun_br = [",
            "                mock.call.provision_local_vlan(",
            "                    network_type=network_type,",
            "                    segmentation_id=segmentation_id,",
            "                    lvid=lvid,",
            "                    distributed=True),",
            "            ] + self._expected_install_dvr_process(",
            "                port=self._port,",
            "                lvid=lvid,",
            "                ip_version=ip_version,",
            "                gateway_ip=gateway_ip)",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "            phys_br.assert_not_called()",
            "            int_br.reset_mock()",
            "            tun_br.reset_mock()",
            "            phys_br.reset_mock()",
            "            self.agent.port_bound(self._compute_port, self._net_uuid,",
            "                                  network_type, physical_network,",
            "                                  segmentation_id,",
            "                                  self._compute_fixed_ips,",
            "                                  device_owner, False)",
            "            expected_on_int_br = [",
            "                mock.call.install_dvr_to_src_mac(",
            "                    network_type=network_type,",
            "                    gateway_mac=gateway_mac,",
            "                    dst_mac=self._compute_port.vif_mac,",
            "                    dst_port=self._compute_port.ofport,",
            "                    vlan_tag=lvid,",
            "                ),",
            "            ] + self._expected_port_bound(self._compute_port, lvid, False,",
            "                                          network_type)",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "            phys_br.assert_not_called()",
            "",
            "    def test_port_bound_for_dvr_with_compute_ports(self):",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            network_type=n_const.TYPE_VLAN)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            network_type=n_const.TYPE_VLAN,",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            network_type=n_const.TYPE_FLAT)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            network_type=n_const.TYPE_FLAT,",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_port_bound_for_dvr_on_vxlan_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE)",
            "        self._test_port_bound_for_dvr_on_vxlan_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            ip_version=n_const.IP_VERSION_6)",
            "",
            "    def test_port_bound_for_dvr_with_dhcp_ports(self):",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            network_type=n_const.TYPE_VLAN)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            network_type=n_const.TYPE_VLAN,",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            network_type=n_const.TYPE_FLAT)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            network_type=n_const.TYPE_FLAT,",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_port_bound_for_dvr_on_vxlan_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP)",
            "        self._test_port_bound_for_dvr_on_vxlan_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            ip_version=n_const.IP_VERSION_6)",
            "",
            "    def test_port_bound_for_dvr_with_csnat_ports(self):",
            "        self._setup_for_dvr_test()",
            "        int_br, tun_br = self._port_bound_for_dvr_with_csnat_ports()",
            "        lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "        expected_on_int_br = [",
            "            mock.call.install_dvr_to_src_mac(",
            "                network_type='vxlan',",
            "                gateway_mac='aa:bb:cc:11:22:33',",
            "                dst_mac=self._port.vif_mac,",
            "                dst_port=self._port.ofport,",
            "                vlan_tag=lvid,",
            "            ),",
            "        ] + self._expected_port_bound(self._port, lvid, is_dvr=False)",
            "        int_br.assert_has_calls(expected_on_int_br)",
            "        expected_on_tun_br = [",
            "            mock.call.provision_local_vlan(",
            "                network_type='vxlan',",
            "                lvid=lvid,",
            "                segmentation_id=None,",
            "                distributed=True,",
            "            ),",
            "        ]",
            "        tun_br.assert_has_calls(expected_on_tun_br)",
            "",
            "    def test_port_bound_for_dvr_with_csnat_port_without_passing_fixed_ip(self):",
            "        self._setup_for_dvr_test()",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr') as mock_getsub,\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_ROUTER_SNAT,",
            "                False)",
            "            mock_getsub.assert_called_with(",
            "                self.agent.context, mock.ANY, fixed_ips=None)",
            "",
            "    def test_port_bound_for_dvr_with_csnat_ports_ofport_change(self):",
            "        self._setup_for_dvr_test()",
            "        self._port_bound_for_dvr_with_csnat_ports()",
            "        # simulate a replug",
            "        self._port.ofport = 12",
            "        int_br, tun_br = self._port_bound_for_dvr_with_csnat_ports()",
            "        lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "        expected_on_int_br = [",
            "            mock.call.delete_dvr_to_src_mac(",
            "                network_type='vxlan',",
            "                dst_mac=self._port.vif_mac,",
            "                vlan_tag=lvid,",
            "            ),",
            "            mock.call.install_dvr_to_src_mac(",
            "                network_type='vxlan',",
            "                gateway_mac='aa:bb:cc:11:22:33',",
            "                dst_mac=self._port.vif_mac,",
            "                dst_port=self._port.ofport,",
            "                vlan_tag=lvid,",
            "            ),",
            "        ] + self._expected_port_bound(self._port, lvid, is_dvr=False)",
            "        int_br.assert_has_calls(expected_on_int_br)",
            "        # a local vlan was already provisioned so there should be no new",
            "        # calls to tunbr",
            "        tun_br.assert_not_called()",
            "        # make sure ofport was updated",
            "        self.assertEqual(12,",
            "            self.agent.dvr_agent.local_ports[self._port.vif_id].ofport)",
            "",
            "    def _port_bound_for_dvr_with_csnat_ports(self):",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': '1.1.1.1',",
            "                               'cidr': '1.1.1.0/24',",
            "                               'ip_version': n_const.IP_VERSION_4,",
            "                               'gateway_mac': 'aa:bb:cc:11:22:33'}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_ROUTER_SNAT,",
            "                False)",
            "        return int_br, tun_br",
            "",
            "    def test_port_bound_for_dvr_with_csnat_ports_without_subnet(self):",
            "        self._setup_for_dvr_test()",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "",
            "        # get_subnet_for_dvr RPC returns {} on error",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={}),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_ROUTER_SNAT,",
            "                False)",
            "            int_br.install_dvr_to_src_mac.assert_not_called()",
            "",
            "    def test_treat_devices_removed_for_dvr_interface(self):",
            "        self._test_treat_devices_removed_for_dvr_interface()",
            "        self._test_treat_devices_removed_for_dvr_interface(",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_treat_devices_removed_for_dvr_interface(network_type='vlan')",
            "        self._test_treat_devices_removed_for_dvr_interface(",
            "            ip_version=n_const.IP_VERSION_6, network_type='vlan')",
            "",
            "    def _test_treat_devices_removed_for_dvr_interface(",
            "            self, ip_version=n_const.IP_VERSION_4, network_type='vxlan'):",
            "        self._setup_for_dvr_test()",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            gateway_ip = '1.1.1.1'",
            "            cidr = '1.1.1.0/24'",
            "        else:",
            "            gateway_ip = '2001:100::1'",
            "            cidr = '2001:100::0/64'",
            "        self._port.dvr_mac = self.agent.dvr_agent.dvr_mac_address",
            "        gateway_mac = 'aa:bb:cc:11:22:33'",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': gateway_ip,",
            "                               'cidr': cidr,",
            "                               'ip_version': ip_version,",
            "                               'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port):",
            "            if network_type == 'vlan':",
            "                self.agent.port_bound(self._port, self._net_uuid,",
            "                                      network_type, self._physical_network,",
            "                                      self._segmentation_id,",
            "                                      self._compute_fixed_ips,",
            "                                      n_const.DEVICE_OWNER_DVR_INTERFACE,",
            "                                      False)",
            "            else:",
            "                self.agent.port_bound(",
            "                    self._port, self._net_uuid, 'vxlan',",
            "                    None, None, self._fixed_ips,",
            "                    n_const.DEVICE_OWNER_DVR_INTERFACE,",
            "                    False)",
            "                lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "                int_br.assert_has_calls(",
            "                    self._expected_port_bound(self._port, lvid))",
            "                expected_on_tun_br = [",
            "                    mock.call.provision_local_vlan(network_type='vxlan',",
            "                        lvid=lvid, segmentation_id=None, distributed=True),",
            "                ] + self._expected_install_dvr_process(",
            "                    port=self._port,",
            "                    lvid=lvid,",
            "                    ip_version=ip_version,",
            "                    gateway_ip=gateway_ip)",
            "                tun_br.assert_has_calls(expected_on_tun_br)",
            "",
            "        int_br.reset_mock()",
            "        tun_br.reset_mock()",
            "        phys_br = mock.create_autospec(self.br_phys_cls('br-phys'))",
            "        with mock.patch.object(self.agent, 'reclaim_local_vlan'),\\",
            "                mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={",
            "                                      'devices_up': [],",
            "                                      'devices_down': [self._port.vif_id],",
            "                                      'failed_devices_up': [],",
            "                                      'failed_devices_down': []}),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {self._physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {self._physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=None):",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_devices['removed'] = self.agent.treat_devices_removed(",
            "                [self._port.vif_id])",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            if ip_version == n_const.IP_VERSION_4:",
            "                expected = [",
            "                    mock.call.delete_dvr_process_ipv4(",
            "                        vlan_tag=lvid,",
            "                        gateway_ip=gateway_ip),",
            "                ]",
            "            else:",
            "                expected = [",
            "                    mock.call.delete_dvr_process_ipv6(",
            "                        vlan_tag=lvid,",
            "                        gateway_mac=gateway_mac),",
            "                ]",
            "            expected.extend([",
            "                mock.call.delete_dvr_process(",
            "                    vlan_tag=lvid,",
            "                    vif_mac=self._port.vif_mac),",
            "            ])",
            "            if network_type == 'vlan':",
            "                expected_unbound_dvr = self._expected_port_unbound(self._port,",
            "                    self._segmentation_id, network_type=network_type)",
            "                int_br.assert_has_calls(expected_unbound_dvr)",
            "                tun_br.assert_not_called()",
            "                phys_br.assert_has_calls(expected)",
            "                self.assertEqual({}, self.agent.dvr_agent.local_ports)",
            "            else:",
            "                expected_unbound_dvr = self._expected_port_unbound(self._port,",
            "                    lvid, network_type=network_type)",
            "                int_br.assert_has_calls(expected_unbound_dvr)",
            "                tun_br.assert_has_calls(expected)",
            "                phys_br.assert_not_called()",
            "",
            "    def _test_treat_devices_removed_for_dvr(self, device_owner,",
            "                                            ip_version=n_const.IP_VERSION_4):",
            "        self._setup_for_dvr_test()",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            gateway_ip = '1.1.1.1'",
            "            cidr = '1.1.1.0/24'",
            "        else:",
            "            gateway_ip = '2001:100::1'",
            "            cidr = '2001:100::0/64'",
            "        self._port.dvr_mac = self.agent.dvr_agent.dvr_mac_address",
            "        gateway_mac = 'aa:bb:cc:11:22:33'",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': gateway_ip,",
            "                               'cidr': cidr,",
            "                               'ip_version': ip_version,",
            "                               'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_DVR_INTERFACE,",
            "                False)",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            int_br.assert_has_calls(",
            "                self._expected_port_bound(self._port, lvid))",
            "            expected_on_tun_br = [",
            "                mock.call.provision_local_vlan(",
            "                    network_type='vxlan',",
            "                    segmentation_id=None,",
            "                    lvid=lvid,",
            "                    distributed=True),",
            "            ] + self._expected_install_dvr_process(",
            "                port=self._port,",
            "                lvid=lvid,",
            "                ip_version=ip_version,",
            "                gateway_ip=gateway_ip)",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "            int_br.reset_mock()",
            "            tun_br.reset_mock()",
            "            self.agent.port_bound(self._compute_port,",
            "                                  self._net_uuid, 'vxlan',",
            "                                  None, None,",
            "                                  self._compute_fixed_ips,",
            "                                  device_owner, False)",
            "            int_br.assert_has_calls(",
            "                [",
            "                    mock.call.install_dvr_to_src_mac(",
            "                        network_type='vxlan',",
            "                        gateway_mac='aa:bb:cc:11:22:33',",
            "                        dst_mac=self._compute_port.vif_mac,",
            "                        dst_port=self._compute_port.ofport,",
            "                        vlan_tag=lvid,",
            "                    ),",
            "                ] + self._expected_port_bound(self._compute_port, lvid, False))",
            "            tun_br.assert_not_called()",
            "",
            "        int_br.reset_mock()",
            "        tun_br.reset_mock()",
            "        with mock.patch.object(self.agent, 'reclaim_local_vlan'),\\",
            "                mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={",
            "                                      'devices_up': [],",
            "                                      'devices_down': [",
            "                                          self._compute_port.vif_id],",
            "                                      'failed_devices_up': [],",
            "                                      'failed_devices_down': []}),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_devices['removed'] = self.agent.treat_devices_removed(",
            "                [self._compute_port.vif_id])",
            "            int_br.assert_has_calls([",
            "                mock.call.delete_dvr_to_src_mac(",
            "                    network_type='vxlan',",
            "                    vlan_tag=lvid,",
            "                    dst_mac=self._compute_port.vif_mac,",
            "                ),",
            "            ])",
            "            tun_br.assert_not_called()",
            "",
            "    def test_treat_devices_removed_for_dvr_with_compute_ports(self):",
            "        self._test_treat_devices_removed_for_dvr(",
            "            device_owner=DEVICE_OWNER_COMPUTE)",
            "        self._test_treat_devices_removed_for_dvr(",
            "            device_owner=DEVICE_OWNER_COMPUTE, ip_version=n_const.IP_VERSION_6)",
            "",
            "    def test_treat_devices_removed_for_dvr_with_dhcp_ports(self):",
            "        self._test_treat_devices_removed_for_dvr(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP)",
            "        self._test_treat_devices_removed_for_dvr(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            ip_version=n_const.IP_VERSION_6)",
            "",
            "    def test_treat_devices_removed_for_dvr_csnat_port(self):",
            "        self._setup_for_dvr_test()",
            "        gateway_mac = 'aa:bb:cc:11:22:33'",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': '1.1.1.1',",
            "                               'cidr': '1.1.1.0/24',",
            "                               'ip_version': n_const.IP_VERSION_4,",
            "                               'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_ROUTER_SNAT,",
            "                False)",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            expected_on_int_br = [",
            "                mock.call.install_dvr_to_src_mac(",
            "                    network_type='vxlan',",
            "                    gateway_mac=gateway_mac,",
            "                    dst_mac=self._port.vif_mac,",
            "                    dst_port=self._port.ofport,",
            "                    vlan_tag=lvid,",
            "                ),",
            "            ] + self._expected_port_bound(self._port, lvid, is_dvr=False)",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            expected_on_tun_br = [",
            "                mock.call.provision_local_vlan(",
            "                    network_type='vxlan',",
            "                    lvid=lvid,",
            "                    segmentation_id=None,",
            "                    distributed=True,",
            "                ),",
            "            ]",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "",
            "        int_br.reset_mock()",
            "        tun_br.reset_mock()",
            "        with mock.patch.object(self.agent, 'reclaim_local_vlan'),\\",
            "                mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={",
            "                                      'devices_up': [],",
            "                                      'devices_down': [self._port.vif_id],",
            "                                      'failed_devices_up': [],",
            "                                      'failed_devices_down': []}),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.int_br, 'get_vif_port_by_id',",
            "                                  return_value=None):",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_devices['removed'] = self.agent.treat_devices_removed(",
            "                [self._port.vif_id])",
            "            expected_on_int_br = [",
            "                mock.call.delete_dvr_to_src_mac(",
            "                    network_type='vxlan',",
            "                    dst_mac=self._port.vif_mac,",
            "                    vlan_tag=lvid,",
            "                ),",
            "            ]",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "",
            "    def test_setup_dvr_flows_on_int_br(self):",
            "        self._setup_for_dvr_test()",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        with mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_dvr_mac_address_list',",
            "                                  return_value=[{'host': 'cn1',",
            "                                  'mac_address': 'aa-bb-cc-dd-ee-ff'},",
            "                                  {'host': 'cn2',",
            "                                  'mac_address': '11-22-33-44-55-66'}]):",
            "            self.agent.dvr_agent.setup_dvr_flows_on_integ_br()",
            "            self.assertTrue(self.agent.dvr_agent.in_distributed_mode())",
            "            physical_networks = list(",
            "                self.agent.dvr_agent.bridge_mappings.keys())",
            "            ioport = self.agent.dvr_agent.int_ofports[physical_networks[0]]",
            "            expected_on_int_br = [",
            "                # setup_dvr_flows_on_integ_br",
            "                mock.call.setup_canary_table(),",
            "                mock.call.install_drop(table_id=constants.DVR_TO_SRC_MAC,",
            "                                       priority=1),",
            "                mock.call.install_drop(",
            "                    table_id=constants.DVR_TO_SRC_MAC_PHYSICAL,",
            "                    priority=1),",
            "                mock.call.install_drop(table_id=constants.LOCAL_SWITCHING,",
            "                                       priority=2,",
            "                                       in_port=ioport),",
            "            ]",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "",
            "    def test_get_dvr_mac_address(self):",
            "        self._setup_for_dvr_test()",
            "        self.agent.dvr_agent.dvr_mac_address = None",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_dvr_mac_address_by_host',",
            "                               return_value={'host': 'cn1',",
            "                                  'mac_address': 'aa-22-33-44-55-66'}):",
            "            self.agent.dvr_agent.get_dvr_mac_address()",
            "            self.assertEqual('aa:22:33:44:55:66',",
            "                             self.agent.dvr_agent.dvr_mac_address)",
            "            self.assertTrue(self.agent.dvr_agent.in_distributed_mode())",
            "",
            "    def test_get_dvr_mac_address_exception(self):",
            "        self._setup_for_dvr_test()",
            "        self.agent.dvr_agent.dvr_mac_address = None",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_dvr_mac_address_by_host',",
            "                               side_effect=oslo_messaging.RemoteError),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br):",
            "            with testtools.ExpectedException(SystemExit):",
            "                self.agent.dvr_agent.get_dvr_mac_address()",
            "                self.assertIsNone(self.agent.dvr_agent.dvr_mac_address)",
            "                self.assertFalse(self.agent.dvr_agent.in_distributed_mode())",
            "",
            "    def test_get_dvr_mac_address_retried(self):",
            "        valid_entry = {'host': 'cn1', 'mac_address': 'aa-22-33-44-55-66'}",
            "        raise_timeout = oslo_messaging.MessagingTimeout()",
            "        # Raise a timeout the first 2 times it calls get_dvr_mac_address()",
            "        self._setup_for_dvr_test()",
            "        self.agent.dvr_agent.dvr_mac_address = None",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_dvr_mac_address_by_host',",
            "                               side_effect=(raise_timeout, raise_timeout,",
            "                                            valid_entry)):",
            "            self.agent.dvr_agent.get_dvr_mac_address()",
            "            self.assertEqual('aa:22:33:44:55:66',",
            "                             self.agent.dvr_agent.dvr_mac_address)",
            "            self.assertTrue(self.agent.dvr_agent.in_distributed_mode())",
            "            self.assertEqual(self.agent.dvr_agent.plugin_rpc.",
            "                             get_dvr_mac_address_by_host.call_count, 3)",
            "",
            "    def test_get_dvr_mac_address_retried_max(self):",
            "        raise_timeout = oslo_messaging.MessagingTimeout()",
            "        # Raise a timeout every time until we give up, currently 5 tries",
            "        self._setup_for_dvr_test()",
            "        self.agent.dvr_agent.dvr_mac_address = None",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_dvr_mac_address_by_host',",
            "                               side_effect=raise_timeout),\\",
            "                mock.patch.object(utils, \"execute\"),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br):",
            "            with testtools.ExpectedException(SystemExit):",
            "                self.agent.dvr_agent.get_dvr_mac_address()",
            "                self.assertIsNone(self.agent.dvr_agent.dvr_mac_address)",
            "                self.assertFalse(self.agent.dvr_agent.in_distributed_mode())",
            "                self.assertEqual(self.agent.dvr_agent.plugin_rpc.",
            "                                 get_dvr_mac_address_by_host.call_count, 5)",
            "",
            "    def test_dvr_mac_address_update(self):",
            "        self._setup_for_dvr_test()",
            "        newhost = 'cn2'",
            "        newmac = 'aa:bb:cc:dd:ee:ff'",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        phys_br = mock.create_autospec(self.br_phys_cls('br-phys'))",
            "        physical_network = 'physeth1'",
            "        with mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {physical_network: phys_br}):",
            "            self.agent.dvr_agent.\\",
            "                dvr_mac_address_update(",
            "                    dvr_macs=[{'host': newhost,",
            "                               'mac_address': newmac}])",
            "            expected_on_int_br = [",
            "                mock.call.add_dvr_mac_physical(",
            "                    mac=newmac,",
            "                    port=self.agent.int_ofports[physical_network]),",
            "                mock.call.add_dvr_mac_tun(",
            "                    mac=newmac,",
            "                    port=self.agent.patch_tun_ofport),",
            "            ]",
            "            expected_on_tun_br = [",
            "                mock.call.add_dvr_mac_tun(",
            "                    mac=newmac,",
            "                    port=self.agent.patch_int_ofport),",
            "            ]",
            "            expected_on_phys_br = [",
            "                mock.call.add_dvr_mac_physical(",
            "                    mac=newmac,",
            "                    port=self.agent.phys_ofports[physical_network]),",
            "            ]",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "            phys_br.assert_has_calls(expected_on_phys_br)",
            "        int_br.reset_mock()",
            "        tun_br.reset_mock()",
            "        phys_br.reset_mock()",
            "        with mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {physical_network: phys_br}):",
            "            self.agent.dvr_agent.dvr_mac_address_update(dvr_macs=[])",
            "            expected_on_int_br = [",
            "                mock.call.remove_dvr_mac_vlan(",
            "                    mac=newmac),",
            "                mock.call.remove_dvr_mac_tun(",
            "                    mac=newmac,",
            "                    port=self.agent.patch_tun_ofport),",
            "            ]",
            "            expected_on_tun_br = [",
            "                mock.call.remove_dvr_mac_tun(",
            "                    mac=newmac),",
            "            ]",
            "            expected_on_phys_br = [",
            "                mock.call.remove_dvr_mac_vlan(",
            "                    mac=newmac),",
            "            ]",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "            phys_br.assert_has_calls(expected_on_phys_br)",
            "",
            "    def test_ovs_restart(self):",
            "        self._setup_for_dvr_test()",
            "        reset_methods = (",
            "            'reset_ovs_parameters', 'reset_dvr_parameters',",
            "            'setup_dvr_flows_on_integ_br', 'setup_dvr_flows_on_tun_br',",
            "            'setup_dvr_flows_on_phys_br', 'setup_dvr_mac_flows_on_all_brs')",
            "        reset_mocks = [mock.patch.object(self.agent.dvr_agent, method).start()",
            "                       for method in reset_methods]",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        with mock.patch.object(self.agent,",
            "                               'check_ovs_status',",
            "                               return_value=constants.OVS_RESTARTED),\\",
            "                mock.patch.object(self.agent,",
            "                                  '_agent_has_updates',",
            "                                  side_effect=TypeError('loop exit')),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent, 'setup_physical_bridges'),\\",
            "                mock.patch.object(self.agent, 'setup_integration_br'),\\",
            "                mock.patch.object(self.agent, 'setup_tunnel_br'),\\",
            "                mock.patch.object(self.agent, 'state_rpc'), \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor'):",
            "            try:",
            "                self.agent.rpc_loop(polling_manager=mock.Mock())",
            "            except TypeError:",
            "                pass",
            "        self.assertTrue(all([x.called for x in reset_mocks]))",
            "",
            "    def test_rpc_loop_survives_error_in_check_canary_table(self):",
            "        with mock.patch.object(self.agent.int_br,",
            "                               'check_canary_table',",
            "                               side_effect=TypeError('borked')),\\",
            "                mock.patch.object(self.agent, '_check_and_handle_signal',",
            "                                  side_effect=[True, False]):",
            "            self.agent.rpc_loop(polling_manager=mock.Mock())",
            "",
            "    def _test_scan_ports_failure(self, scan_method_name):",
            "        with mock.patch.object(self.agent,",
            "                               'check_ovs_status',",
            "                               return_value=constants.OVS_RESTARTED),\\",
            "                mock.patch.object(self.agent, scan_method_name,",
            "                               side_effect=TypeError('broken')),\\",
            "                mock.patch.object(self.agent, '_agent_has_updates',",
            "                                  return_value=True),\\",
            "                mock.patch.object(self.agent, '_check_and_handle_signal',",
            "                                  side_effect=[True, False]),\\",
            "                mock.patch.object(self.agent, 'setup_physical_bridges'),\\",
            "                mock.patch.object(self.agent, 'setup_integration_br'),\\",
            "                mock.patch.object(self.agent, 'state_rpc'), \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor'):",
            "            # block RPC calls and bridge calls",
            "            self.agent.rpc_loop(polling_manager=mock.Mock())",
            "",
            "    def test_scan_ports_failure(self):",
            "        self._test_scan_ports_failure('scan_ports')",
            "",
            "    def test_scan_ancillary_ports_failure(self):",
            "        with mock.patch.object(self.agent, 'scan_ports'):",
            "            with mock.patch.object(self.agent, 'update_stale_ofport_rules'):",
            "                self.agent.ancillary_brs = mock.Mock()",
            "                self._test_scan_ports_failure('scan_ancillary_ports')",
            "",
            "    def test_ext_br_recreated(self):",
            "        self._setup_for_dvr_test()",
            "        reset_methods = (",
            "            'reset_ovs_parameters', 'reset_dvr_parameters',",
            "            'setup_dvr_flows_on_integ_br', 'setup_dvr_flows_on_tun_br',",
            "            'setup_dvr_flows_on_phys_br', 'setup_dvr_mac_flows_on_all_brs')",
            "        for method in reset_methods:",
            "            mock.patch.object(self.agent.dvr_agent, method).start()",
            "        bridge_mappings = {'physnet0': 'br-ex0',",
            "                           'physnet1': 'br-ex1'}",
            "        ex_br_mocks = [mock.Mock(br_name='br-ex0'),",
            "                       mock.Mock(br_name='br-ex1')]",
            "        phys_bridges = {'physnet0': ex_br_mocks[0],",
            "                        'physnet1': ex_br_mocks[1]},",
            "        bridges_added = ['br-ex0']",
            "        with mock.patch.object(self.agent, 'check_ovs_status',",
            "                               return_value=constants.OVS_NORMAL), \\",
            "                mock.patch.object(self.agent, '_agent_has_updates',",
            "                                  side_effect=TypeError('loop exit')), \\",
            "                mock.patch.dict(self.agent.bridge_mappings, bridge_mappings,",
            "                                clear=True), \\",
            "                mock.patch.dict(self.agent.phys_brs, phys_bridges,",
            "                                clear=True), \\",
            "                mock.patch.object(self.agent, 'setup_physical_bridges') as \\",
            "                setup_physical_bridges, \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor') as \\",
            "                mock_idl_monitor:",
            "            mock_idl_monitor.bridges_added = bridges_added",
            "            try:",
            "                self.agent.rpc_loop(polling_manager=mock.Mock())",
            "            except TypeError:",
            "                pass",
            "        # Setup bridges should be called once even if it will raise Runtime",
            "        # Error because TypeError is raised in _agent_has_updates to stop",
            "        # agent after first loop iteration",
            "        setup_physical_bridges.assert_called_once_with({'physnet0': 'br-ex0'})",
            "        # Ensure dvr_agent methods were called correctly",
            "        self.agent.dvr_agent.reset_ovs_parameters.assert_called_once_with(",
            "            self.agent.int_br, self.agent.tun_br, self.agent.phys_brs,",
            "            self.agent.patch_int_ofport, self.agent.patch_tun_ofport)",
            "        self.agent.dvr_agent.reset_dvr_parameters.assert_called_once_with()",
            "        (self.agent.dvr_agent.setup_dvr_flows_on_phys_br.",
            "         assert_called_once_with({'physnet0': 'br-ex0'}))",
            "        (self.agent.dvr_agent.setup_dvr_flows_on_integ_br.",
            "            assert_called_once_with())",
            "        (self.agent.dvr_agent.setup_dvr_flows_on_tun_br.",
            "            assert_called_once_with())",
            "        (self.agent.dvr_agent.setup_dvr_mac_flows_on_all_brs.",
            "            assert_called_once_with())",
            "",
            "",
            "class TestOvsDvrNeutronAgentOSKen(TestOvsDvrNeutronAgent,",
            "                                ovs_test_base.OVSOSKenTestBase):",
            "    pass",
            "",
            "",
            "class TestValidateTunnelLocalIP(base.BaseTestCase):",
            "    def test_validate_local_ip_with_valid_ip(self):",
            "        mock_get_device_by_ip = mock.patch.object(",
            "            ip_lib.IPWrapper, 'get_device_by_ip').start()",
            "        ovs_agent.validate_local_ip(FAKE_IP1)",
            "        mock_get_device_by_ip.assert_called_once_with(FAKE_IP1)",
            "",
            "    def test_validate_local_ip_with_valid_ipv6(self):",
            "        mock_get_device_by_ip = mock.patch.object(",
            "            ip_lib.IPWrapper, 'get_device_by_ip').start()",
            "        ovs_agent.validate_local_ip(FAKE_IP6)",
            "        mock_get_device_by_ip.assert_called_once_with(FAKE_IP6)",
            "",
            "    def test_validate_local_ip_with_none_ip(self):",
            "        with testtools.ExpectedException(SystemExit):",
            "            ovs_agent.validate_local_ip(None)",
            "",
            "    def test_validate_local_ip_with_invalid_ip(self):",
            "        mock_get_device_by_ip = mock.patch.object(",
            "            ip_lib.IPWrapper, 'get_device_by_ip').start()",
            "        mock_get_device_by_ip.return_value = None",
            "        with testtools.ExpectedException(SystemExit):",
            "            ovs_agent.validate_local_ip(FAKE_IP1)",
            "        mock_get_device_by_ip.assert_called_once_with(FAKE_IP1)",
            "",
            "    def test_validate_local_ip_with_invalid_ipv6(self):",
            "        mock_get_device_by_ip = mock.patch.object(",
            "            ip_lib.IPWrapper, 'get_device_by_ip').start()",
            "        mock_get_device_by_ip.return_value = None",
            "        with testtools.ExpectedException(SystemExit):",
            "            ovs_agent.validate_local_ip(FAKE_IP6)",
            "        mock_get_device_by_ip.assert_called_once_with(FAKE_IP6)",
            "",
            "",
            "class TestOvsAgentTunnelName(base.BaseTestCase):",
            "    def test_get_tunnel_hash_invalid_address(self):",
            "        hashlen = n_const.DEVICE_NAME_MAX_LEN",
            "        self.assertIsNone(",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_hash('a.b.c.d', hashlen))",
            "",
            "    def test_get_tunnel_name_vxlan(self):",
            "        self.assertEqual(",
            "            'vxlan-7f000002',",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_name(",
            "                'vxlan', '127.0.0.1', '127.0.0.2'))",
            "",
            "    def test_get_tunnel_name_gre(self):",
            "        self.assertEqual(",
            "            'gre-7f000002',",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_name(",
            "                'gre', '127.0.0.1', '127.0.0.2'))",
            "",
            "    def test_get_tunnel_name_vxlan_ipv6(self):",
            "        self.assertEqual(",
            "            'vxlan-pehtjzksi',",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_name(",
            "                'vxlan', '2001:db8::1', '2001:db8::2'))",
            "",
            "    def test_get_tunnel_name_gre_ipv6(self):",
            "        self.assertEqual(",
            "            'gre-pehtjzksiqr',",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_name(",
            "                'gre', '2001:db8::1', '2001:db8::2'))"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2012 OpenStack Foundation.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import contextlib",
            "import sys",
            "import time",
            "from unittest import mock",
            "",
            "import netaddr",
            "from neutron_lib.agent import constants as agent_consts",
            "from neutron_lib.api.definitions import portbindings",
            "from neutron_lib.api.definitions import provider_net",
            "from neutron_lib import constants as n_const",
            "from neutron_lib import rpc as n_rpc",
            "import os_vif",
            "from os_vif.objects import instance_info as vif_instance_object",
            "from oslo_config import cfg",
            "from oslo_log import log",
            "import oslo_messaging",
            "import testtools",
            "",
            "from neutron._i18n import _",
            "from neutron.agent.common import async_process",
            "from neutron.agent.common import ovs_lib",
            "from neutron.agent.common import polling",
            "from neutron.agent.common import utils",
            "from neutron.agent.linux import ip_lib",
            "from neutron.agent.linux import utils as linux_utils",
            "from neutron.api.rpc.callbacks import resources",
            "from neutron.objects.ports import Port",
            "from neutron.objects.ports import PortBinding",
            "from neutron.plugins.ml2.drivers.l2pop import rpc as l2pop_rpc",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants",
            "from neutron.plugins.ml2.drivers.openvswitch.agent import ovs_neutron_agent \\",
            "    as ovs_agent",
            "from neutron.tests import base",
            "from neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_test_base",
            "from neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent \\",
            "    import test_vlanmanager",
            "",
            "",
            "NOTIFIER = 'neutron.plugins.ml2.rpc.AgentNotifierApi'",
            "PULLAPI = 'neutron.api.rpc.handlers.resources_rpc.ResourcesPullRpcApi'",
            "OVS_LINUX_KERN_VERS_WITHOUT_VXLAN = \"3.12.0\"",
            "",
            "FAKE_MAC = '00:11:22:33:44:55'",
            "FAKE_IP1 = '10.0.0.1'",
            "FAKE_IP2 = '10.0.0.2'",
            "FAKE_IP6 = '2001:db8:42:42::10'",
            "",
            "TEST_PORT_ID1 = 'port-id-1'",
            "TEST_PORT_ID2 = 'port-id-2'",
            "TEST_PORT_ID3 = 'port-id-3'",
            "",
            "TEST_NETWORK_ID1 = 'net-id-1'",
            "TEST_NETWORK_ID2 = 'net-id-2'",
            "",
            "DEVICE_OWNER_COMPUTE = n_const.DEVICE_OWNER_COMPUTE_PREFIX + 'fake'",
            "",
            "",
            "class FakeVif(object):",
            "    ofport = 99",
            "    port_name = 'name'",
            "    vif_mac = 'aa:bb:cc:11:22:33'",
            "",
            "",
            "class MockFixedIntervalLoopingCall(object):",
            "    def __init__(self, f):",
            "        self.f = f",
            "",
            "    def start(self, interval=0):",
            "        self.f()",
            "",
            "",
            "class ValidateTunnelTypes(ovs_test_base.OVSAgentConfigTestBase):",
            "",
            "    def setUp(self):",
            "        super(ValidateTunnelTypes, self).setUp()",
            "        self.mock_validate_local_ip = mock.patch.object(",
            "            self.mod_agent, 'validate_local_ip').start()",
            "",
            "    def test_validate_tunnel_types_succeeds(self):",
            "        cfg.CONF.set_override('local_ip', '10.10.10.10', group='OVS')",
            "        cfg.CONF.set_override('tunnel_types', [n_const.TYPE_GRE],",
            "                              group='AGENT')",
            "        self.mod_agent.validate_tunnel_config(cfg.CONF.AGENT.tunnel_types,",
            "                                              cfg.CONF.OVS.local_ip)",
            "        self.mock_validate_local_ip.assert_called_once_with('10.10.10.10')",
            "",
            "    def test_validate_tunnel_types_fails_for_invalid_tunnel_type(self):",
            "        cfg.CONF.set_override('local_ip', '10.10.10.10', group='OVS')",
            "        cfg.CONF.set_override('tunnel_types', ['foobar'], group='AGENT')",
            "        with testtools.ExpectedException(SystemExit):",
            "            self.mod_agent.validate_tunnel_config(cfg.CONF.AGENT.tunnel_types,",
            "                                                  cfg.CONF.OVS.local_ip)",
            "",
            "",
            "class TestOvsNeutronAgent(object):",
            "",
            "    def setUp(self):",
            "        super(TestOvsNeutronAgent, self).setUp()",
            "        self.useFixture(test_vlanmanager.LocalVlanManagerFixture())",
            "        mock.patch(PULLAPI).start()",
            "        notifier_p = mock.patch(NOTIFIER)",
            "        notifier_cls = notifier_p.start()",
            "        self.notifier = mock.Mock()",
            "        notifier_cls.return_value = self.notifier",
            "        systemd_patch = mock.patch('oslo_service.systemd.notify_once')",
            "        self.systemd_notify = systemd_patch.start()",
            "",
            "        cfg.CONF.set_default('firewall_driver',",
            "                             'neutron.agent.firewall.NoopFirewallDriver',",
            "                             group='SECURITYGROUP')",
            "        cfg.CONF.set_default('quitting_rpc_timeout', 10, 'AGENT')",
            "        cfg.CONF.set_default('local_ip', '127.0.0.1', 'OVS')",
            "        cfg.CONF.set_default('host', 'host')",
            "        mock.patch(",
            "            'neutron.agent.ovsdb.native.helpers.enable_connection_uri').start()",
            "        mock.patch(",
            "            'neutron.agent.common.ovs_lib.OVSBridge.get_ports_attributes',",
            "            return_value=[]).start()",
            "",
            "        mock.patch('neutron.agent.common.ovs_lib.BaseOVS.config',",
            "                   new_callable=mock.PropertyMock,",
            "                   return_value={}).start()",
            "        mock.patch('neutron.agent.ovsdb.impl_idl._connection').start()",
            "        self.agent = self._make_agent()",
            "        self.agent.sg_agent = mock.Mock()",
            "",
            "    def _make_agent(self):",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'),\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_ancillary_bridges',",
            "                                  return_value=[]),\\",
            "                mock.patch('neutron.agent.linux.ip_lib.get_device_mac',",
            "                           return_value='00:00:00:00:00:01'),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.BaseOVS.get_bridges'),\\",
            "                mock.patch('oslo_service.loopingcall.FixedIntervalLoopingCall',",
            "                           new=MockFixedIntervalLoopingCall),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.' 'get_vif_ports',",
            "                    return_value=[]),\\",
            "                mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                           'has_alive_neutron_server'):",
            "            ext_manager = mock.Mock()",
            "            agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                   ext_manager, cfg.CONF)",
            "            agent.tun_br = self.br_tun_cls(br_name='br-tun')",
            "            return agent",
            "",
            "    def _mock_port_bound(self, ofport=None, new_local_vlan=None,",
            "                         old_local_vlan=None, db_get_val=None):",
            "        port = mock.Mock()",
            "        port.ofport = ofport",
            "        net_uuid = 'my-net-uuid'",
            "        fixed_ips = [{'subnet_id': 'my-subnet-uuid',",
            "                      'ip_address': '1.1.1.1'}]",
            "        if old_local_vlan is not None:",
            "            self.agent.vlan_manager.add(",
            "                net_uuid, old_local_vlan, None, None, None)",
            "        with mock.patch.object(self.agent, 'int_br', autospec=True) as int_br:",
            "            int_br.db_get_val.return_value = db_get_val",
            "            int_br.set_db_attribute.return_value = True",
            "            needs_binding = self.agent.port_bound(",
            "                port, net_uuid, 'local', None, None,",
            "                fixed_ips, DEVICE_OWNER_COMPUTE, False)",
            "        if db_get_val is None:",
            "            int_br.assert_not_called()",
            "            self.assertFalse(needs_binding)",
            "        else:",
            "            vlan_mapping = {'net_uuid': net_uuid,",
            "                            'network_type': 'local',",
            "                            'physical_network': 'None'}",
            "            int_br.set_db_attribute.assert_called_once_with(",
            "                \"Port\", mock.ANY, \"other_config\", vlan_mapping)",
            "            self.assertTrue(needs_binding)",
            "",
            "    def test_setup_physical_bridges_during_agent_initialization(self):",
            "        with mock.patch.object(",
            "            self.mod_agent.OVSNeutronAgent,",
            "            'setup_physical_bridges') as setup_physical_bridges,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent, 'setup_rpc') as setup_rpc:",
            "            setup_rpc.side_effect = oslo_messaging.MessagingException(",
            "                \"Test communication failure\")",
            "            try:",
            "                self._make_agent()",
            "            except oslo_messaging.MessagingException:",
            "                pass",
            "            setup_physical_bridges.assert_called_once_with(mock.ANY)",
            "",
            "    def test_datapath_type_system(self):",
            "        # verify kernel datapath is default",
            "        expected = constants.OVS_DATAPATH_SYSTEM",
            "        self.assertEqual(expected, self.agent.int_br.datapath_type)",
            "",
            "    def test_datapath_type_netdev(self):",
            "",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'), \\",
            "            mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                           'setup_ancillary_bridges',",
            "                           return_value=[]), \\",
            "            mock.patch('neutron.agent.linux.ip_lib.get_device_mac',",
            "                    return_value='00:00:00:00:00:01'), \\",
            "            mock.patch(",
            "                'neutron.agent.common.ovs_lib.BaseOVS.get_bridges'), \\",
            "            mock.patch('oslo_service.loopingcall.FixedIntervalLoopingCall',",
            "                       new=MockFixedIntervalLoopingCall), \\",
            "            mock.patch(",
            "                'neutron.agent.common.ovs_lib.OVSBridge.' 'get_vif_ports',",
            "                return_value=[]), \\",
            "            mock.patch('neutron.agent.common.ovs_lib.BaseOVS.config',",
            "                       new_callable=mock.PropertyMock,",
            "                       return_value={'datapath_types': ['netdev']}),\\",
            "            mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                       'has_alive_neutron_server'):",
            "            # validate setting non default datapath",
            "            expected = constants.OVS_DATAPATH_NETDEV",
            "            cfg.CONF.set_override('datapath_type',",
            "                                  expected,",
            "                                  group='OVS')",
            "            ext_manager = mock.Mock()",
            "            self.agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                        ext_manager, cfg.CONF)",
            "            self.assertEqual(expected, self.agent.int_br.datapath_type)",
            "",
            "    def test_agent_type_ovs(self):",
            "        # verify agent_type is default",
            "        expected = n_const.AGENT_TYPE_OVS",
            "        self.assertEqual(expected,",
            "                         self.agent.agent_state['agent_type'])",
            "",
            "    def test_agent_available_local_vlans(self):",
            "        expected = [n_const.MIN_VLAN_TAG,",
            "                    n_const.MIN_VLAN_TAG + 1,",
            "                    n_const.MAX_VLAN_TAG - 1,",
            "                    n_const.MAX_VLAN_TAG]",
            "        exception = [n_const.MIN_VLAN_TAG - 1,",
            "                     n_const.MAX_VLAN_TAG + 1,",
            "                     n_const.MAX_VLAN_TAG + 2]",
            "        available_vlan = self.agent.available_local_vlans",
            "        for tag in expected:",
            "            self.assertIn(tag, available_vlan)",
            "        for tag in exception:",
            "            self.assertNotIn(tag, available_vlan)",
            "",
            "    def _test_restore_local_vlan_maps(self, tag, segmentation_id='1'):",
            "        port = mock.Mock()",
            "        port.port_name = 'fake_port'",
            "        net_uuid = 'fake_network_id'",
            "        local_vlan_map = {'net_uuid': net_uuid,",
            "                          'network_type': 'vlan',",
            "                          'physical_network': 'fake_network'}",
            "        if segmentation_id is not None:",
            "            local_vlan_map['segmentation_id'] = segmentation_id",
            "",
            "        # this is for the call inside get_vif_ports()",
            "        get_interfaces = [{'name': port.port_name,",
            "                           'ofport': '1',",
            "                           'external_ids': {",
            "                               'iface-id': '1',",
            "                               'attached-mac': 'mac1'}},",
            "                          {'name': 'invalid',",
            "                           'ofport': ovs_lib.INVALID_OFPORT,",
            "                           'external_ids': {",
            "                               'iface-id': '2',",
            "                               'attached-mac': 'mac2'}},",
            "                          {'name': 'unassigned',",
            "                           'ofport': ovs_lib.UNASSIGNED_OFPORT,",
            "                           'external_ids': {",
            "                               'iface-id': '3',",
            "                               'attached-mac': 'mac3'}}]",
            "        # this is for the call inside _restore_local_vlan_map()",
            "        get_ports = [{'name': port.port_name,",
            "                      'other_config': local_vlan_map,",
            "                      'tag': tag}]",
            "",
            "        with mock.patch.object(self.agent.int_br,",
            "                               'get_ports_attributes',",
            "                               side_effect=[get_interfaces, get_ports]) as gpa:",
            "            self.agent._restore_local_vlan_map()",
            "            expected_hints = {}",
            "            if tag:",
            "                expected_hints[net_uuid] = tag",
            "            self.assertEqual(expected_hints, self.agent._local_vlan_hints)",
            "            # make sure invalid and unassigned ports were skipped",
            "            gpa.assert_has_calls([",
            "                mock.call('Interface', columns=mock.ANY, if_exists=True),",
            "                mock.call('Port', columns=mock.ANY, ports=['fake_port'])",
            "            ])",
            "",
            "    def test_restore_local_vlan_map_with_device_has_tag(self):",
            "        self._test_restore_local_vlan_maps(2)",
            "",
            "    def test_restore_local_vlan_map_with_device_no_tag(self):",
            "        self._test_restore_local_vlan_maps([])",
            "",
            "    def test_restore_local_vlan_map_no_segmentation_id(self):",
            "        self._test_restore_local_vlan_maps(2, segmentation_id=None)",
            "",
            "    def test_restore_local_vlan_map_segmentation_id_compat(self):",
            "        self._test_restore_local_vlan_maps(2, segmentation_id='None')",
            "",
            "    def test_check_agent_configurations_for_dvr_raises(self):",
            "        self.agent.enable_distributed_routing = True",
            "        self.agent.enable_tunneling = True",
            "        self.agent.l2_pop = False",
            "        self.assertRaises(ValueError,",
            "                          self.agent._check_agent_configurations)",
            "",
            "    def test_check_agent_configurations_for_dvr(self):",
            "        self.agent.enable_distributed_routing = True",
            "        self.agent.enable_tunneling = True",
            "        self.agent.l2_pop = True",
            "        self.assertIsNone(self.agent._check_agent_configurations())",
            "",
            "    def test_check_agent_configurations_for_dvr_with_vlan(self):",
            "        self.agent.enable_distributed_routing = True",
            "        self.agent.enable_tunneling = False",
            "        self.agent.l2_pop = False",
            "        self.assertIsNone(self.agent._check_agent_configurations())",
            "",
            "    def test_port_bound_deletes_flows_for_valid_ofport(self):",
            "        self._mock_port_bound(ofport=1, new_local_vlan=1, db_get_val={})",
            "",
            "    def test_port_bound_ignores_flows_for_invalid_ofport(self):",
            "        self._mock_port_bound(ofport=-1, new_local_vlan=1, db_get_val={})",
            "",
            "    def test_port_bound_does_not_rewire_if_already_bound(self):",
            "        self._mock_port_bound(",
            "            ofport=-1, new_local_vlan=1, old_local_vlan=1, db_get_val={})",
            "",
            "    def test_port_bound_not_found(self):",
            "        self._mock_port_bound(ofport=1, new_local_vlan=1, db_get_val=None)",
            "",
            "    def _test_port_dead(self, cur_tag=None):",
            "        port = mock.Mock()",
            "        port.ofport = 1",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.db_get_val.return_value = cur_tag",
            "            self.agent.port_dead(port)",
            "        if cur_tag is None or cur_tag == constants.DEAD_VLAN_TAG:",
            "            self.assertFalse(int_br.set_db_attribute.called)",
            "            self.assertFalse(int_br.drop_port.called)",
            "        else:",
            "            int_br.assert_has_calls([",
            "                mock.call.set_db_attribute(\"Port\", mock.ANY, \"tag\",",
            "                                           constants.DEAD_VLAN_TAG,",
            "                                           log_errors=True),",
            "                mock.call.drop_port(in_port=port.ofport),",
            "            ])",
            "",
            "    def test_port_dead(self):",
            "        self._test_port_dead()",
            "",
            "    def test_port_dead_with_port_already_dead(self):",
            "        self._test_port_dead(constants.DEAD_VLAN_TAG)",
            "",
            "    def test_port_dead_with_valid_tag(self):",
            "        self._test_port_dead(cur_tag=1)",
            "",
            "    def mock_scan_ports(self, vif_port_set=None, registered_ports=None,",
            "                        updated_ports=None, port_tags_dict=None, sync=False):",
            "        if port_tags_dict is None:  # Because empty dicts evaluate as False.",
            "            port_tags_dict = {}",
            "        with mock.patch.object(self.agent.int_br,",
            "                               'get_vif_port_set',",
            "                               return_value=vif_port_set),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_port_tag_dict',",
            "                                  return_value=port_tags_dict):",
            "            return self.agent.scan_ports(registered_ports, sync, updated_ports)",
            "",
            "    def test_scan_ports_returns_current_only_for_unchanged_ports(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 3])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set)",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ports_returns_port_changes(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added=set([3]),",
            "                                      removed=set([2]))",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ports_returns_port_changes_with_sync(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added=vif_port_set,",
            "                                      removed=set([2]))",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports,",
            "                                      sync=True)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def _test_scan_ports_with_updated_ports(self, updated_ports):",
            "        vif_port_set = set([1, 3, 4])",
            "        registered_ports = set([1, 2, 4])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added={3},",
            "                                      removed={2}, updated={4})",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports,",
            "                                      updated_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ports_finds_known_updated_ports(self):",
            "        self._test_scan_ports_with_updated_ports(set([4]))",
            "",
            "    def test_scan_ports_ignores_unknown_updated_ports(self):",
            "        # the port '5' was not seen on current ports. Hence it has either",
            "        # never been wired or already removed and should be ignored",
            "        self._test_scan_ports_with_updated_ports(set([4, 5]))",
            "",
            "    def test_scan_ports_ignores_updated_port_if_removed(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        updated_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added=set([3]),",
            "                                      removed=set([2]), updated=set([1]))",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports,",
            "                                      updated_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ports_no_vif_changes_returns_updated_port_only(self):",
            "        vif_port_set = set([1, 2, 3])",
            "        registered_ports = set([1, 2, 3])",
            "        updated_ports = set([2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, updated=set([2]))",
            "        actual = self.mock_scan_ports(vif_port_set, registered_ports,",
            "                                      updated_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def _test_process_ports_events(self, events, registered_ports,",
            "                                   ancillary_ports, expected_ports,",
            "                                   expected_ancillary, updated_ports=None,",
            "                                   ):",
            "        with mock.patch.object(self.agent, 'check_changed_vlans',",
            "                               return_value=set()):",
            "            devices_not_ready_yet = set()",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {",
            "                'added': set(), 'removed': set()}",
            "            actual = self.agent.process_ports_events(",
            "                events, registered_ports, ancillary_ports,",
            "                devices_not_ready_yet, failed_devices,",
            "                failed_ancillary_devices, updated_ports)",
            "            self.assertEqual(",
            "                (expected_ports, expected_ancillary, devices_not_ready_yet),",
            "                actual)",
            "",
            "    def test_process_ports_events_port_removed_and_added(self):",
            "        port_id_one = 'f6f104bd-37c7-4f7b-9d70-53a6bb42728f'",
            "        port_id_two = 'fbaf42ef-ab63-4cda-81d2-37ee55daac3a'",
            "        events = {",
            "            'removed':",
            "                [{'ofport': 1,",
            "                  'external_ids': {'iface-id': port_id_one,",
            "                                   'attached-mac': 'fa:16:3e:f6:1b:fb'},",
            "                  'name': 'qvof6f104bd-37'},",
            "                 {'ofport': 2,",
            "                  'external_ids': {'iface-id': port_id_two,",
            "                                   'attached-mac': 'fa:16:3e:a4:42:6e'},",
            "                  'name': 'qvofbaf42ef-ab'}],",
            "            'added':",
            "                [{'ofport': 3,",
            "                  'external_ids': {'iface-id': port_id_one,",
            "                                   'attached-mac': 'fa:16:3e:f6:1b:fb'},",
            "                  'name': 'qvof6f104bd-37'},",
            "                 {'ofport': 4,",
            "                  'external_ids': {'iface-id': port_id_two,",
            "                                   'attached-mac': 'fa:16:3e:a4:42:6e'},",
            "                  'name': 'qvofbaf42ef-ab'}],",
            "            'modified': []",
            "        }",
            "        registered_ports = {port_id_one, port_id_two}",
            "        expected_ancillary = ovs_agent.PortInfo()",
            "",
            "        # port was removed and then added",
            "        expected_ports = ovs_agent.PortInfo(",
            "            added={port_id_one, port_id_two},",
            "            current={port_id_one, port_id_two},",
            "            re_added={port_id_one, port_id_two}",
            "        )",
            "        with mock.patch.object(ovs_lib.BaseOVS, \"port_exists\",",
            "                               return_value=True):",
            "            self._test_process_ports_events(events.copy(), registered_ports,",
            "                                            set(), expected_ports,",
            "                                            expected_ancillary)",
            "",
            "        # port was added and then removed",
            "        expected_ports = ovs_agent.PortInfo(removed={port_id_one, port_id_two})",
            "        with mock.patch.object(ovs_lib.BaseOVS, \"port_exists\",",
            "                               return_value=False):",
            "            self._test_process_ports_events(events.copy(), registered_ports,",
            "                                            set(), expected_ports,",
            "                                            expected_ancillary)",
            "",
            "    def test_process_ports_events_returns_current_for_unchanged_ports(self):",
            "        events = {'added': [], 'removed': [], 'modified': []}",
            "        registered_ports = {1, 3}",
            "        ancillary_ports = {2, 5}",
            "        expected_ports = ovs_agent.PortInfo(current=registered_ports)",
            "        expected_ancillary = ovs_agent.PortInfo(current=ancillary_ports)",
            "        self._test_process_ports_events(events, registered_ports,",
            "                                        ancillary_ports, expected_ports,",
            "                                        expected_ancillary)",
            "",
            "    def test_process_port_events_no_vif_changes_return_updated_port_only(self):",
            "        events = {'added': [], 'removed': [], 'modified': []}",
            "        registered_ports = {1, 2, 3}",
            "        updated_ports = {2}",
            "        expected_ports = ovs_agent.PortInfo(current=registered_ports,",
            "                                            updated={2})",
            "        expected_ancillary = ovs_agent.PortInfo()",
            "        self._test_process_ports_events(events, registered_ports,",
            "                                        set(), expected_ports,",
            "                                        expected_ancillary, updated_ports)",
            "",
            "    def test_process_port_events_ignores_removed_port_if_never_added(self):",
            "        events = {'added': [], 'modified': [],",
            "                  'removed': [{'name': 'port2', 'ofport': 2,",
            "                               'external_ids': {'attached-mac': 'test-mac'}}]}",
            "        registered_ports = {1}",
            "        expected_ports = ovs_agent.PortInfo(current=registered_ports)",
            "        expected_ancillary = ovs_agent.PortInfo()",
            "        devices_not_ready_yet = set()",
            "        with mock.patch.object(self.agent.int_br, 'portid_from_external_ids',",
            "                               side_effect=[2]), \\",
            "            mock.patch.object(self.agent, 'check_changed_vlans',",
            "                              return_value=set()):",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {",
            "                'added': set(), 'removed': set()}",
            "            ports_not_ready_yet = set()",
            "            actual = self.agent.process_ports_events(",
            "                events, registered_ports, set(), ports_not_ready_yet,",
            "                failed_devices, failed_ancillary_devices)",
            "            self.assertEqual(",
            "                (expected_ports, expected_ancillary, devices_not_ready_yet),",
            "                actual)",
            "",
            "    def test_process_port_events_port_not_ready_yet(self):",
            "        events = {'added': [{'name': 'port5', 'ofport': [],",
            "                  'external_ids': {'attached-mac': 'test-mac'}}],",
            "                  'removed': [], 'modified': []}",
            "        old_devices_not_ready = {'port4'}",
            "        registered_ports = {1, 2, 3}",
            "        expected_ports = ovs_agent.PortInfo(current={1, 2, 3, 4}, added={4},",
            "                                            removed=set())",
            "        self.agent.ancillary_brs = []",
            "        expected_ancillary = ovs_agent.PortInfo()",
            "        with mock.patch.object(self.agent.int_br, 'portid_from_external_ids',",
            "                               side_effect=[5, 4]), \\",
            "            mock.patch.object(self.agent, 'check_changed_vlans',",
            "                              return_value=set()), \\",
            "            mock.patch.object(self.agent.int_br, 'get_ports_attributes',",
            "                              return_value=[{'name': 'port4', 'ofport': 4,",
            "                                             'external_ids': {",
            "                                                 'attached-mac': 'mac4'}}]):",
            "            expected_devices_not_ready = {'port5'}",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {",
            "                'added': set(), 'removed': set()}",
            "            actual = self.agent.process_ports_events(",
            "                events, registered_ports, set(), old_devices_not_ready,",
            "                failed_devices, failed_ancillary_devices)",
            "            self.assertEqual(",
            "                (expected_ports, expected_ancillary,",
            "                 expected_devices_not_ready), actual)",
            "",
            "    def _test_process_port_events_with_updated_ports(self, updated_ports):",
            "        events = {'added': [{'name': 'port3', 'ofport': 3,",
            "                            'external_ids': {'attached-mac': 'test-mac'}},",
            "                            {'name': 'qg-port2', 'ofport': 6,",
            "                             'external_ids': {'attached-mac': 'test-mac'}}],",
            "                  'removed': [{'name': 'port2', 'ofport': 2,",
            "                               'external_ids': {'attached-mac': 'test-mac'}},",
            "                              {'name': 'qg-port1', 'ofport': 5,",
            "                               'external_ids': {'attached-mac': 'test-mac'}}],",
            "                  'modified': []}",
            "        registered_ports = {1, 2, 4}",
            "        ancillary_ports = {5, 8}",
            "        expected_ports = ovs_agent.PortInfo(current={1, 3, 4}, added={3},",
            "                                            removed={2}, updated=updated_ports)",
            "        expected_ancillary = ovs_agent.PortInfo(current={6, 8}, added={6},",
            "                                                removed={5})",
            "        ancillary_bridge = mock.Mock()",
            "        ancillary_bridge.get_vif_port_set.return_value = {5, 6, 8}",
            "        self.agent.ancillary_brs = [ancillary_bridge]",
            "        with mock.patch.object(self.agent.int_br, 'portid_from_external_ids',",
            "                              side_effect=[3, 6, 2, 5]), \\",
            "            mock.patch.object(self.agent, 'check_changed_vlans',",
            "                              return_value=set()):",
            "",
            "            devices_not_ready_yet = set()",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {",
            "                'added': set(), 'removed': set()}",
            "            actual = self.agent.process_ports_events(",
            "                events, registered_ports, ancillary_ports,",
            "                devices_not_ready_yet, failed_devices,",
            "                failed_ancillary_devices, updated_ports)",
            "            self.assertEqual(",
            "                (expected_ports, expected_ancillary, devices_not_ready_yet),",
            "                actual)",
            "",
            "    def test_process_port_events_returns_port_changes(self):",
            "        self._test_process_port_events_with_updated_ports(set())",
            "",
            "    def test_process_port_events_finds_known_updated_ports(self):",
            "        self._test_process_port_events_with_updated_ports({4})",
            "",
            "    def test_process_port_events_ignores_unknown_updated_ports(self):",
            "        # the port '10' was not seen on current ports. Hence it has either",
            "        # never been wired or already removed and should be ignored",
            "        self._test_process_port_events_with_updated_ports({4, 10})",
            "",
            "    def test_process_port_events_ignores_updated_port_if_removed(self):",
            "        self._test_process_port_events_with_updated_ports({4, 5})",
            "",
            "    def test_update_ports_returns_changed_vlan(self):",
            "        br = self.br_int_cls('br-int')",
            "        mac = \"ca:fe:de:ad:be:ef\"",
            "        port = ovs_lib.VifPort(1, 1, 1, mac, br)",
            "        self.agent.vlan_manager.add(",
            "            '1', 1, '1', None, 1, {port.vif_id: port})",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        port_tags_dict = {1: []}",
            "        expected = ovs_agent.PortInfo(added={3}, current=vif_port_set,",
            "                                      removed={2}, updated={1})",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True), \\",
            "                mock.patch.object(self.agent.plugin_rpc,",
            "                                  'update_device_list') as upd_l:",
            "            actual = self.mock_scan_ports(",
            "                vif_port_set, registered_ports, port_tags_dict=port_tags_dict)",
            "        self.assertEqual(expected, actual)",
            "        upd_l.assert_called_once_with(mock.ANY, [], set([1]),",
            "                                      self.agent.agent_id,",
            "                                      self.agent.conf.host)",
            "",
            "    def test_update_retries_map_and_remove_devs_not_to_retry(self):",
            "        failed_devices_retries_map = {",
            "            'device_not_to_retry': constants.MAX_DEVICE_RETRIES,",
            "            'device_to_retry': 2,",
            "            'ancillary_not_to_retry': constants.MAX_DEVICE_RETRIES,",
            "            'ancillary_to_retry': 1}",
            "        failed_devices = {",
            "            'added': set(['device_not_to_retry']),",
            "            'removed': set(['device_to_retry', 'new_device'])}",
            "        failed_ancillary_devices = {'added': set(['ancillary_to_retry']),",
            "                                    'removed': set(['ancillary_not_to_retry'])}",
            "        expected_failed_devices_retries_map = {",
            "            'device_to_retry': 3, 'new_device': 1, 'ancillary_to_retry': 2}",
            "        (new_failed_devices_retries_map, devices_not_to_retry,",
            "         ancillary_devices_not_t_retry) = self.agent._get_devices_not_to_retry(",
            "            failed_devices, failed_ancillary_devices,",
            "            failed_devices_retries_map)",
            "        self.agent._remove_devices_not_to_retry(",
            "            failed_devices, failed_ancillary_devices, devices_not_to_retry,",
            "            ancillary_devices_not_t_retry)",
            "        self.assertIn('device_to_retry', failed_devices['removed'])",
            "        self.assertNotIn('device_not_to_retry', failed_devices['added'])",
            "        self.assertEqual(",
            "            expected_failed_devices_retries_map,",
            "            new_failed_devices_retries_map)",
            "",
            "    def test_add_port_tag_info(self):",
            "        lvm = mock.Mock()",
            "        lvm.vlan = 1",
            "        self.agent.vlan_manager.mapping[\"net1\"] = lvm",
            "        ovs_db_list = [{'name': 'tap1',",
            "                        'tag': [],",
            "                        'other_config': {'segmentation_id': '1'}},",
            "                       {'name': 'tap2',",
            "                        'tag': [],",
            "                        'other_config': {}},",
            "                       {'name': 'tap3',",
            "                        'tag': [],",
            "                        'other_config': None}]",
            "        vif_port1 = mock.Mock()",
            "        vif_port1.port_name = 'tap1'",
            "        vif_port2 = mock.Mock()",
            "        vif_port2.port_name = 'tap2'",
            "        vif_port3 = mock.Mock()",
            "        vif_port3.port_name = 'tap3'",
            "        port_details = [",
            "            {'network_id': 'net1', 'vif_port': vif_port1},",
            "            {'network_id': 'net1', 'vif_port': vif_port2},",
            "            {'network_id': 'net1', 'vif_port': vif_port3}]",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list",
            "            self.agent._add_port_tag_info(port_details)",
            "            set_db_attribute_calls = \\",
            "                [mock.call.set_db_attribute(\"Port\", \"tap1\",",
            "                    \"other_config\", {\"segmentation_id\": \"1\", \"tag\": \"1\"}),",
            "                 mock.call.set_db_attribute(\"Port\", \"tap2\",",
            "                    \"other_config\", {\"tag\": \"1\"}),",
            "                 mock.call.set_db_attribute(\"Port\", \"tap3\",",
            "                    \"other_config\", {\"tag\": \"1\"})]",
            "            int_br.assert_has_calls(set_db_attribute_calls, any_order=True)",
            "",
            "    def test_add_port_tag_info_with_tagged_ports(self):",
            "        lvm = mock.Mock()",
            "        lvm.vlan = 1",
            "        self.agent.vlan_manager.mapping[\"net1\"] = lvm",
            "        ovs_db_list1 = [{'name': 'tap1',",
            "                         'tag': 1,",
            "                         'other_config': {'segmentation_id': '1', 'tag': '1'}}]",
            "        ovs_db_list2 = [{'name': 'tap2',",
            "                         'tag': 2,",
            "                         'other_config': {'segmentation_id': '1', 'tag': '1'}},",
            "                        {'name': 'tap3',",
            "                         'tag': 1,",
            "                         'other_config': {'segmentation_id': '2', 'tag': '2'}}]",
            "        vif_port1 = mock.Mock()",
            "        vif_port1.port_name = 'tap1'",
            "        vif_port2 = mock.Mock()",
            "        vif_port2.port_name = 'tap2'",
            "        vif_port2.ofport = 7",
            "        vif_port3 = mock.Mock()",
            "        vif_port3.port_name = 'tap3'",
            "        vif_port3.ofport = 8",
            "        port_details1 = [{'network_id': 'net1', 'vif_port': vif_port1}]",
            "        port_details2 = [{'network_id': 'net1', 'vif_port': vif_port2},",
            "                         {'network_id': 'net1', 'vif_port': vif_port3}]",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list1",
            "            self.agent._add_port_tag_info(port_details1)",
            "            int_br.set_db_attribute.assert_not_called()",
            "            # Reset mock to check port with changed tag",
            "            int_br.reset_mock()",
            "            int_br.get_ports_attributes.return_value = ovs_db_list2",
            "            self.agent._add_port_tag_info(port_details2)",
            "            expected_calls = \\",
            "                [mock.call.set_db_attribute(\"Port\", \"tap2\",",
            "                    \"other_config\", {'segmentation_id': '1', 'tag': '1'}),",
            "                 mock.call.uninstall_flows(in_port=7),",
            "                 mock.call.set_db_attribute(\"Port\", \"tap3\",",
            "                     \"other_config\", {'segmentation_id': '2', 'tag': '1'}),",
            "                 mock.call.uninstall_flows(in_port=8)]",
            "            int_br.assert_has_calls(expected_calls)",
            "",
            "    def test_bind_devices(self):",
            "        devices_up = ['tap1']",
            "        devices_down = ['tap2']",
            "        self.agent.vlan_manager.mapping[\"net1\"] = mock.Mock()",
            "        ovs_db_list = [{'name': 'tap1', 'tag': []},",
            "                       {'name': 'tap2', 'tag': []}]",
            "        vif_port1 = mock.Mock()",
            "        vif_port1.port_name = 'tap1'",
            "        vif_port2 = mock.Mock()",
            "        vif_port2.port_name = 'tap2'",
            "        port_details = [",
            "            {'network_id': 'net1', 'vif_port': vif_port1,",
            "             'device': devices_up[0],",
            "             'device_owner': 'network:dhcp',",
            "             'admin_state_up': True},",
            "            {'network_id': 'net1', 'vif_port': vif_port2,",
            "             'device': devices_down[0],",
            "             'device_owner': 'network:dhcp',",
            "             'admin_state_up': False}]",
            "        with mock.patch.object(",
            "            self.agent.plugin_rpc, 'update_device_list',",
            "            return_value={'devices_up': devices_up,",
            "                          'devices_down': devices_down,",
            "                          'failed_devices_up': [],",
            "                          'failed_devices_down': []}) as update_devices, \\",
            "                mock.patch.object(self.agent,",
            "                                  'int_br') as int_br:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list",
            "            self.agent._bind_devices(port_details)",
            "            update_devices.assert_called_once_with(mock.ANY, devices_up,",
            "                                                   devices_down,",
            "                                                   mock.ANY, mock.ANY,",
            "                                                   refresh_tunnels=True)",
            "",
            "    def _test_bind_devices_sets_refresh_tunnels(self, tun_ofports, expected):",
            "        self.agent.iter_num = 3",
            "        self.agent.prevent_arp_spoofing = False",
            "        self.agent.vlan_manager.add('fake_network', 1,",
            "                                    n_const.TYPE_VXLAN, None, 1)",
            "        ovs_db_list = [{'name': 'fake_device', 'tag': []}]",
            "        self.agent.vlan_manager.get('fake_network').tun_ofports = tun_ofports",
            "        vif_port = mock.Mock()",
            "        vif_port.port_name = 'fake_device'",
            "        vif_port.ofport = 1",
            "        need_binding_ports = [{'network_id': 'fake_network',",
            "                               'vif_port': vif_port,",
            "                               'device': 'fake_device',",
            "                               'admin_state_up': True}]",
            "        with mock.patch.object(",
            "            self.agent.plugin_rpc, 'update_device_list',",
            "            return_value={'devices_up': [],",
            "                          'devices_down': [],",
            "                          'failed_devices_up': [],",
            "                          'failed_devices_down': []}) as update_devices, \\",
            "                mock.patch.object(self.agent,",
            "                                  'int_br') as int_br:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list",
            "            self.agent._bind_devices(need_binding_ports)",
            "            update_devices.assert_called_once_with(mock.ANY, ['fake_device'],",
            "                                                   [], mock.ANY, mock.ANY,",
            "                                                   refresh_tunnels=expected)",
            "",
            "    def test_bind_devices_sets_refresh_tunnels_if_tunnels_missing(self):",
            "        self._test_bind_devices_sets_refresh_tunnels([], True)",
            "",
            "    def test_bind_devices_does_not_set_refresh_tunnels_if_tunnels_exist(self):",
            "        self._test_bind_devices_sets_refresh_tunnels([1, 2, 3], False)",
            "",
            "    def _test_arp_spoofing(self, enable_prevent_arp_spoofing):",
            "        self.agent.prevent_arp_spoofing = enable_prevent_arp_spoofing",
            "",
            "        ovs_db_list = [{'name': 'fake_device', 'tag': []}]",
            "        self.agent.vlan_manager.add('fake_network', 1, None, None, 1)",
            "        vif_port = mock.Mock()",
            "        vif_port.port_name = 'fake_device'",
            "        vif_port.ofport = 1",
            "        need_binding_ports = [{'network_id': 'fake_network',",
            "                               'vif_port': vif_port,",
            "                               'device': 'fake_device',",
            "                               'admin_state_up': True}]",
            "        with mock.patch.object(",
            "            self.agent.plugin_rpc, 'update_device_list',",
            "            return_value={'devices_up': [],",
            "                          'devices_down': [],",
            "                          'failed_devices_up': [],",
            "                          'failed_devices_down': []}), \\",
            "                mock.patch.object(self.agent,",
            "                                  'int_br') as int_br, \\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    'setup_arp_spoofing_protection') as setup_arp:",
            "            int_br.get_ports_attributes.return_value = ovs_db_list",
            "            self.agent._bind_devices(need_binding_ports)",
            "            self.assertEqual(enable_prevent_arp_spoofing, setup_arp.called)",
            "",
            "    def test_setup_arp_spoofing_protection_enable(self):",
            "        self._test_arp_spoofing(True)",
            "",
            "    def test_setup_arp_spoofing_protection_disabled(self):",
            "        self._test_arp_spoofing(False)",
            "",
            "    def _mock_treat_devices_added_updated(self, details, port, func_name):",
            "        \"\"\"Mock treat devices added or updated.",
            "",
            "        :param details: the details to return for the device",
            "        :param port: the port that get_vif_port_by_id should return",
            "        :param func_name: the function that should be called",
            "        :returns: whether the named function was called",
            "        \"\"\"",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [details],",
            "                                             'failed_devices': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={details['device']: port}),\\",
            "                mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={'devices_up': [],",
            "                                                'devices_down': details,",
            "                                                'failed_devices_up': [],",
            "                                                'failed_devices_down': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                    'get_port_tag_dict',",
            "                    return_value={}),\\",
            "                mock.patch.object(self.agent, func_name) as func:",
            "            skip_devs, _, need_bound_devices, _, _ = (",
            "                self.agent.treat_devices_added_or_updated([], False, set()))",
            "            # The function should not raise",
            "            self.assertFalse(skip_devs)",
            "            return func.called",
            "",
            "    def test_treat_devices_added_updated_no_active_binding(self):",
            "        details = {'device': 'id',",
            "                   n_const.NO_ACTIVE_BINDING: True}",
            "        port = mock.Mock()",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [details],",
            "                                             'failed_devices': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={details['device']: port}),\\",
            "                mock.patch.object(self.agent, 'port_dead') as func:",
            "            skip_devs, binding_no_activated_devices, _, _, _ = (",
            "                self.agent.treat_devices_added_or_updated([], False, set()))",
            "            self.assertFalse(skip_devs)",
            "            self.assertTrue(func.called)",
            "            self.assertIn('id', binding_no_activated_devices)",
            "",
            "    def test_treat_devices_added_updated_ignores_invalid_ofport(self):",
            "        port = mock.Mock()",
            "        port.ofport = -1",
            "        self.assertFalse(self._mock_treat_devices_added_updated(",
            "            mock.MagicMock(), port, 'port_dead'))",
            "",
            "    def test_treat_devices_added_updated_marks_unknown_port_as_dead(self):",
            "        port = mock.Mock()",
            "        port.ofport = 1",
            "        self.assertTrue(self._mock_treat_devices_added_updated(",
            "            mock.MagicMock(), port, 'port_dead'))",
            "",
            "    def test_treat_devices_added_does_not_process_missing_port(self):",
            "        with mock.patch.object(",
            "            self.agent.plugin_rpc,",
            "            'get_devices_details_list_and_failed_devices') as get_dev_fn,\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=None):",
            "            get_dev_fn.assert_not_called()",
            "",
            "    def test_treat_devices_added_updated_updates_known_port(self):",
            "        details = mock.MagicMock()",
            "        details.__contains__.side_effect = lambda x: True",
            "        self.assertTrue(self._mock_treat_devices_added_updated(",
            "            details, mock.Mock(), 'treat_vif_port'))",
            "",
            "    def test_treat_devices_added_updated_sends_vif_port_into_extension_manager(",
            "            self, *args):",
            "        details = mock.MagicMock()",
            "        details.__contains__.side_effect = lambda x: True",
            "        port = mock.MagicMock()",
            "",
            "        def fake_handle_port(context, port):",
            "            self.assertIn('vif_port', port)",
            "",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [details],",
            "                                             'failed_devices': []}),\\",
            "            mock.patch.object(self.agent.ext_manager,",
            "                              'handle_port', new=fake_handle_port),\\",
            "            mock.patch.object(self.agent.int_br,",
            "                              'get_vifs_by_ids',",
            "                              return_value={details['device']: port}),\\",
            "            mock.patch.object(self.agent, 'treat_vif_port',",
            "                              return_value=False):",
            "",
            "            self.agent.treat_devices_added_or_updated([], False, set())",
            "",
            "    def test_treat_devices_added_updated_skips_if_port_not_found(self):",
            "        dev_mock = mock.MagicMock()",
            "        dev_mock.__getitem__.return_value = 'the_skipped_one'",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [dev_mock],",
            "                                             'failed_devices': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                    'get_port_tag_dict',",
            "                    return_value={}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={}),\\",
            "                mock.patch.object(self.agent.ext_manager,",
            "                                  \"delete_port\") as ext_mgr_delete_port,\\",
            "                mock.patch.object(self.agent,",
            "                                  'treat_vif_port') as treat_vif_port:",
            "            skip_devs = self.agent.treat_devices_added_or_updated(",
            "                [], False, set())",
            "            # The function should return False for resync and no device",
            "            # processed",
            "            self.assertEqual((['the_skipped_one'], set(), [], set(), set()),",
            "                             skip_devs)",
            "            ext_mgr_delete_port.assert_called_once_with(",
            "                self.agent.context, {'port_id': 'the_skipped_one'})",
            "            treat_vif_port.assert_not_called()",
            "",
            "    def test_treat_devices_added_failed_devices(self):",
            "        dev_mock = 'the_failed_one'",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [],",
            "                                             'failed_devices': [dev_mock]}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={}),\\",
            "                mock.patch.object(self.agent,",
            "                                  'treat_vif_port') as treat_vif_port:",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            (_, _, _, failed_devices['added'], _) = (",
            "                self.agent.treat_devices_added_or_updated([], False, set()))",
            "            # The function should return False for resync and no device",
            "            # processed",
            "            self.assertEqual(set([dev_mock]), failed_devices.get('added'))",
            "            treat_vif_port.assert_not_called()",
            "",
            "    def test_treat_devices_added_updated_put_port_down(self):",
            "        fake_details_dict = {'admin_state_up': False,",
            "                             'port_id': 'xxx',",
            "                             'device': 'xxx',",
            "                             'network_id': 'yyy',",
            "                             'physical_network': 'foo',",
            "                             'segmentation_id': 'bar',",
            "                             'network_type': 'baz',",
            "                             'fixed_ips': [{'subnet_id': 'my-subnet-uuid',",
            "                                            'ip_address': '1.1.1.1'}],",
            "                             'device_owner': DEVICE_OWNER_COMPUTE",
            "                             }",
            "",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'get_devices_details_list_and_failed_devices',",
            "                               return_value={'devices': [fake_details_dict],",
            "                                             'failed_devices': []}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vifs_by_ids',",
            "                                  return_value={'xxx': mock.MagicMock()}),\\",
            "                mock.patch.object(self.agent.int_br, 'get_port_tag_dict',",
            "                                  return_value={}),\\",
            "                mock.patch.object(self.agent,",
            "                                  'treat_vif_port') as treat_vif_port:",
            "            skip_devs, _, need_bound_devices, _, _ = (",
            "                self.agent.treat_devices_added_or_updated([], False, set()))",
            "            # The function should return False for resync",
            "            self.assertFalse(skip_devs)",
            "            self.assertTrue(treat_vif_port.called)",
            "",
            "    def _mock_treat_devices_removed(self, port_exists):",
            "        details = dict(exists=port_exists)",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'update_device_list',",
            "                               return_value={'devices_up': [],",
            "                                             'devices_down': details,",
            "                                             'failed_devices_up': [],",
            "                                             'failed_devices_down': []}):",
            "            with mock.patch.object(self.agent, 'port_unbound') as port_unbound:",
            "                with mock.patch.object(self.agent.int_br,",
            "                                       'get_vif_port_by_id',",
            "                                       return_value=None):",
            "                    self.assertFalse(self.agent.treat_devices_removed([{}]))",
            "        self.assertTrue(port_unbound.called)",
            "",
            "    def test_treat_devices_removed_unbinds_port(self):",
            "        self._mock_treat_devices_removed(True)",
            "",
            "    def test_treat_devices_removed_ignores_missing_port(self):",
            "        self._mock_treat_devices_removed(False)",
            "",
            "    def test_treat_devices_removed_failed_devices(self):",
            "        dev_mock = 'the_failed_one'",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'update_device_list',",
            "                               return_value={'devices_up': [],",
            "                                             'devices_down': [],",
            "                                             'failed_devices_up': [],",
            "                                             'failed_devices_down': [",
            "                                                 dev_mock]}):",
            "            with mock.patch.object(self.agent.int_br,",
            "                                   'get_vif_port_by_id',",
            "                                   return_value=None):",
            "                failed_devices = {'added': set(), 'removed': set()}",
            "                failed_devices['removed'] = \\",
            "                    self.agent.treat_devices_removed([{}])",
            "                self.assertEqual(set([dev_mock]),",
            "                                 failed_devices.get('removed'))",
            "",
            "    def test_treat_devices_removed_ext_delete_port(self):",
            "        port_id = 'fake-id'",
            "",
            "        m_delete = mock.patch.object(self.agent.ext_manager, 'delete_port')",
            "        m_rpc = mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={'devices_up': [],",
            "                                                'devices_down': [],",
            "                                                'failed_devices_up': [],",
            "                                                'failed_devices_down': []})",
            "        m_unbound = mock.patch.object(self.agent, 'port_unbound')",
            "        with m_delete as delete, m_rpc, m_unbound:",
            "            with mock.patch.object(self.agent.int_br,",
            "                                   'get_vif_port_by_id',",
            "                                   return_value=None):",
            "                self.agent.treat_devices_removed([port_id])",
            "                delete.assert_called_with(mock.ANY, {'port_id': port_id})",
            "",
            "    def test_treat_vif_port_shut_down_port(self):",
            "        details = mock.MagicMock()",
            "        vif_port = type('vif_port', (object,), {",
            "            \"vif_id\": \"12\",",
            "            \"iface-id\": \"407a79e0-e0be-4b7d-92a6-513b2161011b\",",
            "            \"vif_mac\": \"fa:16:3e:68:46:7b\",",
            "            \"port_name\": \"qr-407a79e0-e0\",",
            "            \"ofport\": -1,",
            "            \"bridge_name\": \"br-int\"})",
            "        with mock.patch.object(",
            "                self.agent.plugin_rpc, 'update_device_down'",
            "        ) as update_device_down, mock.patch.object(",
            "            self.agent, \"port_dead\"",
            "        ) as port_dead:",
            "            port_needs_binding = self.agent.treat_vif_port(",
            "                vif_port, details['port_id'],",
            "                details['network_id'],",
            "                details['network_type'],",
            "                details['physical_network'],",
            "                details['segmentation_id'],",
            "                False,",
            "                details['fixed_ips'],",
            "                details['device_owner'], False)",
            "        self.assertFalse(port_needs_binding)",
            "        port_dead.assert_called_once_with(vif_port)",
            "        update_device_down.assert_called_once_with(",
            "            self.agent.context, details['port_id'], self.agent.agent_id,",
            "            self.agent.conf.host)",
            "",
            "    def test_bind_port_with_missing_network(self):",
            "        vif_port = mock.Mock()",
            "        vif_port.name.return_value = 'port'",
            "        self.agent._bind_devices([{'network_id': 'non-existent',",
            "                                   'vif_port': vif_port}])",
            "",
            "    def _test_process_network_ports(self, port_info, skipped_devices=None,",
            "                                    binding_no_activated_devices=None):",
            "        failed_devices = {'added': set(), 'removed': set()}",
            "        skipped_devices = skipped_devices or []",
            "        binding_no_activated_devices = binding_no_activated_devices or set()",
            "        added_devices = port_info.get('added', set())",
            "        with mock.patch.object(self.agent.sg_agent,",
            "                               \"setup_port_filters\") as setup_port_filters,\\",
            "                mock.patch.object(",
            "                    self.agent, \"treat_devices_added_or_updated\",",
            "                    return_value=(",
            "                        skipped_devices, binding_no_activated_devices, [],",
            "                        failed_devices['added'],",
            "                        set())) as device_added_updated,\\",
            "                mock.patch.object(self.agent.int_br, \"get_ports_attributes\",",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent,",
            "                                  \"treat_devices_removed\",",
            "                                  return_value=(",
            "                                      failed_devices[",
            "                                          'removed'])) as device_removed,\\",
            "                mock.patch.object(self.agent,",
            "                                  \"treat_devices_skipped\",",
            "                                  return_value=(",
            "                                      skipped_devices)) as device_skipped:",
            "            self.assertEqual(",
            "                failed_devices,",
            "                self.agent.process_network_ports(port_info, False))",
            "            setup_port_filters.assert_called_once_with(",
            "                (added_devices - set(skipped_devices) -",
            "                    binding_no_activated_devices),",
            "                port_info.get('updated', set()))",
            "            devices_added_updated = (added_devices |",
            "                                     port_info.get('updated', set()))",
            "            if devices_added_updated:",
            "                device_added_updated.assert_called_once_with(",
            "                    devices_added_updated, False, set())",
            "            if port_info.get('removed', set()):",
            "                device_removed.assert_called_once_with(port_info['removed'])",
            "            if skipped_devices:",
            "                device_skipped.assert_called_once_with(set(skipped_devices))",
            "",
            "    def test_process_network_ports(self):",
            "        self._test_process_network_ports(",
            "            {'current': set(['tap0']),",
            "             'removed': set(['eth0']),",
            "             'added': set(['eth1'])})",
            "",
            "    def test_process_network_port_with_updated_ports(self):",
            "        self._test_process_network_ports(",
            "            {'current': set(['tap0', 'tap1']),",
            "             'updated': set(['tap1', 'eth1']),",
            "             'removed': set(['eth0']),",
            "             'added': set(['eth1'])})",
            "",
            "    def test_process_network_port_with_skipped_ports(self):",
            "        port_info = {'current': set(['tap0', 'tap1']),",
            "                     'removed': set(['eth0']),",
            "                     'added': set(['eth1', 'eth2'])}",
            "        self._test_process_network_ports(port_info, skipped_devices=['eth1'])",
            "",
            "    def test_process_network_port_with_binding_no_activated_devices(self):",
            "        port_info = {'current': set(['tap0', 'tap1']),",
            "                     'removed': set(['eth0']),",
            "                     'added': set(['eth1', 'eth2', 'eth3'])}",
            "        self._test_process_network_ports(",
            "            port_info, skipped_devices=['eth1'],",
            "            binding_no_activated_devices=set(['eth3']))",
            "",
            "    def test_process_network_port_with_empty_port(self):",
            "        self._test_process_network_ports({})",
            "",
            "    @mock.patch.object(linux_utils, 'execute', return_value=False)",
            "    def test_hybrid_plug_flag_based_on_firewall(self, *args):",
            "        cfg.CONF.set_default(",
            "            'firewall_driver',",
            "            'neutron.agent.firewall.NoopFirewallDriver',",
            "            group='SECURITYGROUP')",
            "        agt = self._make_agent()",
            "        self.assertFalse(agt.agent_state['configurations']['ovs_hybrid_plug'])",
            "        cfg.CONF.set_default(",
            "            'firewall_driver',",
            "            'neutron.agent.linux.openvswitch_firewall.OVSFirewallDriver',",
            "            group='SECURITYGROUP')",
            "        with mock.patch('neutron.agent.linux.openvswitch_firewall.'",
            "                        'OVSFirewallDriver.initialize_bridge'):",
            "            agt = self._make_agent()",
            "        self.assertFalse(agt.agent_state['configurations']['ovs_hybrid_plug'])",
            "        cfg.CONF.set_default(",
            "            'firewall_driver',",
            "            'neutron.agent.linux.iptables_firewall.'",
            "            'OVSHybridIptablesFirewallDriver',",
            "            group='SECURITYGROUP')",
            "        with mock.patch('neutron.agent.linux.ip_conntrack.'",
            "                        'IpConntrackManager._populate_initial_zone_map'):",
            "            agt = self._make_agent()",
            "        self.assertTrue(agt.agent_state['configurations']['ovs_hybrid_plug'])",
            "",
            "    def test_report_state(self):",
            "        with mock.patch.object(self.agent.state_rpc,",
            "                               \"report_state\") as report_st:",
            "            self.agent.int_br_device_count = 5",
            "            self.systemd_notify.assert_not_called()",
            "            self.agent._report_state()",
            "            report_st.assert_called_with(self.agent.context,",
            "                                         self.agent.agent_state, True)",
            "            self.systemd_notify.assert_called_once_with()",
            "            self.systemd_notify.reset_mock()",
            "            # agent keeps sending \"start_flag\" while iter 0 not completed",
            "            self.assertIn(\"start_flag\", self.agent.agent_state)",
            "            self.assertEqual(",
            "                self.agent.agent_state[\"configurations\"][\"devices\"],",
            "                self.agent.int_br_device_count",
            "            )",
            "            self.agent._report_state()",
            "            report_st.assert_called_with(self.agent.context,",
            "                                         self.agent.agent_state, True)",
            "            self.systemd_notify.assert_not_called()",
            "",
            "    def test_report_state_fail(self):",
            "        with mock.patch.object(self.agent.state_rpc,",
            "                               \"report_state\") as report_st:",
            "            report_st.side_effect = Exception()",
            "            self.agent._report_state()",
            "            report_st.assert_called_with(self.agent.context,",
            "                                         self.agent.agent_state, True)",
            "            self.agent._report_state()",
            "            report_st.assert_called_with(self.agent.context,",
            "                                         self.agent.agent_state, True)",
            "            self.systemd_notify.assert_not_called()",
            "",
            "    def test_report_state_revived(self):",
            "        with mock.patch.object(self.agent.state_rpc,",
            "                               \"report_state\") as report_st:",
            "            report_st.return_value = agent_consts.AGENT_REVIVED",
            "            self.agent._report_state()",
            "            self.assertTrue(self.agent.fullsync)",
            "",
            "    def test_port_update(self):",
            "        port_arg = {\"id\": TEST_PORT_ID1}",
            "        with mock.patch.object(self.agent.plugin_rpc.remote_resource_cache,",
            "                               \"get_resource_by_id\") as mocked_resource:",
            "            port = Port()",
            "            port['mac_address'] = netaddr.EUI(FAKE_MAC)",
            "            port['device_id'] = '0'",
            "            port_bind = PortBinding()",
            "            port_bind['host'] = 'host'",
            "            port_bind['vnic_type'] = 'normal'",
            "            port.bindings = [port_bind]",
            "            mocked_resource.return_value = port",
            "            self.agent.port_update(\"unused_context\",",
            "                                   port=port_arg,",
            "                                   network_type=\"vlan\",",
            "                                   segmentation_id=\"1\",",
            "                                   physical_network=\"physnet\")",
            "            self.assertEqual(set([TEST_PORT_ID1]), self.agent.updated_ports)",
            "            self.assertEqual([], self.agent.updated_smartnic_ports)",
            "",
            "    def test_port_update_smartnic(self):",
            "        cfg.CONF.set_default('baremetal_smartnic', True, group='AGENT')",
            "        port_arg = {\"id\": TEST_PORT_ID1}",
            "        with mock.patch.object(self.agent.plugin_rpc.remote_resource_cache,",
            "                               \"get_resource_by_id\") as mocked_resource:",
            "            port = Port()",
            "            port['id'] = 'd850ed99-5f46-47bc-8c06-86d9d519c46a'",
            "            port['mac_address'] = netaddr.EUI(FAKE_MAC)",
            "            port['device_id'] = '0'",
            "            bindings_data = PortBinding()",
            "            bindings_data['host'] = 'host'",
            "            bindings_data['vnic_type'] = portbindings.VNIC_SMARTNIC",
            "            bindings_data['vif_type'] = portbindings.VIF_TYPE_OVS",
            "            bindings_data['profile'] = {",
            "                'local_link_information': [{'port_id': 'rep_port'}]}",
            "            port.bindings = [bindings_data]",
            "            mocked_resource.return_value = port",
            "            self.agent.port_update(\"unused_context\",",
            "                                   port=port_arg)",
            "            expected_smartnic_port_data = {",
            "                'mac': port['mac_address'],",
            "                'vm_uuid': port['device_id'],",
            "                'vif_name': 'rep_port',",
            "                'iface_id': port['id'],",
            "                'vif_type': bindings_data['vif_type']",
            "            }",
            "            self.assertEqual({TEST_PORT_ID1}, self.agent.updated_ports)",
            "            self.assertEqual([expected_smartnic_port_data],",
            "                             self.agent.updated_smartnic_ports)",
            "",
            "    def test_port_update_unbound_smartnic_port(self):",
            "        cfg.CONF.set_default('baremetal_smartnic', True, group='AGENT')",
            "        port_arg = {\"id\": 'd850ed99-5f46-47bc-8c06-86d9d519c46a'}",
            "        vif_name = \"rep0-0\"",
            "        vif_id = port_arg[\"id\"]",
            "        vif_mac = FAKE_MAC",
            "        self.agent.current_smartnic_ports_map = {",
            "            vif_id: {",
            "                'vif_mac': vif_mac,",
            "                'vif_name': vif_name}}",
            "",
            "        with mock.patch.object(self.agent.plugin_rpc.remote_resource_cache,",
            "                               \"get_resource_by_id\") as mocked_resource:",
            "            port = Port()",
            "            port['id'] = port_arg[\"id\"]",
            "            port['mac_address'] = netaddr.EUI(FAKE_MAC)",
            "            port['device_id'] = '0'",
            "            bindings_data = PortBinding()",
            "            bindings_data['host'] = ''",
            "            bindings_data['vnic_type'] = portbindings.VNIC_SMARTNIC",
            "            bindings_data['vif_type'] = portbindings.VIF_TYPE_UNBOUND",
            "            bindings_data['profile'] = {}",
            "            port.bindings = [bindings_data]",
            "            mocked_resource.return_value = port",
            "            self.agent.port_update(\"unused_context\",",
            "                                   port=port_arg)",
            "            expected_smartnic_port_data = [{",
            "                'mac': port['mac_address'],",
            "                'vm_uuid': '',",
            "                'vif_name': 'rep0-0',",
            "                'iface_id': port['id'],",
            "                'vif_type': portbindings.VIF_TYPE_UNBOUND",
            "            }]",
            "            mocked_resource.assert_called_with(resources.PORT, port['id'])",
            "            self.assertEqual({port['id']}, self.agent.updated_ports)",
            "            self.assertEqual(expected_smartnic_port_data,",
            "                             self.agent.updated_smartnic_ports)",
            "",
            "    def test_port_update_unbound_smartnic_port_not_belong_to_the_agent(self):",
            "        cfg.CONF.set_default('baremetal_smartnic', True, group='AGENT')",
            "        port_arg = {\"id\": 'd850ed99-5f46-47bc-8c06-86d9d519c46a'}",
            "        vif_name = \"rep0-0\"",
            "        vif_id = 'd850ed99-5f46-47bc-8c06-86d9d519c46b'",
            "        vif_mac = FAKE_MAC",
            "        self.agent.current_smartnic_ports_map = {",
            "            vif_id: {",
            "                'vif_mac': vif_mac,",
            "                'vif_name': vif_name}}",
            "",
            "        with mock.patch.object(self.agent.plugin_rpc.remote_resource_cache,",
            "                               \"get_resource_by_id\") as mocked_resource:",
            "            port = Port()",
            "            port['id'] = port_arg[\"id\"]",
            "            port['mac_address'] = netaddr.EUI(FAKE_MAC)",
            "            port['device_id'] = '0'",
            "            bindings_data = PortBinding()",
            "            bindings_data['host'] = ''",
            "            bindings_data['vnic_type'] = portbindings.VNIC_SMARTNIC",
            "            bindings_data['vif_type'] = portbindings.VIF_TYPE_UNBOUND",
            "            bindings_data['profile'] = {}",
            "            port.bindings = [bindings_data]",
            "            mocked_resource.return_value = port",
            "            self.agent.port_update(\"unused_context\",",
            "                                   port=port_arg)",
            "            mocked_resource.assert_called_with(resources.PORT, port['id'])",
            "            self.assertEqual({port['id']}, self.agent.updated_ports)",
            "            self.assertEqual([], self.agent.updated_smartnic_ports)",
            "",
            "    def test_port_delete_after_update(self):",
            "        \"\"\"Make sure a port is not marked for delete and update.\"\"\"",
            "        port = {'id': TEST_PORT_ID1}",
            "",
            "        self.agent.port_update(context=None, port=port)",
            "        self.agent.port_delete(context=None, port_id=port['id'])",
            "        self.assertEqual(set(), self.agent.updated_ports)",
            "        self.assertEqual(set([port['id']]), self.agent.deleted_ports)",
            "",
            "    def test_process_deleted_ports_cleans_network_ports(self):",
            "        self.agent._update_port_network(TEST_PORT_ID1, TEST_NETWORK_ID1)",
            "        self.agent.port_delete(context=None, port_id=TEST_PORT_ID1)",
            "        self.agent.sg_agent = mock.Mock()",
            "        self.agent.int_br = mock.Mock()",
            "",
            "        @contextlib.contextmanager",
            "        def bridge_deferred(*args, **kwargs):",
            "            yield",
            "",
            "        self.agent.int_br.deferred = mock.Mock(side_effect=bridge_deferred)",
            "        self.agent.process_deleted_ports(port_info={})",
            "        self.assertEqual(set(), self.agent.network_ports[TEST_NETWORK_ID1])",
            "",
            "    def test_network_update(self):",
            "        \"\"\"Network update marks port for update. \"\"\"",
            "        network = {'id': TEST_NETWORK_ID1}",
            "        port = {'id': TEST_PORT_ID1, 'network_id': network['id']}",
            "",
            "        self.agent._update_port_network(port['id'], port['network_id'])",
            "        with mock.patch.object(self.agent.plugin_rpc, 'get_network_details'), \\",
            "                mock.patch.object(self.agent,",
            "                                  '_update_network_segmentation_id'):",
            "            self.agent.network_update(context=None, network=network)",
            "        self.assertEqual(set([port['id']]), self.agent.updated_ports)",
            "",
            "    def test_network_update_outoforder(self):",
            "        \"\"\"Network update arrives later than port_delete.",
            "",
            "        But the main agent loop still didn't process the ports,",
            "        so we ensure the port is not marked for update.",
            "        \"\"\"",
            "        network = {'id': TEST_NETWORK_ID1}",
            "        port = {'id': TEST_PORT_ID1, 'network_id': network['id']}",
            "",
            "        self.agent._update_port_network(port['id'], port['network_id'])",
            "        self.agent.port_delete(context=None, port_id=port['id'])",
            "        with mock.patch.object(self.agent.plugin_rpc, 'get_network_details'), \\",
            "                mock.patch.object(self.agent,",
            "                                  '_update_network_segmentation_id'):",
            "            self.agent.network_update(context=None, network=network)",
            "        self.assertEqual(set(), self.agent.updated_ports)",
            "",
            "    def test_update_port_network(self):",
            "        \"\"\"Ensure ports are associated and moved across networks correctly.\"\"\"",
            "        self.agent._update_port_network(TEST_PORT_ID1, TEST_NETWORK_ID1)",
            "        self.agent._update_port_network(TEST_PORT_ID2, TEST_NETWORK_ID1)",
            "        self.agent._update_port_network(TEST_PORT_ID3, TEST_NETWORK_ID2)",
            "        self.agent._update_port_network(TEST_PORT_ID1, TEST_NETWORK_ID2)",
            "",
            "        self.assertEqual(set([TEST_PORT_ID2]),",
            "                         self.agent.network_ports[TEST_NETWORK_ID1])",
            "        self.assertEqual(set([TEST_PORT_ID1, TEST_PORT_ID3]),",
            "                         self.agent.network_ports[TEST_NETWORK_ID2])",
            "",
            "    def test_port_delete(self):",
            "        vif = FakeVif()",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.get_vif_by_port_id.return_value = vif.port_name",
            "            int_br.get_vif_port_by_id.return_value = vif",
            "            self.agent.port_delete(\"unused_context\",",
            "                                   port_id='id')",
            "            self.agent.process_deleted_ports(port_info={})",
            "            # the main things we care about are that it gets put in the",
            "            # dead vlan and gets blocked",
            "            int_br.set_db_attribute.assert_any_call(",
            "                'Port', vif.port_name, 'tag', constants.DEAD_VLAN_TAG,",
            "                log_errors=False)",
            "            int_br.drop_port.assert_called_once_with(in_port=vif.ofport)",
            "",
            "    def test_port_delete_removed_port(self):",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            self.agent.port_delete(\"unused_context\",",
            "                                   port_id='id')",
            "            # if it was removed from the bridge, we shouldn't be processing it",
            "            self.agent.process_deleted_ports(port_info={'removed': {'id', }})",
            "            int_br.set_db_attribute.assert_not_called()",
            "            int_br.drop_port.assert_not_called()",
            "",
            "    def test_binding_deactivate_not_for_host(self):",
            "        self.agent.binding_deactivate('unused_context', port_id='id',",
            "                                      host='other_host')",
            "        self.assertEqual(set(), self.agent.deactivated_bindings)",
            "",
            "    def test_binding_deactivate(self):",
            "        vif = FakeVif()",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            int_br.get_vif_port_by_id.return_value = vif",
            "            self.agent.binding_deactivate('unused_context', port_id='id',",
            "                                          host='host')",
            "            self.assertEqual(set(['id']), self.agent.deactivated_bindings)",
            "            self.agent.process_deactivated_bindings(port_info={})",
            "            int_br.get_vif_port_by_id.assert_called_once_with('id')",
            "            int_br.delete_port.assert_called_once_with(vif.port_name)",
            "            self.assertEqual(set(), self.agent.deactivated_bindings)",
            "",
            "    def test_binding_deactivate_removed_port(self):",
            "        with mock.patch.object(self.agent, 'int_br') as int_br:",
            "            self.agent.binding_deactivate('unused_context', port_id='id',",
            "                                          host='host')",
            "            self.assertEqual(set(['id']), self.agent.deactivated_bindings)",
            "            self.agent.process_deactivated_bindings(",
            "                port_info={'removed': {'id', }})",
            "            int_br.get_vif_port_by_id.assert_not_called()",
            "            int_br.delete_port.assert_not_called()",
            "            self.assertEqual(set(), self.agent.deactivated_bindings)",
            "",
            "    def test_binding_activate(self):",
            "        self.agent.binding_activate('context', port_id='id', host='host')",
            "        self.assertIn('id', self.agent.activated_bindings)",
            "",
            "    def test_binding_activate_not_for_host(self):",
            "        self.agent.binding_activate('context', port_id='id', host='other-host')",
            "        self.assertEqual(set(), self.agent.activated_bindings)",
            "",
            "    def test_process_activated_bindings(self):",
            "        port_info = {}",
            "        port_info['added'] = set(['added_port_id'])",
            "        port_info['current'] = set(['activated_port_id'])",
            "        self.agent.process_activated_bindings(port_info,",
            "                                              set(['activated_port_id']))",
            "        self.assertIn('added_port_id', port_info['added'])",
            "        self.assertIn('activated_port_id', port_info['added'])",
            "",
            "    def test_process_activated_bindings_activated_port_not_present(self):",
            "        port_info = {}",
            "        port_info['added'] = set(['added_port_id'])",
            "        port_info['current'] = set()",
            "        self.agent.process_activated_bindings(port_info,",
            "                                              set(['activated_port_id']))",
            "        self.assertIn('added_port_id', port_info['added'])",
            "        self.assertNotIn('activated_port_id', port_info['added'])",
            "",
            "    def _test_setup_physical_bridges(self, port_exists=False,",
            "                                     dvr_enabled=False):",
            "        self.agent.enable_distributed_routing = dvr_enabled",
            "        with mock.patch.object(ip_lib.IPDevice, \"exists\") as devex_fn,\\",
            "                mock.patch.object(sys, \"exit\"),\\",
            "                mock.patch.object(self.agent, 'br_phys_cls') as phys_br_cls,\\",
            "                mock.patch.object(self.agent, 'int_br') as int_br,\\",
            "                mock.patch.object(self.agent, '_check_bridge_datapath_id'),\\",
            "                mock.patch.object(ovs_lib.BaseOVS, 'get_bridges'):",
            "            devex_fn.return_value = True",
            "            parent = mock.MagicMock()",
            "            phys_br = phys_br_cls()",
            "            parent.attach_mock(phys_br_cls, 'phys_br_cls')",
            "            parent.attach_mock(phys_br, 'phys_br')",
            "            parent.attach_mock(int_br, 'int_br')",
            "            if port_exists:",
            "                phys_br.get_port_ofport.return_value = \"phy_ofport\"",
            "                int_br.get_port_ofport.return_value = \"int_ofport\"",
            "            else:",
            "                phys_br.add_patch_port.return_value = \"phy_ofport\"",
            "                int_br.add_patch_port.return_value = \"int_ofport\"",
            "            phys_br.port_exists.return_value = port_exists",
            "            int_br.port_exists.return_value = port_exists",
            "            self.agent.setup_physical_bridges({\"physnet1\": \"br-eth\"})",
            "            expected_calls = [",
            "                mock.call.phys_br_cls('br-eth'),",
            "                mock.call.phys_br.create(),",
            "                mock.call.phys_br.set_secure_mode(),",
            "                mock.call.phys_br.setup_controllers(mock.ANY),",
            "                mock.call.phys_br.setup_default_table(),",
            "                mock.call.int_br.db_get_val('Interface', 'int-br-eth',",
            "                                            'type', log_errors=False),",
            "                # Have to use __getattr__ here to avoid mock._Call.__eq__",
            "                # method being called",
            "                mock.call.int_br.db_get_val().__getattr__('__eq__')('veth'),",
            "                mock.call.int_br.port_exists('int-br-eth'),",
            "            ]",
            "            if port_exists:",
            "                expected_calls += [",
            "                    mock.call.int_br.get_port_ofport('int-br-eth'),",
            "                ]",
            "            else:",
            "                expected_calls += [",
            "                    mock.call.int_br.add_patch_port(",
            "                        'int-br-eth', constants.NONEXISTENT_PEER),",
            "                ]",
            "            expected_calls += [",
            "                mock.call.phys_br.port_exists('phy-br-eth'),",
            "            ]",
            "            if port_exists:",
            "                expected_calls += [",
            "                    mock.call.phys_br.get_port_ofport('phy-br-eth'),",
            "                ]",
            "            else:",
            "                expected_calls += [",
            "                    mock.call.phys_br.add_patch_port(",
            "                        'phy-br-eth', constants.NONEXISTENT_PEER),",
            "                ]",
            "            expected_calls += [",
            "                    mock.call.int_br.drop_port(in_port='int_ofport')",
            "            ]",
            "            if not dvr_enabled:",
            "                expected_calls += [",
            "                        mock.call.phys_br.drop_port(in_port='phy_ofport')",
            "                ]",
            "            expected_calls += [",
            "                mock.call.int_br.set_db_attribute('Interface', 'int-br-eth',",
            "                                                  'options',",
            "                                                  {'peer': 'phy-br-eth'}),",
            "                mock.call.phys_br.set_db_attribute('Interface', 'phy-br-eth',",
            "                                                   'options',",
            "                                                   {'peer': 'int-br-eth'}),",
            "            ]",
            "            parent.assert_has_calls(expected_calls)",
            "            self.assertEqual(\"int_ofport\",",
            "                             self.agent.int_ofports[\"physnet1\"])",
            "            self.assertEqual(\"phy_ofport\",",
            "                             self.agent.phys_ofports[\"physnet1\"])",
            "",
            "    def test_setup_physical_bridges(self):",
            "        self._test_setup_physical_bridges()",
            "",
            "    def test_setup_physical_bridges_port_exists(self):",
            "        self._test_setup_physical_bridges(port_exists=True)",
            "",
            "    def test_setup_physical_bridges_dvr_enabled(self):",
            "        self._test_setup_physical_bridges(dvr_enabled=True)",
            "",
            "    def test_setup_physical_bridges_using_veth_interconnection(self):",
            "        self.agent.use_veth_interconnection = True",
            "        with mock.patch.object(ip_lib.IPDevice, \"exists\") as devex_fn,\\",
            "                mock.patch.object(sys, \"exit\"),\\",
            "                mock.patch.object(utils, \"execute\") as utilsexec_fn,\\",
            "                mock.patch.object(self.agent, 'br_phys_cls') as phys_br_cls,\\",
            "                mock.patch.object(self.agent, 'int_br') as int_br,\\",
            "                mock.patch.object(self.agent, '_check_bridge_datapath_id'),\\",
            "                mock.patch.object(ip_lib.IPWrapper, \"add_veth\") as addveth_fn,\\",
            "                mock.patch.object(ip_lib.IpLinkCommand,",
            "                                  \"delete\") as linkdel_fn,\\",
            "                mock.patch.object(ip_lib.IpLinkCommand, \"set_up\"),\\",
            "                mock.patch.object(ip_lib.IpLinkCommand, \"set_mtu\"),\\",
            "                mock.patch.object(ovs_lib.BaseOVS, \"get_bridges\") as get_br_fn:",
            "            devex_fn.return_value = True",
            "            parent = mock.MagicMock()",
            "            parent.attach_mock(utilsexec_fn, 'utils_execute')",
            "            parent.attach_mock(linkdel_fn, 'link_delete')",
            "            parent.attach_mock(addveth_fn, 'add_veth')",
            "            addveth_fn.return_value = (ip_lib.IPDevice(\"int-br-eth1\"),",
            "                                       ip_lib.IPDevice(\"phy-br-eth1\"))",
            "            phys_br = phys_br_cls()",
            "            phys_br.add_port.return_value = \"phys_veth_ofport\"",
            "            int_br.add_port.return_value = \"int_veth_ofport\"",
            "            get_br_fn.return_value = [\"br-eth\"]",
            "            self.agent.setup_physical_bridges({\"physnet1\": \"br-eth\"})",
            "            expected_calls = [mock.call.link_delete(),",
            "                              mock.call.utils_execute(['udevadm',",
            "                                                       'settle',",
            "                                                       '--timeout=10']),",
            "                              mock.call.add_veth('int-br-eth',",
            "                                                 'phy-br-eth')]",
            "            parent.assert_has_calls(expected_calls, any_order=False)",
            "            self.assertEqual(\"int_veth_ofport\",",
            "                             self.agent.int_ofports[\"physnet1\"])",
            "            self.assertEqual(\"phys_veth_ofport\",",
            "                             self.agent.phys_ofports[\"physnet1\"])",
            "            int_br.add_port.assert_called_with(\"int-br-eth\")",
            "            phys_br.add_port.assert_called_with(\"phy-br-eth\")",
            "",
            "    def _test_setup_physical_bridges_change_from_veth_to_patch_conf(",
            "            self, port_exists=False):",
            "        with mock.patch.object(sys, \"exit\"),\\",
            "                mock.patch.object(self.agent, 'br_phys_cls') as phys_br_cls,\\",
            "                mock.patch.object(self.agent, 'int_br') as int_br,\\",
            "                mock.patch.object(self.agent.int_br, 'db_get_val',",
            "                                  return_value='veth'), \\",
            "                mock.patch.object(self.agent, '_check_bridge_datapath_id'), \\",
            "                mock.patch.object(ovs_lib.BaseOVS, 'get_bridges'):",
            "            phys_br = phys_br_cls()",
            "            parent = mock.MagicMock()",
            "            parent.attach_mock(phys_br_cls, 'phys_br_cls')",
            "            parent.attach_mock(phys_br, 'phys_br')",
            "            parent.attach_mock(int_br, 'int_br')",
            "            if port_exists:",
            "                phys_br.get_port_ofport.return_value = \"phy_ofport\"",
            "                int_br.get_port_ofport.return_value = \"int_ofport\"",
            "            else:",
            "                phys_br.add_patch_port.return_value = \"phy_ofport\"",
            "                int_br.add_patch_port.return_value = \"int_ofport\"",
            "            phys_br.port_exists.return_value = port_exists",
            "            int_br.port_exists.return_value = port_exists",
            "            self.agent.setup_physical_bridges({\"physnet1\": \"br-eth\"})",
            "            expected_calls = [",
            "                mock.call.phys_br_cls('br-eth'),",
            "                mock.call.phys_br.create(),",
            "                mock.call.phys_br.set_secure_mode(),",
            "                mock.call.phys_br.setup_controllers(mock.ANY),",
            "                mock.call.phys_br.setup_default_table(),",
            "                mock.call.int_br.delete_port('int-br-eth'),",
            "                mock.call.phys_br.delete_port('phy-br-eth'),",
            "                mock.call.int_br.port_exists('int-br-eth'),",
            "            ]",
            "            if port_exists:",
            "                expected_calls += [",
            "                    mock.call.int_br.get_port_ofport('int-br-eth'),",
            "                ]",
            "            else:",
            "                expected_calls += [",
            "                    mock.call.int_br.add_patch_port(",
            "                        'int-br-eth', constants.NONEXISTENT_PEER),",
            "                ]",
            "            expected_calls += [",
            "                mock.call.phys_br.port_exists('phy-br-eth'),",
            "            ]",
            "            if port_exists:",
            "                expected_calls += [",
            "                    mock.call.phys_br.get_port_ofport('phy-br-eth'),",
            "                ]",
            "            else:",
            "                expected_calls += [",
            "                    mock.call.phys_br.add_patch_port(",
            "                        'phy-br-eth', constants.NONEXISTENT_PEER),",
            "                ]",
            "            expected_calls += [",
            "                mock.call.int_br.drop_port(in_port='int_ofport'),",
            "                mock.call.phys_br.drop_port(in_port='phy_ofport'),",
            "                mock.call.int_br.set_db_attribute('Interface', 'int-br-eth',",
            "                                                  'options',",
            "                                                  {'peer': 'phy-br-eth'}),",
            "                mock.call.phys_br.set_db_attribute('Interface', 'phy-br-eth',",
            "                                                   'options',",
            "                                                   {'peer': 'int-br-eth'}),",
            "            ]",
            "            parent.assert_has_calls(expected_calls)",
            "            self.assertEqual(\"int_ofport\",",
            "                             self.agent.int_ofports[\"physnet1\"])",
            "            self.assertEqual(\"phy_ofport\",",
            "                             self.agent.phys_ofports[\"physnet1\"])",
            "",
            "    def test_setup_physical_bridges_change_from_veth_to_patch_conf(self):",
            "        self._test_setup_physical_bridges_change_from_veth_to_patch_conf()",
            "",
            "    def test_setup_physical_bridges_change_from_veth_to_patch_conf_port_exists(",
            "            self):",
            "        self._test_setup_physical_bridges_change_from_veth_to_patch_conf(",
            "            port_exists=True)",
            "",
            "    def test_setup_tunnel_br(self):",
            "        self.tun_br = mock.Mock()",
            "        with mock.patch.object(self.agent.int_br,",
            "                               \"add_patch_port\",",
            "                               return_value=1) as int_patch_port,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  \"add_patch_port\",",
            "                                  return_value=1) as tun_patch_port,\\",
            "                mock.patch.object(self.agent.tun_br, 'bridge_exists',",
            "                                  return_value=False),\\",
            "                mock.patch.object(self.agent.tun_br, 'create') as create_tun,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  'setup_controllers') as setup_controllers,\\",
            "                mock.patch.object(self.agent.tun_br, 'port_exists',",
            "                                  return_value=False),\\",
            "                mock.patch.object(self.agent.int_br, 'port_exists',",
            "                                  return_value=False),\\",
            "                mock.patch.object(sys, \"exit\"):",
            "            self.agent.setup_tunnel_br(None)",
            "            self.agent.setup_tunnel_br()",
            "            self.assertTrue(create_tun.called)",
            "            self.assertTrue(setup_controllers.called)",
            "            self.assertTrue(int_patch_port.called)",
            "            self.assertTrue(tun_patch_port.called)",
            "",
            "    def test_setup_tunnel_br_ports_exits_drop_flows(self):",
            "        cfg.CONF.set_override('drop_flows_on_start', True, 'AGENT')",
            "        with mock.patch.object(self.agent.tun_br, 'port_exists',",
            "                               return_value=True),\\",
            "                mock.patch.object(self.agent, 'tun_br'),\\",
            "                mock.patch.object(self.agent.int_br, 'port_exists',",
            "                                  return_value=True),\\",
            "                mock.patch.object(self.agent.tun_br, 'setup_controllers'),\\",
            "                mock.patch.object(self.agent, 'patch_tun_ofport', new=2),\\",
            "                mock.patch.object(self.agent, 'patch_int_ofport', new=2),\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  'uninstall_flows') as delete,\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  \"add_patch_port\") as int_patch_port,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  \"add_patch_port\") as tun_patch_port,\\",
            "                mock.patch.object(sys, \"exit\"):",
            "            self.agent.setup_tunnel_br(None)",
            "            self.agent.setup_tunnel_br()",
            "            int_patch_port.assert_not_called()",
            "            tun_patch_port.assert_not_called()",
            "            self.assertTrue(delete.called)",
            "",
            "    def test_setup_tunnel_port(self):",
            "        self.agent.tun_br = mock.Mock()",
            "        self.agent.l2_pop = False",
            "        self.agent.udp_vxlan_port = 8472",
            "        self.agent.tun_br_ofports['vxlan'] = {}",
            "        self.agent.local_ip = '2.3.4.5'",
            "        with mock.patch.object(self.agent.tun_br,",
            "                               \"add_tunnel_port\",",
            "                               return_value='6') as add_tun_port_fn,\\",
            "                mock.patch.object(self.agent.tun_br, \"add_flow\"):",
            "            self.agent._setup_tunnel_port(self.agent.tun_br, 'portname',",
            "                                          '1.2.3.4', 'vxlan')",
            "            self.assertTrue(add_tun_port_fn.called)",
            "",
            "    def test_port_unbound(self):",
            "        with mock.patch.object(self.agent, \"reclaim_local_vlan\") as reclvl_fn:",
            "            self.agent.enable_tunneling = True",
            "            lvm = mock.Mock()",
            "            lvm.network_type = \"gre\"",
            "            lvm.vif_ports = {\"vif1\": mock.Mock()}",
            "            self.agent.vlan_manager.mapping[\"netuid12345\"] = lvm",
            "            self.agent.port_unbound(\"vif1\", \"netuid12345\")",
            "            self.assertTrue(reclvl_fn.called)",
            "",
            "            lvm.vif_ports = {}",
            "            self.agent.port_unbound(\"vif1\", \"netuid12345\")",
            "            self.assertEqual(2, reclvl_fn.call_count)",
            "",
            "            lvm.vif_ports = {\"vif1\": mock.Mock()}",
            "            self.agent.port_unbound(\"vif3\", \"netuid12345\")",
            "            self.assertEqual(2, reclvl_fn.call_count)",
            "",
            "    def _prepare_l2_pop_ofports(self):",
            "        lvm1 = mock.Mock()",
            "        lvm1.network_type = 'gre'",
            "        lvm1.vlan = 'vlan1'",
            "        lvm1.segmentation_id = 'seg1'",
            "        lvm1.tun_ofports = set(['1'])",
            "        lvm2 = mock.Mock()",
            "        lvm2.network_type = 'gre'",
            "        lvm2.vlan = 'vlan2'",
            "        lvm2.segmentation_id = 'seg2'",
            "        lvm2.tun_ofports = set(['1', '2'])",
            "        self.agent.vlan_manager.mapping = {'net1': lvm1, 'net2': lvm2}",
            "        self.agent.tun_br_ofports = {'gre':",
            "                                     {'1.1.1.1': '1', '2.2.2.2': '2'}}",
            "        self.agent.arp_responder_enabled = True",
            "",
            "    def test_fdb_ignore_network(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net3': {}}",
            "        with mock.patch.object(self.agent.tun_br, 'add_flow') as add_flow_fn,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  'uninstall_flows') as del_flow_fn,\\",
            "                mock.patch.object(self.agent,",
            "                                  '_setup_tunnel_port') as add_tun_fn,\\",
            "                mock.patch.object(self.agent,",
            "                                  'cleanup_tunnel_port') as clean_tun_fn:",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            add_flow_fn.assert_not_called()",
            "            add_tun_fn.assert_not_called()",
            "            self.agent.fdb_remove(None, fdb_entry)",
            "            del_flow_fn.assert_not_called()",
            "            clean_tun_fn.assert_not_called()",
            "",
            "    def test_fdb_ignore_self(self):",
            "        self._prepare_l2_pop_ofports()",
            "        self.agent.local_ip = 'agent_ip'",
            "        fdb_entry = {'net2':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun2',",
            "                      'ports':",
            "                      {'agent_ip':",
            "                       [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1),",
            "                        n_const.FLOODING_ENTRY]}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            tun_br.add_port.assert_not_called()",
            "",
            "            self.agent.fdb_remove(None, fdb_entry)",
            "            tun_br.delete_port.assert_not_called()",
            "",
            "    def test_fdb_add_flows(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net1':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun1',",
            "                      'ports':",
            "                      {'2.2.2.2':",
            "                       [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1),",
            "                        n_const.FLOODING_ENTRY]}}}",
            "",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br,\\",
            "                mock.patch.object(self.agent,",
            "                                  '_setup_tunnel_port',",
            "                                  autospec=True) as add_tun_fn:",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            add_tun_fn.assert_not_called()",
            "            expected_calls = [",
            "                mock.call.install_arp_responder('vlan1', FAKE_IP1, FAKE_MAC),",
            "                mock.call.install_unicast_to_tun('vlan1', 'seg1', '2',",
            "                                                 FAKE_MAC),",
            "                mock.call.install_flood_to_tun('vlan1', 'seg1',",
            "                                               set(['1', '2'])),",
            "            ]",
            "            tun_br.assert_has_calls(expected_calls)",
            "",
            "    def test_fdb_del_flows(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net2':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun2',",
            "                      'ports':",
            "                      {'2.2.2.2':",
            "                       [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1),",
            "                        n_const.FLOODING_ENTRY]}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as br_tun:",
            "            self.agent.fdb_remove(None, fdb_entry)",
            "            expected_calls = [",
            "                mock.call.delete_arp_responder('vlan2', FAKE_IP1),",
            "                mock.call.delete_unicast_to_tun('vlan2', FAKE_MAC),",
            "                mock.call.install_flood_to_tun('vlan2', 'seg2', set(['1'])),",
            "                mock.call.delete_port('gre-02020202'),",
            "                mock.call.cleanup_tunnel_port('2'),",
            "            ]",
            "            br_tun.assert_has_calls(expected_calls)",
            "",
            "    def test_fdb_add_port(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net1':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun1',",
            "                      'ports': {'1.1.1.1': [l2pop_rpc.PortInfo(FAKE_MAC,",
            "                                                               FAKE_IP1)]}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br,\\",
            "                mock.patch.object(self.agent,",
            "                                  '_setup_tunnel_port') as add_tun_fn:",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            add_tun_fn.assert_not_called()",
            "            fdb_entry['net1']['ports']['10.10.10.10'] = [",
            "                l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1)]",
            "            self.agent.fdb_add(None, fdb_entry)",
            "            add_tun_fn.assert_called_with(",
            "                tun_br, 'gre-0a0a0a0a', '10.10.10.10', 'gre')",
            "",
            "    def test_fdb_del_port(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entry = {'net2':",
            "                     {'network_type': 'gre',",
            "                      'segment_id': 'tun2',",
            "                      'ports': {'2.2.2.2': [n_const.FLOODING_ENTRY]}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.fdb_remove(None, fdb_entry)",
            "            tun_br.delete_port.assert_called_once_with('gre-02020202')",
            "",
            "    def test_fdb_update_chg_ip(self):",
            "        self._prepare_l2_pop_ofports()",
            "        fdb_entries = {'chg_ip':",
            "                       {'net1':",
            "                        {'agent_ip':",
            "                         {'before': [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP1)],",
            "                          'after': [l2pop_rpc.PortInfo(FAKE_MAC, FAKE_IP2)]}}}}",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.fdb_update(None, fdb_entries)",
            "            tun_br.assert_has_calls([",
            "                mock.call.install_arp_responder('vlan1', FAKE_IP2, FAKE_MAC),",
            "                mock.call.delete_arp_responder('vlan1', FAKE_IP1)",
            "            ])",
            "",
            "    def test_del_fdb_flow_idempotency(self):",
            "        lvm = mock.Mock()",
            "        lvm.network_type = 'gre'",
            "        lvm.vlan = 'vlan1'",
            "        lvm.segmentation_id = 'seg1'",
            "        lvm.tun_ofports = set(['1', '2'])",
            "        with mock.patch.object(self.agent.tun_br, 'mod_flow') as mod_flow_fn,\\",
            "                mock.patch.object(self.agent.tun_br,",
            "                                  'uninstall_flows') as uninstall_flows_fn:",
            "            self.agent.del_fdb_flow(self.agent.tun_br, n_const.FLOODING_ENTRY,",
            "                                    '1.1.1.1', lvm, '3')",
            "            mod_flow_fn.assert_not_called()",
            "            uninstall_flows_fn.assert_not_called()",
            "",
            "    def test_recl_lv_port_to_preserve(self):",
            "        self._prepare_l2_pop_ofports()",
            "        self.agent.l2_pop = True",
            "        self.agent.enable_tunneling = True",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.reclaim_local_vlan('net1')",
            "            tun_br.cleanup_tunnel_port.assert_not_called()",
            "",
            "    def test_recl_lv_port_to_remove(self):",
            "        self._prepare_l2_pop_ofports()",
            "        self.agent.l2_pop = True",
            "        self.agent.enable_tunneling = True",
            "        with mock.patch.object(self.agent, 'tun_br', autospec=True) as tun_br:",
            "            self.agent.reclaim_local_vlan('net2')",
            "            tun_br.delete_port.assert_called_once_with('gre-02020202')",
            "",
            "    def _test_ext_br_recreated(self, setup_bridges_side_effect):",
            "        bridge_mappings = {'physnet0': 'br-ex0',",
            "                           'physnet1': 'br-ex1'}",
            "        ex_br_mocks = [mock.Mock(br_name='br-ex0'),",
            "                       mock.Mock(br_name='br-ex1')]",
            "        phys_bridges = {'physnet0': ex_br_mocks[0],",
            "                        'physnet1': ex_br_mocks[1]},",
            "        bridges_added = ['br-ex0']",
            "        expected_added_bridges = (",
            "            bridges_added if setup_bridges_side_effect else [])",
            "        with mock.patch.object(self.agent, 'check_ovs_status',",
            "                               return_value=constants.OVS_NORMAL), \\",
            "                mock.patch.object(self.agent, '_agent_has_updates',",
            "                                  side_effect=TypeError('loop exit')), \\",
            "                mock.patch.dict(self.agent.bridge_mappings, bridge_mappings,",
            "                                clear=True), \\",
            "                mock.patch.dict(self.agent.phys_brs, phys_bridges,",
            "                                clear=True), \\",
            "                mock.patch.object(self.agent, 'setup_physical_bridges') as \\",
            "                setup_physical_bridges, \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor') as \\",
            "                mock_idl_monitor:",
            "            mock_idl_monitor.bridges_added = bridges_added",
            "            setup_physical_bridges.side_effect = setup_bridges_side_effect",
            "            try:",
            "                self.agent.rpc_loop(polling_manager=mock.Mock())",
            "            except TypeError:",
            "                pass",
            "        # Setup bridges should be called once even if it will raise Runtime",
            "        # Error because there is raised TypeError in _agent_has_updates to stop",
            "        # agent after first loop iteration",
            "        setup_physical_bridges.assert_called_once_with({'physnet0': 'br-ex0'})",
            "        self.assertEqual(expected_added_bridges, self.agent.added_bridges)",
            "",
            "    def test_ext_br_recreated(self):",
            "        self._test_ext_br_recreated(setup_bridges_side_effect=None)",
            "",
            "    def test_ext_br_recreated_fail_setup_physical_bridge(self):",
            "        self._test_ext_br_recreated(setup_bridges_side_effect=RuntimeError)",
            "",
            "    def test_daemon_loop_uses_polling_manager(self):",
            "        ex_br_mock = mock.Mock(br_name=\"br-ex0\")",
            "        with mock.patch.object(polling, 'get_polling_manager') as \\",
            "                mock_get_pm, \\",
            "                mock.patch.object(self.agent, 'rpc_loop') as mock_loop, \\",
            "                mock.patch.dict(self.agent.phys_brs, {'physnet0': ex_br_mock},",
            "                                clear=True), \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor') as \\",
            "                mock_idl_monitor:",
            "            self.agent.daemon_loop()",
            "        mock_get_pm.assert_called_with(True,",
            "                                       constants.DEFAULT_OVSDBMON_RESPAWN)",
            "        mock_loop.assert_called_once_with(polling_manager=mock.ANY)",
            "        mock_idl_monitor.start_bridge_monitor.assert_called()",
            "",
            "    def test_setup_tunnel_port_invalid_ofport(self):",
            "        remote_ip = '1.2.3.4'",
            "        with mock.patch.object(",
            "            self.agent.tun_br,",
            "            'add_tunnel_port',",
            "            return_value=ovs_lib.INVALID_OFPORT) as add_tunnel_port_fn,\\",
            "                mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.local_ip = '1.2.3.4'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            add_tunnel_port_fn.assert_called_once_with(",
            "                'gre-1', remote_ip, self.agent.local_ip, n_const.TYPE_GRE,",
            "                self.agent.vxlan_udp_port, self.agent.dont_fragment,",
            "                self.agent.tunnel_csum, self.agent.tos)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Failed to set-up %(type)s tunnel port to %(ip)s\"),",
            "                {'type': n_const.TYPE_GRE, 'ip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_invalid_address_mismatch(self):",
            "        remote_ip = '2001:db8::2'",
            "        with mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.local_ip = '1.2.3.4'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"IP version mismatch, cannot create tunnel: \"",
            "                  \"local_ip=%(lip)s remote_ip=%(rip)s\"),",
            "                {'lip': self.agent.local_ip, 'rip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_invalid_netaddr_exception(self):",
            "        remote_ip = '2001:db8::2'",
            "        with mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.local_ip = '1.2.3.4.5'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Invalid local or remote IP, cannot create tunnel: \"",
            "                  \"local_ip=%(lip)s remote_ip=%(rip)s\"),",
            "                {'lip': self.agent.local_ip, 'rip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_error_negative_df_disabled(self):",
            "        remote_ip = '1.2.3.4'",
            "        with mock.patch.object(",
            "            self.agent.tun_br,",
            "            'add_tunnel_port',",
            "            return_value=ovs_lib.INVALID_OFPORT) as add_tunnel_port_fn,\\",
            "                mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.dont_fragment = False",
            "            self.agent.tunnel_csum = False",
            "            self.agent.local_ip = '2.3.4.5'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            add_tunnel_port_fn.assert_called_once_with(",
            "                'gre-1', remote_ip, self.agent.local_ip, n_const.TYPE_GRE,",
            "                self.agent.vxlan_udp_port, self.agent.dont_fragment,",
            "                self.agent.tunnel_csum, self.agent.tos)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Failed to set-up %(type)s tunnel port to %(ip)s\"),",
            "                {'type': n_const.TYPE_GRE, 'ip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_error_negative_tunnel_csum(self):",
            "        remote_ip = '1.2.3.4'",
            "        with mock.patch.object(",
            "            self.agent.tun_br,",
            "            'add_tunnel_port',",
            "            return_value=ovs_lib.INVALID_OFPORT) as add_tunnel_port_fn,\\",
            "                mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.dont_fragment = True",
            "            self.agent.tunnel_csum = True",
            "            self.agent.local_ip = '2.3.4.5'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            add_tunnel_port_fn.assert_called_once_with(",
            "                'gre-1', remote_ip, self.agent.local_ip, n_const.TYPE_GRE,",
            "                self.agent.vxlan_udp_port, self.agent.dont_fragment,",
            "                self.agent.tunnel_csum, self.agent.tos)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Failed to set-up %(type)s tunnel port to %(ip)s\"),",
            "                {'type': n_const.TYPE_GRE, 'ip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_setup_tunnel_port_error_negative_tos_inherit(self):",
            "        remote_ip = '1.2.3.4'",
            "        with mock.patch.object(",
            "            self.agent.tun_br,",
            "            'add_tunnel_port',",
            "            return_value=ovs_lib.INVALID_OFPORT) as add_tunnel_port_fn,\\",
            "                mock.patch.object(self.mod_agent.LOG, 'error') as log_error_fn:",
            "            self.agent.tos = 'inherit'",
            "            self.agent.local_ip = '2.3.4.5'",
            "            ofport = self.agent._setup_tunnel_port(",
            "                self.agent.tun_br, 'gre-1', remote_ip, n_const.TYPE_GRE)",
            "            add_tunnel_port_fn.assert_called_once_with(",
            "                'gre-1', remote_ip, self.agent.local_ip, n_const.TYPE_GRE,",
            "                self.agent.vxlan_udp_port, self.agent.dont_fragment,",
            "                self.agent.tunnel_csum, self.agent.tos)",
            "            log_error_fn.assert_called_once_with(",
            "                _(\"Failed to set-up %(type)s tunnel port to %(ip)s\"),",
            "                {'type': n_const.TYPE_GRE, 'ip': remote_ip})",
            "            self.assertEqual(0, ofport)",
            "",
            "    def test_tunnel_sync_with_ml2_plugin(self):",
            "        fake_tunnel_details = {'tunnels': [{'ip_address': '100.101.31.15'}]}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'tunnel_sync',",
            "                               return_value=fake_tunnel_details),\\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    '_setup_tunnel_port') as _setup_tunnel_port_fn,\\",
            "                mock.patch.object(self.agent,",
            "                                  'cleanup_stale_flows') as cleanup:",
            "            self.agent.tunnel_types = ['vxlan']",
            "            self.agent.tunnel_sync()",
            "            expected_calls = [mock.call(self.agent.tun_br, 'vxlan-64651f0f',",
            "                                        '100.101.31.15', 'vxlan')]",
            "            _setup_tunnel_port_fn.assert_has_calls(expected_calls)",
            "            cleanup.assert_not_called()",
            "",
            "    def test_tunnel_sync_invalid_ip_address(self):",
            "        fake_tunnel_details = {'tunnels': [{'ip_address': '300.300.300.300'},",
            "                                           {'ip_address': '100.100.100.100'}]}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'tunnel_sync',",
            "                               return_value=fake_tunnel_details),\\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    '_setup_tunnel_port') as _setup_tunnel_port_fn,\\",
            "                mock.patch.object(self.agent,",
            "                                  'cleanup_stale_flows') as cleanup:",
            "            self.agent.tunnel_types = ['vxlan']",
            "            self.agent.tunnel_sync()",
            "            _setup_tunnel_port_fn.assert_called_once_with(self.agent.tun_br,",
            "                                                          'vxlan-64646464',",
            "                                                          '100.100.100.100',",
            "                                                          'vxlan')",
            "            cleanup.assert_not_called()",
            "",
            "    def test_tunnel_sync_setup_tunnel_flood_flow_once(self):",
            "        fake_tunnel_details = {'tunnels': [{'ip_address': '200.200.200.200'},",
            "                                           {'ip_address': '100.100.100.100'}]}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               'tunnel_sync',",
            "                               return_value=fake_tunnel_details),\\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    '_setup_tunnel_port') as _setup_tunnel_port_fn,\\",
            "                mock.patch.object(",
            "                    self.agent,",
            "                    '_setup_tunnel_flood_flow') as _setup_tunnel_flood_flow:",
            "            self.agent.tunnel_types = ['vxlan']",
            "            self.agent.tunnel_sync()",
            "            expected_calls = [mock.call(self.agent.tun_br, 'vxlan-c8c8c8c8',",
            "                                        '200.200.200.200', 'vxlan'),",
            "                              mock.call(self.agent.tun_br, 'vxlan-64646464',",
            "                                        '100.100.100.100', 'vxlan')]",
            "            _setup_tunnel_port_fn.assert_has_calls(expected_calls)",
            "            _setup_tunnel_flood_flow.assert_called_once_with(self.agent.tun_br,",
            "                                                             'vxlan')",
            "",
            "    def test_tunnel_update(self):",
            "        kwargs = {'tunnel_ip': '10.10.10.10',",
            "                  'tunnel_type': 'gre'}",
            "        self.agent._setup_tunnel_port = mock.Mock()",
            "        self.agent.enable_tunneling = True",
            "        self.agent.tunnel_types = ['gre']",
            "        self.agent.l2_pop = False",
            "        self.agent.tunnel_update(context=None, **kwargs)",
            "        expected_calls = [",
            "            mock.call(self.agent.tun_br, 'gre-0a0a0a0a', '10.10.10.10', 'gre')]",
            "        self.agent._setup_tunnel_port.assert_has_calls(expected_calls)",
            "",
            "    def test_tunnel_delete(self):",
            "        kwargs = {'tunnel_ip': '10.10.10.10',",
            "                  'tunnel_type': 'gre'}",
            "        self.agent.enable_tunneling = True",
            "        self.agent.tunnel_types = ['gre']",
            "        self.agent.tun_br_ofports = {'gre': {'10.10.10.10': '1'}}",
            "        with mock.patch.object(",
            "            self.agent, 'cleanup_tunnel_port'",
            "        ) as clean_tun_fn:",
            "            self.agent.tunnel_delete(context=None, **kwargs)",
            "            self.assertTrue(clean_tun_fn.called)",
            "",
            "    def test_reset_tunnel_ofports(self):",
            "        tunnel_handles = self.agent.tun_br_ofports",
            "        self.agent.tun_br_ofports = {'gre': {'10.10.10.10': '1'}}",
            "        self.agent._reset_tunnel_ofports()",
            "        self.assertEqual(self.agent.tun_br_ofports, tunnel_handles)",
            "",
            "    def _test_ovs_status(self, *args):",
            "        reply2 = {'current': set(['tap0']),",
            "                  'added': set(['tap2']),",
            "                  'removed': set([])}",
            "",
            "        reply3 = {'current': set(['tap2']),",
            "                  'added': set([]),",
            "                  'removed': set(['tap0'])}",
            "",
            "        reply_ancillary = {'current': set([]),",
            "                           'added': set([]),",
            "                           'removed': set([])}",
            "",
            "        self.agent.enable_tunneling = True",
            "",
            "        with mock.patch.object(async_process.AsyncProcess, \"_spawn\"),\\",
            "                mock.patch.object(async_process.AsyncProcess, \"start\"),\\",
            "                mock.patch.object(async_process.AsyncProcess,",
            "                                  \"is_active\", return_value=True),\\",
            "                mock.patch.object(async_process.AsyncProcess, \"stop\"),\\",
            "                mock.patch.object(log.KeywordArgumentAdapter,",
            "                                  'exception') as log_exception,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'process_ports_events') as process_p_events,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'process_network_ports') as process_network_ports,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'check_ovs_status') as check_ovs_status,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_integration_br') as setup_int_br,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_physical_bridges') as setup_phys_br,\\",
            "                mock.patch.object(time, 'sleep'),\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'update_stale_ofport_rules') as update_stale, \\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'cleanup_stale_flows') as cleanup, \\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_tunnel_br') as setup_tunnel_br,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'setup_tunnel_br_flows') as setup_tunnel_br_flows,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    '_reset_tunnel_ofports') as reset_tunnel_ofports, \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor'),\\",
            "                mock.patch.object(self.agent.state_rpc,",
            "                                  'report_state') as report_st:",
            "            log_exception.side_effect = Exception(",
            "                'Fake exception to get out of the loop')",
            "            devices_not_ready = set()",
            "            process_p_events.side_effect = [(reply2, reply_ancillary,",
            "                                             devices_not_ready),",
            "                                            (reply3, reply_ancillary,",
            "                                             devices_not_ready)]",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_ancillary_devices = {'added': set(), 'removed': set()}",
            "            process_network_ports.side_effect = [",
            "                failed_devices,",
            "                Exception('Fake exception to get out of the loop')]",
            "            check_ovs_status.side_effect = args",
            "",
            "            if self.agent.enable_tunneling:",
            "                self.agent.agent_state.pop(\"start_flag\")",
            "",
            "            try:",
            "                self.agent.daemon_loop()",
            "            except Exception:",
            "                pass",
            "",
            "            process_p_events.assert_has_calls([",
            "                mock.call({'removed': [], 'added': [], 'modified': []},",
            "                          set(), set(), set(),",
            "                          failed_devices, failed_ancillary_devices,",
            "                          set()),",
            "                mock.call({'removed': [], 'added': [], 'modified': []},",
            "                          set(['tap0']), set(),",
            "                          set(), failed_devices, failed_ancillary_devices,",
            "                          set())",
            "            ])",
            "",
            "            process_network_ports.assert_has_calls([",
            "                mock.call(reply2, False),",
            "                mock.call(reply3, True)",
            "            ])",
            "            cleanup.assert_called_once_with()",
            "            self.assertTrue(update_stale.called)",
            "            # Verify the OVS restart we triggered in the loop",
            "            # re-setup the bridges",
            "            setup_int_br.assert_has_calls([mock.call()])",
            "            setup_phys_br.assert_has_calls([mock.call({})])",
            "            # Ensure that tunnel handles are reset and bridge",
            "            # and flows reconfigured.",
            "            self.assertTrue(reset_tunnel_ofports.called)",
            "            self.assertTrue(setup_tunnel_br_flows.called)",
            "            self.assertTrue(setup_tunnel_br.called)",
            "            if self.agent.enable_tunneling:",
            "                self.agent.agent_state['start_flag'] = True",
            "                report_st.assert_called_once_with(",
            "                    self.agent.context, self.agent.agent_state, True)",
            "",
            "    def test_ovs_status(self):",
            "        self._test_ovs_status(constants.OVS_NORMAL,",
            "                              constants.OVS_DEAD,",
            "                              constants.OVS_RESTARTED)",
            "        # OVS will not DEAD in some exception, like DBConnectionError.",
            "        self._test_ovs_status(constants.OVS_NORMAL,",
            "                              constants.OVS_RESTARTED)",
            "",
            "    def test_rpc_loop_fail_to_process_network_ports_keep_flows(self):",
            "        with mock.patch.object(async_process.AsyncProcess, \"_spawn\"),\\",
            "                mock.patch.object(async_process.AsyncProcess, \"start\"),\\",
            "                mock.patch.object(async_process.AsyncProcess,",
            "                                  \"is_active\", return_value=True),\\",
            "                mock.patch.object(async_process.AsyncProcess, \"stop\"),\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'process_network_ports') as process_network_ports,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'check_ovs_status') as check_ovs_status,\\",
            "                mock.patch.object(time, 'sleep'),\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'update_stale_ofport_rules') as update_stale, \\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'cleanup_stale_flows') as cleanup,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    '_check_and_handle_signal') as check_and_handle_signal, \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor'):",
            "            process_network_ports.side_effect = Exception(\"Trigger resync\")",
            "            check_ovs_status.return_value = constants.OVS_NORMAL",
            "            check_and_handle_signal.side_effect = [True, False]",
            "            self.agent.daemon_loop()",
            "            self.assertTrue(update_stale.called)",
            "            cleanup.assert_not_called()",
            "",
            "    def test_set_rpc_timeout(self):",
            "        with mock.patch.object(n_rpc.BackingOffClient,",
            "                               'set_max_timeout') as smt:",
            "            self.agent._handle_sigterm(None, None)",
            "            for rpc_client in (self.agent.plugin_rpc.client,",
            "                               self.agent.sg_plugin_rpc.client,",
            "                               self.agent.dvr_plugin_rpc.client,",
            "                               self.agent.state_rpc.client):",
            "                smt.assert_called_with(10)",
            "",
            "    def test_set_rpc_timeout_no_value(self):",
            "        self.agent.quitting_rpc_timeout = None",
            "        with mock.patch.object(self.agent, 'set_rpc_timeout') as mock_set_rpc:",
            "            self.agent._handle_sigterm(None, None)",
            "        mock_set_rpc.assert_not_called()",
            "",
            "    def test_arp_spoofing_network_port(self):",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(",
            "            int_br, FakeVif(),",
            "            {'device_owner': n_const.DEVICE_OWNER_ROUTER_INTF})",
            "        self.assertTrue(int_br.delete_arp_spoofing_protection.called)",
            "        int_br.install_arp_spoofing_protection.assert_not_called()",
            "",
            "    def test_arp_spoofing_port_security_disabled(self):",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(",
            "            int_br, FakeVif(), {'port_security_enabled': False})",
            "        self.assertTrue(int_br.delete_arp_spoofing_protection.called)",
            "        int_br.install_arp_spoofing_protection.assert_not_called()",
            "",
            "    def test_arp_spoofing_basic_rule_setup(self):",
            "        vif = FakeVif()",
            "        fake_details = {'fixed_ips': [], 'device_owner': 'nobody'}",
            "        self.agent.prevent_arp_spoofing = True",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(int_br, vif, fake_details)",
            "        int_br.delete_arp_spoofing_allow_rules.assert_has_calls(",
            "            [mock.call(port=vif.ofport)])",
            "        int_br.install_arp_spoofing_protection.assert_has_calls(",
            "            [mock.call(ip_addresses=set(), port=vif.ofport)])",
            "",
            "    def test_arp_spoofing_basic_rule_setup_fixed_ipv6(self):",
            "        vif = FakeVif()",
            "        fake_details = {'fixed_ips': [{'ip_address': 'fdf8:f53b:82e4::1'}],",
            "                        'device_owner': 'nobody'}",
            "        self.agent.prevent_arp_spoofing = True",
            "        br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(br, vif, fake_details)",
            "        br.delete_arp_spoofing_allow_rules.assert_has_calls(",
            "            [mock.call(port=vif.ofport)])",
            "        self.assertTrue(br.install_icmpv6_na_spoofing_protection.called)",
            "",
            "    def test_arp_spoofing_fixed_and_allowed_addresses(self):",
            "        vif = FakeVif()",
            "        fake_details = {",
            "            'device_owner': 'nobody',",
            "            'fixed_ips': [{'ip_address': '192.168.44.100'},",
            "                          {'ip_address': '192.168.44.101'}],",
            "            'allowed_address_pairs': [{'ip_address': '192.168.44.102/32'},",
            "                                      {'ip_address': '192.168.44.103/32'}]",
            "        }",
            "        self.agent.prevent_arp_spoofing = True",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(int_br, vif, fake_details)",
            "        # make sure all addresses are allowed",
            "        addresses = {'192.168.44.100', '192.168.44.101', '192.168.44.102/32',",
            "                     '192.168.44.103/32'}",
            "        int_br.install_arp_spoofing_protection.assert_has_calls(",
            "            [mock.call(port=vif.ofport, ip_addresses=addresses)])",
            "",
            "    def test_arp_spoofing_fixed_and_allowed_addresses_ipv6(self):",
            "        vif = FakeVif()",
            "        fake_details = {",
            "            'device_owner': 'nobody',",
            "            'fixed_ips': [{'ip_address': '2001:db8::1'},",
            "                          {'ip_address': '2001:db8::2'}],",
            "            'allowed_address_pairs': [{'ip_address': '2001:db8::200',",
            "                                       'mac_address': 'aa:22:33:44:55:66'}]",
            "        }",
            "        self.agent.prevent_arp_spoofing = True",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        self.agent.setup_arp_spoofing_protection(int_br, vif, fake_details)",
            "        # make sure all addresses are allowed including ipv6 LLAs",
            "        addresses = {'2001:db8::1', '2001:db8::2', '2001:db8::200',",
            "                     'fe80::a822:33ff:fe44:5566', 'fe80::a8bb:ccff:fe11:2233'}",
            "        int_br.install_icmpv6_na_spoofing_protection.assert_has_calls(",
            "            [mock.call(port=vif.ofport, ip_addresses=addresses)])",
            "",
            "    def test__get_ofport_moves(self):",
            "        previous = {'port1': 1, 'port2': 2}",
            "        current = {'port1': 5, 'port2': 2}",
            "        # we expect it to tell us port1 moved",
            "        expected = ['port1']",
            "        self.assertEqual(expected,",
            "                         self.agent._get_ofport_moves(current, previous))",
            "",
            "    def test_update_stale_ofport_rules_clears_old(self):",
            "        self.agent.prevent_arp_spoofing = True",
            "        self.agent.vifname_to_ofport_map = {'port1': 1, 'port2': 2}",
            "        self.agent.int_br = mock.Mock()",
            "        # simulate port1 was removed",
            "        newmap = {'port2': 2}",
            "        self.agent.int_br.get_vif_port_to_ofport_map.return_value = newmap",
            "        self.agent.update_stale_ofport_rules()",
            "        # rules matching port 1 should have been deleted",
            "        self.agent.int_br.delete_arp_spoofing_protection.assert_has_calls(",
            "            [mock.call(port=1)])",
            "        # make sure the state was updated with the new map",
            "        self.assertEqual(newmap, self.agent.vifname_to_ofport_map)",
            "",
            "    def test_update_stale_ofport_rules_treats_moved(self):",
            "        self.agent.prevent_arp_spoofing = True",
            "        self.agent.vifname_to_ofport_map = {'port1': 1, 'port2': 2}",
            "        self.agent.treat_devices_added_or_updated = mock.Mock()",
            "        self.agent.int_br = mock.Mock()",
            "        # simulate port1 was moved",
            "        newmap = {'port2': 2, 'port1': 90}",
            "        self.agent.int_br.get_vif_port_to_ofport_map.return_value = newmap",
            "        ofport_changed_ports = self.agent.update_stale_ofport_rules()",
            "        self.assertEqual(['port1'], ofport_changed_ports)",
            "",
            "    def test_update_stale_ofport_rules_removes_drop_flow(self):",
            "        self.agent.prevent_arp_spoofing = False",
            "        self.agent.vifname_to_ofport_map = {'port1': 1, 'port2': 2}",
            "        self.agent.int_br = mock.Mock()",
            "        # simulate port1 was removed",
            "        newmap = {'port2': 2}",
            "        self.agent.int_br.get_vif_port_to_ofport_map.return_value = newmap",
            "        self.agent.update_stale_ofport_rules()",
            "        # drop flow rule matching port 1 should have been deleted",
            "        ofport_changed_ports = self.agent.update_stale_ofport_rules()",
            "        expected = [",
            "            mock.call(in_port=1)",
            "        ]",
            "        self.agent.int_br.uninstall_flows.assert_has_calls(expected)",
            "        self.assertEqual(newmap, self.agent.vifname_to_ofport_map)",
            "        self.agent.int_br.delete_arp_spoofing_protection.assert_not_called()",
            "        self.assertEqual([], ofport_changed_ports)",
            "",
            "    def test__setup_tunnel_port_while_new_mapping_is_added(self):",
            "        \"\"\"Test setup_tunnel_port while adding a new mapping",
            "",
            "        Test that _setup_tunnel_port doesn't fail if new vlan mapping is",
            "        added in a different coroutine while iterating over existing mappings.",
            "        See bug 1449944 for more info.",
            "        \"\"\"",
            "",
            "        def add_new_vlan_mapping(*args, **kwargs):",
            "            self.agent.vlan_manager.add('bar', 1, 2, 3, 4)",
            "        bridge = mock.Mock()",
            "        tunnel_type = 'vxlan'",
            "        self.agent.tun_br_ofports = {tunnel_type: dict()}",
            "        self.agent.l2_pop = False",
            "        self.agent.vlan_manager.add('foo', 4, tunnel_type, 2, 1)",
            "        self.agent.local_ip = '2.3.4.5'",
            "        bridge.install_flood_to_tun.side_effect = add_new_vlan_mapping",
            "        self.agent._setup_tunnel_port(bridge, 1, '1.2.3.4',",
            "                                      tunnel_type=tunnel_type)",
            "        self.agent._setup_tunnel_flood_flow(bridge, tunnel_type)",
            "        self.assertIn('bar', self.agent.vlan_manager)",
            "",
            "    def test_setup_entry_for_arp_reply_ignores_ipv6_addresses(self):",
            "        self.agent.arp_responder_enabled = True",
            "        ip = '2001:db8::1'",
            "        br = mock.Mock()",
            "        self.agent.setup_entry_for_arp_reply(",
            "            br, 'add', mock.Mock(), mock.Mock(), ip)",
            "        br.install_arp_responder.assert_not_called()",
            "",
            "    def test_configurations_has_rp_bandwidth(self):",
            "        self.assertIn(n_const.RP_BANDWIDTHS,",
            "                      self.agent.agent_state['configurations'])",
            "",
            "    def test_configurations_has_rp_default_inventory(self):",
            "        self.assertIn(n_const.RP_INVENTORY_DEFAULTS,",
            "                      self.agent.agent_state['configurations'])",
            "        rp_inv_defaults = \\",
            "            self.agent.agent_state['configurations'][",
            "                n_const.RP_INVENTORY_DEFAULTS]",
            "        self.assertListEqual(",
            "            sorted(['reserved', 'min_unit', 'allocation_ratio', 'step_size']),",
            "            sorted(list(rp_inv_defaults)))",
            "        self.assertEqual(1.0, rp_inv_defaults['allocation_ratio'])",
            "        self.assertEqual(1, rp_inv_defaults['min_unit'])",
            "        self.assertEqual(1, rp_inv_defaults['step_size'])",
            "        self.assertEqual(0, rp_inv_defaults['reserved'])",
            "",
            "    def test__validate_rp_bandwidth_bridges(self):",
            "        cfg.CONF.set_override('bridge_mappings', [], 'OVS')",
            "        cfg.CONF.set_override(n_const.RP_BANDWIDTHS,",
            "                              ['no_such_br_in_bridge_mappings:1:1'],",
            "                              'OVS')",
            "        self.assertRaises(ValueError, self._make_agent)",
            "",
            "    def test__check_bridge_datapath_id(self):",
            "        datapath_id = u'0000622486fa3f42'",
            "        datapath_ids_set = set()",
            "        for i in range(5):",
            "            dpid = format((i << 48) + int(datapath_id, 16), '0x').zfill(16)",
            "            bridge = mock.Mock()",
            "            bridge.br_name = 'bridge_%s' % i",
            "            bridge.get_datapath_id = mock.Mock(return_value=datapath_id)",
            "            self.agent._check_bridge_datapath_id(bridge, datapath_ids_set)",
            "            self.assertEqual(i + 1, len(datapath_ids_set))",
            "            self.assertIn(dpid, datapath_ids_set)",
            "            if i == 0:",
            "                bridge.set_datapath_id.assert_not_called()",
            "            else:",
            "                bridge.set_datapath_id.assert_called_once_with(dpid)",
            "",
            "    def test__update_network_segmentation_id(self):",
            "        network = {'id': 'my-net-uuid',",
            "                   provider_net.SEGMENTATION_ID: 1005,",
            "                   provider_net.PHYSICAL_NETWORK: 'provider_net',",
            "                   provider_net.NETWORK_TYPE: n_const.TYPE_VLAN}",
            "        self.agent.vlan_manager.add('my-net-uuid', 5, n_const.TYPE_VLAN,",
            "                                    'provider_net', 1004, None)",
            "        mock_phys_br = mock.Mock()",
            "        self.agent.phys_brs['provider_net'] = mock_phys_br",
            "        self.agent.phys_ofports['provider_net'] = 'phy_ofport'",
            "        self.agent.int_ofports['provider_net'] = 'int_ofport'",
            "",
            "        with mock.patch.object(self.agent.int_br, 'reclaim_local_vlan') \\",
            "                as mock_reclaim_local_vlan, \\",
            "                mock.patch.object(self.agent.int_br, 'provision_local_vlan') \\",
            "                as mock_provision_local_vlan:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_reclaim_local_vlan.assert_called_once_with(",
            "                port='int_ofport', segmentation_id=1004)",
            "            mock_provision_local_vlan.assert_called_once_with(",
            "                port='int_ofport', lvid=5, segmentation_id=1005)",
            "        mock_phys_br.reclaim_local_vlan.assert_called_once_with(",
            "            port='phy_ofport', lvid=5)",
            "",
            "    def test__update_network_segmentation_id_not_vlan(self):",
            "        network = {provider_net.NETWORK_TYPE: 'not_vlan'}",
            "        with mock.patch.object(self.agent.vlan_manager, 'get') as mock_get:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_get.assert_not_called()",
            "",
            "    def test__update_network_segmentation_id_vlan_not_found(self):",
            "        network = {'id': 'my-net-uuid',",
            "                   provider_net.SEGMENTATION_ID: 1005,",
            "                   provider_net.NETWORK_TYPE: n_const.TYPE_VLAN,",
            "                   provider_net.PHYSICAL_NETWORK: 'default_network'}",
            "        with mock.patch.object(self.agent.vlan_manager,",
            "                               'update_segmentation_id') as mock_update_segid:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_update_segid.assert_not_called()",
            "",
            "    def test__update_network_segmentation_id_segmentation_id_not_updated(self):",
            "        network = {'id': 'my-net-uuid',",
            "                   provider_net.SEGMENTATION_ID: 1005,",
            "                   provider_net.NETWORK_TYPE: n_const.TYPE_VLAN,",
            "                   provider_net.PHYSICAL_NETWORK: 'default_network'}",
            "        self.agent.vlan_manager.add('my-net-uuid', 5, n_const.TYPE_VLAN,",
            "                                    'provider_net', 1005, None)",
            "        with mock.patch.object(self.agent.vlan_manager,",
            "                               'update_segmentation_id') as mock_update_segid:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_update_segid.assert_not_called()",
            "",
            "    def test__update_network_segmentation_id_multisegments(self):",
            "        network = {'id': 'my-net-uuid',",
            "                   'segments': [mock.ANY]}",
            "        with mock.patch.object(self.agent.vlan_manager,",
            "                               'get') as mock_get:",
            "            self.agent._update_network_segmentation_id(network)",
            "            mock_get.assert_not_called()",
            "",
            "    def _test_treat_smartnic_port(self, vif_type):",
            "        vm_uuid = \"407a79e0-e0be-4b7d-92a6-513b2161011b\"",
            "        iface_id = \"407a79e0-e0be-4b7d-92a6-513b2161011c\"",
            "        rep_port = 'rep0-0'",
            "        mac = FAKE_MAC",
            "        smartnic_data = {",
            "            'mac': mac,",
            "            'vm_uuid': vm_uuid,",
            "            'vif_name': rep_port,",
            "            'iface_id': iface_id,",
            "            'vif_type': vif_type}",
            "",
            "        cfg.CONF.set_default('baremetal_smartnic', True, group='AGENT')",
            "        agent = self._make_agent()",
            "        instance_info = vif_instance_object.InstanceInfo(uuid=vm_uuid)",
            "        vif = agent._get_vif_object(iface_id, rep_port, mac)",
            "        with mock.patch.object(os_vif, 'plug') as plug_mock, \\",
            "                mock.patch.object(os_vif, 'unplug') as unplug_mock, \\",
            "                mock.patch('os_vif.objects.instance_info.InstanceInfo',",
            "                           return_value=instance_info), \\",
            "                mock.patch.object(agent, '_get_vif_object',",
            "                                  return_value=vif):",
            "",
            "            agent.treat_smartnic_port(smartnic_data)",
            "",
            "            if vif_type == portbindings.VIF_TYPE_OVS:",
            "                plug_mock.assert_called_once_with(vif, instance_info)",
            "            else:",
            "                unplug_mock.assert_called_once_with(vif, instance_info)",
            "",
            "    def test_treat_smartnic_port_add(self):",
            "        self._test_treat_smartnic_port('ovs')",
            "",
            "    def test_treat_smartnic_port_remove(self):",
            "        self._test_treat_smartnic_port('unbound')",
            "",
            "    def test_process_smartnic_ports_remove(self):",
            "        port_id = \"407a79e0-e0be-4b7d-92a6-513b2161011a\"",
            "        rep_port = 'rep0-0'",
            "        mac = FAKE_MAC",
            "        ovs_port = mock.Mock()",
            "        ovs_port.vif_mac = mac",
            "        ovs_port.port_name = rep_port",
            "        ovs_port.vif_id = port_id",
            "        ports_int_br = [ovs_port]",
            "        expected_smartnic_ports_processed_list = [",
            "            {'iface_id': port_id,",
            "             'vif_name': rep_port,",
            "             'mac': mac,",
            "             'vif_type': portbindings.VIF_TYPE_UNBOUND,",
            "             'vm_uuid': ''}]",
            "        expected_current_smartnic_ports_map = {",
            "            port_id: {",
            "                'vif_mac': mac,",
            "                'vif_name': rep_port}}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               \"get_ports_by_vnic_type_and_host\",",
            "                               return_value=[]),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  \"get_vif_ports\",",
            "                                  return_value=ports_int_br):",
            "            self.agent.process_smartnic_ports()",
            "            self.assertEqual(expected_smartnic_ports_processed_list,",
            "                             self.agent.updated_smartnic_ports)",
            "            self.assertEqual(expected_current_smartnic_ports_map,",
            "                             self.agent.current_smartnic_ports_map)",
            "",
            "    def test_process_smartnic_ports(self):",
            "        port_id = \"407a79e0-e0be-4b7d-92a6-513b2161011a\"",
            "        rep_port = 'rep0-0'",
            "        mac = FAKE_MAC",
            "        ovs_port = mock.Mock()",
            "        ovs_port.vif_mac = mac",
            "        ovs_port.port_name = rep_port",
            "        ovs_port.vif_id = port_id",
            "        ports_int_br = [ovs_port]",
            "",
            "        PORT_TO_PROCESS = {",
            "            'binding:profile': {'local_link_information': [",
            "                {'hostname': 'host1', 'port_id': rep_port}]},",
            "            'mac_address': FAKE_MAC,",
            "            'device_id': \"407a79e0-e0be-4b7d-92a6-513b2161011e\",",
            "            'id': \"407a79e0-e0be-4b7d-92a6-513b2161011c\",",
            "            'binding:vif_type': portbindings.VIF_TYPE_OVS",
            "        }",
            "        expected_smartnic_ports_processed_list = [",
            "            {'iface_id': port_id,",
            "             'vif_name': rep_port,",
            "             'mac': mac,",
            "             'vif_type': portbindings.VIF_TYPE_UNBOUND,",
            "             'vm_uuid': ''},",
            "            {'iface_id': \"407a79e0-e0be-4b7d-92a6-513b2161011c\",",
            "             'vif_name': rep_port,",
            "             'mac': mac,",
            "             'vif_type': portbindings.VIF_TYPE_OVS,",
            "             'vm_uuid': \"407a79e0-e0be-4b7d-92a6-513b2161011e\"}]",
            "        expected_current_smartnic_ports_map = {",
            "            port_id: {",
            "                'vif_mac': mac,",
            "                'vif_name': rep_port}}",
            "        with mock.patch.object(self.agent.plugin_rpc,",
            "                               \"get_ports_by_vnic_type_and_host\",",
            "                               return_value=[PORT_TO_PROCESS]),\\",
            "            mock.patch.object(self.agent.int_br,",
            "                              \"get_vif_ports\",",
            "                              return_value=ports_int_br):",
            "            self.agent.process_smartnic_ports()",
            "            self.assertEqual(expected_smartnic_ports_processed_list,",
            "                             self.agent.updated_smartnic_ports)",
            "            self.assertEqual(expected_current_smartnic_ports_map,",
            "                             self.agent.current_smartnic_ports_map)",
            "",
            "    def test_add_bound_port_to_updated_smartnic_ports(self):",
            "        mac = FAKE_MAC",
            "        vm_uuid = \"407a79e0-e0be-4b7d-92a6-513b2161011b\"",
            "        rep_port = 'rep0-0'",
            "        iface_id = \"407a79e0-e0be-4b7d-92a6-513b2161011c\"",
            "        self.agent._add_port_to_updated_smartnic_ports(",
            "            mac,",
            "            rep_port,",
            "            iface_id,",
            "            portbindings.VIF_TYPE_OVS,",
            "            vm_uuid,)",
            "",
            "        smartnic_data = {",
            "            'mac': mac,",
            "            'vm_uuid': vm_uuid,",
            "            'vif_name': rep_port,",
            "            'iface_id': iface_id,",
            "            'vif_type': portbindings.VIF_TYPE_OVS}",
            "        self.assertEqual([smartnic_data],",
            "                         self.agent.updated_smartnic_ports)",
            "",
            "    def test_add_unbound_port_to_updated_smartnic_ports(self):",
            "        vif_mac = FAKE_MAC",
            "        vif_name = 'rep0-0'",
            "        vif_id = \"407a79e0-e0be-4b7d-92a6-513b2161011a\"",
            "        self.agent._add_port_to_updated_smartnic_ports(",
            "            vif_mac,",
            "            vif_name,",
            "            vif_id,",
            "            portbindings.VIF_TYPE_UNBOUND)",
            "        smartnic_data = {",
            "            'mac': vif_mac,",
            "            'vm_uuid': '',",
            "            'vif_name': vif_name,",
            "            'iface_id': vif_id,",
            "            'vif_type': portbindings.VIF_TYPE_UNBOUND}",
            "        self.assertEqual([smartnic_data],",
            "                         self.agent.updated_smartnic_ports)",
            "",
            "    def test_create_smartnic_port_map_entry_data(self):",
            "        mac = FAKE_MAC",
            "        rep_port = 'rep0-0'",
            "        expected_return_value = {\"vif_mac\": mac,",
            "                                 \"vif_name\": rep_port}",
            "        int_br_smartnic_port_map =\\",
            "            self.agent.create_smartnic_port_map_entry_data(mac, rep_port)",
            "        self.assertEqual(int_br_smartnic_port_map, expected_return_value)",
            "",
            "",
            "class TestOvsNeutronAgentOSKen(TestOvsNeutronAgent,",
            "                               ovs_test_base.OVSOSKenTestBase):",
            "    def test_cleanup_stale_flows(self):",
            "        uint64_max = (1 << 64) - 1",
            "        with mock.patch.object(self.agent.int_br,",
            "                               'dump_flows') as dump_flows,\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'uninstall_flows') as uninstall_flows:",
            "            self.agent.int_br.set_agent_uuid_stamp(1234)",
            "            fake_flows = [",
            "                # mock os_ken.ofproto.ofproto_v1_3_parser.OFPFlowStats",
            "                mock.Mock(cookie=1234, table_id=0),",
            "                mock.Mock(cookie=17185, table_id=2),",
            "                mock.Mock(cookie=9029, table_id=2),",
            "                mock.Mock(cookie=1234, table_id=3),",
            "            ]",
            "            dump_flows.return_value = fake_flows",
            "            self.agent.iter_num = 3",
            "            self.agent.cleanup_stale_flows()",
            "",
            "            dump_flows_expected = [",
            "                mock.call(tid) for tid in constants.INT_BR_ALL_TABLES]",
            "            dump_flows.assert_has_calls(dump_flows_expected)",
            "",
            "            expected = [mock.call(cookie=17185,",
            "                                  cookie_mask=uint64_max),",
            "                        mock.call(cookie=9029,",
            "                                  cookie_mask=uint64_max)]",
            "            uninstall_flows.assert_has_calls(expected, any_order=True)",
            "            self.assertEqual(len(constants.INT_BR_ALL_TABLES) * len(expected),",
            "                             len(uninstall_flows.mock_calls))",
            "",
            "",
            "class AncillaryBridgesTest(object):",
            "",
            "    def setUp(self):",
            "        super(AncillaryBridgesTest, self).setUp()",
            "        conn_patcher = mock.patch(",
            "            'neutron.agent.ovsdb.impl_idl._connection')",
            "        conn_patcher.start()",
            "        self.addCleanup(conn_patcher.stop)",
            "        mock.patch(PULLAPI).start()",
            "        notifier_p = mock.patch(NOTIFIER)",
            "        notifier_cls = notifier_p.start()",
            "        self.notifier = mock.Mock()",
            "        notifier_cls.return_value = self.notifier",
            "        cfg.CONF.set_default('firewall_driver',",
            "                             'neutron.agent.firewall.NoopFirewallDriver',",
            "                             group='SECURITYGROUP')",
            "        cfg.CONF.set_override('report_interval', 0, 'AGENT')",
            "        mock.patch('neutron.agent.common.ovs_lib.BaseOVS.config',",
            "                   new_callable=mock.PropertyMock,",
            "                   return_value={}).start()",
            "",
            "    def _test_ancillary_bridges(self, bridges, ancillary):",
            "        device_ids = ancillary[:]",
            "",
            "        def pullup_side_effect(*args, **kwargs):",
            "            # Check that the device_id exists, if it does return it",
            "            # if it does not return None",
            "            try:",
            "                device_ids.remove(args[0])",
            "                return args[0]",
            "            except Exception:",
            "                return None",
            "",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'),\\",
            "                mock.patch('neutron.agent.linux.ip_lib.get_device_mac',",
            "                           return_value='00:00:00:00:00:01'),\\",
            "                mock.patch('neutron.agent.common.ovs_lib.BaseOVS.get_bridges',",
            "                           return_value=bridges),\\",
            "                mock.patch('neutron.agent.common.ovs_lib.BaseOVS.'",
            "                           'get_bridge_external_bridge_id',",
            "                           side_effect=pullup_side_effect),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.'",
            "                    'get_ports_attributes',",
            "                    return_value=[]),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.' 'get_vif_ports',",
            "                    return_value=[]),\\",
            "                mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                           'has_alive_neutron_server'):",
            "            ext_manager = mock.Mock()",
            "            self.agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                        ext_manager, cfg.CONF)",
            "            self.assertEqual(len(ancillary), len(self.agent.ancillary_brs))",
            "            if ancillary:",
            "                bridges = [br.br_name for br in self.agent.ancillary_brs]",
            "                for br in ancillary:",
            "                    self.assertIn(br, bridges)",
            "",
            "    def test_ancillary_bridges_single(self):",
            "        bridges = ['br-int', 'br-ex']",
            "        self._test_ancillary_bridges(bridges, ['br-ex'])",
            "",
            "    def test_ancillary_bridges_none(self):",
            "        bridges = ['br-int']",
            "        self._test_ancillary_bridges(bridges, [])",
            "",
            "    def test_ancillary_bridges_multiple(self):",
            "        bridges = ['br-int', 'br-ex1', 'br-ex2']",
            "        self._test_ancillary_bridges(bridges, ['br-ex1', 'br-ex2'])",
            "",
            "    def mock_scan_ancillary_ports(self, vif_port_set=None,",
            "                                  registered_ports=None, sync=False):",
            "        bridges = ['br-int', 'br-ex']",
            "        ancillary = ['br-ex']",
            "",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'), \\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  '_restore_local_vlan_map'), \\",
            "                mock.patch('neutron.agent.common.ovs_lib.BaseOVS.get_bridges',",
            "                           return_value=bridges), \\",
            "                mock.patch('neutron.agent.common.ovs_lib.BaseOVS.'",
            "                           'get_bridge_external_bridge_id',",
            "                           side_effect=ancillary), \\",
            "                mock.patch('neutron.agent.common.ovs_lib.OVSBridge.'",
            "                           'get_vif_port_set',",
            "                           return_value=vif_port_set),\\",
            "                mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                           'has_alive_neutron_server'):",
            "            ext_manager = mock.Mock()",
            "            self.agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                        ext_manager, cfg.CONF)",
            "            return self.agent.scan_ancillary_ports(registered_ports, sync)",
            "",
            "    def test_scan_ancillary_ports_returns_cur_only_for_unchanged_ports(self):",
            "        vif_port_set = set([1, 2])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set)",
            "        actual = self.mock_scan_ancillary_ports(vif_port_set, registered_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ancillary_ports_returns_port_changes(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added={3},",
            "                                      removed={2})",
            "        actual = self.mock_scan_ancillary_ports(vif_port_set, registered_ports)",
            "        self.assertEqual(expected, actual)",
            "",
            "    def test_scan_ancillary_ports_returns_port_changes_with_sync(self):",
            "        vif_port_set = set([1, 3])",
            "        registered_ports = set([1, 2])",
            "        expected = ovs_agent.PortInfo(current=vif_port_set, added=vif_port_set,",
            "                                      removed={2})",
            "        actual = self.mock_scan_ancillary_ports(vif_port_set, registered_ports,",
            "                                                sync=True)",
            "        self.assertEqual(expected, actual)",
            "",
            "",
            "class AncillaryBridgesTestOSKen(AncillaryBridgesTest,",
            "                              ovs_test_base.OVSOSKenTestBase):",
            "    pass",
            "",
            "",
            "class TestOvsDvrNeutronAgent(object):",
            "",
            "    def setUp(self):",
            "        super(TestOvsDvrNeutronAgent, self).setUp()",
            "        mock.patch(PULLAPI).start()",
            "        notifier_p = mock.patch(NOTIFIER)",
            "        notifier_cls = notifier_p.start()",
            "        self.notifier = mock.Mock()",
            "        notifier_cls.return_value = self.notifier",
            "        cfg.CONF.set_default('firewall_driver',",
            "                             'neutron.agent.firewall.NoopFirewallDriver',",
            "                             group='SECURITYGROUP')",
            "",
            "        mock.patch('neutron.agent.common.ovs_lib.BaseOVS.config',",
            "                   new_callable=mock.PropertyMock,",
            "                   return_value={}).start()",
            "        mock.patch('neutron.agent.ovsdb.impl_idl._connection').start()",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'setup_integration_br'),\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'setup_ancillary_bridges',",
            "                                  return_value=[]),\\",
            "                mock.patch('neutron.agent.linux.ip_lib.get_device_mac',",
            "                           return_value='00:00:00:00:00:01'),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.BaseOVS.get_bridges'),\\",
            "                mock.patch('oslo_service.loopingcall.'",
            "                           'FixedIntervalLoopingCall',",
            "                           new=MockFixedIntervalLoopingCall),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.'",
            "                    'get_ports_attributes',",
            "                    return_value=[]),\\",
            "                mock.patch(",
            "                    'neutron.agent.common.ovs_lib.OVSBridge.' 'get_vif_ports',",
            "                    return_value=[]),\\",
            "                mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                           'has_alive_neutron_server'):",
            "            ext_manager = mock.Mock()",
            "            self.agent = self.mod_agent.OVSNeutronAgent(self._bridge_classes(),",
            "                                                       ext_manager, cfg.CONF)",
            "            self.agent.tun_br = self.br_tun_cls(br_name='br-tun')",
            "        self.agent.sg_agent = mock.Mock()",
            "",
            "    def _setup_for_dvr_test(self):",
            "        self._port = mock.Mock()",
            "        self._port.ofport = 10",
            "        self._port.vif_id = \"1234-5678-90\"",
            "        self._physical_network = 'physeth1'",
            "        self._old_local_vlan = None",
            "        self._segmentation_id = 2001",
            "        self.agent.enable_distributed_routing = True",
            "        self.agent.enable_tunneling = True",
            "        self.agent.patch_tun_ofport = 1",
            "        self.agent.patch_int_ofport = 2",
            "        self.agent.dvr_agent.local_ports = {}",
            "        self.agent.vlan_manager = self.useFixture(",
            "            test_vlanmanager.LocalVlanManagerFixture()).manager",
            "        self.agent.dvr_agent.enable_distributed_routing = True",
            "        self.agent.dvr_agent.enable_tunneling = True",
            "        self.agent.dvr_agent.patch_tun_ofport = 1",
            "        self.agent.dvr_agent.patch_int_ofport = 2",
            "        self.agent.dvr_agent.tun_br = mock.Mock()",
            "        self.agent.dvr_agent.phys_brs[self._physical_network] = mock.Mock()",
            "        self.agent.dvr_agent.bridge_mappings = {self._physical_network:",
            "                                                'br-eth1'}",
            "        self.agent.dvr_agent.int_ofports[self._physical_network] = 30",
            "        self.agent.dvr_agent.phys_ofports[self._physical_network] = 40",
            "        self.agent.dvr_agent.local_dvr_map = {}",
            "        self.agent.dvr_agent.registered_dvr_macs = set()",
            "        self.agent.dvr_agent.dvr_mac_address = 'aa:22:33:44:55:66'",
            "        self._net_uuid = 'my-net-uuid'",
            "        self._fixed_ips = [{'subnet_id': 'my-subnet-uuid',",
            "                            'ip_address': '1.1.1.1'}]",
            "        self._compute_port = mock.Mock()",
            "        self._compute_port.ofport = 20",
            "        self._compute_port.vif_id = \"1234-5678-91\"",
            "        self._compute_fixed_ips = [{'subnet_id': 'my-subnet-uuid',",
            "                                    'ip_address': '1.1.1.3'}]",
            "",
            "    @staticmethod",
            "    def _expected_port_bound(port, lvid, is_dvr=True,",
            "                             network_type=n_const.TYPE_VXLAN):",
            "        resp = [",
            "            mock.call.db_get_val('Port', port.port_name, 'other_config'),",
            "            mock.call.set_db_attribute('Port', port.port_name, 'other_config',",
            "                                       mock.ANY),",
            "        ]",
            "        if is_dvr:",
            "            resp = [",
            "                mock.call.get_vifs_by_ids([]),",
            "                mock.call.install_dvr_dst_mac_for_arp(",
            "                    network_type,",
            "                    dvr_mac=port.dvr_mac,",
            "                    gateway_mac=port.vif_mac,",
            "                    rtr_port=port.ofport,",
            "                    vlan_tag=lvid)",
            "            ] + resp",
            "        return resp",
            "",
            "    @staticmethod",
            "    def _expected_port_unbound(port, lvid, is_dvr=True,",
            "                               network_type=n_const.TYPE_VXLAN):",
            "        resp = []",
            "        if is_dvr:",
            "            resp = [",
            "                mock.call.delete_dvr_dst_mac_for_arp(",
            "                    network_type=network_type,",
            "                    dvr_mac=port.dvr_mac,",
            "                    gateway_mac=port.vif_mac,",
            "                    rtr_port=port.ofport,",
            "                    vlan_tag=lvid)",
            "            ]",
            "        return resp",
            "",
            "    def _expected_install_dvr_process(self, lvid, port, ip_version,",
            "                                      gateway_ip):",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            ipvx_calls = [",
            "                mock.call.install_dvr_process_ipv4(",
            "                    vlan_tag=lvid,",
            "                    gateway_ip=gateway_ip),",
            "            ]",
            "        else:",
            "            ipvx_calls = [",
            "                mock.call.install_dvr_process_ipv6(",
            "                    vlan_tag=lvid,",
            "                    gateway_mac=port.vif_mac),",
            "            ]",
            "        return ipvx_calls + [",
            "            mock.call.install_dvr_process(",
            "                vlan_tag=lvid,",
            "                dvr_mac_address=self.agent.dvr_agent.dvr_mac_address,",
            "                vif_mac=port.vif_mac,",
            "            ),",
            "        ]",
            "",
            "    def _test_port_bound_for_dvr_on_physical_network(",
            "            self, device_owner, network_type, ip_version=n_const.IP_VERSION_4):",
            "        self._setup_for_dvr_test()",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            gateway_ip = '1.1.1.10'",
            "            cidr = '1.1.1.0/24'",
            "        else:",
            "            gateway_ip = '2001:100::1'",
            "            cidr = '2001:100::0/64'",
            "        self._port.vif_mac = 'aa:bb:cc:11:22:33'",
            "        self._port.dvr_mac = self.agent.dvr_agent.dvr_mac_address",
            "        gateway_mac = 'aa:bb:cc:66:66:66'",
            "        self._compute_port.vif_mac = '77:88:99:00:11:22'",
            "        physical_network = self._physical_network",
            "        segmentation_id = self._segmentation_id",
            "        if network_type == n_const.TYPE_FLAT:",
            "            segmentation_id = None",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        phys_br = mock.create_autospec(self.br_phys_cls('br-phys'))",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': gateway_ip,",
            "                                             'cidr': cidr,",
            "                                             'ip_version': ip_version,",
            "                                             'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {physical_network: phys_br}):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, network_type,",
            "                physical_network, segmentation_id, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_DVR_INTERFACE, False)",
            "            phy_ofp = self.agent.dvr_agent.phys_ofports[physical_network]",
            "            int_ofp = self.agent.dvr_agent.int_ofports[physical_network]",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            expected_on_phys_br = [",
            "                mock.call.provision_local_vlan(",
            "                    port=phy_ofp,",
            "                    lvid=lvid,",
            "                    segmentation_id=segmentation_id,",
            "                    distributed=True,",
            "                ),",
            "            ] + self._expected_install_dvr_process(",
            "                port=self._port,",
            "                lvid=lvid,",
            "                ip_version=ip_version,",
            "                gateway_ip=self._fixed_ips[0]['ip_address'])",
            "            expected_on_int_br = [",
            "                mock.call.provision_local_vlan(",
            "                    port=int_ofp,",
            "                    lvid=lvid,",
            "                    segmentation_id=segmentation_id,",
            "                ),",
            "            ] + self._expected_port_bound(self._port, lvid,",
            "                                          network_type=network_type)",
            "            int_br.assert_has_calls(expected_on_int_br, any_order=True)",
            "            tun_br.assert_not_called()",
            "            phys_br.assert_has_calls(expected_on_phys_br)",
            "            int_br.reset_mock()",
            "            tun_br.reset_mock()",
            "            phys_br.reset_mock()",
            "            self.agent.port_bound(self._compute_port, self._net_uuid,",
            "                                  network_type, physical_network,",
            "                                  segmentation_id,",
            "                                  self._compute_fixed_ips,",
            "                                  device_owner, False)",
            "            expected_on_int_br = [",
            "                mock.call.install_dvr_to_src_mac(",
            "                    network_type=network_type,",
            "                    gateway_mac=gateway_mac,",
            "                    dst_mac=self._compute_port.vif_mac,",
            "                    dst_port=self._compute_port.ofport,",
            "                    vlan_tag=segmentation_id,",
            "                ),",
            "            ] + self._expected_port_bound(self._compute_port, lvid,",
            "                                          is_dvr=False,",
            "                                          network_type=network_type)",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "            phys_br.assert_not_called()",
            "",
            "    def _test_port_bound_for_dvr_on_vxlan_network(",
            "            self, device_owner, ip_version=n_const.IP_VERSION_4):",
            "        self._setup_for_dvr_test()",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            gateway_ip = '1.1.1.1'",
            "            cidr = '1.1.1.0/24'",
            "        else:",
            "            gateway_ip = '2001:100::1'",
            "            cidr = '2001:100::0/64'",
            "        network_type = n_const.TYPE_VXLAN",
            "        self._port.vif_mac = gateway_mac = 'aa:bb:cc:11:22:33'",
            "        self._port.dvr_mac = self.agent.dvr_agent.dvr_mac_address",
            "        self._compute_port.vif_mac = '77:88:99:00:11:22'",
            "        physical_network = self._physical_network",
            "        segmentation_id = self._segmentation_id",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        phys_br = mock.create_autospec(self.br_phys_cls('br-phys'))",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': gateway_ip,",
            "                                             'cidr': cidr,",
            "                                             'ip_version': ip_version,",
            "                                             'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {physical_network: phys_br}):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, network_type,",
            "                physical_network, segmentation_id, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_DVR_INTERFACE, False)",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            expected_on_int_br = self._expected_port_bound(",
            "                self._port, lvid)",
            "            expected_on_tun_br = [",
            "                mock.call.provision_local_vlan(",
            "                    network_type=network_type,",
            "                    segmentation_id=segmentation_id,",
            "                    lvid=lvid,",
            "                    distributed=True),",
            "            ] + self._expected_install_dvr_process(",
            "                port=self._port,",
            "                lvid=lvid,",
            "                ip_version=ip_version,",
            "                gateway_ip=gateway_ip)",
            "            int_br.assert_has_calls(expected_on_int_br, any_order=True)",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "            phys_br.assert_not_called()",
            "            int_br.reset_mock()",
            "            tun_br.reset_mock()",
            "            phys_br.reset_mock()",
            "            self.agent.port_bound(self._compute_port, self._net_uuid,",
            "                                  network_type, physical_network,",
            "                                  segmentation_id,",
            "                                  self._compute_fixed_ips,",
            "                                  device_owner, False)",
            "            expected_on_int_br = [",
            "                mock.call.install_dvr_to_src_mac(",
            "                    network_type=network_type,",
            "                    gateway_mac=gateway_mac,",
            "                    dst_mac=self._compute_port.vif_mac,",
            "                    dst_port=self._compute_port.ofport,",
            "                    vlan_tag=lvid,",
            "                ),",
            "            ] + self._expected_port_bound(self._compute_port, lvid, False,",
            "                                          network_type)",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "            phys_br.assert_not_called()",
            "",
            "    def test_port_bound_for_dvr_with_compute_ports(self):",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            network_type=n_const.TYPE_VLAN)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            network_type=n_const.TYPE_VLAN,",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            network_type=n_const.TYPE_FLAT)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            network_type=n_const.TYPE_FLAT,",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_port_bound_for_dvr_on_vxlan_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE)",
            "        self._test_port_bound_for_dvr_on_vxlan_network(",
            "            device_owner=DEVICE_OWNER_COMPUTE,",
            "            ip_version=n_const.IP_VERSION_6)",
            "",
            "    def test_port_bound_for_dvr_with_dhcp_ports(self):",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            network_type=n_const.TYPE_VLAN)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            network_type=n_const.TYPE_VLAN,",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            network_type=n_const.TYPE_FLAT)",
            "        self._test_port_bound_for_dvr_on_physical_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            network_type=n_const.TYPE_FLAT,",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_port_bound_for_dvr_on_vxlan_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP)",
            "        self._test_port_bound_for_dvr_on_vxlan_network(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            ip_version=n_const.IP_VERSION_6)",
            "",
            "    def test_port_bound_for_dvr_with_csnat_ports(self):",
            "        self._setup_for_dvr_test()",
            "        int_br, tun_br = self._port_bound_for_dvr_with_csnat_ports()",
            "        lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "        expected_on_int_br = [",
            "            mock.call.install_dvr_to_src_mac(",
            "                network_type='vxlan',",
            "                gateway_mac='aa:bb:cc:11:22:33',",
            "                dst_mac=self._port.vif_mac,",
            "                dst_port=self._port.ofport,",
            "                vlan_tag=lvid,",
            "            ),",
            "        ] + self._expected_port_bound(self._port, lvid, is_dvr=False)",
            "        int_br.assert_has_calls(expected_on_int_br)",
            "        expected_on_tun_br = [",
            "            mock.call.provision_local_vlan(",
            "                network_type='vxlan',",
            "                lvid=lvid,",
            "                segmentation_id=None,",
            "                distributed=True,",
            "            ),",
            "        ]",
            "        tun_br.assert_has_calls(expected_on_tun_br)",
            "",
            "    def test_port_bound_for_dvr_with_csnat_port_without_passing_fixed_ip(self):",
            "        self._setup_for_dvr_test()",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr') as mock_getsub,\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_ROUTER_SNAT,",
            "                False)",
            "            mock_getsub.assert_called_with(",
            "                self.agent.context, mock.ANY, fixed_ips=None)",
            "",
            "    def test_port_bound_for_dvr_with_csnat_ports_ofport_change(self):",
            "        self._setup_for_dvr_test()",
            "        self._port_bound_for_dvr_with_csnat_ports()",
            "        # simulate a replug",
            "        self._port.ofport = 12",
            "        int_br, tun_br = self._port_bound_for_dvr_with_csnat_ports()",
            "        lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "        expected_on_int_br = [",
            "            mock.call.delete_dvr_to_src_mac(",
            "                network_type='vxlan',",
            "                dst_mac=self._port.vif_mac,",
            "                vlan_tag=lvid,",
            "            ),",
            "            mock.call.install_dvr_to_src_mac(",
            "                network_type='vxlan',",
            "                gateway_mac='aa:bb:cc:11:22:33',",
            "                dst_mac=self._port.vif_mac,",
            "                dst_port=self._port.ofport,",
            "                vlan_tag=lvid,",
            "            ),",
            "        ] + self._expected_port_bound(self._port, lvid, is_dvr=False)",
            "        int_br.assert_has_calls(expected_on_int_br)",
            "        # a local vlan was already provisioned so there should be no new",
            "        # calls to tunbr",
            "        tun_br.assert_not_called()",
            "        # make sure ofport was updated",
            "        self.assertEqual(12,",
            "            self.agent.dvr_agent.local_ports[self._port.vif_id].ofport)",
            "",
            "    def _port_bound_for_dvr_with_csnat_ports(self):",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': '1.1.1.1',",
            "                               'cidr': '1.1.1.0/24',",
            "                               'ip_version': n_const.IP_VERSION_4,",
            "                               'gateway_mac': 'aa:bb:cc:11:22:33'}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_ROUTER_SNAT,",
            "                False)",
            "        return int_br, tun_br",
            "",
            "    def test_port_bound_for_dvr_with_csnat_ports_without_subnet(self):",
            "        self._setup_for_dvr_test()",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "",
            "        # get_subnet_for_dvr RPC returns {} on error",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={}),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_ROUTER_SNAT,",
            "                False)",
            "            int_br.install_dvr_to_src_mac.assert_not_called()",
            "",
            "    def test_treat_devices_removed_for_dvr_interface(self):",
            "        self._test_treat_devices_removed_for_dvr_interface()",
            "        self._test_treat_devices_removed_for_dvr_interface(",
            "            ip_version=n_const.IP_VERSION_6)",
            "        self._test_treat_devices_removed_for_dvr_interface(network_type='vlan')",
            "        self._test_treat_devices_removed_for_dvr_interface(",
            "            ip_version=n_const.IP_VERSION_6, network_type='vlan')",
            "",
            "    def _test_treat_devices_removed_for_dvr_interface(",
            "            self, ip_version=n_const.IP_VERSION_4, network_type='vxlan'):",
            "        self._setup_for_dvr_test()",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            gateway_ip = '1.1.1.1'",
            "            cidr = '1.1.1.0/24'",
            "        else:",
            "            gateway_ip = '2001:100::1'",
            "            cidr = '2001:100::0/64'",
            "        self._port.dvr_mac = self.agent.dvr_agent.dvr_mac_address",
            "        gateway_mac = 'aa:bb:cc:11:22:33'",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': gateway_ip,",
            "                               'cidr': cidr,",
            "                               'ip_version': ip_version,",
            "                               'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port):",
            "            if network_type == 'vlan':",
            "                self.agent.port_bound(self._port, self._net_uuid,",
            "                                      network_type, self._physical_network,",
            "                                      self._segmentation_id,",
            "                                      self._compute_fixed_ips,",
            "                                      n_const.DEVICE_OWNER_DVR_INTERFACE,",
            "                                      False)",
            "            else:",
            "                self.agent.port_bound(",
            "                    self._port, self._net_uuid, 'vxlan',",
            "                    None, None, self._fixed_ips,",
            "                    n_const.DEVICE_OWNER_DVR_INTERFACE,",
            "                    False)",
            "                lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "                int_br.assert_has_calls(",
            "                    self._expected_port_bound(self._port, lvid),",
            "                    any_order=True)",
            "                expected_on_tun_br = [",
            "                    mock.call.provision_local_vlan(network_type='vxlan',",
            "                        lvid=lvid, segmentation_id=None, distributed=True),",
            "                ] + self._expected_install_dvr_process(",
            "                    port=self._port,",
            "                    lvid=lvid,",
            "                    ip_version=ip_version,",
            "                    gateway_ip=gateway_ip)",
            "                tun_br.assert_has_calls(expected_on_tun_br)",
            "",
            "        int_br.reset_mock()",
            "        tun_br.reset_mock()",
            "        phys_br = mock.create_autospec(self.br_phys_cls('br-phys'))",
            "        with mock.patch.object(self.agent, 'reclaim_local_vlan'),\\",
            "                mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={",
            "                                      'devices_up': [],",
            "                                      'devices_down': [self._port.vif_id],",
            "                                      'failed_devices_up': [],",
            "                                      'failed_devices_down': []}),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {self._physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {self._physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=None):",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_devices['removed'] = self.agent.treat_devices_removed(",
            "                [self._port.vif_id])",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            if ip_version == n_const.IP_VERSION_4:",
            "                expected = [",
            "                    mock.call.delete_dvr_process_ipv4(",
            "                        vlan_tag=lvid,",
            "                        gateway_ip=gateway_ip),",
            "                ]",
            "            else:",
            "                expected = [",
            "                    mock.call.delete_dvr_process_ipv6(",
            "                        vlan_tag=lvid,",
            "                        gateway_mac=gateway_mac),",
            "                ]",
            "            expected.extend([",
            "                mock.call.delete_dvr_process(",
            "                    vlan_tag=lvid,",
            "                    vif_mac=self._port.vif_mac),",
            "            ])",
            "            if network_type == 'vlan':",
            "                expected_unbound_dvr = self._expected_port_unbound(self._port,",
            "                    self._segmentation_id, network_type=network_type)",
            "                int_br.assert_has_calls(expected_unbound_dvr)",
            "                tun_br.assert_not_called()",
            "                phys_br.assert_has_calls(expected)",
            "                self.assertEqual({}, self.agent.dvr_agent.local_ports)",
            "            else:",
            "                expected_unbound_dvr = self._expected_port_unbound(self._port,",
            "                    lvid, network_type=network_type)",
            "                int_br.assert_has_calls(expected_unbound_dvr)",
            "                tun_br.assert_has_calls(expected)",
            "                phys_br.assert_not_called()",
            "",
            "    def _test_treat_devices_removed_for_dvr(self, device_owner,",
            "                                            ip_version=n_const.IP_VERSION_4):",
            "        self._setup_for_dvr_test()",
            "        if ip_version == n_const.IP_VERSION_4:",
            "            gateway_ip = '1.1.1.1'",
            "            cidr = '1.1.1.0/24'",
            "        else:",
            "            gateway_ip = '2001:100::1'",
            "            cidr = '2001:100::0/64'",
            "        self._port.dvr_mac = self.agent.dvr_agent.dvr_mac_address",
            "        gateway_mac = 'aa:bb:cc:11:22:33'",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': gateway_ip,",
            "                               'cidr': cidr,",
            "                               'ip_version': ip_version,",
            "                               'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_DVR_INTERFACE,",
            "                False)",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            int_br.assert_has_calls(",
            "                self._expected_port_bound(self._port, lvid), any_order=True)",
            "            expected_on_tun_br = [",
            "                mock.call.provision_local_vlan(",
            "                    network_type='vxlan',",
            "                    segmentation_id=None,",
            "                    lvid=lvid,",
            "                    distributed=True),",
            "            ] + self._expected_install_dvr_process(",
            "                port=self._port,",
            "                lvid=lvid,",
            "                ip_version=ip_version,",
            "                gateway_ip=gateway_ip)",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "            int_br.reset_mock()",
            "            tun_br.reset_mock()",
            "            self.agent.port_bound(self._compute_port,",
            "                                  self._net_uuid, 'vxlan',",
            "                                  None, None,",
            "                                  self._compute_fixed_ips,",
            "                                  device_owner, False)",
            "            int_br.assert_has_calls(",
            "                [",
            "                    mock.call.install_dvr_to_src_mac(",
            "                        network_type='vxlan',",
            "                        gateway_mac='aa:bb:cc:11:22:33',",
            "                        dst_mac=self._compute_port.vif_mac,",
            "                        dst_port=self._compute_port.ofport,",
            "                        vlan_tag=lvid,",
            "                    ),",
            "                ] + self._expected_port_bound(self._compute_port, lvid, False))",
            "            tun_br.assert_not_called()",
            "",
            "        int_br.reset_mock()",
            "        tun_br.reset_mock()",
            "        with mock.patch.object(self.agent, 'reclaim_local_vlan'),\\",
            "                mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={",
            "                                      'devices_up': [],",
            "                                      'devices_down': [",
            "                                          self._compute_port.vif_id],",
            "                                      'failed_devices_up': [],",
            "                                      'failed_devices_down': []}),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_devices['removed'] = self.agent.treat_devices_removed(",
            "                [self._compute_port.vif_id])",
            "            int_br.assert_has_calls([",
            "                mock.call.delete_dvr_to_src_mac(",
            "                    network_type='vxlan',",
            "                    vlan_tag=lvid,",
            "                    dst_mac=self._compute_port.vif_mac,",
            "                ),",
            "            ])",
            "            tun_br.assert_not_called()",
            "",
            "    def test_treat_devices_removed_for_dvr_with_compute_ports(self):",
            "        self._test_treat_devices_removed_for_dvr(",
            "            device_owner=DEVICE_OWNER_COMPUTE)",
            "        self._test_treat_devices_removed_for_dvr(",
            "            device_owner=DEVICE_OWNER_COMPUTE, ip_version=n_const.IP_VERSION_6)",
            "",
            "    def test_treat_devices_removed_for_dvr_with_dhcp_ports(self):",
            "        self._test_treat_devices_removed_for_dvr(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP)",
            "        self._test_treat_devices_removed_for_dvr(",
            "            device_owner=n_const.DEVICE_OWNER_DHCP,",
            "            ip_version=n_const.IP_VERSION_6)",
            "",
            "    def test_treat_devices_removed_for_dvr_csnat_port(self):",
            "        self._setup_for_dvr_test()",
            "        gateway_mac = 'aa:bb:cc:11:22:33'",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        int_br.set_db_attribute.return_value = True",
            "        int_br.db_get_val.return_value = {}",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_subnet_for_dvr',",
            "                               return_value={'gateway_ip': '1.1.1.1',",
            "                               'cidr': '1.1.1.0/24',",
            "                               'ip_version': n_const.IP_VERSION_4,",
            "                               'gateway_mac': gateway_mac}),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_ports_on_host_by_subnet',",
            "                                  return_value=[]),\\",
            "                mock.patch.object(self.agent.dvr_agent.int_br,",
            "                                  'get_vif_port_by_id',",
            "                                  return_value=self._port),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br):",
            "            self.agent.port_bound(",
            "                self._port, self._net_uuid, 'vxlan',",
            "                None, None, self._fixed_ips,",
            "                n_const.DEVICE_OWNER_ROUTER_SNAT,",
            "                False)",
            "            lvid = self.agent.vlan_manager.get(self._net_uuid).vlan",
            "            expected_on_int_br = [",
            "                mock.call.install_dvr_to_src_mac(",
            "                    network_type='vxlan',",
            "                    gateway_mac=gateway_mac,",
            "                    dst_mac=self._port.vif_mac,",
            "                    dst_port=self._port.ofport,",
            "                    vlan_tag=lvid,",
            "                ),",
            "            ] + self._expected_port_bound(self._port, lvid, is_dvr=False)",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            expected_on_tun_br = [",
            "                mock.call.provision_local_vlan(",
            "                    network_type='vxlan',",
            "                    lvid=lvid,",
            "                    segmentation_id=None,",
            "                    distributed=True,",
            "                ),",
            "            ]",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "",
            "        int_br.reset_mock()",
            "        tun_br.reset_mock()",
            "        with mock.patch.object(self.agent, 'reclaim_local_vlan'),\\",
            "                mock.patch.object(self.agent.plugin_rpc, 'update_device_list',",
            "                                  return_value={",
            "                                      'devices_up': [],",
            "                                      'devices_down': [self._port.vif_id],",
            "                                      'failed_devices_up': [],",
            "                                      'failed_devices_down': []}),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.int_br, 'get_vif_port_by_id',",
            "                                  return_value=None):",
            "            failed_devices = {'added': set(), 'removed': set()}",
            "            failed_devices['removed'] = self.agent.treat_devices_removed(",
            "                [self._port.vif_id])",
            "            expected_on_int_br = [",
            "                mock.call.delete_dvr_to_src_mac(",
            "                    network_type='vxlan',",
            "                    dst_mac=self._port.vif_mac,",
            "                    vlan_tag=lvid,",
            "                ),",
            "            ]",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "",
            "    def test_setup_dvr_flows_on_int_br(self):",
            "        self._setup_for_dvr_test()",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        with mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                                  'get_dvr_mac_address_list',",
            "                                  return_value=[{'host': 'cn1',",
            "                                  'mac_address': 'aa-bb-cc-dd-ee-ff'},",
            "                                  {'host': 'cn2',",
            "                                  'mac_address': '11-22-33-44-55-66'}]):",
            "            self.agent.dvr_agent.setup_dvr_flows_on_integ_br()",
            "            self.assertTrue(self.agent.dvr_agent.in_distributed_mode())",
            "            physical_networks = list(",
            "                self.agent.dvr_agent.bridge_mappings.keys())",
            "            ioport = self.agent.dvr_agent.int_ofports[physical_networks[0]]",
            "            expected_on_int_br = [",
            "                # setup_dvr_flows_on_integ_br",
            "                mock.call.setup_canary_table(),",
            "                mock.call.install_drop(table_id=constants.DVR_TO_SRC_MAC,",
            "                                       priority=1),",
            "                mock.call.install_drop(",
            "                    table_id=constants.DVR_TO_SRC_MAC_PHYSICAL,",
            "                    priority=1),",
            "                mock.call.install_drop(table_id=constants.LOCAL_SWITCHING,",
            "                                       priority=2,",
            "                                       in_port=ioport),",
            "            ]",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_not_called()",
            "",
            "    def test_get_dvr_mac_address(self):",
            "        self._setup_for_dvr_test()",
            "        self.agent.dvr_agent.dvr_mac_address = None",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_dvr_mac_address_by_host',",
            "                               return_value={'host': 'cn1',",
            "                                  'mac_address': 'aa-22-33-44-55-66'}):",
            "            self.agent.dvr_agent.get_dvr_mac_address()",
            "            self.assertEqual('aa:22:33:44:55:66',",
            "                             self.agent.dvr_agent.dvr_mac_address)",
            "            self.assertTrue(self.agent.dvr_agent.in_distributed_mode())",
            "",
            "    def test_get_dvr_mac_address_exception(self):",
            "        self._setup_for_dvr_test()",
            "        self.agent.dvr_agent.dvr_mac_address = None",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_dvr_mac_address_by_host',",
            "                               side_effect=oslo_messaging.RemoteError),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br):",
            "            with testtools.ExpectedException(SystemExit):",
            "                self.agent.dvr_agent.get_dvr_mac_address()",
            "                self.assertIsNone(self.agent.dvr_agent.dvr_mac_address)",
            "                self.assertFalse(self.agent.dvr_agent.in_distributed_mode())",
            "",
            "    def test_get_dvr_mac_address_retried(self):",
            "        valid_entry = {'host': 'cn1', 'mac_address': 'aa-22-33-44-55-66'}",
            "        raise_timeout = oslo_messaging.MessagingTimeout()",
            "        # Raise a timeout the first 2 times it calls get_dvr_mac_address()",
            "        self._setup_for_dvr_test()",
            "        self.agent.dvr_agent.dvr_mac_address = None",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_dvr_mac_address_by_host',",
            "                               side_effect=(raise_timeout, raise_timeout,",
            "                                            valid_entry)):",
            "            self.agent.dvr_agent.get_dvr_mac_address()",
            "            self.assertEqual('aa:22:33:44:55:66',",
            "                             self.agent.dvr_agent.dvr_mac_address)",
            "            self.assertTrue(self.agent.dvr_agent.in_distributed_mode())",
            "            self.assertEqual(self.agent.dvr_agent.plugin_rpc.",
            "                             get_dvr_mac_address_by_host.call_count, 3)",
            "",
            "    def test_get_dvr_mac_address_retried_max(self):",
            "        raise_timeout = oslo_messaging.MessagingTimeout()",
            "        # Raise a timeout every time until we give up, currently 5 tries",
            "        self._setup_for_dvr_test()",
            "        self.agent.dvr_agent.dvr_mac_address = None",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        with mock.patch.object(self.agent.dvr_agent.plugin_rpc,",
            "                               'get_dvr_mac_address_by_host',",
            "                               side_effect=raise_timeout),\\",
            "                mock.patch.object(utils, \"execute\"),\\",
            "                mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br):",
            "            with testtools.ExpectedException(SystemExit):",
            "                self.agent.dvr_agent.get_dvr_mac_address()",
            "                self.assertIsNone(self.agent.dvr_agent.dvr_mac_address)",
            "                self.assertFalse(self.agent.dvr_agent.in_distributed_mode())",
            "                self.assertEqual(self.agent.dvr_agent.plugin_rpc.",
            "                                 get_dvr_mac_address_by_host.call_count, 5)",
            "",
            "    def test_dvr_mac_address_update(self):",
            "        self._setup_for_dvr_test()",
            "        newhost = 'cn2'",
            "        newmac = 'aa:bb:cc:dd:ee:ff'",
            "        int_br = mock.create_autospec(self.agent.int_br)",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        phys_br = mock.create_autospec(self.br_phys_cls('br-phys'))",
            "        physical_network = 'physeth1'",
            "        with mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {physical_network: phys_br}):",
            "            self.agent.dvr_agent.\\",
            "                dvr_mac_address_update(",
            "                    dvr_macs=[{'host': newhost,",
            "                               'mac_address': newmac}])",
            "            expected_on_int_br = [",
            "                mock.call.add_dvr_mac_physical(",
            "                    mac=newmac,",
            "                    port=self.agent.int_ofports[physical_network]),",
            "                mock.call.add_dvr_mac_tun(",
            "                    mac=newmac,",
            "                    port=self.agent.patch_tun_ofport),",
            "            ]",
            "            expected_on_tun_br = [",
            "                mock.call.add_dvr_mac_tun(",
            "                    mac=newmac,",
            "                    port=self.agent.patch_int_ofport),",
            "            ]",
            "            expected_on_phys_br = [",
            "                mock.call.add_dvr_mac_physical(",
            "                    mac=newmac,",
            "                    port=self.agent.phys_ofports[physical_network]),",
            "            ]",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "            phys_br.assert_has_calls(expected_on_phys_br)",
            "        int_br.reset_mock()",
            "        tun_br.reset_mock()",
            "        phys_br.reset_mock()",
            "        with mock.patch.object(self.agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.phys_brs,",
            "                                {physical_network: phys_br}),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'int_br', new=int_br),\\",
            "                mock.patch.object(self.agent.dvr_agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.dict(self.agent.dvr_agent.phys_brs,",
            "                                {physical_network: phys_br}):",
            "            self.agent.dvr_agent.dvr_mac_address_update(dvr_macs=[])",
            "            expected_on_int_br = [",
            "                mock.call.remove_dvr_mac_vlan(",
            "                    mac=newmac),",
            "                mock.call.remove_dvr_mac_tun(",
            "                    mac=newmac,",
            "                    port=self.agent.patch_tun_ofport),",
            "            ]",
            "            expected_on_tun_br = [",
            "                mock.call.remove_dvr_mac_tun(",
            "                    mac=newmac),",
            "            ]",
            "            expected_on_phys_br = [",
            "                mock.call.remove_dvr_mac_vlan(",
            "                    mac=newmac),",
            "            ]",
            "            int_br.assert_has_calls(expected_on_int_br)",
            "            tun_br.assert_has_calls(expected_on_tun_br)",
            "            phys_br.assert_has_calls(expected_on_phys_br)",
            "",
            "    def test_ovs_restart(self):",
            "        self._setup_for_dvr_test()",
            "        reset_methods = (",
            "            'reset_ovs_parameters', 'reset_dvr_parameters',",
            "            'setup_dvr_flows_on_integ_br', 'setup_dvr_flows_on_tun_br',",
            "            'setup_dvr_flows_on_phys_br', 'setup_dvr_mac_flows_on_all_brs')",
            "        reset_mocks = [mock.patch.object(self.agent.dvr_agent, method).start()",
            "                       for method in reset_methods]",
            "        tun_br = mock.create_autospec(self.agent.tun_br)",
            "        with mock.patch.object(self.agent,",
            "                               'check_ovs_status',",
            "                               return_value=constants.OVS_RESTARTED),\\",
            "                mock.patch.object(self.agent,",
            "                                  '_agent_has_updates',",
            "                                  side_effect=TypeError('loop exit')),\\",
            "                mock.patch.object(self.agent, 'tun_br', new=tun_br),\\",
            "                mock.patch.object(self.agent, 'setup_physical_bridges'),\\",
            "                mock.patch.object(self.agent, 'setup_integration_br'),\\",
            "                mock.patch.object(self.agent, 'setup_tunnel_br'),\\",
            "                mock.patch.object(self.agent, 'state_rpc'), \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor'):",
            "            try:",
            "                self.agent.rpc_loop(polling_manager=mock.Mock())",
            "            except TypeError:",
            "                pass",
            "        self.assertTrue(all([x.called for x in reset_mocks]))",
            "",
            "    def test_rpc_loop_survives_error_in_check_canary_table(self):",
            "        with mock.patch.object(self.agent.int_br,",
            "                               'check_canary_table',",
            "                               side_effect=TypeError('borked')),\\",
            "                mock.patch.object(self.agent, '_check_and_handle_signal',",
            "                                  side_effect=[True, False]):",
            "            self.agent.rpc_loop(polling_manager=mock.Mock())",
            "",
            "    def _test_scan_ports_failure(self, scan_method_name):",
            "        with mock.patch.object(self.agent,",
            "                               'check_ovs_status',",
            "                               return_value=constants.OVS_RESTARTED),\\",
            "                mock.patch.object(self.agent, scan_method_name,",
            "                               side_effect=TypeError('broken')),\\",
            "                mock.patch.object(self.agent, '_agent_has_updates',",
            "                                  return_value=True),\\",
            "                mock.patch.object(self.agent, '_check_and_handle_signal',",
            "                                  side_effect=[True, False]),\\",
            "                mock.patch.object(self.agent, 'setup_physical_bridges'),\\",
            "                mock.patch.object(self.agent, 'setup_integration_br'),\\",
            "                mock.patch.object(self.agent, 'state_rpc'), \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor'):",
            "            # block RPC calls and bridge calls",
            "            self.agent.rpc_loop(polling_manager=mock.Mock())",
            "",
            "    def test_scan_ports_failure(self):",
            "        self._test_scan_ports_failure('scan_ports')",
            "",
            "    def test_scan_ancillary_ports_failure(self):",
            "        with mock.patch.object(self.agent, 'scan_ports'):",
            "            with mock.patch.object(self.agent, 'update_stale_ofport_rules'):",
            "                self.agent.ancillary_brs = mock.Mock()",
            "                self._test_scan_ports_failure('scan_ancillary_ports')",
            "",
            "    def test_ext_br_recreated(self):",
            "        self._setup_for_dvr_test()",
            "        reset_methods = (",
            "            'reset_ovs_parameters', 'reset_dvr_parameters',",
            "            'setup_dvr_flows_on_integ_br', 'setup_dvr_flows_on_tun_br',",
            "            'setup_dvr_flows_on_phys_br', 'setup_dvr_mac_flows_on_all_brs')",
            "        for method in reset_methods:",
            "            mock.patch.object(self.agent.dvr_agent, method).start()",
            "        bridge_mappings = {'physnet0': 'br-ex0',",
            "                           'physnet1': 'br-ex1'}",
            "        ex_br_mocks = [mock.Mock(br_name='br-ex0'),",
            "                       mock.Mock(br_name='br-ex1')]",
            "        phys_bridges = {'physnet0': ex_br_mocks[0],",
            "                        'physnet1': ex_br_mocks[1]},",
            "        bridges_added = ['br-ex0']",
            "        with mock.patch.object(self.agent, 'check_ovs_status',",
            "                               return_value=constants.OVS_NORMAL), \\",
            "                mock.patch.object(self.agent, '_agent_has_updates',",
            "                                  side_effect=TypeError('loop exit')), \\",
            "                mock.patch.dict(self.agent.bridge_mappings, bridge_mappings,",
            "                                clear=True), \\",
            "                mock.patch.dict(self.agent.phys_brs, phys_bridges,",
            "                                clear=True), \\",
            "                mock.patch.object(self.agent, 'setup_physical_bridges') as \\",
            "                setup_physical_bridges, \\",
            "                mock.patch.object(self.agent.ovs.ovsdb, 'idl_monitor') as \\",
            "                mock_idl_monitor:",
            "            mock_idl_monitor.bridges_added = bridges_added",
            "            try:",
            "                self.agent.rpc_loop(polling_manager=mock.Mock())",
            "            except TypeError:",
            "                pass",
            "        # Setup bridges should be called once even if it will raise Runtime",
            "        # Error because TypeError is raised in _agent_has_updates to stop",
            "        # agent after first loop iteration",
            "        setup_physical_bridges.assert_called_once_with({'physnet0': 'br-ex0'})",
            "        # Ensure dvr_agent methods were called correctly",
            "        self.agent.dvr_agent.reset_ovs_parameters.assert_called_once_with(",
            "            self.agent.int_br, self.agent.tun_br, self.agent.phys_brs,",
            "            self.agent.patch_int_ofport, self.agent.patch_tun_ofport)",
            "        self.agent.dvr_agent.reset_dvr_parameters.assert_called_once_with()",
            "        (self.agent.dvr_agent.setup_dvr_flows_on_phys_br.",
            "         assert_called_once_with({'physnet0': 'br-ex0'}))",
            "        (self.agent.dvr_agent.setup_dvr_flows_on_integ_br.",
            "            assert_called_once_with())",
            "        (self.agent.dvr_agent.setup_dvr_flows_on_tun_br.",
            "            assert_called_once_with())",
            "        (self.agent.dvr_agent.setup_dvr_mac_flows_on_all_brs.",
            "            assert_called_once_with())",
            "",
            "",
            "class TestOvsDvrNeutronAgentOSKen(TestOvsDvrNeutronAgent,",
            "                                ovs_test_base.OVSOSKenTestBase):",
            "    pass",
            "",
            "",
            "class TestValidateTunnelLocalIP(base.BaseTestCase):",
            "    def test_validate_local_ip_with_valid_ip(self):",
            "        mock_get_device_by_ip = mock.patch.object(",
            "            ip_lib.IPWrapper, 'get_device_by_ip').start()",
            "        ovs_agent.validate_local_ip(FAKE_IP1)",
            "        mock_get_device_by_ip.assert_called_once_with(FAKE_IP1)",
            "",
            "    def test_validate_local_ip_with_valid_ipv6(self):",
            "        mock_get_device_by_ip = mock.patch.object(",
            "            ip_lib.IPWrapper, 'get_device_by_ip').start()",
            "        ovs_agent.validate_local_ip(FAKE_IP6)",
            "        mock_get_device_by_ip.assert_called_once_with(FAKE_IP6)",
            "",
            "    def test_validate_local_ip_with_none_ip(self):",
            "        with testtools.ExpectedException(SystemExit):",
            "            ovs_agent.validate_local_ip(None)",
            "",
            "    def test_validate_local_ip_with_invalid_ip(self):",
            "        mock_get_device_by_ip = mock.patch.object(",
            "            ip_lib.IPWrapper, 'get_device_by_ip').start()",
            "        mock_get_device_by_ip.return_value = None",
            "        with testtools.ExpectedException(SystemExit):",
            "            ovs_agent.validate_local_ip(FAKE_IP1)",
            "        mock_get_device_by_ip.assert_called_once_with(FAKE_IP1)",
            "",
            "    def test_validate_local_ip_with_invalid_ipv6(self):",
            "        mock_get_device_by_ip = mock.patch.object(",
            "            ip_lib.IPWrapper, 'get_device_by_ip').start()",
            "        mock_get_device_by_ip.return_value = None",
            "        with testtools.ExpectedException(SystemExit):",
            "            ovs_agent.validate_local_ip(FAKE_IP6)",
            "        mock_get_device_by_ip.assert_called_once_with(FAKE_IP6)",
            "",
            "",
            "class TestOvsAgentTunnelName(base.BaseTestCase):",
            "    def test_get_tunnel_hash_invalid_address(self):",
            "        hashlen = n_const.DEVICE_NAME_MAX_LEN",
            "        self.assertIsNone(",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_hash('a.b.c.d', hashlen))",
            "",
            "    def test_get_tunnel_name_vxlan(self):",
            "        self.assertEqual(",
            "            'vxlan-7f000002',",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_name(",
            "                'vxlan', '127.0.0.1', '127.0.0.2'))",
            "",
            "    def test_get_tunnel_name_gre(self):",
            "        self.assertEqual(",
            "            'gre-7f000002',",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_name(",
            "                'gre', '127.0.0.1', '127.0.0.2'))",
            "",
            "    def test_get_tunnel_name_vxlan_ipv6(self):",
            "        self.assertEqual(",
            "            'vxlan-pehtjzksi',",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_name(",
            "                'vxlan', '2001:db8::1', '2001:db8::2'))",
            "",
            "    def test_get_tunnel_name_gre_ipv6(self):",
            "        self.assertEqual(",
            "            'gre-pehtjzksiqr',",
            "            ovs_agent.OVSNeutronAgent.get_tunnel_name(",
            "                'gre', '2001:db8::1', '2001:db8::2'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "885": [
                "TestOvsNeutronAgent",
                "_mock_treat_devices_added_updated"
            ],
            "903": [
                "TestOvsNeutronAgent",
                "test_treat_devices_added_updated_no_active_binding"
            ],
            "980": [
                "TestOvsNeutronAgent",
                "test_treat_devices_added_updated_skips_if_port_not_found"
            ],
            "998": [
                "TestOvsNeutronAgent",
                "test_treat_devices_added_failed_devices"
            ],
            "1029": [
                "TestOvsNeutronAgent",
                "test_treat_devices_added_updated_put_port_down"
            ],
            "1138": [
                "TestOvsNeutronAgent",
                "_test_process_network_ports"
            ],
            "3160": [
                "TestOvsDvrNeutronAgent",
                "_test_port_bound_for_dvr_on_physical_network"
            ],
            "3244": [
                "TestOvsDvrNeutronAgent",
                "_test_port_bound_for_dvr_on_vxlan_network"
            ],
            "3492": [
                "TestOvsDvrNeutronAgent",
                "_test_treat_devices_removed_for_dvr_interface"
            ],
            "3597": [
                "TestOvsDvrNeutronAgent",
                "_test_treat_devices_removed_for_dvr"
            ]
        },
        "addLocation": []
    },
    "neutron/tests/unit/plugins/ml2/drivers/openvswitch/agent/test_ovs_tunnel.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " #    under the License."
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " #"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+import collections"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import time"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from unittest import mock"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     import test_vlanmanager"
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+Switch = collections.namedtuple('Switch', ['br_name'])"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " # Useful global dummy variables."
            },
            "13": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " NET_UUID = '3faeebfe-5d37-11e1-a64b-000c29d5f0a7'"
            },
            "14": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " LS_ID = 420"
            },
            "15": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " VIF_ID = '404deaec-5d37-11e1-a64b-000c29d5f0a8'"
            },
            "16": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " VIF_MAC = '3c:09:24:1e:78:23'"
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " OFPORT_NUM = 1"
            },
            "18": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-VIF_PORT = ovs_lib.VifPort('port', OFPORT_NUM,"
            },
            "19": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                           VIF_ID, VIF_MAC, 'switch')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+VIF_PORT = ovs_lib.VifPort('port', OFPORT_NUM, VIF_ID, VIF_MAC,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+                           Switch(br_name='br_name'))"
            },
            "22": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " VIF_PORTS = {VIF_ID: VIF_PORT}"
            },
            "23": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " FIXED_IPS = [{'subnet_id': 'my-subnet-uuid',"
            },
            "24": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "               'ip_address': '1.1.1.1'}]"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 VMware, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "#",
            "",
            "import time",
            "from unittest import mock",
            "",
            "from neutron_lib import constants as n_const",
            "from oslo_config import cfg",
            "from oslo_log import log",
            "",
            "from neutron.agent.common import ip_lib",
            "from neutron.agent.common import ovs_lib",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants",
            "from neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_test_base",
            "from neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent \\",
            "    import test_vlanmanager",
            "",
            "",
            "# Useful global dummy variables.",
            "NET_UUID = '3faeebfe-5d37-11e1-a64b-000c29d5f0a7'",
            "LS_ID = 420",
            "LV_ID = 42",
            "LV_IDS = [42, 43]",
            "VIF_ID = '404deaec-5d37-11e1-a64b-000c29d5f0a8'",
            "VIF_MAC = '3c:09:24:1e:78:23'",
            "OFPORT_NUM = 1",
            "VIF_PORT = ovs_lib.VifPort('port', OFPORT_NUM,",
            "                           VIF_ID, VIF_MAC, 'switch')",
            "VIF_PORTS = {VIF_ID: VIF_PORT}",
            "FIXED_IPS = [{'subnet_id': 'my-subnet-uuid',",
            "              'ip_address': '1.1.1.1'}]",
            "VM_DEVICE_OWNER = n_const.DEVICE_OWNER_COMPUTE_PREFIX + 'fake'",
            "",
            "TUN_OFPORTS = {n_const.TYPE_GRE: {'ip1': '11', 'ip2': '12'}}",
            "",
            "BCAST_MAC = \"01:00:00:00:00:00/01:00:00:00:00:00\"",
            "UCAST_MAC = \"00:00:00:00:00:00/01:00:00:00:00:00\"",
            "",
            "",
            "class DummyPort(object):",
            "    def __init__(self, interface_id):",
            "        self.interface_id = interface_id",
            "",
            "",
            "class DummyVlanBinding(object):",
            "    def __init__(self, network_id, vlan_id):",
            "        self.network_id = network_id",
            "        self.vlan_id = vlan_id",
            "",
            "",
            "class TunnelTest(object):",
            "    USE_VETH_INTERCONNECTION = False",
            "    VETH_MTU = None",
            "",
            "    def setUp(self):",
            "        super(TunnelTest, self).setUp()",
            "        self.useFixture(test_vlanmanager.LocalVlanManagerFixture())",
            "        conn_patcher = mock.patch(",
            "            'neutron.agent.ovsdb.impl_idl._connection')",
            "        conn_patcher.start()",
            "        mock.patch(",
            "            'neutron.api.rpc.handlers.resources_rpc.ResourcesPullRpcApi'",
            "        ).start()",
            "        self.addCleanup(conn_patcher.stop)",
            "        cfg.CONF.set_default('firewall_driver',",
            "                             'neutron.agent.firewall.NoopFirewallDriver',",
            "                             group='SECURITYGROUP')",
            "        cfg.CONF.set_override('report_interval', 0, 'AGENT')",
            "        cfg.CONF.set_override('explicitly_egress_direct', True, 'AGENT')",
            "",
            "        self.INT_BRIDGE = 'integration_bridge'",
            "        self.TUN_BRIDGE = 'tunnel_bridge'",
            "        self.MAP_TUN_BRIDGE = 'tun_br_map'",
            "        self.AUX_BRIDGE = 'ancillary_bridge'",
            "        self.NET_MAPPING = ['net1:%s' % self.MAP_TUN_BRIDGE]",
            "        self.INT_OFPORT = 11111",
            "        self.TUN_OFPORT = 22222",
            "        self.MAP_TUN_INT_OFPORT = 33333",
            "        self.MAP_TUN_PHY_OFPORT = 44444",
            "",
            "        self.LVM_DATA = (",
            "            LV_ID, 'gre', None, LS_ID, VIF_PORTS)",
            "        self.LVM_FLAT_DATA = (",
            "            LV_ID, 'flat', 'net1', LS_ID, VIF_PORTS)",
            "        self.LVM_VLAN_DATA = (",
            "            LV_ID, 'vlan', 'net1', LS_ID, VIF_PORTS)",
            "",
            "        self.inta = mock.Mock()",
            "        self.intb = mock.Mock()",
            "",
            "        mock.patch.object(ovs_lib.BaseOVS, 'config',",
            "                          new_callable=mock.PropertyMock,",
            "                          return_value={}).start()",
            "",
            "        mock.patch('neutron.agent.ovsdb.impl_idl._connection').start()",
            "        self.ovs_bridges = {",
            "            self.INT_BRIDGE: mock.create_autospec(",
            "                self.br_int_cls('br-int')),",
            "            self.TUN_BRIDGE: mock.create_autospec(",
            "                self.br_tun_cls('br-tun')),",
            "            self.MAP_TUN_BRIDGE: mock.create_autospec(",
            "                self.br_phys_cls('br-phys')),",
            "            self.AUX_BRIDGE: mock.create_autospec(",
            "                ovs_lib.OVSBridge('br-aux')),",
            "        }",
            "        self.ovs_int_ofports = {",
            "            'patch-tun': self.TUN_OFPORT,",
            "            'int-%s' % self.MAP_TUN_BRIDGE: self.MAP_TUN_INT_OFPORT",
            "        }",
            "",
            "        mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                   'has_alive_neutron_server').start()",
            "",
            "        def lookup_br(br_name, *args, **kwargs):",
            "            return self.ovs_bridges[br_name]",
            "",
            "        self.mock_int_bridge_cls = mock.patch(self._BR_INT_CLASS,",
            "                                              autospec=True).start()",
            "        self.mock_int_bridge_cls.side_effect = lookup_br",
            "        self.mock_phys_bridge_cls = mock.patch(self._BR_PHYS_CLASS,",
            "                                               autospec=True).start()",
            "        self.mock_phys_bridge_cls.side_effect = lookup_br",
            "        self.mock_tun_bridge_cls = mock.patch(self._BR_TUN_CLASS,",
            "                                              autospec=True).start()",
            "        self.mock_tun_bridge_cls.side_effect = lookup_br",
            "        self.mock_aux_bridge_cls = mock.patch(",
            "            'neutron.agent.common.ovs_lib.OVSBridge',",
            "            autospec=True).start()",
            "        self.mock_aux_bridge_cls.side_effect = lookup_br",
            "",
            "        self.mock_int_bridge = self.ovs_bridges[self.INT_BRIDGE]",
            "        self.mock_int_bridge.add_port.return_value = self.MAP_TUN_INT_OFPORT",
            "        self.mock_int_bridge.add_patch_port.side_effect = (",
            "            lambda tap, peer: self.ovs_int_ofports[tap])",
            "        self.mock_int_bridge.port_exists.return_value = False",
            "        self.mock_int_bridge.get_vif_ports.return_value = []",
            "        self.mock_int_bridge.get_ports_attributes.return_value = []",
            "        self.mock_int_bridge.db_get_val.return_value = {}",
            "",
            "        self.mock_map_tun_bridge = self.ovs_bridges[self.MAP_TUN_BRIDGE]",
            "        self.mock_map_tun_bridge.br_name = self.MAP_TUN_BRIDGE",
            "        self.mock_map_tun_bridge.add_port.return_value = (",
            "            self.MAP_TUN_PHY_OFPORT)",
            "        self.mock_map_tun_bridge.add_patch_port.return_value = (",
            "            self.MAP_TUN_PHY_OFPORT)",
            "        self.mock_map_tun_bridge.port_exists.return_value = False",
            "",
            "        self.mock_tun_bridge = self.ovs_bridges[self.TUN_BRIDGE]",
            "        self.mock_tun_bridge.add_port.return_value = self.INT_OFPORT",
            "        self.mock_tun_bridge.add_patch_port.return_value = self.INT_OFPORT",
            "",
            "        self.ipdevice = mock.patch.object(ip_lib, 'IPDevice').start()",
            "",
            "        self.ipwrapper = mock.patch.object(ip_lib, 'IPWrapper').start()",
            "        add_veth = self.ipwrapper.return_value.add_veth",
            "        add_veth.return_value = [self.inta, self.intb]",
            "",
            "        self.get_bridges = mock.patch.object(ovs_lib.BaseOVS,",
            "                                             'get_bridges').start()",
            "        self.get_bridges.return_value = [self.INT_BRIDGE,",
            "                                         self.TUN_BRIDGE,",
            "                                         self.MAP_TUN_BRIDGE,",
            "                                         self.AUX_BRIDGE]",
            "        self.get_bridge_external_bridge_id = mock.patch.object(",
            "            ovs_lib.BaseOVS,",
            "            'get_bridge_external_bridge_id').start()",
            "        self.get_bridge_external_bridge_id.side_effect = (",
            "            lambda bridge, log_errors: bridge if bridge in self.ovs_bridges",
            "            else None)",
            "",
            "        self.execute = mock.patch('neutron.agent.common.utils.execute').start()",
            "        self.mock_check_bridge_datapath_id = mock.patch.object(",
            "            self.mod_agent.OVSNeutronAgent,",
            "            '_check_bridge_datapath_id').start()",
            "        self._define_expected_calls()",
            "",
            "    def _define_expected_calls(self, arp_responder=False, igmp_snooping=False):",
            "        self.mock_int_bridge_cls_expected = [",
            "            mock.call(self.INT_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "        self.mock_phys_bridge_cls_expected = [",
            "            mock.call(self.MAP_TUN_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "        self.mock_tun_bridge_cls_expected = [",
            "            mock.call(self.TUN_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "",
            "        self.mock_int_bridge = self.ovs_bridges[self.INT_BRIDGE]",
            "        self.mock_int_bridge_expected = [",
            "            mock.call.create(),",
            "            mock.call.set_secure_mode(),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.set_igmp_snooping_state(igmp_snooping),",
            "            mock.call.setup_default_table(),",
            "        ]",
            "",
            "        self.mock_map_tun_bridge_expected = [",
            "            mock.call.create(),",
            "            mock.call.set_secure_mode(),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.setup_default_table(),",
            "            mock.call.port_exists('phy-%s' % self.MAP_TUN_BRIDGE),",
            "            mock.call.add_patch_port('phy-%s' % self.MAP_TUN_BRIDGE,",
            "                                     constants.NONEXISTENT_PEER),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.db_get_val('Interface', 'int-%s' % self.MAP_TUN_BRIDGE,",
            "                                 'type', log_errors=False),",
            "            mock.call.port_exists('int-%s' % self.MAP_TUN_BRIDGE),",
            "            mock.call.add_patch_port('int-%s' % self.MAP_TUN_BRIDGE,",
            "                                     constants.NONEXISTENT_PEER),",
            "        ]",
            "",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.drop_port(in_port=self.MAP_TUN_INT_OFPORT),",
            "            mock.call.set_db_attribute(",
            "                'Interface', 'int-%s' % self.MAP_TUN_BRIDGE,",
            "                'options', {'peer': 'phy-%s' % self.MAP_TUN_BRIDGE}),",
            "        ]",
            "        self.mock_map_tun_bridge_expected += [",
            "            mock.call.drop_port(in_port=self.MAP_TUN_PHY_OFPORT),",
            "            mock.call.set_db_attribute(",
            "                'Interface', 'phy-%s' % self.MAP_TUN_BRIDGE,",
            "                'options', {'peer': 'int-%s' % self.MAP_TUN_BRIDGE}),",
            "        ]",
            "",
            "        self.mock_aux_bridge = self.ovs_bridges[self.AUX_BRIDGE]",
            "        self.mock_aux_bridge_expected = [",
            "        ]",
            "",
            "        self.mock_tun_bridge_expected = [",
            "            mock.call.create(secure_mode=True),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.port_exists('patch-int'),",
            "            mock.ANY,",
            "            mock.call.add_patch_port('patch-int', 'patch-tun'),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.port_exists('patch-tun'),",
            "            mock.call.add_patch_port('patch-tun', 'patch-int'),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.get_vif_ports((ovs_lib.INVALID_OFPORT,",
            "                                     ovs_lib.UNASSIGNED_OFPORT)),",
            "            mock.call.get_ports_attributes(",
            "                'Port', columns=['name', 'other_config', 'tag'], ports=[])",
            "        ]",
            "",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.setup_default_table(self.INT_OFPORT, arp_responder),",
            "        ]",
            "",
            "        self.ipdevice_expected = []",
            "        self.ipwrapper_expected = [mock.call()]",
            "",
            "        self.get_bridges_expected = [mock.call(), mock.call()]",
            "",
            "        self.inta_expected = []",
            "        self.intb_expected = []",
            "        self.execute_expected = []",
            "",
            "    def _build_agent(self, **config_opts_agent):",
            "        \"\"\"Configure and initialize OVS agent.",
            "",
            "        :param config_opts_agent: a dict with options to override the",
            "               default values for the AGENT group.",
            "        \"\"\"",
            "        bridge_classes = {",
            "            'br_int': self.mock_int_bridge_cls,",
            "            'br_phys': self.mock_phys_bridge_cls,",
            "            'br_tun': self.mock_tun_bridge_cls,",
            "        }",
            "        cfg.CONF.set_override('integration_bridge', self.INT_BRIDGE, 'OVS')",
            "        cfg.CONF.set_override('tunnel_bridge', self.TUN_BRIDGE, 'OVS')",
            "        cfg.CONF.set_override('local_ip', '10.0.0.1', 'OVS')",
            "        cfg.CONF.set_override('bridge_mappings', self.NET_MAPPING, 'OVS')",
            "        cfg.CONF.set_override('polling_interval', 2, 'AGENT')",
            "        cfg.CONF.set_override('tunnel_types', ['gre'], 'AGENT')",
            "        cfg.CONF.set_override('veth_mtu', self.VETH_MTU, 'AGENT')",
            "        cfg.CONF.set_override('minimize_polling', False, 'AGENT')",
            "        cfg.CONF.set_override('use_veth_interconnection',",
            "                              self.USE_VETH_INTERCONNECTION, 'OVS')",
            "",
            "        for k, v in config_opts_agent.items():",
            "            cfg.CONF.set_override(k, v, 'AGENT')",
            "",
            "        ext_mgr = mock.Mock()",
            "        agent = self.mod_agent.OVSNeutronAgent(",
            "            bridge_classes, ext_mgr, cfg.CONF)",
            "        mock.patch.object(agent.ovs.ovsdb, 'idl_monitor').start()",
            "        return agent",
            "",
            "    def _verify_mock_call(self, mock_obj, expected):",
            "        mock_obj.assert_has_calls(expected)",
            "        self.assertEqual(expected, mock_obj.mock_calls)",
            "",
            "    def _verify_mock_calls(self):",
            "        self._verify_mock_call(self.mock_int_bridge_cls,",
            "                               self.mock_int_bridge_cls_expected)",
            "        self._verify_mock_call(self.mock_tun_bridge_cls,",
            "                               self.mock_tun_bridge_cls_expected)",
            "        self._verify_mock_call(self.mock_phys_bridge_cls,",
            "                               self.mock_phys_bridge_cls_expected)",
            "        self._verify_mock_call(self.mock_int_bridge,",
            "                               self.mock_int_bridge_expected)",
            "        self._verify_mock_call(self.mock_map_tun_bridge,",
            "                               self.mock_map_tun_bridge_expected)",
            "        self._verify_mock_call(self.mock_tun_bridge,",
            "                               self.mock_tun_bridge_expected)",
            "        self._verify_mock_call(self.mock_aux_bridge,",
            "                               self.mock_aux_bridge_expected)",
            "        self._verify_mock_call(self.ipdevice, self.ipdevice_expected)",
            "        self._verify_mock_call(self.ipwrapper, self.ipwrapper_expected)",
            "        self._verify_mock_call(self.get_bridges, self.get_bridges_expected)",
            "        self._verify_mock_call(self.inta, self.inta_expected)",
            "        self._verify_mock_call(self.intb, self.intb_expected)",
            "        self._verify_mock_call(self.execute, self.execute_expected)",
            "",
            "    def test_construct(self):",
            "        agent = self._build_agent()",
            "        self.assertEqual(agent.agent_id, 'ovs-agent-%s' % cfg.CONF.host)",
            "        self._verify_mock_calls()",
            "",
            "    # TODO(ethuleau): Initially, local ARP responder is be dependent to the",
            "    #                 ML2 l2 population mechanism driver.",
            "    #                 The next two tests use l2_pop flag to test ARP responder",
            "    def test_construct_with_arp_responder(self):",
            "        self._build_agent(l2_population=True, arp_responder=True)",
            "        self._define_expected_calls(arp_responder=True)",
            "        self._verify_mock_calls()",
            "",
            "    def test_construct_with_igmp_snooping(self):",
            "        cfg.CONF.set_override('igmp_snooping_enable', True, 'OVS')",
            "        self._build_agent()",
            "        self._define_expected_calls(igmp_snooping=True)",
            "        self._verify_mock_calls()",
            "",
            "    def test_construct_without_arp_responder(self):",
            "        self._build_agent(l2_population=False, arp_responder=True)",
            "        self._verify_mock_calls()",
            "",
            "    def test_construct_vxlan(self):",
            "        self._build_agent(tunnel_types=['vxlan'])",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan(self):",
            "        ofports = list(TUN_OFPORTS[n_const.TYPE_GRE].values())",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.install_flood_to_tun(LV_ID, LS_ID, ofports),",
            "            mock.call.provision_local_vlan(",
            "                network_type=n_const.TYPE_GRE,",
            "                lvid=LV_ID,",
            "                segmentation_id=LS_ID),",
            "        ]",
            "",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set([LV_ID])",
            "        a.tun_br_ofports = TUN_OFPORTS",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_GRE, None, LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan_flat(self):",
            "        self.mock_map_tun_bridge_expected.append(",
            "            mock.call.provision_local_vlan(",
            "                port=self.MAP_TUN_PHY_OFPORT,",
            "                lvid=LV_ID,",
            "                segmentation_id=None,",
            "                distributed=False))",
            "        self.mock_int_bridge_expected.append(",
            "            mock.call.provision_local_vlan(",
            "                port=self.INT_OFPORT,",
            "                lvid=LV_ID,",
            "                segmentation_id=None))",
            "",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set([LV_ID])",
            "        a.phys_brs['net1'] = self.mock_map_tun_bridge",
            "        a.phys_ofports['net1'] = self.MAP_TUN_PHY_OFPORT",
            "        a.int_ofports['net1'] = self.INT_OFPORT",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_FLAT, 'net1', LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan_flat_fail(self):",
            "        a = self._build_agent()",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_FLAT, 'net2', LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan_vlan(self):",
            "        self.mock_map_tun_bridge_expected.append(",
            "            mock.call.provision_local_vlan(",
            "                port=self.MAP_TUN_PHY_OFPORT,",
            "                lvid=LV_ID,",
            "                segmentation_id=LS_ID,",
            "                distributed=False))",
            "        self.mock_int_bridge_expected.append(",
            "            mock.call.provision_local_vlan(",
            "                port=self.INT_OFPORT,",
            "                lvid=LV_ID,",
            "                segmentation_id=LS_ID))",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set([LV_ID])",
            "        a.phys_brs['net1'] = self.mock_map_tun_bridge",
            "        a.phys_ofports['net1'] = self.MAP_TUN_PHY_OFPORT",
            "        a.int_ofports['net1'] = self.INT_OFPORT",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_VLAN, 'net1', LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan_vlan_fail(self):",
            "        a = self._build_agent()",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_VLAN, 'net2', LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_reclaim_local_vlan(self):",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.reclaim_local_vlan(network_type='gre',",
            "                                         segmentation_id=LS_ID),",
            "            mock.call.delete_flood_to_tun(LV_ID),",
            "            mock.call.delete_unicast_to_tun(LV_ID, None),",
            "            mock.call.delete_arp_responder(LV_ID, None),",
            "        ]",
            "",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set()",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_DATA)",
            "        a.reclaim_local_vlan(NET_UUID)",
            "        self.assertIn(self.LVM_DATA[0], a.available_local_vlans)",
            "        self._verify_mock_calls()",
            "",
            "    def test_reclaim_local_vlan_flat(self):",
            "        self.mock_map_tun_bridge_expected.append(",
            "            mock.call.reclaim_local_vlan(",
            "                port=self.MAP_TUN_PHY_OFPORT,",
            "                lvid=self.LVM_FLAT_DATA[0]))",
            "        self.mock_int_bridge_expected.append(",
            "            mock.call.reclaim_local_vlan(",
            "                port=self.INT_OFPORT,",
            "                segmentation_id=None))",
            "        a = self._build_agent()",
            "        a.phys_brs['net1'] = self.mock_map_tun_bridge",
            "        a.phys_ofports['net1'] = self.MAP_TUN_PHY_OFPORT",
            "        a.int_ofports['net1'] = self.INT_OFPORT",
            "",
            "        a.available_local_vlans = set()",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_FLAT_DATA)",
            "        a.reclaim_local_vlan(NET_UUID)",
            "        self.assertIn(self.LVM_FLAT_DATA[0], a.available_local_vlans)",
            "        self._verify_mock_calls()",
            "",
            "    def test_reclaim_local_vlan_vlan(self):",
            "        self.mock_map_tun_bridge_expected.append(",
            "            mock.call.reclaim_local_vlan(",
            "                port=self.MAP_TUN_PHY_OFPORT,",
            "                lvid=self.LVM_VLAN_DATA[0]))",
            "        self.mock_int_bridge_expected.append(",
            "            mock.call.reclaim_local_vlan(",
            "                port=self.INT_OFPORT,",
            "                segmentation_id=LS_ID))",
            "        a = self._build_agent()",
            "        a.phys_brs['net1'] = self.mock_map_tun_bridge",
            "        a.phys_ofports['net1'] = self.MAP_TUN_PHY_OFPORT",
            "        a.int_ofports['net1'] = self.INT_OFPORT",
            "",
            "        a.available_local_vlans = set()",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_VLAN_DATA)",
            "        a.reclaim_local_vlan(NET_UUID)",
            "        self.assertIn(self.LVM_VLAN_DATA[0], a.available_local_vlans)",
            "        self._verify_mock_calls()",
            "",
            "    def test_port_bound(self):",
            "        vlan_mapping = {'segmentation_id': str(LS_ID),",
            "                        'physical_network': 'None',",
            "                        'net_uuid': NET_UUID,",
            "                        'network_type': 'gre'}",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.db_get_val('Port', 'port', 'other_config'),",
            "            mock.call.set_db_attribute('Port', VIF_PORT.port_name,",
            "                                       'other_config',",
            "                                       vlan_mapping)]",
            "",
            "        a = self._build_agent()",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_DATA)",
            "        a.local_dvr_map = {}",
            "        self.ovs_bridges[self.INT_BRIDGE].db_get_val.return_value = {}",
            "        a.port_bound(VIF_PORT, NET_UUID, 'gre', None, LS_ID,",
            "                     FIXED_IPS, VM_DEVICE_OWNER, False)",
            "        self._verify_mock_calls()",
            "",
            "    def test_port_unbound(self):",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'reclaim_local_vlan') as reclaim_local_vlan:",
            "            a = self._build_agent()",
            "            a.vlan_manager.add(NET_UUID, *self.LVM_DATA)",
            "            a.port_unbound(VIF_ID, NET_UUID)",
            "",
            "        reclaim_local_vlan.assert_called_once_with(NET_UUID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_port_dead(self):",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.db_get_val('Port', VIF_PORT.port_name, 'tag',",
            "                                 log_errors=True),",
            "            mock.call.set_db_attribute(",
            "                'Port', VIF_PORT.port_name,",
            "                'tag', constants.DEAD_VLAN_TAG,",
            "                log_errors=True),",
            "            mock.call.drop_port(in_port=VIF_PORT.ofport),",
            "        ]",
            "",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set([LV_ID])",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_DATA)",
            "        self.ovs_bridges[self.INT_BRIDGE].db_get_val.return_value = mock.Mock()",
            "        a.port_dead(VIF_PORT)",
            "        self._verify_mock_calls()",
            "",
            "    def test_tunnel_update(self):",
            "        tunnel_port = '9999'",
            "        self.mock_tun_bridge.add_tunnel_port.return_value = tunnel_port",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.add_tunnel_port('gre-0a000a01', '10.0.10.1', '10.0.0.1',",
            "                                      'gre', 4789, True, False, None),",
            "            mock.call.setup_tunnel_port('gre', tunnel_port),",
            "        ]",
            "",
            "        a = self._build_agent()",
            "        a.tunnel_update(",
            "            mock.sentinel.ctx, tunnel_ip='10.0.10.1',",
            "            tunnel_type=n_const.TYPE_GRE)",
            "        self._verify_mock_calls()",
            "",
            "    def test_tunnel_update_self(self):",
            "        a = self._build_agent()",
            "        a.tunnel_update(",
            "            mock.sentinel.ctx, tunnel_ip='10.0.0.1')",
            "        self._verify_mock_calls()",
            "",
            "    def test_daemon_loop(self):",
            "        reply_ge_1 = {'added': [{'name': 'tap0', 'ofport': 3,",
            "                                 'external_ids': {",
            "                                     'attached-mac': 'test_mac'}}],",
            "                      'removed': []}",
            "",
            "        reply_ge_2 = {'added': [],",
            "                      'removed': [{'name': 'tap0', 'ofport': 3,",
            "                                   'external_ids': {",
            "                                       'attached-mac': 'test_mac'}}]}",
            "",
            "        reply_pe_1 = {'current': set(['tap0']),",
            "                      'added': set(['tap0']),",
            "                      'removed': set([])}",
            "",
            "        reply_pe_2 = {'current': set([]),",
            "                      'added': set([]),",
            "                      'removed': set(['tap0'])}",
            "",
            "        reply_ancillary = {'current': set([]),",
            "                           'added': set([]),",
            "                           'removed': set([])}",
            "",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.check_canary_table(),",
            "            mock.call.deferred(full_ordered=True, use_bundle=True),",
            "            mock.call.deferred().__enter__(),",
            "            mock.call.deferred().__exit__(None, None, None),",
            "            mock.call.cleanup_flows(),",
            "            mock.call.check_canary_table(),",
            "            mock.call.deferred(full_ordered=True, use_bundle=True),",
            "            mock.call.deferred().__enter__(),",
            "            mock.call.deferred().__exit__(None, None, None),",
            "        ]",
            "        self.mock_map_tun_bridge_expected += [",
            "            mock.call.cleanup_flows(),",
            "        ]",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.cleanup_flows()",
            "        ]",
            "        # No cleanup is expected on ancillary bridge",
            "",
            "        self.ovs_bridges[self.INT_BRIDGE].check_canary_table.return_value = \\",
            "            constants.OVS_NORMAL",
            "        with mock.patch.object(log.KeywordArgumentAdapter,",
            "                               'exception') as log_exception,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'process_ports_events') as process_p_events,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'process_network_ports') as process_network_ports,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'tunnel_sync'),\\",
            "                mock.patch.object(time, 'sleep'),\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'update_stale_ofport_rules') as update_stale:",
            "            log_exception.side_effect = Exception(",
            "                'Fake exception to get out of the loop')",
            "            update_stale.return_value = []",
            "            devices_not_ready = set()",
            "            process_p_events.side_effect = [",
            "                (reply_pe_1, reply_ancillary, devices_not_ready),",
            "                (reply_pe_2, reply_ancillary, devices_not_ready)]",
            "            interface_polling = mock.Mock()",
            "            interface_polling.get_events.side_effect = [reply_ge_1, reply_ge_2]",
            "            failed_devices = {'removed': set([]), 'added': set([])}",
            "            failed_ancillary_devices = {'removed': set([]), 'added': set([])}",
            "            process_network_ports.side_effect = [",
            "                failed_devices,",
            "                Exception('Fake exception to get out of the loop')]",
            "",
            "            n_agent = self._build_agent()",
            "",
            "            # Hack to test loop",
            "            # We start method and expect it will raise after 2nd loop",
            "            # If something goes wrong, assert_has_calls below will catch it",
            "            try:",
            "                n_agent.rpc_loop(interface_polling)",
            "            except Exception:",
            "                pass",
            "",
            "            # FIXME(salv-orlando): There should not be assertions on log",
            "            # messages",
            "            log_exception.assert_called_once_with(",
            "                \"Error while processing VIF ports\")",
            "            process_p_events.assert_has_calls([",
            "                mock.call(reply_ge_1, set(), set(), devices_not_ready,",
            "                          failed_devices, failed_ancillary_devices, set()),",
            "                mock.call(reply_ge_2, set(['tap0']), set(), devices_not_ready,",
            "                          failed_devices, failed_ancillary_devices,",
            "                          set())",
            "            ])",
            "            process_network_ports.assert_has_calls([",
            "                mock.call({'current': set(['tap0']),",
            "                           'removed': set([]),",
            "                           'added': set(['tap0'])}, False),",
            "            ])",
            "",
            "            self.assertTrue(update_stale.called)",
            "            self._verify_mock_calls()",
            "",
            "",
            "class TunnelTestOSKen(TunnelTest, ovs_test_base.OVSOSKenTestBase):",
            "    pass",
            "",
            "",
            "class TunnelTestUseVethInterco(TunnelTest):",
            "    USE_VETH_INTERCONNECTION = True",
            "",
            "    def _define_expected_calls(self, arp_responder=False, igmp_snooping=False):",
            "        self.mock_int_bridge_cls_expected = [",
            "            mock.call(self.INT_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "        self.mock_phys_bridge_cls_expected = [",
            "            mock.call(self.MAP_TUN_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "        self.mock_tun_bridge_cls_expected = [",
            "            mock.call(self.TUN_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "",
            "        self.mock_int_bridge_expected = [",
            "            mock.call.create(),",
            "            mock.call.set_secure_mode(),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.set_igmp_snooping_state(igmp_snooping),",
            "            mock.call.setup_default_table(),",
            "        ]",
            "",
            "        self.mock_map_tun_bridge_expected = [",
            "            mock.call.create(),",
            "            mock.call.set_secure_mode(),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.setup_default_table(),",
            "            mock.call.add_port('phy-%s' % self.MAP_TUN_BRIDGE),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.db_get_val('Interface', 'int-%s' % self.MAP_TUN_BRIDGE,",
            "                                 'type', log_errors=False),",
            "            mock.call.add_port('int-%s' % self.MAP_TUN_BRIDGE)",
            "        ]",
            "",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.drop_port(in_port=self.MAP_TUN_INT_OFPORT),",
            "        ]",
            "        self.mock_map_tun_bridge_expected += [",
            "            mock.call.drop_port(in_port=self.MAP_TUN_PHY_OFPORT),",
            "        ]",
            "",
            "        self.mock_aux_bridge = self.ovs_bridges[self.AUX_BRIDGE]",
            "        self.mock_aux_bridge_expected = [",
            "        ]",
            "",
            "        self.mock_tun_bridge_expected = [",
            "            mock.call.create(secure_mode=True),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.port_exists('patch-int'),",
            "            mock.ANY,",
            "            mock.call.add_patch_port('patch-int', 'patch-tun'),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.port_exists('patch-tun'),",
            "            mock.call.add_patch_port('patch-tun', 'patch-int')",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.get_vif_ports((ovs_lib.INVALID_OFPORT,",
            "                                     ovs_lib.UNASSIGNED_OFPORT)),",
            "            mock.call.get_ports_attributes(",
            "                'Port', columns=['name', 'other_config', 'tag'], ports=[])",
            "        ]",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.setup_default_table(self.INT_OFPORT, arp_responder),",
            "        ]",
            "",
            "        self.ipdevice_expected = [",
            "            mock.call('int-%s' % self.MAP_TUN_BRIDGE),",
            "            mock.call().exists(),",
            "            mock.ANY,",
            "            mock.call().link.delete()",
            "        ]",
            "        self.ipwrapper_expected = [",
            "            mock.call(),",
            "            mock.call().add_veth('int-%s' % self.MAP_TUN_BRIDGE,",
            "                                 'phy-%s' % self.MAP_TUN_BRIDGE)",
            "        ]",
            "",
            "        self.get_bridges_expected = [mock.call(), mock.call()]",
            "",
            "        self.inta_expected = [mock.call.link.set_up()]",
            "        self.intb_expected = [mock.call.link.set_up()]",
            "        self.execute_expected = [mock.call(['udevadm', 'settle',",
            "                                            '--timeout=10'])]",
            "",
            "",
            "class TunnelTestUseVethIntercoOSKen(TunnelTestUseVethInterco,",
            "                                  ovs_test_base.OVSOSKenTestBase):",
            "    pass",
            "",
            "",
            "class TunnelTestWithMTU(TunnelTestUseVethInterco):",
            "    VETH_MTU = 1500",
            "",
            "    def _define_expected_calls(self, arp_responder=False, igmp_snooping=False):",
            "        super(TunnelTestWithMTU, self)._define_expected_calls(",
            "            arp_responder, igmp_snooping)",
            "        self.inta_expected.append(mock.call.link.set_mtu(self.VETH_MTU))",
            "        self.intb_expected.append(mock.call.link.set_mtu(self.VETH_MTU))",
            "",
            "",
            "class TunnelTestWithMTUOSKen(TunnelTestWithMTU,",
            "                           ovs_test_base.OVSOSKenTestBase):",
            "    pass"
        ],
        "afterPatchFile": [
            "# Copyright 2012 VMware, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "#",
            "",
            "import collections",
            "import time",
            "from unittest import mock",
            "",
            "from neutron_lib import constants as n_const",
            "from oslo_config import cfg",
            "from oslo_log import log",
            "",
            "from neutron.agent.common import ip_lib",
            "from neutron.agent.common import ovs_lib",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants",
            "from neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent \\",
            "    import ovs_test_base",
            "from neutron.tests.unit.plugins.ml2.drivers.openvswitch.agent \\",
            "    import test_vlanmanager",
            "",
            "",
            "Switch = collections.namedtuple('Switch', ['br_name'])",
            "",
            "# Useful global dummy variables.",
            "NET_UUID = '3faeebfe-5d37-11e1-a64b-000c29d5f0a7'",
            "LS_ID = 420",
            "LV_ID = 42",
            "LV_IDS = [42, 43]",
            "VIF_ID = '404deaec-5d37-11e1-a64b-000c29d5f0a8'",
            "VIF_MAC = '3c:09:24:1e:78:23'",
            "OFPORT_NUM = 1",
            "VIF_PORT = ovs_lib.VifPort('port', OFPORT_NUM, VIF_ID, VIF_MAC,",
            "                           Switch(br_name='br_name'))",
            "VIF_PORTS = {VIF_ID: VIF_PORT}",
            "FIXED_IPS = [{'subnet_id': 'my-subnet-uuid',",
            "              'ip_address': '1.1.1.1'}]",
            "VM_DEVICE_OWNER = n_const.DEVICE_OWNER_COMPUTE_PREFIX + 'fake'",
            "",
            "TUN_OFPORTS = {n_const.TYPE_GRE: {'ip1': '11', 'ip2': '12'}}",
            "",
            "BCAST_MAC = \"01:00:00:00:00:00/01:00:00:00:00:00\"",
            "UCAST_MAC = \"00:00:00:00:00:00/01:00:00:00:00:00\"",
            "",
            "",
            "class DummyPort(object):",
            "    def __init__(self, interface_id):",
            "        self.interface_id = interface_id",
            "",
            "",
            "class DummyVlanBinding(object):",
            "    def __init__(self, network_id, vlan_id):",
            "        self.network_id = network_id",
            "        self.vlan_id = vlan_id",
            "",
            "",
            "class TunnelTest(object):",
            "    USE_VETH_INTERCONNECTION = False",
            "    VETH_MTU = None",
            "",
            "    def setUp(self):",
            "        super(TunnelTest, self).setUp()",
            "        self.useFixture(test_vlanmanager.LocalVlanManagerFixture())",
            "        conn_patcher = mock.patch(",
            "            'neutron.agent.ovsdb.impl_idl._connection')",
            "        conn_patcher.start()",
            "        mock.patch(",
            "            'neutron.api.rpc.handlers.resources_rpc.ResourcesPullRpcApi'",
            "        ).start()",
            "        self.addCleanup(conn_patcher.stop)",
            "        cfg.CONF.set_default('firewall_driver',",
            "                             'neutron.agent.firewall.NoopFirewallDriver',",
            "                             group='SECURITYGROUP')",
            "        cfg.CONF.set_override('report_interval', 0, 'AGENT')",
            "        cfg.CONF.set_override('explicitly_egress_direct', True, 'AGENT')",
            "",
            "        self.INT_BRIDGE = 'integration_bridge'",
            "        self.TUN_BRIDGE = 'tunnel_bridge'",
            "        self.MAP_TUN_BRIDGE = 'tun_br_map'",
            "        self.AUX_BRIDGE = 'ancillary_bridge'",
            "        self.NET_MAPPING = ['net1:%s' % self.MAP_TUN_BRIDGE]",
            "        self.INT_OFPORT = 11111",
            "        self.TUN_OFPORT = 22222",
            "        self.MAP_TUN_INT_OFPORT = 33333",
            "        self.MAP_TUN_PHY_OFPORT = 44444",
            "",
            "        self.LVM_DATA = (",
            "            LV_ID, 'gre', None, LS_ID, VIF_PORTS)",
            "        self.LVM_FLAT_DATA = (",
            "            LV_ID, 'flat', 'net1', LS_ID, VIF_PORTS)",
            "        self.LVM_VLAN_DATA = (",
            "            LV_ID, 'vlan', 'net1', LS_ID, VIF_PORTS)",
            "",
            "        self.inta = mock.Mock()",
            "        self.intb = mock.Mock()",
            "",
            "        mock.patch.object(ovs_lib.BaseOVS, 'config',",
            "                          new_callable=mock.PropertyMock,",
            "                          return_value={}).start()",
            "",
            "        mock.patch('neutron.agent.ovsdb.impl_idl._connection').start()",
            "        self.ovs_bridges = {",
            "            self.INT_BRIDGE: mock.create_autospec(",
            "                self.br_int_cls('br-int')),",
            "            self.TUN_BRIDGE: mock.create_autospec(",
            "                self.br_tun_cls('br-tun')),",
            "            self.MAP_TUN_BRIDGE: mock.create_autospec(",
            "                self.br_phys_cls('br-phys')),",
            "            self.AUX_BRIDGE: mock.create_autospec(",
            "                ovs_lib.OVSBridge('br-aux')),",
            "        }",
            "        self.ovs_int_ofports = {",
            "            'patch-tun': self.TUN_OFPORT,",
            "            'int-%s' % self.MAP_TUN_BRIDGE: self.MAP_TUN_INT_OFPORT",
            "        }",
            "",
            "        mock.patch('neutron.agent.rpc.PluginReportStateAPI.'",
            "                   'has_alive_neutron_server').start()",
            "",
            "        def lookup_br(br_name, *args, **kwargs):",
            "            return self.ovs_bridges[br_name]",
            "",
            "        self.mock_int_bridge_cls = mock.patch(self._BR_INT_CLASS,",
            "                                              autospec=True).start()",
            "        self.mock_int_bridge_cls.side_effect = lookup_br",
            "        self.mock_phys_bridge_cls = mock.patch(self._BR_PHYS_CLASS,",
            "                                               autospec=True).start()",
            "        self.mock_phys_bridge_cls.side_effect = lookup_br",
            "        self.mock_tun_bridge_cls = mock.patch(self._BR_TUN_CLASS,",
            "                                              autospec=True).start()",
            "        self.mock_tun_bridge_cls.side_effect = lookup_br",
            "        self.mock_aux_bridge_cls = mock.patch(",
            "            'neutron.agent.common.ovs_lib.OVSBridge',",
            "            autospec=True).start()",
            "        self.mock_aux_bridge_cls.side_effect = lookup_br",
            "",
            "        self.mock_int_bridge = self.ovs_bridges[self.INT_BRIDGE]",
            "        self.mock_int_bridge.add_port.return_value = self.MAP_TUN_INT_OFPORT",
            "        self.mock_int_bridge.add_patch_port.side_effect = (",
            "            lambda tap, peer: self.ovs_int_ofports[tap])",
            "        self.mock_int_bridge.port_exists.return_value = False",
            "        self.mock_int_bridge.get_vif_ports.return_value = []",
            "        self.mock_int_bridge.get_ports_attributes.return_value = []",
            "        self.mock_int_bridge.db_get_val.return_value = {}",
            "",
            "        self.mock_map_tun_bridge = self.ovs_bridges[self.MAP_TUN_BRIDGE]",
            "        self.mock_map_tun_bridge.br_name = self.MAP_TUN_BRIDGE",
            "        self.mock_map_tun_bridge.add_port.return_value = (",
            "            self.MAP_TUN_PHY_OFPORT)",
            "        self.mock_map_tun_bridge.add_patch_port.return_value = (",
            "            self.MAP_TUN_PHY_OFPORT)",
            "        self.mock_map_tun_bridge.port_exists.return_value = False",
            "",
            "        self.mock_tun_bridge = self.ovs_bridges[self.TUN_BRIDGE]",
            "        self.mock_tun_bridge.add_port.return_value = self.INT_OFPORT",
            "        self.mock_tun_bridge.add_patch_port.return_value = self.INT_OFPORT",
            "",
            "        self.ipdevice = mock.patch.object(ip_lib, 'IPDevice').start()",
            "",
            "        self.ipwrapper = mock.patch.object(ip_lib, 'IPWrapper').start()",
            "        add_veth = self.ipwrapper.return_value.add_veth",
            "        add_veth.return_value = [self.inta, self.intb]",
            "",
            "        self.get_bridges = mock.patch.object(ovs_lib.BaseOVS,",
            "                                             'get_bridges').start()",
            "        self.get_bridges.return_value = [self.INT_BRIDGE,",
            "                                         self.TUN_BRIDGE,",
            "                                         self.MAP_TUN_BRIDGE,",
            "                                         self.AUX_BRIDGE]",
            "        self.get_bridge_external_bridge_id = mock.patch.object(",
            "            ovs_lib.BaseOVS,",
            "            'get_bridge_external_bridge_id').start()",
            "        self.get_bridge_external_bridge_id.side_effect = (",
            "            lambda bridge, log_errors: bridge if bridge in self.ovs_bridges",
            "            else None)",
            "",
            "        self.execute = mock.patch('neutron.agent.common.utils.execute').start()",
            "        self.mock_check_bridge_datapath_id = mock.patch.object(",
            "            self.mod_agent.OVSNeutronAgent,",
            "            '_check_bridge_datapath_id').start()",
            "        self._define_expected_calls()",
            "",
            "    def _define_expected_calls(self, arp_responder=False, igmp_snooping=False):",
            "        self.mock_int_bridge_cls_expected = [",
            "            mock.call(self.INT_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "        self.mock_phys_bridge_cls_expected = [",
            "            mock.call(self.MAP_TUN_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "        self.mock_tun_bridge_cls_expected = [",
            "            mock.call(self.TUN_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "",
            "        self.mock_int_bridge = self.ovs_bridges[self.INT_BRIDGE]",
            "        self.mock_int_bridge_expected = [",
            "            mock.call.create(),",
            "            mock.call.set_secure_mode(),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.set_igmp_snooping_state(igmp_snooping),",
            "            mock.call.setup_default_table(),",
            "        ]",
            "",
            "        self.mock_map_tun_bridge_expected = [",
            "            mock.call.create(),",
            "            mock.call.set_secure_mode(),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.setup_default_table(),",
            "            mock.call.port_exists('phy-%s' % self.MAP_TUN_BRIDGE),",
            "            mock.call.add_patch_port('phy-%s' % self.MAP_TUN_BRIDGE,",
            "                                     constants.NONEXISTENT_PEER),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.db_get_val('Interface', 'int-%s' % self.MAP_TUN_BRIDGE,",
            "                                 'type', log_errors=False),",
            "            mock.call.port_exists('int-%s' % self.MAP_TUN_BRIDGE),",
            "            mock.call.add_patch_port('int-%s' % self.MAP_TUN_BRIDGE,",
            "                                     constants.NONEXISTENT_PEER),",
            "        ]",
            "",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.drop_port(in_port=self.MAP_TUN_INT_OFPORT),",
            "            mock.call.set_db_attribute(",
            "                'Interface', 'int-%s' % self.MAP_TUN_BRIDGE,",
            "                'options', {'peer': 'phy-%s' % self.MAP_TUN_BRIDGE}),",
            "        ]",
            "        self.mock_map_tun_bridge_expected += [",
            "            mock.call.drop_port(in_port=self.MAP_TUN_PHY_OFPORT),",
            "            mock.call.set_db_attribute(",
            "                'Interface', 'phy-%s' % self.MAP_TUN_BRIDGE,",
            "                'options', {'peer': 'int-%s' % self.MAP_TUN_BRIDGE}),",
            "        ]",
            "",
            "        self.mock_aux_bridge = self.ovs_bridges[self.AUX_BRIDGE]",
            "        self.mock_aux_bridge_expected = [",
            "        ]",
            "",
            "        self.mock_tun_bridge_expected = [",
            "            mock.call.create(secure_mode=True),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.port_exists('patch-int'),",
            "            mock.ANY,",
            "            mock.call.add_patch_port('patch-int', 'patch-tun'),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.port_exists('patch-tun'),",
            "            mock.call.add_patch_port('patch-tun', 'patch-int'),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.get_vif_ports((ovs_lib.INVALID_OFPORT,",
            "                                     ovs_lib.UNASSIGNED_OFPORT)),",
            "            mock.call.get_ports_attributes(",
            "                'Port', columns=['name', 'other_config', 'tag'], ports=[])",
            "        ]",
            "",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.setup_default_table(self.INT_OFPORT, arp_responder),",
            "        ]",
            "",
            "        self.ipdevice_expected = []",
            "        self.ipwrapper_expected = [mock.call()]",
            "",
            "        self.get_bridges_expected = [mock.call(), mock.call()]",
            "",
            "        self.inta_expected = []",
            "        self.intb_expected = []",
            "        self.execute_expected = []",
            "",
            "    def _build_agent(self, **config_opts_agent):",
            "        \"\"\"Configure and initialize OVS agent.",
            "",
            "        :param config_opts_agent: a dict with options to override the",
            "               default values for the AGENT group.",
            "        \"\"\"",
            "        bridge_classes = {",
            "            'br_int': self.mock_int_bridge_cls,",
            "            'br_phys': self.mock_phys_bridge_cls,",
            "            'br_tun': self.mock_tun_bridge_cls,",
            "        }",
            "        cfg.CONF.set_override('integration_bridge', self.INT_BRIDGE, 'OVS')",
            "        cfg.CONF.set_override('tunnel_bridge', self.TUN_BRIDGE, 'OVS')",
            "        cfg.CONF.set_override('local_ip', '10.0.0.1', 'OVS')",
            "        cfg.CONF.set_override('bridge_mappings', self.NET_MAPPING, 'OVS')",
            "        cfg.CONF.set_override('polling_interval', 2, 'AGENT')",
            "        cfg.CONF.set_override('tunnel_types', ['gre'], 'AGENT')",
            "        cfg.CONF.set_override('veth_mtu', self.VETH_MTU, 'AGENT')",
            "        cfg.CONF.set_override('minimize_polling', False, 'AGENT')",
            "        cfg.CONF.set_override('use_veth_interconnection',",
            "                              self.USE_VETH_INTERCONNECTION, 'OVS')",
            "",
            "        for k, v in config_opts_agent.items():",
            "            cfg.CONF.set_override(k, v, 'AGENT')",
            "",
            "        ext_mgr = mock.Mock()",
            "        agent = self.mod_agent.OVSNeutronAgent(",
            "            bridge_classes, ext_mgr, cfg.CONF)",
            "        mock.patch.object(agent.ovs.ovsdb, 'idl_monitor').start()",
            "        return agent",
            "",
            "    def _verify_mock_call(self, mock_obj, expected):",
            "        mock_obj.assert_has_calls(expected)",
            "        self.assertEqual(expected, mock_obj.mock_calls)",
            "",
            "    def _verify_mock_calls(self):",
            "        self._verify_mock_call(self.mock_int_bridge_cls,",
            "                               self.mock_int_bridge_cls_expected)",
            "        self._verify_mock_call(self.mock_tun_bridge_cls,",
            "                               self.mock_tun_bridge_cls_expected)",
            "        self._verify_mock_call(self.mock_phys_bridge_cls,",
            "                               self.mock_phys_bridge_cls_expected)",
            "        self._verify_mock_call(self.mock_int_bridge,",
            "                               self.mock_int_bridge_expected)",
            "        self._verify_mock_call(self.mock_map_tun_bridge,",
            "                               self.mock_map_tun_bridge_expected)",
            "        self._verify_mock_call(self.mock_tun_bridge,",
            "                               self.mock_tun_bridge_expected)",
            "        self._verify_mock_call(self.mock_aux_bridge,",
            "                               self.mock_aux_bridge_expected)",
            "        self._verify_mock_call(self.ipdevice, self.ipdevice_expected)",
            "        self._verify_mock_call(self.ipwrapper, self.ipwrapper_expected)",
            "        self._verify_mock_call(self.get_bridges, self.get_bridges_expected)",
            "        self._verify_mock_call(self.inta, self.inta_expected)",
            "        self._verify_mock_call(self.intb, self.intb_expected)",
            "        self._verify_mock_call(self.execute, self.execute_expected)",
            "",
            "    def test_construct(self):",
            "        agent = self._build_agent()",
            "        self.assertEqual(agent.agent_id, 'ovs-agent-%s' % cfg.CONF.host)",
            "        self._verify_mock_calls()",
            "",
            "    # TODO(ethuleau): Initially, local ARP responder is be dependent to the",
            "    #                 ML2 l2 population mechanism driver.",
            "    #                 The next two tests use l2_pop flag to test ARP responder",
            "    def test_construct_with_arp_responder(self):",
            "        self._build_agent(l2_population=True, arp_responder=True)",
            "        self._define_expected_calls(arp_responder=True)",
            "        self._verify_mock_calls()",
            "",
            "    def test_construct_with_igmp_snooping(self):",
            "        cfg.CONF.set_override('igmp_snooping_enable', True, 'OVS')",
            "        self._build_agent()",
            "        self._define_expected_calls(igmp_snooping=True)",
            "        self._verify_mock_calls()",
            "",
            "    def test_construct_without_arp_responder(self):",
            "        self._build_agent(l2_population=False, arp_responder=True)",
            "        self._verify_mock_calls()",
            "",
            "    def test_construct_vxlan(self):",
            "        self._build_agent(tunnel_types=['vxlan'])",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan(self):",
            "        ofports = list(TUN_OFPORTS[n_const.TYPE_GRE].values())",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.install_flood_to_tun(LV_ID, LS_ID, ofports),",
            "            mock.call.provision_local_vlan(",
            "                network_type=n_const.TYPE_GRE,",
            "                lvid=LV_ID,",
            "                segmentation_id=LS_ID),",
            "        ]",
            "",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set([LV_ID])",
            "        a.tun_br_ofports = TUN_OFPORTS",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_GRE, None, LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan_flat(self):",
            "        self.mock_map_tun_bridge_expected.append(",
            "            mock.call.provision_local_vlan(",
            "                port=self.MAP_TUN_PHY_OFPORT,",
            "                lvid=LV_ID,",
            "                segmentation_id=None,",
            "                distributed=False))",
            "        self.mock_int_bridge_expected.append(",
            "            mock.call.provision_local_vlan(",
            "                port=self.INT_OFPORT,",
            "                lvid=LV_ID,",
            "                segmentation_id=None))",
            "",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set([LV_ID])",
            "        a.phys_brs['net1'] = self.mock_map_tun_bridge",
            "        a.phys_ofports['net1'] = self.MAP_TUN_PHY_OFPORT",
            "        a.int_ofports['net1'] = self.INT_OFPORT",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_FLAT, 'net1', LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan_flat_fail(self):",
            "        a = self._build_agent()",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_FLAT, 'net2', LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan_vlan(self):",
            "        self.mock_map_tun_bridge_expected.append(",
            "            mock.call.provision_local_vlan(",
            "                port=self.MAP_TUN_PHY_OFPORT,",
            "                lvid=LV_ID,",
            "                segmentation_id=LS_ID,",
            "                distributed=False))",
            "        self.mock_int_bridge_expected.append(",
            "            mock.call.provision_local_vlan(",
            "                port=self.INT_OFPORT,",
            "                lvid=LV_ID,",
            "                segmentation_id=LS_ID))",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set([LV_ID])",
            "        a.phys_brs['net1'] = self.mock_map_tun_bridge",
            "        a.phys_ofports['net1'] = self.MAP_TUN_PHY_OFPORT",
            "        a.int_ofports['net1'] = self.INT_OFPORT",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_VLAN, 'net1', LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_provision_local_vlan_vlan_fail(self):",
            "        a = self._build_agent()",
            "        a.provision_local_vlan(NET_UUID, n_const.TYPE_VLAN, 'net2', LS_ID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_reclaim_local_vlan(self):",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.reclaim_local_vlan(network_type='gre',",
            "                                         segmentation_id=LS_ID),",
            "            mock.call.delete_flood_to_tun(LV_ID),",
            "            mock.call.delete_unicast_to_tun(LV_ID, None),",
            "            mock.call.delete_arp_responder(LV_ID, None),",
            "        ]",
            "",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set()",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_DATA)",
            "        a.reclaim_local_vlan(NET_UUID)",
            "        self.assertIn(self.LVM_DATA[0], a.available_local_vlans)",
            "        self._verify_mock_calls()",
            "",
            "    def test_reclaim_local_vlan_flat(self):",
            "        self.mock_map_tun_bridge_expected.append(",
            "            mock.call.reclaim_local_vlan(",
            "                port=self.MAP_TUN_PHY_OFPORT,",
            "                lvid=self.LVM_FLAT_DATA[0]))",
            "        self.mock_int_bridge_expected.append(",
            "            mock.call.reclaim_local_vlan(",
            "                port=self.INT_OFPORT,",
            "                segmentation_id=None))",
            "        a = self._build_agent()",
            "        a.phys_brs['net1'] = self.mock_map_tun_bridge",
            "        a.phys_ofports['net1'] = self.MAP_TUN_PHY_OFPORT",
            "        a.int_ofports['net1'] = self.INT_OFPORT",
            "",
            "        a.available_local_vlans = set()",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_FLAT_DATA)",
            "        a.reclaim_local_vlan(NET_UUID)",
            "        self.assertIn(self.LVM_FLAT_DATA[0], a.available_local_vlans)",
            "        self._verify_mock_calls()",
            "",
            "    def test_reclaim_local_vlan_vlan(self):",
            "        self.mock_map_tun_bridge_expected.append(",
            "            mock.call.reclaim_local_vlan(",
            "                port=self.MAP_TUN_PHY_OFPORT,",
            "                lvid=self.LVM_VLAN_DATA[0]))",
            "        self.mock_int_bridge_expected.append(",
            "            mock.call.reclaim_local_vlan(",
            "                port=self.INT_OFPORT,",
            "                segmentation_id=LS_ID))",
            "        a = self._build_agent()",
            "        a.phys_brs['net1'] = self.mock_map_tun_bridge",
            "        a.phys_ofports['net1'] = self.MAP_TUN_PHY_OFPORT",
            "        a.int_ofports['net1'] = self.INT_OFPORT",
            "",
            "        a.available_local_vlans = set()",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_VLAN_DATA)",
            "        a.reclaim_local_vlan(NET_UUID)",
            "        self.assertIn(self.LVM_VLAN_DATA[0], a.available_local_vlans)",
            "        self._verify_mock_calls()",
            "",
            "    def test_port_bound(self):",
            "        vlan_mapping = {'segmentation_id': str(LS_ID),",
            "                        'physical_network': 'None',",
            "                        'net_uuid': NET_UUID,",
            "                        'network_type': 'gre'}",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.db_get_val('Port', 'port', 'other_config'),",
            "            mock.call.set_db_attribute('Port', VIF_PORT.port_name,",
            "                                       'other_config',",
            "                                       vlan_mapping)]",
            "",
            "        a = self._build_agent()",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_DATA)",
            "        a.local_dvr_map = {}",
            "        self.ovs_bridges[self.INT_BRIDGE].db_get_val.return_value = {}",
            "        a.port_bound(VIF_PORT, NET_UUID, 'gre', None, LS_ID,",
            "                     FIXED_IPS, VM_DEVICE_OWNER, False)",
            "        self._verify_mock_calls()",
            "",
            "    def test_port_unbound(self):",
            "        with mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                               'reclaim_local_vlan') as reclaim_local_vlan:",
            "            a = self._build_agent()",
            "            a.vlan_manager.add(NET_UUID, *self.LVM_DATA)",
            "            a.port_unbound(VIF_ID, NET_UUID)",
            "",
            "        reclaim_local_vlan.assert_called_once_with(NET_UUID)",
            "        self._verify_mock_calls()",
            "",
            "    def test_port_dead(self):",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.db_get_val('Port', VIF_PORT.port_name, 'tag',",
            "                                 log_errors=True),",
            "            mock.call.set_db_attribute(",
            "                'Port', VIF_PORT.port_name,",
            "                'tag', constants.DEAD_VLAN_TAG,",
            "                log_errors=True),",
            "            mock.call.drop_port(in_port=VIF_PORT.ofport),",
            "        ]",
            "",
            "        a = self._build_agent()",
            "        a.available_local_vlans = set([LV_ID])",
            "        a.vlan_manager.add(NET_UUID, *self.LVM_DATA)",
            "        self.ovs_bridges[self.INT_BRIDGE].db_get_val.return_value = mock.Mock()",
            "        a.port_dead(VIF_PORT)",
            "        self._verify_mock_calls()",
            "",
            "    def test_tunnel_update(self):",
            "        tunnel_port = '9999'",
            "        self.mock_tun_bridge.add_tunnel_port.return_value = tunnel_port",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.add_tunnel_port('gre-0a000a01', '10.0.10.1', '10.0.0.1',",
            "                                      'gre', 4789, True, False, None),",
            "            mock.call.setup_tunnel_port('gre', tunnel_port),",
            "        ]",
            "",
            "        a = self._build_agent()",
            "        a.tunnel_update(",
            "            mock.sentinel.ctx, tunnel_ip='10.0.10.1',",
            "            tunnel_type=n_const.TYPE_GRE)",
            "        self._verify_mock_calls()",
            "",
            "    def test_tunnel_update_self(self):",
            "        a = self._build_agent()",
            "        a.tunnel_update(",
            "            mock.sentinel.ctx, tunnel_ip='10.0.0.1')",
            "        self._verify_mock_calls()",
            "",
            "    def test_daemon_loop(self):",
            "        reply_ge_1 = {'added': [{'name': 'tap0', 'ofport': 3,",
            "                                 'external_ids': {",
            "                                     'attached-mac': 'test_mac'}}],",
            "                      'removed': []}",
            "",
            "        reply_ge_2 = {'added': [],",
            "                      'removed': [{'name': 'tap0', 'ofport': 3,",
            "                                   'external_ids': {",
            "                                       'attached-mac': 'test_mac'}}]}",
            "",
            "        reply_pe_1 = {'current': set(['tap0']),",
            "                      'added': set(['tap0']),",
            "                      'removed': set([])}",
            "",
            "        reply_pe_2 = {'current': set([]),",
            "                      'added': set([]),",
            "                      'removed': set(['tap0'])}",
            "",
            "        reply_ancillary = {'current': set([]),",
            "                           'added': set([]),",
            "                           'removed': set([])}",
            "",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.check_canary_table(),",
            "            mock.call.deferred(full_ordered=True, use_bundle=True),",
            "            mock.call.deferred().__enter__(),",
            "            mock.call.deferred().__exit__(None, None, None),",
            "            mock.call.cleanup_flows(),",
            "            mock.call.check_canary_table(),",
            "            mock.call.deferred(full_ordered=True, use_bundle=True),",
            "            mock.call.deferred().__enter__(),",
            "            mock.call.deferred().__exit__(None, None, None),",
            "        ]",
            "        self.mock_map_tun_bridge_expected += [",
            "            mock.call.cleanup_flows(),",
            "        ]",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.cleanup_flows()",
            "        ]",
            "        # No cleanup is expected on ancillary bridge",
            "",
            "        self.ovs_bridges[self.INT_BRIDGE].check_canary_table.return_value = \\",
            "            constants.OVS_NORMAL",
            "        with mock.patch.object(log.KeywordArgumentAdapter,",
            "                               'exception') as log_exception,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'process_ports_events') as process_p_events,\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'process_network_ports') as process_network_ports,\\",
            "                mock.patch.object(self.mod_agent.OVSNeutronAgent,",
            "                                  'tunnel_sync'),\\",
            "                mock.patch.object(time, 'sleep'),\\",
            "                mock.patch.object(",
            "                    self.mod_agent.OVSNeutronAgent,",
            "                    'update_stale_ofport_rules') as update_stale:",
            "            log_exception.side_effect = Exception(",
            "                'Fake exception to get out of the loop')",
            "            update_stale.return_value = []",
            "            devices_not_ready = set()",
            "            process_p_events.side_effect = [",
            "                (reply_pe_1, reply_ancillary, devices_not_ready),",
            "                (reply_pe_2, reply_ancillary, devices_not_ready)]",
            "            interface_polling = mock.Mock()",
            "            interface_polling.get_events.side_effect = [reply_ge_1, reply_ge_2]",
            "            failed_devices = {'removed': set([]), 'added': set([])}",
            "            failed_ancillary_devices = {'removed': set([]), 'added': set([])}",
            "            process_network_ports.side_effect = [",
            "                failed_devices,",
            "                Exception('Fake exception to get out of the loop')]",
            "",
            "            n_agent = self._build_agent()",
            "",
            "            # Hack to test loop",
            "            # We start method and expect it will raise after 2nd loop",
            "            # If something goes wrong, assert_has_calls below will catch it",
            "            try:",
            "                n_agent.rpc_loop(interface_polling)",
            "            except Exception:",
            "                pass",
            "",
            "            # FIXME(salv-orlando): There should not be assertions on log",
            "            # messages",
            "            log_exception.assert_called_once_with(",
            "                \"Error while processing VIF ports\")",
            "            process_p_events.assert_has_calls([",
            "                mock.call(reply_ge_1, set(), set(), devices_not_ready,",
            "                          failed_devices, failed_ancillary_devices, set()),",
            "                mock.call(reply_ge_2, set(['tap0']), set(), devices_not_ready,",
            "                          failed_devices, failed_ancillary_devices,",
            "                          set())",
            "            ])",
            "            process_network_ports.assert_has_calls([",
            "                mock.call({'current': set(['tap0']),",
            "                           'removed': set([]),",
            "                           'added': set(['tap0'])}, False),",
            "            ])",
            "",
            "            self.assertTrue(update_stale.called)",
            "            self._verify_mock_calls()",
            "",
            "",
            "class TunnelTestOSKen(TunnelTest, ovs_test_base.OVSOSKenTestBase):",
            "    pass",
            "",
            "",
            "class TunnelTestUseVethInterco(TunnelTest):",
            "    USE_VETH_INTERCONNECTION = True",
            "",
            "    def _define_expected_calls(self, arp_responder=False, igmp_snooping=False):",
            "        self.mock_int_bridge_cls_expected = [",
            "            mock.call(self.INT_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "        self.mock_phys_bridge_cls_expected = [",
            "            mock.call(self.MAP_TUN_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "        self.mock_tun_bridge_cls_expected = [",
            "            mock.call(self.TUN_BRIDGE,",
            "                      datapath_type=mock.ANY),",
            "        ]",
            "",
            "        self.mock_int_bridge_expected = [",
            "            mock.call.create(),",
            "            mock.call.set_secure_mode(),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.set_igmp_snooping_state(igmp_snooping),",
            "            mock.call.setup_default_table(),",
            "        ]",
            "",
            "        self.mock_map_tun_bridge_expected = [",
            "            mock.call.create(),",
            "            mock.call.set_secure_mode(),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.setup_default_table(),",
            "            mock.call.add_port('phy-%s' % self.MAP_TUN_BRIDGE),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.db_get_val('Interface', 'int-%s' % self.MAP_TUN_BRIDGE,",
            "                                 'type', log_errors=False),",
            "            mock.call.add_port('int-%s' % self.MAP_TUN_BRIDGE)",
            "        ]",
            "",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.drop_port(in_port=self.MAP_TUN_INT_OFPORT),",
            "        ]",
            "        self.mock_map_tun_bridge_expected += [",
            "            mock.call.drop_port(in_port=self.MAP_TUN_PHY_OFPORT),",
            "        ]",
            "",
            "        self.mock_aux_bridge = self.ovs_bridges[self.AUX_BRIDGE]",
            "        self.mock_aux_bridge_expected = [",
            "        ]",
            "",
            "        self.mock_tun_bridge_expected = [",
            "            mock.call.create(secure_mode=True),",
            "            mock.call.setup_controllers(mock.ANY),",
            "            mock.call.port_exists('patch-int'),",
            "            mock.ANY,",
            "            mock.call.add_patch_port('patch-int', 'patch-tun'),",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.port_exists('patch-tun'),",
            "            mock.call.add_patch_port('patch-tun', 'patch-int')",
            "        ]",
            "        self.mock_int_bridge_expected += [",
            "            mock.call.get_vif_ports((ovs_lib.INVALID_OFPORT,",
            "                                     ovs_lib.UNASSIGNED_OFPORT)),",
            "            mock.call.get_ports_attributes(",
            "                'Port', columns=['name', 'other_config', 'tag'], ports=[])",
            "        ]",
            "        self.mock_tun_bridge_expected += [",
            "            mock.call.setup_default_table(self.INT_OFPORT, arp_responder),",
            "        ]",
            "",
            "        self.ipdevice_expected = [",
            "            mock.call('int-%s' % self.MAP_TUN_BRIDGE),",
            "            mock.call().exists(),",
            "            mock.ANY,",
            "            mock.call().link.delete()",
            "        ]",
            "        self.ipwrapper_expected = [",
            "            mock.call(),",
            "            mock.call().add_veth('int-%s' % self.MAP_TUN_BRIDGE,",
            "                                 'phy-%s' % self.MAP_TUN_BRIDGE)",
            "        ]",
            "",
            "        self.get_bridges_expected = [mock.call(), mock.call()]",
            "",
            "        self.inta_expected = [mock.call.link.set_up()]",
            "        self.intb_expected = [mock.call.link.set_up()]",
            "        self.execute_expected = [mock.call(['udevadm', 'settle',",
            "                                            '--timeout=10'])]",
            "",
            "",
            "class TunnelTestUseVethIntercoOSKen(TunnelTestUseVethInterco,",
            "                                  ovs_test_base.OVSOSKenTestBase):",
            "    pass",
            "",
            "",
            "class TunnelTestWithMTU(TunnelTestUseVethInterco):",
            "    VETH_MTU = 1500",
            "",
            "    def _define_expected_calls(self, arp_responder=False, igmp_snooping=False):",
            "        super(TunnelTestWithMTU, self)._define_expected_calls(",
            "            arp_responder, igmp_snooping)",
            "        self.inta_expected.append(mock.call.link.set_mtu(self.VETH_MTU))",
            "        self.intb_expected.append(mock.call.link.set_mtu(self.VETH_MTU))",
            "",
            "",
            "class TunnelTestWithMTUOSKen(TunnelTestWithMTU,",
            "                           ovs_test_base.OVSOSKenTestBase):",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "41": [
                "VIF_PORT"
            ],
            "42": []
        },
        "addLocation": []
    }
}