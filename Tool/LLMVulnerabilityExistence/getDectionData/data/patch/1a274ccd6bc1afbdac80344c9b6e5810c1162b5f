{
    "django/contrib/auth/tests/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "         for bad_url in ('http://example.com',"
            },
            "1": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "                         'https://example.com',"
            },
            "2": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "                         'ftp://exampel.com',"
            },
            "3": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        '//example.com'):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+                        '//example.com',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+                        'javascript:alert(\"XSS\")'):"
            },
            "6": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 333,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "             nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {"
            },
            "8": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "                 'url': login_url,"
            },
            "9": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "                          '/view?param=ftp://exampel.com',"
            },
            "10": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "                          'view/?param=//example.com',"
            },
            "11": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 352,
                "PatchRowcode": "                          'https:///',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+                         'HTTPS:///',"
            },
            "13": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "                          '//testserver/',"
            },
            "14": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "                          '/url%20with%20spaces/'):  # see ticket #12534"
            },
            "15": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "             safe_url = '%(url)s?%(next)s=%(good_url)s' % {"
            },
            "16": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": 524,
                "PatchRowcode": "         for bad_url in ('http://example.com',"
            },
            "17": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": 525,
                "PatchRowcode": "                         'https://example.com',"
            },
            "18": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": 526,
                "PatchRowcode": "                         'ftp://exampel.com',"
            },
            "19": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        '//example.com'):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 527,
                "PatchRowcode": "+                        '//example.com',"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 528,
                "PatchRowcode": "+                        'javascript:alert(\"XSS\")'):"
            },
            "22": {
                "beforePatchRowNumber": 526,
                "afterPatchRowNumber": 529,
                "PatchRowcode": "             nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {"
            },
            "23": {
                "beforePatchRowNumber": 527,
                "afterPatchRowNumber": 530,
                "PatchRowcode": "                 'url': logout_url,"
            },
            "24": {
                "beforePatchRowNumber": 528,
                "afterPatchRowNumber": 531,
                "PatchRowcode": "                 'next': REDIRECT_FIELD_NAME,"
            },
            "25": {
                "beforePatchRowNumber": 541,
                "afterPatchRowNumber": 544,
                "PatchRowcode": "                          '/view?param=ftp://exampel.com',"
            },
            "26": {
                "beforePatchRowNumber": 542,
                "afterPatchRowNumber": 545,
                "PatchRowcode": "                          'view/?param=//example.com',"
            },
            "27": {
                "beforePatchRowNumber": 543,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "                          'https:///',"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 547,
                "PatchRowcode": "+                         'HTTPS:///',"
            },
            "29": {
                "beforePatchRowNumber": 544,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "                          '//testserver/',"
            },
            "30": {
                "beforePatchRowNumber": 545,
                "afterPatchRowNumber": 549,
                "PatchRowcode": "                          '/url%20with%20spaces/'):  # see ticket #12534"
            },
            "31": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "             safe_url = '%(url)s?%(next)s=%(good_url)s' % {"
            }
        },
        "frontPatchFile": [
            "import os",
            "import re",
            "",
            "from django.conf import global_settings, settings",
            "from django.contrib.sites.models import Site, RequestSite",
            "from django.contrib.auth.models import User",
            "from django.core import mail",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.core.urlresolvers import reverse, NoReverseMatch",
            "from django.http import QueryDict, HttpRequest",
            "from django.utils.encoding import force_text",
            "from django.utils.html import escape",
            "from django.utils.http import urlquote",
            "from django.utils._os import upath",
            "from django.test import TestCase",
            "from django.test.utils import override_settings",
            "from django.middleware.csrf import CsrfViewMiddleware",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "",
            "from django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME",
            "from django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,",
            "                SetPasswordForm, PasswordResetForm)",
            "from django.contrib.auth.tests.utils import skipIfCustomUser",
            "from django.contrib.auth.views import login as login_view",
            "",
            "",
            "@override_settings(",
            "    LANGUAGES=(",
            "        ('en', 'English'),",
            "    ),",
            "    LANGUAGE_CODE='en',",
            "    TEMPLATE_LOADERS=global_settings.TEMPLATE_LOADERS,",
            "    TEMPLATE_DIRS=(",
            "        os.path.join(os.path.dirname(upath(__file__)), 'templates'),",
            "    ),",
            "    USE_TZ=False,",
            "    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),",
            ")",
            "class AuthViewsTestCase(TestCase):",
            "    \"\"\"",
            "    Helper base class for all the follow test cases.",
            "    \"\"\"",
            "    fixtures = ['authtestdata.json']",
            "    urls = 'django.contrib.auth.tests.urls'",
            "",
            "    def login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "            })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith(settings.LOGIN_REDIRECT_URL))",
            "        self.assertTrue(SESSION_KEY in self.client.session)",
            "",
            "    def assertContainsEscaped(self, response, text, **kwargs):",
            "        return self.assertContains(response, escape(force_text(text)), **kwargs)",
            "",
            "",
            "@skipIfCustomUser",
            "class AuthViewNamedURLTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.urls'",
            "",
            "    def test_named_urls(self):",
            "        \"Named URLs should be reversible\"",
            "        expected_named_urls = [",
            "            ('login', [], {}),",
            "            ('logout', [], {}),",
            "            ('password_change', [], {}),",
            "            ('password_change_done', [], {}),",
            "            ('password_reset', [], {}),",
            "            ('password_reset_done', [], {}),",
            "            ('password_reset_confirm', [], {",
            "                'uidb36': 'aaaaaaa',",
            "                'token': '1111-aaaaa',",
            "            }),",
            "            ('password_reset_complete', [], {}),",
            "        ]",
            "        for name, args, kwargs in expected_named_urls:",
            "            try:",
            "                reverse(name, args=args, kwargs=kwargs)",
            "            except NoReverseMatch:",
            "                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)",
            "",
            "",
            "@skipIfCustomUser",
            "class PasswordResetTest(AuthViewsTestCase):",
            "",
            "    def test_email_not_found(self):",
            "        \"Error is raised if the provided email address isn't currently registered\"",
            "        response = self.client.get('/password_reset/')",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})",
            "        self.assertContainsEscaped(response, PasswordResetForm.error_messages['unknown'])",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_email_found(self):",
            "        \"Email is sent if a valid email address is provided for password reset\"",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    def test_email_found_custom_from(self):",
            "        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"",
            "        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)",
            "",
            "    @override_settings(ALLOWED_HOSTS=['adminsite.com'])",
            "    def test_admin_reset(self):",
            "        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"",
            "        response = self.client.post('/admin_password_reset/',",
            "            {'email': 'staffmember@example.com'},",
            "            HTTP_HOST='adminsite.com'",
            "        )",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails\"",
            "        # This attack is based on the way browsers handle URLs. The colon",
            "        # should be used to separate the port, but if the URL contains an @,",
            "        # the colon is interpreted as part of a username for login purposes,",
            "        # making 'evil.com' the request domain. Since HTTP_HOST is used to",
            "        # produce a meaningful reset URL, we need to be certain that the",
            "        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()",
            "        # is invoked, but we check here as a practical consequence.",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host_admin_site(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/admin_password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "    def test_confirm_invalid(self):",
            "        url, path = self._test_confirm_start()",
            "        # Let's munge the token in the path, but keep the same length,",
            "        # in case the URLconf will reject a different length.",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_user(self):",
            "        # Ensure that we get a 200 response for a non-existant user, not a 404",
            "        response = self.client.get('/reset/123456-1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_overflow_user(self):",
            "        # Ensure that we get a 200 response for a base36 user id that overflows int",
            "        response = self.client.get('/reset/zzzzzzzzzzzzz-1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_post(self):",
            "        # Same as test_confirm_invalid, but trying",
            "        # to do a POST instead.",
            "        url, path = self._test_confirm_start()",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        self.client.post(path, {",
            "            'new_password1': 'anewpassword',",
            "            'new_password2': ' anewpassword',",
            "        })",
            "        # Check the password has not been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(not u.check_password(\"anewpassword\"))",
            "",
            "    def test_confirm_complete(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        # It redirects us to a 'complete' page:",
            "        self.assertEqual(response.status_code, 302)",
            "        # Check the password has been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(u.check_password(\"anewpassword\"))",
            "",
            "        # Check we can't use the link again",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_different_passwords(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'x'})",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "",
            "@override_settings(AUTH_USER_MODEL='auth.CustomUser')",
            "class CustomUserPasswordResetTest(AuthViewsTestCase):",
            "    fixtures = ['custom_user.json']",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid_custom_user(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "",
            "@skipIfCustomUser",
            "class ChangePasswordTest(AuthViewsTestCase):",
            "",
            "    def fail_login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "        })",
            "        self.assertContainsEscaped(response, AuthenticationForm.error_messages['invalid_login'] % {",
            "                'username': User._meta.get_field('username').verbose_name",
            "            })",
            "",
            "    def logout(self):",
            "        response = self.client.get('/logout/')",
            "",
            "    def test_password_change_fails_with_invalid_old_password(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'donuts',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertContainsEscaped(response, PasswordChangeForm.error_messages['password_incorrect'])",
            "",
            "    def test_password_change_fails_with_mismatched_passwords(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'donuts',",
            "        })",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_password_change_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "        self.fail_login()",
            "        self.login(password='password1')",
            "",
            "    def test_password_change_done_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "",
            "    def test_password_change_done_fails(self):",
            "        with self.settings(LOGIN_URL='/login/'):",
            "            response = self.client.get('/password_change/done/')",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(response['Location'].endswith('/login/?next=/password_change/done/'))",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginTest(AuthViewsTestCase):",
            "",
            "    def test_current_site_in_context_after_login(self):",
            "        response = self.client.get(reverse('django.contrib.auth.views.login'))",
            "        self.assertEqual(response.status_code, 200)",
            "        if Site._meta.installed:",
            "            site = Site.objects.get_current()",
            "            self.assertEqual(response.context['site'], site)",
            "            self.assertEqual(response.context['site_name'], site.name)",
            "        else:",
            "            self.assertIsInstance(response.context['site'], RequestSite)",
            "        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),",
            "                     'Login form is not an AuthenticationForm')",
            "",
            "    def test_security_check(self, password='password'):",
            "        login_url = reverse('django.contrib.auth.views.login')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            response = self.client.post(nasty_url, {",
            "                'username': 'testclient',",
            "                'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            response = self.client.post(safe_url, {",
            "                    'username': 'testclient',",
            "                    'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "",
            "    def test_login_csrf_rotate(self, password='password'):",
            "        \"\"\"",
            "        Makes sure that a login rotates the currently-used CSRF token.",
            "        \"\"\"",
            "        # Do a GET to establish a CSRF token",
            "        # TestClient isn't used here as we're testing middleware, essentially.",
            "        req = HttpRequest()",
            "        CsrfViewMiddleware().process_view(req, login_view, (), {})",
            "        req.META[\"CSRF_COOKIE_USED\"] = True",
            "        resp = login_view(req)",
            "        resp2 = CsrfViewMiddleware().process_response(req, resp)",
            "        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)",
            "        token1 = csrf_cookie.coded_value",
            "",
            "        # Prepare the POST request",
            "        req = HttpRequest()",
            "        req.COOKIES[settings.CSRF_COOKIE_NAME] = token1",
            "        req.method = \"POST\"",
            "        req.POST = {'username': 'testclient', 'password': password, 'csrfmiddlewaretoken': token1}",
            "        req.REQUEST = req.POST",
            "",
            "        # Use POST request to log in",
            "        SessionMiddleware().process_request(req)",
            "        CsrfViewMiddleware().process_view(req, login_view, (), {})",
            "        req.META[\"SERVER_NAME\"] = \"testserver\"  # Required to have redirect work in login view",
            "        req.META[\"SERVER_PORT\"] = 80",
            "        req.META[\"CSRF_COOKIE_USED\"] = True",
            "        resp = login_view(req)",
            "        resp2 = CsrfViewMiddleware().process_response(req, resp)",
            "        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)",
            "        token2 = csrf_cookie.coded_value",
            "",
            "        # Check the CSRF token switched",
            "        self.assertNotEqual(token1, token2)",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginURLSettings(AuthViewsTestCase):",
            "",
            "    def setUp(self):",
            "        super(LoginURLSettings, self).setUp()",
            "        self.old_LOGIN_URL = settings.LOGIN_URL",
            "",
            "    def tearDown(self):",
            "        super(LoginURLSettings, self).tearDown()",
            "        settings.LOGIN_URL = self.old_LOGIN_URL",
            "",
            "    def get_login_required_url(self, login_url):",
            "        settings.LOGIN_URL = login_url",
            "        response = self.client.get('/login_required/')",
            "        self.assertEqual(response.status_code, 302)",
            "        return response['Location']",
            "",
            "    def test_standard_login_url(self):",
            "        login_url = '/login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver%s?%s' %",
            "                         (login_url, querystring.urlencode('/')))",
            "",
            "    def test_remote_login_url(self):",
            "        login_url = 'http://remote.example.com/login'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_https_login_url(self):",
            "        login_url = 'https:///login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_login_url_with_querystring(self):",
            "        login_url = '/login/?pretty=1'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('pretty=1', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver/login/?%s' %",
            "                         querystring.urlencode('/'))",
            "",
            "    def test_remote_login_url_with_next_querystring(self):",
            "        login_url = 'http://remote.example.com/login/'",
            "        login_required_url = self.get_login_required_url('%s?next=/default/' %",
            "                                                         login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url, '%s?%s' % (login_url,",
            "                                                    querystring.urlencode('/')))",
            "",
            "",
            "@skipIfCustomUser",
            "class LogoutTest(AuthViewsTestCase):",
            "",
            "    def confirm_logged_out(self):",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def test_logout_default(self):",
            "        \"Logout without next_page option renders the default template\"",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertContains(response, 'Logged out')",
            "        self.confirm_logged_out()",
            "",
            "    def test_14377(self):",
            "        # Bug 14377",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertTrue('site' in response.context)",
            "",
            "    def test_logout_with_overridden_redirect_url(self):",
            "        # Bug 11223",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "",
            "        response = self.client.get('/logout/next_page/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_next_page_specified(self):",
            "        \"Logout with next_page option given redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_redirect_argument(self):",
            "        \"Logout with query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_custom_redirect_argument(self):",
            "        \"Logout with custom query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/custom_query/?follow=/somewhere/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_security_check(self, password='password'):",
            "        logout_url = reverse('django.contrib.auth.views.logout')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(nasty_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "            self.confirm_logged_out()",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(safe_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "            self.confirm_logged_out()",
            "",
            "@skipIfCustomUser",
            "class ChangelistTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.tests.urls_admin'",
            "",
            "    # #20078 - users shouldn't be allowed to guess password hashes via",
            "    # repeated password__startswith queries.",
            "    def test_changelist_disallows_password_lookups(self):",
            "        # Make me a superuser before loging in.",
            "        User.objects.filter(username='testclient').update(is_staff=True, is_superuser=True)",
            "        self.login()",
            "",
            "        # A lookup that tries to filter on password isn't OK",
            "        with self.assertRaises(SuspiciousOperation):",
            "            response = self.client.get('/admin/auth/user/?password__startswith=sha1$')"
        ],
        "afterPatchFile": [
            "import os",
            "import re",
            "",
            "from django.conf import global_settings, settings",
            "from django.contrib.sites.models import Site, RequestSite",
            "from django.contrib.auth.models import User",
            "from django.core import mail",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.core.urlresolvers import reverse, NoReverseMatch",
            "from django.http import QueryDict, HttpRequest",
            "from django.utils.encoding import force_text",
            "from django.utils.html import escape",
            "from django.utils.http import urlquote",
            "from django.utils._os import upath",
            "from django.test import TestCase",
            "from django.test.utils import override_settings",
            "from django.middleware.csrf import CsrfViewMiddleware",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "",
            "from django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME",
            "from django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,",
            "                SetPasswordForm, PasswordResetForm)",
            "from django.contrib.auth.tests.utils import skipIfCustomUser",
            "from django.contrib.auth.views import login as login_view",
            "",
            "",
            "@override_settings(",
            "    LANGUAGES=(",
            "        ('en', 'English'),",
            "    ),",
            "    LANGUAGE_CODE='en',",
            "    TEMPLATE_LOADERS=global_settings.TEMPLATE_LOADERS,",
            "    TEMPLATE_DIRS=(",
            "        os.path.join(os.path.dirname(upath(__file__)), 'templates'),",
            "    ),",
            "    USE_TZ=False,",
            "    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),",
            ")",
            "class AuthViewsTestCase(TestCase):",
            "    \"\"\"",
            "    Helper base class for all the follow test cases.",
            "    \"\"\"",
            "    fixtures = ['authtestdata.json']",
            "    urls = 'django.contrib.auth.tests.urls'",
            "",
            "    def login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "            })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith(settings.LOGIN_REDIRECT_URL))",
            "        self.assertTrue(SESSION_KEY in self.client.session)",
            "",
            "    def assertContainsEscaped(self, response, text, **kwargs):",
            "        return self.assertContains(response, escape(force_text(text)), **kwargs)",
            "",
            "",
            "@skipIfCustomUser",
            "class AuthViewNamedURLTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.urls'",
            "",
            "    def test_named_urls(self):",
            "        \"Named URLs should be reversible\"",
            "        expected_named_urls = [",
            "            ('login', [], {}),",
            "            ('logout', [], {}),",
            "            ('password_change', [], {}),",
            "            ('password_change_done', [], {}),",
            "            ('password_reset', [], {}),",
            "            ('password_reset_done', [], {}),",
            "            ('password_reset_confirm', [], {",
            "                'uidb36': 'aaaaaaa',",
            "                'token': '1111-aaaaa',",
            "            }),",
            "            ('password_reset_complete', [], {}),",
            "        ]",
            "        for name, args, kwargs in expected_named_urls:",
            "            try:",
            "                reverse(name, args=args, kwargs=kwargs)",
            "            except NoReverseMatch:",
            "                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)",
            "",
            "",
            "@skipIfCustomUser",
            "class PasswordResetTest(AuthViewsTestCase):",
            "",
            "    def test_email_not_found(self):",
            "        \"Error is raised if the provided email address isn't currently registered\"",
            "        response = self.client.get('/password_reset/')",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})",
            "        self.assertContainsEscaped(response, PasswordResetForm.error_messages['unknown'])",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_email_found(self):",
            "        \"Email is sent if a valid email address is provided for password reset\"",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    def test_email_found_custom_from(self):",
            "        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"",
            "        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)",
            "",
            "    @override_settings(ALLOWED_HOSTS=['adminsite.com'])",
            "    def test_admin_reset(self):",
            "        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"",
            "        response = self.client.post('/admin_password_reset/',",
            "            {'email': 'staffmember@example.com'},",
            "            HTTP_HOST='adminsite.com'",
            "        )",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails\"",
            "        # This attack is based on the way browsers handle URLs. The colon",
            "        # should be used to separate the port, but if the URL contains an @,",
            "        # the colon is interpreted as part of a username for login purposes,",
            "        # making 'evil.com' the request domain. Since HTTP_HOST is used to",
            "        # produce a meaningful reset URL, we need to be certain that the",
            "        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()",
            "        # is invoked, but we check here as a practical consequence.",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host_admin_site(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"",
            "        with self.assertRaises(SuspiciousOperation):",
            "            self.client.post('/admin_password_reset/',",
            "                {'email': 'staffmember@example.com'},",
            "                HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "            )",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "    def test_confirm_invalid(self):",
            "        url, path = self._test_confirm_start()",
            "        # Let's munge the token in the path, but keep the same length,",
            "        # in case the URLconf will reject a different length.",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_user(self):",
            "        # Ensure that we get a 200 response for a non-existant user, not a 404",
            "        response = self.client.get('/reset/123456-1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_overflow_user(self):",
            "        # Ensure that we get a 200 response for a base36 user id that overflows int",
            "        response = self.client.get('/reset/zzzzzzzzzzzzz-1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_post(self):",
            "        # Same as test_confirm_invalid, but trying",
            "        # to do a POST instead.",
            "        url, path = self._test_confirm_start()",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        self.client.post(path, {",
            "            'new_password1': 'anewpassword',",
            "            'new_password2': ' anewpassword',",
            "        })",
            "        # Check the password has not been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(not u.check_password(\"anewpassword\"))",
            "",
            "    def test_confirm_complete(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        # It redirects us to a 'complete' page:",
            "        self.assertEqual(response.status_code, 302)",
            "        # Check the password has been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(u.check_password(\"anewpassword\"))",
            "",
            "        # Check we can't use the link again",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_different_passwords(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'x'})",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "",
            "@override_settings(AUTH_USER_MODEL='auth.CustomUser')",
            "class CustomUserPasswordResetTest(AuthViewsTestCase):",
            "    fixtures = ['custom_user.json']",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid_custom_user(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "",
            "@skipIfCustomUser",
            "class ChangePasswordTest(AuthViewsTestCase):",
            "",
            "    def fail_login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "        })",
            "        self.assertContainsEscaped(response, AuthenticationForm.error_messages['invalid_login'] % {",
            "                'username': User._meta.get_field('username').verbose_name",
            "            })",
            "",
            "    def logout(self):",
            "        response = self.client.get('/logout/')",
            "",
            "    def test_password_change_fails_with_invalid_old_password(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'donuts',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertContainsEscaped(response, PasswordChangeForm.error_messages['password_incorrect'])",
            "",
            "    def test_password_change_fails_with_mismatched_passwords(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'donuts',",
            "        })",
            "        self.assertContainsEscaped(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_password_change_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "        self.fail_login()",
            "        self.login(password='password1')",
            "",
            "    def test_password_change_done_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/password_change/done/'))",
            "",
            "    def test_password_change_done_fails(self):",
            "        with self.settings(LOGIN_URL='/login/'):",
            "            response = self.client.get('/password_change/done/')",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(response['Location'].endswith('/login/?next=/password_change/done/'))",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginTest(AuthViewsTestCase):",
            "",
            "    def test_current_site_in_context_after_login(self):",
            "        response = self.client.get(reverse('django.contrib.auth.views.login'))",
            "        self.assertEqual(response.status_code, 200)",
            "        if Site._meta.installed:",
            "            site = Site.objects.get_current()",
            "            self.assertEqual(response.context['site'], site)",
            "            self.assertEqual(response.context['site_name'], site.name)",
            "        else:",
            "            self.assertIsInstance(response.context['site'], RequestSite)",
            "        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),",
            "                     'Login form is not an AuthenticationForm')",
            "",
            "    def test_security_check(self, password='password'):",
            "        login_url = reverse('django.contrib.auth.views.login')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com',",
            "                        'javascript:alert(\"XSS\")'):",
            "",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            response = self.client.post(nasty_url, {",
            "                'username': 'testclient',",
            "                'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         'HTTPS:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            response = self.client.post(safe_url, {",
            "                    'username': 'testclient',",
            "                    'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "",
            "    def test_login_csrf_rotate(self, password='password'):",
            "        \"\"\"",
            "        Makes sure that a login rotates the currently-used CSRF token.",
            "        \"\"\"",
            "        # Do a GET to establish a CSRF token",
            "        # TestClient isn't used here as we're testing middleware, essentially.",
            "        req = HttpRequest()",
            "        CsrfViewMiddleware().process_view(req, login_view, (), {})",
            "        req.META[\"CSRF_COOKIE_USED\"] = True",
            "        resp = login_view(req)",
            "        resp2 = CsrfViewMiddleware().process_response(req, resp)",
            "        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)",
            "        token1 = csrf_cookie.coded_value",
            "",
            "        # Prepare the POST request",
            "        req = HttpRequest()",
            "        req.COOKIES[settings.CSRF_COOKIE_NAME] = token1",
            "        req.method = \"POST\"",
            "        req.POST = {'username': 'testclient', 'password': password, 'csrfmiddlewaretoken': token1}",
            "        req.REQUEST = req.POST",
            "",
            "        # Use POST request to log in",
            "        SessionMiddleware().process_request(req)",
            "        CsrfViewMiddleware().process_view(req, login_view, (), {})",
            "        req.META[\"SERVER_NAME\"] = \"testserver\"  # Required to have redirect work in login view",
            "        req.META[\"SERVER_PORT\"] = 80",
            "        req.META[\"CSRF_COOKIE_USED\"] = True",
            "        resp = login_view(req)",
            "        resp2 = CsrfViewMiddleware().process_response(req, resp)",
            "        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)",
            "        token2 = csrf_cookie.coded_value",
            "",
            "        # Check the CSRF token switched",
            "        self.assertNotEqual(token1, token2)",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginURLSettings(AuthViewsTestCase):",
            "",
            "    def setUp(self):",
            "        super(LoginURLSettings, self).setUp()",
            "        self.old_LOGIN_URL = settings.LOGIN_URL",
            "",
            "    def tearDown(self):",
            "        super(LoginURLSettings, self).tearDown()",
            "        settings.LOGIN_URL = self.old_LOGIN_URL",
            "",
            "    def get_login_required_url(self, login_url):",
            "        settings.LOGIN_URL = login_url",
            "        response = self.client.get('/login_required/')",
            "        self.assertEqual(response.status_code, 302)",
            "        return response['Location']",
            "",
            "    def test_standard_login_url(self):",
            "        login_url = '/login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver%s?%s' %",
            "                         (login_url, querystring.urlencode('/')))",
            "",
            "    def test_remote_login_url(self):",
            "        login_url = 'http://remote.example.com/login'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_https_login_url(self):",
            "        login_url = 'https:///login/'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url,",
            "                         '%s?%s' % (login_url, querystring.urlencode('/')))",
            "",
            "    def test_login_url_with_querystring(self):",
            "        login_url = '/login/?pretty=1'",
            "        login_required_url = self.get_login_required_url(login_url)",
            "        querystring = QueryDict('pretty=1', mutable=True)",
            "        querystring['next'] = '/login_required/'",
            "        self.assertEqual(login_required_url, 'http://testserver/login/?%s' %",
            "                         querystring.urlencode('/'))",
            "",
            "    def test_remote_login_url_with_next_querystring(self):",
            "        login_url = 'http://remote.example.com/login/'",
            "        login_required_url = self.get_login_required_url('%s?next=/default/' %",
            "                                                         login_url)",
            "        querystring = QueryDict('', mutable=True)",
            "        querystring['next'] = 'http://testserver/login_required/'",
            "        self.assertEqual(login_required_url, '%s?%s' % (login_url,",
            "                                                    querystring.urlencode('/')))",
            "",
            "",
            "@skipIfCustomUser",
            "class LogoutTest(AuthViewsTestCase):",
            "",
            "    def confirm_logged_out(self):",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def test_logout_default(self):",
            "        \"Logout without next_page option renders the default template\"",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertContains(response, 'Logged out')",
            "        self.confirm_logged_out()",
            "",
            "    def test_14377(self):",
            "        # Bug 14377",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertTrue('site' in response.context)",
            "",
            "    def test_logout_with_overridden_redirect_url(self):",
            "        # Bug 11223",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "",
            "        response = self.client.get('/logout/next_page/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_next_page_specified(self):",
            "        \"Logout with next_page option given redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_redirect_argument(self):",
            "        \"Logout with query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/login/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_custom_redirect_argument(self):",
            "        \"Logout with custom query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/custom_query/?follow=/somewhere/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertTrue(response['Location'].endswith('/somewhere/'))",
            "        self.confirm_logged_out()",
            "",
            "    def test_security_check(self, password='password'):",
            "        logout_url = reverse('django.contrib.auth.views.logout')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com',",
            "                        'javascript:alert(\"XSS\")'):",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(nasty_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response['Location'],",
            "                             \"%s should be blocked\" % bad_url)",
            "            self.confirm_logged_out()",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         'HTTPS:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(safe_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response['Location'],",
            "                            \"%s should be allowed\" % good_url)",
            "            self.confirm_logged_out()",
            "",
            "@skipIfCustomUser",
            "class ChangelistTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.tests.urls_admin'",
            "",
            "    # #20078 - users shouldn't be allowed to guess password hashes via",
            "    # repeated password__startswith queries.",
            "    def test_changelist_disallows_password_lookups(self):",
            "        # Make me a superuser before loging in.",
            "        User.objects.filter(username='testclient').update(is_staff=True, is_superuser=True)",
            "        self.login()",
            "",
            "        # A lookup that tries to filter on password isn't OK",
            "        with self.assertRaises(SuspiciousOperation):",
            "            response = self.client.get('/admin/auth/user/?password__startswith=sha1$')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "331": [
                "LoginTest",
                "test_security_check"
            ],
            "525": [
                "LogoutTest",
                "test_security_check"
            ]
        },
        "addLocation": []
    },
    "django/utils/http.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 231,
                "PatchRowcode": " def is_safe_url(url, host=None):"
            },
            "1": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "     Return ``True`` if the url is a safe redirection (i.e. it doesn't point to"
            },
            "3": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    a different host)."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+    a different host and uses a safe scheme)."
            },
            "5": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "     Always returns ``False`` on an empty url."
            },
            "7": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "     \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "     if not url:"
            },
            "9": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         return False"
            },
            "10": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    netloc = urllib_parse.urlparse(url)[1]"
            },
            "11": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return not netloc or netloc == host"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+    url_info = urllib_parse.urlparse(url)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+    return (not url_info.netloc or url_info.netloc == host) and \\"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+        (not url_info.scheme or url_info.scheme in ['http', 'https'])"
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import calendar",
            "import datetime",
            "import re",
            "import sys",
            "try:",
            "    from urllib import parse as urllib_parse",
            "except ImportError:     # Python 2",
            "    import urllib as urllib_parse",
            "    import urlparse",
            "    urllib_parse.urlparse = urlparse.urlparse",
            "",
            "",
            "from email.utils import formatdate",
            "",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.encoding import force_str, force_text",
            "from django.utils.functional import allow_lazy",
            "from django.utils import six",
            "",
            "ETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')",
            "",
            "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()",
            "__D = r'(?P<day>\\d{2})'",
            "__D2 = r'(?P<day>[ \\d]\\d)'",
            "__M = r'(?P<mon>\\w{3})'",
            "__Y = r'(?P<year>\\d{4})'",
            "__Y2 = r'(?P<year>\\d{2})'",
            "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'",
            "RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))",
            "RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))",
            "ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))",
            "",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A version of Python's urllib.quote() function that can operate on unicode",
            "    strings. The url is first UTF-8 encoded before quoting. The returned string",
            "    can safely be used as part of an argument to a subsequent iri_to_uri() call",
            "    without double-quoting occurring.",
            "    \"\"\"",
            "    return force_text(urllib_parse.quote(force_str(url), force_str(safe)))",
            "urlquote = allow_lazy(urlquote, six.text_type)",
            "",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A version of Python's urllib.quote_plus() function that can operate on",
            "    unicode strings. The url is first UTF-8 encoded before quoting. The",
            "    returned string can safely be used as part of an argument to a subsequent",
            "    iri_to_uri() call without double-quoting occurring.",
            "    \"\"\"",
            "    return force_text(urllib_parse.quote_plus(force_str(url), force_str(safe)))",
            "urlquote_plus = allow_lazy(urlquote_plus, six.text_type)",
            "",
            "def urlunquote(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote() function that can operate on",
            "    the result of django.utils.http.urlquote().",
            "    \"\"\"",
            "    return force_text(urllib_parse.unquote(force_str(quoted_url)))",
            "urlunquote = allow_lazy(urlunquote, six.text_type)",
            "",
            "def urlunquote_plus(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote_plus() function that can operate on",
            "    the result of django.utils.http.urlquote_plus().",
            "    \"\"\"",
            "    return force_text(urllib_parse.unquote_plus(force_str(quoted_url)))",
            "urlunquote_plus = allow_lazy(urlunquote_plus, six.text_type)",
            "",
            "def urlencode(query, doseq=0):",
            "    \"\"\"",
            "    A version of Python's urllib.urlencode() function that can operate on",
            "    unicode strings. The parameters are first case to UTF-8 encoded strings and",
            "    then encoded as per normal.",
            "    \"\"\"",
            "    if isinstance(query, MultiValueDict):",
            "        query = query.lists()",
            "    elif hasattr(query, 'items'):",
            "        query = query.items()",
            "    return urllib_parse.urlencode(",
            "        [(force_str(k),",
            "         [force_str(i) for i in v] if isinstance(v, (list,tuple)) else force_str(v))",
            "            for k, v in query],",
            "        doseq)",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to match the RFC1123 date format as specified by HTTP",
            "    RFC2616 section 3.3.1.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s GMT' % rfcdate[:25]",
            "",
            "def parse_http_date(date):",
            "    \"\"\"",
            "    Parses a date format as specified by HTTP RFC2616 section 3.3.1.",
            "",
            "    The three formats allowed by the RFC are accepted, even if only the first",
            "    one is still in widespread use.",
            "",
            "    Returns an integer expressed in seconds since the epoch, in UTC.",
            "    \"\"\"",
            "    # emails.Util.parsedate does the job for RFC1123 dates; unfortunately",
            "    # RFC2616 makes it mandatory to support RFC850 dates too. So we roll",
            "    # our own RFC-compliant parsing.",
            "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:",
            "        m = regex.match(date)",
            "        if m is not None:",
            "            break",
            "    else:",
            "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)",
            "    try:",
            "        year = int(m.group('year'))",
            "        if year < 100:",
            "            if year < 70:",
            "                year += 2000",
            "            else:",
            "                year += 1900",
            "        month = MONTHS.index(m.group('mon').lower()) + 1",
            "        day = int(m.group('day'))",
            "        hour = int(m.group('hour'))",
            "        min = int(m.group('min'))",
            "        sec = int(m.group('sec'))",
            "        result = datetime.datetime(year, month, day, hour, min, sec)",
            "        return calendar.timegm(result.utctimetuple())",
            "    except Exception:",
            "        raise ValueError(\"%r is not a valid date\" % date)",
            "",
            "def parse_http_date_safe(date):",
            "    \"\"\"",
            "    Same as parse_http_date, but returns None if the input is invalid.",
            "    \"\"\"",
            "    try:",
            "        return parse_http_date(date)",
            "    except Exception:",
            "        pass",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Converts a base 36 string to an ``int``. Raises ``ValueError` if the",
            "    input won't fit into an int.",
            "    \"\"\"",
            "    # To prevent overconsumption of server resources, reject any",
            "    # base36 string that is long than 13 base36 digits (13 digits",
            "    # is sufficient to base36-encode any 64-bit integer)",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    value = int(s, 36)",
            "    # ... then do a final check that the value will fit into an int to avoid",
            "    # returning a long (#15067). The long type was removed in Python 3.",
            "    if not six.PY3 and value > sys.maxint:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return value",
            "",
            "def int_to_base36(i):",
            "    \"\"\"",
            "    Converts an integer to a base36 string",
            "    \"\"\"",
            "    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"",
            "    factor = 0",
            "    if i < 0:",
            "        raise ValueError(\"Negative base36 conversion input.\")",
            "    if not six.PY3:",
            "        if not isinstance(i, six.integer_types):",
            "            raise TypeError(\"Non-integer base36 conversion input.\")",
            "        if i > sys.maxint:",
            "            raise ValueError(\"Base36 conversion input too large.\")",
            "    # Find starting factor",
            "    while True:",
            "        factor += 1",
            "        if i < 36 ** factor:",
            "            factor -= 1",
            "            break",
            "    base36 = []",
            "    # Construct base36 representation",
            "    while factor >= 0:",
            "        j = 36 ** factor",
            "        base36.append(digits[i // j])",
            "        i = i % j",
            "        factor -= 1",
            "    return ''.join(base36)",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parses a string with one or several etags passed in If-None-Match and",
            "    If-Match headers by the rules in RFC 2616. Returns a list of etags",
            "    without surrounding double quotes (\") and unescaped from \\<CHAR>.",
            "    \"\"\"",
            "    etags = ETAG_MATCH.findall(etag_str)",
            "    if not etags:",
            "        # etag_str has wrong format, treat it as an opaque string then",
            "        return [etag_str]",
            "    etags = [e.encode('ascii').decode('unicode_escape') for e in etags]",
            "    return etags",
            "",
            "def quote_etag(etag):",
            "    \"\"\"",
            "    Wraps a string in double quotes escaping contents as necessary.",
            "    \"\"\"",
            "    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')",
            "",
            "def same_origin(url1, url2):",
            "    \"\"\"",
            "    Checks if two URLs are 'same-origin'",
            "    \"\"\"",
            "    p1, p2 = urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)",
            "    return (p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port)",
            "",
            "def is_safe_url(url, host=None):",
            "    \"\"\"",
            "    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to",
            "    a different host).",
            "",
            "    Always returns ``False`` on an empty url.",
            "    \"\"\"",
            "    if not url:",
            "        return False",
            "    netloc = urllib_parse.urlparse(url)[1]",
            "    return not netloc or netloc == host"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import calendar",
            "import datetime",
            "import re",
            "import sys",
            "try:",
            "    from urllib import parse as urllib_parse",
            "except ImportError:     # Python 2",
            "    import urllib as urllib_parse",
            "    import urlparse",
            "    urllib_parse.urlparse = urlparse.urlparse",
            "",
            "",
            "from email.utils import formatdate",
            "",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.encoding import force_str, force_text",
            "from django.utils.functional import allow_lazy",
            "from django.utils import six",
            "",
            "ETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')",
            "",
            "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()",
            "__D = r'(?P<day>\\d{2})'",
            "__D2 = r'(?P<day>[ \\d]\\d)'",
            "__M = r'(?P<mon>\\w{3})'",
            "__Y = r'(?P<year>\\d{4})'",
            "__Y2 = r'(?P<year>\\d{2})'",
            "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'",
            "RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))",
            "RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))",
            "ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))",
            "",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A version of Python's urllib.quote() function that can operate on unicode",
            "    strings. The url is first UTF-8 encoded before quoting. The returned string",
            "    can safely be used as part of an argument to a subsequent iri_to_uri() call",
            "    without double-quoting occurring.",
            "    \"\"\"",
            "    return force_text(urllib_parse.quote(force_str(url), force_str(safe)))",
            "urlquote = allow_lazy(urlquote, six.text_type)",
            "",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A version of Python's urllib.quote_plus() function that can operate on",
            "    unicode strings. The url is first UTF-8 encoded before quoting. The",
            "    returned string can safely be used as part of an argument to a subsequent",
            "    iri_to_uri() call without double-quoting occurring.",
            "    \"\"\"",
            "    return force_text(urllib_parse.quote_plus(force_str(url), force_str(safe)))",
            "urlquote_plus = allow_lazy(urlquote_plus, six.text_type)",
            "",
            "def urlunquote(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote() function that can operate on",
            "    the result of django.utils.http.urlquote().",
            "    \"\"\"",
            "    return force_text(urllib_parse.unquote(force_str(quoted_url)))",
            "urlunquote = allow_lazy(urlunquote, six.text_type)",
            "",
            "def urlunquote_plus(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote_plus() function that can operate on",
            "    the result of django.utils.http.urlquote_plus().",
            "    \"\"\"",
            "    return force_text(urllib_parse.unquote_plus(force_str(quoted_url)))",
            "urlunquote_plus = allow_lazy(urlunquote_plus, six.text_type)",
            "",
            "def urlencode(query, doseq=0):",
            "    \"\"\"",
            "    A version of Python's urllib.urlencode() function that can operate on",
            "    unicode strings. The parameters are first case to UTF-8 encoded strings and",
            "    then encoded as per normal.",
            "    \"\"\"",
            "    if isinstance(query, MultiValueDict):",
            "        query = query.lists()",
            "    elif hasattr(query, 'items'):",
            "        query = query.items()",
            "    return urllib_parse.urlencode(",
            "        [(force_str(k),",
            "         [force_str(i) for i in v] if isinstance(v, (list,tuple)) else force_str(v))",
            "            for k, v in query],",
            "        doseq)",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to match the RFC1123 date format as specified by HTTP",
            "    RFC2616 section 3.3.1.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s GMT' % rfcdate[:25]",
            "",
            "def parse_http_date(date):",
            "    \"\"\"",
            "    Parses a date format as specified by HTTP RFC2616 section 3.3.1.",
            "",
            "    The three formats allowed by the RFC are accepted, even if only the first",
            "    one is still in widespread use.",
            "",
            "    Returns an integer expressed in seconds since the epoch, in UTC.",
            "    \"\"\"",
            "    # emails.Util.parsedate does the job for RFC1123 dates; unfortunately",
            "    # RFC2616 makes it mandatory to support RFC850 dates too. So we roll",
            "    # our own RFC-compliant parsing.",
            "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:",
            "        m = regex.match(date)",
            "        if m is not None:",
            "            break",
            "    else:",
            "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)",
            "    try:",
            "        year = int(m.group('year'))",
            "        if year < 100:",
            "            if year < 70:",
            "                year += 2000",
            "            else:",
            "                year += 1900",
            "        month = MONTHS.index(m.group('mon').lower()) + 1",
            "        day = int(m.group('day'))",
            "        hour = int(m.group('hour'))",
            "        min = int(m.group('min'))",
            "        sec = int(m.group('sec'))",
            "        result = datetime.datetime(year, month, day, hour, min, sec)",
            "        return calendar.timegm(result.utctimetuple())",
            "    except Exception:",
            "        raise ValueError(\"%r is not a valid date\" % date)",
            "",
            "def parse_http_date_safe(date):",
            "    \"\"\"",
            "    Same as parse_http_date, but returns None if the input is invalid.",
            "    \"\"\"",
            "    try:",
            "        return parse_http_date(date)",
            "    except Exception:",
            "        pass",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Converts a base 36 string to an ``int``. Raises ``ValueError` if the",
            "    input won't fit into an int.",
            "    \"\"\"",
            "    # To prevent overconsumption of server resources, reject any",
            "    # base36 string that is long than 13 base36 digits (13 digits",
            "    # is sufficient to base36-encode any 64-bit integer)",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    value = int(s, 36)",
            "    # ... then do a final check that the value will fit into an int to avoid",
            "    # returning a long (#15067). The long type was removed in Python 3.",
            "    if not six.PY3 and value > sys.maxint:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return value",
            "",
            "def int_to_base36(i):",
            "    \"\"\"",
            "    Converts an integer to a base36 string",
            "    \"\"\"",
            "    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"",
            "    factor = 0",
            "    if i < 0:",
            "        raise ValueError(\"Negative base36 conversion input.\")",
            "    if not six.PY3:",
            "        if not isinstance(i, six.integer_types):",
            "            raise TypeError(\"Non-integer base36 conversion input.\")",
            "        if i > sys.maxint:",
            "            raise ValueError(\"Base36 conversion input too large.\")",
            "    # Find starting factor",
            "    while True:",
            "        factor += 1",
            "        if i < 36 ** factor:",
            "            factor -= 1",
            "            break",
            "    base36 = []",
            "    # Construct base36 representation",
            "    while factor >= 0:",
            "        j = 36 ** factor",
            "        base36.append(digits[i // j])",
            "        i = i % j",
            "        factor -= 1",
            "    return ''.join(base36)",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parses a string with one or several etags passed in If-None-Match and",
            "    If-Match headers by the rules in RFC 2616. Returns a list of etags",
            "    without surrounding double quotes (\") and unescaped from \\<CHAR>.",
            "    \"\"\"",
            "    etags = ETAG_MATCH.findall(etag_str)",
            "    if not etags:",
            "        # etag_str has wrong format, treat it as an opaque string then",
            "        return [etag_str]",
            "    etags = [e.encode('ascii').decode('unicode_escape') for e in etags]",
            "    return etags",
            "",
            "def quote_etag(etag):",
            "    \"\"\"",
            "    Wraps a string in double quotes escaping contents as necessary.",
            "    \"\"\"",
            "    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')",
            "",
            "def same_origin(url1, url2):",
            "    \"\"\"",
            "    Checks if two URLs are 'same-origin'",
            "    \"\"\"",
            "    p1, p2 = urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)",
            "    return (p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port)",
            "",
            "def is_safe_url(url, host=None):",
            "    \"\"\"",
            "    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to",
            "    a different host and uses a safe scheme).",
            "",
            "    Always returns ``False`` on an empty url.",
            "    \"\"\"",
            "    if not url:",
            "        return False",
            "    url_info = urllib_parse.urlparse(url)",
            "    return (not url_info.netloc or url_info.netloc == host) and \\",
            "        (not url_info.scheme or url_info.scheme in ['http', 'https'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "234": [
                "is_safe_url"
            ],
            "240": [
                "is_safe_url"
            ],
            "241": [
                "is_safe_url"
            ]
        },
        "addLocation": []
    }
}