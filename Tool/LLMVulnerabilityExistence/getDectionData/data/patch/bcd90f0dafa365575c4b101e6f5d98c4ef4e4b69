{
    "templated_dictionary/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " # vim:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:textwidth=0:"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from collections.abc import MutableMapping"
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import jinja2"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from jinja2 import sandbox"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " # pylint: disable=no-member,unsupported-assignment-operation"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "         '''"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "         self.__dict__.update(*args, **kwargs)"
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+        self.sandbox = sandbox.SandboxedEnvironment(keep_trailing_newline=True)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         self._aliases = {}"
            },
            "14": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         if alias_spec:"
            },
            "15": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "             for aliased_to, aliases in alias_spec.items():"
            },
            "16": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         orig = last = value"
            },
            "17": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         max_recursion = self.__dict__.get('jinja_max_recursion', 5)"
            },
            "18": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         for _ in range(max_recursion):"
            },
            "19": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            template = jinja2.Template(value, keep_trailing_newline=True)"
            },
            "20": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            value = _to_native(template.render(self.__dict__))"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            value = _to_native(self.sandbox.from_string(value).render(self.__dict__, func=lambda:None))"
            },
            "22": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "             if value == last:"
            },
            "23": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                 return value"
            },
            "24": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "             last = value"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# vim:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:textwidth=0:",
            "",
            "from collections.abc import MutableMapping",
            "import jinja2",
            "",
            "",
            "# pylint: disable=no-member,unsupported-assignment-operation",
            "class TemplatedDictionary(MutableMapping):",
            "    \"\"\" Dictionary where __getitem__() is run through Jinja2 template \"\"\"",
            "    def __init__(self, *args, alias_spec=None, **kwargs):",
            "        '''",
            "        Use the object dict.",
            "",
            "        Optional parameter 'alias_spec' is dictionary of form:",
            "        {'aliased_to': ['alias_one', 'alias_two', ...], ...}",
            "        When specified, and one of the aliases is accessed - the",
            "        'aliased_to' config option is returned.",
            "        '''",
            "        self.__dict__.update(*args, **kwargs)",
            "",
            "        self._aliases = {}",
            "        if alias_spec:",
            "            for aliased_to, aliases in alias_spec.items():",
            "                for alias in aliases:",
            "                    self._aliases[alias] = aliased_to",
            "",
            "    # The next five methods are requirements of the ABC.",
            "    def __setitem__(self, key, value):",
            "        key = self._aliases.get(key, key)",
            "        self.__dict__[key] = value",
            "",
            "    def __getitem__(self, key):",
            "        key = self._aliases.get(key, key)",
            "        if '__jinja_expand' in self.__dict__ and self.__dict__['__jinja_expand']:",
            "            return self.__render_value(self.__dict__[key])",
            "        return self.__dict__[key]",
            "",
            "    def __delitem__(self, key):",
            "        del self.__dict__[key]",
            "",
            "    def __iter__(self):",
            "        return iter(self.__dict__)",
            "",
            "    def __len__(self):",
            "        return len(self.__dict__)",
            "",
            "    # The final two methods aren't required, but nice to have",
            "    def __str__(self):",
            "        '''returns simple dict representation of the mapping'''",
            "        return str(self.__dict__)",
            "",
            "    def __repr__(self):",
            "        '''echoes class, id, & reproducible representation in the REPL'''",
            "        return '{}, TemplatedDictionary({})'.format(super(TemplatedDictionary, self).__repr__(),",
            "                                                    self.__dict__)",
            "",
            "    def copy(self):",
            "        return TemplatedDictionary(self.__dict__)",
            "",
            "    def __render_value(self, value):",
            "        if isinstance(value, str):",
            "            return self.__render_string(value)",
            "        elif isinstance(value, list):",
            "            # we cannot use list comprehension here, as we need to NOT modify the list (pointer to list)",
            "            # and we need to modifiy only individual values in the list",
            "            # If we would create new list, we cannot assign to it, which often happens in configs (e.g. plugins)",
            "            for i in range(len(value)):  # pylint: disable=consider-using-enumerate",
            "                value[i] = self.__render_value(value[i])",
            "            return value",
            "        elif isinstance(value, dict):",
            "            # we cannot use list comprehension here, same reasoning as for `list` above",
            "            for k in value.keys():",
            "                value[k] = self.__render_value(value[k])",
            "            return value",
            "        else:",
            "            return value",
            "",
            "    def __render_string(self, value):",
            "        orig = last = value",
            "        max_recursion = self.__dict__.get('jinja_max_recursion', 5)",
            "        for _ in range(max_recursion):",
            "            template = jinja2.Template(value, keep_trailing_newline=True)",
            "            value = _to_native(template.render(self.__dict__))",
            "            if value == last:",
            "                return value",
            "            last = value",
            "        raise ValueError(\"too deep jinja re-evaluation on '{}'\".format(orig))",
            "",
            "",
            "def _to_text(obj, arg_encoding='utf-8', errors='strict', nonstring='strict'):",
            "    if isinstance(obj, str):",
            "        return obj",
            "    elif isinstance(obj, bytes):",
            "        return obj.decode(arg_encoding, errors)",
            "    else:",
            "        if nonstring == 'strict':",
            "            raise TypeError('First argument must be a string')",
            "        raise ValueError('nonstring must be one of: [\"strict\",]')",
            "",
            "",
            "_to_native = _to_text"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# vim:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:textwidth=0:",
            "",
            "from collections.abc import MutableMapping",
            "from jinja2 import sandbox",
            "",
            "",
            "# pylint: disable=no-member,unsupported-assignment-operation",
            "class TemplatedDictionary(MutableMapping):",
            "    \"\"\" Dictionary where __getitem__() is run through Jinja2 template \"\"\"",
            "    def __init__(self, *args, alias_spec=None, **kwargs):",
            "        '''",
            "        Use the object dict.",
            "",
            "        Optional parameter 'alias_spec' is dictionary of form:",
            "        {'aliased_to': ['alias_one', 'alias_two', ...], ...}",
            "        When specified, and one of the aliases is accessed - the",
            "        'aliased_to' config option is returned.",
            "        '''",
            "        self.__dict__.update(*args, **kwargs)",
            "",
            "        self.sandbox = sandbox.SandboxedEnvironment(keep_trailing_newline=True)",
            "",
            "        self._aliases = {}",
            "        if alias_spec:",
            "            for aliased_to, aliases in alias_spec.items():",
            "                for alias in aliases:",
            "                    self._aliases[alias] = aliased_to",
            "",
            "    # The next five methods are requirements of the ABC.",
            "    def __setitem__(self, key, value):",
            "        key = self._aliases.get(key, key)",
            "        self.__dict__[key] = value",
            "",
            "    def __getitem__(self, key):",
            "        key = self._aliases.get(key, key)",
            "        if '__jinja_expand' in self.__dict__ and self.__dict__['__jinja_expand']:",
            "            return self.__render_value(self.__dict__[key])",
            "        return self.__dict__[key]",
            "",
            "    def __delitem__(self, key):",
            "        del self.__dict__[key]",
            "",
            "    def __iter__(self):",
            "        return iter(self.__dict__)",
            "",
            "    def __len__(self):",
            "        return len(self.__dict__)",
            "",
            "    # The final two methods aren't required, but nice to have",
            "    def __str__(self):",
            "        '''returns simple dict representation of the mapping'''",
            "        return str(self.__dict__)",
            "",
            "    def __repr__(self):",
            "        '''echoes class, id, & reproducible representation in the REPL'''",
            "        return '{}, TemplatedDictionary({})'.format(super(TemplatedDictionary, self).__repr__(),",
            "                                                    self.__dict__)",
            "",
            "    def copy(self):",
            "        return TemplatedDictionary(self.__dict__)",
            "",
            "    def __render_value(self, value):",
            "        if isinstance(value, str):",
            "            return self.__render_string(value)",
            "        elif isinstance(value, list):",
            "            # we cannot use list comprehension here, as we need to NOT modify the list (pointer to list)",
            "            # and we need to modifiy only individual values in the list",
            "            # If we would create new list, we cannot assign to it, which often happens in configs (e.g. plugins)",
            "            for i in range(len(value)):  # pylint: disable=consider-using-enumerate",
            "                value[i] = self.__render_value(value[i])",
            "            return value",
            "        elif isinstance(value, dict):",
            "            # we cannot use list comprehension here, same reasoning as for `list` above",
            "            for k in value.keys():",
            "                value[k] = self.__render_value(value[k])",
            "            return value",
            "        else:",
            "            return value",
            "",
            "    def __render_string(self, value):",
            "        orig = last = value",
            "        max_recursion = self.__dict__.get('jinja_max_recursion', 5)",
            "        for _ in range(max_recursion):",
            "            value = _to_native(self.sandbox.from_string(value).render(self.__dict__, func=lambda:None))",
            "            if value == last:",
            "                return value",
            "            last = value",
            "        raise ValueError(\"too deep jinja re-evaluation on '{}'\".format(orig))",
            "",
            "",
            "def _to_text(obj, arg_encoding='utf-8', errors='strict', nonstring='strict'):",
            "    if isinstance(obj, str):",
            "        return obj",
            "    elif isinstance(obj, bytes):",
            "        return obj.decode(arg_encoding, errors)",
            "    else:",
            "        if nonstring == 'strict':",
            "            raise TypeError('First argument must be a string')",
            "        raise ValueError('nonstring must be one of: [\"strict\",]')",
            "",
            "",
            "_to_native = _to_text"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "83": [
                "TemplatedDictionary",
                "__render_string"
            ],
            "84": [
                "TemplatedDictionary",
                "__render_string"
            ]
        },
        "addLocation": []
    }
}