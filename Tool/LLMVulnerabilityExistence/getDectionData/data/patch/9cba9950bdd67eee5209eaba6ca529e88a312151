{
    "keylime/elchecking/__main__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " refstate = json.loads(refstate_str)"
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " log_bin = args.eventlog_file.read()"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " tpm = tpm_main.tpm()"
            },
            "3": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-log_data = tpm.parse_binary_bootlog(log_bin)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+_, log_data = tpm.parse_binary_bootlog(log_bin)"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " with open(\"/tmp/parsed.json\", \"wt\", encoding=\"utf-8\") as log_data_file:"
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     log_data_file.write(json.dumps(log_data, indent=True))"
            },
            "7": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " why_not = policy.evaluate(refstate, log_data)"
            }
        },
        "frontPatchFile": [
            "import argparse",
            "import json",
            "import sys",
            "",
            "from ..tpm import tpm_main",
            "from . import policies",
            "",
            "# This main module is just for command-line based testing.",
            "# It implements a command to do one test.",
            "# Invoke it with `python3 -m $packagename`, for some value of",
            "# `$packagename` that works with your `$PYTHONPATH`.",
            "",
            "",
            "parser = argparse.ArgumentParser()",
            "parser.add_argument(\"policy_name\", choices=policies.get_policy_names())",
            "parser.add_argument(\"refstate_file\", type=argparse.FileType(\"rt\"))",
            "parser.add_argument(\"eventlog_file\", type=argparse.FileType(\"rb\"), default=sys.stdin)",
            "args = parser.parse_args()",
            "policy = policies.get_policy(args.policy_name)",
            "refstate_str = args.refstate_file.read()",
            "refstate = json.loads(refstate_str)",
            "log_bin = args.eventlog_file.read()",
            "tpm = tpm_main.tpm()",
            "log_data = tpm.parse_binary_bootlog(log_bin)",
            "with open(\"/tmp/parsed.json\", \"wt\", encoding=\"utf-8\") as log_data_file:",
            "    log_data_file.write(json.dumps(log_data, indent=True))",
            "why_not = policy.evaluate(refstate, log_data)",
            "if why_not:",
            "    print(why_not, file=sys.stderr)",
            "    sys.exit(1)",
            "print(\"AOK\")"
        ],
        "afterPatchFile": [
            "import argparse",
            "import json",
            "import sys",
            "",
            "from ..tpm import tpm_main",
            "from . import policies",
            "",
            "# This main module is just for command-line based testing.",
            "# It implements a command to do one test.",
            "# Invoke it with `python3 -m $packagename`, for some value of",
            "# `$packagename` that works with your `$PYTHONPATH`.",
            "",
            "",
            "parser = argparse.ArgumentParser()",
            "parser.add_argument(\"policy_name\", choices=policies.get_policy_names())",
            "parser.add_argument(\"refstate_file\", type=argparse.FileType(\"rt\"))",
            "parser.add_argument(\"eventlog_file\", type=argparse.FileType(\"rb\"), default=sys.stdin)",
            "args = parser.parse_args()",
            "policy = policies.get_policy(args.policy_name)",
            "refstate_str = args.refstate_file.read()",
            "refstate = json.loads(refstate_str)",
            "log_bin = args.eventlog_file.read()",
            "tpm = tpm_main.tpm()",
            "_, log_data = tpm.parse_binary_bootlog(log_bin)",
            "with open(\"/tmp/parsed.json\", \"wt\", encoding=\"utf-8\") as log_data_file:",
            "    log_data_file.write(json.dumps(log_data, indent=True))",
            "why_not = policy.evaluate(refstate, log_data)",
            "if why_not:",
            "    print(why_not, file=sys.stderr)",
            "    sys.exit(1)",
            "print(\"AOK\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "24": [
                "log_data"
            ]
        },
        "addLocation": []
    },
    "keylime/elchecking/example.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         vd_shim_test = tests.OnceTest(tests.AcceptAll())"
            },
            "1": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         vd_authority.set(\"50ab5d60-46e0-0043-abb6-3dd810dd8b23\", \"Shim\", vd_shim_test)"
            },
            "2": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         vd_authority.set(\"605dab50-e046-4300-abb6-3dd810dd8b23\", \"Shim\", vd_shim_test)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+        # Because we validate the MokList, we do not check if the kernel should trust those keys."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+        vd_authority.set("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+            \"605dab50-e046-4300-abb6-3dd810dd8b23\","
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+            \"MokListTrusted\","
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+            tests.OnceTest("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+                tests.Or("
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+                    tests.FieldTest(\"Enabled\", tests.StringEqual(\"Yes\")),"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+                    tests.FieldTest(\"Enabled\", tests.StringEqual(\"No\")),"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+                )"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+            ),"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+        )"
            },
            "14": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         # A list of allowed digests for firmware from device driver appears"
            },
            "16": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         # in PCR2, event type EV_EFI_BOOT_SERVICES_DRIVER. Here we will just"
            },
            "17": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "                     tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.StringEqual(\"MokListX\"))),"
            },
            "18": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "                     tests.DigestsTest(digests_strip0x(refstate[\"mokxdig\"])),"
            },
            "19": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "                 ),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+                tests.And("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+                    tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.StringEqual(\"MokListTrusted\"))),"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+                    tests.OnceTest(tests.AcceptAll()),"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+                ),"
            },
            "24": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "             ),"
            },
            "25": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         )"
            },
            "26": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "         dispatcher.set("
            }
        },
        "frontPatchFile": [
            "import re",
            "import typing",
            "",
            "from . import policies, tests",
            "",
            "# The Example class is an example of a policy for checking boot event logs",
            "# against reference state.  This policy checks:",
            "# - that SecureBoot was enabled",
            "# - that a good BIOS, shim, grub, and kernel were run",
            "# - that only good keys are allowed",
            "# - that all known bad keys are forbidden",
            "# - the initial ramdisk contents and kernel command line were good",
            "#",
            "# This policy expects the reference state to be a dict created by `json.load`",
            "# containing the following.",
            "# scrtm_and_bios - list of allowed {",
            "#    scrtm - digest for PCR 0 event type EV_S_CRTM_VERSION",
            "#    platform_firmware - sequence of digest for PCR 0 event type EV_EFI_PLATFORM_FIRMWARE_BLOB",
            "# }",
            "# pk - list of allowed PK keys",
            "# kek - list of allowed KEK keys",
            "# db - list of allowed db keys",
            "# dbx - list of required dbx keys",
            "# mokdig - list of allowed digests of MoKList (PCR 14 EV_IPL)",
            "# mokxdig - list of allowed digests of MoKListX (PCR 14 EV_IPL)",
            "# kernels - list of allowed {",
            "#   shim_authcode_sha256: 0xhex (for PCR 4 EV_EFI_BOOT_SERVICES_APPLICATION),",
            "#   grub_authcode_sha256: 0xhex (for PCR 4 EV_EFI_BOOT_SERVICES_APPLICATION),",
            "#   kernel_authcode_sha256: 0xhex (for PCR 4 EV_EFI_BOOT_SERVICES_APPLICATION),",
            "#   initrd_plain_sha256: 0xhex (for PCR 9 EV_IPL),",
            "#   kernel_cmdline: regex (for PCR 8 EV_IPL event.Event)",
            "# }",
            "# Here 0xhex is a string starting with '0x' and continuing with lowercase",
            "# hex digits; in the case of a hash value, this includes leading zeros as",
            "# needed to express the full number of bytes the hash function is defined",
            "# to produce.",
            "# A digest is a map from hash-algorithm-name (sha1 or sha256) to 0xhex.",
            "# A key is {SignatureOwner: UUID, SignatureData: 0xhex}.",
            "",
            "# First, define some helper functions for checking that the refstate is valid.",
            "# They raise Exception when something invalid is encountered.",
            "",
            "hex_pat = re.compile(\"0x[0-9a-f]+\")",
            "",
            "",
            "def hex_test(dat: typing.Any) -> bool:",
            "    if isinstance(dat, str) and hex_pat.fullmatch(dat):",
            "        return True",
            "    raise Exception(f\"{dat!r} is not 0x followed by some lowercase hex digits\")",
            "",
            "",
            "digest_type_test = tests.dict_test(tests.type_test(str), hex_test)",
            "",
            "allowed_scrtm_and_bios_test = tests.obj_test(",
            "    scrtm=digest_type_test, platform_firmware=tests.list_test(digest_type_test)",
            ")",
            "",
            "allowed_scrtm_and_bios_list_test = tests.list_test(allowed_scrtm_and_bios_test)",
            "",
            "allowed_kernel_test = tests.obj_test(",
            "    shim_authcode_sha256=hex_test,",
            "    grub_authcode_sha256=hex_test,",
            "    kernel_authcode_sha256=hex_test,",
            "    initrd_plain_sha256=hex_test,",
            "    kernel_cmdline=tests.type_test(str),",
            ")",
            "",
            "allowed_kernel_list_test = tests.list_test(allowed_kernel_test)",
            "",
            "",
            "class Example(policies.Policy):",
            "    relevant_pcr_indices = frozenset(list(range(10)) + [14])",
            "",
            "    def get_relevant_pcrs(self) -> typing.FrozenSet[int]:",
            "        return self.relevant_pcr_indices",
            "",
            "    def refstate_to_test(self, refstate: policies.RefState) -> tests.Test:",
            "        \"\"\"Return the boot event log test corresponding to the given refstate",
            "        The given refstate is expected to be Python data coming from `json.load`\"\"\"",
            "        if not isinstance(refstate, dict):",
            "            raise Exception(f\"Expected refstate to be a Python dict but instead got this Python value: {refstate!r}\")",
            "",
            "        kernels = refstate.get(\"kernels\")",
            "        if not isinstance(kernels, list):",
            "            raise Exception(f\"refstate['kernels'] is {kernels!r} instead of a list\")",
            "        allowed_kernel_list_test(kernels)",
            "",
            "        scrtm_and_bios_spec = refstate.get(\"scrtm_and_bios\")",
            "        if scrtm_and_bios_spec is None:",
            "            raise Exception(\"refstate['scrtm_and_bios'] is missing\")",
            "        allowed_scrtm_and_bios_list_test(scrtm_and_bios_spec)",
            "        scrtm_and_bios_test = tests.Or(",
            "            *[",
            "                tests.And(",
            "                    tests.FieldTest(\"s_crtms\", tests.TupleTest(tests.DigestTest(digest_strip0x(allowed[\"scrtm\"])))),",
            "                    tests.FieldTest(",
            "                        \"platform_firmware_blobs\",",
            "                        tests.TupleTest(*[tests.DigestTest(digest_strip0x(pf)) for pf in allowed[\"platform_firmware\"]]),",
            "                    ),",
            "                )",
            "                for allowed in scrtm_and_bios_spec",
            "            ]",
            "        )",
            "",
            "        for req in (\"pk\", \"kek\", \"db\", \"dbx\", \"mokdig\", \"mokxdig\"):",
            "            if req not in refstate:",
            "                raise Exception(f\"refstate lacks {req}\")",
            "",
            "        dispatcher = tests.Dispatcher((\"PCRIndex\", \"EventType\"))",
            "        vd_driver_config = tests.VariableDispatch()",
            "        vd_authority = tests.VariableDispatch()",
            "",
            "        def bsa_test(kernel: dict) -> tests.Test:",
            "            tt = [",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"shim_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"grub_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"kernel_authcode_sha256\"])}),",
            "            ]",
            "",
            "            # In some scenarios the kernel gets measured twice",
            "            tt2 = [",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"shim_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"grub_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"kernel_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"kernel_authcode_sha256\"])}),",
            "            ]",
            "            return tests.Or(tests.TupleTest(*tt), tests.TupleTest(*tt2))",
            "",
            "        events_final = tests.DelayToFields(",
            "            tests.And(",
            "                tests.Or(",
            "                    *[",
            "                        tests.FieldsTest(",
            "                            bsas=bsa_test(kernel),",
            "                            ipl9s=tests.TupleTest(",
            "                                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"initrd_plain_sha256\"])})",
            "                            ),",
            "                            kernel_cmdlines=tests.TupleTest(",
            "                                tests.RegExp(\"kernel_cmdline: \" + kernel[\"kernel_cmdline\"])",
            "                            ),",
            "                        )",
            "                        for kernel in kernels",
            "                    ]",
            "                ),",
            "                scrtm_and_bios_test,",
            "            ),",
            "            \"kernel_cmdlines\",",
            "            \"bsas\",",
            "            \"ipl9s\",",
            "            \"s_crtms\",",
            "            \"platform_firmware_blobs\",",
            "        )",
            "        # We only expect one EV_NO_ACTION event at the start.",
            "        dispatcher.set((0, \"EV_NO_ACTION\"), tests.OnceTest(tests.AcceptAll()))",
            "        dispatcher.set((0, \"EV_S_CRTM_VERSION\"), events_final.get(\"s_crtms\"))",
            "        dispatcher.set((0, \"EV_EFI_PLATFORM_FIRMWARE_BLOB\"), events_final.get(\"platform_firmware_blobs\"))",
            "        dispatcher.set((7, \"EV_EFI_VARIABLE_DRIVER_CONFIG\"), vd_driver_config)",
            "        # tpm2-tools versions < 5.2 parsed the GUIDs wrong therefore we include a check for both here",
            "        # For more information see: https://github.com/keylime/keylime/issues/1003",
            "        secure_boot_test = tests.FieldTest(\"Enabled\", tests.StringEqual(\"Yes\"))",
            "        vd_driver_config.set(\"61dfe48b-ca93-d211-aa0d-00e098032b8c\", \"SecureBoot\", secure_boot_test)",
            "        vd_driver_config.set(\"8be4df61-93ca-11d2-aa0d-00e098032b8c\", \"SecureBoot\", secure_boot_test)",
            "        pk_test = tests.OnceTest(",
            "            tests.Or(",
            "                tests.KeySubset(\"a159c0a5-e494-a74a-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"pk\"])),",
            "                tests.KeySubset(\"a5c059a1-94e4-4aa7-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"pk\"])),",
            "            )",
            "        )",
            "        vd_driver_config.set(",
            "            \"61dfe48b-ca93-d211-aa0d-00e098032b8c\",",
            "            \"PK\",",
            "            pk_test,",
            "        )",
            "        vd_driver_config.set(",
            "            \"8be4df61-93ca-11d2-aa0d-00e098032b8c\",",
            "            \"PK\",",
            "            pk_test,",
            "        )",
            "",
            "        kek_test = tests.OnceTest(",
            "            tests.Or(",
            "                tests.KeySubset(\"a159c0a5-e494-a74a-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"kek\"])),",
            "                tests.KeySubset(\"a5c059a1-94e4-4aa7-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"kek\"])),",
            "            )",
            "        )",
            "        vd_driver_config.set(",
            "            \"61dfe48b-ca93-d211-aa0d-00e098032b8c\",",
            "            \"KEK\",",
            "            kek_test,",
            "        )",
            "        vd_driver_config.set(",
            "            \"8be4df61-93ca-11d2-aa0d-00e098032b8c\",",
            "            \"KEK\",",
            "            kek_test,",
            "        )",
            "        db_test = tests.OnceTest(",
            "            tests.Or(",
            "                tests.KeySubset(\"a159c0a5-e494-a74a-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"db\"])),",
            "                tests.KeySubset(\"a5c059a1-94e4-4aa7-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"db\"])),",
            "            )",
            "        )",
            "        vd_driver_config.set(",
            "            \"cbb219d7-3a3d-9645-a3bc-dad00e67656f\",",
            "            \"db\",",
            "            db_test,",
            "        )",
            "        vd_driver_config.set(",
            "            \"d719b2cb-3d3a-4596-a3bc-dad00e67656f\",",
            "            \"db\",",
            "            db_test,",
            "        )",
            "        dbx_test = tests.OnceTest(",
            "            tests.Or(",
            "                tests.KeySuperset(\"2616c4c1-4c50-9240-aca9-41f936934328\", sigs_strip0x(refstate[\"dbx\"])),",
            "                tests.KeySuperset(\"c1c41626-504c-4092-aca9-41f936934328\", sigs_strip0x(refstate[\"dbx\"])),",
            "            )",
            "        )",
            "        vd_driver_config.set(",
            "            \"cbb219d7-3a3d-9645-a3bc-dad00e67656f\",",
            "            \"dbx\",",
            "            dbx_test,",
            "        )",
            "        vd_driver_config.set(",
            "            \"d719b2cb-3d3a-4596-a3bc-dad00e67656f\",",
            "            \"dbx\",",
            "            dbx_test,",
            "        )",
            "        dispatcher.set((7, \"EV_EFI_VARIABLE_AUTHORITY\"), vd_authority)",
            "        # Assume that the cert that was used to verify the Shim is always trusted.",
            "        # TODO: can we use the db entry for that instead of AcceptAll?",
            "        vd_db_test = tests.OnceTest(tests.AcceptAll())",
            "        vd_authority.set(\"cbb219d7-3a3d-9645-a3bc-dad00e67656f\", \"db\", vd_db_test)",
            "        vd_authority.set(\"d719b2cb-3d3a-4596-a3bc-dad00e67656f\", \"db\", vd_db_test)",
            "        # Accept all SbatLevels of the Shim, because we already checked the hash of the Shim itself.",
            "        vd_sbat_level_test = tests.OnceTest(tests.AcceptAll())",
            "        vd_authority.set(\"50ab5d60-46e0-0043-abb6-3dd810dd8b23\", \"SbatLevel\", vd_sbat_level_test)",
            "        vd_authority.set(\"605dab50-e046-4300-abb6-3dd810dd8b23\", \"SbatLevel\", vd_sbat_level_test)",
            "        # Accept all certificates that are used by the Shim to verify the next component,",
            "        # because we already checked the hash of the Shim itself.",
            "        vd_shim_test = tests.OnceTest(tests.AcceptAll())",
            "        vd_authority.set(\"50ab5d60-46e0-0043-abb6-3dd810dd8b23\", \"Shim\", vd_shim_test)",
            "        vd_authority.set(\"605dab50-e046-4300-abb6-3dd810dd8b23\", \"Shim\", vd_shim_test)",
            "",
            "        # A list of allowed digests for firmware from device driver appears",
            "        # in PCR2, event type EV_EFI_BOOT_SERVICES_DRIVER. Here we will just",
            "        # accept everything.",
            "        # This is fine because we do not use any other entry type from PCR 2 for validation.",
            "        dispatcher.set((2, \"EV_EFI_BOOT_SERVICES_DRIVER\"), tests.AcceptAll())",
            "        dispatcher.set(",
            "            (1, \"EV_EFI_VARIABLE_BOOT\"),",
            "            tests.Or(",
            "                tests.VariableTest(",
            "                    \"61dfe48b-ca93-d211-aa0d-00e098032b8c\", re.compile(\"BootOrder|Boot[0-9a-fA-F]+\"), tests.AcceptAll()",
            "                ),",
            "                tests.VariableTest(",
            "                    \"8be4df61-93ca-11d2-aa0d-00e098032b8c\", re.compile(\"BootOrder|Boot[0-9a-fA-F]+\"), tests.AcceptAll()",
            "                ),",
            "            ),",
            "        )",
            "        dispatcher.set((4, \"EV_EFI_ACTION\"), tests.EvEfiActionTest(4))",
            "        for pcr in range(8):",
            "            dispatcher.set((pcr, \"EV_SEPARATOR\"), tests.EvSeperatorTest())",
            "",
            "        dispatcher.set((4, \"EV_EFI_BOOT_SERVICES_APPLICATION\"), events_final.get(\"bsas\"))",
            "        dispatcher.set(",
            "            (14, \"EV_IPL\"),",
            "            tests.Or(",
            "                tests.And(",
            "                    tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.StringEqual(\"MokList\"))),",
            "                    tests.DigestsTest(digests_strip0x(refstate[\"mokdig\"])),",
            "                ),",
            "                tests.And(",
            "                    tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.StringEqual(\"MokListX\"))),",
            "                    tests.DigestsTest(digests_strip0x(refstate[\"mokxdig\"])),",
            "                ),",
            "            ),",
            "        )",
            "        dispatcher.set(",
            "            (9, \"EV_IPL\"),",
            "            tests.Or(",
            "                tests.FieldTest(",
            "                    \"Event\", tests.FieldTest(\"String\", tests.RegExp(r\".*/loader/entries.*\"))",
            "                ),  # Ignore  Boot Loader Spec files",
            "                tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.RegExp(r\".*/grub.*\"))),",
            "                tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.RegExp(r\".*/vmlinuz.*\"))),",
            "                tests.And(",
            "                    tests.FieldTest(",
            "                        \"Event\",",
            "                        tests.FieldTest(",
            "                            \"String\",",
            "                            tests.Or(",
            "                                tests.RegExp(r\".*/initrd.*\"),",
            "                                tests.RegExp(r\".*/initramfs.*\"),",
            "                            ),",
            "                        ),",
            "                    ),",
            "                    events_final.get(\"ipl9s\"),",
            "                ),",
            "            ),",
            "        )",
            "        dispatcher.set(",
            "            (8, \"EV_IPL\"),",
            "            tests.FieldTest(",
            "                \"Event\",",
            "                tests.FieldTest(",
            "                    \"String\",",
            "                    tests.Or(",
            "                        tests.RegExp(\"grub_cmd: .*\", re.DOTALL),",
            "                        tests.And(tests.RegExp(\"kernel_cmdline: .*\"), events_final.get(\"kernel_cmdlines\")),",
            "                    ),",
            "                ),",
            "            ),",
            "        )",
            "        dispatcher.set((5, \"EV_EFI_ACTION\"), tests.EvEfiActionTest(5))",
            "        # Accept all UEFI_GPT_DATA. We only expect one entry for that.",
            "        dispatcher.set((5, \"EV_EFI_GPT_EVENT\"), tests.OnceTest(tests.AcceptAll()))",
            "        events_test = tests.FieldTest(",
            "            \"events\",",
            "            tests.And(events_final.get_initializer(), tests.IterateTest(dispatcher, show_elt=True), events_final),",
            "            show_name=False,",
            "        )",
            "        return events_test",
            "",
            "",
            "def string_strip0x(con: str) -> str:",
            "    if con.startswith(\"0x\"):",
            "        return con[2:]",
            "    raise Exception(f\"{con!r} does not start with 0x\")",
            "",
            "",
            "def digest_strip0x(digest: typing.Dict[str, str]) -> tests.Digest:",
            "    digest_type_test(digest)",
            "    return {alg: string_strip0x(val) for alg, val in digest.items()}",
            "",
            "",
            "def digests_strip0x(digests: typing.List[typing.Dict[str, str]]) -> typing.List[tests.Digest]:",
            "    tests.type_test(list)(digests)",
            "    return map(digest_strip0x, digests)",
            "",
            "",
            "def sig_strip0x(sig: typing.Dict[str, str]) -> tests.Signature:",
            "    tests.obj_test(SignatureOwner=tests.type_test(str), SignatureData=tests.type_test(str))(sig)",
            "    return dict(SignatureOwner=sig[\"SignatureOwner\"], SignatureData=string_strip0x(sig[\"SignatureData\"]))",
            "",
            "",
            "def sigs_strip0x(sigs: typing.Iterable[typing.Dict[str, str]]) -> typing.List[tests.Signature]:",
            "    tests.type_test(typing.Iterable)(sigs)",
            "    return map(sig_strip0x, sigs)",
            "",
            "",
            "policies.register(\"example\", Example())"
        ],
        "afterPatchFile": [
            "import re",
            "import typing",
            "",
            "from . import policies, tests",
            "",
            "# The Example class is an example of a policy for checking boot event logs",
            "# against reference state.  This policy checks:",
            "# - that SecureBoot was enabled",
            "# - that a good BIOS, shim, grub, and kernel were run",
            "# - that only good keys are allowed",
            "# - that all known bad keys are forbidden",
            "# - the initial ramdisk contents and kernel command line were good",
            "#",
            "# This policy expects the reference state to be a dict created by `json.load`",
            "# containing the following.",
            "# scrtm_and_bios - list of allowed {",
            "#    scrtm - digest for PCR 0 event type EV_S_CRTM_VERSION",
            "#    platform_firmware - sequence of digest for PCR 0 event type EV_EFI_PLATFORM_FIRMWARE_BLOB",
            "# }",
            "# pk - list of allowed PK keys",
            "# kek - list of allowed KEK keys",
            "# db - list of allowed db keys",
            "# dbx - list of required dbx keys",
            "# mokdig - list of allowed digests of MoKList (PCR 14 EV_IPL)",
            "# mokxdig - list of allowed digests of MoKListX (PCR 14 EV_IPL)",
            "# kernels - list of allowed {",
            "#   shim_authcode_sha256: 0xhex (for PCR 4 EV_EFI_BOOT_SERVICES_APPLICATION),",
            "#   grub_authcode_sha256: 0xhex (for PCR 4 EV_EFI_BOOT_SERVICES_APPLICATION),",
            "#   kernel_authcode_sha256: 0xhex (for PCR 4 EV_EFI_BOOT_SERVICES_APPLICATION),",
            "#   initrd_plain_sha256: 0xhex (for PCR 9 EV_IPL),",
            "#   kernel_cmdline: regex (for PCR 8 EV_IPL event.Event)",
            "# }",
            "# Here 0xhex is a string starting with '0x' and continuing with lowercase",
            "# hex digits; in the case of a hash value, this includes leading zeros as",
            "# needed to express the full number of bytes the hash function is defined",
            "# to produce.",
            "# A digest is a map from hash-algorithm-name (sha1 or sha256) to 0xhex.",
            "# A key is {SignatureOwner: UUID, SignatureData: 0xhex}.",
            "",
            "# First, define some helper functions for checking that the refstate is valid.",
            "# They raise Exception when something invalid is encountered.",
            "",
            "hex_pat = re.compile(\"0x[0-9a-f]+\")",
            "",
            "",
            "def hex_test(dat: typing.Any) -> bool:",
            "    if isinstance(dat, str) and hex_pat.fullmatch(dat):",
            "        return True",
            "    raise Exception(f\"{dat!r} is not 0x followed by some lowercase hex digits\")",
            "",
            "",
            "digest_type_test = tests.dict_test(tests.type_test(str), hex_test)",
            "",
            "allowed_scrtm_and_bios_test = tests.obj_test(",
            "    scrtm=digest_type_test, platform_firmware=tests.list_test(digest_type_test)",
            ")",
            "",
            "allowed_scrtm_and_bios_list_test = tests.list_test(allowed_scrtm_and_bios_test)",
            "",
            "allowed_kernel_test = tests.obj_test(",
            "    shim_authcode_sha256=hex_test,",
            "    grub_authcode_sha256=hex_test,",
            "    kernel_authcode_sha256=hex_test,",
            "    initrd_plain_sha256=hex_test,",
            "    kernel_cmdline=tests.type_test(str),",
            ")",
            "",
            "allowed_kernel_list_test = tests.list_test(allowed_kernel_test)",
            "",
            "",
            "class Example(policies.Policy):",
            "    relevant_pcr_indices = frozenset(list(range(10)) + [14])",
            "",
            "    def get_relevant_pcrs(self) -> typing.FrozenSet[int]:",
            "        return self.relevant_pcr_indices",
            "",
            "    def refstate_to_test(self, refstate: policies.RefState) -> tests.Test:",
            "        \"\"\"Return the boot event log test corresponding to the given refstate",
            "        The given refstate is expected to be Python data coming from `json.load`\"\"\"",
            "        if not isinstance(refstate, dict):",
            "            raise Exception(f\"Expected refstate to be a Python dict but instead got this Python value: {refstate!r}\")",
            "",
            "        kernels = refstate.get(\"kernels\")",
            "        if not isinstance(kernels, list):",
            "            raise Exception(f\"refstate['kernels'] is {kernels!r} instead of a list\")",
            "        allowed_kernel_list_test(kernels)",
            "",
            "        scrtm_and_bios_spec = refstate.get(\"scrtm_and_bios\")",
            "        if scrtm_and_bios_spec is None:",
            "            raise Exception(\"refstate['scrtm_and_bios'] is missing\")",
            "        allowed_scrtm_and_bios_list_test(scrtm_and_bios_spec)",
            "        scrtm_and_bios_test = tests.Or(",
            "            *[",
            "                tests.And(",
            "                    tests.FieldTest(\"s_crtms\", tests.TupleTest(tests.DigestTest(digest_strip0x(allowed[\"scrtm\"])))),",
            "                    tests.FieldTest(",
            "                        \"platform_firmware_blobs\",",
            "                        tests.TupleTest(*[tests.DigestTest(digest_strip0x(pf)) for pf in allowed[\"platform_firmware\"]]),",
            "                    ),",
            "                )",
            "                for allowed in scrtm_and_bios_spec",
            "            ]",
            "        )",
            "",
            "        for req in (\"pk\", \"kek\", \"db\", \"dbx\", \"mokdig\", \"mokxdig\"):",
            "            if req not in refstate:",
            "                raise Exception(f\"refstate lacks {req}\")",
            "",
            "        dispatcher = tests.Dispatcher((\"PCRIndex\", \"EventType\"))",
            "        vd_driver_config = tests.VariableDispatch()",
            "        vd_authority = tests.VariableDispatch()",
            "",
            "        def bsa_test(kernel: dict) -> tests.Test:",
            "            tt = [",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"shim_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"grub_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"kernel_authcode_sha256\"])}),",
            "            ]",
            "",
            "            # In some scenarios the kernel gets measured twice",
            "            tt2 = [",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"shim_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"grub_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"kernel_authcode_sha256\"])}),",
            "                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"kernel_authcode_sha256\"])}),",
            "            ]",
            "            return tests.Or(tests.TupleTest(*tt), tests.TupleTest(*tt2))",
            "",
            "        events_final = tests.DelayToFields(",
            "            tests.And(",
            "                tests.Or(",
            "                    *[",
            "                        tests.FieldsTest(",
            "                            bsas=bsa_test(kernel),",
            "                            ipl9s=tests.TupleTest(",
            "                                tests.DigestTest({\"sha256\": string_strip0x(kernel[\"initrd_plain_sha256\"])})",
            "                            ),",
            "                            kernel_cmdlines=tests.TupleTest(",
            "                                tests.RegExp(\"kernel_cmdline: \" + kernel[\"kernel_cmdline\"])",
            "                            ),",
            "                        )",
            "                        for kernel in kernels",
            "                    ]",
            "                ),",
            "                scrtm_and_bios_test,",
            "            ),",
            "            \"kernel_cmdlines\",",
            "            \"bsas\",",
            "            \"ipl9s\",",
            "            \"s_crtms\",",
            "            \"platform_firmware_blobs\",",
            "        )",
            "        # We only expect one EV_NO_ACTION event at the start.",
            "        dispatcher.set((0, \"EV_NO_ACTION\"), tests.OnceTest(tests.AcceptAll()))",
            "        dispatcher.set((0, \"EV_S_CRTM_VERSION\"), events_final.get(\"s_crtms\"))",
            "        dispatcher.set((0, \"EV_EFI_PLATFORM_FIRMWARE_BLOB\"), events_final.get(\"platform_firmware_blobs\"))",
            "        dispatcher.set((7, \"EV_EFI_VARIABLE_DRIVER_CONFIG\"), vd_driver_config)",
            "        # tpm2-tools versions < 5.2 parsed the GUIDs wrong therefore we include a check for both here",
            "        # For more information see: https://github.com/keylime/keylime/issues/1003",
            "        secure_boot_test = tests.FieldTest(\"Enabled\", tests.StringEqual(\"Yes\"))",
            "        vd_driver_config.set(\"61dfe48b-ca93-d211-aa0d-00e098032b8c\", \"SecureBoot\", secure_boot_test)",
            "        vd_driver_config.set(\"8be4df61-93ca-11d2-aa0d-00e098032b8c\", \"SecureBoot\", secure_boot_test)",
            "        pk_test = tests.OnceTest(",
            "            tests.Or(",
            "                tests.KeySubset(\"a159c0a5-e494-a74a-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"pk\"])),",
            "                tests.KeySubset(\"a5c059a1-94e4-4aa7-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"pk\"])),",
            "            )",
            "        )",
            "        vd_driver_config.set(",
            "            \"61dfe48b-ca93-d211-aa0d-00e098032b8c\",",
            "            \"PK\",",
            "            pk_test,",
            "        )",
            "        vd_driver_config.set(",
            "            \"8be4df61-93ca-11d2-aa0d-00e098032b8c\",",
            "            \"PK\",",
            "            pk_test,",
            "        )",
            "",
            "        kek_test = tests.OnceTest(",
            "            tests.Or(",
            "                tests.KeySubset(\"a159c0a5-e494-a74a-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"kek\"])),",
            "                tests.KeySubset(\"a5c059a1-94e4-4aa7-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"kek\"])),",
            "            )",
            "        )",
            "        vd_driver_config.set(",
            "            \"61dfe48b-ca93-d211-aa0d-00e098032b8c\",",
            "            \"KEK\",",
            "            kek_test,",
            "        )",
            "        vd_driver_config.set(",
            "            \"8be4df61-93ca-11d2-aa0d-00e098032b8c\",",
            "            \"KEK\",",
            "            kek_test,",
            "        )",
            "        db_test = tests.OnceTest(",
            "            tests.Or(",
            "                tests.KeySubset(\"a159c0a5-e494-a74a-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"db\"])),",
            "                tests.KeySubset(\"a5c059a1-94e4-4aa7-87b5-ab155c2bf072\", sigs_strip0x(refstate[\"db\"])),",
            "            )",
            "        )",
            "        vd_driver_config.set(",
            "            \"cbb219d7-3a3d-9645-a3bc-dad00e67656f\",",
            "            \"db\",",
            "            db_test,",
            "        )",
            "        vd_driver_config.set(",
            "            \"d719b2cb-3d3a-4596-a3bc-dad00e67656f\",",
            "            \"db\",",
            "            db_test,",
            "        )",
            "        dbx_test = tests.OnceTest(",
            "            tests.Or(",
            "                tests.KeySuperset(\"2616c4c1-4c50-9240-aca9-41f936934328\", sigs_strip0x(refstate[\"dbx\"])),",
            "                tests.KeySuperset(\"c1c41626-504c-4092-aca9-41f936934328\", sigs_strip0x(refstate[\"dbx\"])),",
            "            )",
            "        )",
            "        vd_driver_config.set(",
            "            \"cbb219d7-3a3d-9645-a3bc-dad00e67656f\",",
            "            \"dbx\",",
            "            dbx_test,",
            "        )",
            "        vd_driver_config.set(",
            "            \"d719b2cb-3d3a-4596-a3bc-dad00e67656f\",",
            "            \"dbx\",",
            "            dbx_test,",
            "        )",
            "        dispatcher.set((7, \"EV_EFI_VARIABLE_AUTHORITY\"), vd_authority)",
            "        # Assume that the cert that was used to verify the Shim is always trusted.",
            "        # TODO: can we use the db entry for that instead of AcceptAll?",
            "        vd_db_test = tests.OnceTest(tests.AcceptAll())",
            "        vd_authority.set(\"cbb219d7-3a3d-9645-a3bc-dad00e67656f\", \"db\", vd_db_test)",
            "        vd_authority.set(\"d719b2cb-3d3a-4596-a3bc-dad00e67656f\", \"db\", vd_db_test)",
            "        # Accept all SbatLevels of the Shim, because we already checked the hash of the Shim itself.",
            "        vd_sbat_level_test = tests.OnceTest(tests.AcceptAll())",
            "        vd_authority.set(\"50ab5d60-46e0-0043-abb6-3dd810dd8b23\", \"SbatLevel\", vd_sbat_level_test)",
            "        vd_authority.set(\"605dab50-e046-4300-abb6-3dd810dd8b23\", \"SbatLevel\", vd_sbat_level_test)",
            "        # Accept all certificates that are used by the Shim to verify the next component,",
            "        # because we already checked the hash of the Shim itself.",
            "        vd_shim_test = tests.OnceTest(tests.AcceptAll())",
            "        vd_authority.set(\"50ab5d60-46e0-0043-abb6-3dd810dd8b23\", \"Shim\", vd_shim_test)",
            "        vd_authority.set(\"605dab50-e046-4300-abb6-3dd810dd8b23\", \"Shim\", vd_shim_test)",
            "        # Because we validate the MokList, we do not check if the kernel should trust those keys.",
            "        vd_authority.set(",
            "            \"605dab50-e046-4300-abb6-3dd810dd8b23\",",
            "            \"MokListTrusted\",",
            "            tests.OnceTest(",
            "                tests.Or(",
            "                    tests.FieldTest(\"Enabled\", tests.StringEqual(\"Yes\")),",
            "                    tests.FieldTest(\"Enabled\", tests.StringEqual(\"No\")),",
            "                )",
            "            ),",
            "        )",
            "",
            "        # A list of allowed digests for firmware from device driver appears",
            "        # in PCR2, event type EV_EFI_BOOT_SERVICES_DRIVER. Here we will just",
            "        # accept everything.",
            "        # This is fine because we do not use any other entry type from PCR 2 for validation.",
            "        dispatcher.set((2, \"EV_EFI_BOOT_SERVICES_DRIVER\"), tests.AcceptAll())",
            "        dispatcher.set(",
            "            (1, \"EV_EFI_VARIABLE_BOOT\"),",
            "            tests.Or(",
            "                tests.VariableTest(",
            "                    \"61dfe48b-ca93-d211-aa0d-00e098032b8c\", re.compile(\"BootOrder|Boot[0-9a-fA-F]+\"), tests.AcceptAll()",
            "                ),",
            "                tests.VariableTest(",
            "                    \"8be4df61-93ca-11d2-aa0d-00e098032b8c\", re.compile(\"BootOrder|Boot[0-9a-fA-F]+\"), tests.AcceptAll()",
            "                ),",
            "            ),",
            "        )",
            "        dispatcher.set((4, \"EV_EFI_ACTION\"), tests.EvEfiActionTest(4))",
            "        for pcr in range(8):",
            "            dispatcher.set((pcr, \"EV_SEPARATOR\"), tests.EvSeperatorTest())",
            "",
            "        dispatcher.set((4, \"EV_EFI_BOOT_SERVICES_APPLICATION\"), events_final.get(\"bsas\"))",
            "        dispatcher.set(",
            "            (14, \"EV_IPL\"),",
            "            tests.Or(",
            "                tests.And(",
            "                    tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.StringEqual(\"MokList\"))),",
            "                    tests.DigestsTest(digests_strip0x(refstate[\"mokdig\"])),",
            "                ),",
            "                tests.And(",
            "                    tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.StringEqual(\"MokListX\"))),",
            "                    tests.DigestsTest(digests_strip0x(refstate[\"mokxdig\"])),",
            "                ),",
            "                tests.And(",
            "                    tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.StringEqual(\"MokListTrusted\"))),",
            "                    tests.OnceTest(tests.AcceptAll()),",
            "                ),",
            "            ),",
            "        )",
            "        dispatcher.set(",
            "            (9, \"EV_IPL\"),",
            "            tests.Or(",
            "                tests.FieldTest(",
            "                    \"Event\", tests.FieldTest(\"String\", tests.RegExp(r\".*/loader/entries.*\"))",
            "                ),  # Ignore  Boot Loader Spec files",
            "                tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.RegExp(r\".*/grub.*\"))),",
            "                tests.FieldTest(\"Event\", tests.FieldTest(\"String\", tests.RegExp(r\".*/vmlinuz.*\"))),",
            "                tests.And(",
            "                    tests.FieldTest(",
            "                        \"Event\",",
            "                        tests.FieldTest(",
            "                            \"String\",",
            "                            tests.Or(",
            "                                tests.RegExp(r\".*/initrd.*\"),",
            "                                tests.RegExp(r\".*/initramfs.*\"),",
            "                            ),",
            "                        ),",
            "                    ),",
            "                    events_final.get(\"ipl9s\"),",
            "                ),",
            "            ),",
            "        )",
            "        dispatcher.set(",
            "            (8, \"EV_IPL\"),",
            "            tests.FieldTest(",
            "                \"Event\",",
            "                tests.FieldTest(",
            "                    \"String\",",
            "                    tests.Or(",
            "                        tests.RegExp(\"grub_cmd: .*\", re.DOTALL),",
            "                        tests.And(tests.RegExp(\"kernel_cmdline: .*\"), events_final.get(\"kernel_cmdlines\")),",
            "                    ),",
            "                ),",
            "            ),",
            "        )",
            "        dispatcher.set((5, \"EV_EFI_ACTION\"), tests.EvEfiActionTest(5))",
            "        # Accept all UEFI_GPT_DATA. We only expect one entry for that.",
            "        dispatcher.set((5, \"EV_EFI_GPT_EVENT\"), tests.OnceTest(tests.AcceptAll()))",
            "        events_test = tests.FieldTest(",
            "            \"events\",",
            "            tests.And(events_final.get_initializer(), tests.IterateTest(dispatcher, show_elt=True), events_final),",
            "            show_name=False,",
            "        )",
            "        return events_test",
            "",
            "",
            "def string_strip0x(con: str) -> str:",
            "    if con.startswith(\"0x\"):",
            "        return con[2:]",
            "    raise Exception(f\"{con!r} does not start with 0x\")",
            "",
            "",
            "def digest_strip0x(digest: typing.Dict[str, str]) -> tests.Digest:",
            "    digest_type_test(digest)",
            "    return {alg: string_strip0x(val) for alg, val in digest.items()}",
            "",
            "",
            "def digests_strip0x(digests: typing.List[typing.Dict[str, str]]) -> typing.List[tests.Digest]:",
            "    tests.type_test(list)(digests)",
            "    return map(digest_strip0x, digests)",
            "",
            "",
            "def sig_strip0x(sig: typing.Dict[str, str]) -> tests.Signature:",
            "    tests.obj_test(SignatureOwner=tests.type_test(str), SignatureData=tests.type_test(str))(sig)",
            "    return dict(SignatureOwner=sig[\"SignatureOwner\"], SignatureData=string_strip0x(sig[\"SignatureData\"]))",
            "",
            "",
            "def sigs_strip0x(sigs: typing.Iterable[typing.Dict[str, str]]) -> typing.List[tests.Signature]:",
            "    tests.type_test(typing.Iterable)(sigs)",
            "    return map(sig_strip0x, sigs)",
            "",
            "",
            "policies.register(\"example\", Example())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.pyload.webui.app"
        ]
    },
    "keylime/elchecking/tests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         self.key_names = key_names"
            },
            "1": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         self.tests = {}"
            },
            "2": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def set(self, key_vals: typing.Tuple[str, ...], test: Test) -> None:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+    def set(self, key_vals: typing.Tuple[typing.Union[int, str], ...], test: Test) -> None:"
            },
            "5": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         \"\"\"Set the test for the given value tuple\"\"\""
            },
            "6": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         if len(key_vals) != len(self.key_names):"
            },
            "7": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "             raise Exception(f\"{key_vals!a} does not match length of {self.key_names}\")"
            }
        },
        "frontPatchFile": [
            "import abc",
            "import codecs",
            "import re",
            "import typing",
            "",
            "from keylime.common.algorithms import Hash",
            "",
            "# This module defines the abstraction of a Test (of JSON data)",
            "# and several specific test classes.",
            "# A Test can be used multiple times, even concurrently.",
            "",
            "# Data is the type of Python data that corresponds to JSON values.",
            "Data = typing.Union[int, float, str, bool, typing.Tuple[\"Data\", ...], typing.Mapping[str, \"Data\"], None]",
            "",
            "# Globals is a dict of variables for communication among tests.",
            "# There is a distinct dict for each top-level use of a test.",
            "Globals = typing.Mapping[str, Data]",
            "",
            "# PCR_Contents maps digest name to map from PCR index to PCR value.",
            "# Here digest name is something like 'sha256'.",
            "# Each PCR index is a decimal string, so that this can be JSON data",
            "PCR_Contents = typing.Mapping[str, typing.Mapping[str, int]]",
            "",
            "",
            "class Test(metaclass=abc.ABCMeta):",
            "    \"\"\"Test is something that can examine a value and either approve it or give a reason for rejection\"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        \"\"\"Test the given value, return empty string for pass, explanation for fail.",
            "",
            "        The explanation is (except in deliberate exceptions) English that",
            "        makes a sentence when placed after a noun phrase identifying the subject.",
            "        The test can read and write in the given globs dict.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "# type_test constructs a test of data type that is expected to pass.",
            "# This and the following are used to check reference state for bugs.",
            "def type_test(t) -> typing.Callable[[typing.Any], bool]:",
            "    \"\"\"Returns a lambda that tests against the given type.",
            "    The lambda returns True on pass, raises Exception on fail.\"\"\"",
            "",
            "    def test(v: typing.Any) -> bool:",
            "        if isinstance(v, t):",
            "            return True",
            "        raise Exception(f\"{v!r} is a {type(v)} rather than a {t}\")",
            "",
            "    return test",
            "",
            "",
            "def list_test(elt_test: typing.Callable[[typing.Any], bool]) -> typing.Callable[[typing.Any], bool]:",
            "    \"\"\"Return a lambda that tests for list with certain type of element\"\"\"",
            "",
            "    def test(dat: typing.Any) -> bool:",
            "        type_test(list)(dat)",
            "        for elt in dat:",
            "            elt_test(elt)",
            "        return True",
            "",
            "    return test",
            "",
            "",
            "def dict_test(",
            "    dom_test: typing.Callable[[typing.Any], bool], rng_test: typing.Callable[[typing.Any], bool]",
            ") -> typing.Callable[[typing.Any], bool]:",
            "    \"\"\"Return a lambda that tests for dict with certain type key and value\"\"\"",
            "",
            "    def test(dat: typing.Any) -> bool:",
            "        type_test(dict)(dat)",
            "        for dom, rng in dat.items():",
            "            dom_test(dom)",
            "            rng_test(rng)",
            "        return True",
            "",
            "    return test",
            "",
            "",
            "def obj_test(**field_tests: typing.Callable[[typing.Any], bool]) -> typing.Callable[[typing.Any], bool]:",
            "    \"\"\"Return a lambda that tests for dict with string keys and a particular type for each key\"\"\"",
            "",
            "    def test(dat: typing.Any) -> bool:",
            "        type_test(dict)(dat)",
            "        dom_test = type_test(str)",
            "        for dom, rng in dat.items():",
            "            dom_test(dom)",
            "            if dom not in field_tests:",
            "                continue",
            "            rng_test = field_tests[dom]",
            "            rng_test(rng)",
            "        missing = set(field_tests.keys()) - set(dat.keys())",
            "        if missing:",
            "            raise Exception(f\"{dat!r} lacks fields {missing}\")",
            "        return True",
            "",
            "    return test",
            "",
            "",
            "class AcceptAll(Test):",
            "    \"\"\"Every value passes this test\"\"\"",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        return \"\"",
            "",
            "",
            "class RejectAll(Test):",
            "    \"\"\"No value passes this test\"\"\"",
            "",
            "    def __init__(self, why: str):",
            "        super().__init__()",
            "        if not why:",
            "            raise Exception(f\"the truth value of {why!r} is false\")",
            "        self.why = why",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        return self.why",
            "",
            "",
            "class And(Test):",
            "    \"\"\"Conjunction of given tests",
            "",
            "    The tests are run in series, stopping as soon as one fails.\"\"\"",
            "",
            "    def __init__(self, *tests: Test):",
            "        super().__init__()",
            "        list(map(type_test(Test), tests))",
            "        self.tests = tests",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        for test in self.tests:",
            "            reason = test.why_not(globs, subject)",
            "            if reason:",
            "                return reason",
            "        return \"\"",
            "",
            "",
            "class Or(Test):",
            "    \"\"\"Disjunction of given tests",
            "",
            "    The tests are run in series, stopping as soon as one succeeds.\"\"\"",
            "",
            "    def __init__(self, *tests: Test):",
            "        super().__init__()",
            "        list(map(type_test(Test), tests))",
            "        self.tests = tests",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not self.tests:",
            "            return \"does not pass empty disjunction\"",
            "        reasons = []",
            "        for test in self.tests:",
            "            reason = test.why_not(globs, subject)",
            "            if not reason:",
            "                return \"\"",
            "            reasons.append(reason)",
            "        return \"[\" + \", \".join(reasons) + \"]\"",
            "",
            "",
            "class Dispatcher(Test):",
            "    \"\"\"Apply a specific test for each key tuple.",
            "",
            "    This kind of test applies when the subject is a dict and",
            "    it is desired to apply a different test depending on",
            "    the value(s) of one or more entries.\"\"\"",
            "",
            "    def __init__(self, key_names: typing.Tuple[str, ...]):",
            "        \"\"\"Initialize a Dispatcher Test.",
            "",
            "        key_names identifies the subject dict entries that determine",
            "        which subsidiary test to apply.\"\"\"",
            "        super().__init__()",
            "        if len(key_names) < 1:",
            "            raise Exception(\"Dispatcher given empty list of key names\")",
            "        list(map(type_test(str), key_names))",
            "        self.key_names = key_names",
            "        self.tests = {}",
            "",
            "    def set(self, key_vals: typing.Tuple[str, ...], test: Test) -> None:",
            "        \"\"\"Set the test for the given value tuple\"\"\"",
            "        if len(key_vals) != len(self.key_names):",
            "            raise Exception(f\"{key_vals!a} does not match length of {self.key_names}\")",
            "        if key_vals in self.tests:",
            "            raise Exception(f\"multiple tests for {key_vals!a}\")",
            "        self.tests[key_vals] = test",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, dict):",
            "            return \"is not a dict\"",
            "        key_vals = tuple()",
            "        for kn in self.key_names:",
            "            if kn not in subject:",
            "                return f\"has no {kn}\"",
            "            key_vals += (subject[kn],)",
            "        test = self.tests.get(key_vals)",
            "        if test is None:",
            "            return f\"has unexpected {self.key_names} combination {key_vals}\"",
            "        return test.why_not(globs, subject)",
            "",
            "",
            "class FieldTest(Test):",
            "    \"\"\"Applies given test to field having given name\"\"\"",
            "",
            "    def __init__(self, field_name: str, field_test: Test, show_name: bool = True):",
            "        super().__init__()",
            "        type_test(str)(field_name)",
            "        type_test(Test)(field_test)",
            "        self.field_name = field_name",
            "        self.field_test = field_test",
            "        self.show_name = show_name",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, dict):",
            "            return \"is not a dict\"",
            "        if self.field_name not in subject:",
            "            return f\"has no {self.field_name!a} field\"",
            "        reason = self.field_test.why_not(globs, subject[self.field_name])",
            "        if reason and self.show_name:",
            "            return self.field_name + \" \" + reason",
            "        return reason",
            "",
            "",
            "class FieldsTest(And):",
            "    \"\"\"Tests a collection of fields\"\"\"",
            "",
            "    def __init__(self, **fields: Test):",
            "        tests = [FieldTest(field_name, field_test) for field_name, field_test in fields.items()]",
            "        super().__init__(*tests)",
            "",
            "",
            "class IterateTest(Test):",
            "    \"\"\"Applies a test to every member of a list\"\"\"",
            "",
            "    def __init__(self, elt_test: Test, show_elt: bool = False):",
            "        super().__init__()",
            "        self.elt_test = elt_test",
            "        self.show_elt = show_elt",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, list):",
            "            return \"is not a list\"",
            "        for idx, elt in enumerate(subject):",
            "            reason = self.elt_test.why_not(globs, elt)",
            "            if not reason:",
            "                continue",
            "            if self.show_elt:",
            "                return f\"{elt!a} \" + reason",
            "            return f\"[{idx}] \" + reason",
            "        return \"\"",
            "",
            "",
            "class TupleTest(Test):",
            "    \"\"\"Applies a sequence of tests to a sequence of values",
            "",
            "    The tests are run in series, stopping as soon as one fails\"\"\"",
            "",
            "    def __init__(self, *member_tests: Test, pad: bool = False):",
            "        super().__init__()",
            "        list(map(type_test(Test), member_tests))",
            "        self.member_tests = member_tests",
            "        self.pad = pad",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, list):",
            "            return \"is not a list\"",
            "        subject_len = len(subject)",
            "        test_len = len(self.member_tests)",
            "        if subject_len > test_len:",
            "            return f\" is longer ({subject_len}) than the applicable tests ({test_len})\"",
            "        if (subject_len < test_len) and not self.pad:",
            "            return f\" is shorter ({subject_len}) than the applicable tests ({test_len})\"",
            "        for idx, test in enumerate(self.member_tests):",
            "            subject_elt = subject[idx] if idx < subject_len else None",
            "            reason = test.why_not(globs, subject_elt)",
            "            if reason:",
            "                return f\"[{idx}] \" + reason",
            "        return \"\"",
            "",
            "",
            "class DelayedField(Test):",
            "    \"\"\"Remembers a field value for later testing\"\"\"",
            "",
            "    def __init__(self, delayer: \"DelayToFields\", field_name: str):",
            "        super().__init__()",
            "        self.delayer = delayer",
            "        self.field_name = field_name",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        \"\"\"Add the value to the list stashed for later testing\"\"\"",
            "        val_list = globs[self.field_name]",
            "        if not isinstance(val_list, list):",
            "            return f\"malformed test: global {self.field_name} is not a list\"",
            "        val_list.append(subject)",
            "        return \"\"",
            "",
            "",
            "class DelayInitializer(Test):",
            "    \"\"\"A Test that initializes the globals used by a DelayToFields and reports acceptance\"\"\"",
            "",
            "    def __init__(self, delayer: \"DelayToFields\"):",
            "        super().__init__()",
            "        self.delayer = delayer",
            "",
            "    def why_not(self, globs: Globals, subject):",
            "        self.delayer.initialize_globals(globs)",
            "        return \"\"",
            "",
            "",
            "class DelayToFields(Test):",
            "    \"\"\"A test to apply after stashing fields to test.",
            "",
            "    For each field, accumulates a list of values",
            "    in a correspondingly-named global.",
            "    As a test, ignores the given subject and instead applies the",
            "    configured fields_test to the record of accumulated value lists.",
            "    \"\"\"",
            "",
            "    def __init__(self, fields_test: Test, *field_names: str):",
            "        super().__init__()",
            "        self.field_names = field_names",
            "        self.fields_test = fields_test",
            "",
            "    def initialize_globals(self, globs: Globals) -> None:",
            "        \"\"\"Initialize for a new pass over data\"\"\"",
            "        for field_name in self.field_names:",
            "            globs[field_name] = []",
            "",
            "    def get_initializer(self) -> DelayInitializer:",
            "        \"\"\"Get a Test that accepts the subject and initializes the relevant globals\"\"\"",
            "        return DelayInitializer(self)",
            "",
            "    def get(self, field_name: str) -> DelayedField:",
            "        \"\"\"Return a Test that adds the subject to the list stashed for later evaulation\"\"\"",
            "        if field_name not in self.field_names:",
            "            raise Exception(f\"{field_name} not in {self.field_names}\")",
            "        return DelayedField(self, field_name)",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        \"\"\"Test the stashed field values\"\"\"",
            "        delayed = {}",
            "        for field_name in self.field_names:",
            "            delayed[field_name] = globs.get(field_name, None)",
            "        return self.fields_test.why_not(globs, delayed)",
            "",
            "",
            "class IntEqual(Test):",
            "    \"\"\"Compares with a given int\"\"\"",
            "",
            "    def __init__(self, expected: int):",
            "        super().__init__()",
            "        type_test(int)(expected)",
            "        self.expected = expected",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, int):",
            "            return \"is not a int\"",
            "        if subject == self.expected:",
            "            return \"\"",
            "        return f\"is not {self.expected}\"",
            "",
            "",
            "class StringEqual(Test):",
            "    \"\"\"Compares with a given string\"\"\"",
            "",
            "    def __init__(self, expected: str):",
            "        super().__init__()",
            "        type_test(str)(expected)",
            "        self.expected = expected",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, str):",
            "            return \"is not a str\"",
            "        if subject == self.expected:",
            "            return \"\"",
            "        return f\"is not {self.expected!a}\"",
            "",
            "",
            "class RegExp(Test):",
            "    \"\"\"Does a full match against a regular expression\"\"\"",
            "",
            "    def __init__(self, pattern: str, flags=0):",
            "        super().__init__()",
            "        self.regexp = re.compile(pattern, flags)",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, str):",
            "            return \"is not a str\"",
            "        if self.regexp.fullmatch(subject):",
            "            return \"\"",
            "        return f\"does not match {self.regexp.pattern}\"",
            "",
            "",
            "# hash algorithm -> hash value in hex (sans leading 0x)",
            "Digest = typing.Mapping[str, str]",
            "",
            "",
            "class DigestsTest(Test):",
            "    \"\"\"Tests whether subject has a digest that is in a list of good ones\"\"\"",
            "",
            "    def __init__(self, good_digests_list: typing.Iterable[Digest]):",
            "        \"\"\"good_digests_list is a list of good {alg:hash}\"\"\"",
            "        super().__init__()",
            "        self.good_digests = {}",
            "        \"map from alg to set of good digests\"",
            "        for good_digests in good_digests_list:",
            "            type_test(dict)(good_digests)",
            "            for alg, hash_val in good_digests.items():",
            "                if alg in self.good_digests:",
            "                    self.good_digests[alg].add(hash_val)",
            "                else:",
            "                    self.good_digests[alg] = set((hash_val,))",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, dict):",
            "            return \"is not a dict\"",
            "        if \"Digests\" not in subject:",
            "            return \"has no Digests\"",
            "        digest_list = subject[\"Digests\"]",
            "        if not isinstance(digest_list, list):",
            "            return \"Digests is not a list\"",
            "        for idx, subject_digest in enumerate(digest_list):",
            "            if not isinstance(subject_digest, dict):",
            "                return f\"Digests[{idx}] is {subject_digest!r}, not a dict\"",
            "            if \"AlgorithmId\" not in subject_digest:",
            "                return f\"digest {idx} has no AlgorithmId\"",
            "            alg = subject_digest[\"AlgorithmId\"]",
            "            if not isinstance(alg, str):",
            "                return f\"Digests[{idx}].AlgorithmId is {alg!r}, not a str\"",
            "            if \"Digest\" not in subject_digest:",
            "                return f\"digest {idx} has no Digest\"",
            "            hash_val = subject_digest[\"Digest\"]",
            "            if not isinstance(hash_val, str):",
            "                return f\"Digests[{idx}].Digest is {hash_val!r}, not a str\"",
            "            if alg not in self.good_digests:",
            "                continue",
            "            if hash_val in self.good_digests[alg]:",
            "                return \"\"",
            "        return f\"has no digest approved by {self.good_digests}\"",
            "",
            "",
            "class DigestTest(DigestsTest):",
            "    \"\"\"Tests whether subject has a digest that equals a given one\"\"\"",
            "",
            "    def __init__(self, good_digest: Digest):",
            "        super().__init__([good_digest])",
            "",
            "",
            "StrOrRE = typing.Union[str, typing.Pattern]",
            "",
            "",
            "class VariableTest(Test):",
            "    \"\"\"Test whether a given variable has value passing given test\"\"\"",
            "",
            "    def __init__(self, variable_name: str, unicode_name: StrOrRE, data_test: Test):",
            "        \"\"\"variable_name and unicode_name are as in the parsed event; data_test applies to VariableData\"\"\"",
            "        super().__init__()",
            "        self.variable_name = variable_name",
            "        # pylint: disable=isinstance-second-argument-not-valid-type",
            "        if not isinstance(unicode_name, (str, typing.Pattern)):",
            "            # pylint: enable=isinstance-second-argument-not-valid-type",
            "            raise Exception(f\"unicode_name={unicode_name!r} is neither a str nor an re.Pattern\")",
            "        self.unicode_name = unicode_name",
            "        self.data_test = data_test",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, dict):",
            "            return \"is not a dict\"",
            "        if \"Event\" not in subject:",
            "            return \"has no Event field\"",
            "        evt = subject[\"Event\"]",
            "        if not isinstance(evt, dict):",
            "            return \"Event is not a dict\"",
            "        if \"VariableName\" not in evt:",
            "            return \"Event has no VariableName field\"",
            "        variable_name = evt[\"VariableName\"]",
            "        if variable_name != self.variable_name:",
            "            return f\"Event.VariableName is {variable_name} rather than {self.variable_name}\"",
            "        if \"UnicodeName\" not in evt:",
            "            return \"Event has no UnicodeName field\"",
            "        unicode_name = evt[\"UnicodeName\"]",
            "        if \"VariableData\" not in evt:",
            "            return \"Event has no VariableData field\"",
            "        if not isinstance(unicode_name, str):",
            "            return \"Event.UnicodeName is not a str\"",
            "        variable_data = evt[\"VariableData\"]",
            "        if isinstance(self.unicode_name, str):",
            "            if unicode_name != self.unicode_name:",
            "                return f\"Event.UnicodeName is {unicode_name} rather than {self.unicode_name}\"",
            "        elif not self.unicode_name.fullmatch(unicode_name):",
            "            return f\"Event.UnicodeName, {unicode_name}, does not match {self.unicode_name.pattern}\"",
            "        return self.data_test.why_not(globs, variable_data)",
            "",
            "",
            "class VariableDispatch(FieldTest):",
            "    \"\"\"Do a specific test for each variable\"\"\"",
            "",
            "    def __init__(self):",
            "        self.vd = Dispatcher((\"VariableName\", \"UnicodeName\"))",
            "        super().__init__(\"Event\", self.vd)",
            "",
            "    def set(self, variable_name: str, unicode_name: str, data_test: Test) -> None:",
            "        \"\"\"Define the test for a specific variable\"\"\"",
            "        self.vd.set((variable_name, unicode_name), FieldTest(\"VariableData\", data_test))",
            "",
            "",
            "# Signature has the following fields.",
            "# - SignatureOwner, value is a string UUID",
            "# - SignatureData, value is a hex string without leading 0x",
            "",
            "",
            "Signature = typing.Mapping[str, str]",
            "",
            "",
            "class SignatureTest(And):",
            "    \"\"\"Compares to a particular signature\"\"\"",
            "",
            "    def __init__(self, owner: str, data: str):",
            "        \"\"\"owner is SignatureOwner, data is SignatureData\"\"\"",
            "        super().__init__(FieldTest(\"SignatureOwner\", StringEqual(owner)), FieldTest(\"SignatureData\", StringEqual(data)))",
            "",
            "",
            "class SignatureSetMember(Or):",
            "    \"\"\"Tests for membership in the given list of signatures\"\"\"",
            "",
            "    def __init__(self, sigs: typing.Iterable[Signature]):",
            "        tests = [SignatureTest(sig[\"SignatureOwner\"], sig[\"SignatureData\"]) for sig in sigs]",
            "        super().__init__(*tests)",
            "",
            "",
            "class KeySubset(IterateTest):",
            "    def __init__(self, sig_type: str, keys: typing.Iterable[typing.Mapping[str, str]]):",
            "        super().__init__(",
            "            And(",
            "                FieldTest(\"SignatureType\", StringEqual(sig_type)),",
            "                FieldTest(\"Keys\", IterateTest(SignatureSetMember(keys))),",
            "            )",
            "        )",
            "",
            "",
            "class FieldsMismatchError(Exception):",
            "    \"\"\"Represents a mismatch between expected and actual sets of field names.\"\"\"",
            "",
            "    def __init__(self, expected, actual):",
            "        \"\"\"Constructor.\"\"\"",
            "        super().__init__(expected, actual)",
            "        type_test(set)(expected)",
            "        type_test(set)(actual)",
            "        list(map(type_test(str), expected))",
            "        list(map(type_test(str), actual))",
            "        self.expected = expected",
            "        self.actual = actual",
            "",
            "    def __str__(self):",
            "        return f\"expected fields {self.expected} but got {self.actual}\"",
            "",
            "",
            "class SupersetOfDicts(Test):",
            "    \"\"\"Tests that the subject is a list of dicts with at least certain members",
            "",
            "    All dicts must have the same field names\"\"\"",
            "",
            "    @staticmethod",
            "    def dict_to_tuple(it: dict, field_names: typing.Tuple[str]) -> typing.Tuple:",
            "        actual_keys = set(it.keys())",
            "        expected_keys = set(field_names)",
            "        if actual_keys != expected_keys:",
            "            raise FieldsMismatchError(expected_keys, actual_keys)",
            "        return tuple(it.get(field_name) for field_name in field_names)",
            "",
            "    def __init__(self, reqs: typing.Iterable[dict], field_names: typing.Tuple[str]):",
            "        list(map(type_test(dict), reqs))",
            "        type_test(tuple)(field_names)",
            "        list(map(type_test(str), field_names))",
            "        self.field_names = field_names",
            "        self.reqs = {SupersetOfDicts.dict_to_tuple(req, field_names) for req in reqs}",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, list):",
            "            return \"is not a list\"",
            "        actual = set()",
            "        for elt in subject:",
            "            if not isinstance(elt, dict):",
            "                return f\"member {elt} is not a dict\"",
            "            try:",
            "                tup = SupersetOfDicts.dict_to_tuple(elt, self.field_names)",
            "            except FieldsMismatchError:",
            "                return f\"member {elt!r} does not have the right set of field names {self.field_names}\"",
            "            actual.add(tup)",
            "        missing = self.reqs - actual",
            "        if not missing:",
            "            return \"\"",
            "        return f\"lacks {self.field_names} combinations {missing}\"",
            "",
            "",
            "class KeySuperset(TupleTest):",
            "    \"\"\"Tests that there is one Keys dict containing at least certain members\"\"\"",
            "",
            "    def __init__(self, sig_type: str, keys: typing.Iterable[Signature]):",
            "        super().__init__(",
            "            And(",
            "                FieldTest(\"SignatureType\", StringEqual(sig_type)),",
            "                FieldTest(\"Keys\", SupersetOfDicts(keys, (\"SignatureOwner\", \"SignatureData\"))),",
            "            )",
            "        )",
            "",
            "",
            "class OnceTest(Test):",
            "    \"\"\"Tests that only works once\"\"\"",
            "",
            "    def __init__(self, test: Test):",
            "        self.executed = False",
            "        self.test = test",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if self.executed:",
            "            return \"test was already run once\"",
            "",
            "        self.executed = True",
            "        return self.test.why_not(globs, subject)",
            "",
            "",
            "# Following tests are TCG PC Client Platform specific, but are common and reduce the use of AcceptAll",
            "",
            "",
            "class EvSeperatorTest(Or):",
            "    \"\"\"Test for valid EV_SEPARATOR entry values\"\"\"",
            "",
            "    def __init__(self):",
            "        # See TCG PC Client Platform Firmware Profile (Table 9 Events)",
            "        valid_hex_values = [\"00000000\", \"FFFFFFFF\"]",
            "        tests = []",
            "        for value in valid_hex_values:",
            "            val_bytes = codecs.decode(value.encode(), \"hex\")",
            "            event_test = FieldTest(\"Event\", StringEqual(value))",
            "            digests = {}",
            "            for hash_alg in Hash:",
            "                digests[str(hash_alg)] = codecs.encode(hash_alg.hash(val_bytes), \"hex\").decode(\"utf-8\")",
            "            tests.append(And(event_test, DigestTest(digests)))",
            "        super().__init__(*tests)",
            "",
            "",
            "class EvEfiActionTest(Test):",
            "    \"\"\"Test for valid EV_EFI_ACTION entry values\"\"\"",
            "",
            "    _expected_strings = {",
            "        4: [\"Calling EFI Application from Boot Option\", \"Returning from EFI Application from Boot Option\"],",
            "        5: [",
            "            \"Exit Boot Services Invocation\",",
            "            \"Exit Boot Services Returned with Failure\",",
            "            \"Exit Boot Services Returned with Success\",",
            "        ],",
            "        6: [\"UEFI Debug Mode\"],",
            "    }",
            "",
            "    def __init__(self, pcr: int):",
            "        self.pcr = pcr",
            "        if pcr not in self._expected_strings:",
            "            self.test = None",
            "            return",
            "",
            "        tests = []",
            "        for value in self._expected_strings[pcr]:",
            "            event_test = FieldTest(\"Event\", StringEqual(value))",
            "            digests = {}",
            "            for hash_alg in Hash:",
            "                digests[str(hash_alg)] = codecs.encode(hash_alg.hash(value.encode()), \"hex\").decode(\"utf-8\")",
            "            tests.append(And(event_test, DigestTest(digests)))",
            "        self.test = Or(*tests)",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if self.test is None:",
            "            return f\"No EV_EFI_ACTION event for {self.pcr} is expected in the spec\"",
            "",
            "        return self.test.why_not(globs, subject)"
        ],
        "afterPatchFile": [
            "import abc",
            "import codecs",
            "import re",
            "import typing",
            "",
            "from keylime.common.algorithms import Hash",
            "",
            "# This module defines the abstraction of a Test (of JSON data)",
            "# and several specific test classes.",
            "# A Test can be used multiple times, even concurrently.",
            "",
            "# Data is the type of Python data that corresponds to JSON values.",
            "Data = typing.Union[int, float, str, bool, typing.Tuple[\"Data\", ...], typing.Mapping[str, \"Data\"], None]",
            "",
            "# Globals is a dict of variables for communication among tests.",
            "# There is a distinct dict for each top-level use of a test.",
            "Globals = typing.Mapping[str, Data]",
            "",
            "# PCR_Contents maps digest name to map from PCR index to PCR value.",
            "# Here digest name is something like 'sha256'.",
            "# Each PCR index is a decimal string, so that this can be JSON data",
            "PCR_Contents = typing.Mapping[str, typing.Mapping[str, int]]",
            "",
            "",
            "class Test(metaclass=abc.ABCMeta):",
            "    \"\"\"Test is something that can examine a value and either approve it or give a reason for rejection\"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        \"\"\"Test the given value, return empty string for pass, explanation for fail.",
            "",
            "        The explanation is (except in deliberate exceptions) English that",
            "        makes a sentence when placed after a noun phrase identifying the subject.",
            "        The test can read and write in the given globs dict.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "# type_test constructs a test of data type that is expected to pass.",
            "# This and the following are used to check reference state for bugs.",
            "def type_test(t) -> typing.Callable[[typing.Any], bool]:",
            "    \"\"\"Returns a lambda that tests against the given type.",
            "    The lambda returns True on pass, raises Exception on fail.\"\"\"",
            "",
            "    def test(v: typing.Any) -> bool:",
            "        if isinstance(v, t):",
            "            return True",
            "        raise Exception(f\"{v!r} is a {type(v)} rather than a {t}\")",
            "",
            "    return test",
            "",
            "",
            "def list_test(elt_test: typing.Callable[[typing.Any], bool]) -> typing.Callable[[typing.Any], bool]:",
            "    \"\"\"Return a lambda that tests for list with certain type of element\"\"\"",
            "",
            "    def test(dat: typing.Any) -> bool:",
            "        type_test(list)(dat)",
            "        for elt in dat:",
            "            elt_test(elt)",
            "        return True",
            "",
            "    return test",
            "",
            "",
            "def dict_test(",
            "    dom_test: typing.Callable[[typing.Any], bool], rng_test: typing.Callable[[typing.Any], bool]",
            ") -> typing.Callable[[typing.Any], bool]:",
            "    \"\"\"Return a lambda that tests for dict with certain type key and value\"\"\"",
            "",
            "    def test(dat: typing.Any) -> bool:",
            "        type_test(dict)(dat)",
            "        for dom, rng in dat.items():",
            "            dom_test(dom)",
            "            rng_test(rng)",
            "        return True",
            "",
            "    return test",
            "",
            "",
            "def obj_test(**field_tests: typing.Callable[[typing.Any], bool]) -> typing.Callable[[typing.Any], bool]:",
            "    \"\"\"Return a lambda that tests for dict with string keys and a particular type for each key\"\"\"",
            "",
            "    def test(dat: typing.Any) -> bool:",
            "        type_test(dict)(dat)",
            "        dom_test = type_test(str)",
            "        for dom, rng in dat.items():",
            "            dom_test(dom)",
            "            if dom not in field_tests:",
            "                continue",
            "            rng_test = field_tests[dom]",
            "            rng_test(rng)",
            "        missing = set(field_tests.keys()) - set(dat.keys())",
            "        if missing:",
            "            raise Exception(f\"{dat!r} lacks fields {missing}\")",
            "        return True",
            "",
            "    return test",
            "",
            "",
            "class AcceptAll(Test):",
            "    \"\"\"Every value passes this test\"\"\"",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        return \"\"",
            "",
            "",
            "class RejectAll(Test):",
            "    \"\"\"No value passes this test\"\"\"",
            "",
            "    def __init__(self, why: str):",
            "        super().__init__()",
            "        if not why:",
            "            raise Exception(f\"the truth value of {why!r} is false\")",
            "        self.why = why",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        return self.why",
            "",
            "",
            "class And(Test):",
            "    \"\"\"Conjunction of given tests",
            "",
            "    The tests are run in series, stopping as soon as one fails.\"\"\"",
            "",
            "    def __init__(self, *tests: Test):",
            "        super().__init__()",
            "        list(map(type_test(Test), tests))",
            "        self.tests = tests",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        for test in self.tests:",
            "            reason = test.why_not(globs, subject)",
            "            if reason:",
            "                return reason",
            "        return \"\"",
            "",
            "",
            "class Or(Test):",
            "    \"\"\"Disjunction of given tests",
            "",
            "    The tests are run in series, stopping as soon as one succeeds.\"\"\"",
            "",
            "    def __init__(self, *tests: Test):",
            "        super().__init__()",
            "        list(map(type_test(Test), tests))",
            "        self.tests = tests",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not self.tests:",
            "            return \"does not pass empty disjunction\"",
            "        reasons = []",
            "        for test in self.tests:",
            "            reason = test.why_not(globs, subject)",
            "            if not reason:",
            "                return \"\"",
            "            reasons.append(reason)",
            "        return \"[\" + \", \".join(reasons) + \"]\"",
            "",
            "",
            "class Dispatcher(Test):",
            "    \"\"\"Apply a specific test for each key tuple.",
            "",
            "    This kind of test applies when the subject is a dict and",
            "    it is desired to apply a different test depending on",
            "    the value(s) of one or more entries.\"\"\"",
            "",
            "    def __init__(self, key_names: typing.Tuple[str, ...]):",
            "        \"\"\"Initialize a Dispatcher Test.",
            "",
            "        key_names identifies the subject dict entries that determine",
            "        which subsidiary test to apply.\"\"\"",
            "        super().__init__()",
            "        if len(key_names) < 1:",
            "            raise Exception(\"Dispatcher given empty list of key names\")",
            "        list(map(type_test(str), key_names))",
            "        self.key_names = key_names",
            "        self.tests = {}",
            "",
            "    def set(self, key_vals: typing.Tuple[typing.Union[int, str], ...], test: Test) -> None:",
            "        \"\"\"Set the test for the given value tuple\"\"\"",
            "        if len(key_vals) != len(self.key_names):",
            "            raise Exception(f\"{key_vals!a} does not match length of {self.key_names}\")",
            "        if key_vals in self.tests:",
            "            raise Exception(f\"multiple tests for {key_vals!a}\")",
            "        self.tests[key_vals] = test",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, dict):",
            "            return \"is not a dict\"",
            "        key_vals = tuple()",
            "        for kn in self.key_names:",
            "            if kn not in subject:",
            "                return f\"has no {kn}\"",
            "            key_vals += (subject[kn],)",
            "        test = self.tests.get(key_vals)",
            "        if test is None:",
            "            return f\"has unexpected {self.key_names} combination {key_vals}\"",
            "        return test.why_not(globs, subject)",
            "",
            "",
            "class FieldTest(Test):",
            "    \"\"\"Applies given test to field having given name\"\"\"",
            "",
            "    def __init__(self, field_name: str, field_test: Test, show_name: bool = True):",
            "        super().__init__()",
            "        type_test(str)(field_name)",
            "        type_test(Test)(field_test)",
            "        self.field_name = field_name",
            "        self.field_test = field_test",
            "        self.show_name = show_name",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, dict):",
            "            return \"is not a dict\"",
            "        if self.field_name not in subject:",
            "            return f\"has no {self.field_name!a} field\"",
            "        reason = self.field_test.why_not(globs, subject[self.field_name])",
            "        if reason and self.show_name:",
            "            return self.field_name + \" \" + reason",
            "        return reason",
            "",
            "",
            "class FieldsTest(And):",
            "    \"\"\"Tests a collection of fields\"\"\"",
            "",
            "    def __init__(self, **fields: Test):",
            "        tests = [FieldTest(field_name, field_test) for field_name, field_test in fields.items()]",
            "        super().__init__(*tests)",
            "",
            "",
            "class IterateTest(Test):",
            "    \"\"\"Applies a test to every member of a list\"\"\"",
            "",
            "    def __init__(self, elt_test: Test, show_elt: bool = False):",
            "        super().__init__()",
            "        self.elt_test = elt_test",
            "        self.show_elt = show_elt",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, list):",
            "            return \"is not a list\"",
            "        for idx, elt in enumerate(subject):",
            "            reason = self.elt_test.why_not(globs, elt)",
            "            if not reason:",
            "                continue",
            "            if self.show_elt:",
            "                return f\"{elt!a} \" + reason",
            "            return f\"[{idx}] \" + reason",
            "        return \"\"",
            "",
            "",
            "class TupleTest(Test):",
            "    \"\"\"Applies a sequence of tests to a sequence of values",
            "",
            "    The tests are run in series, stopping as soon as one fails\"\"\"",
            "",
            "    def __init__(self, *member_tests: Test, pad: bool = False):",
            "        super().__init__()",
            "        list(map(type_test(Test), member_tests))",
            "        self.member_tests = member_tests",
            "        self.pad = pad",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, list):",
            "            return \"is not a list\"",
            "        subject_len = len(subject)",
            "        test_len = len(self.member_tests)",
            "        if subject_len > test_len:",
            "            return f\" is longer ({subject_len}) than the applicable tests ({test_len})\"",
            "        if (subject_len < test_len) and not self.pad:",
            "            return f\" is shorter ({subject_len}) than the applicable tests ({test_len})\"",
            "        for idx, test in enumerate(self.member_tests):",
            "            subject_elt = subject[idx] if idx < subject_len else None",
            "            reason = test.why_not(globs, subject_elt)",
            "            if reason:",
            "                return f\"[{idx}] \" + reason",
            "        return \"\"",
            "",
            "",
            "class DelayedField(Test):",
            "    \"\"\"Remembers a field value for later testing\"\"\"",
            "",
            "    def __init__(self, delayer: \"DelayToFields\", field_name: str):",
            "        super().__init__()",
            "        self.delayer = delayer",
            "        self.field_name = field_name",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        \"\"\"Add the value to the list stashed for later testing\"\"\"",
            "        val_list = globs[self.field_name]",
            "        if not isinstance(val_list, list):",
            "            return f\"malformed test: global {self.field_name} is not a list\"",
            "        val_list.append(subject)",
            "        return \"\"",
            "",
            "",
            "class DelayInitializer(Test):",
            "    \"\"\"A Test that initializes the globals used by a DelayToFields and reports acceptance\"\"\"",
            "",
            "    def __init__(self, delayer: \"DelayToFields\"):",
            "        super().__init__()",
            "        self.delayer = delayer",
            "",
            "    def why_not(self, globs: Globals, subject):",
            "        self.delayer.initialize_globals(globs)",
            "        return \"\"",
            "",
            "",
            "class DelayToFields(Test):",
            "    \"\"\"A test to apply after stashing fields to test.",
            "",
            "    For each field, accumulates a list of values",
            "    in a correspondingly-named global.",
            "    As a test, ignores the given subject and instead applies the",
            "    configured fields_test to the record of accumulated value lists.",
            "    \"\"\"",
            "",
            "    def __init__(self, fields_test: Test, *field_names: str):",
            "        super().__init__()",
            "        self.field_names = field_names",
            "        self.fields_test = fields_test",
            "",
            "    def initialize_globals(self, globs: Globals) -> None:",
            "        \"\"\"Initialize for a new pass over data\"\"\"",
            "        for field_name in self.field_names:",
            "            globs[field_name] = []",
            "",
            "    def get_initializer(self) -> DelayInitializer:",
            "        \"\"\"Get a Test that accepts the subject and initializes the relevant globals\"\"\"",
            "        return DelayInitializer(self)",
            "",
            "    def get(self, field_name: str) -> DelayedField:",
            "        \"\"\"Return a Test that adds the subject to the list stashed for later evaulation\"\"\"",
            "        if field_name not in self.field_names:",
            "            raise Exception(f\"{field_name} not in {self.field_names}\")",
            "        return DelayedField(self, field_name)",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        \"\"\"Test the stashed field values\"\"\"",
            "        delayed = {}",
            "        for field_name in self.field_names:",
            "            delayed[field_name] = globs.get(field_name, None)",
            "        return self.fields_test.why_not(globs, delayed)",
            "",
            "",
            "class IntEqual(Test):",
            "    \"\"\"Compares with a given int\"\"\"",
            "",
            "    def __init__(self, expected: int):",
            "        super().__init__()",
            "        type_test(int)(expected)",
            "        self.expected = expected",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, int):",
            "            return \"is not a int\"",
            "        if subject == self.expected:",
            "            return \"\"",
            "        return f\"is not {self.expected}\"",
            "",
            "",
            "class StringEqual(Test):",
            "    \"\"\"Compares with a given string\"\"\"",
            "",
            "    def __init__(self, expected: str):",
            "        super().__init__()",
            "        type_test(str)(expected)",
            "        self.expected = expected",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, str):",
            "            return \"is not a str\"",
            "        if subject == self.expected:",
            "            return \"\"",
            "        return f\"is not {self.expected!a}\"",
            "",
            "",
            "class RegExp(Test):",
            "    \"\"\"Does a full match against a regular expression\"\"\"",
            "",
            "    def __init__(self, pattern: str, flags=0):",
            "        super().__init__()",
            "        self.regexp = re.compile(pattern, flags)",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, str):",
            "            return \"is not a str\"",
            "        if self.regexp.fullmatch(subject):",
            "            return \"\"",
            "        return f\"does not match {self.regexp.pattern}\"",
            "",
            "",
            "# hash algorithm -> hash value in hex (sans leading 0x)",
            "Digest = typing.Mapping[str, str]",
            "",
            "",
            "class DigestsTest(Test):",
            "    \"\"\"Tests whether subject has a digest that is in a list of good ones\"\"\"",
            "",
            "    def __init__(self, good_digests_list: typing.Iterable[Digest]):",
            "        \"\"\"good_digests_list is a list of good {alg:hash}\"\"\"",
            "        super().__init__()",
            "        self.good_digests = {}",
            "        \"map from alg to set of good digests\"",
            "        for good_digests in good_digests_list:",
            "            type_test(dict)(good_digests)",
            "            for alg, hash_val in good_digests.items():",
            "                if alg in self.good_digests:",
            "                    self.good_digests[alg].add(hash_val)",
            "                else:",
            "                    self.good_digests[alg] = set((hash_val,))",
            "",
            "    def why_not(self, _: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, dict):",
            "            return \"is not a dict\"",
            "        if \"Digests\" not in subject:",
            "            return \"has no Digests\"",
            "        digest_list = subject[\"Digests\"]",
            "        if not isinstance(digest_list, list):",
            "            return \"Digests is not a list\"",
            "        for idx, subject_digest in enumerate(digest_list):",
            "            if not isinstance(subject_digest, dict):",
            "                return f\"Digests[{idx}] is {subject_digest!r}, not a dict\"",
            "            if \"AlgorithmId\" not in subject_digest:",
            "                return f\"digest {idx} has no AlgorithmId\"",
            "            alg = subject_digest[\"AlgorithmId\"]",
            "            if not isinstance(alg, str):",
            "                return f\"Digests[{idx}].AlgorithmId is {alg!r}, not a str\"",
            "            if \"Digest\" not in subject_digest:",
            "                return f\"digest {idx} has no Digest\"",
            "            hash_val = subject_digest[\"Digest\"]",
            "            if not isinstance(hash_val, str):",
            "                return f\"Digests[{idx}].Digest is {hash_val!r}, not a str\"",
            "            if alg not in self.good_digests:",
            "                continue",
            "            if hash_val in self.good_digests[alg]:",
            "                return \"\"",
            "        return f\"has no digest approved by {self.good_digests}\"",
            "",
            "",
            "class DigestTest(DigestsTest):",
            "    \"\"\"Tests whether subject has a digest that equals a given one\"\"\"",
            "",
            "    def __init__(self, good_digest: Digest):",
            "        super().__init__([good_digest])",
            "",
            "",
            "StrOrRE = typing.Union[str, typing.Pattern]",
            "",
            "",
            "class VariableTest(Test):",
            "    \"\"\"Test whether a given variable has value passing given test\"\"\"",
            "",
            "    def __init__(self, variable_name: str, unicode_name: StrOrRE, data_test: Test):",
            "        \"\"\"variable_name and unicode_name are as in the parsed event; data_test applies to VariableData\"\"\"",
            "        super().__init__()",
            "        self.variable_name = variable_name",
            "        # pylint: disable=isinstance-second-argument-not-valid-type",
            "        if not isinstance(unicode_name, (str, typing.Pattern)):",
            "            # pylint: enable=isinstance-second-argument-not-valid-type",
            "            raise Exception(f\"unicode_name={unicode_name!r} is neither a str nor an re.Pattern\")",
            "        self.unicode_name = unicode_name",
            "        self.data_test = data_test",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, dict):",
            "            return \"is not a dict\"",
            "        if \"Event\" not in subject:",
            "            return \"has no Event field\"",
            "        evt = subject[\"Event\"]",
            "        if not isinstance(evt, dict):",
            "            return \"Event is not a dict\"",
            "        if \"VariableName\" not in evt:",
            "            return \"Event has no VariableName field\"",
            "        variable_name = evt[\"VariableName\"]",
            "        if variable_name != self.variable_name:",
            "            return f\"Event.VariableName is {variable_name} rather than {self.variable_name}\"",
            "        if \"UnicodeName\" not in evt:",
            "            return \"Event has no UnicodeName field\"",
            "        unicode_name = evt[\"UnicodeName\"]",
            "        if \"VariableData\" not in evt:",
            "            return \"Event has no VariableData field\"",
            "        if not isinstance(unicode_name, str):",
            "            return \"Event.UnicodeName is not a str\"",
            "        variable_data = evt[\"VariableData\"]",
            "        if isinstance(self.unicode_name, str):",
            "            if unicode_name != self.unicode_name:",
            "                return f\"Event.UnicodeName is {unicode_name} rather than {self.unicode_name}\"",
            "        elif not self.unicode_name.fullmatch(unicode_name):",
            "            return f\"Event.UnicodeName, {unicode_name}, does not match {self.unicode_name.pattern}\"",
            "        return self.data_test.why_not(globs, variable_data)",
            "",
            "",
            "class VariableDispatch(FieldTest):",
            "    \"\"\"Do a specific test for each variable\"\"\"",
            "",
            "    def __init__(self):",
            "        self.vd = Dispatcher((\"VariableName\", \"UnicodeName\"))",
            "        super().__init__(\"Event\", self.vd)",
            "",
            "    def set(self, variable_name: str, unicode_name: str, data_test: Test) -> None:",
            "        \"\"\"Define the test for a specific variable\"\"\"",
            "        self.vd.set((variable_name, unicode_name), FieldTest(\"VariableData\", data_test))",
            "",
            "",
            "# Signature has the following fields.",
            "# - SignatureOwner, value is a string UUID",
            "# - SignatureData, value is a hex string without leading 0x",
            "",
            "",
            "Signature = typing.Mapping[str, str]",
            "",
            "",
            "class SignatureTest(And):",
            "    \"\"\"Compares to a particular signature\"\"\"",
            "",
            "    def __init__(self, owner: str, data: str):",
            "        \"\"\"owner is SignatureOwner, data is SignatureData\"\"\"",
            "        super().__init__(FieldTest(\"SignatureOwner\", StringEqual(owner)), FieldTest(\"SignatureData\", StringEqual(data)))",
            "",
            "",
            "class SignatureSetMember(Or):",
            "    \"\"\"Tests for membership in the given list of signatures\"\"\"",
            "",
            "    def __init__(self, sigs: typing.Iterable[Signature]):",
            "        tests = [SignatureTest(sig[\"SignatureOwner\"], sig[\"SignatureData\"]) for sig in sigs]",
            "        super().__init__(*tests)",
            "",
            "",
            "class KeySubset(IterateTest):",
            "    def __init__(self, sig_type: str, keys: typing.Iterable[typing.Mapping[str, str]]):",
            "        super().__init__(",
            "            And(",
            "                FieldTest(\"SignatureType\", StringEqual(sig_type)),",
            "                FieldTest(\"Keys\", IterateTest(SignatureSetMember(keys))),",
            "            )",
            "        )",
            "",
            "",
            "class FieldsMismatchError(Exception):",
            "    \"\"\"Represents a mismatch between expected and actual sets of field names.\"\"\"",
            "",
            "    def __init__(self, expected, actual):",
            "        \"\"\"Constructor.\"\"\"",
            "        super().__init__(expected, actual)",
            "        type_test(set)(expected)",
            "        type_test(set)(actual)",
            "        list(map(type_test(str), expected))",
            "        list(map(type_test(str), actual))",
            "        self.expected = expected",
            "        self.actual = actual",
            "",
            "    def __str__(self):",
            "        return f\"expected fields {self.expected} but got {self.actual}\"",
            "",
            "",
            "class SupersetOfDicts(Test):",
            "    \"\"\"Tests that the subject is a list of dicts with at least certain members",
            "",
            "    All dicts must have the same field names\"\"\"",
            "",
            "    @staticmethod",
            "    def dict_to_tuple(it: dict, field_names: typing.Tuple[str]) -> typing.Tuple:",
            "        actual_keys = set(it.keys())",
            "        expected_keys = set(field_names)",
            "        if actual_keys != expected_keys:",
            "            raise FieldsMismatchError(expected_keys, actual_keys)",
            "        return tuple(it.get(field_name) for field_name in field_names)",
            "",
            "    def __init__(self, reqs: typing.Iterable[dict], field_names: typing.Tuple[str]):",
            "        list(map(type_test(dict), reqs))",
            "        type_test(tuple)(field_names)",
            "        list(map(type_test(str), field_names))",
            "        self.field_names = field_names",
            "        self.reqs = {SupersetOfDicts.dict_to_tuple(req, field_names) for req in reqs}",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if not isinstance(subject, list):",
            "            return \"is not a list\"",
            "        actual = set()",
            "        for elt in subject:",
            "            if not isinstance(elt, dict):",
            "                return f\"member {elt} is not a dict\"",
            "            try:",
            "                tup = SupersetOfDicts.dict_to_tuple(elt, self.field_names)",
            "            except FieldsMismatchError:",
            "                return f\"member {elt!r} does not have the right set of field names {self.field_names}\"",
            "            actual.add(tup)",
            "        missing = self.reqs - actual",
            "        if not missing:",
            "            return \"\"",
            "        return f\"lacks {self.field_names} combinations {missing}\"",
            "",
            "",
            "class KeySuperset(TupleTest):",
            "    \"\"\"Tests that there is one Keys dict containing at least certain members\"\"\"",
            "",
            "    def __init__(self, sig_type: str, keys: typing.Iterable[Signature]):",
            "        super().__init__(",
            "            And(",
            "                FieldTest(\"SignatureType\", StringEqual(sig_type)),",
            "                FieldTest(\"Keys\", SupersetOfDicts(keys, (\"SignatureOwner\", \"SignatureData\"))),",
            "            )",
            "        )",
            "",
            "",
            "class OnceTest(Test):",
            "    \"\"\"Tests that only works once\"\"\"",
            "",
            "    def __init__(self, test: Test):",
            "        self.executed = False",
            "        self.test = test",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if self.executed:",
            "            return \"test was already run once\"",
            "",
            "        self.executed = True",
            "        return self.test.why_not(globs, subject)",
            "",
            "",
            "# Following tests are TCG PC Client Platform specific, but are common and reduce the use of AcceptAll",
            "",
            "",
            "class EvSeperatorTest(Or):",
            "    \"\"\"Test for valid EV_SEPARATOR entry values\"\"\"",
            "",
            "    def __init__(self):",
            "        # See TCG PC Client Platform Firmware Profile (Table 9 Events)",
            "        valid_hex_values = [\"00000000\", \"FFFFFFFF\"]",
            "        tests = []",
            "        for value in valid_hex_values:",
            "            val_bytes = codecs.decode(value.encode(), \"hex\")",
            "            event_test = FieldTest(\"Event\", StringEqual(value))",
            "            digests = {}",
            "            for hash_alg in Hash:",
            "                digests[str(hash_alg)] = codecs.encode(hash_alg.hash(val_bytes), \"hex\").decode(\"utf-8\")",
            "            tests.append(And(event_test, DigestTest(digests)))",
            "        super().__init__(*tests)",
            "",
            "",
            "class EvEfiActionTest(Test):",
            "    \"\"\"Test for valid EV_EFI_ACTION entry values\"\"\"",
            "",
            "    _expected_strings = {",
            "        4: [\"Calling EFI Application from Boot Option\", \"Returning from EFI Application from Boot Option\"],",
            "        5: [",
            "            \"Exit Boot Services Invocation\",",
            "            \"Exit Boot Services Returned with Failure\",",
            "            \"Exit Boot Services Returned with Success\",",
            "        ],",
            "        6: [\"UEFI Debug Mode\"],",
            "    }",
            "",
            "    def __init__(self, pcr: int):",
            "        self.pcr = pcr",
            "        if pcr not in self._expected_strings:",
            "            self.test = None",
            "            return",
            "",
            "        tests = []",
            "        for value in self._expected_strings[pcr]:",
            "            event_test = FieldTest(\"Event\", StringEqual(value))",
            "            digests = {}",
            "            for hash_alg in Hash:",
            "                digests[str(hash_alg)] = codecs.encode(hash_alg.hash(value.encode()), \"hex\").decode(\"utf-8\")",
            "            tests.append(And(event_test, DigestTest(digests)))",
            "        self.test = Or(*tests)",
            "",
            "    def why_not(self, globs: Globals, subject: Data) -> str:",
            "        if self.test is None:",
            "            return f\"No EV_EFI_ACTION event for {self.pcr} is expected in the spec\"",
            "",
            "        return self.test.why_not(globs, subject)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "179": [
                "Dispatcher",
                "set"
            ]
        },
        "addLocation": []
    },
    "keylime/tpm/tpm_main.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         # Extract the full semver release number."
            },
            "1": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         self.tools_version = version_str.split(\"-\")"
            },
            "2": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if Version(self.tools_version[0]) >= Version(\"4.2\"):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        if Version(self.tools_version[0]) >= Version(\"5.4\") or ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+            # Also mark first git version that introduces the change to the tpm2_eventlog format as 5.4"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            # See: https://github.com/tpm2-software/tpm2-tools/commit/c78d258b2588aee535fd17594ad2f5e808056373"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+            Version(self.tools_version[0]) == Version(\"5.3\")"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+            and len(self.tools_version) > 1"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+            and int(self.tools_version[1]) >= 24"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        ):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+            logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+            self.tools_version = \"5.4\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        elif Version(self.tools_version[0]) >= Version(\"4.2\"):"
            },
            "14": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "             logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])"
            },
            "15": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             self.tools_version = \"4.2\""
            },
            "16": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         elif Version(self.tools_version[0]) >= Version(\"4.0.0\"):"
            },
            "17": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "     def __get_tpm_algorithms(self):"
            },
            "18": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         if self.tools_version == \"3.2\":"
            },
            "19": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_getcap\", \"-c\", \"algorithms\"])"
            },
            "20": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "22": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_getcap\", \"algorithms\"])"
            },
            "23": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         output = config.convert(retDict[\"retout\"])"
            },
            "25": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         \"\"\"Gets which PCRs are enabled with which hash algorithm\"\"\""
            },
            "26": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         if self.tools_version == \"3.2\":"
            },
            "27": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_getcap\", \"-c\", \"pcrs\"])"
            },
            "28": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "30": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_getcap\", \"pcrs\"])"
            },
            "31": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         output = config.convert(retDict[\"retout\"])"
            },
            "33": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "             logger.info(\"Flushing old ek handle: %s\", hex(current_handle))"
            },
            "34": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "             if self.tools_version == \"3.2\":"
            },
            "35": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "                 retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"], raiseOnError=False)"
            },
            "36": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "38": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "                 retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"], raiseOnError=False)"
            },
            "39": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "             output = retDict[\"retout\"]"
            },
            "40": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "             reterr = retDict[\"reterr\"]"
            },
            "41": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "                 if self.tools_version == \"3.2\":"
            },
            "42": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "                     cmd = [\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(current_handle), \"-P\", owner_pw]"
            },
            "43": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "                     retDict = self.__run(cmd, raiseOnError=False)"
            },
            "44": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+                elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "46": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "                     cmd = [\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", hex(current_handle), \"-P\", owner_pw]"
            },
            "47": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "                     retDict = self.__run(cmd, raiseOnError=False)"
            },
            "48": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "                 output = retDict[\"retout\"]"
            },
            "49": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 319,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "             if self.tools_version == \"3.2\":"
            },
            "51": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "                 handle = int(0x81010007)"
            },
            "52": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "54": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "                 handle = None"
            },
            "55": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "                 retyaml = config.yaml_to_dict(output, logger=logger)"
            },
            "56": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "                 if retyaml is None:"
            },
            "57": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "             if self.tools_version == \"3.2\":"
            },
            "58": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "                 cmd = [\"tpm2_readpublic\", \"-H\", hex(ek_handle), \"-o\", tmppath.name, \"-f\", \"tss\"]"
            },
            "59": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "                 retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)"
            },
            "60": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "62": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "                 cmd = [\"tpm2_readpublic\", \"-c\", hex(ek_handle), \"-o\", tmppath.name, \"-f\", \"tss\"]"
            },
            "63": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "                 retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)"
            },
            "64": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 351,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "         if self.tools_version == \"3.2\":"
            },
            "66": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_takeownership\", \"-c\"], raiseOnError=False)"
            },
            "67": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_takeownership\", \"-o\", owner_pw, \"-e\", owner_pw], raiseOnError=False)"
            },
            "68": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "70": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"o\", owner_pw], raiseOnError=False)"
            },
            "71": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"e\", owner_pw], raiseOnError=False)"
            },
            "72": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 379,
                "PatchRowcode": " "
            },
            "73": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "                     [\"tpm2_takeownership\", \"-o\", owner_pw, \"-e\", owner_pw, \"-O\", owner_pw, \"-E\", owner_pw],"
            },
            "74": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "                     raiseOnError=False,"
            },
            "75": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "                 )"
            },
            "76": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "78": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "                 retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"o\", \"-p\", owner_pw, owner_pw], raiseOnError=False)"
            },
            "79": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "                 retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"e\", \"-p\", owner_pw, owner_pw], raiseOnError=False)"
            },
            "80": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 391,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "             if self.tools_version == \"3.2\":"
            },
            "82": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "                 cmd = [\"tpm2_readpublic\", \"-H\", hex(handle), \"-o\", tmppath.name]"
            },
            "83": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "                 retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)"
            },
            "84": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "86": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 412,
                "PatchRowcode": "                 cmd = [\"tpm2_readpublic\", \"-c\", hex(handle), \"-o\", tmppath.name]"
            },
            "87": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 413,
                "PatchRowcode": "                 retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)"
            },
            "88": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 414,
                "PatchRowcode": " "
            },
            "89": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "             if self.tools_version == \"3.2\":"
            },
            "90": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "                 logger.info(\"Flushing old ak handle: %s\", hex(aik_handle))"
            },
            "91": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "                 retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"], raiseOnError=False)"
            },
            "92": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "94": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 440,
                "PatchRowcode": "                 logger.info(\"Flushing old ak handle: %s\", aik_handle)"
            },
            "95": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "                 retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"], raiseOnError=False)"
            },
            "96": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 442,
                "PatchRowcode": "             output = config.convert(retDict[\"retout\"])"
            },
            "97": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 455,
                "PatchRowcode": "             outjson = config.yaml_to_dict(output, logger=logger)"
            },
            "98": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "             if self.tools_version == \"3.2\":"
            },
            "99": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 457,
                "PatchRowcode": "                 evict_it = outjson is not None and aik_handle in outjson"
            },
            "100": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "102": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 459,
                "PatchRowcode": "                 evict_it = os.path.exists(aik_handle)"
            },
            "103": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 460,
                "PatchRowcode": "             if evict_it:"
            },
            "104": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "                 if self.tools_version == \"3.2\":"
            },
            "105": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "                     cmd = [\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(aik_handle), \"-P\", owner_pw]"
            },
            "106": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "                     retDict = self.__run(cmd, raiseOnError=False)"
            },
            "107": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+                elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "109": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 465,
                "PatchRowcode": "                     cmd = [\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", aik_handle, \"-P\", owner_pw]"
            },
            "110": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "                     retDict = self.__run(cmd, raiseOnError=False)"
            },
            "111": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "                     os.remove(aik_handle)"
            },
            "112": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": 475,
                "PatchRowcode": "                         logger.info("
            },
            "113": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 476,
                "PatchRowcode": "                             \"Failed to flush old ak handle: %s.  Code %s: %s\", hex(aik_handle), str(code), str(reterr)"
            },
            "114": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 477,
                "PatchRowcode": "                         )"
            },
            "115": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+                    elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "117": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": 479,
                "PatchRowcode": "                         logger.info("
            },
            "118": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "                             \"Failed to flush old ak handle: %s.  Code %s: %s\", aik_handle, str(code), str(reterr)"
            },
            "119": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "                         )"
            },
            "120": {
                "beforePatchRowNumber": 486,
                "afterPatchRowNumber": 495,
                "PatchRowcode": "         # make a temp file for the output"
            },
            "121": {
                "beforePatchRowNumber": 487,
                "afterPatchRowNumber": 496,
                "PatchRowcode": "         with tempfile.NamedTemporaryFile() as akpubfile:"
            },
            "122": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": 497,
                "PatchRowcode": "             secpath = \"\""
            },
            "123": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+            if self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "125": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 499,
                "PatchRowcode": "                 # ok lets write out the key now"
            },
            "126": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": 500,
                "PatchRowcode": "                 secdir = secure_mount.mount()  # confirm that storage is still securely mounted"
            },
            "127": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": 501,
                "PatchRowcode": "                 secfd, secpath = tempfile.mkstemp(dir=secdir)"
            },
            "128": {
                "beforePatchRowNumber": 513,
                "afterPatchRowNumber": 522,
                "PatchRowcode": "                     \"-o\","
            },
            "129": {
                "beforePatchRowNumber": 514,
                "afterPatchRowNumber": 523,
                "PatchRowcode": "                     owner_pw,"
            },
            "130": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": 524,
                "PatchRowcode": "                 ]"
            },
            "131": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 525,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "133": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 526,
                "PatchRowcode": "                 command = ["
            },
            "134": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 527,
                "PatchRowcode": "                     \"tpm2_createak\","
            },
            "135": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": 528,
                "PatchRowcode": "                     \"-C\","
            },
            "136": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": 572,
                "PatchRowcode": " "
            },
            "137": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "             # get and persist the pem (not returned by tpm2_getpubak)"
            },
            "138": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 574,
                "PatchRowcode": "             self._set_tpm_metadata(\"aik_handle\", handle)"
            },
            "139": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 575,
                "PatchRowcode": "+        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "141": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 576,
                "PatchRowcode": "             if \"loaded-key\" not in jsonout:"
            },
            "142": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": 577,
                "PatchRowcode": "                 raise Exception(\"tpm2_createak failed to create aik: return \" + str(reterr))"
            },
            "143": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": 578,
                "PatchRowcode": " "
            },
            "144": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": 591,
                "PatchRowcode": "         logger.debug(\"Flushing keys from TPM...\")"
            },
            "145": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 592,
                "PatchRowcode": "         if self.tools_version == \"3.2\":"
            },
            "146": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 593,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"])"
            },
            "147": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 594,
                "PatchRowcode": "+        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "149": {
                "beforePatchRowNumber": 586,
                "afterPatchRowNumber": 595,
                "PatchRowcode": "             retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"])"
            },
            "150": {
                "beforePatchRowNumber": 587,
                "afterPatchRowNumber": 596,
                "PatchRowcode": "         # retout = retDict['retout']"
            },
            "151": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": 597,
                "PatchRowcode": "         retout = config.convert(retDict[\"retout\"])"
            },
            "152": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": 617,
                "PatchRowcode": "                 logger.debug(\"Flushing key handle %s\", hex(key))"
            },
            "153": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 618,
                "PatchRowcode": "                 if self.tools_version == \"3.2\":"
            },
            "154": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": 619,
                "PatchRowcode": "                     self.__run([\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(key), \"-P\", owner_pw], raiseOnError=False)"
            },
            "155": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+                elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "157": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": 621,
                "PatchRowcode": "                     self.__run([\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", hex(key), \"-P\", owner_pw], raiseOnError=False)"
            },
            "158": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": 622,
                "PatchRowcode": "         # Make sure that all transient objects are flushed"
            },
            "159": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": 623,
                "PatchRowcode": "         self.__run([\"tpm2_flushcontext\", \"-t\"], lock=False, raiseOnError=False)"
            },
            "160": {
                "beforePatchRowNumber": 725,
                "afterPatchRowNumber": 734,
                "PatchRowcode": "                     owner_pw,"
            },
            "161": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": 735,
                "PatchRowcode": "                 ]"
            },
            "162": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 736,
                "PatchRowcode": "                 retDict = self.__run(command, outputpaths=secpath)"
            },
            "163": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 737,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "165": {
                "beforePatchRowNumber": 729,
                "afterPatchRowNumber": 738,
                "PatchRowcode": "                 self.__run([\"tpm2_startauthsession\", \"--policy-session\", \"-S\", sesspath])"
            },
            "166": {
                "beforePatchRowNumber": 730,
                "afterPatchRowNumber": 739,
                "PatchRowcode": "                 self.__run([\"tpm2_policysecret\", \"-S\", sesspath, \"-c\", \"0x4000000B\", owner_pw])"
            },
            "167": {
                "beforePatchRowNumber": 731,
                "afterPatchRowNumber": 740,
                "PatchRowcode": "                 command = ["
            },
            "168": {
                "beforePatchRowNumber": 822,
                "afterPatchRowNumber": 831,
                "PatchRowcode": "         if not output:"
            },
            "169": {
                "beforePatchRowNumber": 823,
                "afterPatchRowNumber": 832,
                "PatchRowcode": "             if self.tools_version == \"3.2\":"
            },
            "170": {
                "beforePatchRowNumber": 824,
                "afterPatchRowNumber": 833,
                "PatchRowcode": "                 retDict = self.__run([\"tpm2_getcap\", \"-c\", \"properties-fixed\"])"
            },
            "171": {
                "beforePatchRowNumber": 825,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 834,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "173": {
                "beforePatchRowNumber": 826,
                "afterPatchRowNumber": 835,
                "PatchRowcode": "                 retDict = self.__run([\"tpm2_getcap\", \"properties-fixed\"])"
            },
            "174": {
                "beforePatchRowNumber": 827,
                "afterPatchRowNumber": 836,
                "PatchRowcode": "             else:"
            },
            "175": {
                "beforePatchRowNumber": 828,
                "afterPatchRowNumber": 837,
                "PatchRowcode": "                 raise Exception(f\"Unsupported tools version: {self.tools_version}\")"
            },
            "176": {
                "beforePatchRowNumber": 973,
                "afterPatchRowNumber": 982,
                "PatchRowcode": "                         \"-P\","
            },
            "177": {
                "beforePatchRowNumber": 974,
                "afterPatchRowNumber": 983,
                "PatchRowcode": "                         aik_pw,"
            },
            "178": {
                "beforePatchRowNumber": 975,
                "afterPatchRowNumber": 984,
                "PatchRowcode": "                     ]"
            },
            "179": {
                "beforePatchRowNumber": 976,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 985,
                "PatchRowcode": "+                elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "181": {
                "beforePatchRowNumber": 977,
                "afterPatchRowNumber": 986,
                "PatchRowcode": "                     command = ["
            },
            "182": {
                "beforePatchRowNumber": 978,
                "afterPatchRowNumber": 987,
                "PatchRowcode": "                         \"tpm2_quote\","
            },
            "183": {
                "beforePatchRowNumber": 979,
                "afterPatchRowNumber": 988,
                "PatchRowcode": "                         \"-c\","
            },
            "184": {
                "beforePatchRowNumber": 1034,
                "afterPatchRowNumber": 1043,
                "PatchRowcode": "                 \"-q\","
            },
            "185": {
                "beforePatchRowNumber": 1035,
                "afterPatchRowNumber": 1044,
                "PatchRowcode": "                 nonce,"
            },
            "186": {
                "beforePatchRowNumber": 1036,
                "afterPatchRowNumber": 1045,
                "PatchRowcode": "             ]"
            },
            "187": {
                "beforePatchRowNumber": 1037,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1046,
                "PatchRowcode": "+        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "189": {
                "beforePatchRowNumber": 1038,
                "afterPatchRowNumber": 1047,
                "PatchRowcode": "             command = ["
            },
            "190": {
                "beforePatchRowNumber": 1039,
                "afterPatchRowNumber": 1048,
                "PatchRowcode": "                 \"tpm2_checkquote\","
            },
            "191": {
                "beforePatchRowNumber": 1040,
                "afterPatchRowNumber": 1049,
                "PatchRowcode": "                 \"-u\","
            },
            "192": {
                "beforePatchRowNumber": 1340,
                "afterPatchRowNumber": 1349,
                "PatchRowcode": "             hash_alg = self.defaults[\"hash\"]"
            },
            "193": {
                "beforePatchRowNumber": 1341,
                "afterPatchRowNumber": 1350,
                "PatchRowcode": "         if self.tools_version == \"3.2\":"
            },
            "194": {
                "beforePatchRowNumber": 1342,
                "afterPatchRowNumber": 1351,
                "PatchRowcode": "             output = config.convert(self.__run(\"tpm2_pcrlist\")[\"retout\"])"
            },
            "195": {
                "beforePatchRowNumber": 1343,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "196": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1352,
                "PatchRowcode": "+        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "197": {
                "beforePatchRowNumber": 1344,
                "afterPatchRowNumber": 1353,
                "PatchRowcode": "             output = config.convert(self.__run(\"tpm2_pcrread\")[\"retout\"])"
            },
            "198": {
                "beforePatchRowNumber": 1345,
                "afterPatchRowNumber": 1354,
                "PatchRowcode": " "
            },
            "199": {
                "beforePatchRowNumber": 1346,
                "afterPatchRowNumber": 1355,
                "PatchRowcode": "         jsonout = config.yaml_to_dict(output, logger=logger)"
            },
            "200": {
                "beforePatchRowNumber": 1404,
                "afterPatchRowNumber": 1413,
                "PatchRowcode": "                     [\"tpm2_nvwrite\", \"-x\", \"0x1500018\", \"-a\", \"0x40000001\", \"-P\", owner_pw, keyFile.name],"
            },
            "201": {
                "beforePatchRowNumber": 1405,
                "afterPatchRowNumber": 1414,
                "PatchRowcode": "                     raiseOnError=False,"
            },
            "202": {
                "beforePatchRowNumber": 1406,
                "afterPatchRowNumber": 1415,
                "PatchRowcode": "                 )"
            },
            "203": {
                "beforePatchRowNumber": 1407,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1416,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "205": {
                "beforePatchRowNumber": 1408,
                "afterPatchRowNumber": 1417,
                "PatchRowcode": "                 self.__run("
            },
            "206": {
                "beforePatchRowNumber": 1409,
                "afterPatchRowNumber": 1418,
                "PatchRowcode": "                     ["
            },
            "207": {
                "beforePatchRowNumber": 1410,
                "afterPatchRowNumber": 1419,
                "PatchRowcode": "                         \"tpm2_nvdefine\","
            },
            "208": {
                "beforePatchRowNumber": 1434,
                "afterPatchRowNumber": 1443,
                "PatchRowcode": "             # Check for RSA EK cert in NVRAM (and get length)"
            },
            "209": {
                "beforePatchRowNumber": 1435,
                "afterPatchRowNumber": 1444,
                "PatchRowcode": "             if self.tools_version == \"3.2\":"
            },
            "210": {
                "beforePatchRowNumber": 1436,
                "afterPatchRowNumber": 1445,
                "PatchRowcode": "                 retDict = self.__run(\"tpm2_nvlist\", raiseOnError=False)"
            },
            "211": {
                "beforePatchRowNumber": 1437,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "212": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1446,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "213": {
                "beforePatchRowNumber": 1438,
                "afterPatchRowNumber": 1447,
                "PatchRowcode": "                 retDict = self.__run(\"tpm2_nvreadpublic\", raiseOnError=False)"
            },
            "214": {
                "beforePatchRowNumber": 1439,
                "afterPatchRowNumber": 1448,
                "PatchRowcode": "             output = retDict[\"retout\"]"
            },
            "215": {
                "beforePatchRowNumber": 1440,
                "afterPatchRowNumber": 1449,
                "PatchRowcode": "             reterr = retDict[\"reterr\"]"
            },
            "216": {
                "beforePatchRowNumber": 1443,
                "afterPatchRowNumber": 1452,
                "PatchRowcode": "             if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:"
            },
            "217": {
                "beforePatchRowNumber": 1444,
                "afterPatchRowNumber": 1453,
                "PatchRowcode": "                 if self.tools_version == \"3.2\":"
            },
            "218": {
                "beforePatchRowNumber": 1445,
                "afterPatchRowNumber": 1454,
                "PatchRowcode": "                     raise Exception(\"tpm2_nvlist for ekcert failed with code \" + str(code) + \": \" + str(reterr))"
            },
            "219": {
                "beforePatchRowNumber": 1446,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "220": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1455,
                "PatchRowcode": "+                if self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "221": {
                "beforePatchRowNumber": 1447,
                "afterPatchRowNumber": 1456,
                "PatchRowcode": "                     raise Exception(\"tpm2_nvreadpublic for ekcert failed with code \" + str(code) + \": \" + str(reterr))"
            },
            "222": {
                "beforePatchRowNumber": 1448,
                "afterPatchRowNumber": 1457,
                "PatchRowcode": " "
            },
            "223": {
                "beforePatchRowNumber": 1449,
                "afterPatchRowNumber": 1458,
                "PatchRowcode": "             outjson = config.yaml_to_dict(output, logger=logger)"
            },
            "224": {
                "beforePatchRowNumber": 1461,
                "afterPatchRowNumber": 1470,
                "PatchRowcode": "                     raiseOnError=False,"
            },
            "225": {
                "beforePatchRowNumber": 1462,
                "afterPatchRowNumber": 1471,
                "PatchRowcode": "                     outputpaths=nvpath.name,"
            },
            "226": {
                "beforePatchRowNumber": 1463,
                "afterPatchRowNumber": 1472,
                "PatchRowcode": "                 )"
            },
            "227": {
                "beforePatchRowNumber": 1464,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "228": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1473,
                "PatchRowcode": "+            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "229": {
                "beforePatchRowNumber": 1465,
                "afterPatchRowNumber": 1474,
                "PatchRowcode": "                 retDict = self.__run("
            },
            "230": {
                "beforePatchRowNumber": 1466,
                "afterPatchRowNumber": 1475,
                "PatchRowcode": "                     [\"tpm2_nvread\", \"0x1c00002\", \"-s\", ekcert_size, \"-o\", nvpath.name],"
            },
            "231": {
                "beforePatchRowNumber": 1467,
                "afterPatchRowNumber": 1476,
                "PatchRowcode": "                     raiseOnError=False,"
            },
            "232": {
                "beforePatchRowNumber": 1494,
                "afterPatchRowNumber": 1503,
                "PatchRowcode": "                 ],"
            },
            "233": {
                "beforePatchRowNumber": 1495,
                "afterPatchRowNumber": 1504,
                "PatchRowcode": "                 raiseOnError=False,"
            },
            "234": {
                "beforePatchRowNumber": 1496,
                "afterPatchRowNumber": 1505,
                "PatchRowcode": "             )"
            },
            "235": {
                "beforePatchRowNumber": 1497,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.tools_version in [\"4.0\", \"4.2\"]:"
            },
            "236": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1506,
                "PatchRowcode": "+        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:"
            },
            "237": {
                "beforePatchRowNumber": 1498,
                "afterPatchRowNumber": 1507,
                "PatchRowcode": "             retDict = self.__run("
            },
            "238": {
                "beforePatchRowNumber": 1499,
                "afterPatchRowNumber": 1508,
                "PatchRowcode": "                 [\"tpm2_nvread\", \"0x1500018\", \"-C\", \"0x40000001\", \"-s\", str(config.BOOTSTRAP_KEY_SIZE), \"-P\", owner_pw],"
            },
            "239": {
                "beforePatchRowNumber": 1500,
                "afterPatchRowNumber": 1509,
                "PatchRowcode": "                 raiseOnError=False,"
            },
            "240": {
                "beforePatchRowNumber": 1576,
                "afterPatchRowNumber": 1585,
                "PatchRowcode": "                 except Exception:"
            },
            "241": {
                "beforePatchRowNumber": 1577,
                "afterPatchRowNumber": 1586,
                "PatchRowcode": "                     pass"
            },
            "242": {
                "beforePatchRowNumber": 1578,
                "afterPatchRowNumber": 1587,
                "PatchRowcode": " "
            },
            "243": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1588,
                "PatchRowcode": "+    @staticmethod"
            },
            "244": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1589,
                "PatchRowcode": "+    def __unescape_eventlog(log: dict):"
            },
            "245": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1590,
                "PatchRowcode": "+        \"\"\""
            },
            "246": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1591,
                "PatchRowcode": "+        Newer versions of tpm2-tools escapes the YAML output and including the trailing null byte."
            },
            "247": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1592,
                "PatchRowcode": "+        See: https://github.com/tpm2-software/tpm2-tools/commit/c78d258b2588aee535fd17594ad2f5e808056373"
            },
            "248": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1593,
                "PatchRowcode": "+        This converts it back to an unescaped string."
            },
            "249": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1594,
                "PatchRowcode": "+        Example:"
            },
            "250": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1595,
                "PatchRowcode": "+            '\"MokList\\\\0\"' -> 'MokList'"
            },
            "251": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1596,
                "PatchRowcode": "+        \"\"\""
            },
            "252": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1597,
                "PatchRowcode": "+        if tpm.tools_version in [\"3.2\", \"4.0\", \"4.2\"]:"
            },
            "253": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1598,
                "PatchRowcode": "+            return"
            },
            "254": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1599,
                "PatchRowcode": "+"
            },
            "255": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1600,
                "PatchRowcode": "+        escaped_chars = ["
            },
            "256": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1601,
                "PatchRowcode": "+            (\"\\0\", \"\\\\0\"),"
            },
            "257": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1602,
                "PatchRowcode": "+            (\"\\a\", \"\\\\a\"),"
            },
            "258": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1603,
                "PatchRowcode": "+            (\"\\b\", \"\\\\b\"),"
            },
            "259": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1604,
                "PatchRowcode": "+            (\"\\t\", \"\\\\t\"),"
            },
            "260": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1605,
                "PatchRowcode": "+            (\"\\v\", \"\\\\v\"),"
            },
            "261": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1606,
                "PatchRowcode": "+            (\"\\f\", \"\\\\f\"),"
            },
            "262": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1607,
                "PatchRowcode": "+            (\"\\r\", \"\\\\r\"),"
            },
            "263": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1608,
                "PatchRowcode": "+            (\"\\x1b\", \"\\\\e\"),"
            },
            "264": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1609,
                "PatchRowcode": "+            (\"'\", \"\\\\'\"),"
            },
            "265": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1610,
                "PatchRowcode": "+            (\"\\\\\", \"\\\\\\\\\"),"
            },
            "266": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1611,
                "PatchRowcode": "+        ]"
            },
            "267": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1612,
                "PatchRowcode": "+"
            },
            "268": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1613,
                "PatchRowcode": "+        def recursive_unescape(data):"
            },
            "269": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1614,
                "PatchRowcode": "+            if isinstance(data, str):"
            },
            "270": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1615,
                "PatchRowcode": "+                if data.startswith('\"') and data.endswith('\"'):"
            },
            "271": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1616,
                "PatchRowcode": "+                    data = data[1:-1]"
            },
            "272": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1617,
                "PatchRowcode": "+                    for orig, escaped in escaped_chars:"
            },
            "273": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1618,
                "PatchRowcode": "+                        data = data.replace(escaped, orig)"
            },
            "274": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1619,
                "PatchRowcode": "+                    data = data.rstrip(\"\\0\")"
            },
            "275": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1620,
                "PatchRowcode": "+            elif isinstance(data, dict):"
            },
            "276": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1621,
                "PatchRowcode": "+                for key, value in data.items():"
            },
            "277": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1622,
                "PatchRowcode": "+                    data[key] = recursive_unescape(value)"
            },
            "278": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1623,
                "PatchRowcode": "+            elif isinstance(data, list):"
            },
            "279": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1624,
                "PatchRowcode": "+                for pos, item in enumerate(data):"
            },
            "280": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1625,
                "PatchRowcode": "+                    data[pos] = recursive_unescape(item)"
            },
            "281": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1626,
                "PatchRowcode": "+            return data"
            },
            "282": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1627,
                "PatchRowcode": "+"
            },
            "283": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1628,
                "PatchRowcode": "+        recursive_unescape(log)"
            },
            "284": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1629,
                "PatchRowcode": "+"
            },
            "285": {
                "beforePatchRowNumber": 1579,
                "afterPatchRowNumber": 1630,
                "PatchRowcode": "     def parse_binary_bootlog(self, log_bin: bytes) -> typing.Tuple[Failure, typing.Optional[dict]]:"
            },
            "286": {
                "beforePatchRowNumber": 1580,
                "afterPatchRowNumber": 1631,
                "PatchRowcode": "         \"\"\"Parse and enrich a BIOS boot log"
            },
            "287": {
                "beforePatchRowNumber": 1581,
                "afterPatchRowNumber": 1632,
                "PatchRowcode": " "
            },
            "288": {
                "beforePatchRowNumber": 1618,
                "afterPatchRowNumber": 1669,
                "PatchRowcode": "         tpm_bootlog_enrich.enrich(log_parsed_data)"
            },
            "289": {
                "beforePatchRowNumber": 1619,
                "afterPatchRowNumber": 1670,
                "PatchRowcode": "         tpm.__stringify_pcr_keys(log_parsed_data)"
            },
            "290": {
                "beforePatchRowNumber": 1620,
                "afterPatchRowNumber": 1671,
                "PatchRowcode": "         tpm.__add_boot_aggregate(log_parsed_data)"
            },
            "291": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1672,
                "PatchRowcode": "+        tpm.__unescape_eventlog(log_parsed_data)"
            },
            "292": {
                "beforePatchRowNumber": 1621,
                "afterPatchRowNumber": 1673,
                "PatchRowcode": "         return failure, log_parsed_data"
            },
            "293": {
                "beforePatchRowNumber": 1622,
                "afterPatchRowNumber": 1674,
                "PatchRowcode": " "
            },
            "294": {
                "beforePatchRowNumber": 1623,
                "afterPatchRowNumber": 1675,
                "PatchRowcode": "     def _parse_mb_bootlog(self, log_b64: str) -> typing.Tuple[Failure, typing.Optional[dict]]:"
            }
        },
        "frontPatchFile": [
            "import base64",
            "import binascii",
            "import codecs",
            "import collections",
            "import hashlib",
            "import os",
            "import re",
            "import sys",
            "import tempfile",
            "import threading",
            "import time",
            "import typing",
            "import zlib",
            "",
            "from cryptography import exceptions as crypto_exceptions",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives import serialization as crypto_serialization",
            "from cryptography.hazmat.primitives.asymmetric import padding",
            "from packaging.version import Version",
            "",
            "from keylime import cmd_exec, config, keylime_logging, secure_mount, tpm_ek_ca",
            "from keylime.agentstates import TPMClockInfo",
            "from keylime.common import algorithms, retry",
            "from keylime.failure import Component, Failure",
            "from keylime.tpm import tpm2_objects, tpm_abstract",
            "",
            "logger = keylime_logging.init_logging(\"tpm\")",
            "",
            "",
            "def _get_cmd_env():",
            "    env = os.environ.copy()",
            "    if \"TPM2TOOLS_TCTI\" not in env:",
            "        # Don't clobber existing setting (if present)",
            "        env[\"TPM2TOOLS_TCTI\"] = \"device:/dev/tpmrm0\"",
            "        # env['TPM2TOOLS_TCTI'] = 'tabrmd:bus_name=com.intel.tss2.Tabrmd'",
            "        # Other (not recommended) options are direct emulator and chardev communications:",
            "        # env['TPM2TOOLS_TCTI'] = 'mssim:port=2321'",
            "        # env['TPM2TOOLS_TCTI'] = 'device:/dev/tpm0'",
            "    return env",
            "",
            "",
            "class tpm(tpm_abstract.AbstractTPM):",
            "    VERSION = 2",
            "    tools_version = \"\"",
            "",
            "    def __init__(self, need_hw_tpm=False):",
            "        tpm_abstract.AbstractTPM.__init__(self, need_hw_tpm)",
            "",
            "        # Shared lock to serialize access to tools",
            "        self.tpmutilLock = threading.Lock()",
            "",
            "        self.__get_tpm2_tools()",
            "",
            "    def __get_tpm2_tools(self):",
            "        retDict = self.__run([\"tpm2_startup\", \"--version\"])",
            "",
            "        code = retDict[\"code\"]",
            "        output = \"\".join(config.convert(retDict[\"retout\"]))",
            "        errout = \"\".join(config.convert(retDict[\"reterr\"]))",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            raise Exception(",
            "                \"Error establishing tpm2-tools version using TPM2_Startup: %s\" + str(code) + \": \" + str(errout)",
            "            )",
            "",
            "        # Extract the `version=\"x.x.x\"` from tools",
            "        version_str = re.search(r'version=\"([^\"]+)\"', output).group(1)",
            "        # Extract the full semver release number.",
            "        self.tools_version = version_str.split(\"-\")",
            "",
            "        if Version(self.tools_version[0]) >= Version(\"4.2\"):",
            "            logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])",
            "            self.tools_version = \"4.2\"",
            "        elif Version(self.tools_version[0]) >= Version(\"4.0.0\"):",
            "            logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])",
            "            self.tools_version = \"4.0\"",
            "        elif Version(self.tools_version[0]) >= Version(\"3.2.0\"):",
            "            logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])",
            "            self.tools_version = \"3.2\"",
            "        else:",
            "            logger.error(\"TPM2-TOOLS Version %s is not supported.\", self.tools_version[0])",
            "            sys.exit()",
            "",
            "    def __get_tpm_algorithms(self):",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run([\"tpm2_getcap\", \"-c\", \"algorithms\"])",
            "        elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "            retDict = self.__run([\"tpm2_getcap\", \"algorithms\"])",
            "",
            "        output = config.convert(retDict[\"retout\"])",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            raise Exception(\"get_tpm_algorithms failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "        if self.tools_version == \"3.2\":",
            "            # output, human-readable -> json",
            "            output = \"\".join(output)",
            "            output = re.sub(r\"TPMA_ALGORITHM for ALG_ID: 0x[0-9a-f]+\\s+-\\s+([a-z0-9_]+)\", r\"\\1:\", output)",
            "            output = output.replace(\"set\", \"1\")",
            "            output = output.replace(\"clear\", \"0\")",
            "            output = [output]",
            "",
            "        retyaml = config.yaml_to_dict(output, logger=logger)",
            "        if retyaml is None:",
            "            logger.warning(\"Could not read YAML output of tpm2_getcap.\")",
            "            return",
            "        for algorithm, details in retyaml.items():",
            "            if details[\"asymmetric\"] == 1 and details[\"object\"] == 1 and algorithms.Encrypt.is_recognized(algorithm):",
            "                self.supported[\"encrypt\"].add(algorithm)",
            "            elif details[\"hash\"] == 1 and algorithms.Hash.is_recognized(algorithm):",
            "                self.supported[\"hash\"].add(algorithm)",
            "            elif details[\"asymmetric\"] == 1 and details[\"signing\"] == 1 and algorithms.Sign.is_recognized(algorithm):",
            "                self.supported[\"sign\"].add(algorithm)",
            "",
            "    def __get_pcrs(self):",
            "        \"\"\"Gets which PCRs are enabled with which hash algorithm\"\"\"",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run([\"tpm2_getcap\", \"-c\", \"pcrs\"])",
            "        elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "            retDict = self.__run([\"tpm2_getcap\", \"pcrs\"])",
            "",
            "        output = config.convert(retDict[\"retout\"])",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            raise Exception(\"get_tpm_algorithms failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "        retyaml = config.yaml_to_dict(output, logger=logger)",
            "        pcrs = {}",
            "        if retyaml is None:",
            "            logger.warning(\"Could not read YAML output of tpm2_getcap.\")",
            "            return pcrs",
            "        if \"selected-pcrs\" in retyaml:",
            "            pcrs = collections.ChainMap(*retyaml[\"selected-pcrs\"])",
            "        return pcrs",
            "",
            "    def run(self, cmd):",
            "        return self.__run(cmd, lock=False)",
            "",
            "    def __run(",
            "        self, cmd, expectedcode=tpm_abstract.AbstractTPM.EXIT_SUCESS, raiseOnError=True, lock=True, outputpaths=None",
            "    ):",
            "        env = _get_cmd_env()",
            "",
            "        # Convert single outputpath to list",
            "        if isinstance(outputpaths, str):",
            "            outputpaths = [outputpaths]",
            "",
            "        numtries = 0",
            "        while True:",
            "            if lock:",
            "                with self.tpmutilLock:",
            "                    retDict = cmd_exec.run(",
            "                        cmd=cmd, expectedcode=expectedcode, raiseOnError=False, outputpaths=outputpaths, env=env",
            "                    )",
            "            else:",
            "                retDict = cmd_exec.run(",
            "                    cmd=cmd, expectedcode=expectedcode, raiseOnError=False, outputpaths=outputpaths, env=env",
            "                )",
            "            code = retDict[\"code\"]",
            "            retout = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "",
            "            # keep trying to get quote if a PCR race condition occurred in quote",
            "            if cmd[0] == \"tpm2_quote\" and cmd_exec.list_contains_substring(",
            "                reterr, \"Error validating calculated PCR composite with quote\"",
            "            ):",
            "                numtries += 1",
            "                maxr = config.getint(\"agent\", \"max_retries\")",
            "                if numtries >= maxr:",
            "                    logger.error(\"Agent did not return proper quote due to PCR race condition.\")",
            "                    break",
            "                interval = config.getfloat(\"agent\", \"retry_interval\")",
            "                exponential_backoff = config.getboolean(\"agent\", \"exponential_backoff\")",
            "                next_retry = retry.retry_time(exponential_backoff, interval, numtries, logger)",
            "                logger.info(",
            "                    \"Failed to get quote %d/%d times, trying again in %f seconds...\", numtries, maxr, next_retry",
            "                )",
            "                time.sleep(next_retry)",
            "                continue",
            "",
            "            break",
            "",
            "        # Don't bother continuing if TPM call failed and we're raising on error",
            "        if code != expectedcode and raiseOnError:",
            "            raise Exception(",
            "                f\"Command: {cmd} returned {code}, expected {expectedcode}, output {retout}, stderr {reterr}\"",
            "            )",
            "",
            "        return retDict",
            "",
            "    # tpm_initialize",
            "    def __startup_tpm(self):",
            "        retDict = self.__run([\"tpm2_startup\", \"-c\"])",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            raise Exception(\"Error initializing emulated TPM with TPM2_Startup: %s\" + str(code) + \": \" + str(errout))",
            "",
            "    def __create_ek(self, asym_alg=None):",
            "        # this function is intended to be idempotent",
            "        if asym_alg is None:",
            "            asym_alg = self.defaults[\"encrypt\"]",
            "",
            "        current_handle = self.get_tpm_metadata(\"ek_handle\")",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "",
            "        # clear out old handle before starting again (give idempotence)",
            "        if current_handle is not None and owner_pw is not None:",
            "            logger.info(\"Flushing old ek handle: %s\", hex(current_handle))",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"], raiseOnError=False)",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"], raiseOnError=False)",
            "            output = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_getcap failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "            outjson = config.yaml_to_dict(output, logger=logger)",
            "            if outjson is not None and hex(current_handle) in outjson:",
            "                if self.tools_version == \"3.2\":",
            "                    cmd = [\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(current_handle), \"-P\", owner_pw]",
            "                    retDict = self.__run(cmd, raiseOnError=False)",
            "                elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                    cmd = [\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", hex(current_handle), \"-P\", owner_pw]",
            "                    retDict = self.__run(cmd, raiseOnError=False)",
            "                output = retDict[\"retout\"]",
            "                reterr = retDict[\"reterr\"]",
            "                code = retDict[\"code\"]",
            "",
            "                if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                    logger.info(",
            "                        \"Failed to flush old ek handle: %s.  Code %s: %s\", hex(current_handle), str(code), str(reterr)",
            "                    )",
            "",
            "                self._set_tpm_metadata(\"ek_handle\", None)",
            "                self._set_tpm_metadata(\"ek_tpm\", None)",
            "                self._set_tpm_metadata(\"ek_pw\", None)",
            "",
            "        # make sure an ownership pw is set",
            "        if owner_pw is None:",
            "            owner_pw = tpm_abstract.TPM_Utilities.random_password(20)",
            "            self._set_tpm_metadata(\"owner_pw\", owner_pw)",
            "        ek_pw = tpm_abstract.TPM_Utilities.random_password(20)",
            "",
            "        # create a new ek",
            "        with tempfile.NamedTemporaryFile() as tmppath:",
            "            # TODO(kaifeng) Missing else here for other versions",
            "            if self.tools_version == \"3.2\":",
            "                command = [",
            "                    \"tpm2_getpubek\",",
            "                    \"-H\",",
            "                    \"0x81010007\",",
            "                    \"-g\",",
            "                    asym_alg,",
            "                    \"-f\",",
            "                    tmppath.name,",
            "                    \"-P\",",
            "                    ek_pw,",
            "                    \"-o\",",
            "                    owner_pw,",
            "                    \"-e\",",
            "                    owner_pw,",
            "                ]",
            "            elif self.tools_version == \"4.0\":",
            "                command = [",
            "                    \"tpm2_createek\",",
            "                    \"-c\",",
            "                    \"-\",",
            "                    \"-G\",",
            "                    asym_alg,",
            "                    \"-u\",",
            "                    tmppath.name,",
            "                    \"-p\",",
            "                    ek_pw,",
            "                    \"-w\",",
            "                    owner_pw,",
            "                    \"-P\",",
            "                    owner_pw,",
            "                ]",
            "            elif self.tools_version == \"4.2\":",
            "                command = [",
            "                    \"tpm2_createek\",",
            "                    \"-c\",",
            "                    \"-\",",
            "                    \"-G\",",
            "                    asym_alg,",
            "                    \"-u\",",
            "                    tmppath.name,",
            "                    \"-w\",",
            "                    owner_pw,",
            "                    \"-P\",",
            "                    owner_pw,",
            "                ]",
            "",
            "            retDict = self.__run(command, raiseOnError=False, outputpaths=tmppath.name)",
            "            output = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "            ek_tpm = retDict[\"fileouts\"][tmppath.name]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"createek failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "            if self.tools_version == \"3.2\":",
            "                handle = int(0x81010007)",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                handle = None",
            "                retyaml = config.yaml_to_dict(output, logger=logger)",
            "                if retyaml is None:",
            "                    raise Exception(\"Could not read YAML output of tpm2_createek.\")",
            "                if \"persistent-handle\" in retyaml:",
            "                    handle = retyaml[\"persistent-handle\"]",
            "",
            "            # Make sure that all transient objects are flushed",
            "            self.__run([\"tpm2_flushcontext\", \"-t\"], raiseOnError=False)",
            "",
            "            self._set_tpm_metadata(\"ek_handle\", handle)",
            "            self._set_tpm_metadata(\"ek_pw\", ek_pw)",
            "            self._set_tpm_metadata(\"ek_tpm\", base64.b64encode(ek_tpm))",
            "            self._set_tpm_metadata(\"ek_alg\", asym_alg)",
            "",
            "    def __use_ek(self, ek_handle, config_pw):",
            "        ek_handle = int(ek_handle, 16)",
            "        logger.info(\"Using an already created ek with handle: %s\", hex(ek_handle))",
            "",
            "        self._set_tpm_metadata(\"owner_pw\", config_pw)",
            "",
            "        with tempfile.NamedTemporaryFile() as tmppath:",
            "            if self.tools_version == \"3.2\":",
            "                cmd = [\"tpm2_readpublic\", \"-H\", hex(ek_handle), \"-o\", tmppath.name, \"-f\", \"tss\"]",
            "                retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                cmd = [\"tpm2_readpublic\", \"-c\", hex(ek_handle), \"-o\", tmppath.name, \"-f\", \"tss\"]",
            "                retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)",
            "",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "            ek_tpm = retDict[\"fileouts\"][tmppath.name]",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_readpublic failed with code \" + str(code) + \": \" + str(reterr))",
            "            self._set_tpm_metadata(\"ek_tpm\", base64.b64encode(ek_tpm))",
            "",
            "        self._set_tpm_metadata(\"ek_handle\", int(ek_handle))",
            "",
            "    def __take_ownership(self, config_pw):",
            "        # if no ownerpassword",
            "        if config_pw == \"generate\":",
            "            logger.info(\"Generating random TPM owner password\")",
            "            owner_pw = tpm_abstract.TPM_Utilities.random_password(20)",
            "        else:",
            "            logger.info(\"Taking ownership with config provided TPM owner password\")",
            "            owner_pw = config_pw",
            "",
            "        logger.debug(\"Removing all saved sessions from TPM\")",
            "        retDict = self.__run([\"tpm2_flushcontext\", \"-s\"], raiseOnError=False)",
            "",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run([\"tpm2_takeownership\", \"-c\"], raiseOnError=False)",
            "            retDict = self.__run([\"tpm2_takeownership\", \"-o\", owner_pw, \"-e\", owner_pw], raiseOnError=False)",
            "        elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "            retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"o\", owner_pw], raiseOnError=False)",
            "            retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"e\", owner_pw], raiseOnError=False)",
            "",
            "        code = retDict[\"code\"]",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            # if we fail, see if already owned with this pw",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run(",
            "                    [\"tpm2_takeownership\", \"-o\", owner_pw, \"-e\", owner_pw, \"-O\", owner_pw, \"-E\", owner_pw],",
            "                    raiseOnError=False,",
            "                )",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"o\", \"-p\", owner_pw, owner_pw], raiseOnError=False)",
            "                retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"e\", \"-p\", owner_pw, owner_pw], raiseOnError=False)",
            "",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                # ut-oh, already owned but not with provided pw!",
            "                raise Exception(\"Owner password unknown, TPM reset required. Code %s\" + str(code) + \": \" + str(reterr))",
            "",
            "        self._set_tpm_metadata(\"owner_pw\", owner_pw)",
            "        logger.info(\"TPM Owner password confirmed: %s\", owner_pw)",
            "",
            "    def __get_pub_ek(self):  # assumes that owner_pw is correct at this point",
            "        handle = self.get_tpm_metadata(\"ek_handle\")",
            "        if handle is None:",
            "            raise Exception(\"create_ek has not been run yet?\")",
            "        # make a temp file for the output",
            "        with tempfile.NamedTemporaryFile() as tmppath:",
            "            # generates pubek.pem",
            "            if self.tools_version == \"3.2\":",
            "                cmd = [\"tpm2_readpublic\", \"-H\", hex(handle), \"-o\", tmppath.name]",
            "                retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                cmd = [\"tpm2_readpublic\", \"-c\", hex(handle), \"-o\", tmppath.name]",
            "                retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)",
            "",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "            ek = retDict[\"fileouts\"][tmppath.name]",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_readpublic failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "        self._set_tpm_metadata(\"ek_tpm\", base64.b64encode(ek))",
            "",
            "    def __create_aik(self, asym_alg=None, hash_alg=None, sign_alg=None):",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"]",
            "        if asym_alg is None:",
            "            asym_alg = self.defaults[\"encrypt\"]",
            "        if sign_alg is None:",
            "            sign_alg = self.defaults[\"sign\"]",
            "",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "",
            "        # clear out old handle before starting again (give idempotence)",
            "        if self.get_tpm_metadata(\"aik_handle\") is not None:",
            "            aik_handle = self.get_tpm_metadata(\"aik_handle\")",
            "            if self.tools_version == \"3.2\":",
            "                logger.info(\"Flushing old ak handle: %s\", hex(aik_handle))",
            "                retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"], raiseOnError=False)",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                logger.info(\"Flushing old ak handle: %s\", aik_handle)",
            "                retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"], raiseOnError=False)",
            "            output = config.convert(retDict[\"retout\"])",
            "            errout = config.convert(retDict[\"reterr\"])",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_getcap failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "            if self.tools_version == \"3.2\":",
            "                # output, human-readable -> json",
            "                output = \"\".join(output)",
            "                output = output.replace(\"0x\", \" - 0x\")",
            "                output = [output]",
            "",
            "            outjson = config.yaml_to_dict(output, logger=logger)",
            "            if self.tools_version == \"3.2\":",
            "                evict_it = outjson is not None and aik_handle in outjson",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                evict_it = os.path.exists(aik_handle)",
            "            if evict_it:",
            "                if self.tools_version == \"3.2\":",
            "                    cmd = [\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(aik_handle), \"-P\", owner_pw]",
            "                    retDict = self.__run(cmd, raiseOnError=False)",
            "                elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                    cmd = [\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", aik_handle, \"-P\", owner_pw]",
            "                    retDict = self.__run(cmd, raiseOnError=False)",
            "                    os.remove(aik_handle)",
            "",
            "                output = retDict[\"retout\"]",
            "                reterr = retDict[\"reterr\"]",
            "                code = retDict[\"code\"]",
            "",
            "                if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                    if self.tools_version == \"3.2\":",
            "                        logger.info(",
            "                            \"Failed to flush old ak handle: %s.  Code %s: %s\", hex(aik_handle), str(code), str(reterr)",
            "                        )",
            "                    elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                        logger.info(",
            "                            \"Failed to flush old ak handle: %s.  Code %s: %s\", aik_handle, str(code), str(reterr)",
            "                        )",
            "",
            "                self._set_tpm_metadata(\"aik_pw\", None)",
            "                self._set_tpm_metadata(\"aik_tpm\", None)",
            "                self._set_tpm_metadata(\"aik_handle\", None)",
            "",
            "        logger.debug(\"Creating a new AIK identity\")",
            "",
            "        # We need an ek handle to make an aik",
            "        ek_handle = self.get_tpm_metadata(\"ek_handle\")",
            "        if ek_handle is None:",
            "            raise Exception(\"Failed to create AIK, since EK has not yet been created!\")",
            "",
            "        aik_pw = tpm_abstract.TPM_Utilities.random_password(20)",
            "        # make a temp file for the output",
            "        with tempfile.NamedTemporaryFile() as akpubfile:",
            "            secpath = \"\"",
            "            if self.tools_version in [\"4.0\", \"4.2\"]:",
            "                # ok lets write out the key now",
            "                secdir = secure_mount.mount()  # confirm that storage is still securely mounted",
            "                secfd, secpath = tempfile.mkstemp(dir=secdir)",
            "",
            "            if self.tools_version == \"3.2\":",
            "                command = [",
            "                    \"tpm2_getpubak\",",
            "                    \"-E\",",
            "                    hex(ek_handle),",
            "                    \"-k\",",
            "                    \"0x81010008\",",
            "                    \"-g\",",
            "                    asym_alg,",
            "                    \"-D\",",
            "                    hash_alg,",
            "                    \"-s\",",
            "                    sign_alg,",
            "                    \"-f\",",
            "                    akpubfile.name,",
            "                    \"-e\",",
            "                    owner_pw,",
            "                    \"-P\",",
            "                    aik_pw,",
            "                    \"-o\",",
            "                    owner_pw,",
            "                ]",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                command = [",
            "                    \"tpm2_createak\",",
            "                    \"-C\",",
            "                    hex(ek_handle),",
            "                    \"-c\",",
            "                    secpath,",
            "                    \"-G\",",
            "                    asym_alg,",
            "                    \"-g\",",
            "                    hash_alg,",
            "                    \"-s\",",
            "                    sign_alg,",
            "                    \"-u\",",
            "                    akpubfile.name,",
            "                    \"-p\",",
            "                    aik_pw,",
            "                    \"-P\",",
            "                    owner_pw,",
            "                ]",
            "            retDict = self.__run(command, outputpaths=akpubfile.name)",
            "            if secfd >= 0:",
            "                os.close(secfd)",
            "            retout = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_createak failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "            jsonout = config.yaml_to_dict(retout, logger=logger)",
            "            if jsonout is None:",
            "                raise Exception(",
            "                    \"unable to parse YAML output of tpm2_createak. Is your tpm2-tools installation up to date?\"",
            "                )",
            "            aik_tpm = retDict[\"fileouts\"][akpubfile.name]",
            "            if aik_tpm == \"\":",
            "                raise Exception(",
            "                    \"unable to read public aik from create identity.  Is your tpm2-tools installation up to date?\"",
            "                )",
            "            self._set_tpm_metadata(\"aik_tpm\", base64.b64encode(aik_tpm))",
            "",
            "        if self.tools_version == \"3.2\":",
            "            if \"loaded-key\" not in jsonout or \"name\" not in jsonout[\"loaded-key\"]:",
            "                raise Exception(\"tpm2_createak failed to create aik: return \" + str(reterr))",
            "",
            "            handle = int(0x81010008)",
            "",
            "            # get and persist the pem (not returned by tpm2_getpubak)",
            "            self._set_tpm_metadata(\"aik_handle\", handle)",
            "        elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "            if \"loaded-key\" not in jsonout:",
            "                raise Exception(\"tpm2_createak failed to create aik: return \" + str(reterr))",
            "",
            "            handle = secpath",
            "",
            "            # persist the pem",
            "            self._set_tpm_metadata(\"aik_handle\", handle)",
            "",
            "        # Make sure that all transient objects are flushed",
            "        self.__run([\"tpm2_flushcontext\", \"-t\"], raiseOnError=False)",
            "",
            "        # persist common results",
            "        self._set_tpm_metadata(\"aik_pw\", aik_pw)",
            "",
            "    def flush_keys(self):",
            "        logger.debug(\"Flushing keys from TPM...\")",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"])",
            "        elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "            retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"])",
            "        # retout = retDict['retout']",
            "        retout = config.convert(retDict[\"retout\"])",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            logger.debug(\"tpm2_getcap failed with code %s: %s\", str(code), str(errout))",
            "",
            "        if self.tools_version == \"3.2\":",
            "            # output, human-readable -> json",
            "            retout = \"\".join(retout)",
            "            retout = retout.replace(\"0x\", \" - 0x\")",
            "            retout = [retout]",
            "",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "        jsonout = config.yaml_to_dict(retout, logger=logger)",
            "        if jsonout is None:",
            "            logger.warning(\"Could not read YAML output of tpm2_getcap.\")",
            "            jsonout = {}",
            "        for key in jsonout:",
            "            if str(hex(key)) != self.defaults[\"ek_handle\"]:",
            "                logger.debug(\"Flushing key handle %s\", hex(key))",
            "                if self.tools_version == \"3.2\":",
            "                    self.__run([\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(key), \"-P\", owner_pw], raiseOnError=False)",
            "                elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                    self.__run([\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", hex(key), \"-P\", owner_pw], raiseOnError=False)",
            "        # Make sure that all transient objects are flushed",
            "        self.__run([\"tpm2_flushcontext\", \"-t\"], lock=False, raiseOnError=False)",
            "",
            "    def encryptAIK(self, uuid, ek_tpm: bytes, aik_tpm: bytes):",
            "",
            "        if ek_tpm is None or aik_tpm is None:",
            "            logger.error(\"Missing parameters for encryptAIK\")",
            "            return None",
            "",
            "        aik_name = tpm2_objects.get_tpm2b_public_name(aik_tpm)",
            "",
            "        efd = keyfd = blobfd = -1",
            "        ekFile = None",
            "        challengeFile = None",
            "        keyblob = None",
            "        blobpath = None",
            "",
            "        try:",
            "            # write out the public EK",
            "            efd, etemp = tempfile.mkstemp()",
            "            with open(etemp, \"wb\") as ekFile:",
            "                ekFile.write(ek_tpm)",
            "",
            "            # write out the challenge",
            "            challenge = tpm_abstract.TPM_Utilities.random_password(32)",
            "            challenge = challenge.encode()",
            "            keyfd, keypath = tempfile.mkstemp()",
            "            with open(keypath, \"wb\") as challengeFile:",
            "                challengeFile.write(challenge)",
            "",
            "            # create temp file for the blob",
            "            blobfd, blobpath = tempfile.mkstemp()",
            "            command = [",
            "                \"tpm2_makecredential\",",
            "                \"-T\",",
            "                \"none\",",
            "                \"-e\",",
            "                ekFile.name,",
            "                \"-s\",",
            "                challengeFile.name,",
            "                \"-n\",",
            "                aik_name,",
            "                \"-o\",",
            "                blobpath,",
            "            ]",
            "            self.__run(command, lock=False)",
            "",
            "            logger.info(\"Encrypting AIK for UUID %s\", uuid)",
            "",
            "            # read in the blob",
            "            with open(blobpath, \"rb\") as f:",
            "                keyblob = base64.b64encode(f.read())",
            "",
            "            # read in the aes key",
            "            key = base64.b64encode(challenge).decode(\"utf-8\")",
            "",
            "        except Exception as e:",
            "            logger.error(\"Error encrypting AIK: %s\", str(e))",
            "            logger.exception(e)",
            "            raise",
            "        finally:",
            "            for fd in [efd, keyfd, blobfd]:",
            "                if fd >= 0:",
            "                    os.close(fd)",
            "            for fi in [ekFile, challengeFile]:",
            "                if fi is not None:",
            "                    os.remove(fi.name)",
            "            if blobpath is not None:",
            "                os.remove(blobpath)",
            "",
            "        return (keyblob, key)",
            "",
            "    def activate_identity(self, keyblob):",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "        aik_keyhandle = self.get_tpm_metadata(\"aik_handle\")",
            "        ek_keyhandle = self.get_tpm_metadata(\"ek_handle\")",
            "",
            "        keyblobFile = None",
            "        secpath = None",
            "        secfd = -1",
            "        sesspath = None",
            "        sesspathfd = -1",
            "        try:",
            "            # write out key blob",
            "            kfd, ktemp = tempfile.mkstemp()",
            "            with open(ktemp, \"wb\") as keyblobFile:",
            "                # the below is a coroutine?",
            "                keyblobFile.write(base64.b64decode(keyblob))",
            "",
            "            os.close(kfd)",
            "",
            "            # ok lets write out the key now",
            "            secdir = secure_mount.mount()  # confirm that storage is still securely mounted",
            "",
            "            secfd, secpath = tempfile.mkstemp(dir=secdir)",
            "            sesspathfd, sesspath = tempfile.mkstemp(dir=secdir)",
            "",
            "            apw = self.get_tpm_metadata(\"aik_pw\")",
            "            if self.tools_version == \"3.2\":",
            "                command = [",
            "                    \"tpm2_activatecredential\",",
            "                    \"-H\",",
            "                    hex(aik_keyhandle),",
            "                    \"-k\",",
            "                    hex(ek_keyhandle),",
            "                    \"-f\",",
            "                    keyblobFile.name,",
            "                    \"-o\",",
            "                    secpath,",
            "                    \"-P\",",
            "                    apw,",
            "                    \"-e\",",
            "                    owner_pw,",
            "                ]",
            "                retDict = self.__run(command, outputpaths=secpath)",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                self.__run([\"tpm2_startauthsession\", \"--policy-session\", \"-S\", sesspath])",
            "                self.__run([\"tpm2_policysecret\", \"-S\", sesspath, \"-c\", \"0x4000000B\", owner_pw])",
            "                command = [",
            "                    \"tpm2_activatecredential\",",
            "                    \"-c\",",
            "                    aik_keyhandle,",
            "                    \"-C\",",
            "                    hex(ek_keyhandle),",
            "                    \"-i\",",
            "                    keyblobFile.name,",
            "                    \"-o\",",
            "                    secpath,",
            "                    \"-p\",",
            "                    apw,",
            "                    \"-P\",",
            "                    f\"session:{sesspath}\",",
            "                ]",
            "                retDict = self.__run(command, outputpaths=secpath)",
            "                self.__run([\"tpm2_flushcontext\", sesspath])",
            "",
            "            # Make sure that all transient objects are flushed",
            "            self.__run([\"tpm2_flushcontext\", \"-t\"], raiseOnError=False)",
            "",
            "            fileout = retDict[\"fileouts\"][secpath]",
            "            logger.info(\"AIK activated.\")",
            "",
            "            key = base64.b64encode(fileout)",
            "",
            "        except Exception as e:",
            "            logger.error(\"Error decrypting AIK: %s\", str(e))",
            "            logger.exception(e)",
            "            return None",
            "        finally:",
            "            if keyblobFile is not None:",
            "                os.remove(keyblobFile.name)",
            "            if secfd >= 0:",
            "                os.close(secfd)",
            "            if secpath is not None and os.path.exists(secpath):",
            "                os.remove(secpath)",
            "            if sesspathfd >= 0:",
            "                os.close(sesspathfd)",
            "            if sesspath is not None and os.path.exists(sesspath):",
            "                os.remove(sesspath)",
            "        return key",
            "",
            "    def verify_ek(self, ekcert):",
            "        \"\"\"Verify that the provided EK certificate is signed by a trusted root",
            "        :param ekcert: The Endorsement Key certificate in DER format",
            "        :returns: True if the certificate can be verified, false otherwise",
            "        \"\"\"",
            "        # openssl x509 -inform der -in certificate.cer -out certificate.pem",
            "        try:",
            "            tpm_ek_ca.check_tpm_cert_store()",
            "",
            "            ek509 = x509.load_der_x509_certificate(",
            "                data=ekcert,",
            "                backend=default_backend(),",
            "            )",
            "",
            "            trusted_certs = tpm_ek_ca.cert_loader()",
            "            for cert in trusted_certs:",
            "                signcert = x509.load_pem_x509_certificate(",
            "                    data=cert.encode(),",
            "                    backend=default_backend(),",
            "                )",
            "",
            "                if ek509.issuer.rfc4514_string() != signcert.subject.rfc4514_string():",
            "                    continue",
            "",
            "                try:",
            "                    signcert.public_key().verify(",
            "                        ek509.signature,",
            "                        ek509.tbs_certificate_bytes,",
            "                        padding.PKCS1v15(),",
            "                        ek509.signature_hash_algorithm,",
            "                    )",
            "                except crypto_exceptions.InvalidSignature:",
            "                    continue",
            "",
            "                logger.debug(\"EK cert matched cert: %s\", cert)",
            "                return True",
            "        except Exception as e:",
            "            # Log the exception so we don't lose the raw message",
            "            logger.exception(e)",
            "            raise Exception(\"Error processing ek/ekcert. Does this TPM have a valid EK?\").with_traceback(",
            "                sys.exc_info()[2]",
            "            )",
            "",
            "        logger.error(\"No Root CA matched EK Certificate\")",
            "        return False",
            "",
            "    def get_tpm_manufacturer(self, output=None):",
            "        vendorStr = None",
            "        if not output:",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run([\"tpm2_getcap\", \"-c\", \"properties-fixed\"])",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                retDict = self.__run([\"tpm2_getcap\", \"properties-fixed\"])",
            "            else:",
            "                raise Exception(f\"Unsupported tools version: {self.tools_version}\")",
            "",
            "            output = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"get_tpm_manufacturer failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "        # Clean up TPM manufacturer information (strip control characters)",
            "        # These strings are supposed to be printable ASCII characters, but",
            "        # some TPM manufacturers put control characters in here",
            "        #",
            "        # TPM manufacturer information can also contain un-escaped",
            "        # double quotes. Making sure that un-escaped quotes are",
            "        # replaced before attempting YAML parse.",
            "        def quoterepl(m):",
            "            return '\"' + m.group(0)[1:-1].replace('\"', '\\\\\"') + '\"'",
            "",
            "        for i, s in enumerate(output):",
            "            s1 = re.sub(r'(?!\".*\\\\\".*\")\".*\".*\"', quoterepl, s.decode(\"utf-8\"))",
            "            output[i] = re.sub(r\"[\\x01-\\x1F\\x7F]\", \"\", s1).encode(\"utf-8\")",
            "",
            "        retyaml = config.yaml_to_dict(output, logger=logger)",
            "        if retyaml is None:",
            "            raise Exception(\"Could not read YAML output of tpm2_getcap.\")",
            "        if \"TPM2_PT_VENDOR_STRING_1\" in retyaml:",
            "            vendorStr = retyaml[\"TPM2_PT_VENDOR_STRING_1\"][\"value\"]",
            "        elif \"TPM_PT_VENDOR_STRING_1\" in retyaml:",
            "            vendorStr = retyaml[\"TPM_PT_VENDOR_STRING_1\"][\"as string\"].strip()",
            "",
            "        return vendorStr",
            "",
            "    def is_emulator(self):",
            "        return self.get_tpm_manufacturer() == \"SW\"",
            "",
            "    def tpm_init(self, self_activate=False, config_pw=None):",
            "        # this was called tpm_initialize.init before",
            "        self.warn_emulator()",
            "",
            "        self.defaults[\"ek_handle\"] = config.get(\"agent\", \"ek_handle\")",
            "",
            "        if self.need_hw_tpm:",
            "            # We don't know which algs the TPM supports yet",
            "            self.supported[\"encrypt\"] = set()",
            "            self.supported[\"hash\"] = set()",
            "            self.supported[\"sign\"] = set()",
            "",
            "            # Grab which default algs the config requested",
            "            defaultHash = config.get(\"agent\", \"tpm_hash_alg\")",
            "            defaultEncrypt = config.get(\"agent\", \"tpm_encryption_alg\")",
            "            defaultSign = config.get(\"agent\", \"tpm_signing_alg\")",
            "",
            "            if self.defaults[\"ek_handle\"] == \"generate\":",
            "                # Start up the TPM",
            "                self.__startup_tpm()",
            "",
            "            # Figure out which algorithms the TPM supports",
            "            self.__get_tpm_algorithms()",
            "",
            "            # Ensure TPM supports the defaults requested",
            "            if defaultHash not in self.supported[\"hash\"]:",
            "                raise Exception(f\"Unsupported hash algorithm specified: {str(defaultHash)}!\")",
            "",
            "            if defaultEncrypt not in self.supported[\"encrypt\"]:",
            "                raise Exception(f\"Unsupported encryption algorithm specified: {str(defaultEncrypt)}!\")",
            "",
            "            if defaultSign not in self.supported[\"sign\"]:",
            "                raise Exception(f\"Unsupported signing algorithm specified: {str(defaultSign)}!\")",
            "",
            "            enabled_pcrs = self.__get_pcrs()",
            "            if not enabled_pcrs.get(str(defaultHash)):",
            "                raise Exception(f\"No PCR banks enabled for hash algorithm specified: {defaultHash}\")",
            "",
            "            self.defaults[\"hash\"] = algorithms.Hash(defaultHash)",
            "            self.defaults[\"encrypt\"] = defaultEncrypt",
            "            self.defaults[\"sign\"] = defaultSign",
            "",
            "        if self.defaults[\"ek_handle\"] == \"generate\":",
            "            self.__take_ownership(config_pw)",
            "            self.__create_ek()",
            "        else:",
            "            self.__use_ek(self.defaults[\"ek_handle\"], config_pw)",
            "",
            "        self.__get_pub_ek()",
            "",
            "        ekcert = self.read_ekcert_nvram()",
            "        self._set_tpm_metadata(\"ekcert\", ekcert)",
            "",
            "        # if no AIK created, then create one",
            "        self.__create_aik()",
            "",
            "        return self.get_tpm_metadata(\"ekcert\"), self.get_tpm_metadata(\"ek_tpm\"), self.get_tpm_metadata(\"aik_tpm\")",
            "",
            "    # tpm_quote",
            "    @staticmethod",
            "    def __pcr_mask_to_list(mask):",
            "        pcr_list = []",
            "        for pcr in range(24):",
            "            if tpm_abstract.TPM_Utilities.check_mask(mask, pcr):",
            "                pcr_list.append(str(pcr))",
            "        return \",\".join(pcr_list)",
            "",
            "    def create_quote(self, nonce, data=None, pcrmask=tpm_abstract.AbstractTPM.EMPTYMASK, hash_alg=None, compress=False):",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"]",
            "",
            "        quote = \"\"",
            "",
            "        with tempfile.NamedTemporaryFile() as quotepath, tempfile.NamedTemporaryFile() as sigpath, tempfile.NamedTemporaryFile() as pcrpath:",
            "            keyhandle = self.get_tpm_metadata(\"aik_handle\")",
            "            aik_pw = self.get_tpm_metadata(\"aik_pw\")",
            "",
            "            if pcrmask is None:",
            "                pcrmask = tpm_abstract.AbstractTPM.EMPTYMASK",
            "",
            "            if data is not None:",
            "                # add PCR 16 to pcrmask",
            "                pcrmask = hex(int(pcrmask, 0) | (1 << config.TPM_DATA_PCR))",
            "",
            "            pcrlist = self.__pcr_mask_to_list(pcrmask)",
            "",
            "            with self.tpmutilLock:",
            "                if data is not None:",
            "                    self.__run([\"tpm2_pcrreset\", str(config.TPM_DATA_PCR)], lock=False)",
            "                    self.extendPCR(pcrval=config.TPM_DATA_PCR, hashval=self.hashdigest(data), lock=False)",
            "",
            "                nonce = bytes(nonce, encoding=\"utf8\").hex()",
            "                if self.tools_version == \"3.2\":",
            "                    command = [",
            "                        \"tpm2_quote\",",
            "                        \"-k\",",
            "                        hex(keyhandle),",
            "                        \"-L\",",
            "                        f\"{str(hash_alg)}:{pcrlist}\",",
            "                        \"-q\",",
            "                        nonce,",
            "                        \"-m\",",
            "                        quotepath.name,",
            "                        \"-s\",",
            "                        sigpath.name,",
            "                        \"-p\",",
            "                        pcrpath.name,",
            "                        \"-G\",",
            "                        hash_alg,",
            "                        \"-P\",",
            "                        aik_pw,",
            "                    ]",
            "                elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                    command = [",
            "                        \"tpm2_quote\",",
            "                        \"-c\",",
            "                        keyhandle,",
            "                        \"-l\",",
            "                        f\"{str(hash_alg)}:{pcrlist}\",",
            "                        \"-q\",",
            "                        nonce,",
            "                        \"-m\",",
            "                        quotepath.name,",
            "                        \"-s\",",
            "                        sigpath.name,",
            "                        \"-o\",",
            "                        pcrpath.name,",
            "                        \"-g\",",
            "                        hash_alg,",
            "                        \"-p\",",
            "                        aik_pw,",
            "                    ]",
            "                retDict = self.__run(command, lock=False, outputpaths=[quotepath.name, sigpath.name, pcrpath.name])",
            "                # Make sure that all transient objects are flushed",
            "                self.__run([\"tpm2_flushcontext\", \"-t\"], lock=False, raiseOnError=False)",
            "                quoteraw = retDict[\"fileouts\"][quotepath.name]",
            "                sigraw = retDict[\"fileouts\"][sigpath.name]",
            "                pcrraw = retDict[\"fileouts\"][pcrpath.name]",
            "                if compress:",
            "                    quoteraw = zlib.compress(quoteraw)",
            "                    sigraw = zlib.compress(sigraw)",
            "                    pcrraw = zlib.compress(pcrraw)",
            "                quote_b64encode = base64.b64encode(quoteraw)",
            "                sigraw_b64encode = base64.b64encode(sigraw)",
            "                pcrraw_b64encode = base64.b64encode(pcrraw)",
            "                quote = (",
            "                    quote_b64encode.decode(\"utf-8\")",
            "                    + \":\"",
            "                    + sigraw_b64encode.decode(\"utf-8\")",
            "                    + \":\"",
            "                    + pcrraw_b64encode.decode(\"utf-8\")",
            "                )",
            "",
            "        return \"r\" + quote",
            "",
            "    def __tpm2_checkquote(self, pubaik, nonce, quoteFile, sigFile, pcrFile, hash_alg):",
            "        nonce = bytes(nonce, encoding=\"utf8\").hex()",
            "        if self.tools_version == \"3.2\":",
            "            command = [",
            "                \"tpm2_checkquote\",",
            "                \"-c\",",
            "                pubaik,",
            "                \"-m\",",
            "                quoteFile,",
            "                \"-s\",",
            "                sigFile,",
            "                \"-p\",",
            "                pcrFile,",
            "                \"-G\",",
            "                hash_alg,",
            "                \"-q\",",
            "                nonce,",
            "            ]",
            "        elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "            command = [",
            "                \"tpm2_checkquote\",",
            "                \"-u\",",
            "                pubaik,",
            "                \"-m\",",
            "                quoteFile,",
            "                \"-s\",",
            "                sigFile,",
            "                \"-f\",",
            "                pcrFile,",
            "                \"-g\",",
            "                hash_alg,",
            "                \"-q\",",
            "                nonce,",
            "            ]",
            "        retDict = self.__run(command, lock=False)",
            "        return retDict",
            "",
            "    def __tpm2_printquote(self, quoteFile):",
            "        command = [\"tpm2_print\", \"-t\", \"TPMS_ATTEST\", quoteFile]",
            "        retDict = self.__run(command, lock=False)",
            "        return retDict",
            "",
            "    def _tpm2_printquote(self, quote, compressed):",
            "        \"\"\"Get TPM timestamp info from quote",
            "        :param quote: quote data in the format 'r<b64-compressed-quoteblob>:<b64-compressed-sigblob>:<b64-compressed-pcrblob>",
            "        :param compressed: if the quote data is compressed with zlib or not",
            "        :returns: Returns the 'retout' from running tpm2_print and True in case of success, None and False in case of error.",
            "        This function throws an Exception on bad input.",
            "        \"\"\"",
            "",
            "        if quote[0] != \"r\":",
            "            raise Exception(f\"Invalid quote type {quote[0]}\")",
            "        quote = quote[1:]",
            "",
            "        quote_tokens = quote.split(\":\")",
            "        if len(quote_tokens) < 3:",
            "            raise Exception(f\"Quote is not compound! {quote}\")",
            "",
            "        quoteblob = base64.b64decode(quote_tokens[0])",
            "",
            "        if compressed:",
            "            logger.warning(\"Decompressing quote data which is unsafe!\")",
            "            quoteblob = zlib.decompress(quoteblob)",
            "",
            "        qfd = -1",
            "        quoteFile = None",
            "",
            "        try:",
            "            # write out quote",
            "            qfd, qtemp = tempfile.mkstemp()",
            "            with open(qtemp, \"wb\") as quoteFile:",
            "                quoteFile.write(quoteblob)",
            "",
            "            retDict = self.__tpm2_printquote(quoteFile.name)",
            "            retout = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "        except Exception as e:",
            "            logger.error(\"Error printing quote: %s\", str(e))",
            "            logger.exception(e)",
            "            return None, False",
            "        finally:",
            "            for fd in [qfd]:",
            "                if fd >= 0:",
            "                    os.close(fd)",
            "            for fi in [quoteFile]:",
            "                if fi is not None:",
            "                    os.remove(fi.name)",
            "",
            "        if len(retout) < 1 or code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            logger.error(\"Failed to print quote info, output: %s\", reterr)",
            "            return None, False",
            "",
            "        return retout, True",
            "",
            "    def _tpm2_checkquote(self, aikTpmFromRegistrar, quote, nonce, hash_alg, compressed):",
            "        \"\"\"Write the files from data returned from tpm2_quote for running tpm2_checkquote",
            "        :param aikTpmFromRegistrar: AIK used to generate the quote and is needed for verifying it now.",
            "        :param quote: quote data in the format 'r<b64-compressed-quoteblob>:<b64-compressed-sigblob>:<b64-compressed-pcrblob>",
            "        :param nonce: nonce that was used to create the quote",
            "        :param hash_alg: the hash algorithm that was used",
            "        :param compressed: if the quote data is compressed with zlib or not",
            "        :returns: Returns the 'retout' from running tpm2_checkquote and True in case of success, None and False in case of error.",
            "        This function throws an Exception on bad input.",
            "        \"\"\"",
            "        aikFromRegistrar = tpm2_objects.pubkey_from_tpm2b_public(base64.b64decode(aikTpmFromRegistrar),).public_bytes(",
            "            crypto_serialization.Encoding.PEM,",
            "            crypto_serialization.PublicFormat.SubjectPublicKeyInfo,",
            "        )",
            "",
            "        if quote[0] != \"r\":",
            "            raise Exception(f\"Invalid quote type {quote[0]}\")",
            "        quote = quote[1:]",
            "",
            "        quote_tokens = quote.split(\":\")",
            "        if len(quote_tokens) < 3:",
            "            raise Exception(f\"Quote is not compound! {quote}\")",
            "",
            "        quoteblob = base64.b64decode(quote_tokens[0])",
            "        sigblob = base64.b64decode(quote_tokens[1])",
            "        pcrblob = base64.b64decode(quote_tokens[2])",
            "",
            "        if compressed:",
            "            logger.warning(\"Decompressing quote data which is unsafe!\")",
            "            quoteblob = zlib.decompress(quoteblob)",
            "            sigblob = zlib.decompress(sigblob)",
            "            pcrblob = zlib.decompress(pcrblob)",
            "",
            "        qfd = sfd = pfd = afd = -1",
            "        quoteFile = None",
            "        aikFile = None",
            "        sigFile = None",
            "        pcrFile = None",
            "",
            "        try:",
            "            # write out quote",
            "            qfd, qtemp = tempfile.mkstemp()",
            "            with open(qtemp, \"wb\") as quoteFile:",
            "                quoteFile.write(quoteblob)",
            "",
            "            # write out sig",
            "            sfd, stemp = tempfile.mkstemp()",
            "            with open(stemp, \"wb\") as sigFile:",
            "                sigFile.write(sigblob)",
            "",
            "            # write out pcr",
            "            pfd, ptemp = tempfile.mkstemp()",
            "            with open(ptemp, \"wb\") as pcrFile:",
            "                pcrFile.write(pcrblob)",
            "",
            "            afd, atemp = tempfile.mkstemp()",
            "            with open(atemp, \"wb\") as aikFile:",
            "                aikFile.write(aikFromRegistrar)",
            "",
            "            retDict = self.__tpm2_checkquote(aikFile.name, nonce, quoteFile.name, sigFile.name, pcrFile.name, hash_alg)",
            "            retout = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "        except Exception as e:",
            "            logger.error(\"Error verifying quote: %s\", str(e))",
            "            logger.exception(e)",
            "            return None, False",
            "        finally:",
            "            for fd in [qfd, sfd, pfd, afd]:",
            "                if fd >= 0:",
            "                    os.close(fd)",
            "            for fi in [aikFile, quoteFile, sigFile, pcrFile]:",
            "                if fi is not None:",
            "                    os.remove(fi.name)",
            "",
            "        if len(retout) < 1 or code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            logger.error(\"Failed to validate signature, output: %s\", reterr)",
            "            return None, False",
            "",
            "        return retout, True",
            "",
            "    def check_quote(",
            "        self,",
            "        agentAttestState,",
            "        nonce,",
            "        data,",
            "        quote,",
            "        aikTpmFromRegistrar,",
            "        tpm_policy=None,",
            "        ima_measurement_list=None,",
            "        allowlist=None,",
            "        hash_alg=None,",
            "        ima_keyrings=None,",
            "        mb_measurement_list=None,",
            "        mb_refstate=None,",
            "        compressed=False,",
            "    ) -> Failure:",
            "        if tpm_policy is None:",
            "            tpm_policy = {}",
            "        if allowlist is None:",
            "            allowlist = {}",
            "",
            "        agent_id = agentAttestState.agent_id",
            "",
            "        failure = Failure(Component.QUOTE_VALIDATION)",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"]",
            "",
            "        # First and foremost, the quote needs to be validated",
            "        retout, success = self._tpm2_checkquote(aikTpmFromRegistrar, quote, nonce, hash_alg, compressed)",
            "        if not success:",
            "            # If the quote validation fails we will skip all other steps therefore this failure is irrecoverable.",
            "            failure.add_event(",
            "                \"quote_validation\", {\"message\": \"Quote data validation using tpm2-tools\", \"data\": retout}, False",
            "            )",
            "            return failure",
            "",
            "        # Only after validating the quote, the TPM clock information can be extracted from it.",
            "        clock_failure, current_clock_info = self.check_quote_timing(agentAttestState.get_tpm_clockinfo(), quote)",
            "        if clock_failure:",
            "            failure.add_event(",
            "                \"quote_validation\",",
            "                {\"message\": \"Validation of clockinfo from quote using tpm2-tools\", \"data\": clock_failure},",
            "                False,",
            "            )",
            "            return failure",
            "        if current_clock_info:",
            "            agentAttestState.set_tpm_clockinfo(current_clock_info)",
            "",
            "        pcrs = []",
            "        jsonout = config.yaml_to_dict(retout, logger=logger)",
            "        if jsonout is None:",
            "            failure.add_event(",
            "                \"quote_validation\",",
            "                {\"message\": \"YAML parsing failed for quote validation using tpm2-tools.\", \"data\": retout},",
            "                False,",
            "            )",
            "            return failure",
            "        if \"pcrs\" in jsonout:",
            "            # The hash algorithm might be in the YAML output but does not contain any data, so we also check that.",
            "            if hash_alg in jsonout[\"pcrs\"] and jsonout[\"pcrs\"][hash_alg] is not None:",
            "                alg_size = hash_alg.get_size() // 4",
            "                for pcrval, hashval in jsonout[\"pcrs\"][hash_alg].items():",
            "                    pcrs.append(f\"PCR {pcrval} {hashval:0{alg_size}x}\")",
            "",
            "        if len(pcrs) == 0:",
            "            logger.warning(",
            "                \"Quote for agent %s does not contain any PCRs. Make sure that the TPM supports %s PCR banks\",",
            "                agent_id,",
            "                str(hash_alg),",
            "            )",
            "",
            "        return self.check_pcrs(",
            "            agentAttestState,",
            "            tpm_policy,",
            "            pcrs,",
            "            data,",
            "            False,",
            "            ima_measurement_list,",
            "            allowlist,",
            "            ima_keyrings,",
            "            mb_measurement_list,",
            "            mb_refstate,",
            "            hash_alg,",
            "        )",
            "",
            "    def check_quote_timing(self, previous_clockinfo, quote):",
            "        # Sanity check quote clock information",
            "",
            "        current_clockinfo = None",
            "",
            "        retout, success = self._tpm2_printquote(quote, False)",
            "        if not success:",
            "            return \"tpm2_print failed with \" + str(retout), current_clockinfo",
            "",
            "        tpm_data_str_dict = config.yaml_to_dict(retout, add_newlines=False, logger=logger)",
            "        if tpm_data_str_dict is None:",
            "            return \"yaml output of tpm2_print could not be parsed!\", current_clockinfo",
            "",
            "        tentative_current_clockinfo = TPMClockInfo.from_dict(tpm_data_str_dict)",
            "",
            "        resetdiff = tentative_current_clockinfo.resetcount - previous_clockinfo.resetcount",
            "        restartdiff = tentative_current_clockinfo.restartcount - previous_clockinfo.restartcount",
            "",
            "        if resetdiff < 0:",
            "            return \"resetCount value decreased on TPM between two consecutive quotes\", current_clockinfo",
            "",
            "        if restartdiff < 0:",
            "            return \"restartCount value decreased on TPM between two consecutive quotes\", current_clockinfo",
            "",
            "        if tentative_current_clockinfo.safe != 1:",
            "            return \"clock safe flag is disabled\", current_clockinfo",
            "",
            "        if not (resetdiff and restartdiff):",
            "            if tentative_current_clockinfo.clock - previous_clockinfo.clock <= 0:",
            "                return (",
            "                    \"clock timestamp did issued by TPM did not increase between two consecutive quotes\",",
            "                    current_clockinfo,",
            "                )",
            "",
            "            current_clockinfo = tentative_current_clockinfo",
            "",
            "        return None, current_clockinfo",
            "",
            "    def sim_extend(self, hashval_1, hashval_0=None, hash_alg=None):",
            "        # simulate extending a PCR value by performing TPM-specific extend procedure",
            "",
            "        if hashval_0 is None:",
            "            hashval_0 = self.START_HASH(hash_alg)",
            "",
            "        # compute expected value  H(0|H(data))",
            "        extendedval = self.hashdigest(",
            "            codecs.decode(hashval_0, \"hex_codec\")",
            "            + codecs.decode(self.hashdigest(hashval_1.encode(\"utf-8\"), hash_alg), \"hex_codec\"),",
            "            hash_alg,",
            "        ).lower()",
            "        return extendedval",
            "",
            "    def extendPCR(self, pcrval, hashval, hash_alg=None, lock=True):",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"].value",
            "",
            "        self.__run([\"tpm2_pcrextend\", f\"{pcrval}:{str(hash_alg)}={hashval}\"], lock=lock)",
            "",
            "    def readPCR(self, pcrval, hash_alg=None):",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"]",
            "        if self.tools_version == \"3.2\":",
            "            output = config.convert(self.__run(\"tpm2_pcrlist\")[\"retout\"])",
            "        elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "            output = config.convert(self.__run(\"tpm2_pcrread\")[\"retout\"])",
            "",
            "        jsonout = config.yaml_to_dict(output, logger=logger)",
            "        if jsonout is None:",
            "            raise Exception(\"Could not read YAML output of tpm2_pcrread.\")",
            "",
            "        if hash_alg not in jsonout:",
            "            raise Exception(f\"Invalid hashing algorithm '{hash_alg}' for reading PCR number {pcrval}.\")",
            "",
            "        # alg_size = Hash_Algorithms.get_hash_size(hash_alg)/4",
            "        alg_size = hash_alg.get_size() // 4",
            "        return f\"{jsonout[hash_alg][pcrval]:0{alg_size}x}\"",
            "",
            "    # tpm_random",
            "    def _get_tpm_rand_block(self, size=32):",
            "        # make a temp file for the output",
            "        rand = None",
            "        with tempfile.NamedTemporaryFile() as randpath:",
            "            try:",
            "                command = [\"tpm2_getrandom\", \"-o\", randpath.name, str(size)]",
            "                retDict = self.__run(command, outputpaths=randpath.name)",
            "                rand = retDict[\"fileouts\"][randpath.name]",
            "            except Exception as e:",
            "                if not self.tpmrand_warned:",
            "                    logger.warning(\"TPM randomness not available: %s\", e)",
            "                    self.tpmrand_warned = True",
            "                return None",
            "        return rand",
            "",
            "    # tpm_nvram",
            "    def write_key_nvram(self, key):",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "",
            "        # write out quote",
            "        with tempfile.NamedTemporaryFile() as keyFile:",
            "            keyFile.write(key)",
            "            keyFile.flush()",
            "",
            "            attrs = \"ownerread|ownerwrite\"",
            "            # TODO(kaifeng) Escaping attrs is probably not required",
            "            if self.tools_version == \"3.2\":",
            "                self.__run(",
            "                    [",
            "                        \"tpm2_nvdefine\",",
            "                        \"-x\",",
            "                        \"0x1500018\",",
            "                        \"-a\",",
            "                        \"0x40000001\",",
            "                        \"-s\",",
            "                        str(config.BOOTSTRAP_KEY_SIZE),",
            "                        \"-t\",",
            "                        f'\"{attrs}\"',",
            "                        \"-I\",",
            "                        owner_pw,",
            "                        \"-P\",",
            "                        owner_pw,",
            "                    ],",
            "                    raiseOnError=False,",
            "                )",
            "                self.__run(",
            "                    [\"tpm2_nvwrite\", \"-x\", \"0x1500018\", \"-a\", \"0x40000001\", \"-P\", owner_pw, keyFile.name],",
            "                    raiseOnError=False,",
            "                )",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                self.__run(",
            "                    [",
            "                        \"tpm2_nvdefine\",",
            "                        \"0x1500018\",",
            "                        \"-C\",",
            "                        \"0x40000001\",",
            "                        \"-s\",",
            "                        str(config.BOOTSTRAP_KEY_SIZE),",
            "                        \"-a\",",
            "                        f'\"{attrs}\"',",
            "                        \"-p\",",
            "                        owner_pw,",
            "                        \"-P\",",
            "                        owner_pw,",
            "                    ],",
            "                    raiseOnError=False,",
            "                )",
            "                self.__run(",
            "                    [\"tpm2_nvwrite\", \"0x1500018\", \"-C\", \"0x40000001\", \"-P\", owner_pw, \"-i\", keyFile.name],",
            "                    raiseOnError=False,",
            "                )",
            "",
            "    def read_ekcert_nvram(self):",
            "        # make a temp file for the quote",
            "        with tempfile.NamedTemporaryFile() as nvpath:",
            "",
            "            # Check for RSA EK cert in NVRAM (and get length)",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run(\"tpm2_nvlist\", raiseOnError=False)",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                retDict = self.__run(\"tpm2_nvreadpublic\", raiseOnError=False)",
            "            output = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                if self.tools_version == \"3.2\":",
            "                    raise Exception(\"tpm2_nvlist for ekcert failed with code \" + str(code) + \": \" + str(reterr))",
            "                if self.tools_version in [\"4.0\", \"4.2\"]:",
            "                    raise Exception(\"tpm2_nvreadpublic for ekcert failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "            outjson = config.yaml_to_dict(output, logger=logger)",
            "",
            "            if outjson is None or 0x1C00002 not in outjson or \"size\" not in outjson[0x1C00002]:",
            "                logger.warning(\"No EK certificate found in TPM NVRAM\")",
            "                return None",
            "",
            "            ekcert_size = str(outjson[0x1C00002][\"size\"])",
            "",
            "            # Read the RSA EK cert from NVRAM (DER format)",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run(",
            "                    [\"tpm2_nvread\", \"-x\", \"0x1c00002\", \"-s\", ekcert_size, \"-f\", nvpath.name, \"-a\", \"0x01c00002\"],",
            "                    raiseOnError=False,",
            "                    outputpaths=nvpath.name,",
            "                )",
            "            elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "                retDict = self.__run(",
            "                    [\"tpm2_nvread\", \"0x1c00002\", \"-s\", ekcert_size, \"-o\", nvpath.name],",
            "                    raiseOnError=False,",
            "                    outputpaths=nvpath.name,",
            "                )",
            "            output = config.convert(retDict[\"retout\"])",
            "            errout = config.convert(retDict[\"reterr\"])",
            "            code = retDict[\"code\"]",
            "            ekcert = retDict[\"fileouts\"][nvpath.name]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_nvread for ekcert failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "        return base64.b64encode(ekcert)",
            "",
            "    def read_key_nvram(self):",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run(",
            "                [",
            "                    \"tpm2_nvread\",",
            "                    \"-x\",",
            "                    \"0x1500018\",",
            "                    \"-a\",",
            "                    \"0x40000001\",",
            "                    \"-s\",",
            "                    str(config.BOOTSTRAP_KEY_SIZE),",
            "                    \"-P\",",
            "                    owner_pw,",
            "                ],",
            "                raiseOnError=False,",
            "            )",
            "        elif self.tools_version in [\"4.0\", \"4.2\"]:",
            "            retDict = self.__run(",
            "                [\"tpm2_nvread\", \"0x1500018\", \"-C\", \"0x40000001\", \"-s\", str(config.BOOTSTRAP_KEY_SIZE), \"-P\", owner_pw],",
            "                raiseOnError=False,",
            "            )",
            "",
            "        output = retDict[\"retout\"]",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            if len(errout) > 0 and \"handle does not exist\" in \"\\n\".join(errout):",
            "                logger.debug(\"No stored U in TPM NVRAM\")",
            "                return None",
            "            if len(errout) > 0 and \"ERROR: Failed to read NVRAM public area at index\" in \"\\n\".join(errout):",
            "                logger.debug(\"No stored U in TPM NVRAM\")",
            "                return None",
            "            if len(errout) > 0 and \"the handle is not correct for the use\" in \"\\n\".join(errout):",
            "                logger.debug(\"No stored U in TPM NVRAM\")",
            "                return None",
            "",
            "            raise Exception(\"nv_readvalue failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "        if len(output) != config.BOOTSTRAP_KEY_SIZE:",
            "            logger.debug(\"Invalid key length from NVRAM: %d\", len(output))",
            "            return None",
            "        return output",
            "",
            "    @staticmethod",
            "    def __stringify_pcr_keys(log: dict) -> None:",
            "        \"\"\"Ensure that the PCR indices are strings",
            "",
            "        The YAML produced by `tpm2_eventlog`, when loaded by the yaml module,",
            "        uses integer keys in the dicts holding PCR contents.  That does not",
            "        correspond to any JSON data.  This method ensures those keys are",
            "        strings.",
            "        The log is untrusted because it ultimately comes from an untrusted",
            "        source and has been processed by software that has had bugs.\"\"\"",
            "        if (not isinstance(log, dict)) or \"pcrs\" not in log:",
            "            return",
            "        old_pcrs = log[\"pcrs\"]",
            "        if not isinstance(old_pcrs, dict):",
            "            return",
            "        new_pcrs = {}",
            "        for hash_alg, cells in old_pcrs.items():",
            "            if not isinstance(cells, dict):",
            "                new_pcrs[hash_alg] = cells",
            "                continue",
            "            new_pcrs[hash_alg] = {str(index): val for index, val in cells.items()}",
            "        log[\"pcrs\"] = new_pcrs",
            "        return",
            "",
            "    @staticmethod",
            "    def __add_boot_aggregate(log: dict) -> None:",
            "        \"\"\"Scan the boot event log and calculate possible boot aggregates.",
            "",
            "        Hashes are calculated for both sha1 and sha256,",
            "        as well as for 8 or 10 participant PCRs.",
            "",
            "        Technically the sha1/10PCR combination is unnecessary, since it has no",
            "        implementation.",
            "",
            "        Error conditions caused by improper string formatting etc. are",
            "        ignored. The current assumption is that the boot event log PCR",
            "        values are in decimal encoding, but this is liable to change.\"\"\"",
            "        if (not isinstance(log, dict)) or \"pcrs\" not in log:",
            "            return",
            "        log[\"boot_aggregates\"] = {}",
            "        for hashalg in log[\"pcrs\"].keys():",
            "            log[\"boot_aggregates\"][hashalg] = []",
            "            for maxpcr in [8, 10]:",
            "                try:",
            "                    hashclass = getattr(hashlib, hashalg)",
            "                    h = hashclass()",
            "                    for pcrno in range(0, maxpcr):",
            "                        pcrstrg = log[\"pcrs\"][hashalg][str(pcrno)]",
            "                        pcrhex = f\"{pcrstrg:0{h.digest_size*2}x}\"",
            "                        h.update(bytes.fromhex(pcrhex))",
            "                    log[\"boot_aggregates\"][hashalg].append(h.hexdigest())",
            "                except Exception:",
            "                    pass",
            "",
            "    def parse_binary_bootlog(self, log_bin: bytes) -> typing.Tuple[Failure, typing.Optional[dict]]:",
            "        \"\"\"Parse and enrich a BIOS boot log",
            "",
            "        The input is the binary log.",
            "        The output is the result of parsing and applying other conveniences.\"\"\"",
            "        failure = Failure(Component.MEASURED_BOOT, [\"parser\"])",
            "        with tempfile.NamedTemporaryFile() as log_bin_file:",
            "            log_bin_file.write(log_bin)",
            "            log_bin_file.seek(0)",
            "            log_bin_filename = log_bin_file.name",
            "            try:",
            "                retDict_tpm2 = self.__run([\"tpm2_eventlog\", \"--eventlog-version=2\", log_bin_filename])",
            "            except Exception:",
            "                failure.add_event(\"tpm2_eventlog\", \"running tpm2_eventlog failed\", True)",
            "                return failure, None",
            "        log_parsed_strs = retDict_tpm2[\"retout\"]",
            "        if len(retDict_tpm2[\"reterr\"]) > 0:",
            "            failure.add_event(",
            "                \"tpm2_eventlog.warning\",",
            "                {\"context\": \"tpm2_eventlog exited with warnings\", \"data\": str(retDict_tpm2[\"reterr\"])},",
            "                True,",
            "            )",
            "            return failure, None",
            "        log_parsed_data = config.yaml_to_dict(log_parsed_strs, add_newlines=False, logger=logger)",
            "        if log_parsed_data is None:",
            "            failure.add_event(\"yaml\", \"yaml output of tpm2_eventlog could not be parsed!\", True)",
            "            return failure, None",
            "        # pylint: disable=import-outside-toplevel",
            "        try:",
            "            from keylime import tpm_bootlog_enrich",
            "        except Exception as e:",
            "            logger.error(\"Could not load tpm_bootlog_enrich (which depends on %s): %s\", config.LIBEFIVAR, str(e))",
            "            failure.add_event(",
            "                \"bootlog_enrich\",",
            "                f\"Could not load tpm_bootlog_enrich (which depends on {config.LIBEFIVAR}): {str(e)}\",",
            "                True,",
            "            )",
            "            return failure, None",
            "        # pylint: enable=import-outside-toplevel",
            "        tpm_bootlog_enrich.enrich(log_parsed_data)",
            "        tpm.__stringify_pcr_keys(log_parsed_data)",
            "        tpm.__add_boot_aggregate(log_parsed_data)",
            "        return failure, log_parsed_data",
            "",
            "    def _parse_mb_bootlog(self, log_b64: str) -> typing.Tuple[Failure, typing.Optional[dict]]:",
            "        \"\"\"Parse and enrich a BIOS boot log",
            "",
            "        The input is the base64 encoding of a binary log.",
            "        The output is the result of parsing and applying other conveniences.\"\"\"",
            "        failure = Failure(Component.MEASURED_BOOT, [\"parser\"])",
            "        try:",
            "            log_bin = base64.b64decode(log_b64, validate=True)",
            "            failure_mb, result = self.parse_binary_bootlog(log_bin)",
            "            if failure_mb:",
            "                failure.merge(failure_mb)",
            "                result = None",
            "        except binascii.Error:",
            "            failure.add_event(\"log.base64decode\", \"Measured boot log could not be decoded\", True)",
            "            result = None",
            "        return failure, result",
            "",
            "    def parse_mb_bootlog(",
            "        self, mb_measurement_list: str, hash_alg: algorithms.Hash",
            "    ) -> typing.Tuple[dict, typing.Optional[dict], dict, Failure]:",
            "        \"\"\"Parse the measured boot log and return its object and the state of the PCRs",
            "        :param mb_measurement_list: The measured boot measurement list",
            "        :param hash_alg: the hash algorithm that should be used for the PCRs",
            "        :returns: Returns a map of the state of the PCRs, measured boot data object and True for success",
            "                  and False in case an error occurred",
            "        \"\"\"",
            "        failure = Failure(Component.MEASURED_BOOT, [\"parser\"])",
            "        if mb_measurement_list:",
            "            failure_mb, mb_measurement_data = self._parse_mb_bootlog(mb_measurement_list)",
            "            if not mb_measurement_data:",
            "                failure.merge(failure_mb)",
            "                logger.error(\"Unable to parse measured boot event log. Check previous messages for a reason for error.\")",
            "                return {}, None, {}, failure",
            "            log_pcrs = mb_measurement_data.get(\"pcrs\")",
            "            if not isinstance(log_pcrs, dict):",
            "                logger.error(\"Parse of measured boot event log has unexpected value for .pcrs: %r\", log_pcrs)",
            "                failure.add_event(\"invalid_pcrs\", {\"got\": log_pcrs}, True)",
            "                return {}, None, {}, failure",
            "            pcr_hashes = log_pcrs.get(str(hash_alg))",
            "            if (not isinstance(pcr_hashes, dict)) or not pcr_hashes:",
            "                logger.error(",
            "                    \"Parse of measured boot event log has unexpected value for .pcrs.%s: %r\", str(hash_alg), pcr_hashes",
            "                )",
            "                failure.add_event(\"invalid_pcrs_hashes\", {\"got\": pcr_hashes}, True)",
            "                return {}, None, {}, failure",
            "            boot_aggregates = mb_measurement_data.get(\"boot_aggregates\")",
            "            if (not isinstance(boot_aggregates, dict)) or not boot_aggregates:",
            "                logger.error(",
            "                    \"Parse of measured boot event log has unexpected value for .boot_aggragtes: %r\", boot_aggregates",
            "                )",
            "                failure.add_event(\"invalid_boot_aggregates\", {\"got\": boot_aggregates}, True)",
            "                return {}, None, {}, failure",
            "",
            "            return pcr_hashes, boot_aggregates, mb_measurement_data, failure",
            "",
            "        return {}, None, {}, failure"
        ],
        "afterPatchFile": [
            "import base64",
            "import binascii",
            "import codecs",
            "import collections",
            "import hashlib",
            "import os",
            "import re",
            "import sys",
            "import tempfile",
            "import threading",
            "import time",
            "import typing",
            "import zlib",
            "",
            "from cryptography import exceptions as crypto_exceptions",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives import serialization as crypto_serialization",
            "from cryptography.hazmat.primitives.asymmetric import padding",
            "from packaging.version import Version",
            "",
            "from keylime import cmd_exec, config, keylime_logging, secure_mount, tpm_ek_ca",
            "from keylime.agentstates import TPMClockInfo",
            "from keylime.common import algorithms, retry",
            "from keylime.failure import Component, Failure",
            "from keylime.tpm import tpm2_objects, tpm_abstract",
            "",
            "logger = keylime_logging.init_logging(\"tpm\")",
            "",
            "",
            "def _get_cmd_env():",
            "    env = os.environ.copy()",
            "    if \"TPM2TOOLS_TCTI\" not in env:",
            "        # Don't clobber existing setting (if present)",
            "        env[\"TPM2TOOLS_TCTI\"] = \"device:/dev/tpmrm0\"",
            "        # env['TPM2TOOLS_TCTI'] = 'tabrmd:bus_name=com.intel.tss2.Tabrmd'",
            "        # Other (not recommended) options are direct emulator and chardev communications:",
            "        # env['TPM2TOOLS_TCTI'] = 'mssim:port=2321'",
            "        # env['TPM2TOOLS_TCTI'] = 'device:/dev/tpm0'",
            "    return env",
            "",
            "",
            "class tpm(tpm_abstract.AbstractTPM):",
            "    VERSION = 2",
            "    tools_version = \"\"",
            "",
            "    def __init__(self, need_hw_tpm=False):",
            "        tpm_abstract.AbstractTPM.__init__(self, need_hw_tpm)",
            "",
            "        # Shared lock to serialize access to tools",
            "        self.tpmutilLock = threading.Lock()",
            "",
            "        self.__get_tpm2_tools()",
            "",
            "    def __get_tpm2_tools(self):",
            "        retDict = self.__run([\"tpm2_startup\", \"--version\"])",
            "",
            "        code = retDict[\"code\"]",
            "        output = \"\".join(config.convert(retDict[\"retout\"]))",
            "        errout = \"\".join(config.convert(retDict[\"reterr\"]))",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            raise Exception(",
            "                \"Error establishing tpm2-tools version using TPM2_Startup: %s\" + str(code) + \": \" + str(errout)",
            "            )",
            "",
            "        # Extract the `version=\"x.x.x\"` from tools",
            "        version_str = re.search(r'version=\"([^\"]+)\"', output).group(1)",
            "        # Extract the full semver release number.",
            "        self.tools_version = version_str.split(\"-\")",
            "",
            "        if Version(self.tools_version[0]) >= Version(\"5.4\") or (",
            "            # Also mark first git version that introduces the change to the tpm2_eventlog format as 5.4",
            "            # See: https://github.com/tpm2-software/tpm2-tools/commit/c78d258b2588aee535fd17594ad2f5e808056373",
            "            Version(self.tools_version[0]) == Version(\"5.3\")",
            "            and len(self.tools_version) > 1",
            "            and int(self.tools_version[1]) >= 24",
            "        ):",
            "            logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])",
            "            self.tools_version = \"5.4\"",
            "        elif Version(self.tools_version[0]) >= Version(\"4.2\"):",
            "            logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])",
            "            self.tools_version = \"4.2\"",
            "        elif Version(self.tools_version[0]) >= Version(\"4.0.0\"):",
            "            logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])",
            "            self.tools_version = \"4.0\"",
            "        elif Version(self.tools_version[0]) >= Version(\"3.2.0\"):",
            "            logger.info(\"TPM2-TOOLS Version: %s\", self.tools_version[0])",
            "            self.tools_version = \"3.2\"",
            "        else:",
            "            logger.error(\"TPM2-TOOLS Version %s is not supported.\", self.tools_version[0])",
            "            sys.exit()",
            "",
            "    def __get_tpm_algorithms(self):",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run([\"tpm2_getcap\", \"-c\", \"algorithms\"])",
            "        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "            retDict = self.__run([\"tpm2_getcap\", \"algorithms\"])",
            "",
            "        output = config.convert(retDict[\"retout\"])",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            raise Exception(\"get_tpm_algorithms failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "        if self.tools_version == \"3.2\":",
            "            # output, human-readable -> json",
            "            output = \"\".join(output)",
            "            output = re.sub(r\"TPMA_ALGORITHM for ALG_ID: 0x[0-9a-f]+\\s+-\\s+([a-z0-9_]+)\", r\"\\1:\", output)",
            "            output = output.replace(\"set\", \"1\")",
            "            output = output.replace(\"clear\", \"0\")",
            "            output = [output]",
            "",
            "        retyaml = config.yaml_to_dict(output, logger=logger)",
            "        if retyaml is None:",
            "            logger.warning(\"Could not read YAML output of tpm2_getcap.\")",
            "            return",
            "        for algorithm, details in retyaml.items():",
            "            if details[\"asymmetric\"] == 1 and details[\"object\"] == 1 and algorithms.Encrypt.is_recognized(algorithm):",
            "                self.supported[\"encrypt\"].add(algorithm)",
            "            elif details[\"hash\"] == 1 and algorithms.Hash.is_recognized(algorithm):",
            "                self.supported[\"hash\"].add(algorithm)",
            "            elif details[\"asymmetric\"] == 1 and details[\"signing\"] == 1 and algorithms.Sign.is_recognized(algorithm):",
            "                self.supported[\"sign\"].add(algorithm)",
            "",
            "    def __get_pcrs(self):",
            "        \"\"\"Gets which PCRs are enabled with which hash algorithm\"\"\"",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run([\"tpm2_getcap\", \"-c\", \"pcrs\"])",
            "        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "            retDict = self.__run([\"tpm2_getcap\", \"pcrs\"])",
            "",
            "        output = config.convert(retDict[\"retout\"])",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            raise Exception(\"get_tpm_algorithms failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "        retyaml = config.yaml_to_dict(output, logger=logger)",
            "        pcrs = {}",
            "        if retyaml is None:",
            "            logger.warning(\"Could not read YAML output of tpm2_getcap.\")",
            "            return pcrs",
            "        if \"selected-pcrs\" in retyaml:",
            "            pcrs = collections.ChainMap(*retyaml[\"selected-pcrs\"])",
            "        return pcrs",
            "",
            "    def run(self, cmd):",
            "        return self.__run(cmd, lock=False)",
            "",
            "    def __run(",
            "        self, cmd, expectedcode=tpm_abstract.AbstractTPM.EXIT_SUCESS, raiseOnError=True, lock=True, outputpaths=None",
            "    ):",
            "        env = _get_cmd_env()",
            "",
            "        # Convert single outputpath to list",
            "        if isinstance(outputpaths, str):",
            "            outputpaths = [outputpaths]",
            "",
            "        numtries = 0",
            "        while True:",
            "            if lock:",
            "                with self.tpmutilLock:",
            "                    retDict = cmd_exec.run(",
            "                        cmd=cmd, expectedcode=expectedcode, raiseOnError=False, outputpaths=outputpaths, env=env",
            "                    )",
            "            else:",
            "                retDict = cmd_exec.run(",
            "                    cmd=cmd, expectedcode=expectedcode, raiseOnError=False, outputpaths=outputpaths, env=env",
            "                )",
            "            code = retDict[\"code\"]",
            "            retout = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "",
            "            # keep trying to get quote if a PCR race condition occurred in quote",
            "            if cmd[0] == \"tpm2_quote\" and cmd_exec.list_contains_substring(",
            "                reterr, \"Error validating calculated PCR composite with quote\"",
            "            ):",
            "                numtries += 1",
            "                maxr = config.getint(\"agent\", \"max_retries\")",
            "                if numtries >= maxr:",
            "                    logger.error(\"Agent did not return proper quote due to PCR race condition.\")",
            "                    break",
            "                interval = config.getfloat(\"agent\", \"retry_interval\")",
            "                exponential_backoff = config.getboolean(\"agent\", \"exponential_backoff\")",
            "                next_retry = retry.retry_time(exponential_backoff, interval, numtries, logger)",
            "                logger.info(",
            "                    \"Failed to get quote %d/%d times, trying again in %f seconds...\", numtries, maxr, next_retry",
            "                )",
            "                time.sleep(next_retry)",
            "                continue",
            "",
            "            break",
            "",
            "        # Don't bother continuing if TPM call failed and we're raising on error",
            "        if code != expectedcode and raiseOnError:",
            "            raise Exception(",
            "                f\"Command: {cmd} returned {code}, expected {expectedcode}, output {retout}, stderr {reterr}\"",
            "            )",
            "",
            "        return retDict",
            "",
            "    # tpm_initialize",
            "    def __startup_tpm(self):",
            "        retDict = self.__run([\"tpm2_startup\", \"-c\"])",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            raise Exception(\"Error initializing emulated TPM with TPM2_Startup: %s\" + str(code) + \": \" + str(errout))",
            "",
            "    def __create_ek(self, asym_alg=None):",
            "        # this function is intended to be idempotent",
            "        if asym_alg is None:",
            "            asym_alg = self.defaults[\"encrypt\"]",
            "",
            "        current_handle = self.get_tpm_metadata(\"ek_handle\")",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "",
            "        # clear out old handle before starting again (give idempotence)",
            "        if current_handle is not None and owner_pw is not None:",
            "            logger.info(\"Flushing old ek handle: %s\", hex(current_handle))",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"], raiseOnError=False)",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"], raiseOnError=False)",
            "            output = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_getcap failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "            outjson = config.yaml_to_dict(output, logger=logger)",
            "            if outjson is not None and hex(current_handle) in outjson:",
            "                if self.tools_version == \"3.2\":",
            "                    cmd = [\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(current_handle), \"-P\", owner_pw]",
            "                    retDict = self.__run(cmd, raiseOnError=False)",
            "                elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                    cmd = [\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", hex(current_handle), \"-P\", owner_pw]",
            "                    retDict = self.__run(cmd, raiseOnError=False)",
            "                output = retDict[\"retout\"]",
            "                reterr = retDict[\"reterr\"]",
            "                code = retDict[\"code\"]",
            "",
            "                if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                    logger.info(",
            "                        \"Failed to flush old ek handle: %s.  Code %s: %s\", hex(current_handle), str(code), str(reterr)",
            "                    )",
            "",
            "                self._set_tpm_metadata(\"ek_handle\", None)",
            "                self._set_tpm_metadata(\"ek_tpm\", None)",
            "                self._set_tpm_metadata(\"ek_pw\", None)",
            "",
            "        # make sure an ownership pw is set",
            "        if owner_pw is None:",
            "            owner_pw = tpm_abstract.TPM_Utilities.random_password(20)",
            "            self._set_tpm_metadata(\"owner_pw\", owner_pw)",
            "        ek_pw = tpm_abstract.TPM_Utilities.random_password(20)",
            "",
            "        # create a new ek",
            "        with tempfile.NamedTemporaryFile() as tmppath:",
            "            # TODO(kaifeng) Missing else here for other versions",
            "            if self.tools_version == \"3.2\":",
            "                command = [",
            "                    \"tpm2_getpubek\",",
            "                    \"-H\",",
            "                    \"0x81010007\",",
            "                    \"-g\",",
            "                    asym_alg,",
            "                    \"-f\",",
            "                    tmppath.name,",
            "                    \"-P\",",
            "                    ek_pw,",
            "                    \"-o\",",
            "                    owner_pw,",
            "                    \"-e\",",
            "                    owner_pw,",
            "                ]",
            "            elif self.tools_version == \"4.0\":",
            "                command = [",
            "                    \"tpm2_createek\",",
            "                    \"-c\",",
            "                    \"-\",",
            "                    \"-G\",",
            "                    asym_alg,",
            "                    \"-u\",",
            "                    tmppath.name,",
            "                    \"-p\",",
            "                    ek_pw,",
            "                    \"-w\",",
            "                    owner_pw,",
            "                    \"-P\",",
            "                    owner_pw,",
            "                ]",
            "            elif self.tools_version == \"4.2\":",
            "                command = [",
            "                    \"tpm2_createek\",",
            "                    \"-c\",",
            "                    \"-\",",
            "                    \"-G\",",
            "                    asym_alg,",
            "                    \"-u\",",
            "                    tmppath.name,",
            "                    \"-w\",",
            "                    owner_pw,",
            "                    \"-P\",",
            "                    owner_pw,",
            "                ]",
            "",
            "            retDict = self.__run(command, raiseOnError=False, outputpaths=tmppath.name)",
            "            output = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "            ek_tpm = retDict[\"fileouts\"][tmppath.name]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"createek failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "            if self.tools_version == \"3.2\":",
            "                handle = int(0x81010007)",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                handle = None",
            "                retyaml = config.yaml_to_dict(output, logger=logger)",
            "                if retyaml is None:",
            "                    raise Exception(\"Could not read YAML output of tpm2_createek.\")",
            "                if \"persistent-handle\" in retyaml:",
            "                    handle = retyaml[\"persistent-handle\"]",
            "",
            "            # Make sure that all transient objects are flushed",
            "            self.__run([\"tpm2_flushcontext\", \"-t\"], raiseOnError=False)",
            "",
            "            self._set_tpm_metadata(\"ek_handle\", handle)",
            "            self._set_tpm_metadata(\"ek_pw\", ek_pw)",
            "            self._set_tpm_metadata(\"ek_tpm\", base64.b64encode(ek_tpm))",
            "            self._set_tpm_metadata(\"ek_alg\", asym_alg)",
            "",
            "    def __use_ek(self, ek_handle, config_pw):",
            "        ek_handle = int(ek_handle, 16)",
            "        logger.info(\"Using an already created ek with handle: %s\", hex(ek_handle))",
            "",
            "        self._set_tpm_metadata(\"owner_pw\", config_pw)",
            "",
            "        with tempfile.NamedTemporaryFile() as tmppath:",
            "            if self.tools_version == \"3.2\":",
            "                cmd = [\"tpm2_readpublic\", \"-H\", hex(ek_handle), \"-o\", tmppath.name, \"-f\", \"tss\"]",
            "                retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                cmd = [\"tpm2_readpublic\", \"-c\", hex(ek_handle), \"-o\", tmppath.name, \"-f\", \"tss\"]",
            "                retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)",
            "",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "            ek_tpm = retDict[\"fileouts\"][tmppath.name]",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_readpublic failed with code \" + str(code) + \": \" + str(reterr))",
            "            self._set_tpm_metadata(\"ek_tpm\", base64.b64encode(ek_tpm))",
            "",
            "        self._set_tpm_metadata(\"ek_handle\", int(ek_handle))",
            "",
            "    def __take_ownership(self, config_pw):",
            "        # if no ownerpassword",
            "        if config_pw == \"generate\":",
            "            logger.info(\"Generating random TPM owner password\")",
            "            owner_pw = tpm_abstract.TPM_Utilities.random_password(20)",
            "        else:",
            "            logger.info(\"Taking ownership with config provided TPM owner password\")",
            "            owner_pw = config_pw",
            "",
            "        logger.debug(\"Removing all saved sessions from TPM\")",
            "        retDict = self.__run([\"tpm2_flushcontext\", \"-s\"], raiseOnError=False)",
            "",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run([\"tpm2_takeownership\", \"-c\"], raiseOnError=False)",
            "            retDict = self.__run([\"tpm2_takeownership\", \"-o\", owner_pw, \"-e\", owner_pw], raiseOnError=False)",
            "        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "            retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"o\", owner_pw], raiseOnError=False)",
            "            retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"e\", owner_pw], raiseOnError=False)",
            "",
            "        code = retDict[\"code\"]",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            # if we fail, see if already owned with this pw",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run(",
            "                    [\"tpm2_takeownership\", \"-o\", owner_pw, \"-e\", owner_pw, \"-O\", owner_pw, \"-E\", owner_pw],",
            "                    raiseOnError=False,",
            "                )",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"o\", \"-p\", owner_pw, owner_pw], raiseOnError=False)",
            "                retDict = self.__run([\"tpm2_changeauth\", \"-c\", \"e\", \"-p\", owner_pw, owner_pw], raiseOnError=False)",
            "",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                # ut-oh, already owned but not with provided pw!",
            "                raise Exception(\"Owner password unknown, TPM reset required. Code %s\" + str(code) + \": \" + str(reterr))",
            "",
            "        self._set_tpm_metadata(\"owner_pw\", owner_pw)",
            "        logger.info(\"TPM Owner password confirmed: %s\", owner_pw)",
            "",
            "    def __get_pub_ek(self):  # assumes that owner_pw is correct at this point",
            "        handle = self.get_tpm_metadata(\"ek_handle\")",
            "        if handle is None:",
            "            raise Exception(\"create_ek has not been run yet?\")",
            "        # make a temp file for the output",
            "        with tempfile.NamedTemporaryFile() as tmppath:",
            "            # generates pubek.pem",
            "            if self.tools_version == \"3.2\":",
            "                cmd = [\"tpm2_readpublic\", \"-H\", hex(handle), \"-o\", tmppath.name]",
            "                retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                cmd = [\"tpm2_readpublic\", \"-c\", hex(handle), \"-o\", tmppath.name]",
            "                retDict = self.__run(cmd, raiseOnError=False, outputpaths=tmppath.name)",
            "",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "            ek = retDict[\"fileouts\"][tmppath.name]",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_readpublic failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "        self._set_tpm_metadata(\"ek_tpm\", base64.b64encode(ek))",
            "",
            "    def __create_aik(self, asym_alg=None, hash_alg=None, sign_alg=None):",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"]",
            "        if asym_alg is None:",
            "            asym_alg = self.defaults[\"encrypt\"]",
            "        if sign_alg is None:",
            "            sign_alg = self.defaults[\"sign\"]",
            "",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "",
            "        # clear out old handle before starting again (give idempotence)",
            "        if self.get_tpm_metadata(\"aik_handle\") is not None:",
            "            aik_handle = self.get_tpm_metadata(\"aik_handle\")",
            "            if self.tools_version == \"3.2\":",
            "                logger.info(\"Flushing old ak handle: %s\", hex(aik_handle))",
            "                retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"], raiseOnError=False)",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                logger.info(\"Flushing old ak handle: %s\", aik_handle)",
            "                retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"], raiseOnError=False)",
            "            output = config.convert(retDict[\"retout\"])",
            "            errout = config.convert(retDict[\"reterr\"])",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_getcap failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "            if self.tools_version == \"3.2\":",
            "                # output, human-readable -> json",
            "                output = \"\".join(output)",
            "                output = output.replace(\"0x\", \" - 0x\")",
            "                output = [output]",
            "",
            "            outjson = config.yaml_to_dict(output, logger=logger)",
            "            if self.tools_version == \"3.2\":",
            "                evict_it = outjson is not None and aik_handle in outjson",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                evict_it = os.path.exists(aik_handle)",
            "            if evict_it:",
            "                if self.tools_version == \"3.2\":",
            "                    cmd = [\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(aik_handle), \"-P\", owner_pw]",
            "                    retDict = self.__run(cmd, raiseOnError=False)",
            "                elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                    cmd = [\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", aik_handle, \"-P\", owner_pw]",
            "                    retDict = self.__run(cmd, raiseOnError=False)",
            "                    os.remove(aik_handle)",
            "",
            "                output = retDict[\"retout\"]",
            "                reterr = retDict[\"reterr\"]",
            "                code = retDict[\"code\"]",
            "",
            "                if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                    if self.tools_version == \"3.2\":",
            "                        logger.info(",
            "                            \"Failed to flush old ak handle: %s.  Code %s: %s\", hex(aik_handle), str(code), str(reterr)",
            "                        )",
            "                    elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                        logger.info(",
            "                            \"Failed to flush old ak handle: %s.  Code %s: %s\", aik_handle, str(code), str(reterr)",
            "                        )",
            "",
            "                self._set_tpm_metadata(\"aik_pw\", None)",
            "                self._set_tpm_metadata(\"aik_tpm\", None)",
            "                self._set_tpm_metadata(\"aik_handle\", None)",
            "",
            "        logger.debug(\"Creating a new AIK identity\")",
            "",
            "        # We need an ek handle to make an aik",
            "        ek_handle = self.get_tpm_metadata(\"ek_handle\")",
            "        if ek_handle is None:",
            "            raise Exception(\"Failed to create AIK, since EK has not yet been created!\")",
            "",
            "        aik_pw = tpm_abstract.TPM_Utilities.random_password(20)",
            "        # make a temp file for the output",
            "        with tempfile.NamedTemporaryFile() as akpubfile:",
            "            secpath = \"\"",
            "            if self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                # ok lets write out the key now",
            "                secdir = secure_mount.mount()  # confirm that storage is still securely mounted",
            "                secfd, secpath = tempfile.mkstemp(dir=secdir)",
            "",
            "            if self.tools_version == \"3.2\":",
            "                command = [",
            "                    \"tpm2_getpubak\",",
            "                    \"-E\",",
            "                    hex(ek_handle),",
            "                    \"-k\",",
            "                    \"0x81010008\",",
            "                    \"-g\",",
            "                    asym_alg,",
            "                    \"-D\",",
            "                    hash_alg,",
            "                    \"-s\",",
            "                    sign_alg,",
            "                    \"-f\",",
            "                    akpubfile.name,",
            "                    \"-e\",",
            "                    owner_pw,",
            "                    \"-P\",",
            "                    aik_pw,",
            "                    \"-o\",",
            "                    owner_pw,",
            "                ]",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                command = [",
            "                    \"tpm2_createak\",",
            "                    \"-C\",",
            "                    hex(ek_handle),",
            "                    \"-c\",",
            "                    secpath,",
            "                    \"-G\",",
            "                    asym_alg,",
            "                    \"-g\",",
            "                    hash_alg,",
            "                    \"-s\",",
            "                    sign_alg,",
            "                    \"-u\",",
            "                    akpubfile.name,",
            "                    \"-p\",",
            "                    aik_pw,",
            "                    \"-P\",",
            "                    owner_pw,",
            "                ]",
            "            retDict = self.__run(command, outputpaths=akpubfile.name)",
            "            if secfd >= 0:",
            "                os.close(secfd)",
            "            retout = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_createak failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "            jsonout = config.yaml_to_dict(retout, logger=logger)",
            "            if jsonout is None:",
            "                raise Exception(",
            "                    \"unable to parse YAML output of tpm2_createak. Is your tpm2-tools installation up to date?\"",
            "                )",
            "            aik_tpm = retDict[\"fileouts\"][akpubfile.name]",
            "            if aik_tpm == \"\":",
            "                raise Exception(",
            "                    \"unable to read public aik from create identity.  Is your tpm2-tools installation up to date?\"",
            "                )",
            "            self._set_tpm_metadata(\"aik_tpm\", base64.b64encode(aik_tpm))",
            "",
            "        if self.tools_version == \"3.2\":",
            "            if \"loaded-key\" not in jsonout or \"name\" not in jsonout[\"loaded-key\"]:",
            "                raise Exception(\"tpm2_createak failed to create aik: return \" + str(reterr))",
            "",
            "            handle = int(0x81010008)",
            "",
            "            # get and persist the pem (not returned by tpm2_getpubak)",
            "            self._set_tpm_metadata(\"aik_handle\", handle)",
            "        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "            if \"loaded-key\" not in jsonout:",
            "                raise Exception(\"tpm2_createak failed to create aik: return \" + str(reterr))",
            "",
            "            handle = secpath",
            "",
            "            # persist the pem",
            "            self._set_tpm_metadata(\"aik_handle\", handle)",
            "",
            "        # Make sure that all transient objects are flushed",
            "        self.__run([\"tpm2_flushcontext\", \"-t\"], raiseOnError=False)",
            "",
            "        # persist common results",
            "        self._set_tpm_metadata(\"aik_pw\", aik_pw)",
            "",
            "    def flush_keys(self):",
            "        logger.debug(\"Flushing keys from TPM...\")",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run([\"tpm2_getcap\", \"-c\", \"handles-persistent\"])",
            "        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "            retDict = self.__run([\"tpm2_getcap\", \"handles-persistent\"])",
            "        # retout = retDict['retout']",
            "        retout = config.convert(retDict[\"retout\"])",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            logger.debug(\"tpm2_getcap failed with code %s: %s\", str(code), str(errout))",
            "",
            "        if self.tools_version == \"3.2\":",
            "            # output, human-readable -> json",
            "            retout = \"\".join(retout)",
            "            retout = retout.replace(\"0x\", \" - 0x\")",
            "            retout = [retout]",
            "",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "        jsonout = config.yaml_to_dict(retout, logger=logger)",
            "        if jsonout is None:",
            "            logger.warning(\"Could not read YAML output of tpm2_getcap.\")",
            "            jsonout = {}",
            "        for key in jsonout:",
            "            if str(hex(key)) != self.defaults[\"ek_handle\"]:",
            "                logger.debug(\"Flushing key handle %s\", hex(key))",
            "                if self.tools_version == \"3.2\":",
            "                    self.__run([\"tpm2_evictcontrol\", \"-A\", \"o\", \"-H\", hex(key), \"-P\", owner_pw], raiseOnError=False)",
            "                elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                    self.__run([\"tpm2_evictcontrol\", \"-C\", \"o\", \"-c\", hex(key), \"-P\", owner_pw], raiseOnError=False)",
            "        # Make sure that all transient objects are flushed",
            "        self.__run([\"tpm2_flushcontext\", \"-t\"], lock=False, raiseOnError=False)",
            "",
            "    def encryptAIK(self, uuid, ek_tpm: bytes, aik_tpm: bytes):",
            "",
            "        if ek_tpm is None or aik_tpm is None:",
            "            logger.error(\"Missing parameters for encryptAIK\")",
            "            return None",
            "",
            "        aik_name = tpm2_objects.get_tpm2b_public_name(aik_tpm)",
            "",
            "        efd = keyfd = blobfd = -1",
            "        ekFile = None",
            "        challengeFile = None",
            "        keyblob = None",
            "        blobpath = None",
            "",
            "        try:",
            "            # write out the public EK",
            "            efd, etemp = tempfile.mkstemp()",
            "            with open(etemp, \"wb\") as ekFile:",
            "                ekFile.write(ek_tpm)",
            "",
            "            # write out the challenge",
            "            challenge = tpm_abstract.TPM_Utilities.random_password(32)",
            "            challenge = challenge.encode()",
            "            keyfd, keypath = tempfile.mkstemp()",
            "            with open(keypath, \"wb\") as challengeFile:",
            "                challengeFile.write(challenge)",
            "",
            "            # create temp file for the blob",
            "            blobfd, blobpath = tempfile.mkstemp()",
            "            command = [",
            "                \"tpm2_makecredential\",",
            "                \"-T\",",
            "                \"none\",",
            "                \"-e\",",
            "                ekFile.name,",
            "                \"-s\",",
            "                challengeFile.name,",
            "                \"-n\",",
            "                aik_name,",
            "                \"-o\",",
            "                blobpath,",
            "            ]",
            "            self.__run(command, lock=False)",
            "",
            "            logger.info(\"Encrypting AIK for UUID %s\", uuid)",
            "",
            "            # read in the blob",
            "            with open(blobpath, \"rb\") as f:",
            "                keyblob = base64.b64encode(f.read())",
            "",
            "            # read in the aes key",
            "            key = base64.b64encode(challenge).decode(\"utf-8\")",
            "",
            "        except Exception as e:",
            "            logger.error(\"Error encrypting AIK: %s\", str(e))",
            "            logger.exception(e)",
            "            raise",
            "        finally:",
            "            for fd in [efd, keyfd, blobfd]:",
            "                if fd >= 0:",
            "                    os.close(fd)",
            "            for fi in [ekFile, challengeFile]:",
            "                if fi is not None:",
            "                    os.remove(fi.name)",
            "            if blobpath is not None:",
            "                os.remove(blobpath)",
            "",
            "        return (keyblob, key)",
            "",
            "    def activate_identity(self, keyblob):",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "        aik_keyhandle = self.get_tpm_metadata(\"aik_handle\")",
            "        ek_keyhandle = self.get_tpm_metadata(\"ek_handle\")",
            "",
            "        keyblobFile = None",
            "        secpath = None",
            "        secfd = -1",
            "        sesspath = None",
            "        sesspathfd = -1",
            "        try:",
            "            # write out key blob",
            "            kfd, ktemp = tempfile.mkstemp()",
            "            with open(ktemp, \"wb\") as keyblobFile:",
            "                # the below is a coroutine?",
            "                keyblobFile.write(base64.b64decode(keyblob))",
            "",
            "            os.close(kfd)",
            "",
            "            # ok lets write out the key now",
            "            secdir = secure_mount.mount()  # confirm that storage is still securely mounted",
            "",
            "            secfd, secpath = tempfile.mkstemp(dir=secdir)",
            "            sesspathfd, sesspath = tempfile.mkstemp(dir=secdir)",
            "",
            "            apw = self.get_tpm_metadata(\"aik_pw\")",
            "            if self.tools_version == \"3.2\":",
            "                command = [",
            "                    \"tpm2_activatecredential\",",
            "                    \"-H\",",
            "                    hex(aik_keyhandle),",
            "                    \"-k\",",
            "                    hex(ek_keyhandle),",
            "                    \"-f\",",
            "                    keyblobFile.name,",
            "                    \"-o\",",
            "                    secpath,",
            "                    \"-P\",",
            "                    apw,",
            "                    \"-e\",",
            "                    owner_pw,",
            "                ]",
            "                retDict = self.__run(command, outputpaths=secpath)",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                self.__run([\"tpm2_startauthsession\", \"--policy-session\", \"-S\", sesspath])",
            "                self.__run([\"tpm2_policysecret\", \"-S\", sesspath, \"-c\", \"0x4000000B\", owner_pw])",
            "                command = [",
            "                    \"tpm2_activatecredential\",",
            "                    \"-c\",",
            "                    aik_keyhandle,",
            "                    \"-C\",",
            "                    hex(ek_keyhandle),",
            "                    \"-i\",",
            "                    keyblobFile.name,",
            "                    \"-o\",",
            "                    secpath,",
            "                    \"-p\",",
            "                    apw,",
            "                    \"-P\",",
            "                    f\"session:{sesspath}\",",
            "                ]",
            "                retDict = self.__run(command, outputpaths=secpath)",
            "                self.__run([\"tpm2_flushcontext\", sesspath])",
            "",
            "            # Make sure that all transient objects are flushed",
            "            self.__run([\"tpm2_flushcontext\", \"-t\"], raiseOnError=False)",
            "",
            "            fileout = retDict[\"fileouts\"][secpath]",
            "            logger.info(\"AIK activated.\")",
            "",
            "            key = base64.b64encode(fileout)",
            "",
            "        except Exception as e:",
            "            logger.error(\"Error decrypting AIK: %s\", str(e))",
            "            logger.exception(e)",
            "            return None",
            "        finally:",
            "            if keyblobFile is not None:",
            "                os.remove(keyblobFile.name)",
            "            if secfd >= 0:",
            "                os.close(secfd)",
            "            if secpath is not None and os.path.exists(secpath):",
            "                os.remove(secpath)",
            "            if sesspathfd >= 0:",
            "                os.close(sesspathfd)",
            "            if sesspath is not None and os.path.exists(sesspath):",
            "                os.remove(sesspath)",
            "        return key",
            "",
            "    def verify_ek(self, ekcert):",
            "        \"\"\"Verify that the provided EK certificate is signed by a trusted root",
            "        :param ekcert: The Endorsement Key certificate in DER format",
            "        :returns: True if the certificate can be verified, false otherwise",
            "        \"\"\"",
            "        # openssl x509 -inform der -in certificate.cer -out certificate.pem",
            "        try:",
            "            tpm_ek_ca.check_tpm_cert_store()",
            "",
            "            ek509 = x509.load_der_x509_certificate(",
            "                data=ekcert,",
            "                backend=default_backend(),",
            "            )",
            "",
            "            trusted_certs = tpm_ek_ca.cert_loader()",
            "            for cert in trusted_certs:",
            "                signcert = x509.load_pem_x509_certificate(",
            "                    data=cert.encode(),",
            "                    backend=default_backend(),",
            "                )",
            "",
            "                if ek509.issuer.rfc4514_string() != signcert.subject.rfc4514_string():",
            "                    continue",
            "",
            "                try:",
            "                    signcert.public_key().verify(",
            "                        ek509.signature,",
            "                        ek509.tbs_certificate_bytes,",
            "                        padding.PKCS1v15(),",
            "                        ek509.signature_hash_algorithm,",
            "                    )",
            "                except crypto_exceptions.InvalidSignature:",
            "                    continue",
            "",
            "                logger.debug(\"EK cert matched cert: %s\", cert)",
            "                return True",
            "        except Exception as e:",
            "            # Log the exception so we don't lose the raw message",
            "            logger.exception(e)",
            "            raise Exception(\"Error processing ek/ekcert. Does this TPM have a valid EK?\").with_traceback(",
            "                sys.exc_info()[2]",
            "            )",
            "",
            "        logger.error(\"No Root CA matched EK Certificate\")",
            "        return False",
            "",
            "    def get_tpm_manufacturer(self, output=None):",
            "        vendorStr = None",
            "        if not output:",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run([\"tpm2_getcap\", \"-c\", \"properties-fixed\"])",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                retDict = self.__run([\"tpm2_getcap\", \"properties-fixed\"])",
            "            else:",
            "                raise Exception(f\"Unsupported tools version: {self.tools_version}\")",
            "",
            "            output = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"get_tpm_manufacturer failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "        # Clean up TPM manufacturer information (strip control characters)",
            "        # These strings are supposed to be printable ASCII characters, but",
            "        # some TPM manufacturers put control characters in here",
            "        #",
            "        # TPM manufacturer information can also contain un-escaped",
            "        # double quotes. Making sure that un-escaped quotes are",
            "        # replaced before attempting YAML parse.",
            "        def quoterepl(m):",
            "            return '\"' + m.group(0)[1:-1].replace('\"', '\\\\\"') + '\"'",
            "",
            "        for i, s in enumerate(output):",
            "            s1 = re.sub(r'(?!\".*\\\\\".*\")\".*\".*\"', quoterepl, s.decode(\"utf-8\"))",
            "            output[i] = re.sub(r\"[\\x01-\\x1F\\x7F]\", \"\", s1).encode(\"utf-8\")",
            "",
            "        retyaml = config.yaml_to_dict(output, logger=logger)",
            "        if retyaml is None:",
            "            raise Exception(\"Could not read YAML output of tpm2_getcap.\")",
            "        if \"TPM2_PT_VENDOR_STRING_1\" in retyaml:",
            "            vendorStr = retyaml[\"TPM2_PT_VENDOR_STRING_1\"][\"value\"]",
            "        elif \"TPM_PT_VENDOR_STRING_1\" in retyaml:",
            "            vendorStr = retyaml[\"TPM_PT_VENDOR_STRING_1\"][\"as string\"].strip()",
            "",
            "        return vendorStr",
            "",
            "    def is_emulator(self):",
            "        return self.get_tpm_manufacturer() == \"SW\"",
            "",
            "    def tpm_init(self, self_activate=False, config_pw=None):",
            "        # this was called tpm_initialize.init before",
            "        self.warn_emulator()",
            "",
            "        self.defaults[\"ek_handle\"] = config.get(\"agent\", \"ek_handle\")",
            "",
            "        if self.need_hw_tpm:",
            "            # We don't know which algs the TPM supports yet",
            "            self.supported[\"encrypt\"] = set()",
            "            self.supported[\"hash\"] = set()",
            "            self.supported[\"sign\"] = set()",
            "",
            "            # Grab which default algs the config requested",
            "            defaultHash = config.get(\"agent\", \"tpm_hash_alg\")",
            "            defaultEncrypt = config.get(\"agent\", \"tpm_encryption_alg\")",
            "            defaultSign = config.get(\"agent\", \"tpm_signing_alg\")",
            "",
            "            if self.defaults[\"ek_handle\"] == \"generate\":",
            "                # Start up the TPM",
            "                self.__startup_tpm()",
            "",
            "            # Figure out which algorithms the TPM supports",
            "            self.__get_tpm_algorithms()",
            "",
            "            # Ensure TPM supports the defaults requested",
            "            if defaultHash not in self.supported[\"hash\"]:",
            "                raise Exception(f\"Unsupported hash algorithm specified: {str(defaultHash)}!\")",
            "",
            "            if defaultEncrypt not in self.supported[\"encrypt\"]:",
            "                raise Exception(f\"Unsupported encryption algorithm specified: {str(defaultEncrypt)}!\")",
            "",
            "            if defaultSign not in self.supported[\"sign\"]:",
            "                raise Exception(f\"Unsupported signing algorithm specified: {str(defaultSign)}!\")",
            "",
            "            enabled_pcrs = self.__get_pcrs()",
            "            if not enabled_pcrs.get(str(defaultHash)):",
            "                raise Exception(f\"No PCR banks enabled for hash algorithm specified: {defaultHash}\")",
            "",
            "            self.defaults[\"hash\"] = algorithms.Hash(defaultHash)",
            "            self.defaults[\"encrypt\"] = defaultEncrypt",
            "            self.defaults[\"sign\"] = defaultSign",
            "",
            "        if self.defaults[\"ek_handle\"] == \"generate\":",
            "            self.__take_ownership(config_pw)",
            "            self.__create_ek()",
            "        else:",
            "            self.__use_ek(self.defaults[\"ek_handle\"], config_pw)",
            "",
            "        self.__get_pub_ek()",
            "",
            "        ekcert = self.read_ekcert_nvram()",
            "        self._set_tpm_metadata(\"ekcert\", ekcert)",
            "",
            "        # if no AIK created, then create one",
            "        self.__create_aik()",
            "",
            "        return self.get_tpm_metadata(\"ekcert\"), self.get_tpm_metadata(\"ek_tpm\"), self.get_tpm_metadata(\"aik_tpm\")",
            "",
            "    # tpm_quote",
            "    @staticmethod",
            "    def __pcr_mask_to_list(mask):",
            "        pcr_list = []",
            "        for pcr in range(24):",
            "            if tpm_abstract.TPM_Utilities.check_mask(mask, pcr):",
            "                pcr_list.append(str(pcr))",
            "        return \",\".join(pcr_list)",
            "",
            "    def create_quote(self, nonce, data=None, pcrmask=tpm_abstract.AbstractTPM.EMPTYMASK, hash_alg=None, compress=False):",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"]",
            "",
            "        quote = \"\"",
            "",
            "        with tempfile.NamedTemporaryFile() as quotepath, tempfile.NamedTemporaryFile() as sigpath, tempfile.NamedTemporaryFile() as pcrpath:",
            "            keyhandle = self.get_tpm_metadata(\"aik_handle\")",
            "            aik_pw = self.get_tpm_metadata(\"aik_pw\")",
            "",
            "            if pcrmask is None:",
            "                pcrmask = tpm_abstract.AbstractTPM.EMPTYMASK",
            "",
            "            if data is not None:",
            "                # add PCR 16 to pcrmask",
            "                pcrmask = hex(int(pcrmask, 0) | (1 << config.TPM_DATA_PCR))",
            "",
            "            pcrlist = self.__pcr_mask_to_list(pcrmask)",
            "",
            "            with self.tpmutilLock:",
            "                if data is not None:",
            "                    self.__run([\"tpm2_pcrreset\", str(config.TPM_DATA_PCR)], lock=False)",
            "                    self.extendPCR(pcrval=config.TPM_DATA_PCR, hashval=self.hashdigest(data), lock=False)",
            "",
            "                nonce = bytes(nonce, encoding=\"utf8\").hex()",
            "                if self.tools_version == \"3.2\":",
            "                    command = [",
            "                        \"tpm2_quote\",",
            "                        \"-k\",",
            "                        hex(keyhandle),",
            "                        \"-L\",",
            "                        f\"{str(hash_alg)}:{pcrlist}\",",
            "                        \"-q\",",
            "                        nonce,",
            "                        \"-m\",",
            "                        quotepath.name,",
            "                        \"-s\",",
            "                        sigpath.name,",
            "                        \"-p\",",
            "                        pcrpath.name,",
            "                        \"-G\",",
            "                        hash_alg,",
            "                        \"-P\",",
            "                        aik_pw,",
            "                    ]",
            "                elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                    command = [",
            "                        \"tpm2_quote\",",
            "                        \"-c\",",
            "                        keyhandle,",
            "                        \"-l\",",
            "                        f\"{str(hash_alg)}:{pcrlist}\",",
            "                        \"-q\",",
            "                        nonce,",
            "                        \"-m\",",
            "                        quotepath.name,",
            "                        \"-s\",",
            "                        sigpath.name,",
            "                        \"-o\",",
            "                        pcrpath.name,",
            "                        \"-g\",",
            "                        hash_alg,",
            "                        \"-p\",",
            "                        aik_pw,",
            "                    ]",
            "                retDict = self.__run(command, lock=False, outputpaths=[quotepath.name, sigpath.name, pcrpath.name])",
            "                # Make sure that all transient objects are flushed",
            "                self.__run([\"tpm2_flushcontext\", \"-t\"], lock=False, raiseOnError=False)",
            "                quoteraw = retDict[\"fileouts\"][quotepath.name]",
            "                sigraw = retDict[\"fileouts\"][sigpath.name]",
            "                pcrraw = retDict[\"fileouts\"][pcrpath.name]",
            "                if compress:",
            "                    quoteraw = zlib.compress(quoteraw)",
            "                    sigraw = zlib.compress(sigraw)",
            "                    pcrraw = zlib.compress(pcrraw)",
            "                quote_b64encode = base64.b64encode(quoteraw)",
            "                sigraw_b64encode = base64.b64encode(sigraw)",
            "                pcrraw_b64encode = base64.b64encode(pcrraw)",
            "                quote = (",
            "                    quote_b64encode.decode(\"utf-8\")",
            "                    + \":\"",
            "                    + sigraw_b64encode.decode(\"utf-8\")",
            "                    + \":\"",
            "                    + pcrraw_b64encode.decode(\"utf-8\")",
            "                )",
            "",
            "        return \"r\" + quote",
            "",
            "    def __tpm2_checkquote(self, pubaik, nonce, quoteFile, sigFile, pcrFile, hash_alg):",
            "        nonce = bytes(nonce, encoding=\"utf8\").hex()",
            "        if self.tools_version == \"3.2\":",
            "            command = [",
            "                \"tpm2_checkquote\",",
            "                \"-c\",",
            "                pubaik,",
            "                \"-m\",",
            "                quoteFile,",
            "                \"-s\",",
            "                sigFile,",
            "                \"-p\",",
            "                pcrFile,",
            "                \"-G\",",
            "                hash_alg,",
            "                \"-q\",",
            "                nonce,",
            "            ]",
            "        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "            command = [",
            "                \"tpm2_checkquote\",",
            "                \"-u\",",
            "                pubaik,",
            "                \"-m\",",
            "                quoteFile,",
            "                \"-s\",",
            "                sigFile,",
            "                \"-f\",",
            "                pcrFile,",
            "                \"-g\",",
            "                hash_alg,",
            "                \"-q\",",
            "                nonce,",
            "            ]",
            "        retDict = self.__run(command, lock=False)",
            "        return retDict",
            "",
            "    def __tpm2_printquote(self, quoteFile):",
            "        command = [\"tpm2_print\", \"-t\", \"TPMS_ATTEST\", quoteFile]",
            "        retDict = self.__run(command, lock=False)",
            "        return retDict",
            "",
            "    def _tpm2_printquote(self, quote, compressed):",
            "        \"\"\"Get TPM timestamp info from quote",
            "        :param quote: quote data in the format 'r<b64-compressed-quoteblob>:<b64-compressed-sigblob>:<b64-compressed-pcrblob>",
            "        :param compressed: if the quote data is compressed with zlib or not",
            "        :returns: Returns the 'retout' from running tpm2_print and True in case of success, None and False in case of error.",
            "        This function throws an Exception on bad input.",
            "        \"\"\"",
            "",
            "        if quote[0] != \"r\":",
            "            raise Exception(f\"Invalid quote type {quote[0]}\")",
            "        quote = quote[1:]",
            "",
            "        quote_tokens = quote.split(\":\")",
            "        if len(quote_tokens) < 3:",
            "            raise Exception(f\"Quote is not compound! {quote}\")",
            "",
            "        quoteblob = base64.b64decode(quote_tokens[0])",
            "",
            "        if compressed:",
            "            logger.warning(\"Decompressing quote data which is unsafe!\")",
            "            quoteblob = zlib.decompress(quoteblob)",
            "",
            "        qfd = -1",
            "        quoteFile = None",
            "",
            "        try:",
            "            # write out quote",
            "            qfd, qtemp = tempfile.mkstemp()",
            "            with open(qtemp, \"wb\") as quoteFile:",
            "                quoteFile.write(quoteblob)",
            "",
            "            retDict = self.__tpm2_printquote(quoteFile.name)",
            "            retout = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "        except Exception as e:",
            "            logger.error(\"Error printing quote: %s\", str(e))",
            "            logger.exception(e)",
            "            return None, False",
            "        finally:",
            "            for fd in [qfd]:",
            "                if fd >= 0:",
            "                    os.close(fd)",
            "            for fi in [quoteFile]:",
            "                if fi is not None:",
            "                    os.remove(fi.name)",
            "",
            "        if len(retout) < 1 or code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            logger.error(\"Failed to print quote info, output: %s\", reterr)",
            "            return None, False",
            "",
            "        return retout, True",
            "",
            "    def _tpm2_checkquote(self, aikTpmFromRegistrar, quote, nonce, hash_alg, compressed):",
            "        \"\"\"Write the files from data returned from tpm2_quote for running tpm2_checkquote",
            "        :param aikTpmFromRegistrar: AIK used to generate the quote and is needed for verifying it now.",
            "        :param quote: quote data in the format 'r<b64-compressed-quoteblob>:<b64-compressed-sigblob>:<b64-compressed-pcrblob>",
            "        :param nonce: nonce that was used to create the quote",
            "        :param hash_alg: the hash algorithm that was used",
            "        :param compressed: if the quote data is compressed with zlib or not",
            "        :returns: Returns the 'retout' from running tpm2_checkquote and True in case of success, None and False in case of error.",
            "        This function throws an Exception on bad input.",
            "        \"\"\"",
            "        aikFromRegistrar = tpm2_objects.pubkey_from_tpm2b_public(base64.b64decode(aikTpmFromRegistrar),).public_bytes(",
            "            crypto_serialization.Encoding.PEM,",
            "            crypto_serialization.PublicFormat.SubjectPublicKeyInfo,",
            "        )",
            "",
            "        if quote[0] != \"r\":",
            "            raise Exception(f\"Invalid quote type {quote[0]}\")",
            "        quote = quote[1:]",
            "",
            "        quote_tokens = quote.split(\":\")",
            "        if len(quote_tokens) < 3:",
            "            raise Exception(f\"Quote is not compound! {quote}\")",
            "",
            "        quoteblob = base64.b64decode(quote_tokens[0])",
            "        sigblob = base64.b64decode(quote_tokens[1])",
            "        pcrblob = base64.b64decode(quote_tokens[2])",
            "",
            "        if compressed:",
            "            logger.warning(\"Decompressing quote data which is unsafe!\")",
            "            quoteblob = zlib.decompress(quoteblob)",
            "            sigblob = zlib.decompress(sigblob)",
            "            pcrblob = zlib.decompress(pcrblob)",
            "",
            "        qfd = sfd = pfd = afd = -1",
            "        quoteFile = None",
            "        aikFile = None",
            "        sigFile = None",
            "        pcrFile = None",
            "",
            "        try:",
            "            # write out quote",
            "            qfd, qtemp = tempfile.mkstemp()",
            "            with open(qtemp, \"wb\") as quoteFile:",
            "                quoteFile.write(quoteblob)",
            "",
            "            # write out sig",
            "            sfd, stemp = tempfile.mkstemp()",
            "            with open(stemp, \"wb\") as sigFile:",
            "                sigFile.write(sigblob)",
            "",
            "            # write out pcr",
            "            pfd, ptemp = tempfile.mkstemp()",
            "            with open(ptemp, \"wb\") as pcrFile:",
            "                pcrFile.write(pcrblob)",
            "",
            "            afd, atemp = tempfile.mkstemp()",
            "            with open(atemp, \"wb\") as aikFile:",
            "                aikFile.write(aikFromRegistrar)",
            "",
            "            retDict = self.__tpm2_checkquote(aikFile.name, nonce, quoteFile.name, sigFile.name, pcrFile.name, hash_alg)",
            "            retout = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "        except Exception as e:",
            "            logger.error(\"Error verifying quote: %s\", str(e))",
            "            logger.exception(e)",
            "            return None, False",
            "        finally:",
            "            for fd in [qfd, sfd, pfd, afd]:",
            "                if fd >= 0:",
            "                    os.close(fd)",
            "            for fi in [aikFile, quoteFile, sigFile, pcrFile]:",
            "                if fi is not None:",
            "                    os.remove(fi.name)",
            "",
            "        if len(retout) < 1 or code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            logger.error(\"Failed to validate signature, output: %s\", reterr)",
            "            return None, False",
            "",
            "        return retout, True",
            "",
            "    def check_quote(",
            "        self,",
            "        agentAttestState,",
            "        nonce,",
            "        data,",
            "        quote,",
            "        aikTpmFromRegistrar,",
            "        tpm_policy=None,",
            "        ima_measurement_list=None,",
            "        allowlist=None,",
            "        hash_alg=None,",
            "        ima_keyrings=None,",
            "        mb_measurement_list=None,",
            "        mb_refstate=None,",
            "        compressed=False,",
            "    ) -> Failure:",
            "        if tpm_policy is None:",
            "            tpm_policy = {}",
            "        if allowlist is None:",
            "            allowlist = {}",
            "",
            "        agent_id = agentAttestState.agent_id",
            "",
            "        failure = Failure(Component.QUOTE_VALIDATION)",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"]",
            "",
            "        # First and foremost, the quote needs to be validated",
            "        retout, success = self._tpm2_checkquote(aikTpmFromRegistrar, quote, nonce, hash_alg, compressed)",
            "        if not success:",
            "            # If the quote validation fails we will skip all other steps therefore this failure is irrecoverable.",
            "            failure.add_event(",
            "                \"quote_validation\", {\"message\": \"Quote data validation using tpm2-tools\", \"data\": retout}, False",
            "            )",
            "            return failure",
            "",
            "        # Only after validating the quote, the TPM clock information can be extracted from it.",
            "        clock_failure, current_clock_info = self.check_quote_timing(agentAttestState.get_tpm_clockinfo(), quote)",
            "        if clock_failure:",
            "            failure.add_event(",
            "                \"quote_validation\",",
            "                {\"message\": \"Validation of clockinfo from quote using tpm2-tools\", \"data\": clock_failure},",
            "                False,",
            "            )",
            "            return failure",
            "        if current_clock_info:",
            "            agentAttestState.set_tpm_clockinfo(current_clock_info)",
            "",
            "        pcrs = []",
            "        jsonout = config.yaml_to_dict(retout, logger=logger)",
            "        if jsonout is None:",
            "            failure.add_event(",
            "                \"quote_validation\",",
            "                {\"message\": \"YAML parsing failed for quote validation using tpm2-tools.\", \"data\": retout},",
            "                False,",
            "            )",
            "            return failure",
            "        if \"pcrs\" in jsonout:",
            "            # The hash algorithm might be in the YAML output but does not contain any data, so we also check that.",
            "            if hash_alg in jsonout[\"pcrs\"] and jsonout[\"pcrs\"][hash_alg] is not None:",
            "                alg_size = hash_alg.get_size() // 4",
            "                for pcrval, hashval in jsonout[\"pcrs\"][hash_alg].items():",
            "                    pcrs.append(f\"PCR {pcrval} {hashval:0{alg_size}x}\")",
            "",
            "        if len(pcrs) == 0:",
            "            logger.warning(",
            "                \"Quote for agent %s does not contain any PCRs. Make sure that the TPM supports %s PCR banks\",",
            "                agent_id,",
            "                str(hash_alg),",
            "            )",
            "",
            "        return self.check_pcrs(",
            "            agentAttestState,",
            "            tpm_policy,",
            "            pcrs,",
            "            data,",
            "            False,",
            "            ima_measurement_list,",
            "            allowlist,",
            "            ima_keyrings,",
            "            mb_measurement_list,",
            "            mb_refstate,",
            "            hash_alg,",
            "        )",
            "",
            "    def check_quote_timing(self, previous_clockinfo, quote):",
            "        # Sanity check quote clock information",
            "",
            "        current_clockinfo = None",
            "",
            "        retout, success = self._tpm2_printquote(quote, False)",
            "        if not success:",
            "            return \"tpm2_print failed with \" + str(retout), current_clockinfo",
            "",
            "        tpm_data_str_dict = config.yaml_to_dict(retout, add_newlines=False, logger=logger)",
            "        if tpm_data_str_dict is None:",
            "            return \"yaml output of tpm2_print could not be parsed!\", current_clockinfo",
            "",
            "        tentative_current_clockinfo = TPMClockInfo.from_dict(tpm_data_str_dict)",
            "",
            "        resetdiff = tentative_current_clockinfo.resetcount - previous_clockinfo.resetcount",
            "        restartdiff = tentative_current_clockinfo.restartcount - previous_clockinfo.restartcount",
            "",
            "        if resetdiff < 0:",
            "            return \"resetCount value decreased on TPM between two consecutive quotes\", current_clockinfo",
            "",
            "        if restartdiff < 0:",
            "            return \"restartCount value decreased on TPM between two consecutive quotes\", current_clockinfo",
            "",
            "        if tentative_current_clockinfo.safe != 1:",
            "            return \"clock safe flag is disabled\", current_clockinfo",
            "",
            "        if not (resetdiff and restartdiff):",
            "            if tentative_current_clockinfo.clock - previous_clockinfo.clock <= 0:",
            "                return (",
            "                    \"clock timestamp did issued by TPM did not increase between two consecutive quotes\",",
            "                    current_clockinfo,",
            "                )",
            "",
            "            current_clockinfo = tentative_current_clockinfo",
            "",
            "        return None, current_clockinfo",
            "",
            "    def sim_extend(self, hashval_1, hashval_0=None, hash_alg=None):",
            "        # simulate extending a PCR value by performing TPM-specific extend procedure",
            "",
            "        if hashval_0 is None:",
            "            hashval_0 = self.START_HASH(hash_alg)",
            "",
            "        # compute expected value  H(0|H(data))",
            "        extendedval = self.hashdigest(",
            "            codecs.decode(hashval_0, \"hex_codec\")",
            "            + codecs.decode(self.hashdigest(hashval_1.encode(\"utf-8\"), hash_alg), \"hex_codec\"),",
            "            hash_alg,",
            "        ).lower()",
            "        return extendedval",
            "",
            "    def extendPCR(self, pcrval, hashval, hash_alg=None, lock=True):",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"].value",
            "",
            "        self.__run([\"tpm2_pcrextend\", f\"{pcrval}:{str(hash_alg)}={hashval}\"], lock=lock)",
            "",
            "    def readPCR(self, pcrval, hash_alg=None):",
            "        if hash_alg is None:",
            "            hash_alg = self.defaults[\"hash\"]",
            "        if self.tools_version == \"3.2\":",
            "            output = config.convert(self.__run(\"tpm2_pcrlist\")[\"retout\"])",
            "        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "            output = config.convert(self.__run(\"tpm2_pcrread\")[\"retout\"])",
            "",
            "        jsonout = config.yaml_to_dict(output, logger=logger)",
            "        if jsonout is None:",
            "            raise Exception(\"Could not read YAML output of tpm2_pcrread.\")",
            "",
            "        if hash_alg not in jsonout:",
            "            raise Exception(f\"Invalid hashing algorithm '{hash_alg}' for reading PCR number {pcrval}.\")",
            "",
            "        # alg_size = Hash_Algorithms.get_hash_size(hash_alg)/4",
            "        alg_size = hash_alg.get_size() // 4",
            "        return f\"{jsonout[hash_alg][pcrval]:0{alg_size}x}\"",
            "",
            "    # tpm_random",
            "    def _get_tpm_rand_block(self, size=32):",
            "        # make a temp file for the output",
            "        rand = None",
            "        with tempfile.NamedTemporaryFile() as randpath:",
            "            try:",
            "                command = [\"tpm2_getrandom\", \"-o\", randpath.name, str(size)]",
            "                retDict = self.__run(command, outputpaths=randpath.name)",
            "                rand = retDict[\"fileouts\"][randpath.name]",
            "            except Exception as e:",
            "                if not self.tpmrand_warned:",
            "                    logger.warning(\"TPM randomness not available: %s\", e)",
            "                    self.tpmrand_warned = True",
            "                return None",
            "        return rand",
            "",
            "    # tpm_nvram",
            "    def write_key_nvram(self, key):",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "",
            "        # write out quote",
            "        with tempfile.NamedTemporaryFile() as keyFile:",
            "            keyFile.write(key)",
            "            keyFile.flush()",
            "",
            "            attrs = \"ownerread|ownerwrite\"",
            "            # TODO(kaifeng) Escaping attrs is probably not required",
            "            if self.tools_version == \"3.2\":",
            "                self.__run(",
            "                    [",
            "                        \"tpm2_nvdefine\",",
            "                        \"-x\",",
            "                        \"0x1500018\",",
            "                        \"-a\",",
            "                        \"0x40000001\",",
            "                        \"-s\",",
            "                        str(config.BOOTSTRAP_KEY_SIZE),",
            "                        \"-t\",",
            "                        f'\"{attrs}\"',",
            "                        \"-I\",",
            "                        owner_pw,",
            "                        \"-P\",",
            "                        owner_pw,",
            "                    ],",
            "                    raiseOnError=False,",
            "                )",
            "                self.__run(",
            "                    [\"tpm2_nvwrite\", \"-x\", \"0x1500018\", \"-a\", \"0x40000001\", \"-P\", owner_pw, keyFile.name],",
            "                    raiseOnError=False,",
            "                )",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                self.__run(",
            "                    [",
            "                        \"tpm2_nvdefine\",",
            "                        \"0x1500018\",",
            "                        \"-C\",",
            "                        \"0x40000001\",",
            "                        \"-s\",",
            "                        str(config.BOOTSTRAP_KEY_SIZE),",
            "                        \"-a\",",
            "                        f'\"{attrs}\"',",
            "                        \"-p\",",
            "                        owner_pw,",
            "                        \"-P\",",
            "                        owner_pw,",
            "                    ],",
            "                    raiseOnError=False,",
            "                )",
            "                self.__run(",
            "                    [\"tpm2_nvwrite\", \"0x1500018\", \"-C\", \"0x40000001\", \"-P\", owner_pw, \"-i\", keyFile.name],",
            "                    raiseOnError=False,",
            "                )",
            "",
            "    def read_ekcert_nvram(self):",
            "        # make a temp file for the quote",
            "        with tempfile.NamedTemporaryFile() as nvpath:",
            "",
            "            # Check for RSA EK cert in NVRAM (and get length)",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run(\"tpm2_nvlist\", raiseOnError=False)",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                retDict = self.__run(\"tpm2_nvreadpublic\", raiseOnError=False)",
            "            output = retDict[\"retout\"]",
            "            reterr = retDict[\"reterr\"]",
            "            code = retDict[\"code\"]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                if self.tools_version == \"3.2\":",
            "                    raise Exception(\"tpm2_nvlist for ekcert failed with code \" + str(code) + \": \" + str(reterr))",
            "                if self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                    raise Exception(\"tpm2_nvreadpublic for ekcert failed with code \" + str(code) + \": \" + str(reterr))",
            "",
            "            outjson = config.yaml_to_dict(output, logger=logger)",
            "",
            "            if outjson is None or 0x1C00002 not in outjson or \"size\" not in outjson[0x1C00002]:",
            "                logger.warning(\"No EK certificate found in TPM NVRAM\")",
            "                return None",
            "",
            "            ekcert_size = str(outjson[0x1C00002][\"size\"])",
            "",
            "            # Read the RSA EK cert from NVRAM (DER format)",
            "            if self.tools_version == \"3.2\":",
            "                retDict = self.__run(",
            "                    [\"tpm2_nvread\", \"-x\", \"0x1c00002\", \"-s\", ekcert_size, \"-f\", nvpath.name, \"-a\", \"0x01c00002\"],",
            "                    raiseOnError=False,",
            "                    outputpaths=nvpath.name,",
            "                )",
            "            elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "                retDict = self.__run(",
            "                    [\"tpm2_nvread\", \"0x1c00002\", \"-s\", ekcert_size, \"-o\", nvpath.name],",
            "                    raiseOnError=False,",
            "                    outputpaths=nvpath.name,",
            "                )",
            "            output = config.convert(retDict[\"retout\"])",
            "            errout = config.convert(retDict[\"reterr\"])",
            "            code = retDict[\"code\"]",
            "            ekcert = retDict[\"fileouts\"][nvpath.name]",
            "",
            "            if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "                raise Exception(\"tpm2_nvread for ekcert failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "        return base64.b64encode(ekcert)",
            "",
            "    def read_key_nvram(self):",
            "        owner_pw = self.get_tpm_metadata(\"owner_pw\")",
            "        if self.tools_version == \"3.2\":",
            "            retDict = self.__run(",
            "                [",
            "                    \"tpm2_nvread\",",
            "                    \"-x\",",
            "                    \"0x1500018\",",
            "                    \"-a\",",
            "                    \"0x40000001\",",
            "                    \"-s\",",
            "                    str(config.BOOTSTRAP_KEY_SIZE),",
            "                    \"-P\",",
            "                    owner_pw,",
            "                ],",
            "                raiseOnError=False,",
            "            )",
            "        elif self.tools_version in [\"4.0\", \"4.2\", \"5.4\"]:",
            "            retDict = self.__run(",
            "                [\"tpm2_nvread\", \"0x1500018\", \"-C\", \"0x40000001\", \"-s\", str(config.BOOTSTRAP_KEY_SIZE), \"-P\", owner_pw],",
            "                raiseOnError=False,",
            "            )",
            "",
            "        output = retDict[\"retout\"]",
            "        errout = config.convert(retDict[\"reterr\"])",
            "        code = retDict[\"code\"]",
            "",
            "        if code != tpm_abstract.AbstractTPM.EXIT_SUCESS:",
            "            if len(errout) > 0 and \"handle does not exist\" in \"\\n\".join(errout):",
            "                logger.debug(\"No stored U in TPM NVRAM\")",
            "                return None",
            "            if len(errout) > 0 and \"ERROR: Failed to read NVRAM public area at index\" in \"\\n\".join(errout):",
            "                logger.debug(\"No stored U in TPM NVRAM\")",
            "                return None",
            "            if len(errout) > 0 and \"the handle is not correct for the use\" in \"\\n\".join(errout):",
            "                logger.debug(\"No stored U in TPM NVRAM\")",
            "                return None",
            "",
            "            raise Exception(\"nv_readvalue failed with code \" + str(code) + \": \" + str(errout))",
            "",
            "        if len(output) != config.BOOTSTRAP_KEY_SIZE:",
            "            logger.debug(\"Invalid key length from NVRAM: %d\", len(output))",
            "            return None",
            "        return output",
            "",
            "    @staticmethod",
            "    def __stringify_pcr_keys(log: dict) -> None:",
            "        \"\"\"Ensure that the PCR indices are strings",
            "",
            "        The YAML produced by `tpm2_eventlog`, when loaded by the yaml module,",
            "        uses integer keys in the dicts holding PCR contents.  That does not",
            "        correspond to any JSON data.  This method ensures those keys are",
            "        strings.",
            "        The log is untrusted because it ultimately comes from an untrusted",
            "        source and has been processed by software that has had bugs.\"\"\"",
            "        if (not isinstance(log, dict)) or \"pcrs\" not in log:",
            "            return",
            "        old_pcrs = log[\"pcrs\"]",
            "        if not isinstance(old_pcrs, dict):",
            "            return",
            "        new_pcrs = {}",
            "        for hash_alg, cells in old_pcrs.items():",
            "            if not isinstance(cells, dict):",
            "                new_pcrs[hash_alg] = cells",
            "                continue",
            "            new_pcrs[hash_alg] = {str(index): val for index, val in cells.items()}",
            "        log[\"pcrs\"] = new_pcrs",
            "        return",
            "",
            "    @staticmethod",
            "    def __add_boot_aggregate(log: dict) -> None:",
            "        \"\"\"Scan the boot event log and calculate possible boot aggregates.",
            "",
            "        Hashes are calculated for both sha1 and sha256,",
            "        as well as for 8 or 10 participant PCRs.",
            "",
            "        Technically the sha1/10PCR combination is unnecessary, since it has no",
            "        implementation.",
            "",
            "        Error conditions caused by improper string formatting etc. are",
            "        ignored. The current assumption is that the boot event log PCR",
            "        values are in decimal encoding, but this is liable to change.\"\"\"",
            "        if (not isinstance(log, dict)) or \"pcrs\" not in log:",
            "            return",
            "        log[\"boot_aggregates\"] = {}",
            "        for hashalg in log[\"pcrs\"].keys():",
            "            log[\"boot_aggregates\"][hashalg] = []",
            "            for maxpcr in [8, 10]:",
            "                try:",
            "                    hashclass = getattr(hashlib, hashalg)",
            "                    h = hashclass()",
            "                    for pcrno in range(0, maxpcr):",
            "                        pcrstrg = log[\"pcrs\"][hashalg][str(pcrno)]",
            "                        pcrhex = f\"{pcrstrg:0{h.digest_size*2}x}\"",
            "                        h.update(bytes.fromhex(pcrhex))",
            "                    log[\"boot_aggregates\"][hashalg].append(h.hexdigest())",
            "                except Exception:",
            "                    pass",
            "",
            "    @staticmethod",
            "    def __unescape_eventlog(log: dict):",
            "        \"\"\"",
            "        Newer versions of tpm2-tools escapes the YAML output and including the trailing null byte.",
            "        See: https://github.com/tpm2-software/tpm2-tools/commit/c78d258b2588aee535fd17594ad2f5e808056373",
            "        This converts it back to an unescaped string.",
            "        Example:",
            "            '\"MokList\\\\0\"' -> 'MokList'",
            "        \"\"\"",
            "        if tpm.tools_version in [\"3.2\", \"4.0\", \"4.2\"]:",
            "            return",
            "",
            "        escaped_chars = [",
            "            (\"\\0\", \"\\\\0\"),",
            "            (\"\\a\", \"\\\\a\"),",
            "            (\"\\b\", \"\\\\b\"),",
            "            (\"\\t\", \"\\\\t\"),",
            "            (\"\\v\", \"\\\\v\"),",
            "            (\"\\f\", \"\\\\f\"),",
            "            (\"\\r\", \"\\\\r\"),",
            "            (\"\\x1b\", \"\\\\e\"),",
            "            (\"'\", \"\\\\'\"),",
            "            (\"\\\\\", \"\\\\\\\\\"),",
            "        ]",
            "",
            "        def recursive_unescape(data):",
            "            if isinstance(data, str):",
            "                if data.startswith('\"') and data.endswith('\"'):",
            "                    data = data[1:-1]",
            "                    for orig, escaped in escaped_chars:",
            "                        data = data.replace(escaped, orig)",
            "                    data = data.rstrip(\"\\0\")",
            "            elif isinstance(data, dict):",
            "                for key, value in data.items():",
            "                    data[key] = recursive_unescape(value)",
            "            elif isinstance(data, list):",
            "                for pos, item in enumerate(data):",
            "                    data[pos] = recursive_unescape(item)",
            "            return data",
            "",
            "        recursive_unescape(log)",
            "",
            "    def parse_binary_bootlog(self, log_bin: bytes) -> typing.Tuple[Failure, typing.Optional[dict]]:",
            "        \"\"\"Parse and enrich a BIOS boot log",
            "",
            "        The input is the binary log.",
            "        The output is the result of parsing and applying other conveniences.\"\"\"",
            "        failure = Failure(Component.MEASURED_BOOT, [\"parser\"])",
            "        with tempfile.NamedTemporaryFile() as log_bin_file:",
            "            log_bin_file.write(log_bin)",
            "            log_bin_file.seek(0)",
            "            log_bin_filename = log_bin_file.name",
            "            try:",
            "                retDict_tpm2 = self.__run([\"tpm2_eventlog\", \"--eventlog-version=2\", log_bin_filename])",
            "            except Exception:",
            "                failure.add_event(\"tpm2_eventlog\", \"running tpm2_eventlog failed\", True)",
            "                return failure, None",
            "        log_parsed_strs = retDict_tpm2[\"retout\"]",
            "        if len(retDict_tpm2[\"reterr\"]) > 0:",
            "            failure.add_event(",
            "                \"tpm2_eventlog.warning\",",
            "                {\"context\": \"tpm2_eventlog exited with warnings\", \"data\": str(retDict_tpm2[\"reterr\"])},",
            "                True,",
            "            )",
            "            return failure, None",
            "        log_parsed_data = config.yaml_to_dict(log_parsed_strs, add_newlines=False, logger=logger)",
            "        if log_parsed_data is None:",
            "            failure.add_event(\"yaml\", \"yaml output of tpm2_eventlog could not be parsed!\", True)",
            "            return failure, None",
            "        # pylint: disable=import-outside-toplevel",
            "        try:",
            "            from keylime import tpm_bootlog_enrich",
            "        except Exception as e:",
            "            logger.error(\"Could not load tpm_bootlog_enrich (which depends on %s): %s\", config.LIBEFIVAR, str(e))",
            "            failure.add_event(",
            "                \"bootlog_enrich\",",
            "                f\"Could not load tpm_bootlog_enrich (which depends on {config.LIBEFIVAR}): {str(e)}\",",
            "                True,",
            "            )",
            "            return failure, None",
            "        # pylint: enable=import-outside-toplevel",
            "        tpm_bootlog_enrich.enrich(log_parsed_data)",
            "        tpm.__stringify_pcr_keys(log_parsed_data)",
            "        tpm.__add_boot_aggregate(log_parsed_data)",
            "        tpm.__unescape_eventlog(log_parsed_data)",
            "        return failure, log_parsed_data",
            "",
            "    def _parse_mb_bootlog(self, log_b64: str) -> typing.Tuple[Failure, typing.Optional[dict]]:",
            "        \"\"\"Parse and enrich a BIOS boot log",
            "",
            "        The input is the base64 encoding of a binary log.",
            "        The output is the result of parsing and applying other conveniences.\"\"\"",
            "        failure = Failure(Component.MEASURED_BOOT, [\"parser\"])",
            "        try:",
            "            log_bin = base64.b64decode(log_b64, validate=True)",
            "            failure_mb, result = self.parse_binary_bootlog(log_bin)",
            "            if failure_mb:",
            "                failure.merge(failure_mb)",
            "                result = None",
            "        except binascii.Error:",
            "            failure.add_event(\"log.base64decode\", \"Measured boot log could not be decoded\", True)",
            "            result = None",
            "        return failure, result",
            "",
            "    def parse_mb_bootlog(",
            "        self, mb_measurement_list: str, hash_alg: algorithms.Hash",
            "    ) -> typing.Tuple[dict, typing.Optional[dict], dict, Failure]:",
            "        \"\"\"Parse the measured boot log and return its object and the state of the PCRs",
            "        :param mb_measurement_list: The measured boot measurement list",
            "        :param hash_alg: the hash algorithm that should be used for the PCRs",
            "        :returns: Returns a map of the state of the PCRs, measured boot data object and True for success",
            "                  and False in case an error occurred",
            "        \"\"\"",
            "        failure = Failure(Component.MEASURED_BOOT, [\"parser\"])",
            "        if mb_measurement_list:",
            "            failure_mb, mb_measurement_data = self._parse_mb_bootlog(mb_measurement_list)",
            "            if not mb_measurement_data:",
            "                failure.merge(failure_mb)",
            "                logger.error(\"Unable to parse measured boot event log. Check previous messages for a reason for error.\")",
            "                return {}, None, {}, failure",
            "            log_pcrs = mb_measurement_data.get(\"pcrs\")",
            "            if not isinstance(log_pcrs, dict):",
            "                logger.error(\"Parse of measured boot event log has unexpected value for .pcrs: %r\", log_pcrs)",
            "                failure.add_event(\"invalid_pcrs\", {\"got\": log_pcrs}, True)",
            "                return {}, None, {}, failure",
            "            pcr_hashes = log_pcrs.get(str(hash_alg))",
            "            if (not isinstance(pcr_hashes, dict)) or not pcr_hashes:",
            "                logger.error(",
            "                    \"Parse of measured boot event log has unexpected value for .pcrs.%s: %r\", str(hash_alg), pcr_hashes",
            "                )",
            "                failure.add_event(\"invalid_pcrs_hashes\", {\"got\": pcr_hashes}, True)",
            "                return {}, None, {}, failure",
            "            boot_aggregates = mb_measurement_data.get(\"boot_aggregates\")",
            "            if (not isinstance(boot_aggregates, dict)) or not boot_aggregates:",
            "                logger.error(",
            "                    \"Parse of measured boot event log has unexpected value for .boot_aggragtes: %r\", boot_aggregates",
            "                )",
            "                failure.add_event(\"invalid_boot_aggregates\", {\"got\": boot_aggregates}, True)",
            "                return {}, None, {}, failure",
            "",
            "            return pcr_hashes, boot_aggregates, mb_measurement_data, failure",
            "",
            "        return {}, None, {}, failure"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "71": [
                "tpm",
                "__get_tpm2_tools"
            ],
            "87": [
                "tpm",
                "__get_tpm_algorithms"
            ],
            "121": [
                "tpm",
                "__get_pcrs"
            ],
            "216": [
                "tpm",
                "__create_ek"
            ],
            "230": [
                "tpm",
                "__create_ek"
            ],
            "313": [
                "tpm",
                "__create_ek"
            ],
            "339": [
                "tpm",
                "__use_ek"
            ],
            "367": [
                "tpm",
                "__take_ownership"
            ],
            "379": [
                "tpm",
                "__take_ownership"
            ],
            "402": [
                "tpm",
                "__get_pub_ek"
            ],
            "430": [
                "tpm",
                "__create_aik"
            ],
            "449": [
                "tpm",
                "__create_aik"
            ],
            "455": [
                "tpm",
                "__create_aik"
            ],
            "469": [
                "tpm",
                "__create_aik"
            ],
            "489": [
                "tpm",
                "__create_aik"
            ],
            "516": [
                "tpm",
                "__create_aik"
            ],
            "566": [
                "tpm",
                "__create_aik"
            ],
            "585": [
                "tpm",
                "flush_keys"
            ],
            "611": [
                "tpm",
                "flush_keys"
            ],
            "728": [
                "tpm",
                "activate_identity"
            ],
            "825": [
                "tpm",
                "get_tpm_manufacturer"
            ],
            "976": [
                "tpm",
                "create_quote"
            ],
            "1037": [
                "tpm",
                "__tpm2_checkquote"
            ],
            "1343": [
                "tpm",
                "readPCR"
            ],
            "1407": [
                "tpm",
                "write_key_nvram"
            ],
            "1437": [
                "tpm",
                "read_ekcert_nvram"
            ],
            "1446": [
                "tpm",
                "read_ekcert_nvram"
            ],
            "1464": [
                "tpm",
                "read_ekcert_nvram"
            ],
            "1497": [
                "tpm",
                "read_key_nvram"
            ]
        },
        "addLocation": []
    }
}