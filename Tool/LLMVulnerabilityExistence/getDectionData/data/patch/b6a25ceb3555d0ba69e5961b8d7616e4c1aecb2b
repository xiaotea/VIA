{
    "websockets/extensions/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     name = ..."
            },
            "2": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def decode(self, frame):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+    def decode(self, frame, *, max_size=None):"
            },
            "5": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         \"\"\""
            },
            "6": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         Decode an incoming frame."
            },
            "7": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "The :mod:`websockets.extensions.base` defines abstract classes for extensions.",
            "",
            "See https://tools.ietf.org/html/rfc6455#section-9.",
            "",
            "\"\"\"",
            "",
            "",
            "class ClientExtensionFactory:",
            "    \"\"\"",
            "    Abstract class for client-side extension factories.",
            "",
            "    Extension factories handle configuration and negotiation.",
            "",
            "    \"\"\"",
            "    name = ...",
            "",
            "    def get_request_params(self):",
            "        \"\"\"",
            "        Build request parameters.",
            "",
            "        Return a list of (name, value) pairs.",
            "",
            "        \"\"\"",
            "",
            "    def process_response_params(self, params, accepted_extensions):",
            "        \"\"\"\"",
            "        Process response parameters.",
            "",
            "        ``params`` are a list of (name, value) pairs.",
            "",
            "        ``accepted_extensions`` is a list of previously accepted extensions,",
            "        represented by extension instances.",
            "",
            "        Return an extension instance (an instance of a subclass of",
            "        :class:`Extension`) if these parameters are acceptable.",
            "",
            "        Raise :exc:`~websockets.exceptions.NegotiationError` if they aren't.",
            "",
            "        \"\"\"",
            "",
            "",
            "class ServerExtensionFactory:",
            "    \"\"\"",
            "    Abstract class for server-side extension factories.",
            "",
            "    Extension factories handle configuration and negotiation.",
            "",
            "    \"\"\"",
            "    name = ...",
            "",
            "    def process_request_params(self, params, accepted_extensions):",
            "        \"\"\"\"",
            "        Process request parameters.",
            "",
            "        ``accepted_extensions`` is a list of previously accepted extensions,",
            "        represented by extension instances.",
            "",
            "        Return response params (a list of (name, value) pairs) and an",
            "        extension instance (an instance of a subclass of :class:`Extension`)",
            "        to accept this extension.",
            "",
            "        Raise :exc:`~websockets.exceptions.NegotiationError` to reject it.",
            "",
            "        \"\"\"",
            "",
            "",
            "class Extension:",
            "    \"\"\"",
            "    Abstract class for extensions.",
            "",
            "    \"\"\"",
            "    name = ...",
            "",
            "    def decode(self, frame):",
            "        \"\"\"",
            "        Decode an incoming frame.",
            "",
            "        Return a frame.",
            "",
            "        \"\"\"",
            "",
            "    def encode(self, frame):",
            "        \"\"\"",
            "        Encode an outgoing frame.",
            "",
            "        Return a frame.",
            "",
            "        \"\"\""
        ],
        "afterPatchFile": [
            "\"\"\"",
            "The :mod:`websockets.extensions.base` defines abstract classes for extensions.",
            "",
            "See https://tools.ietf.org/html/rfc6455#section-9.",
            "",
            "\"\"\"",
            "",
            "",
            "class ClientExtensionFactory:",
            "    \"\"\"",
            "    Abstract class for client-side extension factories.",
            "",
            "    Extension factories handle configuration and negotiation.",
            "",
            "    \"\"\"",
            "    name = ...",
            "",
            "    def get_request_params(self):",
            "        \"\"\"",
            "        Build request parameters.",
            "",
            "        Return a list of (name, value) pairs.",
            "",
            "        \"\"\"",
            "",
            "    def process_response_params(self, params, accepted_extensions):",
            "        \"\"\"\"",
            "        Process response parameters.",
            "",
            "        ``params`` are a list of (name, value) pairs.",
            "",
            "        ``accepted_extensions`` is a list of previously accepted extensions,",
            "        represented by extension instances.",
            "",
            "        Return an extension instance (an instance of a subclass of",
            "        :class:`Extension`) if these parameters are acceptable.",
            "",
            "        Raise :exc:`~websockets.exceptions.NegotiationError` if they aren't.",
            "",
            "        \"\"\"",
            "",
            "",
            "class ServerExtensionFactory:",
            "    \"\"\"",
            "    Abstract class for server-side extension factories.",
            "",
            "    Extension factories handle configuration and negotiation.",
            "",
            "    \"\"\"",
            "    name = ...",
            "",
            "    def process_request_params(self, params, accepted_extensions):",
            "        \"\"\"\"",
            "        Process request parameters.",
            "",
            "        ``accepted_extensions`` is a list of previously accepted extensions,",
            "        represented by extension instances.",
            "",
            "        Return response params (a list of (name, value) pairs) and an",
            "        extension instance (an instance of a subclass of :class:`Extension`)",
            "        to accept this extension.",
            "",
            "        Raise :exc:`~websockets.exceptions.NegotiationError` to reject it.",
            "",
            "        \"\"\"",
            "",
            "",
            "class Extension:",
            "    \"\"\"",
            "    Abstract class for extensions.",
            "",
            "    \"\"\"",
            "    name = ...",
            "",
            "    def decode(self, frame, *, max_size=None):",
            "        \"\"\"",
            "        Decode an incoming frame.",
            "",
            "        Return a frame.",
            "",
            "        \"\"\"",
            "",
            "    def encode(self, frame):",
            "        \"\"\"",
            "        Encode an outgoing frame.",
            "",
            "        Return a frame.",
            "",
            "        \"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "75": [
                "Extension",
                "decode"
            ]
        },
        "addLocation": []
    },
    "websockets/extensions/permessage_deflate.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from ..exceptions import ("
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     DuplicateParameter, InvalidParameterName, InvalidParameterValue,"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    NegotiationError"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+    NegotiationError, PayloadTooBig"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " )"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from ..framing import CTRL_OPCODES, OP_CONT"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "                 self.local_max_window_bits),"
            },
            "9": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": 464,
                "PatchRowcode": "         ]))"
            },
            "10": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": 465,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def decode(self, frame):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+    def decode(self, frame, *, max_size=None):"
            },
            "13": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "         \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "         Decode an incoming frame."
            },
            "15": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": 469,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 495,
                "afterPatchRowNumber": 495,
                "PatchRowcode": "                 self.decoder = zlib.decompressobj("
            },
            "17": {
                "beforePatchRowNumber": 496,
                "afterPatchRowNumber": 496,
                "PatchRowcode": "                     wbits=-self.remote_max_window_bits)"
            },
            "18": {
                "beforePatchRowNumber": 497,
                "afterPatchRowNumber": 497,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Uncompress compressed frames."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+        # Uncompress compressed frames. Protect against zip bombs by"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 499,
                "PatchRowcode": "+        # preventing zlib from decompressing more than max_length bytes"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+        # (except when the limit is disabled with max_size = None)."
            },
            "23": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": 501,
                "PatchRowcode": "         data = frame.data"
            },
            "24": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": 502,
                "PatchRowcode": "         if frame.fin:"
            },
            "25": {
                "beforePatchRowNumber": 501,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "             data += _EMPTY_UNCOMPRESSED_BLOCK"
            },
            "26": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        data = self.decoder.decompress(data)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 504,
                "PatchRowcode": "+        max_length = 0 if max_size is None else max_size"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 505,
                "PatchRowcode": "+        data = self.decoder.decompress(data, max_length)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 506,
                "PatchRowcode": "+        if self.decoder.unconsumed_tail:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+            raise PayloadTooBig("
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 508,
                "PatchRowcode": "+                \"Uncompressed payload length exceeds size limit (? > {} bytes)\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+                .format(max_size))"
            },
            "33": {
                "beforePatchRowNumber": 503,
                "afterPatchRowNumber": 510,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 504,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "         # Allow garbage collection of the decoder if it won't be reused."
            },
            "35": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": 512,
                "PatchRowcode": "         if frame.fin and self.remote_no_context_takeover:"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "The :mod:`websockets.extensions.permessage_deflate` module implements the",
            "Compression Extensions for WebSocket as specified in :rfc:`7692`.",
            "",
            "\"\"\"",
            "",
            "import zlib",
            "",
            "from ..exceptions import (",
            "    DuplicateParameter, InvalidParameterName, InvalidParameterValue,",
            "    NegotiationError",
            ")",
            "from ..framing import CTRL_OPCODES, OP_CONT",
            "",
            "",
            "__all__ = [",
            "    'ClientPerMessageDeflateFactory',",
            "    'ServerPerMessageDeflateFactory',",
            "    'PerMessageDeflate',",
            "]",
            "",
            "_EMPTY_UNCOMPRESSED_BLOCK = b'\\x00\\x00\\xff\\xff'",
            "",
            "_MAX_WINDOW_BITS_VALUES = [str(bits) for bits in range(8, 16)]",
            "",
            "",
            "def _build_parameters(",
            "    server_no_context_takeover,",
            "    client_no_context_takeover,",
            "    server_max_window_bits,",
            "    client_max_window_bits,",
            "):",
            "    \"\"\"",
            "    Build a list of ``(name, value)`` pairs for some compression parameters.",
            "",
            "    \"\"\"",
            "    params = []",
            "    if server_no_context_takeover:",
            "        params.append(('server_no_context_takeover', None))",
            "    if client_no_context_takeover:",
            "        params.append(('client_no_context_takeover', None))",
            "    if server_max_window_bits:",
            "        params.append(('server_max_window_bits', str(server_max_window_bits)))",
            "    if client_max_window_bits is True:          # only in handshake requests",
            "        params.append(('client_max_window_bits', None))",
            "    elif client_max_window_bits:",
            "        params.append(('client_max_window_bits', str(client_max_window_bits)))",
            "    return params",
            "",
            "",
            "def _extract_parameters(params, *, is_server):",
            "    \"\"\"",
            "    Extract compression parameters from a list of ``(name, value)`` pairs.",
            "",
            "    If ``is_server`` is ``True``, ``client_max_window_bits`` may be provided",
            "    without a value. This is only allow in handshake requests.",
            "",
            "    \"\"\"",
            "    server_no_context_takeover = False",
            "    client_no_context_takeover = False",
            "    server_max_window_bits = None",
            "    client_max_window_bits = None",
            "",
            "    for name, value in params:",
            "",
            "        if name == 'server_no_context_takeover':",
            "            if server_no_context_takeover:",
            "                raise DuplicateParameter(name)",
            "            if value is None:",
            "                server_no_context_takeover = True",
            "            else:",
            "                raise InvalidParameterValue(name, value)",
            "",
            "        elif name == 'client_no_context_takeover':",
            "            if client_no_context_takeover:",
            "                raise DuplicateParameter(name)",
            "            if value is None:",
            "                client_no_context_takeover = True",
            "            else:",
            "                raise InvalidParameterValue(name, value)",
            "",
            "        elif name == 'server_max_window_bits':",
            "            if server_max_window_bits is not None:",
            "                raise DuplicateParameter(name)",
            "            if value in _MAX_WINDOW_BITS_VALUES:",
            "                server_max_window_bits = int(value)",
            "            else:",
            "                raise InvalidParameterValue(name, value)",
            "",
            "        elif name == 'client_max_window_bits':",
            "            if client_max_window_bits is not None:",
            "                raise DuplicateParameter(name)",
            "            if is_server and value is None:     # only in handshake requests",
            "                client_max_window_bits = True",
            "            elif value in _MAX_WINDOW_BITS_VALUES:",
            "                client_max_window_bits = int(value)",
            "            else:",
            "                raise InvalidParameterValue(name, value)",
            "",
            "        else:",
            "            raise InvalidParameterName(name)",
            "",
            "    return (",
            "        server_no_context_takeover,",
            "        client_no_context_takeover,",
            "        server_max_window_bits,",
            "        client_max_window_bits,",
            "    )",
            "",
            "",
            "class ClientPerMessageDeflateFactory:",
            "    \"\"\"",
            "    Client-side extension factory for permessage-deflate extension.",
            "",
            "    \"\"\"",
            "    name = 'permessage-deflate'",
            "",
            "    def __init__(",
            "        self,",
            "        server_no_context_takeover=False,",
            "        client_no_context_takeover=False,",
            "        server_max_window_bits=None,",
            "        client_max_window_bits=None,",
            "        compress_settings=None,",
            "    ):",
            "        \"\"\"",
            "        Configure permessage-deflate extension factory.",
            "",
            "        See https://tools.ietf.org/html/rfc7692#section-7.1.",
            "",
            "        \"\"\"",
            "        if not (server_max_window_bits is None or",
            "                8 <= server_max_window_bits <= 15):",
            "            raise ValueError(\"server_max_window_bits must be between 8 and 15\")",
            "        if not (client_max_window_bits is None or",
            "                client_max_window_bits is True or",
            "                8 <= client_max_window_bits <= 15):",
            "            raise ValueError(\"client_max_window_bits must be between 8 and 15\")",
            "        if compress_settings is not None and 'wbits' in compress_settings:",
            "            raise ValueError(\"compress_settings must not include wbits, \"",
            "                             \"set client_max_window_bits instead\")",
            "",
            "        self.server_no_context_takeover = server_no_context_takeover",
            "        self.client_no_context_takeover = client_no_context_takeover",
            "        self.server_max_window_bits = server_max_window_bits",
            "        self.client_max_window_bits = client_max_window_bits",
            "        self.compress_settings = compress_settings",
            "",
            "    def get_request_params(self):",
            "        \"\"\"",
            "        Build request parameters.",
            "",
            "        \"\"\"",
            "        return _build_parameters(",
            "            self.server_no_context_takeover, self.client_no_context_takeover,",
            "            self.server_max_window_bits, self.client_max_window_bits,",
            "        )",
            "",
            "    def process_response_params(self, params, accepted_extensions):",
            "        \"\"\"\"",
            "        Process response parameters.",
            "",
            "        Return an extension instance.",
            "",
            "        \"\"\"",
            "        if any(other.name == self.name for other in accepted_extensions):",
            "            raise NegotiationError(\"Received duplicate {}\".format(self.name))",
            "",
            "        # Request parameters are available in instance variables.",
            "",
            "        # Load response parameters in local variables.",
            "        (",
            "            server_no_context_takeover,",
            "            client_no_context_takeover,",
            "            server_max_window_bits,",
            "            client_max_window_bits,",
            "        ) = _extract_parameters(params, is_server=False)",
            "",
            "        # After comparing the request and the response, the final",
            "        # configuration must be available in the local variables.",
            "",
            "        # server_no_context_takeover",
            "        #",
            "        #   Req.    Resp.   Result",
            "        #   ------  ------  --------------------------------------------------",
            "        #   False   False   False",
            "        #   False   True    True",
            "        #   True    False   Error!",
            "        #   True    True    True",
            "",
            "        if self.server_no_context_takeover:",
            "            if not server_no_context_takeover:",
            "                raise NegotiationError(\"Expected server_no_context_takeover\")",
            "",
            "        # client_no_context_takeover",
            "        #",
            "        #   Req.    Resp.   Result",
            "        #   ------  ------  --------------------------------------------------",
            "        #   False   False   False",
            "        #   False   True    True",
            "        #   True    False   True - must change value",
            "        #   True    True    True",
            "",
            "        if self.client_no_context_takeover:",
            "            if not client_no_context_takeover:",
            "                client_no_context_takeover = True",
            "",
            "        # server_max_window_bits",
            "",
            "        #   Req.    Resp.   Result",
            "        #   ------  ------  --------------------------------------------------",
            "        #   None    None    None",
            "        #   None    8\u2264M\u226415  M",
            "        #   8\u2264N\u226415  None    Error!",
            "        #   8\u2264N\u226415  8\u2264M\u2264N   M",
            "        #   8\u2264N\u226415  N<M\u226415  Error!",
            "",
            "        if self.server_max_window_bits is None:",
            "            pass",
            "",
            "        else:",
            "            if server_max_window_bits is None:",
            "                raise NegotiationError(\"Expected server_max_window_bits\")",
            "            elif server_max_window_bits > self.server_max_window_bits:",
            "                raise NegotiationError(\"Unsupported server_max_window_bits\")",
            "",
            "        # client_max_window_bits",
            "",
            "        #   Req.    Resp.   Result",
            "        #   ------  ------  --------------------------------------------------",
            "        #   None    None    None",
            "        #   None    8\u2264M\u226415  Error!",
            "        #   True    None    None",
            "        #   True    8\u2264M\u226415  M",
            "        #   8\u2264N\u226415  None    N - must change value",
            "        #   8\u2264N\u226415  8\u2264M\u2264N   M",
            "        #   8\u2264N\u226415  N<M\u226415  Error!",
            "",
            "        if self.client_max_window_bits is None:",
            "            if client_max_window_bits is not None:",
            "                raise NegotiationError(\"Unexpected client_max_window_bits\")",
            "",
            "        elif self.client_max_window_bits is True:",
            "            pass",
            "",
            "        else:",
            "            if client_max_window_bits is None:",
            "                client_max_window_bits = self.client_max_window_bits",
            "            elif client_max_window_bits > self.client_max_window_bits:",
            "                raise NegotiationError(\"Unsupported client_max_window_bits\")",
            "",
            "        return PerMessageDeflate(",
            "            server_no_context_takeover,     # remote_no_context_takeover",
            "            client_no_context_takeover,     # local_no_context_takeover",
            "            server_max_window_bits or 15,   # remote_max_window_bits",
            "            client_max_window_bits or 15,   # local_max_window_bits",
            "            self.compress_settings,",
            "        )",
            "",
            "",
            "class ServerPerMessageDeflateFactory:",
            "    \"\"\"",
            "    Server-side extension factory for permessage-deflate extension.",
            "",
            "    \"\"\"",
            "    name = 'permessage-deflate'",
            "",
            "    def __init__(",
            "        self,",
            "        server_no_context_takeover=False,",
            "        client_no_context_takeover=False,",
            "        server_max_window_bits=None,",
            "        client_max_window_bits=None,",
            "        compress_settings=None,",
            "    ):",
            "        \"\"\"",
            "        Configure permessage-deflate extension factory.",
            "",
            "        See https://tools.ietf.org/html/rfc7692#section-7.1.",
            "",
            "        \"\"\"",
            "        if not (server_max_window_bits is None or",
            "                8 <= server_max_window_bits <= 15):",
            "            raise ValueError(\"server_max_window_bits must be between 8 and 15\")",
            "        if not (client_max_window_bits is None or",
            "                8 <= client_max_window_bits <= 15):",
            "            raise ValueError(\"client_max_window_bits must be between 8 and 15\")",
            "        if compress_settings is not None and 'wbits' in compress_settings:",
            "            raise ValueError(\"compress_settings must not include wbits, \"",
            "                             \"set server_max_window_bits instead\")",
            "",
            "        self.server_no_context_takeover = server_no_context_takeover",
            "        self.client_no_context_takeover = client_no_context_takeover",
            "        self.server_max_window_bits = server_max_window_bits",
            "        self.client_max_window_bits = client_max_window_bits",
            "        self.compress_settings = compress_settings",
            "",
            "    def process_request_params(self, params, accepted_extensions):",
            "        \"\"\"\"",
            "        Process request parameters.",
            "",
            "        Return response params and an extension instance.",
            "",
            "        \"\"\"",
            "        if any(other.name == self.name for other in accepted_extensions):",
            "            raise NegotiationError(\"Skipped duplicate {}\".format(self.name))",
            "",
            "        # Load request parameters in local variables.",
            "        (",
            "            server_no_context_takeover,",
            "            client_no_context_takeover,",
            "            server_max_window_bits,",
            "            client_max_window_bits,",
            "        ) = _extract_parameters(params, is_server=True)",
            "",
            "        # Configuration parameters are available in instance variables.",
            "",
            "        # After comparing the request and the configuration, the response must",
            "        # be available in the local variables.",
            "",
            "        # server_no_context_takeover",
            "        #",
            "        #   Config  Req.    Resp.",
            "        #   ------  ------  --------------------------------------------------",
            "        #   False   False   False",
            "        #   False   True    True",
            "        #   True    False   True - must change value to True",
            "        #   True    True    True",
            "",
            "        if self.server_no_context_takeover:",
            "            if not server_no_context_takeover:",
            "                server_no_context_takeover = True",
            "",
            "        # client_no_context_takeover",
            "        #",
            "        #   Config  Req.    Resp.",
            "        #   ------  ------  --------------------------------------------------",
            "        #   False   False   False",
            "        #   False   True    True (or False)",
            "        #   True    False   True - must change value to True",
            "        #   True    True    True (or False)",
            "",
            "        if self.client_no_context_takeover:",
            "            if not client_no_context_takeover:",
            "                client_no_context_takeover = True",
            "",
            "        # server_max_window_bits",
            "",
            "        #   Config  Req.    Resp.",
            "        #   ------  ------  --------------------------------------------------",
            "        #   None    None    None",
            "        #   None    8\u2264M\u226415  M",
            "        #   8\u2264N\u226415  None    N - must change value",
            "        #   8\u2264N\u226415  8\u2264M\u2264N   M",
            "        #   8\u2264N\u226415  N<M\u226415  N - must change value",
            "",
            "        if self.server_max_window_bits is None:",
            "            pass",
            "",
            "        else:",
            "            if server_max_window_bits is None:",
            "                server_max_window_bits = self.server_max_window_bits",
            "            elif server_max_window_bits > self.server_max_window_bits:",
            "                server_max_window_bits = self.server_max_window_bits",
            "",
            "        # client_max_window_bits",
            "",
            "        #   Config  Req.    Resp.",
            "        #   ------  ------  --------------------------------------------------",
            "        #   None    None    None",
            "        #   None    True    None - must change value",
            "        #   None    8\u2264M\u226415  M (or None)",
            "        #   8\u2264N\u226415  None    Error!",
            "        #   8\u2264N\u226415  True    N - must change value",
            "        #   8\u2264N\u226415  8\u2264M\u2264N   M (or None)",
            "        #   8\u2264N\u226415  N<M\u226415  N",
            "",
            "        if self.client_max_window_bits is None:",
            "            if client_max_window_bits is True:",
            "                client_max_window_bits = self.client_max_window_bits",
            "",
            "        else:",
            "            if client_max_window_bits is None:",
            "                raise NegotiationError(\"Required client_max_window_bits\")",
            "            elif client_max_window_bits is True:",
            "                client_max_window_bits = self.client_max_window_bits",
            "            elif self.client_max_window_bits < client_max_window_bits:",
            "                client_max_window_bits = self.client_max_window_bits",
            "",
            "        return (",
            "            _build_parameters(",
            "                server_no_context_takeover, client_no_context_takeover,",
            "                server_max_window_bits, client_max_window_bits,",
            "            ),",
            "            PerMessageDeflate(",
            "                client_no_context_takeover,     # remote_no_context_takeover",
            "                server_no_context_takeover,     # local_no_context_takeover",
            "                client_max_window_bits or 15,   # remote_max_window_bits",
            "                server_max_window_bits or 15,   # local_max_window_bits",
            "                self.compress_settings,",
            "            )",
            "        )",
            "",
            "",
            "class PerMessageDeflate:",
            "    \"\"\"",
            "    permessage-deflate extension.",
            "",
            "    \"\"\"",
            "    name = 'permessage-deflate'",
            "",
            "    def __init__(",
            "        self,",
            "        remote_no_context_takeover,",
            "        local_no_context_takeover,",
            "        remote_max_window_bits,",
            "        local_max_window_bits,",
            "        compress_settings=None,",
            "    ):",
            "        \"\"\"",
            "        Configure permessage-deflate extension.",
            "",
            "        \"\"\"",
            "        if compress_settings is None:",
            "            compress_settings = {}",
            "",
            "        assert remote_no_context_takeover in [False, True]",
            "        assert local_no_context_takeover in [False, True]",
            "        assert 8 <= remote_max_window_bits <= 15",
            "        assert 8 <= local_max_window_bits <= 15",
            "        assert 'wbits' not in compress_settings",
            "",
            "        self.remote_no_context_takeover = remote_no_context_takeover",
            "        self.local_no_context_takeover = local_no_context_takeover",
            "        self.remote_max_window_bits = remote_max_window_bits",
            "        self.local_max_window_bits = local_max_window_bits",
            "        self.compress_settings = compress_settings",
            "",
            "        if not self.remote_no_context_takeover:",
            "            self.decoder = zlib.decompressobj(",
            "                wbits=-self.remote_max_window_bits)",
            "",
            "        if not self.local_no_context_takeover:",
            "            self.encoder = zlib.compressobj(",
            "                wbits=-self.local_max_window_bits,",
            "                **self.compress_settings)",
            "",
            "        # To handle continuation frames properly, we must keep track of",
            "        # whether that initial frame was encoded.",
            "        self.decode_cont_data = False",
            "        # There's no need for self.encode_cont_data because we always encode",
            "        # outgoing frames, so it would always be True.",
            "",
            "    def __repr__(self):",
            "        return 'PerMessageDeflate({})'.format(', '.join([",
            "            'remote_no_context_takeover={}'.format(",
            "                self.remote_no_context_takeover),",
            "            'local_no_context_takeover={}'.format(",
            "                self.local_no_context_takeover),",
            "            'remote_max_window_bits={}'.format(",
            "                self.remote_max_window_bits),",
            "            'local_max_window_bits={}'.format(",
            "                self.local_max_window_bits),",
            "        ]))",
            "",
            "    def decode(self, frame):",
            "        \"\"\"",
            "        Decode an incoming frame.",
            "",
            "        \"\"\"",
            "        # Skip control frames.",
            "        if frame.opcode in CTRL_OPCODES:",
            "            return frame",
            "",
            "        # Handle continuation data frames:",
            "        # - skip if the initial data frame wasn't encoded",
            "        # - reset \"decode continuation data\" flag if it's a final frame",
            "        if frame.opcode == OP_CONT:",
            "            if not self.decode_cont_data:",
            "                return frame",
            "            if frame.fin:",
            "                self.decode_cont_data = False",
            "",
            "        # Handle text and binary data frames:",
            "        # - skip if the frame isn't encoded",
            "        # - set \"decode continuation data\" flag if it's a non-final frame",
            "        else:",
            "            if not frame.rsv1:",
            "                return frame",
            "            if not frame.fin:  # frame.rsv1 is True at this point",
            "                self.decode_cont_data = True",
            "",
            "            # Re-initialize per-message decoder.",
            "            if self.remote_no_context_takeover:",
            "                self.decoder = zlib.decompressobj(",
            "                    wbits=-self.remote_max_window_bits)",
            "",
            "        # Uncompress compressed frames.",
            "        data = frame.data",
            "        if frame.fin:",
            "            data += _EMPTY_UNCOMPRESSED_BLOCK",
            "        data = self.decoder.decompress(data)",
            "",
            "        # Allow garbage collection of the decoder if it won't be reused.",
            "        if frame.fin and self.remote_no_context_takeover:",
            "            self.decoder = None",
            "",
            "        return frame._replace(data=data, rsv1=False)",
            "",
            "    def encode(self, frame):",
            "        \"\"\"",
            "        Encode an outgoing frame.",
            "",
            "        \"\"\"",
            "        # Skip control frames.",
            "        if frame.opcode in CTRL_OPCODES:",
            "            return frame",
            "",
            "        # Since we always encode and never fragment messages, there's no logic",
            "        # similar to decode() here at this time.",
            "",
            "        if frame.opcode != OP_CONT:",
            "            # Re-initialize per-message decoder.",
            "            if self.local_no_context_takeover:",
            "                self.encoder = zlib.compressobj(",
            "                    wbits=-self.local_max_window_bits,",
            "                    **self.compress_settings)",
            "",
            "        # Compress data frames.",
            "        data = (",
            "            self.encoder.compress(frame.data) +",
            "            self.encoder.flush(zlib.Z_SYNC_FLUSH)",
            "        )",
            "        if frame.fin and data.endswith(_EMPTY_UNCOMPRESSED_BLOCK):",
            "            data = data[:-4]",
            "",
            "        # Allow garbage collection of the encoder if it won't be reused.",
            "        if frame.fin and self.local_no_context_takeover:",
            "            self.encoder = None",
            "",
            "        return frame._replace(data=data, rsv1=True)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "The :mod:`websockets.extensions.permessage_deflate` module implements the",
            "Compression Extensions for WebSocket as specified in :rfc:`7692`.",
            "",
            "\"\"\"",
            "",
            "import zlib",
            "",
            "from ..exceptions import (",
            "    DuplicateParameter, InvalidParameterName, InvalidParameterValue,",
            "    NegotiationError, PayloadTooBig",
            ")",
            "from ..framing import CTRL_OPCODES, OP_CONT",
            "",
            "",
            "__all__ = [",
            "    'ClientPerMessageDeflateFactory',",
            "    'ServerPerMessageDeflateFactory',",
            "    'PerMessageDeflate',",
            "]",
            "",
            "_EMPTY_UNCOMPRESSED_BLOCK = b'\\x00\\x00\\xff\\xff'",
            "",
            "_MAX_WINDOW_BITS_VALUES = [str(bits) for bits in range(8, 16)]",
            "",
            "",
            "def _build_parameters(",
            "    server_no_context_takeover,",
            "    client_no_context_takeover,",
            "    server_max_window_bits,",
            "    client_max_window_bits,",
            "):",
            "    \"\"\"",
            "    Build a list of ``(name, value)`` pairs for some compression parameters.",
            "",
            "    \"\"\"",
            "    params = []",
            "    if server_no_context_takeover:",
            "        params.append(('server_no_context_takeover', None))",
            "    if client_no_context_takeover:",
            "        params.append(('client_no_context_takeover', None))",
            "    if server_max_window_bits:",
            "        params.append(('server_max_window_bits', str(server_max_window_bits)))",
            "    if client_max_window_bits is True:          # only in handshake requests",
            "        params.append(('client_max_window_bits', None))",
            "    elif client_max_window_bits:",
            "        params.append(('client_max_window_bits', str(client_max_window_bits)))",
            "    return params",
            "",
            "",
            "def _extract_parameters(params, *, is_server):",
            "    \"\"\"",
            "    Extract compression parameters from a list of ``(name, value)`` pairs.",
            "",
            "    If ``is_server`` is ``True``, ``client_max_window_bits`` may be provided",
            "    without a value. This is only allow in handshake requests.",
            "",
            "    \"\"\"",
            "    server_no_context_takeover = False",
            "    client_no_context_takeover = False",
            "    server_max_window_bits = None",
            "    client_max_window_bits = None",
            "",
            "    for name, value in params:",
            "",
            "        if name == 'server_no_context_takeover':",
            "            if server_no_context_takeover:",
            "                raise DuplicateParameter(name)",
            "            if value is None:",
            "                server_no_context_takeover = True",
            "            else:",
            "                raise InvalidParameterValue(name, value)",
            "",
            "        elif name == 'client_no_context_takeover':",
            "            if client_no_context_takeover:",
            "                raise DuplicateParameter(name)",
            "            if value is None:",
            "                client_no_context_takeover = True",
            "            else:",
            "                raise InvalidParameterValue(name, value)",
            "",
            "        elif name == 'server_max_window_bits':",
            "            if server_max_window_bits is not None:",
            "                raise DuplicateParameter(name)",
            "            if value in _MAX_WINDOW_BITS_VALUES:",
            "                server_max_window_bits = int(value)",
            "            else:",
            "                raise InvalidParameterValue(name, value)",
            "",
            "        elif name == 'client_max_window_bits':",
            "            if client_max_window_bits is not None:",
            "                raise DuplicateParameter(name)",
            "            if is_server and value is None:     # only in handshake requests",
            "                client_max_window_bits = True",
            "            elif value in _MAX_WINDOW_BITS_VALUES:",
            "                client_max_window_bits = int(value)",
            "            else:",
            "                raise InvalidParameterValue(name, value)",
            "",
            "        else:",
            "            raise InvalidParameterName(name)",
            "",
            "    return (",
            "        server_no_context_takeover,",
            "        client_no_context_takeover,",
            "        server_max_window_bits,",
            "        client_max_window_bits,",
            "    )",
            "",
            "",
            "class ClientPerMessageDeflateFactory:",
            "    \"\"\"",
            "    Client-side extension factory for permessage-deflate extension.",
            "",
            "    \"\"\"",
            "    name = 'permessage-deflate'",
            "",
            "    def __init__(",
            "        self,",
            "        server_no_context_takeover=False,",
            "        client_no_context_takeover=False,",
            "        server_max_window_bits=None,",
            "        client_max_window_bits=None,",
            "        compress_settings=None,",
            "    ):",
            "        \"\"\"",
            "        Configure permessage-deflate extension factory.",
            "",
            "        See https://tools.ietf.org/html/rfc7692#section-7.1.",
            "",
            "        \"\"\"",
            "        if not (server_max_window_bits is None or",
            "                8 <= server_max_window_bits <= 15):",
            "            raise ValueError(\"server_max_window_bits must be between 8 and 15\")",
            "        if not (client_max_window_bits is None or",
            "                client_max_window_bits is True or",
            "                8 <= client_max_window_bits <= 15):",
            "            raise ValueError(\"client_max_window_bits must be between 8 and 15\")",
            "        if compress_settings is not None and 'wbits' in compress_settings:",
            "            raise ValueError(\"compress_settings must not include wbits, \"",
            "                             \"set client_max_window_bits instead\")",
            "",
            "        self.server_no_context_takeover = server_no_context_takeover",
            "        self.client_no_context_takeover = client_no_context_takeover",
            "        self.server_max_window_bits = server_max_window_bits",
            "        self.client_max_window_bits = client_max_window_bits",
            "        self.compress_settings = compress_settings",
            "",
            "    def get_request_params(self):",
            "        \"\"\"",
            "        Build request parameters.",
            "",
            "        \"\"\"",
            "        return _build_parameters(",
            "            self.server_no_context_takeover, self.client_no_context_takeover,",
            "            self.server_max_window_bits, self.client_max_window_bits,",
            "        )",
            "",
            "    def process_response_params(self, params, accepted_extensions):",
            "        \"\"\"\"",
            "        Process response parameters.",
            "",
            "        Return an extension instance.",
            "",
            "        \"\"\"",
            "        if any(other.name == self.name for other in accepted_extensions):",
            "            raise NegotiationError(\"Received duplicate {}\".format(self.name))",
            "",
            "        # Request parameters are available in instance variables.",
            "",
            "        # Load response parameters in local variables.",
            "        (",
            "            server_no_context_takeover,",
            "            client_no_context_takeover,",
            "            server_max_window_bits,",
            "            client_max_window_bits,",
            "        ) = _extract_parameters(params, is_server=False)",
            "",
            "        # After comparing the request and the response, the final",
            "        # configuration must be available in the local variables.",
            "",
            "        # server_no_context_takeover",
            "        #",
            "        #   Req.    Resp.   Result",
            "        #   ------  ------  --------------------------------------------------",
            "        #   False   False   False",
            "        #   False   True    True",
            "        #   True    False   Error!",
            "        #   True    True    True",
            "",
            "        if self.server_no_context_takeover:",
            "            if not server_no_context_takeover:",
            "                raise NegotiationError(\"Expected server_no_context_takeover\")",
            "",
            "        # client_no_context_takeover",
            "        #",
            "        #   Req.    Resp.   Result",
            "        #   ------  ------  --------------------------------------------------",
            "        #   False   False   False",
            "        #   False   True    True",
            "        #   True    False   True - must change value",
            "        #   True    True    True",
            "",
            "        if self.client_no_context_takeover:",
            "            if not client_no_context_takeover:",
            "                client_no_context_takeover = True",
            "",
            "        # server_max_window_bits",
            "",
            "        #   Req.    Resp.   Result",
            "        #   ------  ------  --------------------------------------------------",
            "        #   None    None    None",
            "        #   None    8\u2264M\u226415  M",
            "        #   8\u2264N\u226415  None    Error!",
            "        #   8\u2264N\u226415  8\u2264M\u2264N   M",
            "        #   8\u2264N\u226415  N<M\u226415  Error!",
            "",
            "        if self.server_max_window_bits is None:",
            "            pass",
            "",
            "        else:",
            "            if server_max_window_bits is None:",
            "                raise NegotiationError(\"Expected server_max_window_bits\")",
            "            elif server_max_window_bits > self.server_max_window_bits:",
            "                raise NegotiationError(\"Unsupported server_max_window_bits\")",
            "",
            "        # client_max_window_bits",
            "",
            "        #   Req.    Resp.   Result",
            "        #   ------  ------  --------------------------------------------------",
            "        #   None    None    None",
            "        #   None    8\u2264M\u226415  Error!",
            "        #   True    None    None",
            "        #   True    8\u2264M\u226415  M",
            "        #   8\u2264N\u226415  None    N - must change value",
            "        #   8\u2264N\u226415  8\u2264M\u2264N   M",
            "        #   8\u2264N\u226415  N<M\u226415  Error!",
            "",
            "        if self.client_max_window_bits is None:",
            "            if client_max_window_bits is not None:",
            "                raise NegotiationError(\"Unexpected client_max_window_bits\")",
            "",
            "        elif self.client_max_window_bits is True:",
            "            pass",
            "",
            "        else:",
            "            if client_max_window_bits is None:",
            "                client_max_window_bits = self.client_max_window_bits",
            "            elif client_max_window_bits > self.client_max_window_bits:",
            "                raise NegotiationError(\"Unsupported client_max_window_bits\")",
            "",
            "        return PerMessageDeflate(",
            "            server_no_context_takeover,     # remote_no_context_takeover",
            "            client_no_context_takeover,     # local_no_context_takeover",
            "            server_max_window_bits or 15,   # remote_max_window_bits",
            "            client_max_window_bits or 15,   # local_max_window_bits",
            "            self.compress_settings,",
            "        )",
            "",
            "",
            "class ServerPerMessageDeflateFactory:",
            "    \"\"\"",
            "    Server-side extension factory for permessage-deflate extension.",
            "",
            "    \"\"\"",
            "    name = 'permessage-deflate'",
            "",
            "    def __init__(",
            "        self,",
            "        server_no_context_takeover=False,",
            "        client_no_context_takeover=False,",
            "        server_max_window_bits=None,",
            "        client_max_window_bits=None,",
            "        compress_settings=None,",
            "    ):",
            "        \"\"\"",
            "        Configure permessage-deflate extension factory.",
            "",
            "        See https://tools.ietf.org/html/rfc7692#section-7.1.",
            "",
            "        \"\"\"",
            "        if not (server_max_window_bits is None or",
            "                8 <= server_max_window_bits <= 15):",
            "            raise ValueError(\"server_max_window_bits must be between 8 and 15\")",
            "        if not (client_max_window_bits is None or",
            "                8 <= client_max_window_bits <= 15):",
            "            raise ValueError(\"client_max_window_bits must be between 8 and 15\")",
            "        if compress_settings is not None and 'wbits' in compress_settings:",
            "            raise ValueError(\"compress_settings must not include wbits, \"",
            "                             \"set server_max_window_bits instead\")",
            "",
            "        self.server_no_context_takeover = server_no_context_takeover",
            "        self.client_no_context_takeover = client_no_context_takeover",
            "        self.server_max_window_bits = server_max_window_bits",
            "        self.client_max_window_bits = client_max_window_bits",
            "        self.compress_settings = compress_settings",
            "",
            "    def process_request_params(self, params, accepted_extensions):",
            "        \"\"\"\"",
            "        Process request parameters.",
            "",
            "        Return response params and an extension instance.",
            "",
            "        \"\"\"",
            "        if any(other.name == self.name for other in accepted_extensions):",
            "            raise NegotiationError(\"Skipped duplicate {}\".format(self.name))",
            "",
            "        # Load request parameters in local variables.",
            "        (",
            "            server_no_context_takeover,",
            "            client_no_context_takeover,",
            "            server_max_window_bits,",
            "            client_max_window_bits,",
            "        ) = _extract_parameters(params, is_server=True)",
            "",
            "        # Configuration parameters are available in instance variables.",
            "",
            "        # After comparing the request and the configuration, the response must",
            "        # be available in the local variables.",
            "",
            "        # server_no_context_takeover",
            "        #",
            "        #   Config  Req.    Resp.",
            "        #   ------  ------  --------------------------------------------------",
            "        #   False   False   False",
            "        #   False   True    True",
            "        #   True    False   True - must change value to True",
            "        #   True    True    True",
            "",
            "        if self.server_no_context_takeover:",
            "            if not server_no_context_takeover:",
            "                server_no_context_takeover = True",
            "",
            "        # client_no_context_takeover",
            "        #",
            "        #   Config  Req.    Resp.",
            "        #   ------  ------  --------------------------------------------------",
            "        #   False   False   False",
            "        #   False   True    True (or False)",
            "        #   True    False   True - must change value to True",
            "        #   True    True    True (or False)",
            "",
            "        if self.client_no_context_takeover:",
            "            if not client_no_context_takeover:",
            "                client_no_context_takeover = True",
            "",
            "        # server_max_window_bits",
            "",
            "        #   Config  Req.    Resp.",
            "        #   ------  ------  --------------------------------------------------",
            "        #   None    None    None",
            "        #   None    8\u2264M\u226415  M",
            "        #   8\u2264N\u226415  None    N - must change value",
            "        #   8\u2264N\u226415  8\u2264M\u2264N   M",
            "        #   8\u2264N\u226415  N<M\u226415  N - must change value",
            "",
            "        if self.server_max_window_bits is None:",
            "            pass",
            "",
            "        else:",
            "            if server_max_window_bits is None:",
            "                server_max_window_bits = self.server_max_window_bits",
            "            elif server_max_window_bits > self.server_max_window_bits:",
            "                server_max_window_bits = self.server_max_window_bits",
            "",
            "        # client_max_window_bits",
            "",
            "        #   Config  Req.    Resp.",
            "        #   ------  ------  --------------------------------------------------",
            "        #   None    None    None",
            "        #   None    True    None - must change value",
            "        #   None    8\u2264M\u226415  M (or None)",
            "        #   8\u2264N\u226415  None    Error!",
            "        #   8\u2264N\u226415  True    N - must change value",
            "        #   8\u2264N\u226415  8\u2264M\u2264N   M (or None)",
            "        #   8\u2264N\u226415  N<M\u226415  N",
            "",
            "        if self.client_max_window_bits is None:",
            "            if client_max_window_bits is True:",
            "                client_max_window_bits = self.client_max_window_bits",
            "",
            "        else:",
            "            if client_max_window_bits is None:",
            "                raise NegotiationError(\"Required client_max_window_bits\")",
            "            elif client_max_window_bits is True:",
            "                client_max_window_bits = self.client_max_window_bits",
            "            elif self.client_max_window_bits < client_max_window_bits:",
            "                client_max_window_bits = self.client_max_window_bits",
            "",
            "        return (",
            "            _build_parameters(",
            "                server_no_context_takeover, client_no_context_takeover,",
            "                server_max_window_bits, client_max_window_bits,",
            "            ),",
            "            PerMessageDeflate(",
            "                client_no_context_takeover,     # remote_no_context_takeover",
            "                server_no_context_takeover,     # local_no_context_takeover",
            "                client_max_window_bits or 15,   # remote_max_window_bits",
            "                server_max_window_bits or 15,   # local_max_window_bits",
            "                self.compress_settings,",
            "            )",
            "        )",
            "",
            "",
            "class PerMessageDeflate:",
            "    \"\"\"",
            "    permessage-deflate extension.",
            "",
            "    \"\"\"",
            "    name = 'permessage-deflate'",
            "",
            "    def __init__(",
            "        self,",
            "        remote_no_context_takeover,",
            "        local_no_context_takeover,",
            "        remote_max_window_bits,",
            "        local_max_window_bits,",
            "        compress_settings=None,",
            "    ):",
            "        \"\"\"",
            "        Configure permessage-deflate extension.",
            "",
            "        \"\"\"",
            "        if compress_settings is None:",
            "            compress_settings = {}",
            "",
            "        assert remote_no_context_takeover in [False, True]",
            "        assert local_no_context_takeover in [False, True]",
            "        assert 8 <= remote_max_window_bits <= 15",
            "        assert 8 <= local_max_window_bits <= 15",
            "        assert 'wbits' not in compress_settings",
            "",
            "        self.remote_no_context_takeover = remote_no_context_takeover",
            "        self.local_no_context_takeover = local_no_context_takeover",
            "        self.remote_max_window_bits = remote_max_window_bits",
            "        self.local_max_window_bits = local_max_window_bits",
            "        self.compress_settings = compress_settings",
            "",
            "        if not self.remote_no_context_takeover:",
            "            self.decoder = zlib.decompressobj(",
            "                wbits=-self.remote_max_window_bits)",
            "",
            "        if not self.local_no_context_takeover:",
            "            self.encoder = zlib.compressobj(",
            "                wbits=-self.local_max_window_bits,",
            "                **self.compress_settings)",
            "",
            "        # To handle continuation frames properly, we must keep track of",
            "        # whether that initial frame was encoded.",
            "        self.decode_cont_data = False",
            "        # There's no need for self.encode_cont_data because we always encode",
            "        # outgoing frames, so it would always be True.",
            "",
            "    def __repr__(self):",
            "        return 'PerMessageDeflate({})'.format(', '.join([",
            "            'remote_no_context_takeover={}'.format(",
            "                self.remote_no_context_takeover),",
            "            'local_no_context_takeover={}'.format(",
            "                self.local_no_context_takeover),",
            "            'remote_max_window_bits={}'.format(",
            "                self.remote_max_window_bits),",
            "            'local_max_window_bits={}'.format(",
            "                self.local_max_window_bits),",
            "        ]))",
            "",
            "    def decode(self, frame, *, max_size=None):",
            "        \"\"\"",
            "        Decode an incoming frame.",
            "",
            "        \"\"\"",
            "        # Skip control frames.",
            "        if frame.opcode in CTRL_OPCODES:",
            "            return frame",
            "",
            "        # Handle continuation data frames:",
            "        # - skip if the initial data frame wasn't encoded",
            "        # - reset \"decode continuation data\" flag if it's a final frame",
            "        if frame.opcode == OP_CONT:",
            "            if not self.decode_cont_data:",
            "                return frame",
            "            if frame.fin:",
            "                self.decode_cont_data = False",
            "",
            "        # Handle text and binary data frames:",
            "        # - skip if the frame isn't encoded",
            "        # - set \"decode continuation data\" flag if it's a non-final frame",
            "        else:",
            "            if not frame.rsv1:",
            "                return frame",
            "            if not frame.fin:  # frame.rsv1 is True at this point",
            "                self.decode_cont_data = True",
            "",
            "            # Re-initialize per-message decoder.",
            "            if self.remote_no_context_takeover:",
            "                self.decoder = zlib.decompressobj(",
            "                    wbits=-self.remote_max_window_bits)",
            "",
            "        # Uncompress compressed frames. Protect against zip bombs by",
            "        # preventing zlib from decompressing more than max_length bytes",
            "        # (except when the limit is disabled with max_size = None).",
            "        data = frame.data",
            "        if frame.fin:",
            "            data += _EMPTY_UNCOMPRESSED_BLOCK",
            "        max_length = 0 if max_size is None else max_size",
            "        data = self.decoder.decompress(data, max_length)",
            "        if self.decoder.unconsumed_tail:",
            "            raise PayloadTooBig(",
            "                \"Uncompressed payload length exceeds size limit (? > {} bytes)\"",
            "                .format(max_size))",
            "",
            "        # Allow garbage collection of the decoder if it won't be reused.",
            "        if frame.fin and self.remote_no_context_takeover:",
            "            self.decoder = None",
            "",
            "        return frame._replace(data=data, rsv1=False)",
            "",
            "    def encode(self, frame):",
            "        \"\"\"",
            "        Encode an outgoing frame.",
            "",
            "        \"\"\"",
            "        # Skip control frames.",
            "        if frame.opcode in CTRL_OPCODES:",
            "            return frame",
            "",
            "        # Since we always encode and never fragment messages, there's no logic",
            "        # similar to decode() here at this time.",
            "",
            "        if frame.opcode != OP_CONT:",
            "            # Re-initialize per-message decoder.",
            "            if self.local_no_context_takeover:",
            "                self.encoder = zlib.compressobj(",
            "                    wbits=-self.local_max_window_bits,",
            "                    **self.compress_settings)",
            "",
            "        # Compress data frames.",
            "        data = (",
            "            self.encoder.compress(frame.data) +",
            "            self.encoder.flush(zlib.Z_SYNC_FLUSH)",
            "        )",
            "        if frame.fin and data.endswith(_EMPTY_UNCOMPRESSED_BLOCK):",
            "            data = data[:-4]",
            "",
            "        # Allow garbage collection of the encoder if it won't be reused.",
            "        if frame.fin and self.local_no_context_takeover:",
            "            self.encoder = None",
            "",
            "        return frame._replace(data=data, rsv1=True)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "466": [
                "PerMessageDeflate",
                "decode"
            ],
            "498": [
                "PerMessageDeflate",
                "decode"
            ],
            "502": [
                "PerMessageDeflate",
                "decode"
            ]
        },
        "addLocation": []
    },
    "websockets/extensions/test_permessage_deflate.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from ..exceptions import ("
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": "     DuplicateParameter, InvalidParameterName, InvalidParameterValue,"
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    NegotiationError"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+    NegotiationError, PayloadTooBig"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " )"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from ..framing import ("
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "     OP_BINARY, OP_CLOSE, OP_CONT, OP_PING, OP_PONG, OP_TEXT, Frame,"
            },
            "8": {
                "beforePatchRowNumber": 835,
                "afterPatchRowNumber": 835,
                "PatchRowcode": "             rsv1=True,"
            },
            "9": {
                "beforePatchRowNumber": 836,
                "afterPatchRowNumber": 836,
                "PatchRowcode": "             data=b'\\x00\\x05\\x00\\xfa\\xffcaf\\xc3\\xa9\\x00',    # not compressed"
            },
            "10": {
                "beforePatchRowNumber": 837,
                "afterPatchRowNumber": 837,
                "PatchRowcode": "         ))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 838,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 839,
                "PatchRowcode": "+    # Frames aren't decoded beyond max_length."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 840,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 841,
                "PatchRowcode": "+    def test_decompress_max_size(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 842,
                "PatchRowcode": "+        frame = Frame(True, OP_TEXT, ('a' * 20).encode('utf-8'))"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 843,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 844,
                "PatchRowcode": "+        enc_frame = self.extension.encode(frame)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 845,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 846,
                "PatchRowcode": "+        self.assertEqual(enc_frame.data, b'JL\\xc4\\x04\\x00\\x00')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 847,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 848,
                "PatchRowcode": "+        with self.assertRaises(PayloadTooBig):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 849,
                "PatchRowcode": "+            self.extension.decode(enc_frame, max_size=10)"
            }
        },
        "frontPatchFile": [
            "import unittest",
            "import zlib",
            "",
            "from ..exceptions import (",
            "    DuplicateParameter, InvalidParameterName, InvalidParameterValue,",
            "    NegotiationError",
            ")",
            "from ..framing import (",
            "    OP_BINARY, OP_CLOSE, OP_CONT, OP_PING, OP_PONG, OP_TEXT, Frame,",
            "    serialize_close",
            ")",
            "from .permessage_deflate import *",
            "",
            "",
            "class ExtensionTestsMixin:",
            "",
            "    def assertExtensionEqual(self, extension1, extension2):",
            "        self.assertEqual(extension1.remote_no_context_takeover,",
            "                         extension2.remote_no_context_takeover)",
            "        self.assertEqual(extension1.local_no_context_takeover,",
            "                         extension2.local_no_context_takeover)",
            "        self.assertEqual(extension1.remote_max_window_bits,",
            "                         extension2.remote_max_window_bits)",
            "        self.assertEqual(extension1.local_max_window_bits,",
            "                         extension2.local_max_window_bits)",
            "",
            "",
            "class ClientPerMessageDeflateFactoryTests(unittest.TestCase,",
            "                                          ExtensionTestsMixin):",
            "",
            "    def test_name(self):",
            "        assert ClientPerMessageDeflateFactory.name == 'permessage-deflate'",
            "",
            "    def test_init(self):",
            "        for config in [",
            "            (False, False, 8, None),        # server_max_window_bits \u2265 8",
            "            (False, True, 15, None),        # server_max_window_bits \u2264 15",
            "            (True, False, None, 8),         # client_max_window_bits \u2265 8",
            "            (True, True, None, 15),         # client_max_window_bits \u2264 15",
            "            (False, False, None, True),     # client_max_window_bits",
            "            (False, False, None, None, {'memLevel': 4}),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                # This does not raise an exception.",
            "                ClientPerMessageDeflateFactory(*config)",
            "",
            "    def test_init_error(self):",
            "        for config in [",
            "            (False, False, 7, 8),           # server_max_window_bits < 8",
            "            (False, True, 8, 7),            # client_max_window_bits < 8",
            "            (True, False, 16, 15),          # server_max_window_bits > 15",
            "            (True, True, 15, 16),           # client_max_window_bits > 15",
            "            (False, False, True, None),     # server_max_window_bits",
            "            (False, False, None, None, {'wbits': 11}),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                with self.assertRaises(ValueError):",
            "                    ClientPerMessageDeflateFactory(*config)",
            "",
            "    def test_get_request_params(self):",
            "        for config, result in [",
            "            # Test without any parameter",
            "            (",
            "                (False, False, None, None),",
            "                [],",
            "            ),",
            "            # Test server_no_context_takeover",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "            ),",
            "            # Test client_no_context_takeover",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)],",
            "            ),",
            "            # Test server_max_window_bits",
            "            (",
            "                (False, False, 10, None),",
            "                [('server_max_window_bits', '10')],",
            "            ),",
            "            # Test client_max_window_bits",
            "            (",
            "                (False, False, None, 10),",
            "                [('client_max_window_bits', '10')],",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [('client_max_window_bits', None)],",
            "            ),",
            "            # Test all parameters together",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '12'),",
            "                    ('client_max_window_bits', '12'),",
            "                ],",
            "            ),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                factory = ClientPerMessageDeflateFactory(*config)",
            "                self.assertEqual(factory.get_request_params(), result)",
            "",
            "    def test_process_response_params(self):",
            "        for config, response_params, result in [",
            "            # Test without any parameter",
            "            (",
            "                (False, False, None, None),",
            "                [],",
            "                (False, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('unknown', None)],",
            "                InvalidParameterName,",
            "            ),",
            "            # Test server_no_context_takeover",
            "            (",
            "                (False, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)] * 2,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', '42')],",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test client_no_context_takeover",
            "            (",
            "                (False, False, None, None),",
            "                [('client_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)] * 2,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', '42')],",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test server_max_window_bits",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '7')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '10')],",
            "                (False, False, 10, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '16')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '10')],",
            "                (False, False, 10, 15),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '12')],",
            "                (False, False, 12, 15),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '13')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '12')] * 2,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '42')],",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test client_max_window_bits",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', '10')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [],",
            "                (False, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [('client_max_window_bits', '7')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [('client_max_window_bits', '10')],",
            "                (False, False, 15, 10),",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [('client_max_window_bits', '16')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '10')],",
            "                (False, False, 15, 10),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '12')],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '13')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '12')] * 2,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '42')],",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test all parameters together",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                (True, True, 10, 10),",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                (True, True, 10, 10),",
            "            ),",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('server_max_window_bits', '12'),",
            "                ],",
            "                (True, True, 12, 12),",
            "            ),",
            "        ]:",
            "            with self.subTest(",
            "                config=config,",
            "                response_params=response_params,",
            "            ):",
            "                factory = ClientPerMessageDeflateFactory(*config)",
            "                if isinstance(result, type) and issubclass(result, Exception):",
            "                    with self.assertRaises(result):",
            "                        factory.process_response_params(response_params, [])",
            "                else:",
            "                    extension = factory.process_response_params(",
            "                        response_params, [])",
            "                    expected = PerMessageDeflate(*result)",
            "                    self.assertExtensionEqual(extension, expected)",
            "",
            "    def test_process_response_params_deduplication(self):",
            "        factory = ClientPerMessageDeflateFactory(False, False, None, None)",
            "        with self.assertRaises(NegotiationError):",
            "            factory.process_response_params(",
            "                [], [PerMessageDeflate(False, False, 15, 15)])",
            "",
            "",
            "class ServerPerMessageDeflateFactoryTests(unittest.TestCase,",
            "                                          ExtensionTestsMixin):",
            "",
            "    def test_name(self):",
            "        assert ServerPerMessageDeflateFactory.name == 'permessage-deflate'",
            "",
            "    def test_init(self):",
            "        for config in [",
            "            (False, False, 8, None),        # server_max_window_bits \u2265 8",
            "            (False, True, 15, None),        # server_max_window_bits \u2264 15",
            "            (True, False, None, 8),         # client_max_window_bits \u2265 8",
            "            (True, True, None, 15),         # client_max_window_bits \u2264 15",
            "            (False, False, None, None, {'memLevel': 4}),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                # This does not raise an exception.",
            "                ServerPerMessageDeflateFactory(*config)",
            "",
            "    def test_init_error(self):",
            "        for config in [",
            "            (False, False, 7, 8),           # server_max_window_bits < 8",
            "            (False, True, 8, 7),            # client_max_window_bits < 8",
            "            (True, False, 16, 15),          # server_max_window_bits > 15",
            "            (True, True, 15, 16),           # client_max_window_bits > 15",
            "            (False, False, None, True),     # client_max_window_bits",
            "            (False, False, True, None),     # server_max_window_bits",
            "            (False, False, None, None, {'wbits': 11}),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                with self.assertRaises(ValueError):",
            "                    ServerPerMessageDeflateFactory(*config)",
            "",
            "    def test_process_request_params(self):",
            "        # Parameters in result appear swapped vs. config because the order is",
            "        # (remote, local) vs. (server, client).",
            "        for config, request_params, response_params, result in [",
            "            # Test without any parameter",
            "            (",
            "                (False, False, None, None),",
            "                [],",
            "                [],",
            "                (False, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('unknown', None)],",
            "                None,",
            "                InvalidParameterName,",
            "            ),",
            "            # Test server_no_context_takeover",
            "            (",
            "                (False, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "                [('server_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [],",
            "                [('server_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "                [('server_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)] * 2,",
            "                None,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', '42')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test client_no_context_takeover",
            "            (",
            "                (False, False, None, None),",
            "                [('client_no_context_takeover', None)],",
            "                [('client_no_context_takeover', None)],     # doesn't matter",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [],",
            "                [('client_no_context_takeover', None)],",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)],",
            "                [('client_no_context_takeover', None)],     # doesn't matter",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)] * 2,",
            "                None,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', '42')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test server_max_window_bits",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '7')],",
            "                None,",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '10')],",
            "                [('server_max_window_bits', '10')],",
            "                (False, False, 15, 10),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '16')],",
            "                None,",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [],",
            "                [('server_max_window_bits', '12')],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '10')],",
            "                [('server_max_window_bits', '10')],",
            "                (False, False, 15, 10),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '12')],",
            "                [('server_max_window_bits', '12')],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '13')],",
            "                [('server_max_window_bits', '12')],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '12')] * 2,",
            "                None,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '42')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test client_max_window_bits",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', None)],",
            "                [],",
            "                (False, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', '7')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', '10')],",
            "                [('client_max_window_bits', '10')],     # doesn't matter",
            "                (False, False, 10, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', '16')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [],",
            "                None,",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', None)],",
            "                [('client_max_window_bits', '12')],",
            "                (False, False, 12, 15),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '10')],",
            "                [('client_max_window_bits', '10')],",
            "                (False, False, 10, 15),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '12')],",
            "                [('client_max_window_bits', '12')],     # doesn't matter",
            "                (False, False, 12, 15),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '13')],",
            "                [('client_max_window_bits', '12')],     # doesn't matter",
            "                (False, False, 12, 15),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '12')] * 2,",
            "                None,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '42')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            # # Test all parameters together",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                (True, True, 10, 10),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                (True, True, 10, 10),",
            "            ),",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('client_max_window_bits', None),",
            "                ],",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '12'),",
            "                    ('client_max_window_bits', '12'),",
            "                ],",
            "                (True, True, 12, 12),",
            "            ),",
            "        ]:",
            "            with self.subTest(",
            "                config=config,",
            "                request_params=request_params,",
            "                response_params=response_params,",
            "            ):",
            "                factory = ServerPerMessageDeflateFactory(*config)",
            "                if isinstance(result, type) and issubclass(result, Exception):",
            "                    with self.assertRaises(result):",
            "                        factory.process_request_params(request_params, [])",
            "                else:",
            "                    params, extension = factory.process_request_params(",
            "                        request_params, [])",
            "                    self.assertEqual(params, response_params)",
            "                    expected = PerMessageDeflate(*result)",
            "                    self.assertExtensionEqual(extension, expected)",
            "",
            "    def test_process_response_params_deduplication(self):",
            "        factory = ServerPerMessageDeflateFactory(False, False, None, None)",
            "        with self.assertRaises(NegotiationError):",
            "            factory.process_request_params(",
            "                [], [PerMessageDeflate(False, False, 15, 15)])",
            "",
            "",
            "class PerMessageDeflateTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        # Set up an instance of the permessage-deflate extension with the most",
            "        # common settings. Since the extension is symmetrical, this instance",
            "        # may be used for testing both encoding and decoding.",
            "        self.extension = PerMessageDeflate(False, False, 15, 15)",
            "",
            "    def test_name(self):",
            "        assert self.extension.name == 'permessage-deflate'",
            "",
            "    # Control frames aren't encoded or decoded.",
            "",
            "    def test_no_encode_decode_ping_frame(self):",
            "        frame = Frame(True, OP_PING, b'')",
            "",
            "        self.assertEqual(self.extension.encode(frame), frame)",
            "",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    def test_no_encode_decode_pong_frame(self):",
            "        frame = Frame(True, OP_PONG, b'')",
            "",
            "        self.assertEqual(self.extension.encode(frame), frame)",
            "",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    def test_no_encode_decode_close_frame(self):",
            "        frame = Frame(True, OP_CLOSE, serialize_close(1000, ''))",
            "",
            "        self.assertEqual(self.extension.encode(frame), frame)",
            "",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    # Data frames are encoded and decoded.",
            "",
            "    def test_encode_decode_text_frame(self):",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame, frame._replace(",
            "            rsv1=True,",
            "            data=b'JNL;\\xbc\\x12\\x00',",
            "        ))",
            "",
            "        dec_frame = self.extension.decode(enc_frame)",
            "",
            "        self.assertEqual(dec_frame, frame)",
            "",
            "    def test_encode_decode_binary_frame(self):",
            "        frame = Frame(True, OP_BINARY, b'tea')",
            "",
            "        enc_frame = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame, frame._replace(",
            "            rsv1=True,",
            "            data=b'*IM\\x04\\x00',",
            "        ))",
            "",
            "        dec_frame = self.extension.decode(enc_frame)",
            "",
            "        self.assertEqual(dec_frame, frame)",
            "",
            "    def test_encode_decode_fragmented_text_frame(self):",
            "        frame1 = Frame(False, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "        frame2 = Frame(False, OP_CONT, ' & '.encode('utf-8'))",
            "        frame3 = Frame(True, OP_CONT, 'croissants'.encode('utf-8'))",
            "",
            "        enc_frame1 = self.extension.encode(frame1)",
            "        enc_frame2 = self.extension.encode(frame2)",
            "        enc_frame3 = self.extension.encode(frame3)",
            "",
            "        self.assertEqual(enc_frame1, frame1._replace(",
            "            rsv1=True,",
            "            data=b'JNL;\\xbc\\x12\\x00\\x00\\x00\\xff\\xff',",
            "        ))",
            "        self.assertEqual(enc_frame2, frame2._replace(",
            "            rsv1=True,",
            "            data=b'RPS\\x00\\x00\\x00\\x00\\xff\\xff',",
            "        ))",
            "        self.assertEqual(enc_frame3, frame3._replace(",
            "            rsv1=True,",
            "            data=b'J.\\xca\\xcf,.N\\xcc+)\\x06\\x00',",
            "        ))",
            "",
            "        dec_frame1 = self.extension.decode(enc_frame1)",
            "        dec_frame2 = self.extension.decode(enc_frame2)",
            "        dec_frame3 = self.extension.decode(enc_frame3)",
            "",
            "        self.assertEqual(dec_frame1, frame1)",
            "        self.assertEqual(dec_frame2, frame2)",
            "        self.assertEqual(dec_frame3, frame3)",
            "",
            "    def test_encode_decode_fragmented_binary_frame(self):",
            "        frame1 = Frame(False, OP_TEXT, b'tea ')",
            "        frame2 = Frame(True, OP_CONT, b'time')",
            "",
            "        enc_frame1 = self.extension.encode(frame1)",
            "        enc_frame2 = self.extension.encode(frame2)",
            "",
            "        self.assertEqual(enc_frame1, frame1._replace(",
            "            rsv1=True,",
            "            data=b'*IMT\\x00\\x00\\x00\\x00\\xff\\xff',",
            "        ))",
            "        self.assertEqual(enc_frame2, frame2._replace(",
            "            rsv1=True,",
            "            data=b'*\\xc9\\xccM\\x05\\x00',",
            "        ))",
            "",
            "        dec_frame1 = self.extension.decode(enc_frame1)",
            "        dec_frame2 = self.extension.decode(enc_frame2)",
            "",
            "        self.assertEqual(dec_frame1, frame1)",
            "        self.assertEqual(dec_frame2, frame2)",
            "",
            "    def test_no_decode_text_frame(self):",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        # Try decoding a frame that wasn't encoded.",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    def test_no_decode_binary_frame(self):",
            "        frame = Frame(True, OP_TEXT, b'tea')",
            "",
            "        # Try decoding a frame that wasn't encoded.",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    def test_no_decode_fragmented_text_frame(self):",
            "        frame1 = Frame(False, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "        frame2 = Frame(False, OP_CONT, ' & '.encode('utf-8'))",
            "        frame3 = Frame(True, OP_CONT, 'croissants'.encode('utf-8'))",
            "",
            "        dec_frame1 = self.extension.decode(frame1)",
            "        dec_frame2 = self.extension.decode(frame2)",
            "        dec_frame3 = self.extension.decode(frame3)",
            "",
            "        self.assertEqual(dec_frame1, frame1)",
            "        self.assertEqual(dec_frame2, frame2)",
            "        self.assertEqual(dec_frame3, frame3)",
            "",
            "    def test_no_decode_fragmented_binary_frame(self):",
            "        frame1 = Frame(False, OP_TEXT, b'tea ')",
            "        frame2 = Frame(True, OP_CONT, b'time')",
            "",
            "        dec_frame1 = self.extension.decode(frame1)",
            "        dec_frame2 = self.extension.decode(frame2)",
            "",
            "        self.assertEqual(dec_frame1, frame1)",
            "        self.assertEqual(dec_frame2, frame2)",
            "",
            "    def test_context_takeover(self):",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame1 = self.extension.encode(frame)",
            "        enc_frame2 = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame1.data, b'JNL;\\xbc\\x12\\x00')",
            "        self.assertEqual(enc_frame2.data, b'J\\x06\\x11\\x00\\x00')",
            "",
            "    def test_remote_no_context_takeover(self):",
            "        # No context takeover when decoding messages.",
            "        self.extension = PerMessageDeflate(True, False, 15, 15)",
            "",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame1 = self.extension.encode(frame)",
            "        enc_frame2 = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame1.data, b'JNL;\\xbc\\x12\\x00')",
            "        self.assertEqual(enc_frame2.data, b'J\\x06\\x11\\x00\\x00')",
            "",
            "        dec_frame1 = self.extension.decode(enc_frame1)",
            "        self.assertEqual(dec_frame1, frame)",
            "",
            "        with self.assertRaises(zlib.error) as exc:",
            "            self.extension.decode(enc_frame2)",
            "        self.assertIn(\"invalid distance too far back\", str(exc.exception))",
            "",
            "    def test_local_no_context_takeover(self):",
            "        # No context takeover when encoding and decoding messages.",
            "        self.extension = PerMessageDeflate(True, True, 15, 15)",
            "",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame1 = self.extension.encode(frame)",
            "        enc_frame2 = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame1.data, b'JNL;\\xbc\\x12\\x00')",
            "        self.assertEqual(enc_frame2.data, b'JNL;\\xbc\\x12\\x00')",
            "",
            "        dec_frame1 = self.extension.decode(enc_frame1)",
            "        dec_frame2 = self.extension.decode(enc_frame2)",
            "",
            "        self.assertEqual(dec_frame1, frame)",
            "        self.assertEqual(dec_frame2, frame)",
            "",
            "    # Compression settings can be customized.",
            "",
            "    def test_compress_settings(self):",
            "        # Configure an extension so that no compression actually occurs.",
            "        extension = PerMessageDeflate(False, False, 15, 15, {'level': 0})",
            "",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame = extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame, frame._replace(",
            "            rsv1=True,",
            "            data=b'\\x00\\x05\\x00\\xfa\\xffcaf\\xc3\\xa9\\x00',    # not compressed",
            "        ))"
        ],
        "afterPatchFile": [
            "import unittest",
            "import zlib",
            "",
            "from ..exceptions import (",
            "    DuplicateParameter, InvalidParameterName, InvalidParameterValue,",
            "    NegotiationError, PayloadTooBig",
            ")",
            "from ..framing import (",
            "    OP_BINARY, OP_CLOSE, OP_CONT, OP_PING, OP_PONG, OP_TEXT, Frame,",
            "    serialize_close",
            ")",
            "from .permessage_deflate import *",
            "",
            "",
            "class ExtensionTestsMixin:",
            "",
            "    def assertExtensionEqual(self, extension1, extension2):",
            "        self.assertEqual(extension1.remote_no_context_takeover,",
            "                         extension2.remote_no_context_takeover)",
            "        self.assertEqual(extension1.local_no_context_takeover,",
            "                         extension2.local_no_context_takeover)",
            "        self.assertEqual(extension1.remote_max_window_bits,",
            "                         extension2.remote_max_window_bits)",
            "        self.assertEqual(extension1.local_max_window_bits,",
            "                         extension2.local_max_window_bits)",
            "",
            "",
            "class ClientPerMessageDeflateFactoryTests(unittest.TestCase,",
            "                                          ExtensionTestsMixin):",
            "",
            "    def test_name(self):",
            "        assert ClientPerMessageDeflateFactory.name == 'permessage-deflate'",
            "",
            "    def test_init(self):",
            "        for config in [",
            "            (False, False, 8, None),        # server_max_window_bits \u2265 8",
            "            (False, True, 15, None),        # server_max_window_bits \u2264 15",
            "            (True, False, None, 8),         # client_max_window_bits \u2265 8",
            "            (True, True, None, 15),         # client_max_window_bits \u2264 15",
            "            (False, False, None, True),     # client_max_window_bits",
            "            (False, False, None, None, {'memLevel': 4}),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                # This does not raise an exception.",
            "                ClientPerMessageDeflateFactory(*config)",
            "",
            "    def test_init_error(self):",
            "        for config in [",
            "            (False, False, 7, 8),           # server_max_window_bits < 8",
            "            (False, True, 8, 7),            # client_max_window_bits < 8",
            "            (True, False, 16, 15),          # server_max_window_bits > 15",
            "            (True, True, 15, 16),           # client_max_window_bits > 15",
            "            (False, False, True, None),     # server_max_window_bits",
            "            (False, False, None, None, {'wbits': 11}),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                with self.assertRaises(ValueError):",
            "                    ClientPerMessageDeflateFactory(*config)",
            "",
            "    def test_get_request_params(self):",
            "        for config, result in [",
            "            # Test without any parameter",
            "            (",
            "                (False, False, None, None),",
            "                [],",
            "            ),",
            "            # Test server_no_context_takeover",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "            ),",
            "            # Test client_no_context_takeover",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)],",
            "            ),",
            "            # Test server_max_window_bits",
            "            (",
            "                (False, False, 10, None),",
            "                [('server_max_window_bits', '10')],",
            "            ),",
            "            # Test client_max_window_bits",
            "            (",
            "                (False, False, None, 10),",
            "                [('client_max_window_bits', '10')],",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [('client_max_window_bits', None)],",
            "            ),",
            "            # Test all parameters together",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '12'),",
            "                    ('client_max_window_bits', '12'),",
            "                ],",
            "            ),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                factory = ClientPerMessageDeflateFactory(*config)",
            "                self.assertEqual(factory.get_request_params(), result)",
            "",
            "    def test_process_response_params(self):",
            "        for config, response_params, result in [",
            "            # Test without any parameter",
            "            (",
            "                (False, False, None, None),",
            "                [],",
            "                (False, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('unknown', None)],",
            "                InvalidParameterName,",
            "            ),",
            "            # Test server_no_context_takeover",
            "            (",
            "                (False, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)] * 2,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', '42')],",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test client_no_context_takeover",
            "            (",
            "                (False, False, None, None),",
            "                [('client_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)] * 2,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', '42')],",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test server_max_window_bits",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '7')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '10')],",
            "                (False, False, 10, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '16')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '10')],",
            "                (False, False, 10, 15),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '12')],",
            "                (False, False, 12, 15),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '13')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '12')] * 2,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '42')],",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test client_max_window_bits",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', '10')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [],",
            "                (False, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [('client_max_window_bits', '7')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [('client_max_window_bits', '10')],",
            "                (False, False, 15, 10),",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [('client_max_window_bits', '16')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '10')],",
            "                (False, False, 15, 10),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '12')],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '13')],",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '12')] * 2,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '42')],",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test all parameters together",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                (True, True, 10, 10),",
            "            ),",
            "            (",
            "                (False, False, None, True),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                (True, True, 10, 10),",
            "            ),",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('server_max_window_bits', '12'),",
            "                ],",
            "                (True, True, 12, 12),",
            "            ),",
            "        ]:",
            "            with self.subTest(",
            "                config=config,",
            "                response_params=response_params,",
            "            ):",
            "                factory = ClientPerMessageDeflateFactory(*config)",
            "                if isinstance(result, type) and issubclass(result, Exception):",
            "                    with self.assertRaises(result):",
            "                        factory.process_response_params(response_params, [])",
            "                else:",
            "                    extension = factory.process_response_params(",
            "                        response_params, [])",
            "                    expected = PerMessageDeflate(*result)",
            "                    self.assertExtensionEqual(extension, expected)",
            "",
            "    def test_process_response_params_deduplication(self):",
            "        factory = ClientPerMessageDeflateFactory(False, False, None, None)",
            "        with self.assertRaises(NegotiationError):",
            "            factory.process_response_params(",
            "                [], [PerMessageDeflate(False, False, 15, 15)])",
            "",
            "",
            "class ServerPerMessageDeflateFactoryTests(unittest.TestCase,",
            "                                          ExtensionTestsMixin):",
            "",
            "    def test_name(self):",
            "        assert ServerPerMessageDeflateFactory.name == 'permessage-deflate'",
            "",
            "    def test_init(self):",
            "        for config in [",
            "            (False, False, 8, None),        # server_max_window_bits \u2265 8",
            "            (False, True, 15, None),        # server_max_window_bits \u2264 15",
            "            (True, False, None, 8),         # client_max_window_bits \u2265 8",
            "            (True, True, None, 15),         # client_max_window_bits \u2264 15",
            "            (False, False, None, None, {'memLevel': 4}),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                # This does not raise an exception.",
            "                ServerPerMessageDeflateFactory(*config)",
            "",
            "    def test_init_error(self):",
            "        for config in [",
            "            (False, False, 7, 8),           # server_max_window_bits < 8",
            "            (False, True, 8, 7),            # client_max_window_bits < 8",
            "            (True, False, 16, 15),          # server_max_window_bits > 15",
            "            (True, True, 15, 16),           # client_max_window_bits > 15",
            "            (False, False, None, True),     # client_max_window_bits",
            "            (False, False, True, None),     # server_max_window_bits",
            "            (False, False, None, None, {'wbits': 11}),",
            "        ]:",
            "            with self.subTest(config=config):",
            "                with self.assertRaises(ValueError):",
            "                    ServerPerMessageDeflateFactory(*config)",
            "",
            "    def test_process_request_params(self):",
            "        # Parameters in result appear swapped vs. config because the order is",
            "        # (remote, local) vs. (server, client).",
            "        for config, request_params, response_params, result in [",
            "            # Test without any parameter",
            "            (",
            "                (False, False, None, None),",
            "                [],",
            "                [],",
            "                (False, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('unknown', None)],",
            "                None,",
            "                InvalidParameterName,",
            "            ),",
            "            # Test server_no_context_takeover",
            "            (",
            "                (False, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "                [('server_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [],",
            "                [('server_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)],",
            "                [('server_no_context_takeover', None)],",
            "                (False, True, 15, 15),",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', None)] * 2,",
            "                None,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (True, False, None, None),",
            "                [('server_no_context_takeover', '42')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test client_no_context_takeover",
            "            (",
            "                (False, False, None, None),",
            "                [('client_no_context_takeover', None)],",
            "                [('client_no_context_takeover', None)],     # doesn't matter",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [],",
            "                [('client_no_context_takeover', None)],",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)],",
            "                [('client_no_context_takeover', None)],     # doesn't matter",
            "                (True, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', None)] * 2,",
            "                None,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, True, None, None),",
            "                [('client_no_context_takeover', '42')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test server_max_window_bits",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '7')],",
            "                None,",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '10')],",
            "                [('server_max_window_bits', '10')],",
            "                (False, False, 15, 10),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('server_max_window_bits', '16')],",
            "                None,",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [],",
            "                [('server_max_window_bits', '12')],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '10')],",
            "                [('server_max_window_bits', '10')],",
            "                (False, False, 15, 10),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '12')],",
            "                [('server_max_window_bits', '12')],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '13')],",
            "                [('server_max_window_bits', '12')],",
            "                (False, False, 15, 12),",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '12')] * 2,",
            "                None,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, False, 12, None),",
            "                [('server_max_window_bits', '42')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            # Test client_max_window_bits",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', None)],",
            "                [],",
            "                (False, False, 15, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', '7')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', '10')],",
            "                [('client_max_window_bits', '10')],     # doesn't matter",
            "                (False, False, 10, 15),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [('client_max_window_bits', '16')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [],",
            "                None,",
            "                NegotiationError,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', None)],",
            "                [('client_max_window_bits', '12')],",
            "                (False, False, 12, 15),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '10')],",
            "                [('client_max_window_bits', '10')],",
            "                (False, False, 10, 15),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '12')],",
            "                [('client_max_window_bits', '12')],     # doesn't matter",
            "                (False, False, 12, 15),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '13')],",
            "                [('client_max_window_bits', '12')],     # doesn't matter",
            "                (False, False, 12, 15),",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '12')] * 2,",
            "                None,",
            "                DuplicateParameter,",
            "            ),",
            "            (",
            "                (False, False, None, 12),",
            "                [('client_max_window_bits', '42')],",
            "                None,",
            "                InvalidParameterValue,",
            "            ),",
            "            # # Test all parameters together",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                (True, True, 10, 10),",
            "            ),",
            "            (",
            "                (False, False, None, None),",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '10'),",
            "                    ('client_max_window_bits', '10'),",
            "                ],",
            "                (True, True, 10, 10),",
            "            ),",
            "            (",
            "                (True, True, 12, 12),",
            "                [",
            "                    ('client_max_window_bits', None),",
            "                ],",
            "                [",
            "                    ('server_no_context_takeover', None),",
            "                    ('client_no_context_takeover', None),",
            "                    ('server_max_window_bits', '12'),",
            "                    ('client_max_window_bits', '12'),",
            "                ],",
            "                (True, True, 12, 12),",
            "            ),",
            "        ]:",
            "            with self.subTest(",
            "                config=config,",
            "                request_params=request_params,",
            "                response_params=response_params,",
            "            ):",
            "                factory = ServerPerMessageDeflateFactory(*config)",
            "                if isinstance(result, type) and issubclass(result, Exception):",
            "                    with self.assertRaises(result):",
            "                        factory.process_request_params(request_params, [])",
            "                else:",
            "                    params, extension = factory.process_request_params(",
            "                        request_params, [])",
            "                    self.assertEqual(params, response_params)",
            "                    expected = PerMessageDeflate(*result)",
            "                    self.assertExtensionEqual(extension, expected)",
            "",
            "    def test_process_response_params_deduplication(self):",
            "        factory = ServerPerMessageDeflateFactory(False, False, None, None)",
            "        with self.assertRaises(NegotiationError):",
            "            factory.process_request_params(",
            "                [], [PerMessageDeflate(False, False, 15, 15)])",
            "",
            "",
            "class PerMessageDeflateTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        # Set up an instance of the permessage-deflate extension with the most",
            "        # common settings. Since the extension is symmetrical, this instance",
            "        # may be used for testing both encoding and decoding.",
            "        self.extension = PerMessageDeflate(False, False, 15, 15)",
            "",
            "    def test_name(self):",
            "        assert self.extension.name == 'permessage-deflate'",
            "",
            "    # Control frames aren't encoded or decoded.",
            "",
            "    def test_no_encode_decode_ping_frame(self):",
            "        frame = Frame(True, OP_PING, b'')",
            "",
            "        self.assertEqual(self.extension.encode(frame), frame)",
            "",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    def test_no_encode_decode_pong_frame(self):",
            "        frame = Frame(True, OP_PONG, b'')",
            "",
            "        self.assertEqual(self.extension.encode(frame), frame)",
            "",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    def test_no_encode_decode_close_frame(self):",
            "        frame = Frame(True, OP_CLOSE, serialize_close(1000, ''))",
            "",
            "        self.assertEqual(self.extension.encode(frame), frame)",
            "",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    # Data frames are encoded and decoded.",
            "",
            "    def test_encode_decode_text_frame(self):",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame, frame._replace(",
            "            rsv1=True,",
            "            data=b'JNL;\\xbc\\x12\\x00',",
            "        ))",
            "",
            "        dec_frame = self.extension.decode(enc_frame)",
            "",
            "        self.assertEqual(dec_frame, frame)",
            "",
            "    def test_encode_decode_binary_frame(self):",
            "        frame = Frame(True, OP_BINARY, b'tea')",
            "",
            "        enc_frame = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame, frame._replace(",
            "            rsv1=True,",
            "            data=b'*IM\\x04\\x00',",
            "        ))",
            "",
            "        dec_frame = self.extension.decode(enc_frame)",
            "",
            "        self.assertEqual(dec_frame, frame)",
            "",
            "    def test_encode_decode_fragmented_text_frame(self):",
            "        frame1 = Frame(False, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "        frame2 = Frame(False, OP_CONT, ' & '.encode('utf-8'))",
            "        frame3 = Frame(True, OP_CONT, 'croissants'.encode('utf-8'))",
            "",
            "        enc_frame1 = self.extension.encode(frame1)",
            "        enc_frame2 = self.extension.encode(frame2)",
            "        enc_frame3 = self.extension.encode(frame3)",
            "",
            "        self.assertEqual(enc_frame1, frame1._replace(",
            "            rsv1=True,",
            "            data=b'JNL;\\xbc\\x12\\x00\\x00\\x00\\xff\\xff',",
            "        ))",
            "        self.assertEqual(enc_frame2, frame2._replace(",
            "            rsv1=True,",
            "            data=b'RPS\\x00\\x00\\x00\\x00\\xff\\xff',",
            "        ))",
            "        self.assertEqual(enc_frame3, frame3._replace(",
            "            rsv1=True,",
            "            data=b'J.\\xca\\xcf,.N\\xcc+)\\x06\\x00',",
            "        ))",
            "",
            "        dec_frame1 = self.extension.decode(enc_frame1)",
            "        dec_frame2 = self.extension.decode(enc_frame2)",
            "        dec_frame3 = self.extension.decode(enc_frame3)",
            "",
            "        self.assertEqual(dec_frame1, frame1)",
            "        self.assertEqual(dec_frame2, frame2)",
            "        self.assertEqual(dec_frame3, frame3)",
            "",
            "    def test_encode_decode_fragmented_binary_frame(self):",
            "        frame1 = Frame(False, OP_TEXT, b'tea ')",
            "        frame2 = Frame(True, OP_CONT, b'time')",
            "",
            "        enc_frame1 = self.extension.encode(frame1)",
            "        enc_frame2 = self.extension.encode(frame2)",
            "",
            "        self.assertEqual(enc_frame1, frame1._replace(",
            "            rsv1=True,",
            "            data=b'*IMT\\x00\\x00\\x00\\x00\\xff\\xff',",
            "        ))",
            "        self.assertEqual(enc_frame2, frame2._replace(",
            "            rsv1=True,",
            "            data=b'*\\xc9\\xccM\\x05\\x00',",
            "        ))",
            "",
            "        dec_frame1 = self.extension.decode(enc_frame1)",
            "        dec_frame2 = self.extension.decode(enc_frame2)",
            "",
            "        self.assertEqual(dec_frame1, frame1)",
            "        self.assertEqual(dec_frame2, frame2)",
            "",
            "    def test_no_decode_text_frame(self):",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        # Try decoding a frame that wasn't encoded.",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    def test_no_decode_binary_frame(self):",
            "        frame = Frame(True, OP_TEXT, b'tea')",
            "",
            "        # Try decoding a frame that wasn't encoded.",
            "        self.assertEqual(self.extension.decode(frame), frame)",
            "",
            "    def test_no_decode_fragmented_text_frame(self):",
            "        frame1 = Frame(False, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "        frame2 = Frame(False, OP_CONT, ' & '.encode('utf-8'))",
            "        frame3 = Frame(True, OP_CONT, 'croissants'.encode('utf-8'))",
            "",
            "        dec_frame1 = self.extension.decode(frame1)",
            "        dec_frame2 = self.extension.decode(frame2)",
            "        dec_frame3 = self.extension.decode(frame3)",
            "",
            "        self.assertEqual(dec_frame1, frame1)",
            "        self.assertEqual(dec_frame2, frame2)",
            "        self.assertEqual(dec_frame3, frame3)",
            "",
            "    def test_no_decode_fragmented_binary_frame(self):",
            "        frame1 = Frame(False, OP_TEXT, b'tea ')",
            "        frame2 = Frame(True, OP_CONT, b'time')",
            "",
            "        dec_frame1 = self.extension.decode(frame1)",
            "        dec_frame2 = self.extension.decode(frame2)",
            "",
            "        self.assertEqual(dec_frame1, frame1)",
            "        self.assertEqual(dec_frame2, frame2)",
            "",
            "    def test_context_takeover(self):",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame1 = self.extension.encode(frame)",
            "        enc_frame2 = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame1.data, b'JNL;\\xbc\\x12\\x00')",
            "        self.assertEqual(enc_frame2.data, b'J\\x06\\x11\\x00\\x00')",
            "",
            "    def test_remote_no_context_takeover(self):",
            "        # No context takeover when decoding messages.",
            "        self.extension = PerMessageDeflate(True, False, 15, 15)",
            "",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame1 = self.extension.encode(frame)",
            "        enc_frame2 = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame1.data, b'JNL;\\xbc\\x12\\x00')",
            "        self.assertEqual(enc_frame2.data, b'J\\x06\\x11\\x00\\x00')",
            "",
            "        dec_frame1 = self.extension.decode(enc_frame1)",
            "        self.assertEqual(dec_frame1, frame)",
            "",
            "        with self.assertRaises(zlib.error) as exc:",
            "            self.extension.decode(enc_frame2)",
            "        self.assertIn(\"invalid distance too far back\", str(exc.exception))",
            "",
            "    def test_local_no_context_takeover(self):",
            "        # No context takeover when encoding and decoding messages.",
            "        self.extension = PerMessageDeflate(True, True, 15, 15)",
            "",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame1 = self.extension.encode(frame)",
            "        enc_frame2 = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame1.data, b'JNL;\\xbc\\x12\\x00')",
            "        self.assertEqual(enc_frame2.data, b'JNL;\\xbc\\x12\\x00')",
            "",
            "        dec_frame1 = self.extension.decode(enc_frame1)",
            "        dec_frame2 = self.extension.decode(enc_frame2)",
            "",
            "        self.assertEqual(dec_frame1, frame)",
            "        self.assertEqual(dec_frame2, frame)",
            "",
            "    # Compression settings can be customized.",
            "",
            "    def test_compress_settings(self):",
            "        # Configure an extension so that no compression actually occurs.",
            "        extension = PerMessageDeflate(False, False, 15, 15, {'level': 0})",
            "",
            "        frame = Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8'))",
            "",
            "        enc_frame = extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame, frame._replace(",
            "            rsv1=True,",
            "            data=b'\\x00\\x05\\x00\\xfa\\xffcaf\\xc3\\xa9\\x00',    # not compressed",
            "        ))",
            "",
            "    # Frames aren't decoded beyond max_length.",
            "",
            "    def test_decompress_max_size(self):",
            "        frame = Frame(True, OP_TEXT, ('a' * 20).encode('utf-8'))",
            "",
            "        enc_frame = self.extension.encode(frame)",
            "",
            "        self.assertEqual(enc_frame.data, b'JL\\xc4\\x04\\x00\\x00')",
            "",
            "        with self.assertRaises(PayloadTooBig):",
            "            self.extension.decode(enc_frame, max_size=10)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "6": []
        },
        "addLocation": []
    },
    "websockets/framing.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "             length, = struct.unpack('!Q', data)"
            },
            "1": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         if max_size is not None and length > max_size:"
            },
            "2": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "             raise PayloadTooBig("
            },
            "3": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"Payload length exceeds limit: {} > {} bytes\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                \"Payload length exceeds size limit ({} > {} bytes)\""
            },
            "5": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "                 .format(length, max_size))"
            },
            "6": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         if mask:"
            },
            "7": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "             mask_bits = yield from reader(4)"
            },
            "8": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         if extensions is None:"
            },
            "9": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             extensions = []"
            },
            "10": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         for extension in reversed(extensions):"
            },
            "11": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            frame = extension.decode(frame)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            frame = extension.decode(frame, max_size=max_size)"
            },
            "13": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         frame.check()"
            },
            "15": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "The :mod:`websockets.framing` module implements data framing as specified in",
            "`section 5 of RFC 6455`_.",
            "",
            "It deals with a single frame at a time. Anything that depends on the sequence",
            "of frames is implemented in :mod:`websockets.protocol`.",
            "",
            ".. _section 5 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-5",
            "",
            "\"\"\"",
            "",
            "import asyncio",
            "import collections",
            "import io",
            "import random",
            "import struct",
            "",
            "from .exceptions import PayloadTooBig, WebSocketProtocolError",
            "",
            "",
            "try:",
            "    from .speedups import apply_mask",
            "except ImportError:                                         # pragma: no cover",
            "    from .utils import apply_mask",
            "",
            "",
            "__all__ = [",
            "    'DATA_OPCODES', 'CTRL_OPCODES',",
            "    'OP_CONT', 'OP_TEXT', 'OP_BINARY', 'OP_CLOSE', 'OP_PING', 'OP_PONG',",
            "    'Frame', 'encode_data', 'parse_close', 'serialize_close'",
            "]",
            "",
            "DATA_OPCODES = OP_CONT, OP_TEXT, OP_BINARY = 0x00, 0x01, 0x02",
            "CTRL_OPCODES = OP_CLOSE, OP_PING, OP_PONG = 0x08, 0x09, 0x0a",
            "",
            "# Close code that are allowed in a close frame.",
            "# Using a list optimizes `code in EXTERNAL_CLOSE_CODES`.",
            "EXTERNAL_CLOSE_CODES = [",
            "    1000,",
            "    1001,",
            "    1002,",
            "    1003,",
            "    1007,",
            "    1008,",
            "    1009,",
            "    1010,",
            "    1011,",
            "]",
            "",
            "FrameData = collections.namedtuple(",
            "    'FrameData',",
            "    ['fin', 'opcode', 'data', 'rsv1', 'rsv2', 'rsv3'],",
            ")",
            "",
            "",
            "class Frame(FrameData):",
            "    \"\"\"",
            "    WebSocket frame.",
            "",
            "    * ``fin`` is the FIN bit",
            "    * ``rsv1`` is the RSV1 bit",
            "    * ``rsv2`` is the RSV2 bit",
            "    * ``rsv3`` is the RSV3 bit",
            "    * ``opcode`` is the opcode",
            "    * ``data`` is the payload data",
            "",
            "    Only these fields are needed by higher level code. The MASK bit, payload",
            "    length and masking-key are handled on the fly by :meth:`read` and",
            "    :meth:`write`.",
            "",
            "    \"\"\"",
            "    def __new__(cls, fin, opcode, data, rsv1=False, rsv2=False, rsv3=False):",
            "        return FrameData.__new__(cls, fin, opcode, data, rsv1, rsv2, rsv3)",
            "",
            "    @classmethod",
            "    @asyncio.coroutine",
            "    def read(cls, reader, *, mask, max_size=None, extensions=None):",
            "        \"\"\"",
            "        Read a WebSocket frame and return a :class:`Frame` object.",
            "",
            "        ``reader`` is a coroutine taking an integer argument and reading",
            "        exactly this number of bytes, unless the end of file is reached.",
            "",
            "        ``mask`` is a :class:`bool` telling whether the frame should be masked",
            "        i.e. whether the read happens on the server side.",
            "",
            "        If ``max_size`` is set and the payload exceeds this size in bytes,",
            "        :exc:`~websockets.exceptions.PayloadTooBig` is raised.",
            "",
            "        If ``extensions`` is provided, it's a list of classes with an",
            "        ``decode()`` method that transform the frame and return a new frame.",
            "        They are applied in reverse order.",
            "",
            "        This function validates the frame before returning it and raises",
            "        :exc:`~websockets.exceptions.WebSocketProtocolError` if it contains",
            "        incorrect values.",
            "",
            "        \"\"\"",
            "        # Read the header.",
            "        data = yield from reader(2)",
            "        head1, head2 = struct.unpack('!BB', data)",
            "",
            "        # While not Pythonic, this is marginally faster than calling bool().",
            "        fin = True if head1 & 0b10000000 else False",
            "        rsv1 = True if head1 & 0b01000000 else False",
            "        rsv2 = True if head1 & 0b00100000 else False",
            "        rsv3 = True if head1 & 0b00010000 else False",
            "        opcode = head1 & 0b00001111",
            "",
            "        if (True if head2 & 0b10000000 else False) != mask:",
            "            raise WebSocketProtocolError(\"Incorrect masking\")",
            "",
            "        length = head2 & 0b01111111",
            "        if length == 126:",
            "            data = yield from reader(2)",
            "            length, = struct.unpack('!H', data)",
            "        elif length == 127:",
            "            data = yield from reader(8)",
            "            length, = struct.unpack('!Q', data)",
            "        if max_size is not None and length > max_size:",
            "            raise PayloadTooBig(",
            "                \"Payload length exceeds limit: {} > {} bytes\"",
            "                .format(length, max_size))",
            "        if mask:",
            "            mask_bits = yield from reader(4)",
            "",
            "        # Read the data.",
            "        data = yield from reader(length)",
            "        if mask:",
            "            data = apply_mask(data, mask_bits)",
            "",
            "        frame = cls(fin, opcode, data, rsv1, rsv2, rsv3)",
            "",
            "        if extensions is None:",
            "            extensions = []",
            "        for extension in reversed(extensions):",
            "            frame = extension.decode(frame)",
            "",
            "        frame.check()",
            "",
            "        return frame",
            "",
            "    def write(frame, writer, *, mask, extensions=None):",
            "        \"\"\"",
            "        Write a WebSocket frame.",
            "",
            "        ``frame`` is the :class:`Frame` object to write.",
            "",
            "        ``writer`` is a function accepting bytes.",
            "",
            "        ``mask`` is a :class:`bool` telling whether the frame should be masked",
            "        i.e. whether the write happens on the client side.",
            "",
            "        If ``extensions`` is provided, it's a list of classes with an",
            "        ``encode()`` method that transform the frame and return a new frame.",
            "        They are applied in order.",
            "",
            "        This function validates the frame before sending it and raises",
            "        :exc:`~websockets.exceptions.WebSocketProtocolError` if it contains",
            "        incorrect values.",
            "",
            "        \"\"\"",
            "        # The first parameter is called `frame` rather than `self`,",
            "        # but it's the instance of class to which this method is bound.",
            "",
            "        frame.check()",
            "",
            "        if extensions is None:",
            "            extensions = []",
            "        for extension in extensions:",
            "            frame = extension.encode(frame)",
            "",
            "        output = io.BytesIO()",
            "",
            "        # Prepare the header.",
            "        head1 = (",
            "            (0b10000000 if frame.fin else 0) |",
            "            (0b01000000 if frame.rsv1 else 0) |",
            "            (0b00100000 if frame.rsv2 else 0) |",
            "            (0b00010000 if frame.rsv3 else 0) |",
            "            frame.opcode",
            "        )",
            "",
            "        head2 = 0b10000000 if mask else 0",
            "",
            "        length = len(frame.data)",
            "        if length < 126:",
            "            output.write(struct.pack('!BB', head1, head2 | length))",
            "        elif length < 65536:",
            "            output.write(struct.pack('!BBH', head1, head2 | 126, length))",
            "        else:",
            "            output.write(struct.pack('!BBQ', head1, head2 | 127, length))",
            "",
            "        if mask:",
            "            mask_bits = struct.pack('!I', random.getrandbits(32))",
            "            output.write(mask_bits)",
            "",
            "        # Prepare the data.",
            "        if mask:",
            "            data = apply_mask(frame.data, mask_bits)",
            "        else:",
            "            data = frame.data",
            "        output.write(data)",
            "",
            "        # Send the frame.",
            "",
            "        # The frame is written in a single call to writer in order to prevent",
            "        # TCP fragmentation. See #68 for details. This also makes it safe to",
            "        # send frames concurrently from multiple coroutines.",
            "        writer(output.getvalue())",
            "",
            "    def check(frame):",
            "        \"\"\"",
            "        Check that this frame contains acceptable values.",
            "",
            "        Raise :exc:`~websockets.exceptions.WebSocketProtocolError` if this",
            "        frame contains incorrect values.",
            "",
            "        \"\"\"",
            "        # The first parameter is called `frame` rather than `self`,",
            "        # but it's the instance of class to which this method is bound.",
            "",
            "        if frame.rsv1 or frame.rsv2 or frame.rsv3:",
            "            raise WebSocketProtocolError(\"Reserved bits must be 0\")",
            "",
            "        if frame.opcode in DATA_OPCODES:",
            "            return",
            "        elif frame.opcode in CTRL_OPCODES:",
            "            if len(frame.data) > 125:",
            "                raise WebSocketProtocolError(\"Control frame too long\")",
            "            if not frame.fin:",
            "                raise WebSocketProtocolError(\"Fragmented control frame\")",
            "        else:",
            "            raise WebSocketProtocolError(",
            "                \"Invalid opcode: {}\".format(frame.opcode))",
            "",
            "",
            "def encode_data(data):",
            "    \"\"\"",
            "    Helper that converts :class:`str` or :class:`bytes` to :class:`bytes`.",
            "",
            "    :class:`str` are encoded with UTF-8.",
            "",
            "    \"\"\"",
            "    # Expect str or bytes, return bytes.",
            "    if isinstance(data, str):",
            "        return data.encode('utf-8')",
            "    elif isinstance(data, bytes):",
            "        return data",
            "    else:",
            "        raise TypeError(\"data must be bytes or str\")",
            "",
            "",
            "def parse_close(data):",
            "    \"\"\"",
            "    Parse the data in a close frame.",
            "",
            "    Return ``(code, reason)`` when ``code`` is an :class:`int` and ``reason``",
            "    a :class:`str`.",
            "",
            "    Raise :exc:`~websockets.exceptions.WebSocketProtocolError` or",
            "    :exc:`UnicodeDecodeError` if the data is invalid.",
            "",
            "    \"\"\"",
            "    length = len(data)",
            "    if length >= 2:",
            "        code, = struct.unpack('!H', data[:2])",
            "        check_close(code)",
            "        reason = data[2:].decode('utf-8')",
            "        return code, reason",
            "    elif length == 0:",
            "        return 1005, ''",
            "    else:",
            "        assert length == 1",
            "        raise WebSocketProtocolError(\"Close frame too short\")",
            "",
            "",
            "def serialize_close(code, reason):",
            "    \"\"\"",
            "    Serialize the data for a close frame.",
            "",
            "    This is the reverse of :func:`parse_close`.",
            "",
            "    \"\"\"",
            "    check_close(code)",
            "    return struct.pack('!H', code) + reason.encode('utf-8')",
            "",
            "",
            "def check_close(code):",
            "    \"\"\"",
            "    Check the close code for a close frame.",
            "",
            "    \"\"\"",
            "    if not (code in EXTERNAL_CLOSE_CODES or 3000 <= code < 5000):",
            "        raise WebSocketProtocolError(\"Invalid status code\")"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "The :mod:`websockets.framing` module implements data framing as specified in",
            "`section 5 of RFC 6455`_.",
            "",
            "It deals with a single frame at a time. Anything that depends on the sequence",
            "of frames is implemented in :mod:`websockets.protocol`.",
            "",
            ".. _section 5 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-5",
            "",
            "\"\"\"",
            "",
            "import asyncio",
            "import collections",
            "import io",
            "import random",
            "import struct",
            "",
            "from .exceptions import PayloadTooBig, WebSocketProtocolError",
            "",
            "",
            "try:",
            "    from .speedups import apply_mask",
            "except ImportError:                                         # pragma: no cover",
            "    from .utils import apply_mask",
            "",
            "",
            "__all__ = [",
            "    'DATA_OPCODES', 'CTRL_OPCODES',",
            "    'OP_CONT', 'OP_TEXT', 'OP_BINARY', 'OP_CLOSE', 'OP_PING', 'OP_PONG',",
            "    'Frame', 'encode_data', 'parse_close', 'serialize_close'",
            "]",
            "",
            "DATA_OPCODES = OP_CONT, OP_TEXT, OP_BINARY = 0x00, 0x01, 0x02",
            "CTRL_OPCODES = OP_CLOSE, OP_PING, OP_PONG = 0x08, 0x09, 0x0a",
            "",
            "# Close code that are allowed in a close frame.",
            "# Using a list optimizes `code in EXTERNAL_CLOSE_CODES`.",
            "EXTERNAL_CLOSE_CODES = [",
            "    1000,",
            "    1001,",
            "    1002,",
            "    1003,",
            "    1007,",
            "    1008,",
            "    1009,",
            "    1010,",
            "    1011,",
            "]",
            "",
            "FrameData = collections.namedtuple(",
            "    'FrameData',",
            "    ['fin', 'opcode', 'data', 'rsv1', 'rsv2', 'rsv3'],",
            ")",
            "",
            "",
            "class Frame(FrameData):",
            "    \"\"\"",
            "    WebSocket frame.",
            "",
            "    * ``fin`` is the FIN bit",
            "    * ``rsv1`` is the RSV1 bit",
            "    * ``rsv2`` is the RSV2 bit",
            "    * ``rsv3`` is the RSV3 bit",
            "    * ``opcode`` is the opcode",
            "    * ``data`` is the payload data",
            "",
            "    Only these fields are needed by higher level code. The MASK bit, payload",
            "    length and masking-key are handled on the fly by :meth:`read` and",
            "    :meth:`write`.",
            "",
            "    \"\"\"",
            "    def __new__(cls, fin, opcode, data, rsv1=False, rsv2=False, rsv3=False):",
            "        return FrameData.__new__(cls, fin, opcode, data, rsv1, rsv2, rsv3)",
            "",
            "    @classmethod",
            "    @asyncio.coroutine",
            "    def read(cls, reader, *, mask, max_size=None, extensions=None):",
            "        \"\"\"",
            "        Read a WebSocket frame and return a :class:`Frame` object.",
            "",
            "        ``reader`` is a coroutine taking an integer argument and reading",
            "        exactly this number of bytes, unless the end of file is reached.",
            "",
            "        ``mask`` is a :class:`bool` telling whether the frame should be masked",
            "        i.e. whether the read happens on the server side.",
            "",
            "        If ``max_size`` is set and the payload exceeds this size in bytes,",
            "        :exc:`~websockets.exceptions.PayloadTooBig` is raised.",
            "",
            "        If ``extensions`` is provided, it's a list of classes with an",
            "        ``decode()`` method that transform the frame and return a new frame.",
            "        They are applied in reverse order.",
            "",
            "        This function validates the frame before returning it and raises",
            "        :exc:`~websockets.exceptions.WebSocketProtocolError` if it contains",
            "        incorrect values.",
            "",
            "        \"\"\"",
            "        # Read the header.",
            "        data = yield from reader(2)",
            "        head1, head2 = struct.unpack('!BB', data)",
            "",
            "        # While not Pythonic, this is marginally faster than calling bool().",
            "        fin = True if head1 & 0b10000000 else False",
            "        rsv1 = True if head1 & 0b01000000 else False",
            "        rsv2 = True if head1 & 0b00100000 else False",
            "        rsv3 = True if head1 & 0b00010000 else False",
            "        opcode = head1 & 0b00001111",
            "",
            "        if (True if head2 & 0b10000000 else False) != mask:",
            "            raise WebSocketProtocolError(\"Incorrect masking\")",
            "",
            "        length = head2 & 0b01111111",
            "        if length == 126:",
            "            data = yield from reader(2)",
            "            length, = struct.unpack('!H', data)",
            "        elif length == 127:",
            "            data = yield from reader(8)",
            "            length, = struct.unpack('!Q', data)",
            "        if max_size is not None and length > max_size:",
            "            raise PayloadTooBig(",
            "                \"Payload length exceeds size limit ({} > {} bytes)\"",
            "                .format(length, max_size))",
            "        if mask:",
            "            mask_bits = yield from reader(4)",
            "",
            "        # Read the data.",
            "        data = yield from reader(length)",
            "        if mask:",
            "            data = apply_mask(data, mask_bits)",
            "",
            "        frame = cls(fin, opcode, data, rsv1, rsv2, rsv3)",
            "",
            "        if extensions is None:",
            "            extensions = []",
            "        for extension in reversed(extensions):",
            "            frame = extension.decode(frame, max_size=max_size)",
            "",
            "        frame.check()",
            "",
            "        return frame",
            "",
            "    def write(frame, writer, *, mask, extensions=None):",
            "        \"\"\"",
            "        Write a WebSocket frame.",
            "",
            "        ``frame`` is the :class:`Frame` object to write.",
            "",
            "        ``writer`` is a function accepting bytes.",
            "",
            "        ``mask`` is a :class:`bool` telling whether the frame should be masked",
            "        i.e. whether the write happens on the client side.",
            "",
            "        If ``extensions`` is provided, it's a list of classes with an",
            "        ``encode()`` method that transform the frame and return a new frame.",
            "        They are applied in order.",
            "",
            "        This function validates the frame before sending it and raises",
            "        :exc:`~websockets.exceptions.WebSocketProtocolError` if it contains",
            "        incorrect values.",
            "",
            "        \"\"\"",
            "        # The first parameter is called `frame` rather than `self`,",
            "        # but it's the instance of class to which this method is bound.",
            "",
            "        frame.check()",
            "",
            "        if extensions is None:",
            "            extensions = []",
            "        for extension in extensions:",
            "            frame = extension.encode(frame)",
            "",
            "        output = io.BytesIO()",
            "",
            "        # Prepare the header.",
            "        head1 = (",
            "            (0b10000000 if frame.fin else 0) |",
            "            (0b01000000 if frame.rsv1 else 0) |",
            "            (0b00100000 if frame.rsv2 else 0) |",
            "            (0b00010000 if frame.rsv3 else 0) |",
            "            frame.opcode",
            "        )",
            "",
            "        head2 = 0b10000000 if mask else 0",
            "",
            "        length = len(frame.data)",
            "        if length < 126:",
            "            output.write(struct.pack('!BB', head1, head2 | length))",
            "        elif length < 65536:",
            "            output.write(struct.pack('!BBH', head1, head2 | 126, length))",
            "        else:",
            "            output.write(struct.pack('!BBQ', head1, head2 | 127, length))",
            "",
            "        if mask:",
            "            mask_bits = struct.pack('!I', random.getrandbits(32))",
            "            output.write(mask_bits)",
            "",
            "        # Prepare the data.",
            "        if mask:",
            "            data = apply_mask(frame.data, mask_bits)",
            "        else:",
            "            data = frame.data",
            "        output.write(data)",
            "",
            "        # Send the frame.",
            "",
            "        # The frame is written in a single call to writer in order to prevent",
            "        # TCP fragmentation. See #68 for details. This also makes it safe to",
            "        # send frames concurrently from multiple coroutines.",
            "        writer(output.getvalue())",
            "",
            "    def check(frame):",
            "        \"\"\"",
            "        Check that this frame contains acceptable values.",
            "",
            "        Raise :exc:`~websockets.exceptions.WebSocketProtocolError` if this",
            "        frame contains incorrect values.",
            "",
            "        \"\"\"",
            "        # The first parameter is called `frame` rather than `self`,",
            "        # but it's the instance of class to which this method is bound.",
            "",
            "        if frame.rsv1 or frame.rsv2 or frame.rsv3:",
            "            raise WebSocketProtocolError(\"Reserved bits must be 0\")",
            "",
            "        if frame.opcode in DATA_OPCODES:",
            "            return",
            "        elif frame.opcode in CTRL_OPCODES:",
            "            if len(frame.data) > 125:",
            "                raise WebSocketProtocolError(\"Control frame too long\")",
            "            if not frame.fin:",
            "                raise WebSocketProtocolError(\"Fragmented control frame\")",
            "        else:",
            "            raise WebSocketProtocolError(",
            "                \"Invalid opcode: {}\".format(frame.opcode))",
            "",
            "",
            "def encode_data(data):",
            "    \"\"\"",
            "    Helper that converts :class:`str` or :class:`bytes` to :class:`bytes`.",
            "",
            "    :class:`str` are encoded with UTF-8.",
            "",
            "    \"\"\"",
            "    # Expect str or bytes, return bytes.",
            "    if isinstance(data, str):",
            "        return data.encode('utf-8')",
            "    elif isinstance(data, bytes):",
            "        return data",
            "    else:",
            "        raise TypeError(\"data must be bytes or str\")",
            "",
            "",
            "def parse_close(data):",
            "    \"\"\"",
            "    Parse the data in a close frame.",
            "",
            "    Return ``(code, reason)`` when ``code`` is an :class:`int` and ``reason``",
            "    a :class:`str`.",
            "",
            "    Raise :exc:`~websockets.exceptions.WebSocketProtocolError` or",
            "    :exc:`UnicodeDecodeError` if the data is invalid.",
            "",
            "    \"\"\"",
            "    length = len(data)",
            "    if length >= 2:",
            "        code, = struct.unpack('!H', data[:2])",
            "        check_close(code)",
            "        reason = data[2:].decode('utf-8')",
            "        return code, reason",
            "    elif length == 0:",
            "        return 1005, ''",
            "    else:",
            "        assert length == 1",
            "        raise WebSocketProtocolError(\"Close frame too short\")",
            "",
            "",
            "def serialize_close(code, reason):",
            "    \"\"\"",
            "    Serialize the data for a close frame.",
            "",
            "    This is the reverse of :func:`parse_close`.",
            "",
            "    \"\"\"",
            "    check_close(code)",
            "    return struct.pack('!H', code) + reason.encode('utf-8')",
            "",
            "",
            "def check_close(code):",
            "    \"\"\"",
            "    Check the close code for a close frame.",
            "",
            "    \"\"\"",
            "    if not (code in EXTERNAL_CLOSE_CODES or 3000 <= code < 5000):",
            "        raise WebSocketProtocolError(\"Invalid status code\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "122": [
                "Frame",
                "read"
            ],
            "137": [
                "Frame",
                "read"
            ]
        },
        "addLocation": []
    },
    "websockets/test_client_server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "     def __repr__(self):"
            },
            "1": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "         return 'NoOpExtension()'"
            },
            "2": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 206,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def decode(self, frame):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+    def decode(self, frame, *, max_size=None):"
            },
            "5": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         return frame"
            },
            "6": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 209,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "     def encode(self, frame):"
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import contextlib",
            "import functools",
            "import logging",
            "import pathlib",
            "import random",
            "import socket",
            "import ssl",
            "import sys",
            "import tempfile",
            "import unittest",
            "import unittest.mock",
            "import urllib.error",
            "import urllib.request",
            "",
            "from .client import *",
            "from .compatibility import FORBIDDEN, OK, UNAUTHORIZED",
            "from .exceptions import (",
            "    ConnectionClosed, InvalidHandshake, InvalidStatusCode, NegotiationError",
            ")",
            "from .extensions.permessage_deflate import (",
            "    ClientPerMessageDeflateFactory, PerMessageDeflate,",
            "    ServerPerMessageDeflateFactory",
            ")",
            "from .handshake import build_response",
            "from .http import USER_AGENT, read_response",
            "from .server import *",
            "from .test_protocol import MS",
            "",
            "",
            "# Avoid displaying stack traces at the ERROR logging level.",
            "logging.basicConfig(level=logging.CRITICAL)",
            "",
            "",
            "# Generate TLS certificate with:",
            "# $ openssl req -x509 -config test_localhost.cnf -days 15340 -newkey rsa:2048 \\",
            "#       -out test_localhost.crt -keyout test_localhost.key",
            "# $ cat test_localhost.key test_localhost.crt > test_localhost.pem",
            "# $ rm test_localhost.key test_localhost.crt",
            "",
            "testcert = bytes(pathlib.Path(__file__).with_name('test_localhost.pem'))",
            "",
            "",
            "@asyncio.coroutine",
            "def handler(ws, path):",
            "    if path == '/attributes':",
            "        yield from ws.send(repr((ws.host, ws.port, ws.secure)))",
            "    elif path == '/path':",
            "        yield from ws.send(str(ws.path))",
            "    elif path == '/headers':",
            "        yield from ws.send(str(ws.request_headers))",
            "        yield from ws.send(str(ws.response_headers))",
            "    elif path == '/raw_headers':",
            "        yield from ws.send(repr(ws.raw_request_headers))",
            "        yield from ws.send(repr(ws.raw_response_headers))",
            "    elif path == '/extensions':",
            "        yield from ws.send(repr(ws.extensions))",
            "    elif path == '/subprotocol':",
            "        yield from ws.send(repr(ws.subprotocol))",
            "    elif path == '/slow_stop':",
            "        try:",
            "            yield from asyncio.sleep(1000 * MS)",
            "        except asyncio.CancelledError:",
            "            yield from asyncio.sleep(MS)",
            "            raise",
            "    else:",
            "        yield from ws.send((yield from ws.recv()))",
            "",
            "",
            "@contextlib.contextmanager",
            "def temp_test_server(test, **kwds):",
            "    test.start_server(**kwds)",
            "    try:",
            "        yield",
            "    finally:",
            "        test.stop_server()",
            "",
            "",
            "@contextlib.contextmanager",
            "def temp_test_client(test, *args, **kwds):",
            "    test.start_client(*args, **kwds)",
            "    try:",
            "        yield",
            "    finally:",
            "        test.stop_client()",
            "",
            "",
            "def with_manager(manager, *args, **kwds):",
            "    \"\"\"",
            "    Return a decorator that wraps a function with a context manager.",
            "",
            "    \"\"\"",
            "    def decorate(func):",
            "        @functools.wraps(func)",
            "        def _decorate(self, *_args, **_kwds):",
            "            with manager(self, *args, **kwds):",
            "                return func(self, *_args, **_kwds)",
            "",
            "        return _decorate",
            "",
            "    return decorate",
            "",
            "",
            "def with_server(**kwds):",
            "    \"\"\"",
            "    Return a decorator for TestCase methods that starts and stops a server.",
            "",
            "    \"\"\"",
            "    return with_manager(temp_test_server, **kwds)",
            "",
            "",
            "def with_client(*args, **kwds):",
            "    \"\"\"",
            "    Return a decorator for TestCase methods that starts and stops a client.",
            "",
            "    \"\"\"",
            "    return with_manager(temp_test_client, *args, **kwds)",
            "",
            "",
            "def get_server_uri(server, secure=False, resource_name='/', user_info=None):",
            "    \"\"\"",
            "    Return a WebSocket URI for connecting to the given server.",
            "",
            "    \"\"\"",
            "    proto = 'wss' if secure else 'ws'",
            "",
            "    user_info = ':'.join(user_info) + '@' if user_info else ''",
            "",
            "    # Pick a random socket in order to test both IPv4 and IPv6 on systems",
            "    # where both are available. Randomizing tests is usually a bad idea. If",
            "    # needed, either use the first socket, or test separately IPv4 and IPv6.",
            "    server_socket = random.choice(server.sockets)",
            "",
            "    if server_socket.family == socket.AF_INET6:             # pragma: no cover",
            "        host, port = server_socket.getsockname()[:2]        # (no IPv6 on CI)",
            "        host = '[{}]'.format(host)",
            "    elif server_socket.family == socket.AF_INET:",
            "        host, port = server_socket.getsockname()",
            "    elif server_socket.family == socket.AF_UNIX:",
            "        # The host and port are ignored when connecting to a Unix socket.",
            "        host, port = 'localhost', 0",
            "    else:                                                   # pragma: no cover",
            "        raise ValueError(\"Expected an IPv6, IPv4, or Unix socket\")",
            "",
            "    return '{}://{}{}:{}{}'.format(proto, user_info, host, port, resource_name)",
            "",
            "",
            "class UnauthorizedServerProtocol(WebSocketServerProtocol):",
            "",
            "    @asyncio.coroutine",
            "    def process_request(self, path, request_headers):",
            "        return UNAUTHORIZED, []",
            "",
            "",
            "class ForbiddenServerProtocol(WebSocketServerProtocol):",
            "",
            "    @asyncio.coroutine",
            "    def process_request(self, path, request_headers):",
            "        return FORBIDDEN, []",
            "",
            "",
            "class HealthCheckServerProtocol(WebSocketServerProtocol):",
            "",
            "    @asyncio.coroutine",
            "    def process_request(self, path, request_headers):",
            "        if path == '/__health__/':",
            "            body = b'status = green\\n'",
            "            return OK, [('Content-Length', str(len(body)))], body",
            "",
            "",
            "class FooClientProtocol(WebSocketClientProtocol):",
            "    pass",
            "",
            "",
            "class BarClientProtocol(WebSocketClientProtocol):",
            "    pass",
            "",
            "",
            "class ClientNoOpExtensionFactory:",
            "    name = 'x-no-op'",
            "",
            "    def get_request_params(self):",
            "        return []",
            "",
            "    def process_response_params(self, params, accepted_extensions):",
            "        if params:",
            "            raise NegotiationError()",
            "        return NoOpExtension()",
            "",
            "",
            "class ServerNoOpExtensionFactory:",
            "    name = 'x-no-op'",
            "",
            "    def __init__(self, params=None):",
            "        self.params = params or []",
            "",
            "    def process_request_params(self, params, accepted_extensions):",
            "        return self.params, NoOpExtension()",
            "",
            "",
            "class NoOpExtension:",
            "    name = 'x-no-op'",
            "",
            "    def __repr__(self):",
            "        return 'NoOpExtension()'",
            "",
            "    def decode(self, frame):",
            "        return frame",
            "",
            "    def encode(self, frame):",
            "        return frame",
            "",
            "",
            "class ClientServerTests(unittest.TestCase):",
            "",
            "    secure = False",
            "",
            "    def setUp(self):",
            "        self.loop = asyncio.new_event_loop()",
            "        asyncio.set_event_loop(self.loop)",
            "",
            "    def tearDown(self):",
            "        self.loop.close()",
            "",
            "    def run_loop_once(self):",
            "        # Process callbacks scheduled with call_soon by appending a callback",
            "        # to stop the event loop then running it until it hits that callback.",
            "        self.loop.call_soon(self.loop.stop)",
            "        self.loop.run_forever()",
            "",
            "    def start_server(self, **kwds):",
            "        # Don't enable compression by default in tests.",
            "        kwds.setdefault('compression', None)",
            "        start_server = serve(handler, 'localhost', 0, **kwds)",
            "        self.server = self.loop.run_until_complete(start_server)",
            "",
            "    def start_client(self, resource_name='/', user_info=None, **kwds):",
            "        # Don't enable compression by default in tests.",
            "        kwds.setdefault('compression', None)",
            "        secure = kwds.get('ssl') is not None",
            "        server_uri = get_server_uri(",
            "            self.server, secure, resource_name, user_info)",
            "        start_client = connect(server_uri, **kwds)",
            "        self.client = self.loop.run_until_complete(start_client)",
            "",
            "    def stop_client(self):",
            "        try:",
            "            self.loop.run_until_complete(",
            "                asyncio.wait_for(self.client.close_connection_task, timeout=1))",
            "        except asyncio.TimeoutError:                # pragma: no cover",
            "            self.fail(\"Client failed to stop\")",
            "",
            "    def stop_server(self):",
            "        self.server.close()",
            "        try:",
            "            self.loop.run_until_complete(",
            "                asyncio.wait_for(self.server.wait_closed(), timeout=1))",
            "        except asyncio.TimeoutError:                # pragma: no cover",
            "            self.fail(\"Server failed to stop\")",
            "",
            "    @contextlib.contextmanager",
            "    def temp_server(self, **kwds):",
            "        with temp_test_server(self, **kwds):",
            "            yield",
            "",
            "    @contextlib.contextmanager",
            "    def temp_client(self, *args, **kwds):",
            "        with temp_test_client(self, *args, **kwds):",
            "            yield",
            "",
            "    @with_server()",
            "    @with_client()",
            "    def test_basic(self):",
            "        self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "        reply = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(reply, \"Hello!\")",
            "",
            "    def test_server_close_while_client_connected(self):",
            "        with self.temp_server(loop=self.loop):",
            "            # This endpoint waits just a bit when the connection is cancelled",
            "            # in order to test that wait_closed() really waits for completion.",
            "            self.start_client('/slow_stop')",
            "        with self.assertRaises(ConnectionClosed):",
            "            self.loop.run_until_complete(self.client.recv())",
            "        # Connection ends with 1001 going away.",
            "        self.assertEqual(self.client.close_code, 1001)",
            "",
            "    def test_explicit_event_loop(self):",
            "        with self.temp_server(loop=self.loop):",
            "            with self.temp_client(loop=self.loop):",
            "                self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "                reply = self.loop.run_until_complete(self.client.recv())",
            "                self.assertEqual(reply, \"Hello!\")",
            "",
            "    # The way the legacy SSL implementation wraps sockets makes it extremely",
            "    # hard to write a test for Python 3.4.",
            "    @unittest.skipIf(",
            "        sys.version_info[:2] <= (3, 4), 'this test requires Python 3.5+')",
            "    @with_server()",
            "    def test_explicit_socket(self):",
            "",
            "        class TrackedSocket(socket.socket):",
            "            def __init__(self, *args, **kwargs):",
            "                self.used_for_read = False",
            "                self.used_for_write = False",
            "                super().__init__(*args, **kwargs)",
            "",
            "            def recv(self, *args, **kwargs):",
            "                self.used_for_read = True",
            "                return super().recv(*args, **kwargs)",
            "",
            "            def send(self, *args, **kwargs):",
            "                self.used_for_write = True",
            "                return super().send(*args, **kwargs)",
            "",
            "        server_socket = [",
            "            s for s in self.server.sockets if s.family == socket.AF_INET][0]",
            "        client_socket = TrackedSocket(socket.AF_INET, socket.SOCK_STREAM)",
            "        client_socket.connect(server_socket.getsockname())",
            "",
            "        try:",
            "            self.assertFalse(client_socket.used_for_read)",
            "            self.assertFalse(client_socket.used_for_write)",
            "",
            "            with self.temp_client(",
            "                sock=client_socket,",
            "                # \"You must set server_hostname when using ssl without a host\"",
            "                server_hostname='localhost' if self.secure else None,",
            "            ):",
            "                self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "                reply = self.loop.run_until_complete(self.client.recv())",
            "                self.assertEqual(reply, \"Hello!\")",
            "",
            "            self.assertTrue(client_socket.used_for_read)",
            "            self.assertTrue(client_socket.used_for_write)",
            "",
            "        finally:",
            "            client_socket.close()",
            "",
            "    @unittest.skipUnless(",
            "        hasattr(socket, 'AF_UNIX'), 'this test requires Unix sockets')",
            "    def test_unix_socket(self):",
            "        with tempfile.TemporaryDirectory() as temp_dir:",
            "            path = bytes(pathlib.Path(temp_dir) / 'websockets')",
            "",
            "            # Like self.start_server() but with unix_serve().",
            "            unix_server = unix_serve(handler, path)",
            "            self.server = self.loop.run_until_complete(unix_server)",
            "",
            "            client_socket = socket.socket(socket.AF_UNIX)",
            "            client_socket.connect(path)",
            "",
            "            try:",
            "                with self.temp_client(sock=client_socket):",
            "                    self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "                    reply = self.loop.run_until_complete(self.client.recv())",
            "                    self.assertEqual(reply, \"Hello!\")",
            "",
            "            finally:",
            "                client_socket.close()",
            "                self.stop_server()",
            "",
            "    @with_server()",
            "    @with_client('/attributes')",
            "    def test_protocol_attributes(self):",
            "        # The test could be connecting with IPv6 or IPv4.",
            "        expected_client_attrs = [",
            "            server_socket.getsockname()[:2] + (self.secure,)",
            "            for server_socket in self.server.sockets",
            "        ]",
            "        client_attrs = (self.client.host, self.client.port, self.client.secure)",
            "        self.assertIn(client_attrs, expected_client_attrs)",
            "",
            "        expected_server_attrs = ('localhost', 0, self.secure)",
            "        server_attrs = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_attrs, repr(expected_server_attrs))",
            "",
            "    @with_server()",
            "    @with_client('/path')",
            "    def test_protocol_path(self):",
            "        client_path = self.client.path",
            "        self.assertEqual(client_path, '/path')",
            "        server_path = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_path, '/path')",
            "",
            "    @with_server()",
            "    @with_client('/headers', user_info=('user', 'pass'))",
            "    def test_protocol_basic_auth(self):",
            "        self.assertEqual(",
            "            self.client.request_headers['Authorization'],",
            "            'Basic dXNlcjpwYXNz',",
            "        )",
            "",
            "    @with_server()",
            "    @with_client('/headers')",
            "    def test_protocol_headers(self):",
            "        client_req = self.client.request_headers",
            "        client_resp = self.client.response_headers",
            "        self.assertEqual(client_req['User-Agent'], USER_AGENT)",
            "        self.assertEqual(client_resp['Server'], USER_AGENT)",
            "        server_req = self.loop.run_until_complete(self.client.recv())",
            "        server_resp = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_req, str(client_req))",
            "        self.assertEqual(server_resp, str(client_resp))",
            "",
            "    @with_server()",
            "    @with_client('/raw_headers')",
            "    def test_protocol_raw_headers(self):",
            "        client_req = self.client.raw_request_headers",
            "        client_resp = self.client.raw_response_headers",
            "        self.assertEqual(dict(client_req)['User-Agent'], USER_AGENT)",
            "        self.assertEqual(dict(client_resp)['Server'], USER_AGENT)",
            "        server_req = self.loop.run_until_complete(self.client.recv())",
            "        server_resp = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_req, repr(client_req))",
            "        self.assertEqual(server_resp, repr(client_resp))",
            "",
            "    @with_server()",
            "    @with_client('/raw_headers', extra_headers={'X-Spam': 'Eggs'})",
            "    def test_protocol_custom_request_headers_dict(self):",
            "        req_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", req_headers)",
            "",
            "    @with_server()",
            "    @with_client('/raw_headers', extra_headers=[('X-Spam', 'Eggs')])",
            "    def test_protocol_custom_request_headers_list(self):",
            "        req_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", req_headers)",
            "",
            "    @with_server()",
            "    @with_client('/raw_headers', extra_headers=[('User-Agent', 'Eggs')])",
            "    def test_protocol_custom_request_user_agent(self):",
            "        req_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(req_headers.count(\"User-Agent\"), 1)",
            "        self.assertIn(\"('User-Agent', 'Eggs')\", req_headers)",
            "",
            "    @with_server(extra_headers=lambda p, r: {'X-Spam': 'Eggs'})",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_headers_callable_dict(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", resp_headers)",
            "",
            "    @with_server(extra_headers=lambda p, r: [('X-Spam', 'Eggs')])",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_headers_callable_list(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", resp_headers)",
            "",
            "    @with_server(extra_headers={'X-Spam': 'Eggs'})",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_headers_dict(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", resp_headers)",
            "",
            "    @with_server(extra_headers=[('X-Spam', 'Eggs')])",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_headers_list(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", resp_headers)",
            "",
            "    @with_server(extra_headers=[('Server', 'Eggs')])",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_user_agent(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(resp_headers.count(\"Server\"), 1)",
            "        self.assertIn(\"('Server', 'Eggs')\", resp_headers)",
            "",
            "    def make_http_request(self, path='/'):",
            "        # Set url to 'https?://<host>:<port><path>'.",
            "        url = get_server_uri(",
            "            self.server, resource_name=path, secure=self.secure)",
            "        url = url.replace('ws', 'http')",
            "",
            "        if self.secure:",
            "            open_health_check = functools.partial(",
            "                urllib.request.urlopen, url, context=self.client_context)",
            "        else:",
            "            open_health_check = functools.partial(",
            "                urllib.request.urlopen, url)",
            "",
            "        return self.loop.run_in_executor(None, open_health_check)",
            "",
            "    @with_server(create_protocol=HealthCheckServerProtocol)",
            "    def test_http_request_http_endpoint(self):",
            "        # Making a HTTP request to a HTTP endpoint succeeds.",
            "        response = self.loop.run_until_complete(",
            "            self.make_http_request('/__health__/'))",
            "",
            "        with contextlib.closing(response):",
            "            self.assertEqual(response.code, 200)",
            "            self.assertEqual(response.read(), b'status = green\\n')",
            "",
            "    @with_server(create_protocol=HealthCheckServerProtocol)",
            "    def test_http_request_ws_endpoint(self):",
            "        # Making a HTTP request to a WS endpoint fails.",
            "        with self.assertRaises(urllib.error.HTTPError) as raised:",
            "            self.loop.run_until_complete(self.make_http_request())",
            "",
            "        self.assertEqual(raised.exception.code, 426)",
            "        self.assertEqual(raised.exception.headers['Upgrade'], 'websocket')",
            "",
            "    @with_server(create_protocol=HealthCheckServerProtocol)",
            "    def test_ws_connection_http_endpoint(self):",
            "        # Making a WS connection to a HTTP endpoint fails.",
            "        with self.assertRaises(InvalidStatusCode) as raised:",
            "            self.start_client('/__health__/')",
            "",
            "        self.assertEqual(raised.exception.status_code, 200)",
            "",
            "    @with_server(create_protocol=HealthCheckServerProtocol)",
            "    def test_ws_connection_ws_endpoint(self):",
            "        # Making a WS connection to a WS endpoint succeeds.",
            "        self.start_client()",
            "        self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "        self.loop.run_until_complete(self.client.recv())",
            "        self.stop_client()",
            "",
            "    def assert_client_raises_code(self, status_code):",
            "        with self.assertRaises(InvalidStatusCode) as raised:",
            "            self.start_client()",
            "        self.assertEqual(raised.exception.status_code, status_code)",
            "",
            "    @with_server(create_protocol=UnauthorizedServerProtocol)",
            "    def test_server_create_protocol(self):",
            "        self.assert_client_raises_code(401)",
            "",
            "    @with_server(create_protocol=(lambda *args, **kwargs:",
            "                 UnauthorizedServerProtocol(*args, **kwargs)))",
            "    def test_server_create_protocol_function(self):",
            "        self.assert_client_raises_code(401)",
            "",
            "    @with_server(klass=UnauthorizedServerProtocol)",
            "    def test_server_klass(self):",
            "        self.assert_client_raises_code(401)",
            "",
            "    @with_server(create_protocol=ForbiddenServerProtocol,",
            "                 klass=UnauthorizedServerProtocol)",
            "    def test_server_create_protocol_over_klass(self):",
            "        self.assert_client_raises_code(403)",
            "",
            "    @with_server()",
            "    @with_client('/path', create_protocol=FooClientProtocol)",
            "    def test_client_create_protocol(self):",
            "        self.assertIsInstance(self.client, FooClientProtocol)",
            "",
            "    @with_server()",
            "    @with_client('/path', create_protocol=(",
            "                 lambda *args, **kwargs: FooClientProtocol(*args, **kwargs)))",
            "    def test_client_create_protocol_function(self):",
            "        self.assertIsInstance(self.client, FooClientProtocol)",
            "",
            "    @with_server()",
            "    @with_client('/path', klass=FooClientProtocol)",
            "    def test_client_klass(self):",
            "        self.assertIsInstance(self.client, FooClientProtocol)",
            "",
            "    @with_server()",
            "    @with_client('/path', create_protocol=BarClientProtocol,",
            "                 klass=FooClientProtocol)",
            "    def test_client_create_protocol_over_klass(self):",
            "        self.assertIsInstance(self.client, BarClientProtocol)",
            "",
            "    @with_server()",
            "    @with_client('/extensions')",
            "    def test_no_extension(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([]))",
            "        self.assertEqual(repr(self.client.extensions), repr([]))",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory()])",
            "    @with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])",
            "    def test_extension(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([NoOpExtension()]))",
            "        self.assertEqual(repr(self.client.extensions), repr([NoOpExtension()]))",
            "",
            "    @with_server()",
            "    @with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])",
            "    def test_extension_not_accepted(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([]))",
            "        self.assertEqual(repr(self.client.extensions), repr([]))",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory()])",
            "    @with_client('/extensions')",
            "    def test_extension_not_requested(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([]))",
            "        self.assertEqual(repr(self.client.extensions), repr([]))",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory([('foo', None)])])",
            "    def test_extension_client_rejection(self):",
            "        with self.assertRaises(NegotiationError):",
            "            self.start_client(",
            "                '/extensions',",
            "                extensions=[ClientNoOpExtensionFactory()],",
            "            )",
            "",
            "    @with_server(",
            "        extensions=[",
            "            # No match because the client doesn't send client_max_window_bits.",
            "            ServerPerMessageDeflateFactory(client_max_window_bits=10),",
            "            ServerPerMessageDeflateFactory(),",
            "        ],",
            "    )",
            "    @with_client(",
            "        '/extensions',",
            "        extensions=[",
            "            ClientPerMessageDeflateFactory(),",
            "        ],",
            "    )",
            "    def test_extension_no_match_then_match(self):",
            "        # The order requested by the client has priority.",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "        ]))",
            "        self.assertEqual(repr(self.client.extensions), repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "        ]))",
            "",
            "    @with_server(extensions=[ServerPerMessageDeflateFactory()])",
            "    @with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])",
            "    def test_extension_mismatch(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([]))",
            "        self.assertEqual(repr(self.client.extensions), repr([]))",
            "",
            "    @with_server(",
            "        extensions=[",
            "            ServerNoOpExtensionFactory(),",
            "            ServerPerMessageDeflateFactory(),",
            "        ],",
            "    )",
            "    @with_client(",
            "        '/extensions',",
            "        extensions=[",
            "            ClientPerMessageDeflateFactory(),",
            "            ClientNoOpExtensionFactory(),",
            "        ],",
            "    )",
            "    def test_extension_order(self):",
            "        # The order requested by the client has priority.",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "            NoOpExtension(),",
            "        ]))",
            "        self.assertEqual(repr(self.client.extensions), repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "            NoOpExtension(),",
            "        ]))",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory()])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_extensions')",
            "    def test_extensions_error(self, _process_extensions):",
            "        _process_extensions.return_value = 'x-no-op', [NoOpExtension()]",
            "",
            "        with self.assertRaises(NegotiationError):",
            "            self.start_client(",
            "                '/extensions',",
            "                extensions=[ClientPerMessageDeflateFactory()],",
            "            )",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory()])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_extensions')",
            "    def test_extensions_error_no_extensions(self, _process_extensions):",
            "        _process_extensions.return_value = 'x-no-op', [NoOpExtension()]",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client('/extensions')",
            "",
            "    @with_server(compression='deflate')",
            "    @with_client('/extensions', compression='deflate')",
            "    def test_compression_deflate(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "        ]))",
            "        self.assertEqual(repr(self.client.extensions), repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "        ]))",
            "",
            "    @with_server(",
            "        extensions=[",
            "            ServerPerMessageDeflateFactory(",
            "                client_no_context_takeover=True,",
            "                server_max_window_bits=10,",
            "            ),",
            "        ],",
            "        compression='deflate',  # overridden by explicit config",
            "    )",
            "    @with_client(",
            "        '/extensions',",
            "        extensions=[",
            "            ClientPerMessageDeflateFactory(",
            "                server_no_context_takeover=True,",
            "                client_max_window_bits=12,",
            "            ),",
            "        ],",
            "        compression='deflate',  # overridden by explicit config",
            "    )",
            "    def test_compression_deflate_and_explicit_config(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([",
            "            PerMessageDeflate(True, True, 12, 10),",
            "        ]))",
            "        self.assertEqual(repr(self.client.extensions), repr([",
            "            PerMessageDeflate(True, True, 10, 12),",
            "        ]))",
            "",
            "    def test_compression_unsupported_server(self):",
            "        with self.assertRaises(ValueError):",
            "            self.loop.run_until_complete(self.start_server(compression='xz'))",
            "",
            "    @with_server()",
            "    def test_compression_unsupported_client(self):",
            "        with self.assertRaises(ValueError):",
            "            self.loop.run_until_complete(self.start_client(compression='xz'))",
            "",
            "    @with_server()",
            "    @with_client('/subprotocol')",
            "    def test_no_subprotocol(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr(None))",
            "        self.assertEqual(self.client.subprotocol, None)",
            "",
            "    @with_server(subprotocols=['superchat', 'chat'])",
            "    @with_client('/subprotocol', subprotocols=['otherchat', 'chat'])",
            "    def test_subprotocol(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr('chat'))",
            "        self.assertEqual(self.client.subprotocol, 'chat')",
            "",
            "    @with_server(subprotocols=['superchat'])",
            "    @with_client('/subprotocol', subprotocols=['otherchat'])",
            "    def test_subprotocol_not_accepted(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr(None))",
            "        self.assertEqual(self.client.subprotocol, None)",
            "",
            "    @with_server()",
            "    @with_client('/subprotocol', subprotocols=['otherchat', 'chat'])",
            "    def test_subprotocol_not_offered(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr(None))",
            "        self.assertEqual(self.client.subprotocol, None)",
            "",
            "    @with_server(subprotocols=['superchat', 'chat'])",
            "    @with_client('/subprotocol')",
            "    def test_subprotocol_not_requested(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr(None))",
            "        self.assertEqual(self.client.subprotocol, None)",
            "",
            "    @with_server(subprotocols=['superchat'])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')",
            "    def test_subprotocol_error(self, _process_subprotocol):",
            "        _process_subprotocol.return_value = 'superchat'",
            "",
            "        with self.assertRaises(NegotiationError):",
            "            self.start_client('/subprotocol', subprotocols=['otherchat'])",
            "        self.run_loop_once()",
            "",
            "    @with_server(subprotocols=['superchat'])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')",
            "    def test_subprotocol_error_no_subprotocols(self, _process_subprotocol):",
            "        _process_subprotocol.return_value = 'superchat'",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client('/subprotocol')",
            "        self.run_loop_once()",
            "",
            "    @with_server(subprotocols=['superchat', 'chat'])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')",
            "    def test_subprotocol_error_two_subprotocols(self, _process_subprotocol):",
            "        _process_subprotocol.return_value = 'superchat, chat'",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client(",
            "                '/subprotocol', subprotocols=['superchat', 'chat'])",
            "        self.run_loop_once()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.read_request')",
            "    def test_server_receives_malformed_request(self, _read_request):",
            "        _read_request.side_effect = ValueError(\"read_request failed\")",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.client.read_response')",
            "    def test_client_receives_malformed_response(self, _read_response):",
            "        _read_response.side_effect = ValueError(\"read_response failed\")",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "        self.run_loop_once()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.client.build_request')",
            "    def test_client_sends_invalid_handshake_request(self, _build_request):",
            "        def wrong_build_request(set_header):",
            "            return '42'",
            "        _build_request.side_effect = wrong_build_request",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.build_response')",
            "    def test_server_sends_invalid_handshake_response(self, _build_response):",
            "        def wrong_build_response(set_header, key):",
            "            return build_response(set_header, '42')",
            "        _build_response.side_effect = wrong_build_response",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.client.read_response')",
            "    def test_server_does_not_switch_protocols(self, _read_response):",
            "        @asyncio.coroutine",
            "        def wrong_read_response(stream):",
            "            status_code, headers = yield from read_response(stream)",
            "            return 400, headers",
            "        _read_response.side_effect = wrong_read_response",
            "",
            "        with self.assertRaises(InvalidStatusCode):",
            "            self.start_client()",
            "        self.run_loop_once()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch(",
            "        'websockets.server.WebSocketServerProtocol.process_request')",
            "    def test_server_error_in_handshake(self, _process_request):",
            "        _process_request.side_effect = Exception(\"process_request crashed\")",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.WebSocketServerProtocol.send')",
            "    def test_server_handler_crashes(self, send):",
            "        send.side_effect = ValueError(\"send failed\")",
            "",
            "        with self.temp_client():",
            "            self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "            with self.assertRaises(ConnectionClosed):",
            "                self.loop.run_until_complete(self.client.recv())",
            "",
            "        # Connection ends with an unexpected error.",
            "        self.assertEqual(self.client.close_code, 1011)",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')",
            "    def test_server_close_crashes(self, close):",
            "        close.side_effect = ValueError(\"close failed\")",
            "",
            "        with self.temp_client():",
            "            self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "            reply = self.loop.run_until_complete(self.client.recv())",
            "            self.assertEqual(reply, \"Hello!\")",
            "",
            "        # Connection ends with an abnormal closure.",
            "        self.assertEqual(self.client.close_code, 1006)",
            "",
            "    @with_server()",
            "    @with_client()",
            "    @unittest.mock.patch.object(WebSocketClientProtocol, 'handshake')",
            "    def test_client_closes_connection_before_handshake(self, handshake):",
            "        # We have mocked the handshake() method to prevent the client from",
            "        # performing the opening handshake. Force it to close the connection.",
            "        self.client.writer.close()",
            "        # The server should stop properly anyway. It used to hang because the",
            "        # task handling the connection was waiting for the opening handshake.",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.read_request')",
            "    def test_server_shuts_down_during_opening_handshake(self, _read_request):",
            "        _read_request.side_effect = asyncio.CancelledError",
            "",
            "        self.server.closing = True",
            "        with self.assertRaises(InvalidHandshake) as raised:",
            "            self.start_client()",
            "",
            "        # Opening handshake fails with 503 Service Unavailable",
            "        self.assertEqual(str(raised.exception), \"Status code not 101: 503\")",
            "",
            "    @with_server()",
            "    def test_server_shuts_down_during_connection_handling(self):",
            "        with self.temp_client():",
            "            self.server.close()",
            "            with self.assertRaises(ConnectionClosed):",
            "                self.loop.run_until_complete(self.client.recv())",
            "",
            "        # Websocket connection terminates with 1001 Going Away.",
            "        self.assertEqual(self.client.close_code, 1001)",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')",
            "    def test_server_shuts_down_during_connection_close(self, _close):",
            "        _close.side_effect = asyncio.CancelledError",
            "",
            "        self.server.closing = True",
            "        with self.temp_client():",
            "            self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "            reply = self.loop.run_until_complete(self.client.recv())",
            "            self.assertEqual(reply, \"Hello!\")",
            "",
            "        # Websocket connection terminates abnormally.",
            "        self.assertEqual(self.client.close_code, 1006)",
            "",
            "    @with_server(create_protocol=ForbiddenServerProtocol)",
            "    def test_invalid_status_error_during_client_connect(self):",
            "        with self.assertRaises(InvalidStatusCode) as raised:",
            "            self.start_client()",
            "        exception = raised.exception",
            "        self.assertEqual(str(exception), \"Status code not 101: 403\")",
            "        self.assertEqual(exception.status_code, 403)",
            "",
            "    @with_server()",
            "    @unittest.mock.patch(",
            "        'websockets.server.WebSocketServerProtocol.write_http_response')",
            "    @unittest.mock.patch(",
            "        'websockets.server.WebSocketServerProtocol.read_http_request')",
            "    def test_connection_error_during_opening_handshake(",
            "            self, _read_http_request, _write_http_response):",
            "        _read_http_request.side_effect = ConnectionError",
            "",
            "        # This exception is currently platform-dependent. It was observed to",
            "        # be ConnectionResetError on Linux in the non-SSL case, and",
            "        # InvalidMessage otherwise (including both Linux and macOS). This",
            "        # doesn't matter though since this test is primarily for testing a",
            "        # code path on the server side.",
            "        with self.assertRaises(Exception):",
            "            self.start_client()",
            "",
            "        # No response must not be written if the network connection is broken.",
            "        _write_http_response.assert_not_called()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')",
            "    def test_connection_error_during_closing_handshake(self, close):",
            "        close.side_effect = ConnectionError",
            "",
            "        with self.temp_client():",
            "            self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "            reply = self.loop.run_until_complete(self.client.recv())",
            "            self.assertEqual(reply, \"Hello!\")",
            "",
            "        # Connection ends with an abnormal closure.",
            "        self.assertEqual(self.client.close_code, 1006)",
            "",
            "",
            "class SSLClientServerTests(ClientServerTests):",
            "",
            "    secure = True",
            "",
            "    @property",
            "    def server_context(self):",
            "        # Change to ssl.PROTOCOL_TLS_SERVER when dropping Python < 3.6.",
            "        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)",
            "        ssl_context.load_cert_chain(testcert)",
            "        return ssl_context",
            "",
            "    @property",
            "    def client_context(self):",
            "        # Change to ssl.PROTOCOL_TLS_CLIENT when dropping Python < 3.6.",
            "        # Then remove verify_mode and check_hostname below.",
            "        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)",
            "        ssl_context.load_verify_locations(testcert)",
            "        ssl_context.verify_mode = ssl.CERT_REQUIRED",
            "        # ssl.match_hostname can't match IP addresses on Python < 3.5.",
            "        # We're using IP addresses to enforce testing of IPv4 and IPv6.",
            "        if sys.version_info[:2] >= (3, 5):                  # pragma: no cover",
            "            ssl_context.check_hostname = True",
            "        return ssl_context",
            "",
            "    def start_server(self, **kwds):",
            "        kwds.setdefault('ssl', self.server_context)",
            "        super().start_server(**kwds)",
            "",
            "    def start_client(self, path='/', **kwds):",
            "        kwds.setdefault('ssl', self.client_context)",
            "        super().start_client(path, **kwds)",
            "",
            "    # TLS over Unix sockets doesn't make sense.",
            "    test_unix_socket = None",
            "",
            "    @with_server()",
            "    def test_ws_uri_is_rejected(self):",
            "        with self.assertRaises(ValueError):",
            "            client = connect(",
            "                get_server_uri(self.server, secure=False),",
            "                ssl=self.client_context,",
            "            )",
            "            # With Python \u2265 3.5, the exception is raised by connect() even",
            "            # before awaiting.  However, with Python 3.4 the exception is",
            "            # raised only when awaiting.",
            "            self.loop.run_until_complete(client)          # pragma: no cover",
            "",
            "",
            "class ClientServerOriginTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.loop = asyncio.new_event_loop()",
            "        asyncio.set_event_loop(self.loop)",
            "",
            "    def tearDown(self):",
            "        self.loop.close()",
            "",
            "    def test_checking_origin_succeeds(self):",
            "        server = self.loop.run_until_complete(",
            "            serve(handler, 'localhost', 0, origins=['http://localhost']))",
            "        client = self.loop.run_until_complete(",
            "            connect(get_server_uri(server), origin='http://localhost'))",
            "",
            "        self.loop.run_until_complete(client.send(\"Hello!\"))",
            "        self.assertEqual(self.loop.run_until_complete(client.recv()), \"Hello!\")",
            "",
            "        self.loop.run_until_complete(client.close())",
            "        server.close()",
            "        self.loop.run_until_complete(server.wait_closed())",
            "",
            "    def test_checking_origin_fails(self):",
            "        server = self.loop.run_until_complete(",
            "            serve(handler, 'localhost', 0, origins=['http://localhost']))",
            "        with self.assertRaisesRegex(InvalidHandshake,",
            "                                    \"Status code not 101: 403\"):",
            "            self.loop.run_until_complete(",
            "                connect(get_server_uri(server), origin='http://otherhost'))",
            "",
            "        server.close()",
            "        self.loop.run_until_complete(server.wait_closed())",
            "",
            "    def test_checking_lack_of_origin_succeeds(self):",
            "        server = self.loop.run_until_complete(",
            "            serve(handler, 'localhost', 0, origins=['']))",
            "        client = self.loop.run_until_complete(connect(get_server_uri(server)))",
            "",
            "        self.loop.run_until_complete(client.send(\"Hello!\"))",
            "        self.assertEqual(self.loop.run_until_complete(client.recv()), \"Hello!\")",
            "",
            "        self.loop.run_until_complete(client.close())",
            "        server.close()",
            "        self.loop.run_until_complete(server.wait_closed())",
            "",
            "",
            "try:",
            "    from .py35._test_client_server import ContextManagerTests           # noqa",
            "except (SyntaxError, ImportError):                          # pragma: no cover",
            "    pass",
            "",
            "",
            "try:",
            "    from .py36._test_client_server import AsyncIteratorTests            # noqa",
            "except (SyntaxError, ImportError):                          # pragma: no cover",
            "    pass"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import contextlib",
            "import functools",
            "import logging",
            "import pathlib",
            "import random",
            "import socket",
            "import ssl",
            "import sys",
            "import tempfile",
            "import unittest",
            "import unittest.mock",
            "import urllib.error",
            "import urllib.request",
            "",
            "from .client import *",
            "from .compatibility import FORBIDDEN, OK, UNAUTHORIZED",
            "from .exceptions import (",
            "    ConnectionClosed, InvalidHandshake, InvalidStatusCode, NegotiationError",
            ")",
            "from .extensions.permessage_deflate import (",
            "    ClientPerMessageDeflateFactory, PerMessageDeflate,",
            "    ServerPerMessageDeflateFactory",
            ")",
            "from .handshake import build_response",
            "from .http import USER_AGENT, read_response",
            "from .server import *",
            "from .test_protocol import MS",
            "",
            "",
            "# Avoid displaying stack traces at the ERROR logging level.",
            "logging.basicConfig(level=logging.CRITICAL)",
            "",
            "",
            "# Generate TLS certificate with:",
            "# $ openssl req -x509 -config test_localhost.cnf -days 15340 -newkey rsa:2048 \\",
            "#       -out test_localhost.crt -keyout test_localhost.key",
            "# $ cat test_localhost.key test_localhost.crt > test_localhost.pem",
            "# $ rm test_localhost.key test_localhost.crt",
            "",
            "testcert = bytes(pathlib.Path(__file__).with_name('test_localhost.pem'))",
            "",
            "",
            "@asyncio.coroutine",
            "def handler(ws, path):",
            "    if path == '/attributes':",
            "        yield from ws.send(repr((ws.host, ws.port, ws.secure)))",
            "    elif path == '/path':",
            "        yield from ws.send(str(ws.path))",
            "    elif path == '/headers':",
            "        yield from ws.send(str(ws.request_headers))",
            "        yield from ws.send(str(ws.response_headers))",
            "    elif path == '/raw_headers':",
            "        yield from ws.send(repr(ws.raw_request_headers))",
            "        yield from ws.send(repr(ws.raw_response_headers))",
            "    elif path == '/extensions':",
            "        yield from ws.send(repr(ws.extensions))",
            "    elif path == '/subprotocol':",
            "        yield from ws.send(repr(ws.subprotocol))",
            "    elif path == '/slow_stop':",
            "        try:",
            "            yield from asyncio.sleep(1000 * MS)",
            "        except asyncio.CancelledError:",
            "            yield from asyncio.sleep(MS)",
            "            raise",
            "    else:",
            "        yield from ws.send((yield from ws.recv()))",
            "",
            "",
            "@contextlib.contextmanager",
            "def temp_test_server(test, **kwds):",
            "    test.start_server(**kwds)",
            "    try:",
            "        yield",
            "    finally:",
            "        test.stop_server()",
            "",
            "",
            "@contextlib.contextmanager",
            "def temp_test_client(test, *args, **kwds):",
            "    test.start_client(*args, **kwds)",
            "    try:",
            "        yield",
            "    finally:",
            "        test.stop_client()",
            "",
            "",
            "def with_manager(manager, *args, **kwds):",
            "    \"\"\"",
            "    Return a decorator that wraps a function with a context manager.",
            "",
            "    \"\"\"",
            "    def decorate(func):",
            "        @functools.wraps(func)",
            "        def _decorate(self, *_args, **_kwds):",
            "            with manager(self, *args, **kwds):",
            "                return func(self, *_args, **_kwds)",
            "",
            "        return _decorate",
            "",
            "    return decorate",
            "",
            "",
            "def with_server(**kwds):",
            "    \"\"\"",
            "    Return a decorator for TestCase methods that starts and stops a server.",
            "",
            "    \"\"\"",
            "    return with_manager(temp_test_server, **kwds)",
            "",
            "",
            "def with_client(*args, **kwds):",
            "    \"\"\"",
            "    Return a decorator for TestCase methods that starts and stops a client.",
            "",
            "    \"\"\"",
            "    return with_manager(temp_test_client, *args, **kwds)",
            "",
            "",
            "def get_server_uri(server, secure=False, resource_name='/', user_info=None):",
            "    \"\"\"",
            "    Return a WebSocket URI for connecting to the given server.",
            "",
            "    \"\"\"",
            "    proto = 'wss' if secure else 'ws'",
            "",
            "    user_info = ':'.join(user_info) + '@' if user_info else ''",
            "",
            "    # Pick a random socket in order to test both IPv4 and IPv6 on systems",
            "    # where both are available. Randomizing tests is usually a bad idea. If",
            "    # needed, either use the first socket, or test separately IPv4 and IPv6.",
            "    server_socket = random.choice(server.sockets)",
            "",
            "    if server_socket.family == socket.AF_INET6:             # pragma: no cover",
            "        host, port = server_socket.getsockname()[:2]        # (no IPv6 on CI)",
            "        host = '[{}]'.format(host)",
            "    elif server_socket.family == socket.AF_INET:",
            "        host, port = server_socket.getsockname()",
            "    elif server_socket.family == socket.AF_UNIX:",
            "        # The host and port are ignored when connecting to a Unix socket.",
            "        host, port = 'localhost', 0",
            "    else:                                                   # pragma: no cover",
            "        raise ValueError(\"Expected an IPv6, IPv4, or Unix socket\")",
            "",
            "    return '{}://{}{}:{}{}'.format(proto, user_info, host, port, resource_name)",
            "",
            "",
            "class UnauthorizedServerProtocol(WebSocketServerProtocol):",
            "",
            "    @asyncio.coroutine",
            "    def process_request(self, path, request_headers):",
            "        return UNAUTHORIZED, []",
            "",
            "",
            "class ForbiddenServerProtocol(WebSocketServerProtocol):",
            "",
            "    @asyncio.coroutine",
            "    def process_request(self, path, request_headers):",
            "        return FORBIDDEN, []",
            "",
            "",
            "class HealthCheckServerProtocol(WebSocketServerProtocol):",
            "",
            "    @asyncio.coroutine",
            "    def process_request(self, path, request_headers):",
            "        if path == '/__health__/':",
            "            body = b'status = green\\n'",
            "            return OK, [('Content-Length', str(len(body)))], body",
            "",
            "",
            "class FooClientProtocol(WebSocketClientProtocol):",
            "    pass",
            "",
            "",
            "class BarClientProtocol(WebSocketClientProtocol):",
            "    pass",
            "",
            "",
            "class ClientNoOpExtensionFactory:",
            "    name = 'x-no-op'",
            "",
            "    def get_request_params(self):",
            "        return []",
            "",
            "    def process_response_params(self, params, accepted_extensions):",
            "        if params:",
            "            raise NegotiationError()",
            "        return NoOpExtension()",
            "",
            "",
            "class ServerNoOpExtensionFactory:",
            "    name = 'x-no-op'",
            "",
            "    def __init__(self, params=None):",
            "        self.params = params or []",
            "",
            "    def process_request_params(self, params, accepted_extensions):",
            "        return self.params, NoOpExtension()",
            "",
            "",
            "class NoOpExtension:",
            "    name = 'x-no-op'",
            "",
            "    def __repr__(self):",
            "        return 'NoOpExtension()'",
            "",
            "    def decode(self, frame, *, max_size=None):",
            "        return frame",
            "",
            "    def encode(self, frame):",
            "        return frame",
            "",
            "",
            "class ClientServerTests(unittest.TestCase):",
            "",
            "    secure = False",
            "",
            "    def setUp(self):",
            "        self.loop = asyncio.new_event_loop()",
            "        asyncio.set_event_loop(self.loop)",
            "",
            "    def tearDown(self):",
            "        self.loop.close()",
            "",
            "    def run_loop_once(self):",
            "        # Process callbacks scheduled with call_soon by appending a callback",
            "        # to stop the event loop then running it until it hits that callback.",
            "        self.loop.call_soon(self.loop.stop)",
            "        self.loop.run_forever()",
            "",
            "    def start_server(self, **kwds):",
            "        # Don't enable compression by default in tests.",
            "        kwds.setdefault('compression', None)",
            "        start_server = serve(handler, 'localhost', 0, **kwds)",
            "        self.server = self.loop.run_until_complete(start_server)",
            "",
            "    def start_client(self, resource_name='/', user_info=None, **kwds):",
            "        # Don't enable compression by default in tests.",
            "        kwds.setdefault('compression', None)",
            "        secure = kwds.get('ssl') is not None",
            "        server_uri = get_server_uri(",
            "            self.server, secure, resource_name, user_info)",
            "        start_client = connect(server_uri, **kwds)",
            "        self.client = self.loop.run_until_complete(start_client)",
            "",
            "    def stop_client(self):",
            "        try:",
            "            self.loop.run_until_complete(",
            "                asyncio.wait_for(self.client.close_connection_task, timeout=1))",
            "        except asyncio.TimeoutError:                # pragma: no cover",
            "            self.fail(\"Client failed to stop\")",
            "",
            "    def stop_server(self):",
            "        self.server.close()",
            "        try:",
            "            self.loop.run_until_complete(",
            "                asyncio.wait_for(self.server.wait_closed(), timeout=1))",
            "        except asyncio.TimeoutError:                # pragma: no cover",
            "            self.fail(\"Server failed to stop\")",
            "",
            "    @contextlib.contextmanager",
            "    def temp_server(self, **kwds):",
            "        with temp_test_server(self, **kwds):",
            "            yield",
            "",
            "    @contextlib.contextmanager",
            "    def temp_client(self, *args, **kwds):",
            "        with temp_test_client(self, *args, **kwds):",
            "            yield",
            "",
            "    @with_server()",
            "    @with_client()",
            "    def test_basic(self):",
            "        self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "        reply = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(reply, \"Hello!\")",
            "",
            "    def test_server_close_while_client_connected(self):",
            "        with self.temp_server(loop=self.loop):",
            "            # This endpoint waits just a bit when the connection is cancelled",
            "            # in order to test that wait_closed() really waits for completion.",
            "            self.start_client('/slow_stop')",
            "        with self.assertRaises(ConnectionClosed):",
            "            self.loop.run_until_complete(self.client.recv())",
            "        # Connection ends with 1001 going away.",
            "        self.assertEqual(self.client.close_code, 1001)",
            "",
            "    def test_explicit_event_loop(self):",
            "        with self.temp_server(loop=self.loop):",
            "            with self.temp_client(loop=self.loop):",
            "                self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "                reply = self.loop.run_until_complete(self.client.recv())",
            "                self.assertEqual(reply, \"Hello!\")",
            "",
            "    # The way the legacy SSL implementation wraps sockets makes it extremely",
            "    # hard to write a test for Python 3.4.",
            "    @unittest.skipIf(",
            "        sys.version_info[:2] <= (3, 4), 'this test requires Python 3.5+')",
            "    @with_server()",
            "    def test_explicit_socket(self):",
            "",
            "        class TrackedSocket(socket.socket):",
            "            def __init__(self, *args, **kwargs):",
            "                self.used_for_read = False",
            "                self.used_for_write = False",
            "                super().__init__(*args, **kwargs)",
            "",
            "            def recv(self, *args, **kwargs):",
            "                self.used_for_read = True",
            "                return super().recv(*args, **kwargs)",
            "",
            "            def send(self, *args, **kwargs):",
            "                self.used_for_write = True",
            "                return super().send(*args, **kwargs)",
            "",
            "        server_socket = [",
            "            s for s in self.server.sockets if s.family == socket.AF_INET][0]",
            "        client_socket = TrackedSocket(socket.AF_INET, socket.SOCK_STREAM)",
            "        client_socket.connect(server_socket.getsockname())",
            "",
            "        try:",
            "            self.assertFalse(client_socket.used_for_read)",
            "            self.assertFalse(client_socket.used_for_write)",
            "",
            "            with self.temp_client(",
            "                sock=client_socket,",
            "                # \"You must set server_hostname when using ssl without a host\"",
            "                server_hostname='localhost' if self.secure else None,",
            "            ):",
            "                self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "                reply = self.loop.run_until_complete(self.client.recv())",
            "                self.assertEqual(reply, \"Hello!\")",
            "",
            "            self.assertTrue(client_socket.used_for_read)",
            "            self.assertTrue(client_socket.used_for_write)",
            "",
            "        finally:",
            "            client_socket.close()",
            "",
            "    @unittest.skipUnless(",
            "        hasattr(socket, 'AF_UNIX'), 'this test requires Unix sockets')",
            "    def test_unix_socket(self):",
            "        with tempfile.TemporaryDirectory() as temp_dir:",
            "            path = bytes(pathlib.Path(temp_dir) / 'websockets')",
            "",
            "            # Like self.start_server() but with unix_serve().",
            "            unix_server = unix_serve(handler, path)",
            "            self.server = self.loop.run_until_complete(unix_server)",
            "",
            "            client_socket = socket.socket(socket.AF_UNIX)",
            "            client_socket.connect(path)",
            "",
            "            try:",
            "                with self.temp_client(sock=client_socket):",
            "                    self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "                    reply = self.loop.run_until_complete(self.client.recv())",
            "                    self.assertEqual(reply, \"Hello!\")",
            "",
            "            finally:",
            "                client_socket.close()",
            "                self.stop_server()",
            "",
            "    @with_server()",
            "    @with_client('/attributes')",
            "    def test_protocol_attributes(self):",
            "        # The test could be connecting with IPv6 or IPv4.",
            "        expected_client_attrs = [",
            "            server_socket.getsockname()[:2] + (self.secure,)",
            "            for server_socket in self.server.sockets",
            "        ]",
            "        client_attrs = (self.client.host, self.client.port, self.client.secure)",
            "        self.assertIn(client_attrs, expected_client_attrs)",
            "",
            "        expected_server_attrs = ('localhost', 0, self.secure)",
            "        server_attrs = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_attrs, repr(expected_server_attrs))",
            "",
            "    @with_server()",
            "    @with_client('/path')",
            "    def test_protocol_path(self):",
            "        client_path = self.client.path",
            "        self.assertEqual(client_path, '/path')",
            "        server_path = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_path, '/path')",
            "",
            "    @with_server()",
            "    @with_client('/headers', user_info=('user', 'pass'))",
            "    def test_protocol_basic_auth(self):",
            "        self.assertEqual(",
            "            self.client.request_headers['Authorization'],",
            "            'Basic dXNlcjpwYXNz',",
            "        )",
            "",
            "    @with_server()",
            "    @with_client('/headers')",
            "    def test_protocol_headers(self):",
            "        client_req = self.client.request_headers",
            "        client_resp = self.client.response_headers",
            "        self.assertEqual(client_req['User-Agent'], USER_AGENT)",
            "        self.assertEqual(client_resp['Server'], USER_AGENT)",
            "        server_req = self.loop.run_until_complete(self.client.recv())",
            "        server_resp = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_req, str(client_req))",
            "        self.assertEqual(server_resp, str(client_resp))",
            "",
            "    @with_server()",
            "    @with_client('/raw_headers')",
            "    def test_protocol_raw_headers(self):",
            "        client_req = self.client.raw_request_headers",
            "        client_resp = self.client.raw_response_headers",
            "        self.assertEqual(dict(client_req)['User-Agent'], USER_AGENT)",
            "        self.assertEqual(dict(client_resp)['Server'], USER_AGENT)",
            "        server_req = self.loop.run_until_complete(self.client.recv())",
            "        server_resp = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_req, repr(client_req))",
            "        self.assertEqual(server_resp, repr(client_resp))",
            "",
            "    @with_server()",
            "    @with_client('/raw_headers', extra_headers={'X-Spam': 'Eggs'})",
            "    def test_protocol_custom_request_headers_dict(self):",
            "        req_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", req_headers)",
            "",
            "    @with_server()",
            "    @with_client('/raw_headers', extra_headers=[('X-Spam', 'Eggs')])",
            "    def test_protocol_custom_request_headers_list(self):",
            "        req_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", req_headers)",
            "",
            "    @with_server()",
            "    @with_client('/raw_headers', extra_headers=[('User-Agent', 'Eggs')])",
            "    def test_protocol_custom_request_user_agent(self):",
            "        req_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(req_headers.count(\"User-Agent\"), 1)",
            "        self.assertIn(\"('User-Agent', 'Eggs')\", req_headers)",
            "",
            "    @with_server(extra_headers=lambda p, r: {'X-Spam': 'Eggs'})",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_headers_callable_dict(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", resp_headers)",
            "",
            "    @with_server(extra_headers=lambda p, r: [('X-Spam', 'Eggs')])",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_headers_callable_list(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", resp_headers)",
            "",
            "    @with_server(extra_headers={'X-Spam': 'Eggs'})",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_headers_dict(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", resp_headers)",
            "",
            "    @with_server(extra_headers=[('X-Spam', 'Eggs')])",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_headers_list(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertIn(\"('X-Spam', 'Eggs')\", resp_headers)",
            "",
            "    @with_server(extra_headers=[('Server', 'Eggs')])",
            "    @with_client('/raw_headers')",
            "    def test_protocol_custom_response_user_agent(self):",
            "        self.loop.run_until_complete(self.client.recv())",
            "        resp_headers = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(resp_headers.count(\"Server\"), 1)",
            "        self.assertIn(\"('Server', 'Eggs')\", resp_headers)",
            "",
            "    def make_http_request(self, path='/'):",
            "        # Set url to 'https?://<host>:<port><path>'.",
            "        url = get_server_uri(",
            "            self.server, resource_name=path, secure=self.secure)",
            "        url = url.replace('ws', 'http')",
            "",
            "        if self.secure:",
            "            open_health_check = functools.partial(",
            "                urllib.request.urlopen, url, context=self.client_context)",
            "        else:",
            "            open_health_check = functools.partial(",
            "                urllib.request.urlopen, url)",
            "",
            "        return self.loop.run_in_executor(None, open_health_check)",
            "",
            "    @with_server(create_protocol=HealthCheckServerProtocol)",
            "    def test_http_request_http_endpoint(self):",
            "        # Making a HTTP request to a HTTP endpoint succeeds.",
            "        response = self.loop.run_until_complete(",
            "            self.make_http_request('/__health__/'))",
            "",
            "        with contextlib.closing(response):",
            "            self.assertEqual(response.code, 200)",
            "            self.assertEqual(response.read(), b'status = green\\n')",
            "",
            "    @with_server(create_protocol=HealthCheckServerProtocol)",
            "    def test_http_request_ws_endpoint(self):",
            "        # Making a HTTP request to a WS endpoint fails.",
            "        with self.assertRaises(urllib.error.HTTPError) as raised:",
            "            self.loop.run_until_complete(self.make_http_request())",
            "",
            "        self.assertEqual(raised.exception.code, 426)",
            "        self.assertEqual(raised.exception.headers['Upgrade'], 'websocket')",
            "",
            "    @with_server(create_protocol=HealthCheckServerProtocol)",
            "    def test_ws_connection_http_endpoint(self):",
            "        # Making a WS connection to a HTTP endpoint fails.",
            "        with self.assertRaises(InvalidStatusCode) as raised:",
            "            self.start_client('/__health__/')",
            "",
            "        self.assertEqual(raised.exception.status_code, 200)",
            "",
            "    @with_server(create_protocol=HealthCheckServerProtocol)",
            "    def test_ws_connection_ws_endpoint(self):",
            "        # Making a WS connection to a WS endpoint succeeds.",
            "        self.start_client()",
            "        self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "        self.loop.run_until_complete(self.client.recv())",
            "        self.stop_client()",
            "",
            "    def assert_client_raises_code(self, status_code):",
            "        with self.assertRaises(InvalidStatusCode) as raised:",
            "            self.start_client()",
            "        self.assertEqual(raised.exception.status_code, status_code)",
            "",
            "    @with_server(create_protocol=UnauthorizedServerProtocol)",
            "    def test_server_create_protocol(self):",
            "        self.assert_client_raises_code(401)",
            "",
            "    @with_server(create_protocol=(lambda *args, **kwargs:",
            "                 UnauthorizedServerProtocol(*args, **kwargs)))",
            "    def test_server_create_protocol_function(self):",
            "        self.assert_client_raises_code(401)",
            "",
            "    @with_server(klass=UnauthorizedServerProtocol)",
            "    def test_server_klass(self):",
            "        self.assert_client_raises_code(401)",
            "",
            "    @with_server(create_protocol=ForbiddenServerProtocol,",
            "                 klass=UnauthorizedServerProtocol)",
            "    def test_server_create_protocol_over_klass(self):",
            "        self.assert_client_raises_code(403)",
            "",
            "    @with_server()",
            "    @with_client('/path', create_protocol=FooClientProtocol)",
            "    def test_client_create_protocol(self):",
            "        self.assertIsInstance(self.client, FooClientProtocol)",
            "",
            "    @with_server()",
            "    @with_client('/path', create_protocol=(",
            "                 lambda *args, **kwargs: FooClientProtocol(*args, **kwargs)))",
            "    def test_client_create_protocol_function(self):",
            "        self.assertIsInstance(self.client, FooClientProtocol)",
            "",
            "    @with_server()",
            "    @with_client('/path', klass=FooClientProtocol)",
            "    def test_client_klass(self):",
            "        self.assertIsInstance(self.client, FooClientProtocol)",
            "",
            "    @with_server()",
            "    @with_client('/path', create_protocol=BarClientProtocol,",
            "                 klass=FooClientProtocol)",
            "    def test_client_create_protocol_over_klass(self):",
            "        self.assertIsInstance(self.client, BarClientProtocol)",
            "",
            "    @with_server()",
            "    @with_client('/extensions')",
            "    def test_no_extension(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([]))",
            "        self.assertEqual(repr(self.client.extensions), repr([]))",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory()])",
            "    @with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])",
            "    def test_extension(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([NoOpExtension()]))",
            "        self.assertEqual(repr(self.client.extensions), repr([NoOpExtension()]))",
            "",
            "    @with_server()",
            "    @with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])",
            "    def test_extension_not_accepted(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([]))",
            "        self.assertEqual(repr(self.client.extensions), repr([]))",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory()])",
            "    @with_client('/extensions')",
            "    def test_extension_not_requested(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([]))",
            "        self.assertEqual(repr(self.client.extensions), repr([]))",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory([('foo', None)])])",
            "    def test_extension_client_rejection(self):",
            "        with self.assertRaises(NegotiationError):",
            "            self.start_client(",
            "                '/extensions',",
            "                extensions=[ClientNoOpExtensionFactory()],",
            "            )",
            "",
            "    @with_server(",
            "        extensions=[",
            "            # No match because the client doesn't send client_max_window_bits.",
            "            ServerPerMessageDeflateFactory(client_max_window_bits=10),",
            "            ServerPerMessageDeflateFactory(),",
            "        ],",
            "    )",
            "    @with_client(",
            "        '/extensions',",
            "        extensions=[",
            "            ClientPerMessageDeflateFactory(),",
            "        ],",
            "    )",
            "    def test_extension_no_match_then_match(self):",
            "        # The order requested by the client has priority.",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "        ]))",
            "        self.assertEqual(repr(self.client.extensions), repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "        ]))",
            "",
            "    @with_server(extensions=[ServerPerMessageDeflateFactory()])",
            "    @with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])",
            "    def test_extension_mismatch(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([]))",
            "        self.assertEqual(repr(self.client.extensions), repr([]))",
            "",
            "    @with_server(",
            "        extensions=[",
            "            ServerNoOpExtensionFactory(),",
            "            ServerPerMessageDeflateFactory(),",
            "        ],",
            "    )",
            "    @with_client(",
            "        '/extensions',",
            "        extensions=[",
            "            ClientPerMessageDeflateFactory(),",
            "            ClientNoOpExtensionFactory(),",
            "        ],",
            "    )",
            "    def test_extension_order(self):",
            "        # The order requested by the client has priority.",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "            NoOpExtension(),",
            "        ]))",
            "        self.assertEqual(repr(self.client.extensions), repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "            NoOpExtension(),",
            "        ]))",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory()])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_extensions')",
            "    def test_extensions_error(self, _process_extensions):",
            "        _process_extensions.return_value = 'x-no-op', [NoOpExtension()]",
            "",
            "        with self.assertRaises(NegotiationError):",
            "            self.start_client(",
            "                '/extensions',",
            "                extensions=[ClientPerMessageDeflateFactory()],",
            "            )",
            "",
            "    @with_server(extensions=[ServerNoOpExtensionFactory()])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_extensions')",
            "    def test_extensions_error_no_extensions(self, _process_extensions):",
            "        _process_extensions.return_value = 'x-no-op', [NoOpExtension()]",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client('/extensions')",
            "",
            "    @with_server(compression='deflate')",
            "    @with_client('/extensions', compression='deflate')",
            "    def test_compression_deflate(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "        ]))",
            "        self.assertEqual(repr(self.client.extensions), repr([",
            "            PerMessageDeflate(False, False, 15, 15),",
            "        ]))",
            "",
            "    @with_server(",
            "        extensions=[",
            "            ServerPerMessageDeflateFactory(",
            "                client_no_context_takeover=True,",
            "                server_max_window_bits=10,",
            "            ),",
            "        ],",
            "        compression='deflate',  # overridden by explicit config",
            "    )",
            "    @with_client(",
            "        '/extensions',",
            "        extensions=[",
            "            ClientPerMessageDeflateFactory(",
            "                server_no_context_takeover=True,",
            "                client_max_window_bits=12,",
            "            ),",
            "        ],",
            "        compression='deflate',  # overridden by explicit config",
            "    )",
            "    def test_compression_deflate_and_explicit_config(self):",
            "        server_extensions = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_extensions, repr([",
            "            PerMessageDeflate(True, True, 12, 10),",
            "        ]))",
            "        self.assertEqual(repr(self.client.extensions), repr([",
            "            PerMessageDeflate(True, True, 10, 12),",
            "        ]))",
            "",
            "    def test_compression_unsupported_server(self):",
            "        with self.assertRaises(ValueError):",
            "            self.loop.run_until_complete(self.start_server(compression='xz'))",
            "",
            "    @with_server()",
            "    def test_compression_unsupported_client(self):",
            "        with self.assertRaises(ValueError):",
            "            self.loop.run_until_complete(self.start_client(compression='xz'))",
            "",
            "    @with_server()",
            "    @with_client('/subprotocol')",
            "    def test_no_subprotocol(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr(None))",
            "        self.assertEqual(self.client.subprotocol, None)",
            "",
            "    @with_server(subprotocols=['superchat', 'chat'])",
            "    @with_client('/subprotocol', subprotocols=['otherchat', 'chat'])",
            "    def test_subprotocol(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr('chat'))",
            "        self.assertEqual(self.client.subprotocol, 'chat')",
            "",
            "    @with_server(subprotocols=['superchat'])",
            "    @with_client('/subprotocol', subprotocols=['otherchat'])",
            "    def test_subprotocol_not_accepted(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr(None))",
            "        self.assertEqual(self.client.subprotocol, None)",
            "",
            "    @with_server()",
            "    @with_client('/subprotocol', subprotocols=['otherchat', 'chat'])",
            "    def test_subprotocol_not_offered(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr(None))",
            "        self.assertEqual(self.client.subprotocol, None)",
            "",
            "    @with_server(subprotocols=['superchat', 'chat'])",
            "    @with_client('/subprotocol')",
            "    def test_subprotocol_not_requested(self):",
            "        server_subprotocol = self.loop.run_until_complete(self.client.recv())",
            "        self.assertEqual(server_subprotocol, repr(None))",
            "        self.assertEqual(self.client.subprotocol, None)",
            "",
            "    @with_server(subprotocols=['superchat'])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')",
            "    def test_subprotocol_error(self, _process_subprotocol):",
            "        _process_subprotocol.return_value = 'superchat'",
            "",
            "        with self.assertRaises(NegotiationError):",
            "            self.start_client('/subprotocol', subprotocols=['otherchat'])",
            "        self.run_loop_once()",
            "",
            "    @with_server(subprotocols=['superchat'])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')",
            "    def test_subprotocol_error_no_subprotocols(self, _process_subprotocol):",
            "        _process_subprotocol.return_value = 'superchat'",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client('/subprotocol')",
            "        self.run_loop_once()",
            "",
            "    @with_server(subprotocols=['superchat', 'chat'])",
            "    @unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')",
            "    def test_subprotocol_error_two_subprotocols(self, _process_subprotocol):",
            "        _process_subprotocol.return_value = 'superchat, chat'",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client(",
            "                '/subprotocol', subprotocols=['superchat', 'chat'])",
            "        self.run_loop_once()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.read_request')",
            "    def test_server_receives_malformed_request(self, _read_request):",
            "        _read_request.side_effect = ValueError(\"read_request failed\")",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.client.read_response')",
            "    def test_client_receives_malformed_response(self, _read_response):",
            "        _read_response.side_effect = ValueError(\"read_response failed\")",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "        self.run_loop_once()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.client.build_request')",
            "    def test_client_sends_invalid_handshake_request(self, _build_request):",
            "        def wrong_build_request(set_header):",
            "            return '42'",
            "        _build_request.side_effect = wrong_build_request",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.build_response')",
            "    def test_server_sends_invalid_handshake_response(self, _build_response):",
            "        def wrong_build_response(set_header, key):",
            "            return build_response(set_header, '42')",
            "        _build_response.side_effect = wrong_build_response",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.client.read_response')",
            "    def test_server_does_not_switch_protocols(self, _read_response):",
            "        @asyncio.coroutine",
            "        def wrong_read_response(stream):",
            "            status_code, headers = yield from read_response(stream)",
            "            return 400, headers",
            "        _read_response.side_effect = wrong_read_response",
            "",
            "        with self.assertRaises(InvalidStatusCode):",
            "            self.start_client()",
            "        self.run_loop_once()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch(",
            "        'websockets.server.WebSocketServerProtocol.process_request')",
            "    def test_server_error_in_handshake(self, _process_request):",
            "        _process_request.side_effect = Exception(\"process_request crashed\")",
            "",
            "        with self.assertRaises(InvalidHandshake):",
            "            self.start_client()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.WebSocketServerProtocol.send')",
            "    def test_server_handler_crashes(self, send):",
            "        send.side_effect = ValueError(\"send failed\")",
            "",
            "        with self.temp_client():",
            "            self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "            with self.assertRaises(ConnectionClosed):",
            "                self.loop.run_until_complete(self.client.recv())",
            "",
            "        # Connection ends with an unexpected error.",
            "        self.assertEqual(self.client.close_code, 1011)",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')",
            "    def test_server_close_crashes(self, close):",
            "        close.side_effect = ValueError(\"close failed\")",
            "",
            "        with self.temp_client():",
            "            self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "            reply = self.loop.run_until_complete(self.client.recv())",
            "            self.assertEqual(reply, \"Hello!\")",
            "",
            "        # Connection ends with an abnormal closure.",
            "        self.assertEqual(self.client.close_code, 1006)",
            "",
            "    @with_server()",
            "    @with_client()",
            "    @unittest.mock.patch.object(WebSocketClientProtocol, 'handshake')",
            "    def test_client_closes_connection_before_handshake(self, handshake):",
            "        # We have mocked the handshake() method to prevent the client from",
            "        # performing the opening handshake. Force it to close the connection.",
            "        self.client.writer.close()",
            "        # The server should stop properly anyway. It used to hang because the",
            "        # task handling the connection was waiting for the opening handshake.",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.read_request')",
            "    def test_server_shuts_down_during_opening_handshake(self, _read_request):",
            "        _read_request.side_effect = asyncio.CancelledError",
            "",
            "        self.server.closing = True",
            "        with self.assertRaises(InvalidHandshake) as raised:",
            "            self.start_client()",
            "",
            "        # Opening handshake fails with 503 Service Unavailable",
            "        self.assertEqual(str(raised.exception), \"Status code not 101: 503\")",
            "",
            "    @with_server()",
            "    def test_server_shuts_down_during_connection_handling(self):",
            "        with self.temp_client():",
            "            self.server.close()",
            "            with self.assertRaises(ConnectionClosed):",
            "                self.loop.run_until_complete(self.client.recv())",
            "",
            "        # Websocket connection terminates with 1001 Going Away.",
            "        self.assertEqual(self.client.close_code, 1001)",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')",
            "    def test_server_shuts_down_during_connection_close(self, _close):",
            "        _close.side_effect = asyncio.CancelledError",
            "",
            "        self.server.closing = True",
            "        with self.temp_client():",
            "            self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "            reply = self.loop.run_until_complete(self.client.recv())",
            "            self.assertEqual(reply, \"Hello!\")",
            "",
            "        # Websocket connection terminates abnormally.",
            "        self.assertEqual(self.client.close_code, 1006)",
            "",
            "    @with_server(create_protocol=ForbiddenServerProtocol)",
            "    def test_invalid_status_error_during_client_connect(self):",
            "        with self.assertRaises(InvalidStatusCode) as raised:",
            "            self.start_client()",
            "        exception = raised.exception",
            "        self.assertEqual(str(exception), \"Status code not 101: 403\")",
            "        self.assertEqual(exception.status_code, 403)",
            "",
            "    @with_server()",
            "    @unittest.mock.patch(",
            "        'websockets.server.WebSocketServerProtocol.write_http_response')",
            "    @unittest.mock.patch(",
            "        'websockets.server.WebSocketServerProtocol.read_http_request')",
            "    def test_connection_error_during_opening_handshake(",
            "            self, _read_http_request, _write_http_response):",
            "        _read_http_request.side_effect = ConnectionError",
            "",
            "        # This exception is currently platform-dependent. It was observed to",
            "        # be ConnectionResetError on Linux in the non-SSL case, and",
            "        # InvalidMessage otherwise (including both Linux and macOS). This",
            "        # doesn't matter though since this test is primarily for testing a",
            "        # code path on the server side.",
            "        with self.assertRaises(Exception):",
            "            self.start_client()",
            "",
            "        # No response must not be written if the network connection is broken.",
            "        _write_http_response.assert_not_called()",
            "",
            "    @with_server()",
            "    @unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')",
            "    def test_connection_error_during_closing_handshake(self, close):",
            "        close.side_effect = ConnectionError",
            "",
            "        with self.temp_client():",
            "            self.loop.run_until_complete(self.client.send(\"Hello!\"))",
            "            reply = self.loop.run_until_complete(self.client.recv())",
            "            self.assertEqual(reply, \"Hello!\")",
            "",
            "        # Connection ends with an abnormal closure.",
            "        self.assertEqual(self.client.close_code, 1006)",
            "",
            "",
            "class SSLClientServerTests(ClientServerTests):",
            "",
            "    secure = True",
            "",
            "    @property",
            "    def server_context(self):",
            "        # Change to ssl.PROTOCOL_TLS_SERVER when dropping Python < 3.6.",
            "        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)",
            "        ssl_context.load_cert_chain(testcert)",
            "        return ssl_context",
            "",
            "    @property",
            "    def client_context(self):",
            "        # Change to ssl.PROTOCOL_TLS_CLIENT when dropping Python < 3.6.",
            "        # Then remove verify_mode and check_hostname below.",
            "        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)",
            "        ssl_context.load_verify_locations(testcert)",
            "        ssl_context.verify_mode = ssl.CERT_REQUIRED",
            "        # ssl.match_hostname can't match IP addresses on Python < 3.5.",
            "        # We're using IP addresses to enforce testing of IPv4 and IPv6.",
            "        if sys.version_info[:2] >= (3, 5):                  # pragma: no cover",
            "            ssl_context.check_hostname = True",
            "        return ssl_context",
            "",
            "    def start_server(self, **kwds):",
            "        kwds.setdefault('ssl', self.server_context)",
            "        super().start_server(**kwds)",
            "",
            "    def start_client(self, path='/', **kwds):",
            "        kwds.setdefault('ssl', self.client_context)",
            "        super().start_client(path, **kwds)",
            "",
            "    # TLS over Unix sockets doesn't make sense.",
            "    test_unix_socket = None",
            "",
            "    @with_server()",
            "    def test_ws_uri_is_rejected(self):",
            "        with self.assertRaises(ValueError):",
            "            client = connect(",
            "                get_server_uri(self.server, secure=False),",
            "                ssl=self.client_context,",
            "            )",
            "            # With Python \u2265 3.5, the exception is raised by connect() even",
            "            # before awaiting.  However, with Python 3.4 the exception is",
            "            # raised only when awaiting.",
            "            self.loop.run_until_complete(client)          # pragma: no cover",
            "",
            "",
            "class ClientServerOriginTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.loop = asyncio.new_event_loop()",
            "        asyncio.set_event_loop(self.loop)",
            "",
            "    def tearDown(self):",
            "        self.loop.close()",
            "",
            "    def test_checking_origin_succeeds(self):",
            "        server = self.loop.run_until_complete(",
            "            serve(handler, 'localhost', 0, origins=['http://localhost']))",
            "        client = self.loop.run_until_complete(",
            "            connect(get_server_uri(server), origin='http://localhost'))",
            "",
            "        self.loop.run_until_complete(client.send(\"Hello!\"))",
            "        self.assertEqual(self.loop.run_until_complete(client.recv()), \"Hello!\")",
            "",
            "        self.loop.run_until_complete(client.close())",
            "        server.close()",
            "        self.loop.run_until_complete(server.wait_closed())",
            "",
            "    def test_checking_origin_fails(self):",
            "        server = self.loop.run_until_complete(",
            "            serve(handler, 'localhost', 0, origins=['http://localhost']))",
            "        with self.assertRaisesRegex(InvalidHandshake,",
            "                                    \"Status code not 101: 403\"):",
            "            self.loop.run_until_complete(",
            "                connect(get_server_uri(server), origin='http://otherhost'))",
            "",
            "        server.close()",
            "        self.loop.run_until_complete(server.wait_closed())",
            "",
            "    def test_checking_lack_of_origin_succeeds(self):",
            "        server = self.loop.run_until_complete(",
            "            serve(handler, 'localhost', 0, origins=['']))",
            "        client = self.loop.run_until_complete(connect(get_server_uri(server)))",
            "",
            "        self.loop.run_until_complete(client.send(\"Hello!\"))",
            "        self.assertEqual(self.loop.run_until_complete(client.recv()), \"Hello!\")",
            "",
            "        self.loop.run_until_complete(client.close())",
            "        server.close()",
            "        self.loop.run_until_complete(server.wait_closed())",
            "",
            "",
            "try:",
            "    from .py35._test_client_server import ContextManagerTests           # noqa",
            "except (SyntaxError, ImportError):                          # pragma: no cover",
            "    pass",
            "",
            "",
            "try:",
            "    from .py36._test_client_server import AsyncIteratorTests            # noqa",
            "except (SyntaxError, ImportError):                          # pragma: no cover",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "207": [
                "NoOpExtension",
                "decode"
            ]
        },
        "addLocation": []
    },
    "websockets/test_framing.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "                 return frame._replace(data=data)"
            },
            "1": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "             # This extensions is symmetrical."
            },
            "3": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            decode = encode"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+            @staticmethod"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            def decode(frame, *, max_size=None):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+                return Rot13.encode(frame)"
            },
            "7": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 223,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "         self.round_trip("
            },
            "9": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "             b'\\x81\\x05uryyb',"
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import codecs",
            "import unittest",
            "import unittest.mock",
            "",
            "from .exceptions import PayloadTooBig, WebSocketProtocolError",
            "from .framing import *",
            "",
            "",
            "class FramingTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.loop = asyncio.new_event_loop()",
            "        asyncio.set_event_loop(self.loop)",
            "",
            "    def tearDown(self):",
            "        self.loop.close()",
            "",
            "    def decode(self, message, mask=False, max_size=None, extensions=None):",
            "        self.stream = asyncio.StreamReader(loop=self.loop)",
            "        self.stream.feed_data(message)",
            "        self.stream.feed_eof()",
            "        frame = self.loop.run_until_complete(Frame.read(",
            "            self.stream.readexactly, mask=mask,",
            "            max_size=max_size, extensions=extensions,",
            "        ))",
            "        # Make sure all the data was consumed.",
            "        self.assertTrue(self.stream.at_eof())",
            "        return frame",
            "",
            "    def encode(self, frame, mask=False, extensions=None):",
            "        writer = unittest.mock.Mock()",
            "        frame.write(writer, mask=mask, extensions=extensions)",
            "        # Ensure the entire frame is sent with a single call to writer().",
            "        # Multiple calls cause TCP fragmentation and degrade performance.",
            "        self.assertEqual(writer.call_count, 1)",
            "        # The frame data is the single positional argument of that call.",
            "        self.assertEqual(len(writer.call_args[0]), 1)",
            "        self.assertEqual(len(writer.call_args[1]), 0)",
            "        return writer.call_args[0][0]",
            "",
            "    def round_trip(self, message, expected, mask=False, extensions=None):",
            "        decoded = self.decode(message, mask, extensions=extensions)",
            "        self.assertEqual(decoded, expected)",
            "        encoded = self.encode(decoded, mask, extensions=extensions)",
            "        if mask:    # non-deterministic encoding",
            "            decoded = self.decode(encoded, mask, extensions=extensions)",
            "            self.assertEqual(decoded, expected)",
            "        else:       # deterministic encoding",
            "            self.assertEqual(encoded, message)",
            "",
            "    def round_trip_close(self, data, code, reason):",
            "        parsed = parse_close(data)",
            "        self.assertEqual(parsed, (code, reason))",
            "        serialized = serialize_close(code, reason)",
            "        self.assertEqual(serialized, data)",
            "",
            "    def test_text(self):",
            "        self.round_trip(",
            "            b'\\x81\\x04Spam',",
            "            Frame(True, OP_TEXT, b'Spam'),",
            "        )",
            "",
            "    def test_text_masked(self):",
            "        self.round_trip(",
            "            b'\\x81\\x84\\x5b\\xfb\\xe1\\xa8\\x08\\x8b\\x80\\xc5',",
            "            Frame(True, OP_TEXT, b'Spam'),",
            "            mask=True,",
            "        )",
            "",
            "    def test_binary(self):",
            "        self.round_trip(",
            "            b'\\x82\\x04Eggs',",
            "            Frame(True, OP_BINARY, b'Eggs'),",
            "        )",
            "",
            "    def test_binary_masked(self):",
            "        self.round_trip(",
            "            b'\\x82\\x84\\x53\\xcd\\xe2\\x89\\x16\\xaa\\x85\\xfa',",
            "            Frame(True, OP_BINARY, b'Eggs'),",
            "            mask=True,",
            "        )",
            "",
            "    def test_non_ascii_text(self):",
            "        self.round_trip(",
            "            b'\\x81\\x05caf\\xc3\\xa9',",
            "            Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8')),",
            "        )",
            "",
            "    def test_non_ascii_text_masked(self):",
            "        self.round_trip(",
            "            b'\\x81\\x85\\x64\\xbe\\xee\\x7e\\x07\\xdf\\x88\\xbd\\xcd',",
            "            Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8')),",
            "            mask=True,",
            "        )",
            "",
            "    def test_close(self):",
            "        self.round_trip(",
            "            b'\\x88\\x00',",
            "            Frame(True, OP_CLOSE, b''),",
            "        )",
            "",
            "    def test_ping(self):",
            "        self.round_trip(",
            "            b'\\x89\\x04ping',",
            "            Frame(True, OP_PING, b'ping'),",
            "        )",
            "",
            "    def test_pong(self):",
            "        self.round_trip(",
            "            b'\\x8a\\x04pong',",
            "            Frame(True, OP_PONG, b'pong'),",
            "        )",
            "",
            "    def test_long(self):",
            "        self.round_trip(",
            "            b'\\x82\\x7e\\x00\\x7e' + 126 * b'a',",
            "            Frame(True, OP_BINARY, 126 * b'a'),",
            "        )",
            "",
            "    def test_very_long(self):",
            "        self.round_trip(",
            "            b'\\x82\\x7f\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00' + 65536 * b'a',",
            "            Frame(True, OP_BINARY, 65536 * b'a'),",
            "        )",
            "",
            "    def test_payload_too_big(self):",
            "        with self.assertRaises(PayloadTooBig):",
            "            self.decode(",
            "                b'\\x82\\x7e\\x04\\x01' + 1025 * b'a',",
            "                max_size=1024,",
            "            )",
            "",
            "    def test_bad_reserved_bits(self):",
            "        for encoded in [b'\\xc0\\x00', b'\\xa0\\x00', b'\\x90\\x00']:",
            "            with self.subTest(encoded=encoded):",
            "                with self.assertRaises(WebSocketProtocolError):",
            "                    self.decode(encoded)",
            "",
            "    def test_good_opcode(self):",
            "        for opcode in list(range(0x00, 0x03)) + list(range(0x08, 0x0b)):",
            "            encoded = bytes([0x80 | opcode, 0])",
            "            with self.subTest(encoded=encoded):",
            "                self.decode(encoded)            # does not raise an exception",
            "",
            "    def test_bad_opcode(self):",
            "        for opcode in list(range(0x03, 0x08)) + list(range(0x0b, 0x10)):",
            "            encoded = bytes([0x80 | opcode, 0])",
            "            with self.subTest(encoded=encoded):",
            "                with self.assertRaises(WebSocketProtocolError):",
            "                    self.decode(encoded)",
            "",
            "    def test_mask_flag(self):",
            "        # Mask flag correctly set.",
            "        self.decode(b'\\x80\\x80\\x00\\x00\\x00\\x00', mask=True)",
            "        # Mask flag incorrectly unset.",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            self.decode(b'\\x80\\x80\\x00\\x00\\x00\\x00')",
            "        # Mask flag correctly unset.",
            "        self.decode(b'\\x80\\x00')",
            "        # Mask flag incorrectly set.",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            self.decode(b'\\x80\\x00', mask=True)",
            "",
            "    def test_control_frame_max_length(self):",
            "        # At maximum allowed length.",
            "        self.decode(b'\\x88\\x7e\\x00\\x7d' + 125 * b'a')",
            "        # Above maximum allowed length.",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            self.decode(b'\\x88\\x7e\\x00\\x7e' + 126 * b'a')",
            "",
            "    def test_encode_data_str(self):",
            "        self.assertEqual(encode_data('caf\u00e9'), b'caf\\xc3\\xa9')",
            "",
            "    def test_encode_data_bytes(self):",
            "        self.assertEqual(encode_data(b'tea'), b'tea')",
            "",
            "    def test_encode_data_other(self):",
            "        with self.assertRaises(TypeError):",
            "            encode_data(None)",
            "",
            "    def test_fragmented_control_frame(self):",
            "        # Fin bit correctly set.",
            "        self.decode(b'\\x88\\x00')",
            "        # Fin bit incorrectly unset.",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            self.decode(b'\\x08\\x00')",
            "",
            "    def test_parse_close_and_serialize_close(self):",
            "        self.round_trip_close(b'\\x03\\xe8', 1000, '')",
            "        self.round_trip_close(b'\\x03\\xe8OK', 1000, 'OK')",
            "",
            "    def test_parse_close_empty(self):",
            "        self.assertEqual(parse_close(b''), (1005, ''))",
            "",
            "    def test_parse_close_errors(self):",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            parse_close(b'\\x03')",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            parse_close(b'\\x03\\xe7')",
            "        with self.assertRaises(UnicodeDecodeError):",
            "            parse_close(b'\\x03\\xe8\\xff\\xff')",
            "",
            "    def test_serialize_close_errors(self):",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            serialize_close(999, '')",
            "",
            "    def test_extensions(self):",
            "",
            "        class Rot13:",
            "",
            "            @staticmethod",
            "            def encode(frame):",
            "                assert frame.opcode == OP_TEXT",
            "                text = frame.data.decode()",
            "                data = codecs.encode(text, 'rot13').encode()",
            "                return frame._replace(data=data)",
            "",
            "            # This extensions is symmetrical.",
            "            decode = encode",
            "",
            "        self.round_trip(",
            "            b'\\x81\\x05uryyb',",
            "            Frame(True, OP_TEXT, b'hello'),",
            "            extensions=[Rot13()],",
            "        )"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import codecs",
            "import unittest",
            "import unittest.mock",
            "",
            "from .exceptions import PayloadTooBig, WebSocketProtocolError",
            "from .framing import *",
            "",
            "",
            "class FramingTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.loop = asyncio.new_event_loop()",
            "        asyncio.set_event_loop(self.loop)",
            "",
            "    def tearDown(self):",
            "        self.loop.close()",
            "",
            "    def decode(self, message, mask=False, max_size=None, extensions=None):",
            "        self.stream = asyncio.StreamReader(loop=self.loop)",
            "        self.stream.feed_data(message)",
            "        self.stream.feed_eof()",
            "        frame = self.loop.run_until_complete(Frame.read(",
            "            self.stream.readexactly, mask=mask,",
            "            max_size=max_size, extensions=extensions,",
            "        ))",
            "        # Make sure all the data was consumed.",
            "        self.assertTrue(self.stream.at_eof())",
            "        return frame",
            "",
            "    def encode(self, frame, mask=False, extensions=None):",
            "        writer = unittest.mock.Mock()",
            "        frame.write(writer, mask=mask, extensions=extensions)",
            "        # Ensure the entire frame is sent with a single call to writer().",
            "        # Multiple calls cause TCP fragmentation and degrade performance.",
            "        self.assertEqual(writer.call_count, 1)",
            "        # The frame data is the single positional argument of that call.",
            "        self.assertEqual(len(writer.call_args[0]), 1)",
            "        self.assertEqual(len(writer.call_args[1]), 0)",
            "        return writer.call_args[0][0]",
            "",
            "    def round_trip(self, message, expected, mask=False, extensions=None):",
            "        decoded = self.decode(message, mask, extensions=extensions)",
            "        self.assertEqual(decoded, expected)",
            "        encoded = self.encode(decoded, mask, extensions=extensions)",
            "        if mask:    # non-deterministic encoding",
            "            decoded = self.decode(encoded, mask, extensions=extensions)",
            "            self.assertEqual(decoded, expected)",
            "        else:       # deterministic encoding",
            "            self.assertEqual(encoded, message)",
            "",
            "    def round_trip_close(self, data, code, reason):",
            "        parsed = parse_close(data)",
            "        self.assertEqual(parsed, (code, reason))",
            "        serialized = serialize_close(code, reason)",
            "        self.assertEqual(serialized, data)",
            "",
            "    def test_text(self):",
            "        self.round_trip(",
            "            b'\\x81\\x04Spam',",
            "            Frame(True, OP_TEXT, b'Spam'),",
            "        )",
            "",
            "    def test_text_masked(self):",
            "        self.round_trip(",
            "            b'\\x81\\x84\\x5b\\xfb\\xe1\\xa8\\x08\\x8b\\x80\\xc5',",
            "            Frame(True, OP_TEXT, b'Spam'),",
            "            mask=True,",
            "        )",
            "",
            "    def test_binary(self):",
            "        self.round_trip(",
            "            b'\\x82\\x04Eggs',",
            "            Frame(True, OP_BINARY, b'Eggs'),",
            "        )",
            "",
            "    def test_binary_masked(self):",
            "        self.round_trip(",
            "            b'\\x82\\x84\\x53\\xcd\\xe2\\x89\\x16\\xaa\\x85\\xfa',",
            "            Frame(True, OP_BINARY, b'Eggs'),",
            "            mask=True,",
            "        )",
            "",
            "    def test_non_ascii_text(self):",
            "        self.round_trip(",
            "            b'\\x81\\x05caf\\xc3\\xa9',",
            "            Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8')),",
            "        )",
            "",
            "    def test_non_ascii_text_masked(self):",
            "        self.round_trip(",
            "            b'\\x81\\x85\\x64\\xbe\\xee\\x7e\\x07\\xdf\\x88\\xbd\\xcd',",
            "            Frame(True, OP_TEXT, 'caf\u00e9'.encode('utf-8')),",
            "            mask=True,",
            "        )",
            "",
            "    def test_close(self):",
            "        self.round_trip(",
            "            b'\\x88\\x00',",
            "            Frame(True, OP_CLOSE, b''),",
            "        )",
            "",
            "    def test_ping(self):",
            "        self.round_trip(",
            "            b'\\x89\\x04ping',",
            "            Frame(True, OP_PING, b'ping'),",
            "        )",
            "",
            "    def test_pong(self):",
            "        self.round_trip(",
            "            b'\\x8a\\x04pong',",
            "            Frame(True, OP_PONG, b'pong'),",
            "        )",
            "",
            "    def test_long(self):",
            "        self.round_trip(",
            "            b'\\x82\\x7e\\x00\\x7e' + 126 * b'a',",
            "            Frame(True, OP_BINARY, 126 * b'a'),",
            "        )",
            "",
            "    def test_very_long(self):",
            "        self.round_trip(",
            "            b'\\x82\\x7f\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00' + 65536 * b'a',",
            "            Frame(True, OP_BINARY, 65536 * b'a'),",
            "        )",
            "",
            "    def test_payload_too_big(self):",
            "        with self.assertRaises(PayloadTooBig):",
            "            self.decode(",
            "                b'\\x82\\x7e\\x04\\x01' + 1025 * b'a',",
            "                max_size=1024,",
            "            )",
            "",
            "    def test_bad_reserved_bits(self):",
            "        for encoded in [b'\\xc0\\x00', b'\\xa0\\x00', b'\\x90\\x00']:",
            "            with self.subTest(encoded=encoded):",
            "                with self.assertRaises(WebSocketProtocolError):",
            "                    self.decode(encoded)",
            "",
            "    def test_good_opcode(self):",
            "        for opcode in list(range(0x00, 0x03)) + list(range(0x08, 0x0b)):",
            "            encoded = bytes([0x80 | opcode, 0])",
            "            with self.subTest(encoded=encoded):",
            "                self.decode(encoded)            # does not raise an exception",
            "",
            "    def test_bad_opcode(self):",
            "        for opcode in list(range(0x03, 0x08)) + list(range(0x0b, 0x10)):",
            "            encoded = bytes([0x80 | opcode, 0])",
            "            with self.subTest(encoded=encoded):",
            "                with self.assertRaises(WebSocketProtocolError):",
            "                    self.decode(encoded)",
            "",
            "    def test_mask_flag(self):",
            "        # Mask flag correctly set.",
            "        self.decode(b'\\x80\\x80\\x00\\x00\\x00\\x00', mask=True)",
            "        # Mask flag incorrectly unset.",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            self.decode(b'\\x80\\x80\\x00\\x00\\x00\\x00')",
            "        # Mask flag correctly unset.",
            "        self.decode(b'\\x80\\x00')",
            "        # Mask flag incorrectly set.",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            self.decode(b'\\x80\\x00', mask=True)",
            "",
            "    def test_control_frame_max_length(self):",
            "        # At maximum allowed length.",
            "        self.decode(b'\\x88\\x7e\\x00\\x7d' + 125 * b'a')",
            "        # Above maximum allowed length.",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            self.decode(b'\\x88\\x7e\\x00\\x7e' + 126 * b'a')",
            "",
            "    def test_encode_data_str(self):",
            "        self.assertEqual(encode_data('caf\u00e9'), b'caf\\xc3\\xa9')",
            "",
            "    def test_encode_data_bytes(self):",
            "        self.assertEqual(encode_data(b'tea'), b'tea')",
            "",
            "    def test_encode_data_other(self):",
            "        with self.assertRaises(TypeError):",
            "            encode_data(None)",
            "",
            "    def test_fragmented_control_frame(self):",
            "        # Fin bit correctly set.",
            "        self.decode(b'\\x88\\x00')",
            "        # Fin bit incorrectly unset.",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            self.decode(b'\\x08\\x00')",
            "",
            "    def test_parse_close_and_serialize_close(self):",
            "        self.round_trip_close(b'\\x03\\xe8', 1000, '')",
            "        self.round_trip_close(b'\\x03\\xe8OK', 1000, 'OK')",
            "",
            "    def test_parse_close_empty(self):",
            "        self.assertEqual(parse_close(b''), (1005, ''))",
            "",
            "    def test_parse_close_errors(self):",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            parse_close(b'\\x03')",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            parse_close(b'\\x03\\xe7')",
            "        with self.assertRaises(UnicodeDecodeError):",
            "            parse_close(b'\\x03\\xe8\\xff\\xff')",
            "",
            "    def test_serialize_close_errors(self):",
            "        with self.assertRaises(WebSocketProtocolError):",
            "            serialize_close(999, '')",
            "",
            "    def test_extensions(self):",
            "",
            "        class Rot13:",
            "",
            "            @staticmethod",
            "            def encode(frame):",
            "                assert frame.opcode == OP_TEXT",
            "                text = frame.data.decode()",
            "                data = codecs.encode(text, 'rot13').encode()",
            "                return frame._replace(data=data)",
            "",
            "            # This extensions is symmetrical.",
            "            @staticmethod",
            "            def decode(frame, *, max_size=None):",
            "                return Rot13.encode(frame)",
            "",
            "        self.round_trip(",
            "            b'\\x81\\x05uryyb',",
            "            Frame(True, OP_TEXT, b'hello'),",
            "            extensions=[Rot13()],",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "220": [
                "FramingTests",
                "test_extensions",
                "Rot13"
            ]
        },
        "addLocation": []
    }
}