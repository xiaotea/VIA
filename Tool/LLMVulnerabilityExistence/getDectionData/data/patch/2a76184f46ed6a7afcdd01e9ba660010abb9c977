{
    "notebook/services/contents/filemanager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "         model['type'] = 'file'"
            },
            "1": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 364,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "         os_path = self._get_os_path(path)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+        four_o_four = \"file does not exist: %r\" % path"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+            self.log.info(\"Refusing to serve hidden file or file in hidden directory %r, via 404 Error\", os_path)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+            raise web.HTTPError(404, four_o_four)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "         model['mimetype'] = mimetypes.guess_type(os_path)[0]"
            },
            "11": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 374,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "         if content:"
            }
        },
        "frontPatchFile": [
            "\"\"\"A contents manager that uses the local file system for storage.\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "from datetime import datetime",
            "import errno",
            "import os",
            "import shutil",
            "import stat",
            "import sys",
            "import warnings",
            "import mimetypes",
            "import nbformat",
            "",
            "from send2trash import send2trash",
            "from send2trash.exceptions import TrashPermissionError",
            "from tornado import web",
            "",
            "from .filecheckpoints import FileCheckpoints",
            "from .fileio import FileManagerMixin",
            "from .manager import ContentsManager",
            "from ...utils import exists",
            "",
            "from ipython_genutils.importstring import import_item",
            "from traitlets import Any, Unicode, Bool, TraitError, observe, default, validate",
            "from ipython_genutils.py3compat import getcwd, string_types",
            "",
            "from notebook import _tz as tz",
            "from notebook.utils import (",
            "    is_hidden, is_file_hidden,",
            "    to_api_path,",
            ")",
            "from notebook.base.handlers import AuthenticatedFileHandler",
            "from notebook.transutils import _",
            "",
            "from os.path import samefile",
            "",
            "_script_exporter = None",
            "",
            "",
            "def _post_save_script(model, os_path, contents_manager, **kwargs):",
            "    \"\"\"convert notebooks to Python script after save with nbconvert",
            "",
            "    replaces `jupyter notebook --script`",
            "    \"\"\"",
            "    from nbconvert.exporters.script import ScriptExporter",
            "    warnings.warn(\"`_post_save_script` is deprecated and will be removed in Notebook 5.0\", DeprecationWarning)",
            "",
            "    if model['type'] != 'notebook':",
            "        return",
            "",
            "    global _script_exporter",
            "    if _script_exporter is None:",
            "        _script_exporter = ScriptExporter(parent=contents_manager)",
            "    log = contents_manager.log",
            "",
            "    base, ext = os.path.splitext(os_path)",
            "    script, resources = _script_exporter.from_filename(os_path)",
            "    script_fname = base + resources.get('output_extension', '.txt')",
            "    log.info(\"Saving script /%s\", to_api_path(script_fname, contents_manager.root_dir))",
            "    with open(script_fname, 'w', encoding='utf-8') as f:",
            "        f.write(script)",
            "",
            "",
            "class FileContentsManager(FileManagerMixin, ContentsManager):",
            "",
            "    root_dir = Unicode(config=True)",
            "",
            "    @default('root_dir')",
            "    def _default_root_dir(self):",
            "        try:",
            "            return self.parent.notebook_dir",
            "        except AttributeError:",
            "            return getcwd()",
            "",
            "    save_script = Bool(False, config=True, help='DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0')",
            "    @observe('save_script')",
            "    def _update_save_script(self, change):",
            "        if not change['new']:",
            "            return",
            "        self.log.warning(\"\"\"",
            "        `--script` is deprecated and will be removed in notebook 5.0.",
            "",
            "        You can trigger nbconvert via pre- or post-save hooks:",
            "",
            "            ContentsManager.pre_save_hook",
            "            FileContentsManager.post_save_hook",
            "",
            "        A post-save hook has been registered that calls:",
            "",
            "            jupyter nbconvert --to script [notebook]",
            "",
            "        which behaves similarly to `--script`.",
            "        \"\"\")",
            "",
            "        self.post_save_hook = _post_save_script",
            "",
            "    post_save_hook = Any(None, config=True, allow_none=True,",
            "        help=\"\"\"Python callable or importstring thereof",
            "",
            "        to be called on the path of a file just saved.",
            "",
            "        This can be used to process the file on disk,",
            "        such as converting the notebook to a script or HTML via nbconvert.",
            "",
            "        It will be called as (all arguments passed by keyword)::",
            "",
            "            hook(os_path=os_path, model=model, contents_manager=instance)",
            "",
            "        - path: the filesystem path to the file just written",
            "        - model: the model representing the file",
            "        - contents_manager: this ContentsManager instance",
            "        \"\"\"",
            "    )",
            "",
            "    @validate('post_save_hook')",
            "    def _validate_post_save_hook(self, proposal):",
            "        value = proposal['value']",
            "        if isinstance(value, string_types):",
            "            value = import_item(value)",
            "        if not callable(value):",
            "            raise TraitError(\"post_save_hook must be callable\")",
            "        return value",
            "",
            "    def run_post_save_hook(self, model, os_path):",
            "        \"\"\"Run the post-save hook if defined, and log errors\"\"\"",
            "        if self.post_save_hook:",
            "            try:",
            "                self.log.debug(\"Running post-save hook on %s\", os_path)",
            "                self.post_save_hook(os_path=os_path, model=model, contents_manager=self)",
            "            except Exception as e:",
            "                self.log.error(\"Post-save hook failed o-n %s\", os_path, exc_info=True)",
            "                raise web.HTTPError(500, f'Unexpected error while running post hook save: {e}') from e",
            "",
            "    @validate('root_dir')",
            "    def _validate_root_dir(self, proposal):",
            "        \"\"\"Do a bit of validation of the root_dir.\"\"\"",
            "        value = proposal['value']",
            "        if not os.path.isabs(value):",
            "            # If we receive a non-absolute path, make it absolute.",
            "            value = os.path.abspath(value)",
            "        if not os.path.isdir(value):",
            "            raise TraitError(f\"{value!r} is not a directory\")",
            "        return value",
            "",
            "    @default('checkpoints_class')",
            "    def _checkpoints_class_default(self):",
            "        return FileCheckpoints",
            "",
            "    delete_to_trash = Bool(True, config=True,",
            "        help=\"\"\"If True (default), deleting files will send them to the",
            "        platform's trash/recycle bin, where they can be recovered. If False,",
            "        deleting files really deletes them.\"\"\")",
            "",
            "    @default('files_handler_class')",
            "    def _files_handler_class_default(self):",
            "        return AuthenticatedFileHandler",
            "",
            "    @default('files_handler_params')",
            "    def _files_handler_params_default(self):",
            "        return {'path': self.root_dir}",
            "",
            "    def is_hidden(self, path):",
            "        \"\"\"Does the API style path correspond to a hidden directory or file?",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        hidden : bool",
            "            Whether the path exists and is hidden.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return is_hidden(os_path, self.root_dir)",
            "",
            "    def file_exists(self, path):",
            "        \"\"\"Returns True if the file exists, else returns False.",
            "",
            "        API-style wrapper for os.path.isfile",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The relative path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the file exists.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path)",
            "        return os.path.isfile(os_path)",
            "",
            "    def dir_exists(self, path):",
            "        \"\"\"Does the API-style path refer to an extant directory?",
            "",
            "        API-style wrapper for os.path.isdir",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the path is indeed a directory.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.isdir(os_path)",
            "",
            "    def exists(self, path):",
            "        \"\"\"Returns True if the path exists, else returns False.",
            "",
            "        API-style wrapper for os.path.exists",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The API path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the target exists.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return exists(os_path)",
            "",
            "    def _base_model(self, path):",
            "        \"\"\"Build the common base of a contents model\"\"\"",
            "        os_path = self._get_os_path(path)",
            "        info = os.lstat(os_path)",
            "",
            "        try:",
            "            # size of file",
            "            size = info.st_size",
            "        except (ValueError, OSError):",
            "            self.log.warning('Unable to get size.')",
            "            size = None",
            "",
            "        try:",
            "            last_modified = tz.utcfromtimestamp(info.st_mtime)",
            "        except (ValueError, OSError):",
            "            # Files can rarely have an invalid timestamp",
            "            # https://github.com/jupyter/notebook/issues/2539",
            "            # https://github.com/jupyter/notebook/issues/2757",
            "            # Use the Unix epoch as a fallback so we don't crash.",
            "            self.log.warning('Invalid mtime %s for %s', info.st_mtime, os_path)",
            "            last_modified = datetime(1970, 1, 1, 0, 0, tzinfo=tz.UTC)",
            "",
            "        try:",
            "            created = tz.utcfromtimestamp(info.st_ctime)",
            "        except (ValueError, OSError):  # See above",
            "            self.log.warning('Invalid ctime %s for %s', info.st_ctime, os_path)",
            "            created = datetime(1970, 1, 1, 0, 0, tzinfo=tz.UTC)",
            "",
            "        # Create the base model.",
            "        model = {}",
            "        model['name'] = path.rsplit('/', 1)[-1]",
            "        model['path'] = path",
            "        model['last_modified'] = last_modified",
            "        model['created'] = created",
            "        model['content'] = None",
            "        model['format'] = None",
            "        model['mimetype'] = None",
            "        model['size'] = size",
            "",
            "        try:",
            "            model['writable'] = os.access(os_path, os.W_OK)",
            "        except OSError:",
            "            self.log.error(\"Failed to check write permissions on %s\", os_path)",
            "            model['writable'] = False",
            "        return model",
            "",
            "    def _dir_model(self, path, content=True):",
            "        \"\"\"Build a model for a directory",
            "",
            "        if content is requested, will include a listing of the directory",
            "        \"\"\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = f'directory does not exist: {path!r}'",
            "",
            "        if not os.path.isdir(os_path):",
            "            raise web.HTTPError(404, four_o_four)",
            "        elif is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden directory %r, via 404 Error\",",
            "                os_path",
            "            )",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model = self._base_model(path)",
            "        model['type'] = 'directory'",
            "        model['size'] = None",
            "        if content:",
            "            model['content'] = contents = []",
            "            os_dir = self._get_os_path(path)",
            "            for name in os.listdir(os_dir):",
            "                try:",
            "                    os_path = os.path.join(os_dir, name)",
            "                except UnicodeDecodeError as e:",
            "                    self.log.warning(",
            "                        \"failed to decode filename '%s': %s\", name, e)",
            "                    continue",
            "",
            "                try:",
            "                    st = os.lstat(os_path)",
            "                except OSError as e:",
            "                    # skip over broken symlinks in listing",
            "                    if e.errno == errno.ENOENT:",
            "                        self.log.warning(\"%s doesn't exist\", os_path)",
            "                    else:",
            "                        self.log.warning(\"Error stat-ing %s: %s\", os_path, e)",
            "                    continue",
            "",
            "                if (not stat.S_ISLNK(st.st_mode)",
            "                        and not stat.S_ISREG(st.st_mode)",
            "                        and not stat.S_ISDIR(st.st_mode)):",
            "                    self.log.debug(\"%s not a regular file\", os_path)",
            "                    continue",
            "",
            "                try:",
            "                    if self.should_list(name):",
            "                        if self.allow_hidden or not is_file_hidden(os_path, stat_res=st):",
            "                            contents.append(",
            "                                    self.get(path=f'{path}/{name}', content=False)",
            "                            )",
            "                except OSError as e:",
            "                    # ELOOP: recursive symlink",
            "                    if e.errno != errno.ELOOP:",
            "                        self.log.warning(",
            "                            \"Unknown error checking if file %r is hidden\",",
            "                            os_path,",
            "                            exc_info=True,",
            "                        )",
            "            model['format'] = 'json'",
            "",
            "        return model",
            "",
            "",
            "    def _file_model(self, path, content=True, format=None):",
            "        \"\"\"Build a model for a file",
            "",
            "        if content is requested, include the file contents.",
            "",
            "        format:",
            "          If 'text', the contents will be decoded as UTF-8.",
            "          If 'base64', the raw bytes contents will be encoded as base64.",
            "          If not specified, try to decode as UTF-8, and fall back to base64",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model['type'] = 'file'",
            "",
            "        os_path = self._get_os_path(path)",
            "        model['mimetype'] = mimetypes.guess_type(os_path)[0]",
            "",
            "        if content:",
            "            content, format = self._read_file(os_path, format)",
            "            if model['mimetype'] is None:",
            "                default_mime = {",
            "                    'text': 'text/plain',",
            "                    'base64': 'application/octet-stream'",
            "                }[format]",
            "                model['mimetype'] = default_mime",
            "",
            "            model.update(",
            "                content=content,",
            "                format=format,",
            "            )",
            "",
            "        return model",
            "",
            "    def _notebook_model(self, path, content=True):",
            "        \"\"\"Build a notebook model",
            "",
            "        if content is requested, the notebook content will be populated",
            "        as a JSON structure (not double-serialized)",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model['type'] = 'notebook'",
            "        os_path = self._get_os_path(path)",
            "",
            "        if content:",
            "            nb = self._read_notebook(os_path, as_version=4)",
            "            self.mark_trusted_cells(nb, path)",
            "            model['content'] = nb",
            "            model['format'] = 'json'",
            "            self.validate_notebook_model(model)",
            "",
            "        return model",
            "",
            "    def get(self, path, content=True, type=None, format=None):",
            "        \"\"\" Takes a path for an entity and returns its model",
            "",
            "        Parameters",
            "        ----------",
            "        path : str",
            "            the API path that describes the relative path for the target",
            "        content : bool",
            "            Whether to include the contents in the reply",
            "        type : str, optional",
            "            The requested type - 'file', 'notebook', or 'directory'.",
            "            Will raise HTTPError 400 if the content doesn't match.",
            "        format : str, optional",
            "            The requested format for file contents. 'text' or 'base64'.",
            "            Ignored if this returns a notebook or directory model.",
            "",
            "        Returns",
            "        -------",
            "        model : dict",
            "            the contents model. If content=True, returns the contents",
            "            of the file or directory as well.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, f'No such file or directory: {path}')",
            "",
            "        os_path = self._get_os_path(path)",
            "        if os.path.isdir(os_path):",
            "            if type not in (None, 'directory'):",
            "                raise web.HTTPError(400,",
            "                                    f'{path} is a directory, not a {type}', reason='bad type')",
            "            model = self._dir_model(path, content=content)",
            "        elif type == 'notebook' or (type is None and path.endswith('.ipynb')):",
            "            model = self._notebook_model(path, content=content)",
            "        else:",
            "            if type == 'directory':",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f'{path} is not a directory', reason='bad type')",
            "            model = self._file_model(path, content=content, format=format)",
            "        return model",
            "",
            "    def _save_directory(self, os_path, model, path=''):",
            "        \"\"\"create a directory\"\"\"",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            raise web.HTTPError(400, f'Cannot create hidden directory {os_path!r}')",
            "        if not os.path.exists(os_path):",
            "            with self.perm_to_403():",
            "                os.mkdir(os_path)",
            "        elif not os.path.isdir(os_path):",
            "            raise web.HTTPError(400, f'Not a directory: {os_path}')",
            "        else:",
            "            self.log.debug(\"Directory %r already exists\", os_path)",
            "",
            "    def save(self, model, path=''):",
            "        \"\"\"Save the file model and return the model with no content.\"\"\"",
            "        path = path.strip('/')",
            "",
            "        if 'type' not in model:",
            "            raise web.HTTPError(400, 'No file type provided')",
            "        if 'content' not in model and model['type'] != 'directory':",
            "            raise web.HTTPError(400, 'No file content provided')",
            "",
            "        os_path = self._get_os_path(path)",
            "        self.log.debug(\"Saving %s\", os_path)",
            "",
            "        self.run_pre_save_hook(model=model, path=path)",
            "",
            "        try:",
            "            if model['type'] == 'notebook':",
            "                nb = nbformat.from_dict(model['content'])",
            "                self.check_and_sign(nb, path)",
            "                self._save_notebook(os_path, nb)",
            "                # One checkpoint should always exist for notebooks.",
            "                if not self.checkpoints.list_checkpoints(path):",
            "                    self.create_checkpoint(path)",
            "            elif model['type'] == 'file':",
            "                # Missing format will be handled internally by _save_file.",
            "                self._save_file(os_path, model['content'], model.get('format'))",
            "            elif model['type'] == 'directory':",
            "                self._save_directory(os_path, model, path)",
            "            else:",
            "                raise web.HTTPError(400, f\"Unhandled contents type: {model['type']}\")",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            self.log.error('Error while saving file: %s %s', path, e, exc_info=True)",
            "            raise web.HTTPError(500, f'Unexpected error while saving file: {path} {e}') from e",
            "",
            "        validation_message = None",
            "        if model['type'] == 'notebook':",
            "            self.validate_notebook_model(model)",
            "            validation_message = model.get('message', None)",
            "",
            "        model = self.get(path, content=False)",
            "        if validation_message:",
            "            model['message'] = validation_message",
            "",
            "        self.run_post_save_hook(model=model, os_path=os_path)",
            "",
            "        return model",
            "",
            "    def delete_file(self, path):",
            "        \"\"\"Delete file at path.\"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path)",
            "        rm = os.unlink",
            "        if not os.path.exists(os_path):",
            "            raise web.HTTPError(404, f'File or directory does not exist: {os_path}')",
            "",
            "        def is_non_empty_dir(os_path):",
            "            if os.path.isdir(os_path):",
            "                # A directory containing only leftover checkpoints is",
            "                # considered empty.",
            "                cp_dir = getattr(self.checkpoints, 'checkpoint_dir', None)",
            "                if set(os.listdir(os_path)) - {cp_dir}:",
            "                    return True",
            "",
            "            return False",
            "",
            "        if self.delete_to_trash:",
            "            if sys.platform == 'win32' and is_non_empty_dir(os_path):",
            "                # send2trash can really delete files on Windows, so disallow",
            "                # deleting non-empty files. See Github issue 3631.",
            "                raise web.HTTPError(400, f'Directory {os_path} not empty')",
            "            try:",
            "                self.log.debug(\"Sending %s to trash\", os_path)",
            "                send2trash(os_path)",
            "                return",
            "            except TrashPermissionError as e:",
            "                self.log.warning(\"Skipping trash for %s, %s\", os_path, e)",
            "",
            "        if os.path.isdir(os_path):",
            "            # Don't permanently delete non-empty directories.",
            "            if is_non_empty_dir(os_path):",
            "                raise web.HTTPError(400, f'Directory {os_path} not empty')",
            "            self.log.debug(\"Removing directory %s\", os_path)",
            "            with self.perm_to_403():",
            "                shutil.rmtree(os_path)",
            "        else:",
            "            self.log.debug(\"Unlinking file %s\", os_path)",
            "            with self.perm_to_403():",
            "                rm(os_path)",
            "",
            "    def rename_file(self, old_path, new_path):",
            "        \"\"\"Rename a file.\"\"\"",
            "        old_path = old_path.strip('/')",
            "        new_path = new_path.strip('/')",
            "        if new_path == old_path:",
            "            return",
            "",
            "        # Perform path validation prior to converting to os-specific value since this",
            "        # is still relative to root_dir.",
            "        self._validate_path(new_path)",
            "",
            "        new_os_path = self._get_os_path(new_path)",
            "        old_os_path = self._get_os_path(old_path)",
            "",
            "        # Should we proceed with the move?",
            "        if os.path.exists(new_os_path) and not samefile(old_os_path, new_os_path):",
            "            raise web.HTTPError(409, f'File already exists: {new_path}')",
            "",
            "        # Move the file",
            "        try:",
            "            with self.perm_to_403():",
            "                shutil.move(old_os_path, new_os_path)",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            raise web.HTTPError(500, f'Unknown error renaming file: {old_path} {e}') from e",
            "",
            "    def info_string(self):",
            "        return _(\"Serving notebooks from local directory: %s\") % self.root_dir",
            "",
            "    def get_kernel_path(self, path, model=None):",
            "        \"\"\"Return the initial API path of  a kernel associated with a given notebook\"\"\"",
            "        if self.dir_exists(path):",
            "            return path",
            "        if '/' in path:",
            "            parent_dir = path.rsplit('/', 1)[0]",
            "        else:",
            "            parent_dir = ''",
            "        return parent_dir",
            "",
            "    @staticmethod",
            "    def _validate_path(path):",
            "        \"\"\"Checks if the path contains invalid characters relative to the current platform\"\"\"",
            "",
            "        if sys.platform == 'win32':",
            "            # On Windows systems, we MUST disallow colons otherwise an Alternative Data Stream will",
            "            # be created and confusion will reign! (See https://github.com/jupyter/notebook/issues/5190)",
            "            # Go ahead and add other invalid (and non-path-separator) characters here as well so there's",
            "            # consistent behavior - although all others will result in '[Errno 22]Invalid Argument' errors.",
            "            invalid_chars = '?:><*\"|'",
            "        else:",
            "            # On non-windows systems, allow the underlying file creation to perform enforcement when appropriate",
            "            invalid_chars = ''",
            "",
            "        for char in invalid_chars:",
            "            if char in path:",
            "                raise web.HTTPError(400, f\"Path '{path}' contains characters that are invalid for the filesystem. \"",
            "                                         f\"Path names on this filesystem cannot contain any of the following \"",
            "                                         f\"characters: {invalid_chars}\")"
        ],
        "afterPatchFile": [
            "\"\"\"A contents manager that uses the local file system for storage.\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "from datetime import datetime",
            "import errno",
            "import os",
            "import shutil",
            "import stat",
            "import sys",
            "import warnings",
            "import mimetypes",
            "import nbformat",
            "",
            "from send2trash import send2trash",
            "from send2trash.exceptions import TrashPermissionError",
            "from tornado import web",
            "",
            "from .filecheckpoints import FileCheckpoints",
            "from .fileio import FileManagerMixin",
            "from .manager import ContentsManager",
            "from ...utils import exists",
            "",
            "from ipython_genutils.importstring import import_item",
            "from traitlets import Any, Unicode, Bool, TraitError, observe, default, validate",
            "from ipython_genutils.py3compat import getcwd, string_types",
            "",
            "from notebook import _tz as tz",
            "from notebook.utils import (",
            "    is_hidden, is_file_hidden,",
            "    to_api_path,",
            ")",
            "from notebook.base.handlers import AuthenticatedFileHandler",
            "from notebook.transutils import _",
            "",
            "from os.path import samefile",
            "",
            "_script_exporter = None",
            "",
            "",
            "def _post_save_script(model, os_path, contents_manager, **kwargs):",
            "    \"\"\"convert notebooks to Python script after save with nbconvert",
            "",
            "    replaces `jupyter notebook --script`",
            "    \"\"\"",
            "    from nbconvert.exporters.script import ScriptExporter",
            "    warnings.warn(\"`_post_save_script` is deprecated and will be removed in Notebook 5.0\", DeprecationWarning)",
            "",
            "    if model['type'] != 'notebook':",
            "        return",
            "",
            "    global _script_exporter",
            "    if _script_exporter is None:",
            "        _script_exporter = ScriptExporter(parent=contents_manager)",
            "    log = contents_manager.log",
            "",
            "    base, ext = os.path.splitext(os_path)",
            "    script, resources = _script_exporter.from_filename(os_path)",
            "    script_fname = base + resources.get('output_extension', '.txt')",
            "    log.info(\"Saving script /%s\", to_api_path(script_fname, contents_manager.root_dir))",
            "    with open(script_fname, 'w', encoding='utf-8') as f:",
            "        f.write(script)",
            "",
            "",
            "class FileContentsManager(FileManagerMixin, ContentsManager):",
            "",
            "    root_dir = Unicode(config=True)",
            "",
            "    @default('root_dir')",
            "    def _default_root_dir(self):",
            "        try:",
            "            return self.parent.notebook_dir",
            "        except AttributeError:",
            "            return getcwd()",
            "",
            "    save_script = Bool(False, config=True, help='DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0')",
            "    @observe('save_script')",
            "    def _update_save_script(self, change):",
            "        if not change['new']:",
            "            return",
            "        self.log.warning(\"\"\"",
            "        `--script` is deprecated and will be removed in notebook 5.0.",
            "",
            "        You can trigger nbconvert via pre- or post-save hooks:",
            "",
            "            ContentsManager.pre_save_hook",
            "            FileContentsManager.post_save_hook",
            "",
            "        A post-save hook has been registered that calls:",
            "",
            "            jupyter nbconvert --to script [notebook]",
            "",
            "        which behaves similarly to `--script`.",
            "        \"\"\")",
            "",
            "        self.post_save_hook = _post_save_script",
            "",
            "    post_save_hook = Any(None, config=True, allow_none=True,",
            "        help=\"\"\"Python callable or importstring thereof",
            "",
            "        to be called on the path of a file just saved.",
            "",
            "        This can be used to process the file on disk,",
            "        such as converting the notebook to a script or HTML via nbconvert.",
            "",
            "        It will be called as (all arguments passed by keyword)::",
            "",
            "            hook(os_path=os_path, model=model, contents_manager=instance)",
            "",
            "        - path: the filesystem path to the file just written",
            "        - model: the model representing the file",
            "        - contents_manager: this ContentsManager instance",
            "        \"\"\"",
            "    )",
            "",
            "    @validate('post_save_hook')",
            "    def _validate_post_save_hook(self, proposal):",
            "        value = proposal['value']",
            "        if isinstance(value, string_types):",
            "            value = import_item(value)",
            "        if not callable(value):",
            "            raise TraitError(\"post_save_hook must be callable\")",
            "        return value",
            "",
            "    def run_post_save_hook(self, model, os_path):",
            "        \"\"\"Run the post-save hook if defined, and log errors\"\"\"",
            "        if self.post_save_hook:",
            "            try:",
            "                self.log.debug(\"Running post-save hook on %s\", os_path)",
            "                self.post_save_hook(os_path=os_path, model=model, contents_manager=self)",
            "            except Exception as e:",
            "                self.log.error(\"Post-save hook failed o-n %s\", os_path, exc_info=True)",
            "                raise web.HTTPError(500, f'Unexpected error while running post hook save: {e}') from e",
            "",
            "    @validate('root_dir')",
            "    def _validate_root_dir(self, proposal):",
            "        \"\"\"Do a bit of validation of the root_dir.\"\"\"",
            "        value = proposal['value']",
            "        if not os.path.isabs(value):",
            "            # If we receive a non-absolute path, make it absolute.",
            "            value = os.path.abspath(value)",
            "        if not os.path.isdir(value):",
            "            raise TraitError(f\"{value!r} is not a directory\")",
            "        return value",
            "",
            "    @default('checkpoints_class')",
            "    def _checkpoints_class_default(self):",
            "        return FileCheckpoints",
            "",
            "    delete_to_trash = Bool(True, config=True,",
            "        help=\"\"\"If True (default), deleting files will send them to the",
            "        platform's trash/recycle bin, where they can be recovered. If False,",
            "        deleting files really deletes them.\"\"\")",
            "",
            "    @default('files_handler_class')",
            "    def _files_handler_class_default(self):",
            "        return AuthenticatedFileHandler",
            "",
            "    @default('files_handler_params')",
            "    def _files_handler_params_default(self):",
            "        return {'path': self.root_dir}",
            "",
            "    def is_hidden(self, path):",
            "        \"\"\"Does the API style path correspond to a hidden directory or file?",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        hidden : bool",
            "            Whether the path exists and is hidden.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return is_hidden(os_path, self.root_dir)",
            "",
            "    def file_exists(self, path):",
            "        \"\"\"Returns True if the file exists, else returns False.",
            "",
            "        API-style wrapper for os.path.isfile",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The relative path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the file exists.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path)",
            "        return os.path.isfile(os_path)",
            "",
            "    def dir_exists(self, path):",
            "        \"\"\"Does the API-style path refer to an extant directory?",
            "",
            "        API-style wrapper for os.path.isdir",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the path is indeed a directory.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.isdir(os_path)",
            "",
            "    def exists(self, path):",
            "        \"\"\"Returns True if the path exists, else returns False.",
            "",
            "        API-style wrapper for os.path.exists",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The API path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the target exists.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path=path)",
            "        return exists(os_path)",
            "",
            "    def _base_model(self, path):",
            "        \"\"\"Build the common base of a contents model\"\"\"",
            "        os_path = self._get_os_path(path)",
            "        info = os.lstat(os_path)",
            "",
            "        try:",
            "            # size of file",
            "            size = info.st_size",
            "        except (ValueError, OSError):",
            "            self.log.warning('Unable to get size.')",
            "            size = None",
            "",
            "        try:",
            "            last_modified = tz.utcfromtimestamp(info.st_mtime)",
            "        except (ValueError, OSError):",
            "            # Files can rarely have an invalid timestamp",
            "            # https://github.com/jupyter/notebook/issues/2539",
            "            # https://github.com/jupyter/notebook/issues/2757",
            "            # Use the Unix epoch as a fallback so we don't crash.",
            "            self.log.warning('Invalid mtime %s for %s', info.st_mtime, os_path)",
            "            last_modified = datetime(1970, 1, 1, 0, 0, tzinfo=tz.UTC)",
            "",
            "        try:",
            "            created = tz.utcfromtimestamp(info.st_ctime)",
            "        except (ValueError, OSError):  # See above",
            "            self.log.warning('Invalid ctime %s for %s', info.st_ctime, os_path)",
            "            created = datetime(1970, 1, 1, 0, 0, tzinfo=tz.UTC)",
            "",
            "        # Create the base model.",
            "        model = {}",
            "        model['name'] = path.rsplit('/', 1)[-1]",
            "        model['path'] = path",
            "        model['last_modified'] = last_modified",
            "        model['created'] = created",
            "        model['content'] = None",
            "        model['format'] = None",
            "        model['mimetype'] = None",
            "        model['size'] = size",
            "",
            "        try:",
            "            model['writable'] = os.access(os_path, os.W_OK)",
            "        except OSError:",
            "            self.log.error(\"Failed to check write permissions on %s\", os_path)",
            "            model['writable'] = False",
            "        return model",
            "",
            "    def _dir_model(self, path, content=True):",
            "        \"\"\"Build a model for a directory",
            "",
            "        if content is requested, will include a listing of the directory",
            "        \"\"\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = f'directory does not exist: {path!r}'",
            "",
            "        if not os.path.isdir(os_path):",
            "            raise web.HTTPError(404, four_o_four)",
            "        elif is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden directory %r, via 404 Error\",",
            "                os_path",
            "            )",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model = self._base_model(path)",
            "        model['type'] = 'directory'",
            "        model['size'] = None",
            "        if content:",
            "            model['content'] = contents = []",
            "            os_dir = self._get_os_path(path)",
            "            for name in os.listdir(os_dir):",
            "                try:",
            "                    os_path = os.path.join(os_dir, name)",
            "                except UnicodeDecodeError as e:",
            "                    self.log.warning(",
            "                        \"failed to decode filename '%s': %s\", name, e)",
            "                    continue",
            "",
            "                try:",
            "                    st = os.lstat(os_path)",
            "                except OSError as e:",
            "                    # skip over broken symlinks in listing",
            "                    if e.errno == errno.ENOENT:",
            "                        self.log.warning(\"%s doesn't exist\", os_path)",
            "                    else:",
            "                        self.log.warning(\"Error stat-ing %s: %s\", os_path, e)",
            "                    continue",
            "",
            "                if (not stat.S_ISLNK(st.st_mode)",
            "                        and not stat.S_ISREG(st.st_mode)",
            "                        and not stat.S_ISDIR(st.st_mode)):",
            "                    self.log.debug(\"%s not a regular file\", os_path)",
            "                    continue",
            "",
            "                try:",
            "                    if self.should_list(name):",
            "                        if self.allow_hidden or not is_file_hidden(os_path, stat_res=st):",
            "                            contents.append(",
            "                                    self.get(path=f'{path}/{name}', content=False)",
            "                            )",
            "                except OSError as e:",
            "                    # ELOOP: recursive symlink",
            "                    if e.errno != errno.ELOOP:",
            "                        self.log.warning(",
            "                            \"Unknown error checking if file %r is hidden\",",
            "                            os_path,",
            "                            exc_info=True,",
            "                        )",
            "            model['format'] = 'json'",
            "",
            "        return model",
            "",
            "",
            "    def _file_model(self, path, content=True, format=None):",
            "        \"\"\"Build a model for a file",
            "",
            "        if content is requested, include the file contents.",
            "",
            "        format:",
            "          If 'text', the contents will be decoded as UTF-8.",
            "          If 'base64', the raw bytes contents will be encoded as base64.",
            "          If not specified, try to decode as UTF-8, and fall back to base64",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model['type'] = 'file'",
            "",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = \"file does not exist: %r\" % path",
            "",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden file or file in hidden directory %r, via 404 Error\", os_path)",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model['mimetype'] = mimetypes.guess_type(os_path)[0]",
            "",
            "        if content:",
            "            content, format = self._read_file(os_path, format)",
            "            if model['mimetype'] is None:",
            "                default_mime = {",
            "                    'text': 'text/plain',",
            "                    'base64': 'application/octet-stream'",
            "                }[format]",
            "                model['mimetype'] = default_mime",
            "",
            "            model.update(",
            "                content=content,",
            "                format=format,",
            "            )",
            "",
            "        return model",
            "",
            "    def _notebook_model(self, path, content=True):",
            "        \"\"\"Build a notebook model",
            "",
            "        if content is requested, the notebook content will be populated",
            "        as a JSON structure (not double-serialized)",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model['type'] = 'notebook'",
            "        os_path = self._get_os_path(path)",
            "",
            "        if content:",
            "            nb = self._read_notebook(os_path, as_version=4)",
            "            self.mark_trusted_cells(nb, path)",
            "            model['content'] = nb",
            "            model['format'] = 'json'",
            "            self.validate_notebook_model(model)",
            "",
            "        return model",
            "",
            "    def get(self, path, content=True, type=None, format=None):",
            "        \"\"\" Takes a path for an entity and returns its model",
            "",
            "        Parameters",
            "        ----------",
            "        path : str",
            "            the API path that describes the relative path for the target",
            "        content : bool",
            "            Whether to include the contents in the reply",
            "        type : str, optional",
            "            The requested type - 'file', 'notebook', or 'directory'.",
            "            Will raise HTTPError 400 if the content doesn't match.",
            "        format : str, optional",
            "            The requested format for file contents. 'text' or 'base64'.",
            "            Ignored if this returns a notebook or directory model.",
            "",
            "        Returns",
            "        -------",
            "        model : dict",
            "            the contents model. If content=True, returns the contents",
            "            of the file or directory as well.",
            "        \"\"\"",
            "        path = path.strip('/')",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, f'No such file or directory: {path}')",
            "",
            "        os_path = self._get_os_path(path)",
            "        if os.path.isdir(os_path):",
            "            if type not in (None, 'directory'):",
            "                raise web.HTTPError(400,",
            "                                    f'{path} is a directory, not a {type}', reason='bad type')",
            "            model = self._dir_model(path, content=content)",
            "        elif type == 'notebook' or (type is None and path.endswith('.ipynb')):",
            "            model = self._notebook_model(path, content=content)",
            "        else:",
            "            if type == 'directory':",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f'{path} is not a directory', reason='bad type')",
            "            model = self._file_model(path, content=content, format=format)",
            "        return model",
            "",
            "    def _save_directory(self, os_path, model, path=''):",
            "        \"\"\"create a directory\"\"\"",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            raise web.HTTPError(400, f'Cannot create hidden directory {os_path!r}')",
            "        if not os.path.exists(os_path):",
            "            with self.perm_to_403():",
            "                os.mkdir(os_path)",
            "        elif not os.path.isdir(os_path):",
            "            raise web.HTTPError(400, f'Not a directory: {os_path}')",
            "        else:",
            "            self.log.debug(\"Directory %r already exists\", os_path)",
            "",
            "    def save(self, model, path=''):",
            "        \"\"\"Save the file model and return the model with no content.\"\"\"",
            "        path = path.strip('/')",
            "",
            "        if 'type' not in model:",
            "            raise web.HTTPError(400, 'No file type provided')",
            "        if 'content' not in model and model['type'] != 'directory':",
            "            raise web.HTTPError(400, 'No file content provided')",
            "",
            "        os_path = self._get_os_path(path)",
            "        self.log.debug(\"Saving %s\", os_path)",
            "",
            "        self.run_pre_save_hook(model=model, path=path)",
            "",
            "        try:",
            "            if model['type'] == 'notebook':",
            "                nb = nbformat.from_dict(model['content'])",
            "                self.check_and_sign(nb, path)",
            "                self._save_notebook(os_path, nb)",
            "                # One checkpoint should always exist for notebooks.",
            "                if not self.checkpoints.list_checkpoints(path):",
            "                    self.create_checkpoint(path)",
            "            elif model['type'] == 'file':",
            "                # Missing format will be handled internally by _save_file.",
            "                self._save_file(os_path, model['content'], model.get('format'))",
            "            elif model['type'] == 'directory':",
            "                self._save_directory(os_path, model, path)",
            "            else:",
            "                raise web.HTTPError(400, f\"Unhandled contents type: {model['type']}\")",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            self.log.error('Error while saving file: %s %s', path, e, exc_info=True)",
            "            raise web.HTTPError(500, f'Unexpected error while saving file: {path} {e}') from e",
            "",
            "        validation_message = None",
            "        if model['type'] == 'notebook':",
            "            self.validate_notebook_model(model)",
            "            validation_message = model.get('message', None)",
            "",
            "        model = self.get(path, content=False)",
            "        if validation_message:",
            "            model['message'] = validation_message",
            "",
            "        self.run_post_save_hook(model=model, os_path=os_path)",
            "",
            "        return model",
            "",
            "    def delete_file(self, path):",
            "        \"\"\"Delete file at path.\"\"\"",
            "        path = path.strip('/')",
            "        os_path = self._get_os_path(path)",
            "        rm = os.unlink",
            "        if not os.path.exists(os_path):",
            "            raise web.HTTPError(404, f'File or directory does not exist: {os_path}')",
            "",
            "        def is_non_empty_dir(os_path):",
            "            if os.path.isdir(os_path):",
            "                # A directory containing only leftover checkpoints is",
            "                # considered empty.",
            "                cp_dir = getattr(self.checkpoints, 'checkpoint_dir', None)",
            "                if set(os.listdir(os_path)) - {cp_dir}:",
            "                    return True",
            "",
            "            return False",
            "",
            "        if self.delete_to_trash:",
            "            if sys.platform == 'win32' and is_non_empty_dir(os_path):",
            "                # send2trash can really delete files on Windows, so disallow",
            "                # deleting non-empty files. See Github issue 3631.",
            "                raise web.HTTPError(400, f'Directory {os_path} not empty')",
            "            try:",
            "                self.log.debug(\"Sending %s to trash\", os_path)",
            "                send2trash(os_path)",
            "                return",
            "            except TrashPermissionError as e:",
            "                self.log.warning(\"Skipping trash for %s, %s\", os_path, e)",
            "",
            "        if os.path.isdir(os_path):",
            "            # Don't permanently delete non-empty directories.",
            "            if is_non_empty_dir(os_path):",
            "                raise web.HTTPError(400, f'Directory {os_path} not empty')",
            "            self.log.debug(\"Removing directory %s\", os_path)",
            "            with self.perm_to_403():",
            "                shutil.rmtree(os_path)",
            "        else:",
            "            self.log.debug(\"Unlinking file %s\", os_path)",
            "            with self.perm_to_403():",
            "                rm(os_path)",
            "",
            "    def rename_file(self, old_path, new_path):",
            "        \"\"\"Rename a file.\"\"\"",
            "        old_path = old_path.strip('/')",
            "        new_path = new_path.strip('/')",
            "        if new_path == old_path:",
            "            return",
            "",
            "        # Perform path validation prior to converting to os-specific value since this",
            "        # is still relative to root_dir.",
            "        self._validate_path(new_path)",
            "",
            "        new_os_path = self._get_os_path(new_path)",
            "        old_os_path = self._get_os_path(old_path)",
            "",
            "        # Should we proceed with the move?",
            "        if os.path.exists(new_os_path) and not samefile(old_os_path, new_os_path):",
            "            raise web.HTTPError(409, f'File already exists: {new_path}')",
            "",
            "        # Move the file",
            "        try:",
            "            with self.perm_to_403():",
            "                shutil.move(old_os_path, new_os_path)",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            raise web.HTTPError(500, f'Unknown error renaming file: {old_path} {e}') from e",
            "",
            "    def info_string(self):",
            "        return _(\"Serving notebooks from local directory: %s\") % self.root_dir",
            "",
            "    def get_kernel_path(self, path, model=None):",
            "        \"\"\"Return the initial API path of  a kernel associated with a given notebook\"\"\"",
            "        if self.dir_exists(path):",
            "            return path",
            "        if '/' in path:",
            "            parent_dir = path.rsplit('/', 1)[0]",
            "        else:",
            "            parent_dir = ''",
            "        return parent_dir",
            "",
            "    @staticmethod",
            "    def _validate_path(path):",
            "        \"\"\"Checks if the path contains invalid characters relative to the current platform\"\"\"",
            "",
            "        if sys.platform == 'win32':",
            "            # On Windows systems, we MUST disallow colons otherwise an Alternative Data Stream will",
            "            # be created and confusion will reign! (See https://github.com/jupyter/notebook/issues/5190)",
            "            # Go ahead and add other invalid (and non-path-separator) characters here as well so there's",
            "            # consistent behavior - although all others will result in '[Errno 22]Invalid Argument' errors.",
            "            invalid_chars = '?:><*\"|'",
            "        else:",
            "            # On non-windows systems, allow the underlying file creation to perform enforcement when appropriate",
            "            invalid_chars = ''",
            "",
            "        for char in invalid_chars:",
            "            if char in path:",
            "                raise web.HTTPError(400, f\"Path '{path}' contains characters that are invalid for the filesystem. \"",
            "                                         f\"Path names on this filesystem cannot contain any of the following \"",
            "                                         f\"characters: {invalid_chars}\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.urllib3.util.retry",
            "notebook.services.contents.filemanager.FileContentsManager.get"
        ]
    },
    "notebook/services/contents/tests/test_manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             else:"
            },
            "1": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                 self.fail(\"Should have raised HTTPError(403)\")"
            },
            "2": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+    @skipIf(sys.platform.startswith('win'), \"Can't test hidden files on Windows\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+    def test_404(self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        #Test visible file in hidden folder"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        with self.assertRaises(HTTPError) as excinfo:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+            with TemporaryDirectory() as td:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+                cm = FileContentsManager(root_dir=td)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                hidden_dir = '.hidden'"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                file_in_hidden_path = os.path.join(hidden_dir,'visible.txt')"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+                _make_dir(cm, hidden_dir)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+                model = cm.new(path=file_in_hidden_path)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+                os_path = cm._get_os_path(model['path'])"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+                try:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+                    result = cm.get(os_path, 'w')"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                except HTTPError as e:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                    self.assertEqual(e.status_code, 404)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+                else:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+                    self.fail(\"Should have raised HTTPError(404)\")"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+        #Test hidden file in visible folder"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+        with self.assertRaises(HTTPError) as excinfo:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+            with TemporaryDirectory() as td:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+                cm = FileContentsManager(root_dir=td)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+                hidden_dir = 'visible'"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+                file_in_hidden_path = os.path.join(hidden_dir,'.hidden.txt')"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+                _make_dir(cm, hidden_dir)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                model = cm.new(path=file_in_hidden_path)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                os_path = cm._get_os_path(model['path'])"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                try:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                    result = cm.get(os_path, 'w')"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+                except HTTPError as e:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+                    self.assertEqual(e.status_code, 404)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+                else:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+                    self.fail(\"Should have raised HTTPError(404)\")"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "     def test_escape_root(self):"
            },
            "39": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "         with TemporaryDirectory() as td:"
            },
            "40": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "             cm = FileContentsManager(root_dir=td)"
            }
        },
        "frontPatchFile": [
            "\"\"\"Tests for the notebook manager.\"\"\"",
            "",
            "import os",
            "import sys",
            "import time",
            "from contextlib import contextmanager",
            "from itertools import combinations",
            "",
            "from tornado.web import HTTPError",
            "from unittest import TestCase, skipIf",
            "from tempfile import NamedTemporaryFile",
            "",
            "from nbformat import v4 as nbformat",
            "",
            "from ipython_genutils.tempdir import TemporaryDirectory",
            "from traitlets import TraitError",
            "",
            "from ..filemanager import FileContentsManager",
            "",
            "",
            "def _make_dir(contents_manager, api_path):",
            "    \"\"\"",
            "    Make a directory.",
            "    \"\"\"",
            "    os_path = contents_manager._get_os_path(api_path)",
            "    try:",
            "        os.makedirs(os_path)",
            "    except OSError:",
            "        print(f\"Directory already exists: {os_path!r}\")",
            "",
            "",
            "class TestFileContentsManager(TestCase):",
            "",
            "    @contextmanager",
            "    def assertRaisesHTTPError(self, status, msg=None):",
            "        msg = msg or f\"Should have raised HTTPError({status})\"",
            "        try:",
            "            yield",
            "        except HTTPError as e:",
            "            self.assertEqual(e.status_code, status)",
            "        else:",
            "            self.fail(msg)",
            "",
            "    def symlink(self, contents_manager, src, dst):",
            "        \"\"\"Make a symlink to src from dst",
            "",
            "        src and dst are api_paths",
            "        \"\"\"",
            "        src_os_path = contents_manager._get_os_path(src)",
            "        dst_os_path = contents_manager._get_os_path(dst)",
            "        print(src_os_path, dst_os_path, os.path.isfile(src_os_path))",
            "        os.symlink(src_os_path, dst_os_path)",
            "",
            "    def test_root_dir(self):",
            "        with TemporaryDirectory() as td:",
            "            fm = FileContentsManager(root_dir=td)",
            "            self.assertEqual(fm.root_dir, td)",
            "",
            "    def test_missing_root_dir(self):",
            "        with TemporaryDirectory() as td:",
            "            root = os.path.join(td, 'notebook', 'dir', 'is', 'missing')",
            "            self.assertRaises(TraitError, FileContentsManager, root_dir=root)",
            "",
            "    def test_invalid_root_dir(self):",
            "        with NamedTemporaryFile() as tf:",
            "            self.assertRaises(TraitError, FileContentsManager, root_dir=tf.name)",
            "",
            "    def test_get_os_path(self):",
            "        # full filesystem path should be returned with correct operating system",
            "        # separators.",
            "        with TemporaryDirectory() as td:",
            "            root = td",
            "            fm = FileContentsManager(root_dir=root)",
            "            path = fm._get_os_path('/path/to/notebook/test.ipynb')",
            "            rel_path_list =  '/path/to/notebook/test.ipynb'.split('/')",
            "            fs_path = os.path.join(fm.root_dir, *rel_path_list)",
            "            self.assertEqual(path, fs_path)",
            "",
            "            fm = FileContentsManager(root_dir=root)",
            "            path = fm._get_os_path('test.ipynb')",
            "            fs_path = os.path.join(fm.root_dir, 'test.ipynb')",
            "            self.assertEqual(path, fs_path)",
            "",
            "            fm = FileContentsManager(root_dir=root)",
            "            path = fm._get_os_path('////test.ipynb')",
            "            fs_path = os.path.join(fm.root_dir, 'test.ipynb')",
            "            self.assertEqual(path, fs_path)",
            "",
            "    def test_checkpoint_subdir(self):",
            "        subd = 'sub \u2202ir'",
            "        cp_name = 'test-cp.ipynb'",
            "        with TemporaryDirectory() as td:",
            "            root = td",
            "            os.mkdir(os.path.join(td, subd))",
            "            fm = FileContentsManager(root_dir=root)",
            "            cpm = fm.checkpoints",
            "            cp_dir = cpm.checkpoint_path(",
            "                'cp', 'test.ipynb'",
            "            )",
            "            cp_subdir = cpm.checkpoint_path(",
            "                'cp', f'/{subd}/test.ipynb'",
            "            )",
            "        self.assertNotEqual(cp_dir, cp_subdir)",
            "        self.assertEqual(cp_dir, os.path.join(root, cpm.checkpoint_dir, cp_name))",
            "        self.assertEqual(cp_subdir, os.path.join(root, subd, cpm.checkpoint_dir, cp_name))",
            "",
            "    def test_bad_symlink(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            path = 'test bad symlink'",
            "            _make_dir(cm, path)",
            "",
            "            file_model = cm.new_untitled(path=path, ext='.txt')",
            "",
            "            # create a broken symlink",
            "            self.symlink(cm, \"target\", f'{path}/{\"bad symlink\"}')",
            "            model = cm.get(path)",
            "",
            "            contents = {",
            "                content['name']: content for content in model['content']",
            "            }",
            "            self.assertTrue('untitled.txt' in contents)",
            "            self.assertEqual(contents['untitled.txt'], file_model)",
            "            # broken symlinks should still be shown in the contents manager",
            "            self.assertTrue('bad symlink' in contents)",
            "",
            "    @skipIf(sys.platform == 'win32', \"will not run on windows\")",
            "    def test_recursive_symlink(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            path = 'test recursive symlink'",
            "            _make_dir(cm, path)",
            "            os_path = cm._get_os_path(path)",
            "            os.symlink(\"recursive\", os.path.join(os_path, \"recursive\"))",
            "            file_model = cm.new_untitled(path=path, ext='.txt')",
            "",
            "            model = cm.get(path)",
            "",
            "            contents = {",
            "                content['name']: content for content in model['content']",
            "            }",
            "            self.assertIn('untitled.txt', contents)",
            "            self.assertEqual(contents['untitled.txt'], file_model)",
            "            # recursive symlinks should not be shown in the contents manager",
            "            self.assertNotIn('recursive', contents)",
            "",
            "    def test_good_symlink(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            parent = 'test good symlink'",
            "            name = 'good symlink'",
            "            path = f'{parent}/{name}'",
            "            _make_dir(cm, parent)",
            "",
            "            file_model = cm.new(path=parent + '/zfoo.txt')",
            "",
            "            # create a good symlink",
            "            self.symlink(cm, file_model['path'], path)",
            "            symlink_model = cm.get(path, content=False)",
            "            dir_model = cm.get(parent)",
            "            self.assertEqual(",
            "                sorted(dir_model['content'], key=lambda x: x['name']),",
            "                [symlink_model, file_model],",
            "            )",
            "",
            "",
            "    @skipIf(hasattr(os, 'getuid') and os.getuid() == 0, \"Can't test permissions as root\")",
            "    @skipIf(sys.platform.startswith('win'), \"Can't test permissions on Windows\")",
            "    def test_403(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            model = cm.new_untitled(type='file')",
            "            os_path = cm._get_os_path(model['path'])",
            "",
            "            os.chmod(os_path, 0o400)",
            "            try:",
            "                with cm.open(os_path, 'w') as f:",
            "                    f.write(\"don't care\")",
            "            except HTTPError as e:",
            "                self.assertEqual(e.status_code, 403)",
            "            else:",
            "                self.fail(\"Should have raised HTTPError(403)\")",
            "",
            "    def test_escape_root(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            # make foo, bar next to root",
            "            with open(os.path.join(cm.root_dir, '..', 'foo'), 'w') as f:",
            "                f.write('foo')",
            "            with open(os.path.join(cm.root_dir, '..', 'bar'), 'w') as f:",
            "                f.write('bar')",
            "",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.get('..')",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.get('foo/../../../bar')",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.delete('../foo')",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.rename('../foo', '../bar')",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.save(model={",
            "                    'type': 'file',",
            "                    'content': '',",
            "                    'format': 'text',",
            "                }, path='../foo')",
            "",
            "",
            "class TestContentsManager(TestCase):",
            "    @contextmanager",
            "    def assertRaisesHTTPError(self, status, msg=None):",
            "        msg = msg or f\"Should have raised HTTPError({status})\"",
            "        try:",
            "            yield",
            "        except HTTPError as e:",
            "            self.assertEqual(e.status_code, status)",
            "        else:",
            "            self.fail(msg)",
            "",
            "    def make_populated_dir(self, api_path):",
            "        cm = self.contents_manager",
            "",
            "        self.make_dir(api_path)",
            "",
            "        cm.new(path=\"/\".join([api_path, \"nb.ipynb\"]))",
            "        cm.new(path=\"/\".join([api_path, \"file.txt\"]))",
            "",
            "    def check_populated_dir_files(self, api_path):",
            "        dir_model = self.contents_manager.get(api_path)",
            "",
            "        self.assertEqual(dir_model['path'], api_path)",
            "        self.assertEqual(dir_model['type'], \"directory\")",
            "",
            "        for entry in dir_model['content']:",
            "            if entry['type'] == \"directory\":",
            "                continue",
            "            elif entry['type'] == \"file\":",
            "                self.assertEqual(entry['name'], \"file.txt\")",
            "                complete_path = \"/\".join([api_path, \"file.txt\"])",
            "                self.assertEqual(entry[\"path\"], complete_path)",
            "            elif entry['type'] == \"notebook\":",
            "                self.assertEqual(entry['name'], \"nb.ipynb\")",
            "                complete_path = \"/\".join([api_path, \"nb.ipynb\"])",
            "                self.assertEqual(entry[\"path\"], complete_path)",
            "",
            "    def setUp(self):",
            "        self._temp_dir = TemporaryDirectory()",
            "        self.td = self._temp_dir.name",
            "        self.contents_manager = FileContentsManager(",
            "            root_dir=self.td,",
            "        )",
            "",
            "    def tearDown(self):",
            "        self._temp_dir.cleanup()",
            "",
            "    def make_dir(self, api_path):",
            "        \"\"\"make a subdirectory at api_path",
            "",
            "        override in subclasses if contents are not on the filesystem.",
            "        \"\"\"",
            "        _make_dir(self.contents_manager, api_path)",
            "",
            "    def add_code_cell(self, nb):",
            "        output = nbformat.new_output(\"display_data\", {'application/javascript': \"alert('hi');\"})",
            "        cell = nbformat.new_code_cell(\"print('hi')\", outputs=[output])",
            "        nb.cells.append(cell)",
            "",
            "    def new_notebook(self):",
            "        cm = self.contents_manager",
            "        model = cm.new_untitled(type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "",
            "        full_model = cm.get(path)",
            "        nb = full_model['content']",
            "        nb['metadata']['counter'] = int(1e6 * time.time())",
            "        self.add_code_cell(nb)",
            "",
            "        cm.save(full_model, path)",
            "        return nb, name, path",
            "",
            "    def test_new_untitled(self):",
            "        cm = self.contents_manager",
            "        # Test in root directory",
            "        model = cm.new_untitled(type='notebook')",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertIn('type', model)",
            "        self.assertEqual(model['type'], 'notebook')",
            "        self.assertEqual(model['name'], 'Untitled.ipynb')",
            "        self.assertEqual(model['path'], 'Untitled.ipynb')",
            "",
            "        # Test in sub-directory",
            "        model = cm.new_untitled(type='directory')",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertIn('type', model)",
            "        self.assertEqual(model['type'], 'directory')",
            "        self.assertEqual(model['name'], 'Untitled Folder')",
            "        self.assertEqual(model['path'], 'Untitled Folder')",
            "        sub_dir = model['path']",
            "",
            "        model = cm.new_untitled(path=sub_dir)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertIn('type', model)",
            "        self.assertEqual(model['type'], 'file')",
            "        self.assertEqual(model['name'], 'untitled')",
            "        self.assertEqual(model['path'], f'{sub_dir}/untitled')",
            "",
            "        # Test with a compound extension",
            "        model = cm.new_untitled(path=sub_dir, ext='.foo.bar')",
            "        self.assertEqual(model['name'], 'untitled.foo.bar')",
            "        model = cm.new_untitled(path=sub_dir, ext='.foo.bar')",
            "        self.assertEqual(model['name'], 'untitled1.foo.bar')",
            "",
            "    def test_modified_date(self):",
            "",
            "        cm = self.contents_manager",
            "",
            "        # Create a new notebook.",
            "        nb, name, path = self.new_notebook()",
            "        model = cm.get(path)",
            "",
            "        # Add a cell and save.",
            "        self.add_code_cell(model['content'])",
            "        cm.save(model, path)",
            "",
            "        # Reload notebook and verify that last_modified incremented.",
            "        saved = cm.get(path)",
            "        self.assertGreaterEqual(saved['last_modified'], model['last_modified'])",
            "",
            "        # Move the notebook and verify that last_modified stayed the same.",
            "        # (The frontend fires a warning if last_modified increases on the",
            "        # renamed file.)",
            "        new_path = 'renamed.ipynb'",
            "        cm.rename(path, new_path)",
            "        renamed = cm.get(new_path)",
            "        self.assertGreaterEqual(",
            "            renamed['last_modified'],",
            "            saved['last_modified'],",
            "        )",
            "",
            "    def test_get(self):",
            "        cm = self.contents_manager",
            "        # Create a notebook",
            "        model = cm.new_untitled(type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "",
            "        # Check that we 'get' on the notebook we just created",
            "        model2 = cm.get(path)",
            "        assert isinstance(model2, dict)",
            "        self.assertIn('name', model2)",
            "        self.assertIn('path', model2)",
            "        self.assertEqual(model['name'], name)",
            "        self.assertEqual(model['path'], path)",
            "",
            "        nb_as_file = cm.get(path, content=True, type='file')",
            "        self.assertEqual(nb_as_file['path'], path)",
            "        self.assertEqual(nb_as_file['type'], 'file')",
            "        self.assertEqual(nb_as_file['format'], 'text')",
            "        self.assertNotIsInstance(nb_as_file['content'], dict)",
            "",
            "        nb_as_bin_file = cm.get(path, content=True, type='file', format='base64')",
            "        self.assertEqual(nb_as_bin_file['format'], 'base64')",
            "",
            "        # Test in sub-directory",
            "        sub_dir = '/foo/'",
            "        self.make_dir('foo')",
            "        model = cm.new_untitled(path=sub_dir, ext='.ipynb')",
            "        model2 = cm.get(sub_dir + name)",
            "        assert isinstance(model2, dict)",
            "        self.assertIn('name', model2)",
            "        self.assertIn('path', model2)",
            "        self.assertIn('content', model2)",
            "        self.assertEqual(model2['name'], 'Untitled.ipynb')",
            "        self.assertEqual(model2['path'], f'{sub_dir.strip(\"/\")}/{name}')",
            "",
            "        # Test with a regular file.",
            "        file_model_path = cm.new_untitled(path=sub_dir, ext='.txt')['path']",
            "        file_model = cm.get(file_model_path)",
            "        self.assertDictContainsSubset(",
            "            {",
            "                'content': '',",
            "                'format': 'text',",
            "                'mimetype': 'text/plain',",
            "                'name': 'untitled.txt',",
            "                'path': 'foo/untitled.txt',",
            "                'type': 'file',",
            "                'writable': True,",
            "            },",
            "            file_model,",
            "        )",
            "        self.assertIn('created', file_model)",
            "        self.assertIn('last_modified', file_model)",
            "",
            "        # Test getting directory model",
            "",
            "        # Create a sub-sub directory to test getting directory contents with a",
            "        # subdir.",
            "        self.make_dir('foo/bar')",
            "        dirmodel = cm.get('foo')",
            "        self.assertEqual(dirmodel['type'], 'directory')",
            "        self.assertIsInstance(dirmodel['content'], list)",
            "        self.assertEqual(len(dirmodel['content']), 3)",
            "        self.assertEqual(dirmodel['path'], 'foo')",
            "        self.assertEqual(dirmodel['name'], 'foo')",
            "",
            "        # Directory contents should match the contents of each individual entry",
            "        # when requested with content=False.",
            "        model2_no_content = cm.get(sub_dir + name, content=False)",
            "        file_model_no_content = cm.get('foo/untitled.txt', content=False)",
            "        sub_sub_dir_no_content = cm.get('foo/bar', content=False)",
            "        self.assertEqual(sub_sub_dir_no_content['path'], 'foo/bar')",
            "        self.assertEqual(sub_sub_dir_no_content['name'], 'bar')",
            "",
            "        for entry in dirmodel['content']:",
            "            # Order isn't guaranteed by the spec, so this is a hacky way of",
            "            # verifying that all entries are matched.",
            "            if entry['path'] == sub_sub_dir_no_content['path']:",
            "                self.assertEqual(entry, sub_sub_dir_no_content)",
            "            elif entry['path'] == model2_no_content['path']:",
            "                self.assertEqual(entry, model2_no_content)",
            "            elif entry['path'] == file_model_no_content['path']:",
            "                self.assertEqual(entry, file_model_no_content)",
            "            else:",
            "                self.fail(f\"Unexpected directory entry: {entry()}\")",
            "",
            "        with self.assertRaises(HTTPError):",
            "            cm.get('foo', type='file')",
            "",
            "    def test_update(self):",
            "        cm = self.contents_manager",
            "        # Create a notebook",
            "        model = cm.new_untitled(type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "",
            "        # Change the name in the model for rename",
            "        model['path'] = 'test.ipynb'",
            "        model = cm.update(model, path)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertEqual(model['name'], 'test.ipynb')",
            "",
            "        # Make sure the old name is gone",
            "        self.assertRaises(HTTPError, cm.get, path)",
            "",
            "        # Test in sub-directory",
            "        # Create a directory and notebook in that directory",
            "        sub_dir = '/foo/'",
            "        self.make_dir('foo')",
            "        model = cm.new_untitled(path=sub_dir, type='notebook')",
            "        path = model['path']",
            "",
            "        # Change the name in the model for rename",
            "        d = path.rsplit('/', 1)[0]",
            "        new_path = model['path'] = d + '/test_in_sub.ipynb'",
            "        model = cm.update(model, path)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertEqual(model['name'], 'test_in_sub.ipynb')",
            "        self.assertEqual(model['path'], new_path)",
            "",
            "        # Make sure the old name is gone",
            "        self.assertRaises(HTTPError, cm.get, path)",
            "",
            "    def test_save(self):",
            "        cm = self.contents_manager",
            "        # Create a notebook",
            "        model = cm.new_untitled(type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "",
            "        # Get the model with 'content'",
            "        full_model = cm.get(path)",
            "",
            "        # Save the notebook",
            "        model = cm.save(full_model, path)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertEqual(model['name'], name)",
            "        self.assertEqual(model['path'], path)",
            "",
            "        # Test in sub-directory",
            "        # Create a directory and notebook in that directory",
            "        sub_dir = '/foo/'",
            "        self.make_dir('foo')",
            "        model = cm.new_untitled(path=sub_dir, type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "        model = cm.get(path)",
            "",
            "        # Change the name in the model for rename",
            "        model = cm.save(model, path)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertEqual(model['name'], 'Untitled.ipynb')",
            "        self.assertEqual(model['path'], 'foo/Untitled.ipynb')",
            "",
            "    def test_delete(self):",
            "        cm = self.contents_manager",
            "        # Create a notebook",
            "        nb, name, path = self.new_notebook()",
            "",
            "        # Delete the notebook",
            "        cm.delete(path)",
            "",
            "        # Check that deleting a non-existent path raises an error.",
            "        self.assertRaises(HTTPError, cm.delete, path)",
            "",
            "        # Check that a 'get' on the deleted notebook raises and error",
            "        self.assertRaises(HTTPError, cm.get, path)",
            "",
            "    def test_rename(self):",
            "        cm = self.contents_manager",
            "        # Create a new notebook",
            "        nb, name, path = self.new_notebook()",
            "",
            "        # Rename the notebook",
            "        cm.rename(path, \"changed_path\")",
            "",
            "        # Attempting to get the notebook under the old name raises an error",
            "        self.assertRaises(HTTPError, cm.get, path)",
            "        # Fetching the notebook under the new name is successful",
            "        assert isinstance(cm.get(\"changed_path\"), dict)",
            "",
            "        # Test validation.  Currently, only Windows has a non-empty set of invalid characters",
            "        if sys.platform == 'win32' and isinstance(cm, FileContentsManager):",
            "            with self.assertRaisesHTTPError(400):",
            "                cm.rename(\"changed_path\", \"prevent: in name\")",
            "",
            "        # Ported tests on nested directory renaming from pgcontents",
            "        all_dirs = ['foo', 'bar', 'foo/bar', 'foo/bar/foo', 'foo/bar/foo/bar']",
            "        unchanged_dirs = all_dirs[:2]",
            "        changed_dirs = all_dirs[2:]",
            "",
            "        for _dir in all_dirs:",
            "            self.make_populated_dir(_dir)",
            "            self.check_populated_dir_files(_dir)",
            "",
            "        # Renaming to an existing directory should fail",
            "        for src, dest in combinations(all_dirs, 2):",
            "            with self.assertRaisesHTTPError(409):",
            "                cm.rename(src, dest)",
            "",
            "        # Creating a notebook in a non_existant directory should fail",
            "        with self.assertRaisesHTTPError(404):",
            "            cm.new_untitled(\"foo/bar_diff\", ext=\".ipynb\")",
            "",
            "        cm.rename(\"foo/bar\", \"foo/bar_diff\")",
            "",
            "        # Assert that unchanged directories remain so",
            "        for unchanged in unchanged_dirs:",
            "            self.check_populated_dir_files(unchanged)",
            "",
            "        # Assert changed directories can no longer be accessed under old names",
            "        for changed_dirname in changed_dirs:",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.get(changed_dirname)",
            "",
            "            new_dirname = changed_dirname.replace(\"foo/bar\", \"foo/bar_diff\", 1)",
            "",
            "            self.check_populated_dir_files(new_dirname)",
            "",
            "        # Created a notebook in the renamed directory should work",
            "        cm.new_untitled(\"foo/bar_diff\", ext=\".ipynb\")",
            "",
            "    def test_delete_root(self):",
            "        cm = self.contents_manager",
            "        with self.assertRaises(HTTPError) as err:",
            "            cm.delete('')",
            "        self.assertEqual(err.exception.status_code, 400)",
            "",
            "    def test_copy(self):",
            "        cm = self.contents_manager",
            "        parent = '\u00e5 b'",
            "        name = 'nb \u221a.ipynb'",
            "        path = f'{parent}/{name}'",
            "        self.make_dir(parent)",
            "",
            "        orig = cm.new(path=path)",
            "        # copy with unspecified name",
            "        copy = cm.copy(path)",
            "        self.assertEqual(copy['name'], orig['name'].replace('.ipynb', '-Copy1.ipynb'))",
            "",
            "        # copy with specified name",
            "        copy2 = cm.copy(path, '\u00e5 b/copy 2.ipynb')",
            "        self.assertEqual(copy2['name'], 'copy 2.ipynb')",
            "        self.assertEqual(copy2['path'], '\u00e5 b/copy 2.ipynb')",
            "        # copy with specified path",
            "        copy2 = cm.copy(path, '/')",
            "        self.assertEqual(copy2['name'], name)",
            "        self.assertEqual(copy2['path'], name)",
            "",
            "    def test_trust_notebook(self):",
            "        cm = self.contents_manager",
            "        nb, name, path = self.new_notebook()",
            "",
            "        untrusted = cm.get(path)['content']",
            "        assert not cm.notary.check_cells(untrusted)",
            "",
            "        # print(untrusted)",
            "        cm.trust_notebook(path)",
            "        trusted = cm.get(path)['content']",
            "        # print(trusted)",
            "        assert cm.notary.check_cells(trusted)",
            "",
            "    def test_mark_trusted_cells(self):",
            "        cm = self.contents_manager",
            "        nb, name, path = self.new_notebook()",
            "",
            "        cm.mark_trusted_cells(nb, path)",
            "        for cell in nb.cells:",
            "            if cell.cell_type == 'code':",
            "                assert not cell.metadata.trusted",
            "",
            "        cm.trust_notebook(path)",
            "        nb = cm.get(path)['content']",
            "        for cell in nb.cells:",
            "            if cell.cell_type == 'code':",
            "                assert cell.metadata.trusted",
            "",
            "    def test_check_and_sign(self):",
            "        cm = self.contents_manager",
            "        nb, name, path = self.new_notebook()",
            "",
            "        cm.mark_trusted_cells(nb, path)",
            "        cm.check_and_sign(nb, path)",
            "        assert not cm.notary.check_signature(nb)",
            "",
            "        cm.trust_notebook(path)",
            "        nb = cm.get(path)['content']",
            "        cm.mark_trusted_cells(nb, path)",
            "        cm.check_and_sign(nb, path)",
            "        assert cm.notary.check_signature(nb)",
            "",
            "",
            "class TestContentsManagerNoAtomic(TestContentsManager):",
            "    \"\"\"",
            "    Make same test in no atomic case than in atomic case, using inheritance",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        self._temp_dir = TemporaryDirectory()",
            "        self.td = self._temp_dir.name",
            "        self.contents_manager = FileContentsManager(",
            "            root_dir = self.td,",
            "        )",
            "        self.contents_manager.use_atomic_writing = False"
        ],
        "afterPatchFile": [
            "\"\"\"Tests for the notebook manager.\"\"\"",
            "",
            "import os",
            "import sys",
            "import time",
            "from contextlib import contextmanager",
            "from itertools import combinations",
            "",
            "from tornado.web import HTTPError",
            "from unittest import TestCase, skipIf",
            "from tempfile import NamedTemporaryFile",
            "",
            "from nbformat import v4 as nbformat",
            "",
            "from ipython_genutils.tempdir import TemporaryDirectory",
            "from traitlets import TraitError",
            "",
            "from ..filemanager import FileContentsManager",
            "",
            "",
            "def _make_dir(contents_manager, api_path):",
            "    \"\"\"",
            "    Make a directory.",
            "    \"\"\"",
            "    os_path = contents_manager._get_os_path(api_path)",
            "    try:",
            "        os.makedirs(os_path)",
            "    except OSError:",
            "        print(f\"Directory already exists: {os_path!r}\")",
            "",
            "",
            "class TestFileContentsManager(TestCase):",
            "",
            "    @contextmanager",
            "    def assertRaisesHTTPError(self, status, msg=None):",
            "        msg = msg or f\"Should have raised HTTPError({status})\"",
            "        try:",
            "            yield",
            "        except HTTPError as e:",
            "            self.assertEqual(e.status_code, status)",
            "        else:",
            "            self.fail(msg)",
            "",
            "    def symlink(self, contents_manager, src, dst):",
            "        \"\"\"Make a symlink to src from dst",
            "",
            "        src and dst are api_paths",
            "        \"\"\"",
            "        src_os_path = contents_manager._get_os_path(src)",
            "        dst_os_path = contents_manager._get_os_path(dst)",
            "        print(src_os_path, dst_os_path, os.path.isfile(src_os_path))",
            "        os.symlink(src_os_path, dst_os_path)",
            "",
            "    def test_root_dir(self):",
            "        with TemporaryDirectory() as td:",
            "            fm = FileContentsManager(root_dir=td)",
            "            self.assertEqual(fm.root_dir, td)",
            "",
            "    def test_missing_root_dir(self):",
            "        with TemporaryDirectory() as td:",
            "            root = os.path.join(td, 'notebook', 'dir', 'is', 'missing')",
            "            self.assertRaises(TraitError, FileContentsManager, root_dir=root)",
            "",
            "    def test_invalid_root_dir(self):",
            "        with NamedTemporaryFile() as tf:",
            "            self.assertRaises(TraitError, FileContentsManager, root_dir=tf.name)",
            "",
            "    def test_get_os_path(self):",
            "        # full filesystem path should be returned with correct operating system",
            "        # separators.",
            "        with TemporaryDirectory() as td:",
            "            root = td",
            "            fm = FileContentsManager(root_dir=root)",
            "            path = fm._get_os_path('/path/to/notebook/test.ipynb')",
            "            rel_path_list =  '/path/to/notebook/test.ipynb'.split('/')",
            "            fs_path = os.path.join(fm.root_dir, *rel_path_list)",
            "            self.assertEqual(path, fs_path)",
            "",
            "            fm = FileContentsManager(root_dir=root)",
            "            path = fm._get_os_path('test.ipynb')",
            "            fs_path = os.path.join(fm.root_dir, 'test.ipynb')",
            "            self.assertEqual(path, fs_path)",
            "",
            "            fm = FileContentsManager(root_dir=root)",
            "            path = fm._get_os_path('////test.ipynb')",
            "            fs_path = os.path.join(fm.root_dir, 'test.ipynb')",
            "            self.assertEqual(path, fs_path)",
            "",
            "    def test_checkpoint_subdir(self):",
            "        subd = 'sub \u2202ir'",
            "        cp_name = 'test-cp.ipynb'",
            "        with TemporaryDirectory() as td:",
            "            root = td",
            "            os.mkdir(os.path.join(td, subd))",
            "            fm = FileContentsManager(root_dir=root)",
            "            cpm = fm.checkpoints",
            "            cp_dir = cpm.checkpoint_path(",
            "                'cp', 'test.ipynb'",
            "            )",
            "            cp_subdir = cpm.checkpoint_path(",
            "                'cp', f'/{subd}/test.ipynb'",
            "            )",
            "        self.assertNotEqual(cp_dir, cp_subdir)",
            "        self.assertEqual(cp_dir, os.path.join(root, cpm.checkpoint_dir, cp_name))",
            "        self.assertEqual(cp_subdir, os.path.join(root, subd, cpm.checkpoint_dir, cp_name))",
            "",
            "    def test_bad_symlink(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            path = 'test bad symlink'",
            "            _make_dir(cm, path)",
            "",
            "            file_model = cm.new_untitled(path=path, ext='.txt')",
            "",
            "            # create a broken symlink",
            "            self.symlink(cm, \"target\", f'{path}/{\"bad symlink\"}')",
            "            model = cm.get(path)",
            "",
            "            contents = {",
            "                content['name']: content for content in model['content']",
            "            }",
            "            self.assertTrue('untitled.txt' in contents)",
            "            self.assertEqual(contents['untitled.txt'], file_model)",
            "            # broken symlinks should still be shown in the contents manager",
            "            self.assertTrue('bad symlink' in contents)",
            "",
            "    @skipIf(sys.platform == 'win32', \"will not run on windows\")",
            "    def test_recursive_symlink(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            path = 'test recursive symlink'",
            "            _make_dir(cm, path)",
            "            os_path = cm._get_os_path(path)",
            "            os.symlink(\"recursive\", os.path.join(os_path, \"recursive\"))",
            "            file_model = cm.new_untitled(path=path, ext='.txt')",
            "",
            "            model = cm.get(path)",
            "",
            "            contents = {",
            "                content['name']: content for content in model['content']",
            "            }",
            "            self.assertIn('untitled.txt', contents)",
            "            self.assertEqual(contents['untitled.txt'], file_model)",
            "            # recursive symlinks should not be shown in the contents manager",
            "            self.assertNotIn('recursive', contents)",
            "",
            "    def test_good_symlink(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            parent = 'test good symlink'",
            "            name = 'good symlink'",
            "            path = f'{parent}/{name}'",
            "            _make_dir(cm, parent)",
            "",
            "            file_model = cm.new(path=parent + '/zfoo.txt')",
            "",
            "            # create a good symlink",
            "            self.symlink(cm, file_model['path'], path)",
            "            symlink_model = cm.get(path, content=False)",
            "            dir_model = cm.get(parent)",
            "            self.assertEqual(",
            "                sorted(dir_model['content'], key=lambda x: x['name']),",
            "                [symlink_model, file_model],",
            "            )",
            "",
            "",
            "    @skipIf(hasattr(os, 'getuid') and os.getuid() == 0, \"Can't test permissions as root\")",
            "    @skipIf(sys.platform.startswith('win'), \"Can't test permissions on Windows\")",
            "    def test_403(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            model = cm.new_untitled(type='file')",
            "            os_path = cm._get_os_path(model['path'])",
            "",
            "            os.chmod(os_path, 0o400)",
            "            try:",
            "                with cm.open(os_path, 'w') as f:",
            "                    f.write(\"don't care\")",
            "            except HTTPError as e:",
            "                self.assertEqual(e.status_code, 403)",
            "            else:",
            "                self.fail(\"Should have raised HTTPError(403)\")",
            "",
            "    @skipIf(sys.platform.startswith('win'), \"Can't test hidden files on Windows\")",
            "    def test_404(self):",
            "        #Test visible file in hidden folder",
            "        with self.assertRaises(HTTPError) as excinfo:",
            "            with TemporaryDirectory() as td:",
            "                cm = FileContentsManager(root_dir=td)",
            "                hidden_dir = '.hidden'",
            "                file_in_hidden_path = os.path.join(hidden_dir,'visible.txt')",
            "                _make_dir(cm, hidden_dir)",
            "                model = cm.new(path=file_in_hidden_path)",
            "                os_path = cm._get_os_path(model['path'])",
            "",
            "                try:",
            "                    result = cm.get(os_path, 'w')",
            "                except HTTPError as e:",
            "                    self.assertEqual(e.status_code, 404)",
            "                else:",
            "                    self.fail(\"Should have raised HTTPError(404)\")",
            "        #Test hidden file in visible folder",
            "        with self.assertRaises(HTTPError) as excinfo:",
            "            with TemporaryDirectory() as td:",
            "                cm = FileContentsManager(root_dir=td)",
            "                hidden_dir = 'visible'",
            "                file_in_hidden_path = os.path.join(hidden_dir,'.hidden.txt')",
            "                _make_dir(cm, hidden_dir)",
            "                model = cm.new(path=file_in_hidden_path)",
            "                os_path = cm._get_os_path(model['path'])",
            "",
            "                try:",
            "                    result = cm.get(os_path, 'w')",
            "                except HTTPError as e:",
            "                    self.assertEqual(e.status_code, 404)",
            "                else:",
            "                    self.fail(\"Should have raised HTTPError(404)\")",
            "",
            "    def test_escape_root(self):",
            "        with TemporaryDirectory() as td:",
            "            cm = FileContentsManager(root_dir=td)",
            "            # make foo, bar next to root",
            "            with open(os.path.join(cm.root_dir, '..', 'foo'), 'w') as f:",
            "                f.write('foo')",
            "            with open(os.path.join(cm.root_dir, '..', 'bar'), 'w') as f:",
            "                f.write('bar')",
            "",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.get('..')",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.get('foo/../../../bar')",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.delete('../foo')",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.rename('../foo', '../bar')",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.save(model={",
            "                    'type': 'file',",
            "                    'content': '',",
            "                    'format': 'text',",
            "                }, path='../foo')",
            "",
            "",
            "class TestContentsManager(TestCase):",
            "    @contextmanager",
            "    def assertRaisesHTTPError(self, status, msg=None):",
            "        msg = msg or f\"Should have raised HTTPError({status})\"",
            "        try:",
            "            yield",
            "        except HTTPError as e:",
            "            self.assertEqual(e.status_code, status)",
            "        else:",
            "            self.fail(msg)",
            "",
            "    def make_populated_dir(self, api_path):",
            "        cm = self.contents_manager",
            "",
            "        self.make_dir(api_path)",
            "",
            "        cm.new(path=\"/\".join([api_path, \"nb.ipynb\"]))",
            "        cm.new(path=\"/\".join([api_path, \"file.txt\"]))",
            "",
            "    def check_populated_dir_files(self, api_path):",
            "        dir_model = self.contents_manager.get(api_path)",
            "",
            "        self.assertEqual(dir_model['path'], api_path)",
            "        self.assertEqual(dir_model['type'], \"directory\")",
            "",
            "        for entry in dir_model['content']:",
            "            if entry['type'] == \"directory\":",
            "                continue",
            "            elif entry['type'] == \"file\":",
            "                self.assertEqual(entry['name'], \"file.txt\")",
            "                complete_path = \"/\".join([api_path, \"file.txt\"])",
            "                self.assertEqual(entry[\"path\"], complete_path)",
            "            elif entry['type'] == \"notebook\":",
            "                self.assertEqual(entry['name'], \"nb.ipynb\")",
            "                complete_path = \"/\".join([api_path, \"nb.ipynb\"])",
            "                self.assertEqual(entry[\"path\"], complete_path)",
            "",
            "    def setUp(self):",
            "        self._temp_dir = TemporaryDirectory()",
            "        self.td = self._temp_dir.name",
            "        self.contents_manager = FileContentsManager(",
            "            root_dir=self.td,",
            "        )",
            "",
            "    def tearDown(self):",
            "        self._temp_dir.cleanup()",
            "",
            "    def make_dir(self, api_path):",
            "        \"\"\"make a subdirectory at api_path",
            "",
            "        override in subclasses if contents are not on the filesystem.",
            "        \"\"\"",
            "        _make_dir(self.contents_manager, api_path)",
            "",
            "    def add_code_cell(self, nb):",
            "        output = nbformat.new_output(\"display_data\", {'application/javascript': \"alert('hi');\"})",
            "        cell = nbformat.new_code_cell(\"print('hi')\", outputs=[output])",
            "        nb.cells.append(cell)",
            "",
            "    def new_notebook(self):",
            "        cm = self.contents_manager",
            "        model = cm.new_untitled(type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "",
            "        full_model = cm.get(path)",
            "        nb = full_model['content']",
            "        nb['metadata']['counter'] = int(1e6 * time.time())",
            "        self.add_code_cell(nb)",
            "",
            "        cm.save(full_model, path)",
            "        return nb, name, path",
            "",
            "    def test_new_untitled(self):",
            "        cm = self.contents_manager",
            "        # Test in root directory",
            "        model = cm.new_untitled(type='notebook')",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertIn('type', model)",
            "        self.assertEqual(model['type'], 'notebook')",
            "        self.assertEqual(model['name'], 'Untitled.ipynb')",
            "        self.assertEqual(model['path'], 'Untitled.ipynb')",
            "",
            "        # Test in sub-directory",
            "        model = cm.new_untitled(type='directory')",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertIn('type', model)",
            "        self.assertEqual(model['type'], 'directory')",
            "        self.assertEqual(model['name'], 'Untitled Folder')",
            "        self.assertEqual(model['path'], 'Untitled Folder')",
            "        sub_dir = model['path']",
            "",
            "        model = cm.new_untitled(path=sub_dir)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertIn('type', model)",
            "        self.assertEqual(model['type'], 'file')",
            "        self.assertEqual(model['name'], 'untitled')",
            "        self.assertEqual(model['path'], f'{sub_dir}/untitled')",
            "",
            "        # Test with a compound extension",
            "        model = cm.new_untitled(path=sub_dir, ext='.foo.bar')",
            "        self.assertEqual(model['name'], 'untitled.foo.bar')",
            "        model = cm.new_untitled(path=sub_dir, ext='.foo.bar')",
            "        self.assertEqual(model['name'], 'untitled1.foo.bar')",
            "",
            "    def test_modified_date(self):",
            "",
            "        cm = self.contents_manager",
            "",
            "        # Create a new notebook.",
            "        nb, name, path = self.new_notebook()",
            "        model = cm.get(path)",
            "",
            "        # Add a cell and save.",
            "        self.add_code_cell(model['content'])",
            "        cm.save(model, path)",
            "",
            "        # Reload notebook and verify that last_modified incremented.",
            "        saved = cm.get(path)",
            "        self.assertGreaterEqual(saved['last_modified'], model['last_modified'])",
            "",
            "        # Move the notebook and verify that last_modified stayed the same.",
            "        # (The frontend fires a warning if last_modified increases on the",
            "        # renamed file.)",
            "        new_path = 'renamed.ipynb'",
            "        cm.rename(path, new_path)",
            "        renamed = cm.get(new_path)",
            "        self.assertGreaterEqual(",
            "            renamed['last_modified'],",
            "            saved['last_modified'],",
            "        )",
            "",
            "    def test_get(self):",
            "        cm = self.contents_manager",
            "        # Create a notebook",
            "        model = cm.new_untitled(type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "",
            "        # Check that we 'get' on the notebook we just created",
            "        model2 = cm.get(path)",
            "        assert isinstance(model2, dict)",
            "        self.assertIn('name', model2)",
            "        self.assertIn('path', model2)",
            "        self.assertEqual(model['name'], name)",
            "        self.assertEqual(model['path'], path)",
            "",
            "        nb_as_file = cm.get(path, content=True, type='file')",
            "        self.assertEqual(nb_as_file['path'], path)",
            "        self.assertEqual(nb_as_file['type'], 'file')",
            "        self.assertEqual(nb_as_file['format'], 'text')",
            "        self.assertNotIsInstance(nb_as_file['content'], dict)",
            "",
            "        nb_as_bin_file = cm.get(path, content=True, type='file', format='base64')",
            "        self.assertEqual(nb_as_bin_file['format'], 'base64')",
            "",
            "        # Test in sub-directory",
            "        sub_dir = '/foo/'",
            "        self.make_dir('foo')",
            "        model = cm.new_untitled(path=sub_dir, ext='.ipynb')",
            "        model2 = cm.get(sub_dir + name)",
            "        assert isinstance(model2, dict)",
            "        self.assertIn('name', model2)",
            "        self.assertIn('path', model2)",
            "        self.assertIn('content', model2)",
            "        self.assertEqual(model2['name'], 'Untitled.ipynb')",
            "        self.assertEqual(model2['path'], f'{sub_dir.strip(\"/\")}/{name}')",
            "",
            "        # Test with a regular file.",
            "        file_model_path = cm.new_untitled(path=sub_dir, ext='.txt')['path']",
            "        file_model = cm.get(file_model_path)",
            "        self.assertDictContainsSubset(",
            "            {",
            "                'content': '',",
            "                'format': 'text',",
            "                'mimetype': 'text/plain',",
            "                'name': 'untitled.txt',",
            "                'path': 'foo/untitled.txt',",
            "                'type': 'file',",
            "                'writable': True,",
            "            },",
            "            file_model,",
            "        )",
            "        self.assertIn('created', file_model)",
            "        self.assertIn('last_modified', file_model)",
            "",
            "        # Test getting directory model",
            "",
            "        # Create a sub-sub directory to test getting directory contents with a",
            "        # subdir.",
            "        self.make_dir('foo/bar')",
            "        dirmodel = cm.get('foo')",
            "        self.assertEqual(dirmodel['type'], 'directory')",
            "        self.assertIsInstance(dirmodel['content'], list)",
            "        self.assertEqual(len(dirmodel['content']), 3)",
            "        self.assertEqual(dirmodel['path'], 'foo')",
            "        self.assertEqual(dirmodel['name'], 'foo')",
            "",
            "        # Directory contents should match the contents of each individual entry",
            "        # when requested with content=False.",
            "        model2_no_content = cm.get(sub_dir + name, content=False)",
            "        file_model_no_content = cm.get('foo/untitled.txt', content=False)",
            "        sub_sub_dir_no_content = cm.get('foo/bar', content=False)",
            "        self.assertEqual(sub_sub_dir_no_content['path'], 'foo/bar')",
            "        self.assertEqual(sub_sub_dir_no_content['name'], 'bar')",
            "",
            "        for entry in dirmodel['content']:",
            "            # Order isn't guaranteed by the spec, so this is a hacky way of",
            "            # verifying that all entries are matched.",
            "            if entry['path'] == sub_sub_dir_no_content['path']:",
            "                self.assertEqual(entry, sub_sub_dir_no_content)",
            "            elif entry['path'] == model2_no_content['path']:",
            "                self.assertEqual(entry, model2_no_content)",
            "            elif entry['path'] == file_model_no_content['path']:",
            "                self.assertEqual(entry, file_model_no_content)",
            "            else:",
            "                self.fail(f\"Unexpected directory entry: {entry()}\")",
            "",
            "        with self.assertRaises(HTTPError):",
            "            cm.get('foo', type='file')",
            "",
            "    def test_update(self):",
            "        cm = self.contents_manager",
            "        # Create a notebook",
            "        model = cm.new_untitled(type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "",
            "        # Change the name in the model for rename",
            "        model['path'] = 'test.ipynb'",
            "        model = cm.update(model, path)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertEqual(model['name'], 'test.ipynb')",
            "",
            "        # Make sure the old name is gone",
            "        self.assertRaises(HTTPError, cm.get, path)",
            "",
            "        # Test in sub-directory",
            "        # Create a directory and notebook in that directory",
            "        sub_dir = '/foo/'",
            "        self.make_dir('foo')",
            "        model = cm.new_untitled(path=sub_dir, type='notebook')",
            "        path = model['path']",
            "",
            "        # Change the name in the model for rename",
            "        d = path.rsplit('/', 1)[0]",
            "        new_path = model['path'] = d + '/test_in_sub.ipynb'",
            "        model = cm.update(model, path)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertEqual(model['name'], 'test_in_sub.ipynb')",
            "        self.assertEqual(model['path'], new_path)",
            "",
            "        # Make sure the old name is gone",
            "        self.assertRaises(HTTPError, cm.get, path)",
            "",
            "    def test_save(self):",
            "        cm = self.contents_manager",
            "        # Create a notebook",
            "        model = cm.new_untitled(type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "",
            "        # Get the model with 'content'",
            "        full_model = cm.get(path)",
            "",
            "        # Save the notebook",
            "        model = cm.save(full_model, path)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertEqual(model['name'], name)",
            "        self.assertEqual(model['path'], path)",
            "",
            "        # Test in sub-directory",
            "        # Create a directory and notebook in that directory",
            "        sub_dir = '/foo/'",
            "        self.make_dir('foo')",
            "        model = cm.new_untitled(path=sub_dir, type='notebook')",
            "        name = model['name']",
            "        path = model['path']",
            "        model = cm.get(path)",
            "",
            "        # Change the name in the model for rename",
            "        model = cm.save(model, path)",
            "        assert isinstance(model, dict)",
            "        self.assertIn('name', model)",
            "        self.assertIn('path', model)",
            "        self.assertEqual(model['name'], 'Untitled.ipynb')",
            "        self.assertEqual(model['path'], 'foo/Untitled.ipynb')",
            "",
            "    def test_delete(self):",
            "        cm = self.contents_manager",
            "        # Create a notebook",
            "        nb, name, path = self.new_notebook()",
            "",
            "        # Delete the notebook",
            "        cm.delete(path)",
            "",
            "        # Check that deleting a non-existent path raises an error.",
            "        self.assertRaises(HTTPError, cm.delete, path)",
            "",
            "        # Check that a 'get' on the deleted notebook raises and error",
            "        self.assertRaises(HTTPError, cm.get, path)",
            "",
            "    def test_rename(self):",
            "        cm = self.contents_manager",
            "        # Create a new notebook",
            "        nb, name, path = self.new_notebook()",
            "",
            "        # Rename the notebook",
            "        cm.rename(path, \"changed_path\")",
            "",
            "        # Attempting to get the notebook under the old name raises an error",
            "        self.assertRaises(HTTPError, cm.get, path)",
            "        # Fetching the notebook under the new name is successful",
            "        assert isinstance(cm.get(\"changed_path\"), dict)",
            "",
            "        # Test validation.  Currently, only Windows has a non-empty set of invalid characters",
            "        if sys.platform == 'win32' and isinstance(cm, FileContentsManager):",
            "            with self.assertRaisesHTTPError(400):",
            "                cm.rename(\"changed_path\", \"prevent: in name\")",
            "",
            "        # Ported tests on nested directory renaming from pgcontents",
            "        all_dirs = ['foo', 'bar', 'foo/bar', 'foo/bar/foo', 'foo/bar/foo/bar']",
            "        unchanged_dirs = all_dirs[:2]",
            "        changed_dirs = all_dirs[2:]",
            "",
            "        for _dir in all_dirs:",
            "            self.make_populated_dir(_dir)",
            "            self.check_populated_dir_files(_dir)",
            "",
            "        # Renaming to an existing directory should fail",
            "        for src, dest in combinations(all_dirs, 2):",
            "            with self.assertRaisesHTTPError(409):",
            "                cm.rename(src, dest)",
            "",
            "        # Creating a notebook in a non_existant directory should fail",
            "        with self.assertRaisesHTTPError(404):",
            "            cm.new_untitled(\"foo/bar_diff\", ext=\".ipynb\")",
            "",
            "        cm.rename(\"foo/bar\", \"foo/bar_diff\")",
            "",
            "        # Assert that unchanged directories remain so",
            "        for unchanged in unchanged_dirs:",
            "            self.check_populated_dir_files(unchanged)",
            "",
            "        # Assert changed directories can no longer be accessed under old names",
            "        for changed_dirname in changed_dirs:",
            "            with self.assertRaisesHTTPError(404):",
            "                cm.get(changed_dirname)",
            "",
            "            new_dirname = changed_dirname.replace(\"foo/bar\", \"foo/bar_diff\", 1)",
            "",
            "            self.check_populated_dir_files(new_dirname)",
            "",
            "        # Created a notebook in the renamed directory should work",
            "        cm.new_untitled(\"foo/bar_diff\", ext=\".ipynb\")",
            "",
            "    def test_delete_root(self):",
            "        cm = self.contents_manager",
            "        with self.assertRaises(HTTPError) as err:",
            "            cm.delete('')",
            "        self.assertEqual(err.exception.status_code, 400)",
            "",
            "    def test_copy(self):",
            "        cm = self.contents_manager",
            "        parent = '\u00e5 b'",
            "        name = 'nb \u221a.ipynb'",
            "        path = f'{parent}/{name}'",
            "        self.make_dir(parent)",
            "",
            "        orig = cm.new(path=path)",
            "        # copy with unspecified name",
            "        copy = cm.copy(path)",
            "        self.assertEqual(copy['name'], orig['name'].replace('.ipynb', '-Copy1.ipynb'))",
            "",
            "        # copy with specified name",
            "        copy2 = cm.copy(path, '\u00e5 b/copy 2.ipynb')",
            "        self.assertEqual(copy2['name'], 'copy 2.ipynb')",
            "        self.assertEqual(copy2['path'], '\u00e5 b/copy 2.ipynb')",
            "        # copy with specified path",
            "        copy2 = cm.copy(path, '/')",
            "        self.assertEqual(copy2['name'], name)",
            "        self.assertEqual(copy2['path'], name)",
            "",
            "    def test_trust_notebook(self):",
            "        cm = self.contents_manager",
            "        nb, name, path = self.new_notebook()",
            "",
            "        untrusted = cm.get(path)['content']",
            "        assert not cm.notary.check_cells(untrusted)",
            "",
            "        # print(untrusted)",
            "        cm.trust_notebook(path)",
            "        trusted = cm.get(path)['content']",
            "        # print(trusted)",
            "        assert cm.notary.check_cells(trusted)",
            "",
            "    def test_mark_trusted_cells(self):",
            "        cm = self.contents_manager",
            "        nb, name, path = self.new_notebook()",
            "",
            "        cm.mark_trusted_cells(nb, path)",
            "        for cell in nb.cells:",
            "            if cell.cell_type == 'code':",
            "                assert not cell.metadata.trusted",
            "",
            "        cm.trust_notebook(path)",
            "        nb = cm.get(path)['content']",
            "        for cell in nb.cells:",
            "            if cell.cell_type == 'code':",
            "                assert cell.metadata.trusted",
            "",
            "    def test_check_and_sign(self):",
            "        cm = self.contents_manager",
            "        nb, name, path = self.new_notebook()",
            "",
            "        cm.mark_trusted_cells(nb, path)",
            "        cm.check_and_sign(nb, path)",
            "        assert not cm.notary.check_signature(nb)",
            "",
            "        cm.trust_notebook(path)",
            "        nb = cm.get(path)['content']",
            "        cm.mark_trusted_cells(nb, path)",
            "        cm.check_and_sign(nb, path)",
            "        assert cm.notary.check_signature(nb)",
            "",
            "",
            "class TestContentsManagerNoAtomic(TestContentsManager):",
            "    \"\"\"",
            "    Make same test in no atomic case than in atomic case, using inheritance",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        self._temp_dir = TemporaryDirectory()",
            "        self.td = self._temp_dir.name",
            "        self.contents_manager = FileContentsManager(",
            "            root_dir = self.td,",
            "        )",
            "        self.contents_manager.use_atomic_writing = False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "notebook.services.contents.tests.test_manager.TestFileContentsManager.self",
            "src.urllib3.util.retry"
        ]
    }
}