{
    "src/sentry/api/endpoints/accept_organization_invite.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from rest_framework.response import Response"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from sentry.api.base import Endpoint, region_silo_endpoint"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sentry.api.invite_helper import ApiInviteHelper, add_invite_cookie, remove_invite_cookie"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from sentry.api.invite_helper import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+    ApiInviteHelper,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+    add_invite_details_to_session,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+    remove_invite_details_from_session,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+)"
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from sentry.models import AuthProvider, OrganizationMember"
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from sentry.utils import auth"
            },
            "11": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     # Disable authentication and permission requirements."
            },
            "13": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     permission_classes = []"
            },
            "14": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def respond_invalid(self, request: Request) -> Response:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    @staticmethod"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    def respond_invalid() -> Response:"
            },
            "18": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         return Response(status=status.HTTP_400_BAD_REQUEST, data={\"details\": \"Invalid invite code\"})"
            },
            "19": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def get_helper(self, request: Request, member_id, token):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    def get_helper(self, request: Request, member_id: int, token: str) -> ApiInviteHelper:"
            },
            "22": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         return ApiInviteHelper(request=request, member_id=member_id, instance=self, token=token)"
            },
            "23": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def get(self, request: Request, member_id, token) -> Response:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    def get(self, request: Request, member_id: int, token: str) -> Response:"
            },
            "26": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         try:"
            },
            "27": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "             helper = self.get_helper(request, member_id, token)"
            },
            "28": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         except OrganizationMember.DoesNotExist:"
            },
            "29": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self.respond_invalid(request)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+            return self.respond_invalid()"
            },
            "31": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        om = helper.om"
            },
            "33": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        organization = om.organization"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        organization_member = helper.om"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        organization = organization_member.organization"
            },
            "36": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not helper.member_pending or not helper.valid_token or not om.invite_approved:"
            },
            "38": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self.respond_invalid(request)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        if ("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            not helper.member_pending"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            or not helper.valid_token"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+            or not organization_member.invite_approved"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        ):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+            return self.respond_invalid()"
            },
            "45": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Keep track of the invite email for when we land back on the login page"
            },
            "47": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        request.session[\"invite_email\"] = om.email"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        # Keep track of the invite details in the request session"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        request.session[\"invite_email\"] = organization_member.email"
            },
            "50": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         try:"
            },
            "52": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             auth_provider = AuthProvider.objects.get(organization=organization)"
            },
            "53": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         # Allow users to register an account when accepting an invite"
            },
            "54": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         if not helper.user_authenticated:"
            },
            "55": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "             request.session[\"can_register\"] = True"
            },
            "56": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            add_invite_cookie(request, response, member_id, token)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            add_invite_details_to_session("
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                request, organization_member.id, organization_member.token"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            )"
            },
            "60": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "             # When SSO is required do *not* set a next_url to return to accept"
            },
            "62": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             # invite. The invite will be accepted after SSO is completed."
            },
            "63": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         # to come back to the accept invite page since 2FA will *not* be"
            },
            "64": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         # required if SSO is required."
            },
            "65": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         if auth_provider is not None:"
            },
            "66": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            add_invite_cookie(request, response, member_id, token)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            add_invite_details_to_session("
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                request, organization_member.id, organization_member.token"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            )"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "             provider = auth_provider.get_provider()"
            },
            "72": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "             data[\"ssoProvider\"] = provider.name"
            },
            "73": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         onboarding_steps = helper.get_onboarding_steps()"
            },
            "75": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         data.update(onboarding_steps)"
            },
            "76": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         if any(onboarding_steps.values()):"
            },
            "77": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            add_invite_cookie(request, response, member_id, token)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            add_invite_details_to_session("
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                request, organization_member.id, organization_member.token"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            )"
            },
            "81": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " "
            },
            "82": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         response.data = data"
            },
            "83": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         return response"
            },
            "85": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def post(self, request: Request, member_id, token) -> Response:"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    def post(self, request: Request, member_id: int, token: str) -> Response:"
            },
            "88": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "         try:"
            },
            "89": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "             helper = self.get_helper(request, member_id, token)"
            },
            "90": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         except OrganizationMember.DoesNotExist:"
            },
            "91": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self.respond_invalid(request)"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            return self.respond_invalid()"
            },
            "93": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 110,
                "PatchRowcode": " "
            },
            "94": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         if not helper.valid_request:"
            },
            "95": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "             return Response("
            },
            "96": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "             response = Response(status=status.HTTP_204_NO_CONTENT)"
            },
            "97": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         helper.accept_invite()"
            },
            "99": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        remove_invite_cookie(request, response)"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        remove_invite_details_from_session(request)"
            },
            "101": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " "
            },
            "102": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         return response"
            }
        },
        "frontPatchFile": [
            "from django.urls import reverse",
            "from rest_framework import status",
            "from rest_framework.request import Request",
            "from rest_framework.response import Response",
            "",
            "from sentry.api.base import Endpoint, region_silo_endpoint",
            "from sentry.api.invite_helper import ApiInviteHelper, add_invite_cookie, remove_invite_cookie",
            "from sentry.models import AuthProvider, OrganizationMember",
            "from sentry.utils import auth",
            "",
            "",
            "@region_silo_endpoint",
            "class AcceptOrganizationInvite(Endpoint):",
            "    # Disable authentication and permission requirements.",
            "    permission_classes = []",
            "",
            "    def respond_invalid(self, request: Request) -> Response:",
            "        return Response(status=status.HTTP_400_BAD_REQUEST, data={\"details\": \"Invalid invite code\"})",
            "",
            "    def get_helper(self, request: Request, member_id, token):",
            "        return ApiInviteHelper(request=request, member_id=member_id, instance=self, token=token)",
            "",
            "    def get(self, request: Request, member_id, token) -> Response:",
            "        try:",
            "            helper = self.get_helper(request, member_id, token)",
            "        except OrganizationMember.DoesNotExist:",
            "            return self.respond_invalid(request)",
            "",
            "        om = helper.om",
            "        organization = om.organization",
            "",
            "        if not helper.member_pending or not helper.valid_token or not om.invite_approved:",
            "            return self.respond_invalid(request)",
            "",
            "        # Keep track of the invite email for when we land back on the login page",
            "        request.session[\"invite_email\"] = om.email",
            "",
            "        try:",
            "            auth_provider = AuthProvider.objects.get(organization=organization)",
            "        except AuthProvider.DoesNotExist:",
            "            auth_provider = None",
            "",
            "        data = {",
            "            \"orgSlug\": organization.slug,",
            "            \"needsAuthentication\": not helper.user_authenticated,",
            "            \"needsSso\": auth_provider is not None,",
            "            \"hasAuthProvider\": auth_provider is not None,",
            "            \"requireSso\": auth_provider is not None and not auth_provider.flags.allow_unlinked,",
            "            # If they're already a member of the organization its likely",
            "            # they're using a shared account and either previewing this invite",
            "            # or are incorrectly expecting this to create a new account.",
            "            \"existingMember\": helper.member_already_exists,",
            "        }",
            "",
            "        response = Response(None)",
            "",
            "        # Allow users to register an account when accepting an invite",
            "        if not helper.user_authenticated:",
            "            request.session[\"can_register\"] = True",
            "            add_invite_cookie(request, response, member_id, token)",
            "",
            "            # When SSO is required do *not* set a next_url to return to accept",
            "            # invite. The invite will be accepted after SSO is completed.",
            "            url = (",
            "                reverse(\"sentry-accept-invite\", args=[member_id, token])",
            "                if not auth_provider",
            "                else \"/\"",
            "            )",
            "            auth.initiate_login(self.request, next_url=url)",
            "",
            "        # If the org has SSO setup, we'll store the invite cookie to later",
            "        # associate the org member after authentication. We can avoid needing",
            "        # to come back to the accept invite page since 2FA will *not* be",
            "        # required if SSO is required.",
            "        if auth_provider is not None:",
            "            add_invite_cookie(request, response, member_id, token)",
            "            provider = auth_provider.get_provider()",
            "            data[\"ssoProvider\"] = provider.name",
            "",
            "        onboarding_steps = helper.get_onboarding_steps()",
            "        data.update(onboarding_steps)",
            "        if any(onboarding_steps.values()):",
            "            add_invite_cookie(request, response, member_id, token)",
            "",
            "        response.data = data",
            "",
            "        return response",
            "",
            "    def post(self, request: Request, member_id, token) -> Response:",
            "        try:",
            "            helper = self.get_helper(request, member_id, token)",
            "        except OrganizationMember.DoesNotExist:",
            "            return self.respond_invalid(request)",
            "",
            "        if not helper.valid_request:",
            "            return Response(",
            "                status=status.HTTP_400_BAD_REQUEST,",
            "                data={\"details\": \"unable to accept organization invite\"},",
            "            )",
            "",
            "        if helper.member_already_exists:",
            "            response = Response(",
            "                status=status.HTTP_400_BAD_REQUEST, data={\"details\": \"member already exists\"}",
            "            )",
            "        else:",
            "            response = Response(status=status.HTTP_204_NO_CONTENT)",
            "",
            "        helper.accept_invite()",
            "        remove_invite_cookie(request, response)",
            "",
            "        return response"
        ],
        "afterPatchFile": [
            "from django.urls import reverse",
            "from rest_framework import status",
            "from rest_framework.request import Request",
            "from rest_framework.response import Response",
            "",
            "from sentry.api.base import Endpoint, region_silo_endpoint",
            "from sentry.api.invite_helper import (",
            "    ApiInviteHelper,",
            "    add_invite_details_to_session,",
            "    remove_invite_details_from_session,",
            ")",
            "from sentry.models import AuthProvider, OrganizationMember",
            "from sentry.utils import auth",
            "",
            "",
            "@region_silo_endpoint",
            "class AcceptOrganizationInvite(Endpoint):",
            "    # Disable authentication and permission requirements.",
            "    permission_classes = []",
            "",
            "    @staticmethod",
            "    def respond_invalid() -> Response:",
            "        return Response(status=status.HTTP_400_BAD_REQUEST, data={\"details\": \"Invalid invite code\"})",
            "",
            "    def get_helper(self, request: Request, member_id: int, token: str) -> ApiInviteHelper:",
            "        return ApiInviteHelper(request=request, member_id=member_id, instance=self, token=token)",
            "",
            "    def get(self, request: Request, member_id: int, token: str) -> Response:",
            "        try:",
            "            helper = self.get_helper(request, member_id, token)",
            "        except OrganizationMember.DoesNotExist:",
            "            return self.respond_invalid()",
            "",
            "        organization_member = helper.om",
            "        organization = organization_member.organization",
            "",
            "        if (",
            "            not helper.member_pending",
            "            or not helper.valid_token",
            "            or not organization_member.invite_approved",
            "        ):",
            "            return self.respond_invalid()",
            "",
            "        # Keep track of the invite details in the request session",
            "        request.session[\"invite_email\"] = organization_member.email",
            "",
            "        try:",
            "            auth_provider = AuthProvider.objects.get(organization=organization)",
            "        except AuthProvider.DoesNotExist:",
            "            auth_provider = None",
            "",
            "        data = {",
            "            \"orgSlug\": organization.slug,",
            "            \"needsAuthentication\": not helper.user_authenticated,",
            "            \"needsSso\": auth_provider is not None,",
            "            \"hasAuthProvider\": auth_provider is not None,",
            "            \"requireSso\": auth_provider is not None and not auth_provider.flags.allow_unlinked,",
            "            # If they're already a member of the organization its likely",
            "            # they're using a shared account and either previewing this invite",
            "            # or are incorrectly expecting this to create a new account.",
            "            \"existingMember\": helper.member_already_exists,",
            "        }",
            "",
            "        response = Response(None)",
            "",
            "        # Allow users to register an account when accepting an invite",
            "        if not helper.user_authenticated:",
            "            request.session[\"can_register\"] = True",
            "            add_invite_details_to_session(",
            "                request, organization_member.id, organization_member.token",
            "            )",
            "",
            "            # When SSO is required do *not* set a next_url to return to accept",
            "            # invite. The invite will be accepted after SSO is completed.",
            "            url = (",
            "                reverse(\"sentry-accept-invite\", args=[member_id, token])",
            "                if not auth_provider",
            "                else \"/\"",
            "            )",
            "            auth.initiate_login(self.request, next_url=url)",
            "",
            "        # If the org has SSO setup, we'll store the invite cookie to later",
            "        # associate the org member after authentication. We can avoid needing",
            "        # to come back to the accept invite page since 2FA will *not* be",
            "        # required if SSO is required.",
            "        if auth_provider is not None:",
            "            add_invite_details_to_session(",
            "                request, organization_member.id, organization_member.token",
            "            )",
            "",
            "            provider = auth_provider.get_provider()",
            "            data[\"ssoProvider\"] = provider.name",
            "",
            "        onboarding_steps = helper.get_onboarding_steps()",
            "        data.update(onboarding_steps)",
            "        if any(onboarding_steps.values()):",
            "            add_invite_details_to_session(",
            "                request, organization_member.id, organization_member.token",
            "            )",
            "",
            "        response.data = data",
            "",
            "        return response",
            "",
            "    def post(self, request: Request, member_id: int, token: str) -> Response:",
            "        try:",
            "            helper = self.get_helper(request, member_id, token)",
            "        except OrganizationMember.DoesNotExist:",
            "            return self.respond_invalid()",
            "",
            "        if not helper.valid_request:",
            "            return Response(",
            "                status=status.HTTP_400_BAD_REQUEST,",
            "                data={\"details\": \"unable to accept organization invite\"},",
            "            )",
            "",
            "        if helper.member_already_exists:",
            "            response = Response(",
            "                status=status.HTTP_400_BAD_REQUEST, data={\"details\": \"member already exists\"}",
            "            )",
            "        else:",
            "            response = Response(status=status.HTTP_204_NO_CONTENT)",
            "",
            "        helper.accept_invite()",
            "        remove_invite_details_from_session(request)",
            "",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": [],
            "17": [
                "AcceptOrganizationInvite",
                "respond_invalid"
            ],
            "20": [
                "AcceptOrganizationInvite",
                "get_helper"
            ],
            "23": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "27": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "29": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "30": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "32": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "33": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "35": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "36": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "60": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "76": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "83": [
                "AcceptOrganizationInvite",
                "get"
            ],
            "89": [
                "AcceptOrganizationInvite",
                "post"
            ],
            "93": [
                "AcceptOrganizationInvite",
                "post"
            ],
            "109": [
                "AcceptOrganizationInvite",
                "post"
            ]
        },
        "addLocation": []
    },
    "src/sentry/api/endpoints/user_authenticator_enroll.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from sentry.api.base import control_silo_endpoint"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from sentry.api.bases.user import UserEndpoint"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from sentry.api.decorators import email_verification_required, sudo_required"
            },
            "3": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sentry.api.invite_helper import ApiInviteHelper, remove_invite_cookie"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from sentry.api.invite_helper import ApiInviteHelper, remove_invite_details_from_session"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from sentry.api.serializers import serialize"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from sentry.auth.authenticators.base import EnrollmentStatus, NewEnrollmentDisallowed"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from sentry.auth.authenticators.sms import SMSRateLimitExceeded"
            },
            "8": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "         # If there is a pending organization invite accept after the"
            },
            "10": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         # authenticator has been configured."
            },
            "11": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        invite_helper = ApiInviteHelper.from_cookie(request=request, instance=self, logger=logger)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+        invite_helper = ApiInviteHelper.from_session(request=request, instance=self, logger=logger)"
            },
            "13": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 285,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "         if invite_helper and invite_helper.valid_request:"
            },
            "15": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "             invite_helper.accept_invite()"
            },
            "16": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            remove_invite_cookie(request, response)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+            remove_invite_details_from_session(request)"
            },
            "18": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "         return response"
            }
        },
        "frontPatchFile": [
            "import logging",
            "from base64 import b64encode",
            "",
            "import petname",
            "from django.http import HttpResponse",
            "from rest_framework import serializers, status",
            "from rest_framework.fields import SkipField",
            "from rest_framework.request import Request",
            "from rest_framework.response import Response",
            "",
            "from sentry import ratelimits as ratelimiter",
            "from sentry.api.base import control_silo_endpoint",
            "from sentry.api.bases.user import UserEndpoint",
            "from sentry.api.decorators import email_verification_required, sudo_required",
            "from sentry.api.invite_helper import ApiInviteHelper, remove_invite_cookie",
            "from sentry.api.serializers import serialize",
            "from sentry.auth.authenticators.base import EnrollmentStatus, NewEnrollmentDisallowed",
            "from sentry.auth.authenticators.sms import SMSRateLimitExceeded",
            "from sentry.models import Authenticator",
            "from sentry.security import capture_security_activity",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "ALREADY_ENROLLED_ERR = {\"details\": \"Already enrolled\"}",
            "INVALID_OTP_ERR = ({\"details\": \"Invalid OTP\"},)",
            "SEND_SMS_ERR = {\"details\": \"Error sending SMS\"}",
            "DISALLOWED_NEW_ENROLLMENT_ERR = {",
            "    \"details\": \"New enrollments for this 2FA interface are not allowed\"",
            "}",
            "",
            "",
            "class TotpRestSerializer(serializers.Serializer):",
            "    otp = serializers.CharField(",
            "        label=\"Authenticator token\",",
            "        help_text=\"Code from authenticator\",",
            "        required=True,",
            "        max_length=20,",
            "        trim_whitespace=False,",
            "    )",
            "",
            "",
            "class SmsRestSerializer(serializers.Serializer):",
            "    phone = serializers.CharField(",
            "        label=\"Phone number\",",
            "        help_text=\"Phone number to send SMS code\",",
            "        required=True,",
            "        max_length=20,",
            "        trim_whitespace=False,",
            "    )",
            "    otp = serializers.CharField(",
            "        label=\"Authenticator code\",",
            "        help_text=\"Code from authenticator\",",
            "        required=False,",
            "        allow_null=True,",
            "        allow_blank=True,",
            "        max_length=20,",
            "        trim_whitespace=False,",
            "    )",
            "",
            "",
            "class U2fRestSerializer(serializers.Serializer):",
            "    deviceName = serializers.CharField(",
            "        label=\"Device name\",",
            "        required=False,",
            "        allow_null=True,",
            "        allow_blank=True,",
            "        max_length=60,",
            "        trim_whitespace=False,",
            "        default=lambda: petname.Generate(2, \" \", letters=10).title(),",
            "    )",
            "    challenge = serializers.CharField(required=True, trim_whitespace=False)",
            "    response = serializers.CharField(required=True, trim_whitespace=False)",
            "",
            "",
            "serializer_map = {\"totp\": TotpRestSerializer, \"sms\": SmsRestSerializer, \"u2f\": U2fRestSerializer}",
            "",
            "",
            "def get_serializer_field_metadata(serializer, fields=None):",
            "    \"\"\"Returns field metadata for serializer\"\"\"",
            "    meta = []",
            "    for field_name, field in serializer.fields.items():",
            "        if (fields is None or field_name in fields) and field_name:",
            "            try:",
            "                default = field.get_default()",
            "            except SkipField:",
            "                default = None",
            "            serialized_field = {",
            "                \"name\": field_name,",
            "                \"defaultValue\": default,",
            "                \"read_only\": field.read_only,",
            "                \"required\": field.required,",
            "                \"type\": \"string\",",
            "            }",
            "            if hasattr(field, \"max_length\") and field.max_length:",
            "                serialized_field[\"max_length\"] = field.max_length",
            "            if field.label:",
            "                serialized_field[\"label\"] = field.label",
            "",
            "            meta.append(serialized_field)",
            "",
            "    return meta",
            "",
            "",
            "@control_silo_endpoint",
            "class UserAuthenticatorEnrollEndpoint(UserEndpoint):",
            "    @sudo_required",
            "    def get(self, request: Request, user, interface_id) -> Response:",
            "        \"\"\"",
            "        Get Authenticator Interface",
            "        ```````````````````````````",
            "",
            "        Retrieves authenticator interface details for user depending on user enrollment status",
            "",
            "        :pparam string user_id: user id or \"me\" for current user",
            "        :pparam string interface_id: interface id",
            "",
            "        :auth: required",
            "        \"\"\"",
            "",
            "        interface = Authenticator.objects.get_interface(user, interface_id)",
            "",
            "        if interface.is_enrolled():",
            "            # Not all interfaces allow multi enrollment",
            "            if interface.allow_multi_enrollment:",
            "                interface.status = EnrollmentStatus.MULTI",
            "            elif interface.allow_rotation_in_place:",
            "                # The new interface object returns False from",
            "                # interface.is_enrolled(), which is misleading.",
            "                # The status attribute can disambiguate where necessary.",
            "                interface = interface.generate(EnrollmentStatus.ROTATION)",
            "            else:",
            "                return Response(ALREADY_ENROLLED_ERR, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "        # User is not enrolled in auth interface:",
            "        # - display configuration form",
            "        response = serialize(interface)",
            "        response[\"form\"] = get_serializer_field_metadata(serializer_map[interface_id]())",
            "",
            "        # U2fInterface has no 'secret' attribute",
            "        try:",
            "            response[\"secret\"] = interface.secret",
            "        except AttributeError:",
            "            pass",
            "",
            "        if interface_id == \"totp\":",
            "            response[\"qrcode\"] = interface.get_provision_url(user.email)",
            "",
            "        if interface_id == \"u2f\":",
            "            publicKeyCredentialCreate, state = interface.start_enrollment(user)",
            "            response[\"challenge\"] = {}",
            "            response[\"challenge\"][\"webAuthnRegisterData\"] = b64encode(publicKeyCredentialCreate)",
            "            request.session[\"webauthn_register_state\"] = state",
            "        return Response(response)",
            "",
            "    @sudo_required",
            "    @email_verification_required",
            "    def post(self, request: Request, user, interface_id) -> Response:",
            "        \"\"\"",
            "        Enroll in authenticator interface",
            "        `````````````````````````````````",
            "",
            "        :pparam string user_id: user id or \"me\" for current user",
            "        :pparam string interface_id: interface id",
            "",
            "        :auth: required",
            "        \"\"\"",
            "        if ratelimiter.is_limited(",
            "            f\"auth:authenticator-enroll:{request.user.id}:{interface_id}\",",
            "            limit=10,",
            "            window=86400,  # 10 per day should be fine",
            "        ):",
            "            return HttpResponse(",
            "                \"You have made too many authenticator enrollment attempts. Please try again later.\",",
            "                content_type=\"text/plain\",",
            "                status=429,",
            "            )",
            "",
            "        # Using `request.user` here because superuser should not be able to set a user's 2fa",
            "",
            "        # start activation",
            "        serializer_cls = serializer_map.get(interface_id, None)",
            "",
            "        if serializer_cls is None:",
            "            return Response(status=status.HTTP_404_NOT_FOUND)",
            "",
            "        serializer = serializer_cls(data=request.data)",
            "",
            "        if not serializer.is_valid():",
            "            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "        interface = Authenticator.objects.get_interface(request.user, interface_id)",
            "",
            "        # Check if the 2FA interface allows new enrollment, if not we should error",
            "        # on any POSTs",
            "        if interface.disallow_new_enrollment:",
            "            return Response(DISALLOWED_NEW_ENROLLMENT_ERR, status=status.HTTP_403_FORBIDDEN)",
            "",
            "        # Not all interfaces allow multi enrollment",
            "        #",
            "        # This is probably un-needed because we catch",
            "        # `Authenticator.AlreadyEnrolled` when attempting to enroll",
            "        if interface.is_enrolled():",
            "            if interface.allow_multi_enrollment:",
            "                interface.status = EnrollmentStatus.MULTI",
            "            elif interface.allow_rotation_in_place:",
            "                interface.status = EnrollmentStatus.ROTATION",
            "            else:",
            "                return Response(ALREADY_ENROLLED_ERR, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "        try:",
            "            interface.secret = request.data[\"secret\"]",
            "        except KeyError:",
            "            pass",
            "",
            "        context = {}",
            "        # Need to update interface with phone number before validating OTP",
            "        if \"phone\" in request.data:",
            "            interface.phone_number = serializer.data[\"phone\"]",
            "",
            "            # Disregarding value of 'otp', if no OTP was provided,",
            "            # send text message to phone number with OTP",
            "            if \"otp\" not in request.data:",
            "                try:",
            "                    if interface.send_text(for_enrollment=True, request=request._request):",
            "                        return Response(status=status.HTTP_204_NO_CONTENT)",
            "                    else:",
            "                        # Error sending text message",
            "                        return Response(SEND_SMS_ERR, status=status.HTTP_500_INTERNAL_SERVER_ERROR)",
            "                except SMSRateLimitExceeded as e:",
            "                    logger.warning(",
            "                        \"auth-enroll.sms.rate-limit-exceeded\",",
            "                        extra={",
            "                            \"remote_ip\": f\"{e.remote_ip}\",",
            "                            \"user_id\": f\"{e.user_id}\",",
            "                            \"phone_number\": f\"{e.phone_number}\",",
            "                        },",
            "                    )",
            "                    return Response(SEND_SMS_ERR, status=status.HTTP_429_TOO_MANY_REQUESTS)",
            "",
            "        # Attempt to validate OTP",
            "        if \"otp\" in request.data and not interface.validate_otp(serializer.data[\"otp\"]):",
            "            return Response(INVALID_OTP_ERR, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "        # Try u2f enrollment",
            "        if interface_id == \"u2f\":",
            "            # What happens when this fails?",
            "            state = request.session[\"webauthn_register_state\"]",
            "            interface.try_enroll(",
            "                serializer.data[\"challenge\"],",
            "                serializer.data[\"response\"],",
            "                serializer.data[\"deviceName\"],",
            "                state,",
            "            )",
            "            context.update({\"device_name\": serializer.data[\"deviceName\"]})",
            "",
            "        if interface.status == EnrollmentStatus.ROTATION:",
            "            interface.rotate_in_place()",
            "        else:",
            "            try:",
            "                interface.enroll(request.user)",
            "            except Authenticator.AlreadyEnrolled:",
            "                return Response(ALREADY_ENROLLED_ERR, status=status.HTTP_400_BAD_REQUEST)",
            "            except NewEnrollmentDisallowed:",
            "                return Response(DISALLOWED_NEW_ENROLLMENT_ERR, status=status.HTTP_403_FORBIDDEN)",
            "",
            "        context.update({\"authenticator\": interface.authenticator})",
            "        capture_security_activity(",
            "            account=request.user,",
            "            type=\"mfa-added\",",
            "            actor=request.user,",
            "            ip_address=request.META[\"REMOTE_ADDR\"],",
            "            context=context,",
            "            send_email=True,",
            "        )",
            "        request.user.clear_lost_passwords()",
            "        request.user.refresh_session_nonce(self.request)",
            "        request.user.save()",
            "        Authenticator.objects.auto_add_recovery_codes(request.user)",
            "",
            "        response = Response(status=status.HTTP_204_NO_CONTENT)",
            "",
            "        # If there is a pending organization invite accept after the",
            "        # authenticator has been configured.",
            "        invite_helper = ApiInviteHelper.from_cookie(request=request, instance=self, logger=logger)",
            "",
            "        if invite_helper and invite_helper.valid_request:",
            "            invite_helper.accept_invite()",
            "            remove_invite_cookie(request, response)",
            "",
            "        return response"
        ],
        "afterPatchFile": [
            "import logging",
            "from base64 import b64encode",
            "",
            "import petname",
            "from django.http import HttpResponse",
            "from rest_framework import serializers, status",
            "from rest_framework.fields import SkipField",
            "from rest_framework.request import Request",
            "from rest_framework.response import Response",
            "",
            "from sentry import ratelimits as ratelimiter",
            "from sentry.api.base import control_silo_endpoint",
            "from sentry.api.bases.user import UserEndpoint",
            "from sentry.api.decorators import email_verification_required, sudo_required",
            "from sentry.api.invite_helper import ApiInviteHelper, remove_invite_details_from_session",
            "from sentry.api.serializers import serialize",
            "from sentry.auth.authenticators.base import EnrollmentStatus, NewEnrollmentDisallowed",
            "from sentry.auth.authenticators.sms import SMSRateLimitExceeded",
            "from sentry.models import Authenticator",
            "from sentry.security import capture_security_activity",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "ALREADY_ENROLLED_ERR = {\"details\": \"Already enrolled\"}",
            "INVALID_OTP_ERR = ({\"details\": \"Invalid OTP\"},)",
            "SEND_SMS_ERR = {\"details\": \"Error sending SMS\"}",
            "DISALLOWED_NEW_ENROLLMENT_ERR = {",
            "    \"details\": \"New enrollments for this 2FA interface are not allowed\"",
            "}",
            "",
            "",
            "class TotpRestSerializer(serializers.Serializer):",
            "    otp = serializers.CharField(",
            "        label=\"Authenticator token\",",
            "        help_text=\"Code from authenticator\",",
            "        required=True,",
            "        max_length=20,",
            "        trim_whitespace=False,",
            "    )",
            "",
            "",
            "class SmsRestSerializer(serializers.Serializer):",
            "    phone = serializers.CharField(",
            "        label=\"Phone number\",",
            "        help_text=\"Phone number to send SMS code\",",
            "        required=True,",
            "        max_length=20,",
            "        trim_whitespace=False,",
            "    )",
            "    otp = serializers.CharField(",
            "        label=\"Authenticator code\",",
            "        help_text=\"Code from authenticator\",",
            "        required=False,",
            "        allow_null=True,",
            "        allow_blank=True,",
            "        max_length=20,",
            "        trim_whitespace=False,",
            "    )",
            "",
            "",
            "class U2fRestSerializer(serializers.Serializer):",
            "    deviceName = serializers.CharField(",
            "        label=\"Device name\",",
            "        required=False,",
            "        allow_null=True,",
            "        allow_blank=True,",
            "        max_length=60,",
            "        trim_whitespace=False,",
            "        default=lambda: petname.Generate(2, \" \", letters=10).title(),",
            "    )",
            "    challenge = serializers.CharField(required=True, trim_whitespace=False)",
            "    response = serializers.CharField(required=True, trim_whitespace=False)",
            "",
            "",
            "serializer_map = {\"totp\": TotpRestSerializer, \"sms\": SmsRestSerializer, \"u2f\": U2fRestSerializer}",
            "",
            "",
            "def get_serializer_field_metadata(serializer, fields=None):",
            "    \"\"\"Returns field metadata for serializer\"\"\"",
            "    meta = []",
            "    for field_name, field in serializer.fields.items():",
            "        if (fields is None or field_name in fields) and field_name:",
            "            try:",
            "                default = field.get_default()",
            "            except SkipField:",
            "                default = None",
            "            serialized_field = {",
            "                \"name\": field_name,",
            "                \"defaultValue\": default,",
            "                \"read_only\": field.read_only,",
            "                \"required\": field.required,",
            "                \"type\": \"string\",",
            "            }",
            "            if hasattr(field, \"max_length\") and field.max_length:",
            "                serialized_field[\"max_length\"] = field.max_length",
            "            if field.label:",
            "                serialized_field[\"label\"] = field.label",
            "",
            "            meta.append(serialized_field)",
            "",
            "    return meta",
            "",
            "",
            "@control_silo_endpoint",
            "class UserAuthenticatorEnrollEndpoint(UserEndpoint):",
            "    @sudo_required",
            "    def get(self, request: Request, user, interface_id) -> Response:",
            "        \"\"\"",
            "        Get Authenticator Interface",
            "        ```````````````````````````",
            "",
            "        Retrieves authenticator interface details for user depending on user enrollment status",
            "",
            "        :pparam string user_id: user id or \"me\" for current user",
            "        :pparam string interface_id: interface id",
            "",
            "        :auth: required",
            "        \"\"\"",
            "",
            "        interface = Authenticator.objects.get_interface(user, interface_id)",
            "",
            "        if interface.is_enrolled():",
            "            # Not all interfaces allow multi enrollment",
            "            if interface.allow_multi_enrollment:",
            "                interface.status = EnrollmentStatus.MULTI",
            "            elif interface.allow_rotation_in_place:",
            "                # The new interface object returns False from",
            "                # interface.is_enrolled(), which is misleading.",
            "                # The status attribute can disambiguate where necessary.",
            "                interface = interface.generate(EnrollmentStatus.ROTATION)",
            "            else:",
            "                return Response(ALREADY_ENROLLED_ERR, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "        # User is not enrolled in auth interface:",
            "        # - display configuration form",
            "        response = serialize(interface)",
            "        response[\"form\"] = get_serializer_field_metadata(serializer_map[interface_id]())",
            "",
            "        # U2fInterface has no 'secret' attribute",
            "        try:",
            "            response[\"secret\"] = interface.secret",
            "        except AttributeError:",
            "            pass",
            "",
            "        if interface_id == \"totp\":",
            "            response[\"qrcode\"] = interface.get_provision_url(user.email)",
            "",
            "        if interface_id == \"u2f\":",
            "            publicKeyCredentialCreate, state = interface.start_enrollment(user)",
            "            response[\"challenge\"] = {}",
            "            response[\"challenge\"][\"webAuthnRegisterData\"] = b64encode(publicKeyCredentialCreate)",
            "            request.session[\"webauthn_register_state\"] = state",
            "        return Response(response)",
            "",
            "    @sudo_required",
            "    @email_verification_required",
            "    def post(self, request: Request, user, interface_id) -> Response:",
            "        \"\"\"",
            "        Enroll in authenticator interface",
            "        `````````````````````````````````",
            "",
            "        :pparam string user_id: user id or \"me\" for current user",
            "        :pparam string interface_id: interface id",
            "",
            "        :auth: required",
            "        \"\"\"",
            "        if ratelimiter.is_limited(",
            "            f\"auth:authenticator-enroll:{request.user.id}:{interface_id}\",",
            "            limit=10,",
            "            window=86400,  # 10 per day should be fine",
            "        ):",
            "            return HttpResponse(",
            "                \"You have made too many authenticator enrollment attempts. Please try again later.\",",
            "                content_type=\"text/plain\",",
            "                status=429,",
            "            )",
            "",
            "        # Using `request.user` here because superuser should not be able to set a user's 2fa",
            "",
            "        # start activation",
            "        serializer_cls = serializer_map.get(interface_id, None)",
            "",
            "        if serializer_cls is None:",
            "            return Response(status=status.HTTP_404_NOT_FOUND)",
            "",
            "        serializer = serializer_cls(data=request.data)",
            "",
            "        if not serializer.is_valid():",
            "            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "        interface = Authenticator.objects.get_interface(request.user, interface_id)",
            "",
            "        # Check if the 2FA interface allows new enrollment, if not we should error",
            "        # on any POSTs",
            "        if interface.disallow_new_enrollment:",
            "            return Response(DISALLOWED_NEW_ENROLLMENT_ERR, status=status.HTTP_403_FORBIDDEN)",
            "",
            "        # Not all interfaces allow multi enrollment",
            "        #",
            "        # This is probably un-needed because we catch",
            "        # `Authenticator.AlreadyEnrolled` when attempting to enroll",
            "        if interface.is_enrolled():",
            "            if interface.allow_multi_enrollment:",
            "                interface.status = EnrollmentStatus.MULTI",
            "            elif interface.allow_rotation_in_place:",
            "                interface.status = EnrollmentStatus.ROTATION",
            "            else:",
            "                return Response(ALREADY_ENROLLED_ERR, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "        try:",
            "            interface.secret = request.data[\"secret\"]",
            "        except KeyError:",
            "            pass",
            "",
            "        context = {}",
            "        # Need to update interface with phone number before validating OTP",
            "        if \"phone\" in request.data:",
            "            interface.phone_number = serializer.data[\"phone\"]",
            "",
            "            # Disregarding value of 'otp', if no OTP was provided,",
            "            # send text message to phone number with OTP",
            "            if \"otp\" not in request.data:",
            "                try:",
            "                    if interface.send_text(for_enrollment=True, request=request._request):",
            "                        return Response(status=status.HTTP_204_NO_CONTENT)",
            "                    else:",
            "                        # Error sending text message",
            "                        return Response(SEND_SMS_ERR, status=status.HTTP_500_INTERNAL_SERVER_ERROR)",
            "                except SMSRateLimitExceeded as e:",
            "                    logger.warning(",
            "                        \"auth-enroll.sms.rate-limit-exceeded\",",
            "                        extra={",
            "                            \"remote_ip\": f\"{e.remote_ip}\",",
            "                            \"user_id\": f\"{e.user_id}\",",
            "                            \"phone_number\": f\"{e.phone_number}\",",
            "                        },",
            "                    )",
            "                    return Response(SEND_SMS_ERR, status=status.HTTP_429_TOO_MANY_REQUESTS)",
            "",
            "        # Attempt to validate OTP",
            "        if \"otp\" in request.data and not interface.validate_otp(serializer.data[\"otp\"]):",
            "            return Response(INVALID_OTP_ERR, status=status.HTTP_400_BAD_REQUEST)",
            "",
            "        # Try u2f enrollment",
            "        if interface_id == \"u2f\":",
            "            # What happens when this fails?",
            "            state = request.session[\"webauthn_register_state\"]",
            "            interface.try_enroll(",
            "                serializer.data[\"challenge\"],",
            "                serializer.data[\"response\"],",
            "                serializer.data[\"deviceName\"],",
            "                state,",
            "            )",
            "            context.update({\"device_name\": serializer.data[\"deviceName\"]})",
            "",
            "        if interface.status == EnrollmentStatus.ROTATION:",
            "            interface.rotate_in_place()",
            "        else:",
            "            try:",
            "                interface.enroll(request.user)",
            "            except Authenticator.AlreadyEnrolled:",
            "                return Response(ALREADY_ENROLLED_ERR, status=status.HTTP_400_BAD_REQUEST)",
            "            except NewEnrollmentDisallowed:",
            "                return Response(DISALLOWED_NEW_ENROLLMENT_ERR, status=status.HTTP_403_FORBIDDEN)",
            "",
            "        context.update({\"authenticator\": interface.authenticator})",
            "        capture_security_activity(",
            "            account=request.user,",
            "            type=\"mfa-added\",",
            "            actor=request.user,",
            "            ip_address=request.META[\"REMOTE_ADDR\"],",
            "            context=context,",
            "            send_email=True,",
            "        )",
            "        request.user.clear_lost_passwords()",
            "        request.user.refresh_session_nonce(self.request)",
            "        request.user.save()",
            "        Authenticator.objects.auto_add_recovery_codes(request.user)",
            "",
            "        response = Response(status=status.HTTP_204_NO_CONTENT)",
            "",
            "        # If there is a pending organization invite accept after the",
            "        # authenticator has been configured.",
            "        invite_helper = ApiInviteHelper.from_session(request=request, instance=self, logger=logger)",
            "",
            "        if invite_helper and invite_helper.valid_request:",
            "            invite_helper.accept_invite()",
            "            remove_invite_details_from_session(request)",
            "",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "284": [
                "UserAuthenticatorEnrollEndpoint",
                "post"
            ],
            "288": [
                "UserAuthenticatorEnrollEndpoint",
                "post"
            ]
        },
        "addLocation": []
    },
    "src/sentry/api/invite_helper.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Dict"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from urllib.parse import parse_qsl, urlencode"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from typing import Dict, Tuple"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.urls import reverse"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from django.utils.crypto import constant_time_compare"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from rest_framework.request import Request"
            },
            "7": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from sentry import audit_log, features"
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from sentry.models import ("
            },
            "10": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from sentry.utils import metrics"
            },
            "11": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from sentry.utils.audit import create_audit_entry"
            },
            "12": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-INVITE_COOKIE = \"pending-invite\""
            },
            "14": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-COOKIE_MAX_AGE = 60 * 60 * 24 * 7  # 7 days"
            },
            "15": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+def add_invite_details_to_session(request: Request, member_id: int, token: str):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    \"\"\"Add member ID and token to the request session\"\"\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    request.session[\"invite_token\"] = token"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    request.session[\"invite_member_id\"] = member_id"
            },
            "20": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def add_invite_cookie(request, response, member_id, token):"
            },
            "22": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    url = reverse(\"sentry-accept-invite\", args=[member_id, token])"
            },
            "23": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    response.set_cookie("
            },
            "24": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        INVITE_COOKIE,"
            },
            "25": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        urlencode({\"memberId\": member_id, \"token\": token, \"url\": url}),"
            },
            "26": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        max_age=COOKIE_MAX_AGE,"
            },
            "27": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    )"
            },
            "28": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+def remove_invite_details_from_session(request):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    \"\"\"Deletes invite details from the request session\"\"\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    request.session.pop(\"invite_member_id\", None)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    request.session.pop(\"invite_token\", None)"
            },
            "33": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def remove_invite_cookie(request, response):"
            },
            "35": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if INVITE_COOKIE in request.COOKIES:"
            },
            "36": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        response.delete_cookie(INVITE_COOKIE)"
            },
            "37": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "39": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def get_invite_cookie(request):"
            },
            "40": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if INVITE_COOKIE not in request.COOKIES:"
            },
            "41": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return None"
            },
            "42": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "43": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # memberId should be coerced back to an integer"
            },
            "44": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    invite_data = dict(parse_qsl(request.COOKIES.get(INVITE_COOKIE)))"
            },
            "45": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    invite_data[\"memberId\"] = int(invite_data[\"memberId\"])"
            },
            "46": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "47": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return invite_data"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+def get_invite_details(request) -> Tuple[str, int]:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    \"\"\"Returns tuple of (token, member_id) from request session\"\"\""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    return request.session.get(\"invite_token\", None), request.session.get(\"invite_member_id\", None)"
            },
            "51": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " class ApiInviteHelper:"
            },
            "54": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     @classmethod"
            },
            "55": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def from_cookie_or_email(cls, request, organization, email, instance=None, logger=None):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    def from_session_or_email(cls, request, organization, email, instance=None, logger=None):"
            },
            "57": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         \"\"\""
            },
            "58": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         Initializes the ApiInviteHelper by locating the pending organization"
            },
            "59": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        member via the currently set pending invite cookie, or via the passed"
            },
            "60": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        email if no cookie is currently set."
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        member via the currently set pending invite details in the session, or"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        via the passed email if no cookie is currently set."
            },
            "63": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         \"\"\""
            },
            "64": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pending_invite = get_invite_cookie(request)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        invite_token, invite_member_id = get_invite_details(request)"
            },
            "66": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         try:"
            },
            "68": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if pending_invite is not None:"
            },
            "69": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                om = OrganizationMember.objects.get("
            },
            "70": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    id=pending_invite[\"memberId\"], token=pending_invite[\"token\"]"
            },
            "71": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            if invite_token and invite_member_id:"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                om = OrganizationMember.objects.get(token=invite_token, id=invite_member_id)"
            },
            "74": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             else:"
            },
            "75": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                 om = OrganizationMember.objects.get("
            },
            "76": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                     email=email, organization=organization, user=None"
            },
            "77": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         )"
            },
            "78": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     @classmethod"
            },
            "80": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def from_cookie(cls, request, instance=None, logger=None):"
            },
            "81": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        org_invite = get_invite_cookie(request)"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    def from_session(cls, request, instance=None, logger=None):"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        invite_token, invite_member_id = get_invite_details(request)"
            },
            "84": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "85": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not org_invite:"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        if not invite_token or not invite_member_id:"
            },
            "87": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "             return None"
            },
            "88": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "89": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         try:"
            },
            "90": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             return ApiInviteHelper("
            },
            "91": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "                 request=request,"
            },
            "92": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                member_id=org_invite[\"memberId\"],"
            },
            "93": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                token=org_invite[\"token\"],"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                member_id=invite_member_id,"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                token=invite_token,"
            },
            "96": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "                 instance=instance,"
            },
            "97": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "                 logger=logger,"
            },
            "98": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "             )"
            },
            "99": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "             return None"
            },
            "100": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "101": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     def __init__(self, request, member_id, token, instance=None, logger=None):"
            },
            "102": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.request = request"
            },
            "103": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.member_id = member_id"
            },
            "104": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.token = token"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        self.request: Request = request"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        self.member_id: int = member_id"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        self.token: str = token"
            },
            "108": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         self.instance = instance"
            },
            "109": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         self.logger = logger"
            },
            "110": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.om = self.organization_member"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        self.om: OrganizationMember = self.organization_member"
            },
            "112": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "113": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     def handle_success(self):"
            },
            "114": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         member_joined.send_robust("
            },
            "115": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "             self.om.delete()"
            },
            "116": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " "
            },
            "117": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     @property"
            },
            "118": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def organization_member(self):"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    def organization_member(self) -> OrganizationMember:"
            },
            "120": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         return OrganizationMember.objects.select_related(\"organization\").get(pk=self.member_id)"
            },
            "121": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "122": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     @property"
            }
        },
        "frontPatchFile": [
            "from typing import Dict",
            "from urllib.parse import parse_qsl, urlencode",
            "",
            "from django.urls import reverse",
            "from django.utils.crypto import constant_time_compare",
            "",
            "from sentry import audit_log, features",
            "from sentry.models import (",
            "    Authenticator,",
            "    AuthIdentity,",
            "    AuthProvider,",
            "    OrganizationMember,",
            "    User,",
            "    UserEmail,",
            ")",
            "from sentry.signals import member_joined",
            "from sentry.utils import metrics",
            "from sentry.utils.audit import create_audit_entry",
            "",
            "INVITE_COOKIE = \"pending-invite\"",
            "COOKIE_MAX_AGE = 60 * 60 * 24 * 7  # 7 days",
            "",
            "",
            "def add_invite_cookie(request, response, member_id, token):",
            "    url = reverse(\"sentry-accept-invite\", args=[member_id, token])",
            "    response.set_cookie(",
            "        INVITE_COOKIE,",
            "        urlencode({\"memberId\": member_id, \"token\": token, \"url\": url}),",
            "        max_age=COOKIE_MAX_AGE,",
            "    )",
            "",
            "",
            "def remove_invite_cookie(request, response):",
            "    if INVITE_COOKIE in request.COOKIES:",
            "        response.delete_cookie(INVITE_COOKIE)",
            "",
            "",
            "def get_invite_cookie(request):",
            "    if INVITE_COOKIE not in request.COOKIES:",
            "        return None",
            "",
            "    # memberId should be coerced back to an integer",
            "    invite_data = dict(parse_qsl(request.COOKIES.get(INVITE_COOKIE)))",
            "    invite_data[\"memberId\"] = int(invite_data[\"memberId\"])",
            "",
            "    return invite_data",
            "",
            "",
            "class ApiInviteHelper:",
            "    @classmethod",
            "    def from_cookie_or_email(cls, request, organization, email, instance=None, logger=None):",
            "        \"\"\"",
            "        Initializes the ApiInviteHelper by locating the pending organization",
            "        member via the currently set pending invite cookie, or via the passed",
            "        email if no cookie is currently set.",
            "        \"\"\"",
            "        pending_invite = get_invite_cookie(request)",
            "",
            "        try:",
            "            if pending_invite is not None:",
            "                om = OrganizationMember.objects.get(",
            "                    id=pending_invite[\"memberId\"], token=pending_invite[\"token\"]",
            "                )",
            "            else:",
            "                om = OrganizationMember.objects.get(",
            "                    email=email, organization=organization, user=None",
            "                )",
            "        except OrganizationMember.DoesNotExist:",
            "            # Unable to locate the pending organization member. Cannot setup",
            "            # the invite helper.",
            "            return None",
            "",
            "        return cls(",
            "            request=request, member_id=om.id, token=om.token, instance=instance, logger=logger",
            "        )",
            "",
            "    @classmethod",
            "    def from_cookie(cls, request, instance=None, logger=None):",
            "        org_invite = get_invite_cookie(request)",
            "",
            "        if not org_invite:",
            "            return None",
            "",
            "        try:",
            "            return ApiInviteHelper(",
            "                request=request,",
            "                member_id=org_invite[\"memberId\"],",
            "                token=org_invite[\"token\"],",
            "                instance=instance,",
            "                logger=logger,",
            "            )",
            "        except OrganizationMember.DoesNotExist:",
            "            if logger:",
            "                logger.error(\"Invalid pending invite cookie\", exc_info=True)",
            "            return None",
            "",
            "    def __init__(self, request, member_id, token, instance=None, logger=None):",
            "        self.request = request",
            "        self.member_id = member_id",
            "        self.token = token",
            "        self.instance = instance",
            "        self.logger = logger",
            "        self.om = self.organization_member",
            "",
            "    def handle_success(self):",
            "        member_joined.send_robust(",
            "            member=self.om,",
            "            organization=self.om.organization,",
            "            sender=self.instance if self.instance else self,",
            "        )",
            "",
            "    def handle_member_already_exists(self):",
            "        if self.logger:",
            "            self.logger.info(",
            "                \"Pending org invite not accepted - User already org member\",",
            "                extra={\"organization_id\": self.om.organization.id, \"user_id\": self.request.user.id},",
            "            )",
            "",
            "    def handle_member_has_no_sso(self):",
            "        if self.logger:",
            "            self.logger.info(",
            "                \"Pending org invite not accepted - User did not have SSO\",",
            "                extra={\"organization_id\": self.om.organization.id, \"user_id\": self.request.user.id},",
            "            )",
            "",
            "    def handle_invite_not_approved(self):",
            "        if not self.invite_approved:",
            "            self.om.delete()",
            "",
            "    @property",
            "    def organization_member(self):",
            "        return OrganizationMember.objects.select_related(\"organization\").get(pk=self.member_id)",
            "",
            "    @property",
            "    def member_pending(self):",
            "        return self.om.is_pending",
            "",
            "    @property",
            "    def invite_approved(self):",
            "        return self.om.invite_approved",
            "",
            "    @property",
            "    def valid_token(self):",
            "        if self.token is None:",
            "            return False",
            "        if self.om.token_expired:",
            "            return False",
            "        return constant_time_compare(self.om.token or self.om.legacy_token, self.token)",
            "",
            "    @property",
            "    def user_authenticated(self):",
            "        return self.request.user.is_authenticated",
            "",
            "    @property",
            "    def member_already_exists(self):",
            "        if not self.user_authenticated:",
            "            return False",
            "",
            "        return OrganizationMember.objects.filter(",
            "            organization=self.om.organization, user=self.request.user",
            "        ).exists()",
            "",
            "    @property",
            "    def valid_request(self):",
            "        return (",
            "            self.member_pending",
            "            and self.invite_approved",
            "            and self.valid_token",
            "            and self.user_authenticated",
            "            and not any(self.get_onboarding_steps().values())",
            "        )",
            "",
            "    def accept_invite(self, user=None):",
            "        om = self.om",
            "",
            "        if user is None:",
            "            user = self.request.user",
            "",
            "        if self.member_already_exists:",
            "            self.handle_member_already_exists()",
            "            om.delete()",
            "            return",
            "",
            "        try:",
            "            provider = AuthProvider.objects.get(organization=om.organization)",
            "        except AuthProvider.DoesNotExist:",
            "            provider = None",
            "",
            "        # If SSO is required, check for valid AuthIdentity",
            "        if provider and not provider.flags.allow_unlinked:",
            "            # AuthIdentity has a unique constraint on provider and user",
            "            if not AuthIdentity.objects.filter(auth_provider=provider, user=user).exists():",
            "                self.handle_member_has_no_sso()",
            "                return",
            "",
            "        om.set_user(user)",
            "        om.save()",
            "",
            "        create_audit_entry(",
            "            self.request,",
            "            actor=user,",
            "            organization=om.organization,",
            "            target_object=om.id,",
            "            target_user=user,",
            "            event=audit_log.get_event_id(\"MEMBER_ACCEPT\"),",
            "            data=om.get_audit_log_data(),",
            "        )",
            "",
            "        self.handle_success()",
            "        metrics.incr(\"organization.invite-accepted\", sample_rate=1.0)",
            "",
            "        return om",
            "",
            "    def _needs_2fa(self) -> bool:",
            "        org_requires_2fa = self.om.organization.flags.require_2fa.is_set",
            "        user_has_2fa = Authenticator.objects.user_has_2fa(self.request.user.id)",
            "        return org_requires_2fa and not user_has_2fa",
            "",
            "    def _needs_email_verification(self) -> bool:",
            "        organization = self.om.organization",
            "        if not (",
            "            features.has(\"organizations:required-email-verification\", organization)",
            "            and organization.flags.require_email_verification",
            "        ):",
            "            return False",
            "",
            "        user = self.request.user",
            "        primary_email_is_verified = (",
            "            isinstance(user, User) and UserEmail.objects.get_primary_email(user).is_verified",
            "        )",
            "        return not primary_email_is_verified",
            "",
            "    def get_onboarding_steps(self) -> Dict[str, bool]:",
            "        return {",
            "            \"needs2fa\": self._needs_2fa(),",
            "            \"needsEmailVerification\": self._needs_email_verification(),",
            "        }"
        ],
        "afterPatchFile": [
            "from typing import Dict, Tuple",
            "",
            "from django.utils.crypto import constant_time_compare",
            "from rest_framework.request import Request",
            "",
            "from sentry import audit_log, features",
            "from sentry.models import (",
            "    Authenticator,",
            "    AuthIdentity,",
            "    AuthProvider,",
            "    OrganizationMember,",
            "    User,",
            "    UserEmail,",
            ")",
            "from sentry.signals import member_joined",
            "from sentry.utils import metrics",
            "from sentry.utils.audit import create_audit_entry",
            "",
            "",
            "def add_invite_details_to_session(request: Request, member_id: int, token: str):",
            "    \"\"\"Add member ID and token to the request session\"\"\"",
            "    request.session[\"invite_token\"] = token",
            "    request.session[\"invite_member_id\"] = member_id",
            "",
            "",
            "def remove_invite_details_from_session(request):",
            "    \"\"\"Deletes invite details from the request session\"\"\"",
            "    request.session.pop(\"invite_member_id\", None)",
            "    request.session.pop(\"invite_token\", None)",
            "",
            "",
            "def get_invite_details(request) -> Tuple[str, int]:",
            "    \"\"\"Returns tuple of (token, member_id) from request session\"\"\"",
            "    return request.session.get(\"invite_token\", None), request.session.get(\"invite_member_id\", None)",
            "",
            "",
            "class ApiInviteHelper:",
            "    @classmethod",
            "    def from_session_or_email(cls, request, organization, email, instance=None, logger=None):",
            "        \"\"\"",
            "        Initializes the ApiInviteHelper by locating the pending organization",
            "        member via the currently set pending invite details in the session, or",
            "        via the passed email if no cookie is currently set.",
            "        \"\"\"",
            "        invite_token, invite_member_id = get_invite_details(request)",
            "",
            "        try:",
            "            if invite_token and invite_member_id:",
            "                om = OrganizationMember.objects.get(token=invite_token, id=invite_member_id)",
            "            else:",
            "                om = OrganizationMember.objects.get(",
            "                    email=email, organization=organization, user=None",
            "                )",
            "        except OrganizationMember.DoesNotExist:",
            "            # Unable to locate the pending organization member. Cannot setup",
            "            # the invite helper.",
            "            return None",
            "",
            "        return cls(",
            "            request=request, member_id=om.id, token=om.token, instance=instance, logger=logger",
            "        )",
            "",
            "    @classmethod",
            "    def from_session(cls, request, instance=None, logger=None):",
            "        invite_token, invite_member_id = get_invite_details(request)",
            "",
            "        if not invite_token or not invite_member_id:",
            "            return None",
            "",
            "        try:",
            "            return ApiInviteHelper(",
            "                request=request,",
            "                member_id=invite_member_id,",
            "                token=invite_token,",
            "                instance=instance,",
            "                logger=logger,",
            "            )",
            "        except OrganizationMember.DoesNotExist:",
            "            if logger:",
            "                logger.error(\"Invalid pending invite cookie\", exc_info=True)",
            "            return None",
            "",
            "    def __init__(self, request, member_id, token, instance=None, logger=None):",
            "        self.request: Request = request",
            "        self.member_id: int = member_id",
            "        self.token: str = token",
            "        self.instance = instance",
            "        self.logger = logger",
            "        self.om: OrganizationMember = self.organization_member",
            "",
            "    def handle_success(self):",
            "        member_joined.send_robust(",
            "            member=self.om,",
            "            organization=self.om.organization,",
            "            sender=self.instance if self.instance else self,",
            "        )",
            "",
            "    def handle_member_already_exists(self):",
            "        if self.logger:",
            "            self.logger.info(",
            "                \"Pending org invite not accepted - User already org member\",",
            "                extra={\"organization_id\": self.om.organization.id, \"user_id\": self.request.user.id},",
            "            )",
            "",
            "    def handle_member_has_no_sso(self):",
            "        if self.logger:",
            "            self.logger.info(",
            "                \"Pending org invite not accepted - User did not have SSO\",",
            "                extra={\"organization_id\": self.om.organization.id, \"user_id\": self.request.user.id},",
            "            )",
            "",
            "    def handle_invite_not_approved(self):",
            "        if not self.invite_approved:",
            "            self.om.delete()",
            "",
            "    @property",
            "    def organization_member(self) -> OrganizationMember:",
            "        return OrganizationMember.objects.select_related(\"organization\").get(pk=self.member_id)",
            "",
            "    @property",
            "    def member_pending(self):",
            "        return self.om.is_pending",
            "",
            "    @property",
            "    def invite_approved(self):",
            "        return self.om.invite_approved",
            "",
            "    @property",
            "    def valid_token(self):",
            "        if self.token is None:",
            "            return False",
            "        if self.om.token_expired:",
            "            return False",
            "        return constant_time_compare(self.om.token or self.om.legacy_token, self.token)",
            "",
            "    @property",
            "    def user_authenticated(self):",
            "        return self.request.user.is_authenticated",
            "",
            "    @property",
            "    def member_already_exists(self):",
            "        if not self.user_authenticated:",
            "            return False",
            "",
            "        return OrganizationMember.objects.filter(",
            "            organization=self.om.organization, user=self.request.user",
            "        ).exists()",
            "",
            "    @property",
            "    def valid_request(self):",
            "        return (",
            "            self.member_pending",
            "            and self.invite_approved",
            "            and self.valid_token",
            "            and self.user_authenticated",
            "            and not any(self.get_onboarding_steps().values())",
            "        )",
            "",
            "    def accept_invite(self, user=None):",
            "        om = self.om",
            "",
            "        if user is None:",
            "            user = self.request.user",
            "",
            "        if self.member_already_exists:",
            "            self.handle_member_already_exists()",
            "            om.delete()",
            "            return",
            "",
            "        try:",
            "            provider = AuthProvider.objects.get(organization=om.organization)",
            "        except AuthProvider.DoesNotExist:",
            "            provider = None",
            "",
            "        # If SSO is required, check for valid AuthIdentity",
            "        if provider and not provider.flags.allow_unlinked:",
            "            # AuthIdentity has a unique constraint on provider and user",
            "            if not AuthIdentity.objects.filter(auth_provider=provider, user=user).exists():",
            "                self.handle_member_has_no_sso()",
            "                return",
            "",
            "        om.set_user(user)",
            "        om.save()",
            "",
            "        create_audit_entry(",
            "            self.request,",
            "            actor=user,",
            "            organization=om.organization,",
            "            target_object=om.id,",
            "            target_user=user,",
            "            event=audit_log.get_event_id(\"MEMBER_ACCEPT\"),",
            "            data=om.get_audit_log_data(),",
            "        )",
            "",
            "        self.handle_success()",
            "        metrics.incr(\"organization.invite-accepted\", sample_rate=1.0)",
            "",
            "        return om",
            "",
            "    def _needs_2fa(self) -> bool:",
            "        org_requires_2fa = self.om.organization.flags.require_2fa.is_set",
            "        user_has_2fa = Authenticator.objects.user_has_2fa(self.request.user.id)",
            "        return org_requires_2fa and not user_has_2fa",
            "",
            "    def _needs_email_verification(self) -> bool:",
            "        organization = self.om.organization",
            "        if not (",
            "            features.has(\"organizations:required-email-verification\", organization)",
            "            and organization.flags.require_email_verification",
            "        ):",
            "            return False",
            "",
            "        user = self.request.user",
            "        primary_email_is_verified = (",
            "            isinstance(user, User) and UserEmail.objects.get_primary_email(user).is_verified",
            "        )",
            "        return not primary_email_is_verified",
            "",
            "    def get_onboarding_steps(self) -> Dict[str, bool]:",
            "        return {",
            "            \"needs2fa\": self._needs_2fa(),",
            "            \"needsEmailVerification\": self._needs_email_verification(),",
            "        }"
        ],
        "action": [
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1": [],
            "2": [],
            "4": [],
            "20": [
                "INVITE_COOKIE"
            ],
            "21": [
                "COOKIE_MAX_AGE"
            ],
            "24": [
                "add_invite_cookie"
            ],
            "25": [
                "add_invite_cookie"
            ],
            "26": [
                "add_invite_cookie"
            ],
            "27": [
                "add_invite_cookie"
            ],
            "28": [
                "add_invite_cookie"
            ],
            "29": [
                "add_invite_cookie"
            ],
            "30": [
                "add_invite_cookie"
            ],
            "33": [
                "remove_invite_cookie"
            ],
            "34": [
                "remove_invite_cookie"
            ],
            "35": [
                "remove_invite_cookie"
            ],
            "37": [],
            "38": [
                "get_invite_cookie"
            ],
            "39": [
                "get_invite_cookie"
            ],
            "40": [
                "get_invite_cookie"
            ],
            "41": [
                "get_invite_cookie"
            ],
            "42": [
                "get_invite_cookie"
            ],
            "43": [
                "get_invite_cookie"
            ],
            "44": [
                "get_invite_cookie"
            ],
            "45": [
                "get_invite_cookie"
            ],
            "46": [
                "get_invite_cookie"
            ],
            "51": [
                "ApiInviteHelper",
                "from_cookie_or_email"
            ],
            "54": [
                "ApiInviteHelper",
                "from_cookie_or_email"
            ],
            "55": [
                "ApiInviteHelper",
                "from_cookie_or_email"
            ],
            "57": [
                "ApiInviteHelper",
                "from_cookie_or_email"
            ],
            "60": [
                "ApiInviteHelper",
                "from_cookie_or_email"
            ],
            "61": [
                "ApiInviteHelper",
                "from_cookie_or_email"
            ],
            "62": [
                "ApiInviteHelper",
                "from_cookie_or_email"
            ],
            "63": [
                "ApiInviteHelper",
                "from_cookie_or_email"
            ],
            "78": [
                "ApiInviteHelper",
                "from_cookie"
            ],
            "79": [
                "ApiInviteHelper",
                "from_cookie"
            ],
            "81": [
                "ApiInviteHelper",
                "from_cookie"
            ],
            "87": [
                "ApiInviteHelper",
                "from_cookie"
            ],
            "88": [
                "ApiInviteHelper",
                "from_cookie"
            ],
            "98": [
                "ApiInviteHelper",
                "__init__"
            ],
            "99": [
                "ApiInviteHelper",
                "__init__"
            ],
            "100": [
                "ApiInviteHelper",
                "__init__"
            ],
            "103": [
                "ApiInviteHelper",
                "__init__"
            ],
            "131": [
                "ApiInviteHelper",
                "organization_member"
            ]
        },
        "addLocation": []
    },
    "src/sentry/auth/helper.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from django.views import View"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from sentry import audit_log, features"
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sentry.api.invite_helper import ApiInviteHelper, remove_invite_cookie"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from sentry.api.invite_helper import ApiInviteHelper, remove_invite_details_from_session"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from sentry.api.utils import generate_organization_url"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from sentry.auth.email import AmbiguousUserFromEmail, resolve_email_to_user"
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from sentry.auth.exceptions import IdentityNotValid"
            },
            "8": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "         user = auth_identity.user"
            },
            "9": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         # If the user is either currently *pending* invite acceptance (as indicated"
            },
            "11": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # from the pending-invite cookie) OR an existing invite exists on this"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        # from the invite token and member id in the session) OR an existing invite exists on this"
            },
            "13": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "         # organization for the email provided by the identity provider."
            },
            "14": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        invite_helper = ApiInviteHelper.from_cookie_or_email("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        invite_helper = ApiInviteHelper.from_session_or_email("
            },
            "16": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "             request=self.request, organization=self.organization, email=user.email"
            },
            "17": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         )"
            },
            "18": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 406,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "         # Always remove any pending invite cookies, pending invites will have been"
            },
            "21": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         # accepted during the SSO flow."
            },
            "22": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        remove_invite_cookie(self.request, response)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+        remove_invite_details_from_session(self.request)"
            },
            "24": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 410,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 411,
                "PatchRowcode": "         return response"
            },
            "26": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 412,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import logging",
            "from dataclasses import dataclass",
            "from functools import cached_property",
            "from typing import Any, Dict, Mapping, Optional, Tuple, Union",
            "from uuid import uuid4",
            "",
            "import sentry_sdk",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.auth.models import AnonymousUser",
            "from django.db import IntegrityError, transaction",
            "from django.db.models import F",
            "from django.http import HttpResponseRedirect",
            "from django.http.request import HttpRequest",
            "from django.http.response import HttpResponse",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.translation import ugettext_lazy as _",
            "from django.views import View",
            "",
            "from sentry import audit_log, features",
            "from sentry.api.invite_helper import ApiInviteHelper, remove_invite_cookie",
            "from sentry.api.utils import generate_organization_url",
            "from sentry.auth.email import AmbiguousUserFromEmail, resolve_email_to_user",
            "from sentry.auth.exceptions import IdentityNotValid",
            "from sentry.auth.idpmigration import (",
            "    get_verification_value_from_key,",
            "    send_one_time_account_confirm_link,",
            ")",
            "from sentry.auth.provider import MigratingIdentityId, Provider",
            "from sentry.auth.superuser import is_active_superuser",
            "from sentry.locks import locks",
            "from sentry.models import (",
            "    AuditLogEntry,",
            "    AuthIdentity,",
            "    AuthProvider,",
            "    Organization,",
            "    OrganizationMember,",
            "    OrganizationMemberTeam,",
            "    User,",
            ")",
            "from sentry.pipeline import Pipeline, PipelineSessionStore",
            "from sentry.signals import sso_enabled, user_signup",
            "from sentry.tasks.auth import email_missing_links",
            "from sentry.utils import auth, json, metrics",
            "from sentry.utils.audit import create_audit_entry",
            "from sentry.utils.hashlib import md5_text",
            "from sentry.utils.http import absolute_uri",
            "from sentry.utils.retries import TimedRetryPolicy",
            "from sentry.utils.session_store import redis_property",
            "from sentry.utils.urls import add_params_to_url",
            "from sentry.web.forms.accounts import AuthenticationForm",
            "from sentry.web.helpers import render_to_response",
            "",
            "from . import manager",
            "",
            "logger = logging.getLogger(\"sentry.auth\")",
            "",
            "OK_LINK_IDENTITY = _(\"You have successfully linked your account to your SSO provider.\")",
            "",
            "OK_SETUP_SSO = _(",
            "    \"SSO has been configured for your organization and any existing members have been sent an email to link their accounts.\"",
            ")",
            "",
            "ERR_UID_MISMATCH = _(\"There was an error encountered during authentication.\")",
            "",
            "ERR_NOT_AUTHED = _(\"You must be authenticated to link accounts.\")",
            "",
            "ERR_INVALID_IDENTITY = _(\"The provider did not return a valid user identity.\")",
            "",
            "",
            "class AuthHelperSessionStore(PipelineSessionStore):",
            "    redis_namespace = \"auth\"",
            "",
            "    @property",
            "    def session_key(self):",
            "        return \"auth_key\"",
            "",
            "    flow = redis_property(\"flow\")",
            "",
            "    def mark_session(self):",
            "        super().mark_session()",
            "        self.request.session.modified = True",
            "",
            "    def is_valid(self):",
            "        return super().is_valid() and self.flow in (",
            "            AuthHelper.FLOW_LOGIN,",
            "            AuthHelper.FLOW_SETUP_PROVIDER,",
            "        )",
            "",
            "",
            "@dataclass",
            "class AuthIdentityHandler:",
            "    # SSO auth handler",
            "",
            "    auth_provider: Optional[AuthProvider]",
            "    provider: Provider",
            "    organization: Organization",
            "    request: HttpRequest",
            "    identity: Mapping[str, Any]",
            "",
            "    @cached_property",
            "    def user(self) -> Union[User, AnonymousUser]:",
            "        email = self.identity.get(\"email\")",
            "        if email:",
            "            try:",
            "                user = resolve_email_to_user(email)",
            "            except AmbiguousUserFromEmail as e:",
            "                user = e.users[0]",
            "                self.warn_about_ambiguous_email(email, e.users, user)",
            "            if user is not None:",
            "                return user",
            "        return self.request.user",
            "",
            "    @staticmethod",
            "    def warn_about_ambiguous_email(email: str, users: Tuple[User], chosen_user: User):",
            "        with sentry_sdk.push_scope() as scope:",
            "            scope.level = \"warning\"",
            "            scope.set_tag(\"email\", email)",
            "            scope.set_extra(\"user_ids\", [user.id for user in users])",
            "            scope.set_extra(\"chosen_user\", chosen_user.id)",
            "            sentry_sdk.capture_message(\"Handling identity from ambiguous email address\")",
            "",
            "    class _NotCompletedSecurityChecks(Exception):",
            "        pass",
            "",
            "    def _login(self, user: Any) -> None:",
            "        metrics.incr(",
            "            \"sso.login_attempt\",",
            "            tags={",
            "                \"provider\": self.provider.key,",
            "                \"organization_id\": self.organization.id,",
            "                \"user_id\": user.id,",
            "            },",
            "            sample_rate=1.0,",
            "            skip_internal=False,",
            "        )",
            "        user_was_logged_in = auth.login(",
            "            self.request,",
            "            user,",
            "            after_2fa=self.request.build_absolute_uri(),",
            "            organization_id=self.organization.id,",
            "        )",
            "        if not user_was_logged_in:",
            "            raise self._NotCompletedSecurityChecks()",
            "",
            "        metrics.incr(",
            "            \"sso.login_success\",",
            "            tags={",
            "                \"provider\": self.provider.key,",
            "                \"organization_id\": self.organization.id,",
            "                \"user_id\": user.id,",
            "            },",
            "            sample_rate=1.0,",
            "            skip_internal=False,",
            "        )",
            "",
            "    @staticmethod",
            "    def _set_linked_flag(member: OrganizationMember) -> None:",
            "        if getattr(member.flags, \"sso:invalid\") or not getattr(member.flags, \"sso:linked\"):",
            "            setattr(member.flags, \"sso:invalid\", False)",
            "            setattr(member.flags, \"sso:linked\", True)",
            "            member.save()",
            "",
            "    def handle_existing_identity(",
            "        self,",
            "        state: AuthHelperSessionStore,",
            "        auth_identity: AuthIdentity,",
            "    ) -> HttpResponseRedirect:",
            "        # TODO(dcramer): this is very similar to attach",
            "        now = timezone.now()",
            "        auth_identity.update(",
            "            data=self.provider.update_identity(",
            "                new_data=self.identity.get(\"data\", {}), current_data=auth_identity.data",
            "            ),",
            "            last_verified=now,",
            "            last_synced=now,",
            "        )",
            "",
            "        try:",
            "            member = OrganizationMember.objects.get(",
            "                user=auth_identity.user, organization=self.organization",
            "            )",
            "        except OrganizationMember.DoesNotExist:",
            "            # this is likely the case when someone was removed from the org",
            "            # but still has access to rejoin",
            "            member = self._handle_new_membership(auth_identity)",
            "        else:",
            "            self._set_linked_flag(member)",
            "",
            "        user = auth_identity.user",
            "        user.backend = settings.AUTHENTICATION_BACKENDS[0]",
            "",
            "        data = state.data",
            "        subdomain = None",
            "        if data:",
            "            subdomain = data.get(\"subdomain\") or None",
            "",
            "        try:",
            "            self._login(user)",
            "        except self._NotCompletedSecurityChecks:",
            "            return HttpResponseRedirect(self._get_login_redirect(subdomain))",
            "",
            "        state.clear()",
            "",
            "        if not is_active_superuser(self.request):",
            "            # set activeorg to ensure correct redirect upon logging in",
            "            auth.set_active_org(self.request, self.organization.slug)",
            "        return HttpResponseRedirect(self._get_login_redirect(subdomain))",
            "",
            "    def _get_login_redirect(self, subdomain):",
            "        login_redirect_url = auth.get_login_redirect(self.request)",
            "        if subdomain is not None:",
            "            url_prefix = generate_organization_url(subdomain)",
            "            login_redirect_url = absolute_uri(login_redirect_url, url_prefix=url_prefix)",
            "        return login_redirect_url",
            "",
            "    def _handle_new_membership(self, auth_identity: AuthIdentity) -> Optional[OrganizationMember]:",
            "        user = auth_identity.user",
            "",
            "        # If the user is either currently *pending* invite acceptance (as indicated",
            "        # from the pending-invite cookie) OR an existing invite exists on this",
            "        # organization for the email provided by the identity provider.",
            "        invite_helper = ApiInviteHelper.from_cookie_or_email(",
            "            request=self.request, organization=self.organization, email=user.email",
            "        )",
            "",
            "        # If we are able to accept an existing invite for the user for this",
            "        # organization, do so, otherwise handle new membership",
            "        if invite_helper:",
            "            if invite_helper.invite_approved:",
            "                return invite_helper.accept_invite(user)",
            "",
            "            # It's possible the user has an _invite request_ that hasn't been approved yet,",
            "            # and is able to join the organization without an invite through the SSO flow.",
            "            # In that case, delete the invite request and create a new membership.",
            "            invite_helper.handle_invite_not_approved()",
            "",
            "        flags = OrganizationMember.flags[\"sso:linked\"]",
            "        # if the org doesn't have the ability to add members then anyone who got added",
            "        # this way should be disabled until the org upgrades",
            "        if not features.has(\"organizations:invite-members\", self.organization):",
            "            flags = flags | OrganizationMember.flags[\"member-limit:restricted\"]",
            "",
            "        # Otherwise create a new membership",
            "        om = OrganizationMember.objects.create(",
            "            organization=self.organization,",
            "            role=self.organization.default_role,",
            "            user=user,",
            "            flags=flags,",
            "        )",
            "",
            "        default_teams = self.auth_provider.default_teams.all()",
            "        for team in default_teams:",
            "            OrganizationMemberTeam.objects.create(team=team, organizationmember=om)",
            "",
            "        AuditLogEntry.objects.create(",
            "            organization=self.organization,",
            "            actor=user,",
            "            ip_address=self.request.META[\"REMOTE_ADDR\"],",
            "            target_object=om.id,",
            "            target_user=om.user,",
            "            event=audit_log.get_event_id(\"MEMBER_ADD\"),",
            "            data=om.get_audit_log_data(),",
            "        )",
            "",
            "        return om",
            "",
            "    def _get_auth_identity(self, **params) -> Optional[AuthIdentity]:",
            "        try:",
            "            return AuthIdentity.objects.get(auth_provider=self.auth_provider, **params)",
            "        except AuthIdentity.DoesNotExist:",
            "            return None",
            "",
            "    @transaction.atomic",
            "    def handle_attach_identity(self, member: Optional[OrganizationMember] = None) -> AuthIdentity:",
            "        \"\"\"",
            "        Given an already authenticated user, attach or re-attach an identity.",
            "        \"\"\"",
            "        # prioritize identifying by the SSO provider's user ID",
            "        auth_identity = self._get_auth_identity(ident=self.identity[\"id\"])",
            "        if auth_identity is None:",
            "            # otherwise look for an already attached identity",
            "            # this can happen if the SSO provider's internal ID changes",
            "            auth_identity = self._get_auth_identity(user=self.user)",
            "",
            "        if auth_identity is None:",
            "            auth_is_new = True",
            "            auth_identity = AuthIdentity.objects.create(",
            "                auth_provider=self.auth_provider,",
            "                user=self.user,",
            "                ident=self.identity[\"id\"],",
            "                data=self.identity.get(\"data\", {}),",
            "            )",
            "        else:",
            "            auth_is_new = False",
            "",
            "            # TODO(dcramer): this might leave the user with duplicate accounts,",
            "            # and in that kind of situation its very reasonable that we could",
            "            # test email addresses + is_managed to determine if we can auto",
            "            # merge",
            "            if auth_identity.user != self.user:",
            "                wipe = self._wipe_existing_identity(auth_identity)",
            "            else:",
            "                wipe = None",
            "",
            "            now = timezone.now()",
            "            auth_identity.update(",
            "                user=self.user,",
            "                ident=self.identity[\"id\"],",
            "                data=self.provider.update_identity(",
            "                    new_data=self.identity.get(\"data\", {}), current_data=auth_identity.data",
            "                ),",
            "                last_verified=now,",
            "                last_synced=now,",
            "            )",
            "",
            "            logger.info(",
            "                \"sso.login-pipeline.attach-existing-identity\",",
            "                extra={",
            "                    \"wipe_result\": repr(wipe),",
            "                    \"organization_id\": self.organization.id,",
            "                    \"user_id\": self.user.id,",
            "                    \"auth_identity_user_id\": auth_identity.user.id,",
            "                    \"auth_provider_id\": self.auth_provider.id,",
            "                    \"idp_identity_id\": self.identity[\"id\"],",
            "                    \"idp_identity_email\": self.identity.get(\"email\"),",
            "                },",
            "            )",
            "",
            "        if member is None:",
            "            member = self._get_organization_member(auth_identity)",
            "        self._set_linked_flag(member)",
            "",
            "        if auth_is_new:",
            "            AuditLogEntry.objects.create(",
            "                organization=self.organization,",
            "                actor=self.user,",
            "                ip_address=self.request.META[\"REMOTE_ADDR\"],",
            "                target_object=auth_identity.id,",
            "                event=audit_log.get_event_id(\"SSO_IDENTITY_LINK\"),",
            "                data=auth_identity.get_audit_log_data(),",
            "            )",
            "",
            "            messages.add_message(self.request, messages.SUCCESS, OK_LINK_IDENTITY)",
            "",
            "        return auth_identity",
            "",
            "    def _wipe_existing_identity(self, auth_identity: AuthIdentity) -> Any:",
            "        # it's possible the user has an existing identity, let's wipe it out",
            "        # so that the new identifier gets used (other we'll hit a constraint)",
            "        # violation since one might exist for (provider, user) as well as",
            "        # (provider, ident)",
            "        deletion_result = (",
            "            AuthIdentity.objects.exclude(id=auth_identity.id)",
            "            .filter(auth_provider=self.auth_provider, user=self.user)",
            "            .delete()",
            "        )",
            "",
            "        # since we've identified an identity which is no longer valid",
            "        # lets preemptively mark it as such",
            "        try:",
            "            other_member = OrganizationMember.objects.get(",
            "                user=auth_identity.user_id, organization=self.organization",
            "            )",
            "        except OrganizationMember.DoesNotExist:",
            "            return",
            "        other_member.flags[\"sso:invalid\"] = True",
            "        other_member.flags[\"sso:linked\"] = False",
            "        other_member.save()",
            "",
            "        return deletion_result",
            "",
            "    def _get_organization_member(self, auth_identity: AuthIdentity) -> OrganizationMember:",
            "        \"\"\"",
            "        Check to see if the user has a member associated, if not, create a new membership",
            "        based on the auth_identity email.",
            "        \"\"\"",
            "        try:",
            "            return OrganizationMember.objects.get(user=self.user, organization=self.organization)",
            "        except OrganizationMember.DoesNotExist:",
            "            return self._handle_new_membership(auth_identity)",
            "",
            "    def _respond(",
            "        self,",
            "        template: str,",
            "        context: Mapping[str, Any] = None,",
            "        status: int = 200,",
            "    ) -> HttpResponse:",
            "        default_context = {\"organization\": self.organization}",
            "        if context:",
            "            default_context.update(context)",
            "",
            "        return render_to_response(template, default_context, self.request, status=status)",
            "",
            "    def _post_login_redirect(self) -> HttpResponseRedirect:",
            "        url = auth.get_login_redirect(self.request)",
            "        if self.request.POST.get(\"op\") == \"newuser\":",
            "            # add events that we can handle on the front end",
            "            provider = self.auth_provider.provider if self.auth_provider else None",
            "            params = {",
            "                \"frontend_events\": json.dumps({\"event_name\": \"Sign Up\", \"event_label\": provider})",
            "            }",
            "            url = add_params_to_url(url, params)",
            "        response = HttpResponseRedirect(url)",
            "",
            "        # Always remove any pending invite cookies, pending invites will have been",
            "        # accepted during the SSO flow.",
            "        remove_invite_cookie(self.request, response)",
            "",
            "        return response",
            "",
            "    def has_verified_account(self, verification_value: Dict[str, Any]) -> bool:",
            "        return (",
            "            verification_value[\"email\"] == self.identity[\"email\"]",
            "            and verification_value[\"user_id\"] == self.user.id",
            "        )",
            "",
            "    @property",
            "    def _logged_in_user(self) -> Optional[User]:",
            "        \"\"\"The user, if they have authenticated on this session.\"\"\"",
            "        return self.request.user if self.request.user.is_authenticated else None",
            "",
            "    @property",
            "    def _app_user(self) -> Optional[User]:",
            "        \"\"\"The user, if they are represented persistently in our app.\"\"\"",
            "        return self.user if isinstance(self.user, User) else None",
            "",
            "    def _has_usable_password(self):",
            "        return self._app_user and self._app_user.has_usable_password()",
            "",
            "    def handle_unknown_identity(",
            "        self,",
            "        state: AuthHelperSessionStore,",
            "    ) -> HttpResponseRedirect:",
            "        \"\"\"",
            "        Flow is activated upon a user logging in to where an AuthIdentity is",
            "        not present.",
            "",
            "        XXX(dcramer): this docstring is out of date",
            "",
            "        The flow will attempt to answer the following:",
            "",
            "        - Is there an existing user with the same email address? Should they be",
            "          merged?",
            "",
            "        - Is there an existing user (via authentication) that should be merged?",
            "",
            "        - Should I create a new user based on this identity?",
            "        \"\"\"",
            "        op = self.request.POST.get(\"op\")",
            "        login_form = (",
            "            None",
            "            if self._logged_in_user",
            "            else AuthenticationForm(",
            "                self.request,",
            "                self.request.POST if self.request.POST.get(\"op\") == \"login\" else None,",
            "                initial={\"username\": self._app_user and self._app_user.username},",
            "            )",
            "        )",
            "        # we don't trust all IDP email verification, so users can also confirm via one time email link",
            "        is_account_verified = False",
            "        if self.request.session.get(\"confirm_account_verification_key\"):",
            "            verification_key = self.request.session.get(\"confirm_account_verification_key\")",
            "            verification_value = get_verification_value_from_key(verification_key)",
            "            if verification_value:",
            "                is_account_verified = self.has_verified_account(verification_value)",
            "",
            "        is_new_account = not self.user.is_authenticated  # stateful",
            "        if self._app_user and self.identity.get(\"email_verified\") or is_account_verified:",
            "            # we only allow this flow to happen if the existing user has",
            "            # membership, otherwise we short circuit because it might be",
            "            # an attempt to hijack membership of another organization",
            "            has_membership = OrganizationMember.objects.filter(",
            "                user=self._app_user, organization=self.organization",
            "            ).exists()",
            "            if has_membership:",
            "                try:",
            "                    self._login(self.user)",
            "                except self._NotCompletedSecurityChecks:",
            "                    # adding is_account_verified to the check below in order to redirect",
            "                    # to 2fa when the user migrates their idp but has 2fa enabled,",
            "                    # otherwise it would stop them from linking their sso provider",
            "                    if self._has_usable_password() or is_account_verified:",
            "                        return self._post_login_redirect()",
            "                    else:",
            "                        is_new_account = True",
            "                else:",
            "                    # assume they've confirmed they want to attach the identity",
            "                    op = \"confirm\"",
            "            elif is_account_verified:",
            "                op = \"confirm\"",
            "            else:",
            "                # force them to create a new account",
            "                is_new_account = True",
            "        # without a usable password they can't login, so default to a new account",
            "        elif not self._has_usable_password():",
            "            is_new_account = True",
            "",
            "        auth_identity = None",
            "        if op == \"confirm\" and self.user.is_authenticated or is_account_verified:",
            "            auth_identity = self.handle_attach_identity()",
            "        elif op == \"newuser\":",
            "            auth_identity = self.handle_new_user()",
            "        elif op == \"login\" and not self._logged_in_user:",
            "            # confirm authentication, login",
            "            op = None",
            "            if login_form.is_valid():",
            "                # This flow is special.  If we are going through a 2FA",
            "                # flow here (login returns False) we want to instruct the",
            "                # system to return upon completion of the 2fa flow to the",
            "                # current URL and continue with the dialog.",
            "                #",
            "                # If there is no 2fa we don't need to do this and can just",
            "                # go on.",
            "                try:",
            "                    self._login(login_form.get_user())",
            "                except self._NotCompletedSecurityChecks:",
            "                    return self._post_login_redirect()",
            "            else:",
            "                auth.log_auth_failure(self.request, self.request.POST.get(\"username\"))",
            "        else:",
            "            op = None",
            "",
            "        if not op:",
            "            existing_user, template = self._dispatch_to_confirmation(is_new_account)",
            "",
            "            context = {",
            "                \"identity\": self.identity,",
            "                \"provider\": self.provider_name,",
            "                \"identity_display_name\": self.identity.get(\"name\") or self.identity.get(\"email\"),",
            "                \"identity_identifier\": self.identity.get(\"email\") or self.identity.get(\"id\"),",
            "                \"existing_user\": existing_user,",
            "            }",
            "            if login_form:",
            "                context[\"login_form\"] = login_form",
            "            return self._respond(f\"sentry/{template}.html\", context)",
            "",
            "        user = auth_identity.user",
            "        user.backend = settings.AUTHENTICATION_BACKENDS[0]",
            "",
            "        # XXX(dcramer): this is repeated from above",
            "        try:",
            "            self._login(user)",
            "        except self._NotCompletedSecurityChecks:",
            "            return self._post_login_redirect()",
            "",
            "        state.clear()",
            "",
            "        if not is_active_superuser(self.request):",
            "            auth.set_active_org(self.request, self.organization.slug)",
            "        return self._post_login_redirect()",
            "",
            "    @property",
            "    def provider_name(self):",
            "        if self.auth_provider:",
            "            return self.auth_provider.provider_name",
            "        else:",
            "            # A blank character is needed to prevent an HTML span from collapsing",
            "            return \" \"",
            "",
            "    def _dispatch_to_confirmation(self, is_new_account: bool) -> Tuple[Optional[User], str]:",
            "        if self._logged_in_user:",
            "            return self._logged_in_user, \"auth-confirm-link\"",
            "",
            "        if self._app_user and not self._has_usable_password():",
            "            send_one_time_account_confirm_link(",
            "                self._app_user,",
            "                self.organization,",
            "                self.auth_provider,",
            "                self.identity[\"email\"],",
            "                self.identity[\"id\"],",
            "            )",
            "            return self.user, \"auth-confirm-account\"",
            "",
            "        self.request.session.set_test_cookie()",
            "        return None if is_new_account else self.user, \"auth-confirm-identity\"",
            "",
            "    def handle_new_user(self) -> AuthIdentity:",
            "        user = User.objects.create(",
            "            username=uuid4().hex,",
            "            email=self.identity[\"email\"],",
            "            name=self.identity.get(\"name\", \"\")[:200],",
            "        )",
            "",
            "        if settings.TERMS_URL and settings.PRIVACY_URL:",
            "            user.update(flags=F(\"flags\").bitor(User.flags.newsletter_consent_prompt))",
            "",
            "        try:",
            "            with transaction.atomic():",
            "                auth_identity = AuthIdentity.objects.create(",
            "                    auth_provider=self.auth_provider,",
            "                    user=user,",
            "                    ident=self.identity[\"id\"],",
            "                    data=self.identity.get(\"data\", {}),",
            "                )",
            "        except IntegrityError:",
            "            auth_identity = self._get_auth_identity(ident=self.identity[\"id\"])",
            "            auth_identity.update(user=user, data=self.identity.get(\"data\", {}))",
            "",
            "        user.send_confirm_emails(is_new_user=True)",
            "        provider = self.auth_provider.provider if self.auth_provider else None",
            "        user_signup.send_robust(",
            "            sender=self.handle_new_user,",
            "            user=user,",
            "            source=\"sso\",",
            "            provider=provider,",
            "            referrer=\"in-app\",",
            "        )",
            "",
            "        self._handle_new_membership(auth_identity)",
            "",
            "        return auth_identity",
            "",
            "",
            "class AuthHelper(Pipeline):",
            "    \"\"\"",
            "    Helper class which is passed into AuthView's.",
            "",
            "    Designed to link provider and views as well as manage the state and",
            "    pipeline. The pipeline is optional, in case can be done",
            "",
            "    Auth has several flows:",
            "",
            "    1. The user is going through provider setup, thus enforcing that they link",
            "       their current account to the new auth identity.",
            "    2. The user is anonymous and creating a brand new account.",
            "    3. The user is anonymous and logging into an existing account.",
            "    4. The user is anonymous and creating a brand new account, but may have an",
            "       existing account that should/could be merged.",
            "    5. The user is authenticated and creating a new identity, thus associating",
            "       it with their current account.",
            "    6. The user is authenticated and creating a new identity, but not linking",
            "       it with their account (thus creating a new account).",
            "    \"\"\"",
            "",
            "    # logging in or registering",
            "    FLOW_LOGIN = 1",
            "    # configuring the provider",
            "    FLOW_SETUP_PROVIDER = 2",
            "",
            "    pipeline_name = \"pipeline\"",
            "    provider_manager = manager",
            "    provider_model_cls = AuthProvider",
            "    session_store_cls = AuthHelperSessionStore",
            "",
            "    @classmethod",
            "    def get_for_request(cls, request):",
            "        req_state = cls.unpack_state(request)",
            "        if not req_state:",
            "            return None",
            "",
            "        if not req_state.organization:",
            "            logging.info(\"Invalid SSO data found\")",
            "            return None",
            "        flow = req_state.state.flow",
            "",
            "        return cls(",
            "            request,",
            "            req_state.organization,",
            "            flow,",
            "            auth_provider=req_state.provider_model,",
            "            provider_key=req_state.provider_key,",
            "        )",
            "",
            "    def __init__(self, request, organization, flow, auth_provider=None, provider_key=None):",
            "        assert provider_key or auth_provider",
            "        self.flow = flow",
            "        super().__init__(request, provider_key, organization, auth_provider)",
            "",
            "    def get_provider(self, provider_key):",
            "        if self.provider_model:",
            "            return self.provider_model.get_provider()",
            "        elif provider_key:",
            "            return super().get_provider(provider_key)",
            "        else:",
            "            raise NotImplementedError",
            "",
            "    def get_pipeline_views(self):",
            "        if self.flow == self.FLOW_LOGIN:",
            "            return self.provider.get_auth_pipeline()",
            "        elif self.flow == self.FLOW_SETUP_PROVIDER:",
            "            return self.provider.get_setup_pipeline()",
            "        else:",
            "            raise NotImplementedError",
            "",
            "    def is_valid(self):",
            "        return super().is_valid() and self.state.flow in (self.FLOW_LOGIN, self.FLOW_SETUP_PROVIDER)",
            "",
            "    def get_initial_state(self):",
            "        state = super().get_initial_state()",
            "        state.update({\"flow\": self.flow})",
            "        return state",
            "",
            "    def get_redirect_url(self):",
            "        return absolute_uri(reverse(\"sentry-auth-sso\"))",
            "",
            "    def dispatch_to(self, step: View):",
            "        return step.dispatch(request=self.request, helper=self)",
            "",
            "    def finish_pipeline(self):",
            "        data = self.fetch_state()",
            "",
            "        # The state data may have expired, in which case the state data will",
            "        # simply be None.",
            "        if not data:",
            "            return self.error(ERR_INVALID_IDENTITY)",
            "",
            "        try:",
            "            identity = self.provider.build_identity(data)",
            "        except IdentityNotValid as error:",
            "            return self.error(str(error) or ERR_INVALID_IDENTITY)",
            "",
            "        if self.state.flow == self.FLOW_LOGIN:",
            "            # create identity and authenticate the user",
            "            response = self._finish_login_pipeline(identity)",
            "        elif self.state.flow == self.FLOW_SETUP_PROVIDER:",
            "            response = self._finish_setup_pipeline(identity)",
            "        else:",
            "            raise Exception(f\"Unrecognized flow value: {self.state.flow}\")",
            "",
            "        return response",
            "",
            "    def auth_handler(self, identity: Mapping[str, Any]):",
            "        return AuthIdentityHandler(",
            "            self.provider_model, self.provider, self.organization, self.request, identity",
            "        )",
            "",
            "    @transaction.atomic",
            "    def _finish_login_pipeline(self, identity: Mapping[str, Any]):",
            "        \"\"\"",
            "        The login flow executes both with anonymous and authenticated users.",
            "",
            "        Upon completion a few branches exist:",
            "",
            "        If the identity is already linked, the user should be logged in",
            "        and redirected immediately.",
            "",
            "        Otherwise, the user is presented with a confirmation window. That window",
            "        will show them the new account that will be created, and if they're",
            "        already authenticated an optional button to associate the identity with",
            "        their account.",
            "        \"\"\"",
            "        auth_provider = self.provider_model",
            "        user_id = identity[\"id\"]",
            "",
            "        lock = locks.get(",
            "            f\"sso:auth:{auth_provider.id}:{md5_text(user_id).hexdigest()}\",",
            "            duration=5,",
            "            name=\"sso_auth\",",
            "        )",
            "        with TimedRetryPolicy(5)(lock.acquire):",
            "            try:",
            "                auth_identity = AuthIdentity.objects.select_related(\"user\").get(",
            "                    auth_provider=auth_provider, ident=user_id",
            "                )",
            "            except AuthIdentity.DoesNotExist:",
            "                auth_identity = None",
            "",
            "            # Handle migration of identity keys",
            "            if not auth_identity and isinstance(user_id, MigratingIdentityId):",
            "                try:",
            "                    auth_identity = AuthIdentity.objects.select_related(\"user\").get(",
            "                        auth_provider=auth_provider, ident=user_id.legacy_id",
            "                    )",
            "                    auth_identity.update(ident=user_id.id)",
            "                except AuthIdentity.DoesNotExist:",
            "                    auth_identity = None",
            "",
            "            auth_handler = self.auth_handler(identity)",
            "            if not auth_identity:",
            "                return auth_handler.handle_unknown_identity(self.state)",
            "",
            "            # If the User attached to this AuthIdentity is not active,",
            "            # we want to clobber the old account and take it over, rather than",
            "            # getting logged into the inactive account.",
            "            if not auth_identity.user.is_active:",
            "                # Current user is also not logged in, so we have to",
            "                # assume unknown.",
            "                if not self.request.user.is_authenticated:",
            "                    return auth_handler.handle_unknown_identity(self.state)",
            "                auth_identity = auth_handler.handle_attach_identity()",
            "",
            "            return auth_handler.handle_existing_identity(self.state, auth_identity)",
            "",
            "    @transaction.atomic",
            "    def _finish_setup_pipeline(self, identity: Mapping[str, Any]):",
            "        \"\"\"",
            "        The setup flow creates the auth provider as well as an identity linked",
            "        to the active user.",
            "        \"\"\"",
            "        request = self.request",
            "        if not request.user.is_authenticated:",
            "            return self.error(ERR_NOT_AUTHED)",
            "",
            "        if request.user.id != self.state.uid:",
            "            return self.error(ERR_UID_MISMATCH)",
            "",
            "        data = self.fetch_state()",
            "        config = self.provider.build_config(data)",
            "",
            "        try:",
            "            om = OrganizationMember.objects.get(user=request.user, organization=self.organization)",
            "        except OrganizationMember.DoesNotExist:",
            "            return self.error(ERR_UID_MISMATCH)",
            "",
            "        # disable require 2FA for the organization",
            "        # since only SSO or require 2FA can be enabled",
            "        self.disable_2fa_required()",
            "",
            "        self.provider_model = AuthProvider.objects.create(",
            "            organization=self.organization, provider=self.provider.key, config=config",
            "        )",
            "",
            "        self.auth_handler(identity).handle_attach_identity(om)",
            "",
            "        auth.mark_sso_complete(request, self.organization.id)",
            "",
            "        sso_enabled.send_robust(",
            "            organization=self.organization,",
            "            user=request.user,",
            "            provider=self.provider.key,",
            "            sender=self.__class__,",
            "        )",
            "",
            "        AuditLogEntry.objects.create(",
            "            organization=self.organization,",
            "            actor=request.user,",
            "            ip_address=request.META[\"REMOTE_ADDR\"],",
            "            target_object=self.provider_model.id,",
            "            event=audit_log.get_event_id(\"SSO_ENABLE\"),",
            "            data=self.provider_model.get_audit_log_data(),",
            "        )",
            "",
            "        email_missing_links.delay(self.organization.id, request.user.id, self.provider.key)",
            "",
            "        messages.add_message(self.request, messages.SUCCESS, OK_SETUP_SSO)",
            "",
            "        self.clear_session()",
            "",
            "        next_uri = reverse(",
            "            \"sentry-organization-auth-provider-settings\", args=[self.organization.slug]",
            "        )",
            "        return HttpResponseRedirect(next_uri)",
            "",
            "    def error(self, message):",
            "        redirect_uri = \"/\"",
            "",
            "        if self.state.flow == self.FLOW_LOGIN:",
            "            # create identity and authenticate the user",
            "            redirect_uri = reverse(\"sentry-auth-organization\", args=[self.organization.slug])",
            "",
            "        elif self.state.flow == self.FLOW_SETUP_PROVIDER:",
            "            redirect_uri = reverse(",
            "                \"sentry-organization-auth-settings\", args=[self.organization.slug]",
            "            )",
            "",
            "        if redirect_uri == \"/\":",
            "            metrics.incr(",
            "                \"sso.error\",",
            "                tags={",
            "                    \"flow\": self.state.flow,",
            "                    \"provider\": self.provider.key,",
            "                    \"organization_id\": self.organization.id,",
            "                    \"user_id\": self.request.user.id,",
            "                },",
            "                skip_internal=False,",
            "                sample_rate=1.0,",
            "            )",
            "        else:",
            "            metrics.incr(",
            "                \"sso.exit\",",
            "                tags={",
            "                    \"flow\": self.state.flow,",
            "                    \"provider\": self.provider.key,",
            "                    \"organization_id\": self.organization.id,",
            "                    \"user_id\": self.request.user.id,",
            "                },",
            "                skip_internal=False,",
            "                sample_rate=1.0,",
            "            )",
            "",
            "        # NOTE: Does NOT necessarily indicate a login _failure_",
            "        logger.warning(",
            "            \"sso.login-pipeline.error\",",
            "            extra={",
            "                \"flow\": self.state.flow,",
            "                \"provider\": self.provider.key,",
            "                \"organization_id\": self.organization.id,",
            "                \"user_id\": self.request.user.id,",
            "                \"error_message\": message,",
            "            },",
            "        )",
            "",
            "        messages.add_message(self.request, messages.ERROR, f\"Authentication error: {message}\")",
            "",
            "        return HttpResponseRedirect(redirect_uri)",
            "",
            "    def disable_2fa_required(self):",
            "        require_2fa = self.organization.flags.require_2fa",
            "",
            "        if not require_2fa or not require_2fa.is_set:",
            "            return",
            "",
            "        self.organization.update(flags=F(\"flags\").bitand(~Organization.flags.require_2fa))",
            "",
            "        logger.info(",
            "            \"Require 2fa disabled during sso setup\", extra={\"organization_id\": self.organization.id}",
            "        )",
            "        create_audit_entry(",
            "            request=self.request,",
            "            organization=self.organization,",
            "            target_object=self.organization.id,",
            "            event=audit_log.get_event_id(\"ORG_EDIT\"),",
            "            data={\"require_2fa\": \"to False when enabling SSO\"},",
            "        )"
        ],
        "afterPatchFile": [
            "import logging",
            "from dataclasses import dataclass",
            "from functools import cached_property",
            "from typing import Any, Dict, Mapping, Optional, Tuple, Union",
            "from uuid import uuid4",
            "",
            "import sentry_sdk",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.auth.models import AnonymousUser",
            "from django.db import IntegrityError, transaction",
            "from django.db.models import F",
            "from django.http import HttpResponseRedirect",
            "from django.http.request import HttpRequest",
            "from django.http.response import HttpResponse",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.translation import ugettext_lazy as _",
            "from django.views import View",
            "",
            "from sentry import audit_log, features",
            "from sentry.api.invite_helper import ApiInviteHelper, remove_invite_details_from_session",
            "from sentry.api.utils import generate_organization_url",
            "from sentry.auth.email import AmbiguousUserFromEmail, resolve_email_to_user",
            "from sentry.auth.exceptions import IdentityNotValid",
            "from sentry.auth.idpmigration import (",
            "    get_verification_value_from_key,",
            "    send_one_time_account_confirm_link,",
            ")",
            "from sentry.auth.provider import MigratingIdentityId, Provider",
            "from sentry.auth.superuser import is_active_superuser",
            "from sentry.locks import locks",
            "from sentry.models import (",
            "    AuditLogEntry,",
            "    AuthIdentity,",
            "    AuthProvider,",
            "    Organization,",
            "    OrganizationMember,",
            "    OrganizationMemberTeam,",
            "    User,",
            ")",
            "from sentry.pipeline import Pipeline, PipelineSessionStore",
            "from sentry.signals import sso_enabled, user_signup",
            "from sentry.tasks.auth import email_missing_links",
            "from sentry.utils import auth, json, metrics",
            "from sentry.utils.audit import create_audit_entry",
            "from sentry.utils.hashlib import md5_text",
            "from sentry.utils.http import absolute_uri",
            "from sentry.utils.retries import TimedRetryPolicy",
            "from sentry.utils.session_store import redis_property",
            "from sentry.utils.urls import add_params_to_url",
            "from sentry.web.forms.accounts import AuthenticationForm",
            "from sentry.web.helpers import render_to_response",
            "",
            "from . import manager",
            "",
            "logger = logging.getLogger(\"sentry.auth\")",
            "",
            "OK_LINK_IDENTITY = _(\"You have successfully linked your account to your SSO provider.\")",
            "",
            "OK_SETUP_SSO = _(",
            "    \"SSO has been configured for your organization and any existing members have been sent an email to link their accounts.\"",
            ")",
            "",
            "ERR_UID_MISMATCH = _(\"There was an error encountered during authentication.\")",
            "",
            "ERR_NOT_AUTHED = _(\"You must be authenticated to link accounts.\")",
            "",
            "ERR_INVALID_IDENTITY = _(\"The provider did not return a valid user identity.\")",
            "",
            "",
            "class AuthHelperSessionStore(PipelineSessionStore):",
            "    redis_namespace = \"auth\"",
            "",
            "    @property",
            "    def session_key(self):",
            "        return \"auth_key\"",
            "",
            "    flow = redis_property(\"flow\")",
            "",
            "    def mark_session(self):",
            "        super().mark_session()",
            "        self.request.session.modified = True",
            "",
            "    def is_valid(self):",
            "        return super().is_valid() and self.flow in (",
            "            AuthHelper.FLOW_LOGIN,",
            "            AuthHelper.FLOW_SETUP_PROVIDER,",
            "        )",
            "",
            "",
            "@dataclass",
            "class AuthIdentityHandler:",
            "    # SSO auth handler",
            "",
            "    auth_provider: Optional[AuthProvider]",
            "    provider: Provider",
            "    organization: Organization",
            "    request: HttpRequest",
            "    identity: Mapping[str, Any]",
            "",
            "    @cached_property",
            "    def user(self) -> Union[User, AnonymousUser]:",
            "        email = self.identity.get(\"email\")",
            "        if email:",
            "            try:",
            "                user = resolve_email_to_user(email)",
            "            except AmbiguousUserFromEmail as e:",
            "                user = e.users[0]",
            "                self.warn_about_ambiguous_email(email, e.users, user)",
            "            if user is not None:",
            "                return user",
            "        return self.request.user",
            "",
            "    @staticmethod",
            "    def warn_about_ambiguous_email(email: str, users: Tuple[User], chosen_user: User):",
            "        with sentry_sdk.push_scope() as scope:",
            "            scope.level = \"warning\"",
            "            scope.set_tag(\"email\", email)",
            "            scope.set_extra(\"user_ids\", [user.id for user in users])",
            "            scope.set_extra(\"chosen_user\", chosen_user.id)",
            "            sentry_sdk.capture_message(\"Handling identity from ambiguous email address\")",
            "",
            "    class _NotCompletedSecurityChecks(Exception):",
            "        pass",
            "",
            "    def _login(self, user: Any) -> None:",
            "        metrics.incr(",
            "            \"sso.login_attempt\",",
            "            tags={",
            "                \"provider\": self.provider.key,",
            "                \"organization_id\": self.organization.id,",
            "                \"user_id\": user.id,",
            "            },",
            "            sample_rate=1.0,",
            "            skip_internal=False,",
            "        )",
            "        user_was_logged_in = auth.login(",
            "            self.request,",
            "            user,",
            "            after_2fa=self.request.build_absolute_uri(),",
            "            organization_id=self.organization.id,",
            "        )",
            "        if not user_was_logged_in:",
            "            raise self._NotCompletedSecurityChecks()",
            "",
            "        metrics.incr(",
            "            \"sso.login_success\",",
            "            tags={",
            "                \"provider\": self.provider.key,",
            "                \"organization_id\": self.organization.id,",
            "                \"user_id\": user.id,",
            "            },",
            "            sample_rate=1.0,",
            "            skip_internal=False,",
            "        )",
            "",
            "    @staticmethod",
            "    def _set_linked_flag(member: OrganizationMember) -> None:",
            "        if getattr(member.flags, \"sso:invalid\") or not getattr(member.flags, \"sso:linked\"):",
            "            setattr(member.flags, \"sso:invalid\", False)",
            "            setattr(member.flags, \"sso:linked\", True)",
            "            member.save()",
            "",
            "    def handle_existing_identity(",
            "        self,",
            "        state: AuthHelperSessionStore,",
            "        auth_identity: AuthIdentity,",
            "    ) -> HttpResponseRedirect:",
            "        # TODO(dcramer): this is very similar to attach",
            "        now = timezone.now()",
            "        auth_identity.update(",
            "            data=self.provider.update_identity(",
            "                new_data=self.identity.get(\"data\", {}), current_data=auth_identity.data",
            "            ),",
            "            last_verified=now,",
            "            last_synced=now,",
            "        )",
            "",
            "        try:",
            "            member = OrganizationMember.objects.get(",
            "                user=auth_identity.user, organization=self.organization",
            "            )",
            "        except OrganizationMember.DoesNotExist:",
            "            # this is likely the case when someone was removed from the org",
            "            # but still has access to rejoin",
            "            member = self._handle_new_membership(auth_identity)",
            "        else:",
            "            self._set_linked_flag(member)",
            "",
            "        user = auth_identity.user",
            "        user.backend = settings.AUTHENTICATION_BACKENDS[0]",
            "",
            "        data = state.data",
            "        subdomain = None",
            "        if data:",
            "            subdomain = data.get(\"subdomain\") or None",
            "",
            "        try:",
            "            self._login(user)",
            "        except self._NotCompletedSecurityChecks:",
            "            return HttpResponseRedirect(self._get_login_redirect(subdomain))",
            "",
            "        state.clear()",
            "",
            "        if not is_active_superuser(self.request):",
            "            # set activeorg to ensure correct redirect upon logging in",
            "            auth.set_active_org(self.request, self.organization.slug)",
            "        return HttpResponseRedirect(self._get_login_redirect(subdomain))",
            "",
            "    def _get_login_redirect(self, subdomain):",
            "        login_redirect_url = auth.get_login_redirect(self.request)",
            "        if subdomain is not None:",
            "            url_prefix = generate_organization_url(subdomain)",
            "            login_redirect_url = absolute_uri(login_redirect_url, url_prefix=url_prefix)",
            "        return login_redirect_url",
            "",
            "    def _handle_new_membership(self, auth_identity: AuthIdentity) -> Optional[OrganizationMember]:",
            "        user = auth_identity.user",
            "",
            "        # If the user is either currently *pending* invite acceptance (as indicated",
            "        # from the invite token and member id in the session) OR an existing invite exists on this",
            "        # organization for the email provided by the identity provider.",
            "        invite_helper = ApiInviteHelper.from_session_or_email(",
            "            request=self.request, organization=self.organization, email=user.email",
            "        )",
            "",
            "        # If we are able to accept an existing invite for the user for this",
            "        # organization, do so, otherwise handle new membership",
            "        if invite_helper:",
            "            if invite_helper.invite_approved:",
            "                return invite_helper.accept_invite(user)",
            "",
            "            # It's possible the user has an _invite request_ that hasn't been approved yet,",
            "            # and is able to join the organization without an invite through the SSO flow.",
            "            # In that case, delete the invite request and create a new membership.",
            "            invite_helper.handle_invite_not_approved()",
            "",
            "        flags = OrganizationMember.flags[\"sso:linked\"]",
            "        # if the org doesn't have the ability to add members then anyone who got added",
            "        # this way should be disabled until the org upgrades",
            "        if not features.has(\"organizations:invite-members\", self.organization):",
            "            flags = flags | OrganizationMember.flags[\"member-limit:restricted\"]",
            "",
            "        # Otherwise create a new membership",
            "        om = OrganizationMember.objects.create(",
            "            organization=self.organization,",
            "            role=self.organization.default_role,",
            "            user=user,",
            "            flags=flags,",
            "        )",
            "",
            "        default_teams = self.auth_provider.default_teams.all()",
            "        for team in default_teams:",
            "            OrganizationMemberTeam.objects.create(team=team, organizationmember=om)",
            "",
            "        AuditLogEntry.objects.create(",
            "            organization=self.organization,",
            "            actor=user,",
            "            ip_address=self.request.META[\"REMOTE_ADDR\"],",
            "            target_object=om.id,",
            "            target_user=om.user,",
            "            event=audit_log.get_event_id(\"MEMBER_ADD\"),",
            "            data=om.get_audit_log_data(),",
            "        )",
            "",
            "        return om",
            "",
            "    def _get_auth_identity(self, **params) -> Optional[AuthIdentity]:",
            "        try:",
            "            return AuthIdentity.objects.get(auth_provider=self.auth_provider, **params)",
            "        except AuthIdentity.DoesNotExist:",
            "            return None",
            "",
            "    @transaction.atomic",
            "    def handle_attach_identity(self, member: Optional[OrganizationMember] = None) -> AuthIdentity:",
            "        \"\"\"",
            "        Given an already authenticated user, attach or re-attach an identity.",
            "        \"\"\"",
            "        # prioritize identifying by the SSO provider's user ID",
            "        auth_identity = self._get_auth_identity(ident=self.identity[\"id\"])",
            "        if auth_identity is None:",
            "            # otherwise look for an already attached identity",
            "            # this can happen if the SSO provider's internal ID changes",
            "            auth_identity = self._get_auth_identity(user=self.user)",
            "",
            "        if auth_identity is None:",
            "            auth_is_new = True",
            "            auth_identity = AuthIdentity.objects.create(",
            "                auth_provider=self.auth_provider,",
            "                user=self.user,",
            "                ident=self.identity[\"id\"],",
            "                data=self.identity.get(\"data\", {}),",
            "            )",
            "        else:",
            "            auth_is_new = False",
            "",
            "            # TODO(dcramer): this might leave the user with duplicate accounts,",
            "            # and in that kind of situation its very reasonable that we could",
            "            # test email addresses + is_managed to determine if we can auto",
            "            # merge",
            "            if auth_identity.user != self.user:",
            "                wipe = self._wipe_existing_identity(auth_identity)",
            "            else:",
            "                wipe = None",
            "",
            "            now = timezone.now()",
            "            auth_identity.update(",
            "                user=self.user,",
            "                ident=self.identity[\"id\"],",
            "                data=self.provider.update_identity(",
            "                    new_data=self.identity.get(\"data\", {}), current_data=auth_identity.data",
            "                ),",
            "                last_verified=now,",
            "                last_synced=now,",
            "            )",
            "",
            "            logger.info(",
            "                \"sso.login-pipeline.attach-existing-identity\",",
            "                extra={",
            "                    \"wipe_result\": repr(wipe),",
            "                    \"organization_id\": self.organization.id,",
            "                    \"user_id\": self.user.id,",
            "                    \"auth_identity_user_id\": auth_identity.user.id,",
            "                    \"auth_provider_id\": self.auth_provider.id,",
            "                    \"idp_identity_id\": self.identity[\"id\"],",
            "                    \"idp_identity_email\": self.identity.get(\"email\"),",
            "                },",
            "            )",
            "",
            "        if member is None:",
            "            member = self._get_organization_member(auth_identity)",
            "        self._set_linked_flag(member)",
            "",
            "        if auth_is_new:",
            "            AuditLogEntry.objects.create(",
            "                organization=self.organization,",
            "                actor=self.user,",
            "                ip_address=self.request.META[\"REMOTE_ADDR\"],",
            "                target_object=auth_identity.id,",
            "                event=audit_log.get_event_id(\"SSO_IDENTITY_LINK\"),",
            "                data=auth_identity.get_audit_log_data(),",
            "            )",
            "",
            "            messages.add_message(self.request, messages.SUCCESS, OK_LINK_IDENTITY)",
            "",
            "        return auth_identity",
            "",
            "    def _wipe_existing_identity(self, auth_identity: AuthIdentity) -> Any:",
            "        # it's possible the user has an existing identity, let's wipe it out",
            "        # so that the new identifier gets used (other we'll hit a constraint)",
            "        # violation since one might exist for (provider, user) as well as",
            "        # (provider, ident)",
            "        deletion_result = (",
            "            AuthIdentity.objects.exclude(id=auth_identity.id)",
            "            .filter(auth_provider=self.auth_provider, user=self.user)",
            "            .delete()",
            "        )",
            "",
            "        # since we've identified an identity which is no longer valid",
            "        # lets preemptively mark it as such",
            "        try:",
            "            other_member = OrganizationMember.objects.get(",
            "                user=auth_identity.user_id, organization=self.organization",
            "            )",
            "        except OrganizationMember.DoesNotExist:",
            "            return",
            "        other_member.flags[\"sso:invalid\"] = True",
            "        other_member.flags[\"sso:linked\"] = False",
            "        other_member.save()",
            "",
            "        return deletion_result",
            "",
            "    def _get_organization_member(self, auth_identity: AuthIdentity) -> OrganizationMember:",
            "        \"\"\"",
            "        Check to see if the user has a member associated, if not, create a new membership",
            "        based on the auth_identity email.",
            "        \"\"\"",
            "        try:",
            "            return OrganizationMember.objects.get(user=self.user, organization=self.organization)",
            "        except OrganizationMember.DoesNotExist:",
            "            return self._handle_new_membership(auth_identity)",
            "",
            "    def _respond(",
            "        self,",
            "        template: str,",
            "        context: Mapping[str, Any] = None,",
            "        status: int = 200,",
            "    ) -> HttpResponse:",
            "        default_context = {\"organization\": self.organization}",
            "        if context:",
            "            default_context.update(context)",
            "",
            "        return render_to_response(template, default_context, self.request, status=status)",
            "",
            "    def _post_login_redirect(self) -> HttpResponseRedirect:",
            "        url = auth.get_login_redirect(self.request)",
            "        if self.request.POST.get(\"op\") == \"newuser\":",
            "            # add events that we can handle on the front end",
            "            provider = self.auth_provider.provider if self.auth_provider else None",
            "            params = {",
            "                \"frontend_events\": json.dumps({\"event_name\": \"Sign Up\", \"event_label\": provider})",
            "            }",
            "            url = add_params_to_url(url, params)",
            "        response = HttpResponseRedirect(url)",
            "",
            "        # Always remove any pending invite cookies, pending invites will have been",
            "        # accepted during the SSO flow.",
            "        remove_invite_details_from_session(self.request)",
            "",
            "        return response",
            "",
            "    def has_verified_account(self, verification_value: Dict[str, Any]) -> bool:",
            "        return (",
            "            verification_value[\"email\"] == self.identity[\"email\"]",
            "            and verification_value[\"user_id\"] == self.user.id",
            "        )",
            "",
            "    @property",
            "    def _logged_in_user(self) -> Optional[User]:",
            "        \"\"\"The user, if they have authenticated on this session.\"\"\"",
            "        return self.request.user if self.request.user.is_authenticated else None",
            "",
            "    @property",
            "    def _app_user(self) -> Optional[User]:",
            "        \"\"\"The user, if they are represented persistently in our app.\"\"\"",
            "        return self.user if isinstance(self.user, User) else None",
            "",
            "    def _has_usable_password(self):",
            "        return self._app_user and self._app_user.has_usable_password()",
            "",
            "    def handle_unknown_identity(",
            "        self,",
            "        state: AuthHelperSessionStore,",
            "    ) -> HttpResponseRedirect:",
            "        \"\"\"",
            "        Flow is activated upon a user logging in to where an AuthIdentity is",
            "        not present.",
            "",
            "        XXX(dcramer): this docstring is out of date",
            "",
            "        The flow will attempt to answer the following:",
            "",
            "        - Is there an existing user with the same email address? Should they be",
            "          merged?",
            "",
            "        - Is there an existing user (via authentication) that should be merged?",
            "",
            "        - Should I create a new user based on this identity?",
            "        \"\"\"",
            "        op = self.request.POST.get(\"op\")",
            "        login_form = (",
            "            None",
            "            if self._logged_in_user",
            "            else AuthenticationForm(",
            "                self.request,",
            "                self.request.POST if self.request.POST.get(\"op\") == \"login\" else None,",
            "                initial={\"username\": self._app_user and self._app_user.username},",
            "            )",
            "        )",
            "        # we don't trust all IDP email verification, so users can also confirm via one time email link",
            "        is_account_verified = False",
            "        if self.request.session.get(\"confirm_account_verification_key\"):",
            "            verification_key = self.request.session.get(\"confirm_account_verification_key\")",
            "            verification_value = get_verification_value_from_key(verification_key)",
            "            if verification_value:",
            "                is_account_verified = self.has_verified_account(verification_value)",
            "",
            "        is_new_account = not self.user.is_authenticated  # stateful",
            "        if self._app_user and self.identity.get(\"email_verified\") or is_account_verified:",
            "            # we only allow this flow to happen if the existing user has",
            "            # membership, otherwise we short circuit because it might be",
            "            # an attempt to hijack membership of another organization",
            "            has_membership = OrganizationMember.objects.filter(",
            "                user=self._app_user, organization=self.organization",
            "            ).exists()",
            "            if has_membership:",
            "                try:",
            "                    self._login(self.user)",
            "                except self._NotCompletedSecurityChecks:",
            "                    # adding is_account_verified to the check below in order to redirect",
            "                    # to 2fa when the user migrates their idp but has 2fa enabled,",
            "                    # otherwise it would stop them from linking their sso provider",
            "                    if self._has_usable_password() or is_account_verified:",
            "                        return self._post_login_redirect()",
            "                    else:",
            "                        is_new_account = True",
            "                else:",
            "                    # assume they've confirmed they want to attach the identity",
            "                    op = \"confirm\"",
            "            elif is_account_verified:",
            "                op = \"confirm\"",
            "            else:",
            "                # force them to create a new account",
            "                is_new_account = True",
            "        # without a usable password they can't login, so default to a new account",
            "        elif not self._has_usable_password():",
            "            is_new_account = True",
            "",
            "        auth_identity = None",
            "        if op == \"confirm\" and self.user.is_authenticated or is_account_verified:",
            "            auth_identity = self.handle_attach_identity()",
            "        elif op == \"newuser\":",
            "            auth_identity = self.handle_new_user()",
            "        elif op == \"login\" and not self._logged_in_user:",
            "            # confirm authentication, login",
            "            op = None",
            "            if login_form.is_valid():",
            "                # This flow is special.  If we are going through a 2FA",
            "                # flow here (login returns False) we want to instruct the",
            "                # system to return upon completion of the 2fa flow to the",
            "                # current URL and continue with the dialog.",
            "                #",
            "                # If there is no 2fa we don't need to do this and can just",
            "                # go on.",
            "                try:",
            "                    self._login(login_form.get_user())",
            "                except self._NotCompletedSecurityChecks:",
            "                    return self._post_login_redirect()",
            "            else:",
            "                auth.log_auth_failure(self.request, self.request.POST.get(\"username\"))",
            "        else:",
            "            op = None",
            "",
            "        if not op:",
            "            existing_user, template = self._dispatch_to_confirmation(is_new_account)",
            "",
            "            context = {",
            "                \"identity\": self.identity,",
            "                \"provider\": self.provider_name,",
            "                \"identity_display_name\": self.identity.get(\"name\") or self.identity.get(\"email\"),",
            "                \"identity_identifier\": self.identity.get(\"email\") or self.identity.get(\"id\"),",
            "                \"existing_user\": existing_user,",
            "            }",
            "            if login_form:",
            "                context[\"login_form\"] = login_form",
            "            return self._respond(f\"sentry/{template}.html\", context)",
            "",
            "        user = auth_identity.user",
            "        user.backend = settings.AUTHENTICATION_BACKENDS[0]",
            "",
            "        # XXX(dcramer): this is repeated from above",
            "        try:",
            "            self._login(user)",
            "        except self._NotCompletedSecurityChecks:",
            "            return self._post_login_redirect()",
            "",
            "        state.clear()",
            "",
            "        if not is_active_superuser(self.request):",
            "            auth.set_active_org(self.request, self.organization.slug)",
            "        return self._post_login_redirect()",
            "",
            "    @property",
            "    def provider_name(self):",
            "        if self.auth_provider:",
            "            return self.auth_provider.provider_name",
            "        else:",
            "            # A blank character is needed to prevent an HTML span from collapsing",
            "            return \" \"",
            "",
            "    def _dispatch_to_confirmation(self, is_new_account: bool) -> Tuple[Optional[User], str]:",
            "        if self._logged_in_user:",
            "            return self._logged_in_user, \"auth-confirm-link\"",
            "",
            "        if self._app_user and not self._has_usable_password():",
            "            send_one_time_account_confirm_link(",
            "                self._app_user,",
            "                self.organization,",
            "                self.auth_provider,",
            "                self.identity[\"email\"],",
            "                self.identity[\"id\"],",
            "            )",
            "            return self.user, \"auth-confirm-account\"",
            "",
            "        self.request.session.set_test_cookie()",
            "        return None if is_new_account else self.user, \"auth-confirm-identity\"",
            "",
            "    def handle_new_user(self) -> AuthIdentity:",
            "        user = User.objects.create(",
            "            username=uuid4().hex,",
            "            email=self.identity[\"email\"],",
            "            name=self.identity.get(\"name\", \"\")[:200],",
            "        )",
            "",
            "        if settings.TERMS_URL and settings.PRIVACY_URL:",
            "            user.update(flags=F(\"flags\").bitor(User.flags.newsletter_consent_prompt))",
            "",
            "        try:",
            "            with transaction.atomic():",
            "                auth_identity = AuthIdentity.objects.create(",
            "                    auth_provider=self.auth_provider,",
            "                    user=user,",
            "                    ident=self.identity[\"id\"],",
            "                    data=self.identity.get(\"data\", {}),",
            "                )",
            "        except IntegrityError:",
            "            auth_identity = self._get_auth_identity(ident=self.identity[\"id\"])",
            "            auth_identity.update(user=user, data=self.identity.get(\"data\", {}))",
            "",
            "        user.send_confirm_emails(is_new_user=True)",
            "        provider = self.auth_provider.provider if self.auth_provider else None",
            "        user_signup.send_robust(",
            "            sender=self.handle_new_user,",
            "            user=user,",
            "            source=\"sso\",",
            "            provider=provider,",
            "            referrer=\"in-app\",",
            "        )",
            "",
            "        self._handle_new_membership(auth_identity)",
            "",
            "        return auth_identity",
            "",
            "",
            "class AuthHelper(Pipeline):",
            "    \"\"\"",
            "    Helper class which is passed into AuthView's.",
            "",
            "    Designed to link provider and views as well as manage the state and",
            "    pipeline. The pipeline is optional, in case can be done",
            "",
            "    Auth has several flows:",
            "",
            "    1. The user is going through provider setup, thus enforcing that they link",
            "       their current account to the new auth identity.",
            "    2. The user is anonymous and creating a brand new account.",
            "    3. The user is anonymous and logging into an existing account.",
            "    4. The user is anonymous and creating a brand new account, but may have an",
            "       existing account that should/could be merged.",
            "    5. The user is authenticated and creating a new identity, thus associating",
            "       it with their current account.",
            "    6. The user is authenticated and creating a new identity, but not linking",
            "       it with their account (thus creating a new account).",
            "    \"\"\"",
            "",
            "    # logging in or registering",
            "    FLOW_LOGIN = 1",
            "    # configuring the provider",
            "    FLOW_SETUP_PROVIDER = 2",
            "",
            "    pipeline_name = \"pipeline\"",
            "    provider_manager = manager",
            "    provider_model_cls = AuthProvider",
            "    session_store_cls = AuthHelperSessionStore",
            "",
            "    @classmethod",
            "    def get_for_request(cls, request):",
            "        req_state = cls.unpack_state(request)",
            "        if not req_state:",
            "            return None",
            "",
            "        if not req_state.organization:",
            "            logging.info(\"Invalid SSO data found\")",
            "            return None",
            "        flow = req_state.state.flow",
            "",
            "        return cls(",
            "            request,",
            "            req_state.organization,",
            "            flow,",
            "            auth_provider=req_state.provider_model,",
            "            provider_key=req_state.provider_key,",
            "        )",
            "",
            "    def __init__(self, request, organization, flow, auth_provider=None, provider_key=None):",
            "        assert provider_key or auth_provider",
            "        self.flow = flow",
            "        super().__init__(request, provider_key, organization, auth_provider)",
            "",
            "    def get_provider(self, provider_key):",
            "        if self.provider_model:",
            "            return self.provider_model.get_provider()",
            "        elif provider_key:",
            "            return super().get_provider(provider_key)",
            "        else:",
            "            raise NotImplementedError",
            "",
            "    def get_pipeline_views(self):",
            "        if self.flow == self.FLOW_LOGIN:",
            "            return self.provider.get_auth_pipeline()",
            "        elif self.flow == self.FLOW_SETUP_PROVIDER:",
            "            return self.provider.get_setup_pipeline()",
            "        else:",
            "            raise NotImplementedError",
            "",
            "    def is_valid(self):",
            "        return super().is_valid() and self.state.flow in (self.FLOW_LOGIN, self.FLOW_SETUP_PROVIDER)",
            "",
            "    def get_initial_state(self):",
            "        state = super().get_initial_state()",
            "        state.update({\"flow\": self.flow})",
            "        return state",
            "",
            "    def get_redirect_url(self):",
            "        return absolute_uri(reverse(\"sentry-auth-sso\"))",
            "",
            "    def dispatch_to(self, step: View):",
            "        return step.dispatch(request=self.request, helper=self)",
            "",
            "    def finish_pipeline(self):",
            "        data = self.fetch_state()",
            "",
            "        # The state data may have expired, in which case the state data will",
            "        # simply be None.",
            "        if not data:",
            "            return self.error(ERR_INVALID_IDENTITY)",
            "",
            "        try:",
            "            identity = self.provider.build_identity(data)",
            "        except IdentityNotValid as error:",
            "            return self.error(str(error) or ERR_INVALID_IDENTITY)",
            "",
            "        if self.state.flow == self.FLOW_LOGIN:",
            "            # create identity and authenticate the user",
            "            response = self._finish_login_pipeline(identity)",
            "        elif self.state.flow == self.FLOW_SETUP_PROVIDER:",
            "            response = self._finish_setup_pipeline(identity)",
            "        else:",
            "            raise Exception(f\"Unrecognized flow value: {self.state.flow}\")",
            "",
            "        return response",
            "",
            "    def auth_handler(self, identity: Mapping[str, Any]):",
            "        return AuthIdentityHandler(",
            "            self.provider_model, self.provider, self.organization, self.request, identity",
            "        )",
            "",
            "    @transaction.atomic",
            "    def _finish_login_pipeline(self, identity: Mapping[str, Any]):",
            "        \"\"\"",
            "        The login flow executes both with anonymous and authenticated users.",
            "",
            "        Upon completion a few branches exist:",
            "",
            "        If the identity is already linked, the user should be logged in",
            "        and redirected immediately.",
            "",
            "        Otherwise, the user is presented with a confirmation window. That window",
            "        will show them the new account that will be created, and if they're",
            "        already authenticated an optional button to associate the identity with",
            "        their account.",
            "        \"\"\"",
            "        auth_provider = self.provider_model",
            "        user_id = identity[\"id\"]",
            "",
            "        lock = locks.get(",
            "            f\"sso:auth:{auth_provider.id}:{md5_text(user_id).hexdigest()}\",",
            "            duration=5,",
            "            name=\"sso_auth\",",
            "        )",
            "        with TimedRetryPolicy(5)(lock.acquire):",
            "            try:",
            "                auth_identity = AuthIdentity.objects.select_related(\"user\").get(",
            "                    auth_provider=auth_provider, ident=user_id",
            "                )",
            "            except AuthIdentity.DoesNotExist:",
            "                auth_identity = None",
            "",
            "            # Handle migration of identity keys",
            "            if not auth_identity and isinstance(user_id, MigratingIdentityId):",
            "                try:",
            "                    auth_identity = AuthIdentity.objects.select_related(\"user\").get(",
            "                        auth_provider=auth_provider, ident=user_id.legacy_id",
            "                    )",
            "                    auth_identity.update(ident=user_id.id)",
            "                except AuthIdentity.DoesNotExist:",
            "                    auth_identity = None",
            "",
            "            auth_handler = self.auth_handler(identity)",
            "            if not auth_identity:",
            "                return auth_handler.handle_unknown_identity(self.state)",
            "",
            "            # If the User attached to this AuthIdentity is not active,",
            "            # we want to clobber the old account and take it over, rather than",
            "            # getting logged into the inactive account.",
            "            if not auth_identity.user.is_active:",
            "                # Current user is also not logged in, so we have to",
            "                # assume unknown.",
            "                if not self.request.user.is_authenticated:",
            "                    return auth_handler.handle_unknown_identity(self.state)",
            "                auth_identity = auth_handler.handle_attach_identity()",
            "",
            "            return auth_handler.handle_existing_identity(self.state, auth_identity)",
            "",
            "    @transaction.atomic",
            "    def _finish_setup_pipeline(self, identity: Mapping[str, Any]):",
            "        \"\"\"",
            "        The setup flow creates the auth provider as well as an identity linked",
            "        to the active user.",
            "        \"\"\"",
            "        request = self.request",
            "        if not request.user.is_authenticated:",
            "            return self.error(ERR_NOT_AUTHED)",
            "",
            "        if request.user.id != self.state.uid:",
            "            return self.error(ERR_UID_MISMATCH)",
            "",
            "        data = self.fetch_state()",
            "        config = self.provider.build_config(data)",
            "",
            "        try:",
            "            om = OrganizationMember.objects.get(user=request.user, organization=self.organization)",
            "        except OrganizationMember.DoesNotExist:",
            "            return self.error(ERR_UID_MISMATCH)",
            "",
            "        # disable require 2FA for the organization",
            "        # since only SSO or require 2FA can be enabled",
            "        self.disable_2fa_required()",
            "",
            "        self.provider_model = AuthProvider.objects.create(",
            "            organization=self.organization, provider=self.provider.key, config=config",
            "        )",
            "",
            "        self.auth_handler(identity).handle_attach_identity(om)",
            "",
            "        auth.mark_sso_complete(request, self.organization.id)",
            "",
            "        sso_enabled.send_robust(",
            "            organization=self.organization,",
            "            user=request.user,",
            "            provider=self.provider.key,",
            "            sender=self.__class__,",
            "        )",
            "",
            "        AuditLogEntry.objects.create(",
            "            organization=self.organization,",
            "            actor=request.user,",
            "            ip_address=request.META[\"REMOTE_ADDR\"],",
            "            target_object=self.provider_model.id,",
            "            event=audit_log.get_event_id(\"SSO_ENABLE\"),",
            "            data=self.provider_model.get_audit_log_data(),",
            "        )",
            "",
            "        email_missing_links.delay(self.organization.id, request.user.id, self.provider.key)",
            "",
            "        messages.add_message(self.request, messages.SUCCESS, OK_SETUP_SSO)",
            "",
            "        self.clear_session()",
            "",
            "        next_uri = reverse(",
            "            \"sentry-organization-auth-provider-settings\", args=[self.organization.slug]",
            "        )",
            "        return HttpResponseRedirect(next_uri)",
            "",
            "    def error(self, message):",
            "        redirect_uri = \"/\"",
            "",
            "        if self.state.flow == self.FLOW_LOGIN:",
            "            # create identity and authenticate the user",
            "            redirect_uri = reverse(\"sentry-auth-organization\", args=[self.organization.slug])",
            "",
            "        elif self.state.flow == self.FLOW_SETUP_PROVIDER:",
            "            redirect_uri = reverse(",
            "                \"sentry-organization-auth-settings\", args=[self.organization.slug]",
            "            )",
            "",
            "        if redirect_uri == \"/\":",
            "            metrics.incr(",
            "                \"sso.error\",",
            "                tags={",
            "                    \"flow\": self.state.flow,",
            "                    \"provider\": self.provider.key,",
            "                    \"organization_id\": self.organization.id,",
            "                    \"user_id\": self.request.user.id,",
            "                },",
            "                skip_internal=False,",
            "                sample_rate=1.0,",
            "            )",
            "        else:",
            "            metrics.incr(",
            "                \"sso.exit\",",
            "                tags={",
            "                    \"flow\": self.state.flow,",
            "                    \"provider\": self.provider.key,",
            "                    \"organization_id\": self.organization.id,",
            "                    \"user_id\": self.request.user.id,",
            "                },",
            "                skip_internal=False,",
            "                sample_rate=1.0,",
            "            )",
            "",
            "        # NOTE: Does NOT necessarily indicate a login _failure_",
            "        logger.warning(",
            "            \"sso.login-pipeline.error\",",
            "            extra={",
            "                \"flow\": self.state.flow,",
            "                \"provider\": self.provider.key,",
            "                \"organization_id\": self.organization.id,",
            "                \"user_id\": self.request.user.id,",
            "                \"error_message\": message,",
            "            },",
            "        )",
            "",
            "        messages.add_message(self.request, messages.ERROR, f\"Authentication error: {message}\")",
            "",
            "        return HttpResponseRedirect(redirect_uri)",
            "",
            "    def disable_2fa_required(self):",
            "        require_2fa = self.organization.flags.require_2fa",
            "",
            "        if not require_2fa or not require_2fa.is_set:",
            "            return",
            "",
            "        self.organization.update(flags=F(\"flags\").bitand(~Organization.flags.require_2fa))",
            "",
            "        logger.info(",
            "            \"Require 2fa disabled during sso setup\", extra={\"organization_id\": self.organization.id}",
            "        )",
            "        create_audit_entry(",
            "            request=self.request,",
            "            organization=self.organization,",
            "            target_object=self.organization.id,",
            "            event=audit_log.get_event_id(\"ORG_EDIT\"),",
            "            data={\"require_2fa\": \"to False when enabling SSO\"},",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [],
            "222": [
                "AuthIdentityHandler",
                "_handle_new_membership"
            ],
            "224": [
                "AuthIdentityHandler",
                "_handle_new_membership"
            ],
            "409": [
                "AuthIdentityHandler",
                "_post_login_redirect"
            ]
        },
        "addLocation": []
    },
    "src/sentry/web/frontend/auth_login.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from rest_framework.request import Request"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from rest_framework.response import Response"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sentry.api.invite_helper import ApiInviteHelper, remove_invite_cookie"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from sentry.api.invite_helper import ApiInviteHelper, remove_invite_details_from_session"
            },
            "5": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from sentry.auth.superuser import is_active_superuser"
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from sentry.constants import WARN_SESSION_EXPIRED"
            },
            "7": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from sentry.http import get_server_hostname"
            },
            "8": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "             request.session.pop(\"invite_email\", None)"
            },
            "9": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "             # Attempt to directly accept any pending invites"
            },
            "11": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            invite_helper = ApiInviteHelper.from_cookie(request=request, instance=self)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            invite_helper = ApiInviteHelper.from_session(request=request, instance=self)"
            },
            "13": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             # In single org mode, associate the user to the only organization."
            },
            "15": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "             #"
            },
            "16": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "             if invite_helper and invite_helper.valid_request:"
            },
            "17": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "                 invite_helper.accept_invite()"
            },
            "18": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "                 response = self.redirect_to_org(request)"
            },
            "19": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                remove_invite_cookie(request, response)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+                remove_invite_details_from_session(request)"
            },
            "21": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "                 return response"
            },
            "23": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from typing import Optional",
            "",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.auth import REDIRECT_FIELD_NAME",
            "from django.db import transaction",
            "from django.http import HttpResponseRedirect",
            "from django.urls import reverse",
            "from django.utils.translation import ugettext_lazy as _",
            "from django.views.decorators.cache import never_cache",
            "from rest_framework.request import Request",
            "from rest_framework.response import Response",
            "",
            "from sentry.api.invite_helper import ApiInviteHelper, remove_invite_cookie",
            "from sentry.auth.superuser import is_active_superuser",
            "from sentry.constants import WARN_SESSION_EXPIRED",
            "from sentry.http import get_server_hostname",
            "from sentry.models import AuthProvider, Organization, OrganizationMember, OrganizationStatus",
            "from sentry.services.hybrid_cloud.organization import organization_service",
            "from sentry.signals import join_request_link_viewed, user_signup",
            "from sentry.utils import auth, json, metrics",
            "from sentry.utils.auth import (",
            "    get_login_redirect,",
            "    has_user_registration,",
            "    initiate_login,",
            "    is_valid_redirect,",
            "    login,",
            ")",
            "from sentry.utils.client_state import get_client_state_redirect_uri",
            "from sentry.utils.sdk import capture_exception",
            "from sentry.utils.urls import add_params_to_url",
            "from sentry.web.forms.accounts import AuthenticationForm, RegistrationForm",
            "from sentry.web.frontend.base import BaseView",
            "",
            "ERR_NO_SSO = _(\"The organization does not exist or does not have Single Sign-On enabled.\")",
            "",
            "",
            "# Stores callbacks that are called to get additional template context data before the login page",
            "# is rendered. Callbacks are called in any order. If an error is encountered in a callback it is",
            "# ignored. This works like HookStore in Javascript.",
            "class AdditionalContext:",
            "    def __init__(self):",
            "        self._callbacks = set()",
            "",
            "    def add_callback(self, callback):",
            "        \"\"\"callback should take a request object and return a dict of key-value pairs",
            "        to add to the context.\"\"\"",
            "        self._callbacks.add(callback)",
            "",
            "    def run_callbacks(self, request: Request):",
            "        context = {}",
            "        for cb in self._callbacks:",
            "            try:",
            "                result = cb(request)",
            "                context.update(result)",
            "            except Exception:",
            "                capture_exception()",
            "        return context",
            "",
            "",
            "additional_context = AdditionalContext()",
            "",
            "",
            "class AuthLoginView(BaseView):",
            "    auth_required = False",
            "",
            "    def get_auth_provider(self, organization_slug):",
            "        try:",
            "            organization = Organization.objects.get(",
            "                slug=organization_slug, status=OrganizationStatus.VISIBLE",
            "            )",
            "        except Organization.DoesNotExist:",
            "            return None",
            "",
            "        try:",
            "            auth_provider = AuthProvider.objects.get(organization=organization)",
            "        except AuthProvider.DoesNotExist:",
            "            return None",
            "",
            "        return auth_provider",
            "",
            "    def get_login_form(self, request: Request):",
            "        op = request.POST.get(\"op\")",
            "        return AuthenticationForm(request, request.POST if op == \"login\" else None)",
            "",
            "    def get_register_form(self, request: Request, initial=None):",
            "        op = request.POST.get(\"op\")",
            "        return RegistrationForm(",
            "            request.POST if op == \"register\" else None,",
            "            initial=initial,",
            "            # Custom auto_id to avoid ID collision with AuthenticationForm.",
            "            auto_id=\"id_registration_%s\",",
            "        )",
            "",
            "    def can_register(self, request: Request):",
            "        return bool(has_user_registration() or request.session.get(\"can_register\"))",
            "",
            "    def get_join_request_link(self, organization):",
            "        if not organization:",
            "            return None",
            "",
            "        if organization.get_option(\"sentry:join_requests\") is False:",
            "            return None",
            "",
            "        join_request_link_viewed.send_robust(sender=self, organization=organization)",
            "",
            "        return reverse(\"sentry-join-request\", args=[organization.slug])",
            "",
            "    def get_next_uri(self, request: Request):",
            "        next_uri_fallback = None",
            "        if request.session.get(\"_next\") is not None:",
            "            next_uri_fallback = request.session.pop(\"_next\")",
            "        return request.GET.get(REDIRECT_FIELD_NAME, next_uri_fallback)",
            "",
            "    def get_post_register_url(self, request: Request):",
            "        base_url = auth.get_login_redirect(request)",
            "        params = {\"frontend_events\": json.dumps({\"event_name\": \"Sign Up\"})}",
            "        return add_params_to_url(base_url, params)",
            "",
            "    def respond_login(self, request: Request, context, **kwargs):",
            "        return self.respond(\"sentry/login.html\", context)",
            "",
            "    def _handle_login(self, request: Request, user, organization: Optional[Organization]):",
            "        login(request, user, organization_id=organization.id if organization else None)",
            "        self.determine_active_organization(",
            "            request,",
            "        )",
            "",
            "    def handle_basic_auth(self, request: Request, **kwargs):",
            "        can_register = self.can_register(request)",
            "",
            "        op = request.POST.get(\"op\")",
            "        organization = kwargs.pop(\"organization\", None)",
            "",
            "        if not op:",
            "            # Detect that we are on the register page by url /register/ and",
            "            # then activate the register tab by default.",
            "            if \"/register\" in request.path_info and can_register:",
            "                op = \"register\"",
            "            elif request.GET.get(\"op\") == \"sso\":",
            "                op = \"sso\"",
            "",
            "        # login_form either validated on post or renders form fields for GET",
            "        login_form = self.get_login_form(request)",
            "        if can_register:",
            "            register_form = self.get_register_form(",
            "                request, initial={\"username\": request.session.get(\"invite_email\", \"\")}",
            "            )",
            "        else:",
            "            register_form = None",
            "",
            "        if can_register and register_form.is_valid():",
            "            user = register_form.save()",
            "            user.send_confirm_emails(is_new_user=True)",
            "            user_signup.send_robust(",
            "                sender=self, user=user, source=\"register-form\", referrer=\"in-app\"",
            "            )",
            "",
            "            # HACK: grab whatever the first backend is and assume it works",
            "            user.backend = settings.AUTHENTICATION_BACKENDS[0]",
            "",
            "            self._handle_login(request, user, organization)",
            "",
            "            # can_register should only allow a single registration",
            "            request.session.pop(\"can_register\", None)",
            "            request.session.pop(\"invite_email\", None)",
            "",
            "            # Attempt to directly accept any pending invites",
            "            invite_helper = ApiInviteHelper.from_cookie(request=request, instance=self)",
            "",
            "            # In single org mode, associate the user to the only organization.",
            "            #",
            "            # XXX: Only do this if there isn't a pending invitation. The user",
            "            # may need to configure 2FA in which case, we don't want to make",
            "            # the association for them.",
            "            if settings.SENTRY_SINGLE_ORGANIZATION and not invite_helper:",
            "                organization = Organization.get_default()",
            "                OrganizationMember.objects.create(",
            "                    organization=organization, role=organization.default_role, user=user",
            "                )",
            "",
            "            if invite_helper and invite_helper.valid_request:",
            "                invite_helper.accept_invite()",
            "                response = self.redirect_to_org(request)",
            "                remove_invite_cookie(request, response)",
            "",
            "                return response",
            "",
            "            return self.redirect(self.get_post_register_url(request))",
            "",
            "        elif request.method == \"POST\":",
            "            from sentry import ratelimits as ratelimiter",
            "            from sentry.utils.hashlib import md5_text",
            "",
            "            login_attempt = (",
            "                op == \"login\" and request.POST.get(\"username\") and request.POST.get(\"password\")",
            "            )",
            "",
            "            if login_attempt and ratelimiter.is_limited(",
            "                \"auth:login:username:{}\".format(",
            "                    md5_text(login_form.clean_username(request.POST[\"username\"])).hexdigest()",
            "                ),",
            "                limit=5,",
            "                window=60,  # 5 per minute should be enough for anyone",
            "            ):",
            "                login_form.errors[\"__all__\"] = [",
            "                    \"You have made too many login attempts. Please try again later.\"",
            "                ]",
            "                metrics.incr(",
            "                    \"login.attempt\", instance=\"rate_limited\", skip_internal=True, sample_rate=1.0",
            "                )",
            "            elif login_form.is_valid():",
            "                user = login_form.get_user()",
            "",
            "                self._handle_login(request, user, organization)",
            "                metrics.incr(",
            "                    \"login.attempt\", instance=\"success\", skip_internal=True, sample_rate=1.0",
            "                )",
            "",
            "                if not user.is_active:",
            "                    return self.redirect(reverse(\"sentry-reactivate-account\"))",
            "                if organization:",
            "                    # Refresh the organization we fetched prior to login in order to check its login state.",
            "                    org_context = organization_service.get_organization_by_slug(",
            "                        user_id=request.user.id,",
            "                        slug=organization.slug,",
            "                        only_visible=False,",
            "                    )",
            "                    if org_context:",
            "                        if org_context.member and request.user and not is_active_superuser(request):",
            "                            auth.set_active_org(request, org_context.organization.slug)",
            "",
            "                        if settings.SENTRY_SINGLE_ORGANIZATION:",
            "                            om = organization_service.check_membership_by_email(",
            "                                org_context.organization.id, user.email",
            "                            )",
            "                            if om is None:",
            "                                request.session.pop(\"_next\", None)",
            "                            else:",
            "                                if om.user_id is None:",
            "                                    request.session.pop(\"_next\", None)",
            "",
            "                # On login, redirect to onboarding",
            "                if self.active_organization:",
            "                    onboarding_redirect = get_client_state_redirect_uri(",
            "                        self.active_organization.organization.slug, None",
            "                    )",
            "                    if onboarding_redirect:",
            "                        request.session[\"_next\"] = onboarding_redirect",
            "",
            "                return self.redirect(get_login_redirect(request))",
            "            else:",
            "                metrics.incr(",
            "                    \"login.attempt\", instance=\"failure\", skip_internal=True, sample_rate=1.0",
            "                )",
            "",
            "        context = {",
            "            \"op\": op or \"login\",",
            "            \"server_hostname\": get_server_hostname(),",
            "            \"login_form\": login_form,",
            "            \"organization\": organization,",
            "            \"register_form\": register_form,",
            "            \"CAN_REGISTER\": can_register,",
            "            \"join_request_link\": self.get_join_request_link(organization),",
            "            \"show_session_replay_banner\": settings.SHOW_SESSION_REPLAY_BANNER,",
            "        }",
            "",
            "        context.update(additional_context.run_callbacks(request))",
            "        return self.respond_login(request, context, **kwargs)",
            "",
            "    def handle_authenticated(self, request: Request):",
            "        next_uri = self.get_next_uri(request)",
            "        if is_valid_redirect(next_uri, allowed_hosts=(request.get_host(),)):",
            "            return self.redirect(next_uri)",
            "        return self.redirect_to_org(request)",
            "",
            "    @never_cache",
            "    @transaction.atomic",
            "    def handle(self, request: Request, *args, **kwargs) -> Response:",
            "        return super().handle(request, *args, **kwargs)",
            "",
            "    # XXX(dcramer): OAuth provider hooks this view",
            "    def get(self, request: Request, **kwargs) -> Response:",
            "        next_uri = self.get_next_uri(request)",
            "        if request.user.is_authenticated:",
            "            return self.handle_authenticated(request)",
            "",
            "        request.session.set_test_cookie()",
            "",
            "        # we always reset the state on GET so you don't end up at an odd location",
            "        initiate_login(request, next_uri)",
            "",
            "        # Single org mode -- send them to the org-specific handler",
            "        if settings.SENTRY_SINGLE_ORGANIZATION:",
            "            org = Organization.get_default()",
            "            next_uri = reverse(\"sentry-auth-organization\", args=[org.slug])",
            "            return HttpResponseRedirect(next_uri)",
            "",
            "        session_expired = \"session_expired\" in request.COOKIES",
            "        if session_expired:",
            "            messages.add_message(request, messages.WARNING, WARN_SESSION_EXPIRED)",
            "",
            "        response = self.handle_basic_auth(request, **kwargs)",
            "",
            "        if session_expired:",
            "            response.delete_cookie(\"session_expired\")",
            "",
            "        return response",
            "",
            "    # XXX(dcramer): OAuth provider hooks this view",
            "    def post(self, request: Request, **kwargs) -> Response:",
            "        op = request.POST.get(\"op\")",
            "        if op == \"sso\" and request.POST.get(\"organization\"):",
            "            # if post is from \"Single Sign On tab\"",
            "            auth_provider = self.get_auth_provider(request.POST[\"organization\"])",
            "            if auth_provider:",
            "                next_uri = reverse(\"sentry-auth-organization\", args=[request.POST[\"organization\"]])",
            "            else:",
            "                # Redirect to the org login route",
            "                next_uri = request.get_full_path()",
            "                messages.add_message(request, messages.ERROR, ERR_NO_SSO)",
            "",
            "            return HttpResponseRedirect(next_uri)",
            "",
            "        return self.handle_basic_auth(request, **kwargs)"
        ],
        "afterPatchFile": [
            "from typing import Optional",
            "",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.auth import REDIRECT_FIELD_NAME",
            "from django.db import transaction",
            "from django.http import HttpResponseRedirect",
            "from django.urls import reverse",
            "from django.utils.translation import ugettext_lazy as _",
            "from django.views.decorators.cache import never_cache",
            "from rest_framework.request import Request",
            "from rest_framework.response import Response",
            "",
            "from sentry.api.invite_helper import ApiInviteHelper, remove_invite_details_from_session",
            "from sentry.auth.superuser import is_active_superuser",
            "from sentry.constants import WARN_SESSION_EXPIRED",
            "from sentry.http import get_server_hostname",
            "from sentry.models import AuthProvider, Organization, OrganizationMember, OrganizationStatus",
            "from sentry.services.hybrid_cloud.organization import organization_service",
            "from sentry.signals import join_request_link_viewed, user_signup",
            "from sentry.utils import auth, json, metrics",
            "from sentry.utils.auth import (",
            "    get_login_redirect,",
            "    has_user_registration,",
            "    initiate_login,",
            "    is_valid_redirect,",
            "    login,",
            ")",
            "from sentry.utils.client_state import get_client_state_redirect_uri",
            "from sentry.utils.sdk import capture_exception",
            "from sentry.utils.urls import add_params_to_url",
            "from sentry.web.forms.accounts import AuthenticationForm, RegistrationForm",
            "from sentry.web.frontend.base import BaseView",
            "",
            "ERR_NO_SSO = _(\"The organization does not exist or does not have Single Sign-On enabled.\")",
            "",
            "",
            "# Stores callbacks that are called to get additional template context data before the login page",
            "# is rendered. Callbacks are called in any order. If an error is encountered in a callback it is",
            "# ignored. This works like HookStore in Javascript.",
            "class AdditionalContext:",
            "    def __init__(self):",
            "        self._callbacks = set()",
            "",
            "    def add_callback(self, callback):",
            "        \"\"\"callback should take a request object and return a dict of key-value pairs",
            "        to add to the context.\"\"\"",
            "        self._callbacks.add(callback)",
            "",
            "    def run_callbacks(self, request: Request):",
            "        context = {}",
            "        for cb in self._callbacks:",
            "            try:",
            "                result = cb(request)",
            "                context.update(result)",
            "            except Exception:",
            "                capture_exception()",
            "        return context",
            "",
            "",
            "additional_context = AdditionalContext()",
            "",
            "",
            "class AuthLoginView(BaseView):",
            "    auth_required = False",
            "",
            "    def get_auth_provider(self, organization_slug):",
            "        try:",
            "            organization = Organization.objects.get(",
            "                slug=organization_slug, status=OrganizationStatus.VISIBLE",
            "            )",
            "        except Organization.DoesNotExist:",
            "            return None",
            "",
            "        try:",
            "            auth_provider = AuthProvider.objects.get(organization=organization)",
            "        except AuthProvider.DoesNotExist:",
            "            return None",
            "",
            "        return auth_provider",
            "",
            "    def get_login_form(self, request: Request):",
            "        op = request.POST.get(\"op\")",
            "        return AuthenticationForm(request, request.POST if op == \"login\" else None)",
            "",
            "    def get_register_form(self, request: Request, initial=None):",
            "        op = request.POST.get(\"op\")",
            "        return RegistrationForm(",
            "            request.POST if op == \"register\" else None,",
            "            initial=initial,",
            "            # Custom auto_id to avoid ID collision with AuthenticationForm.",
            "            auto_id=\"id_registration_%s\",",
            "        )",
            "",
            "    def can_register(self, request: Request):",
            "        return bool(has_user_registration() or request.session.get(\"can_register\"))",
            "",
            "    def get_join_request_link(self, organization):",
            "        if not organization:",
            "            return None",
            "",
            "        if organization.get_option(\"sentry:join_requests\") is False:",
            "            return None",
            "",
            "        join_request_link_viewed.send_robust(sender=self, organization=organization)",
            "",
            "        return reverse(\"sentry-join-request\", args=[organization.slug])",
            "",
            "    def get_next_uri(self, request: Request):",
            "        next_uri_fallback = None",
            "        if request.session.get(\"_next\") is not None:",
            "            next_uri_fallback = request.session.pop(\"_next\")",
            "        return request.GET.get(REDIRECT_FIELD_NAME, next_uri_fallback)",
            "",
            "    def get_post_register_url(self, request: Request):",
            "        base_url = auth.get_login_redirect(request)",
            "        params = {\"frontend_events\": json.dumps({\"event_name\": \"Sign Up\"})}",
            "        return add_params_to_url(base_url, params)",
            "",
            "    def respond_login(self, request: Request, context, **kwargs):",
            "        return self.respond(\"sentry/login.html\", context)",
            "",
            "    def _handle_login(self, request: Request, user, organization: Optional[Organization]):",
            "        login(request, user, organization_id=organization.id if organization else None)",
            "        self.determine_active_organization(",
            "            request,",
            "        )",
            "",
            "    def handle_basic_auth(self, request: Request, **kwargs):",
            "        can_register = self.can_register(request)",
            "",
            "        op = request.POST.get(\"op\")",
            "        organization = kwargs.pop(\"organization\", None)",
            "",
            "        if not op:",
            "            # Detect that we are on the register page by url /register/ and",
            "            # then activate the register tab by default.",
            "            if \"/register\" in request.path_info and can_register:",
            "                op = \"register\"",
            "            elif request.GET.get(\"op\") == \"sso\":",
            "                op = \"sso\"",
            "",
            "        # login_form either validated on post or renders form fields for GET",
            "        login_form = self.get_login_form(request)",
            "        if can_register:",
            "            register_form = self.get_register_form(",
            "                request, initial={\"username\": request.session.get(\"invite_email\", \"\")}",
            "            )",
            "        else:",
            "            register_form = None",
            "",
            "        if can_register and register_form.is_valid():",
            "            user = register_form.save()",
            "            user.send_confirm_emails(is_new_user=True)",
            "            user_signup.send_robust(",
            "                sender=self, user=user, source=\"register-form\", referrer=\"in-app\"",
            "            )",
            "",
            "            # HACK: grab whatever the first backend is and assume it works",
            "            user.backend = settings.AUTHENTICATION_BACKENDS[0]",
            "",
            "            self._handle_login(request, user, organization)",
            "",
            "            # can_register should only allow a single registration",
            "            request.session.pop(\"can_register\", None)",
            "            request.session.pop(\"invite_email\", None)",
            "",
            "            # Attempt to directly accept any pending invites",
            "            invite_helper = ApiInviteHelper.from_session(request=request, instance=self)",
            "",
            "            # In single org mode, associate the user to the only organization.",
            "            #",
            "            # XXX: Only do this if there isn't a pending invitation. The user",
            "            # may need to configure 2FA in which case, we don't want to make",
            "            # the association for them.",
            "            if settings.SENTRY_SINGLE_ORGANIZATION and not invite_helper:",
            "                organization = Organization.get_default()",
            "                OrganizationMember.objects.create(",
            "                    organization=organization, role=organization.default_role, user=user",
            "                )",
            "",
            "            if invite_helper and invite_helper.valid_request:",
            "                invite_helper.accept_invite()",
            "                response = self.redirect_to_org(request)",
            "                remove_invite_details_from_session(request)",
            "",
            "                return response",
            "",
            "            return self.redirect(self.get_post_register_url(request))",
            "",
            "        elif request.method == \"POST\":",
            "            from sentry import ratelimits as ratelimiter",
            "            from sentry.utils.hashlib import md5_text",
            "",
            "            login_attempt = (",
            "                op == \"login\" and request.POST.get(\"username\") and request.POST.get(\"password\")",
            "            )",
            "",
            "            if login_attempt and ratelimiter.is_limited(",
            "                \"auth:login:username:{}\".format(",
            "                    md5_text(login_form.clean_username(request.POST[\"username\"])).hexdigest()",
            "                ),",
            "                limit=5,",
            "                window=60,  # 5 per minute should be enough for anyone",
            "            ):",
            "                login_form.errors[\"__all__\"] = [",
            "                    \"You have made too many login attempts. Please try again later.\"",
            "                ]",
            "                metrics.incr(",
            "                    \"login.attempt\", instance=\"rate_limited\", skip_internal=True, sample_rate=1.0",
            "                )",
            "            elif login_form.is_valid():",
            "                user = login_form.get_user()",
            "",
            "                self._handle_login(request, user, organization)",
            "                metrics.incr(",
            "                    \"login.attempt\", instance=\"success\", skip_internal=True, sample_rate=1.0",
            "                )",
            "",
            "                if not user.is_active:",
            "                    return self.redirect(reverse(\"sentry-reactivate-account\"))",
            "                if organization:",
            "                    # Refresh the organization we fetched prior to login in order to check its login state.",
            "                    org_context = organization_service.get_organization_by_slug(",
            "                        user_id=request.user.id,",
            "                        slug=organization.slug,",
            "                        only_visible=False,",
            "                    )",
            "                    if org_context:",
            "                        if org_context.member and request.user and not is_active_superuser(request):",
            "                            auth.set_active_org(request, org_context.organization.slug)",
            "",
            "                        if settings.SENTRY_SINGLE_ORGANIZATION:",
            "                            om = organization_service.check_membership_by_email(",
            "                                org_context.organization.id, user.email",
            "                            )",
            "                            if om is None:",
            "                                request.session.pop(\"_next\", None)",
            "                            else:",
            "                                if om.user_id is None:",
            "                                    request.session.pop(\"_next\", None)",
            "",
            "                # On login, redirect to onboarding",
            "                if self.active_organization:",
            "                    onboarding_redirect = get_client_state_redirect_uri(",
            "                        self.active_organization.organization.slug, None",
            "                    )",
            "                    if onboarding_redirect:",
            "                        request.session[\"_next\"] = onboarding_redirect",
            "",
            "                return self.redirect(get_login_redirect(request))",
            "            else:",
            "                metrics.incr(",
            "                    \"login.attempt\", instance=\"failure\", skip_internal=True, sample_rate=1.0",
            "                )",
            "",
            "        context = {",
            "            \"op\": op or \"login\",",
            "            \"server_hostname\": get_server_hostname(),",
            "            \"login_form\": login_form,",
            "            \"organization\": organization,",
            "            \"register_form\": register_form,",
            "            \"CAN_REGISTER\": can_register,",
            "            \"join_request_link\": self.get_join_request_link(organization),",
            "            \"show_session_replay_banner\": settings.SHOW_SESSION_REPLAY_BANNER,",
            "        }",
            "",
            "        context.update(additional_context.run_callbacks(request))",
            "        return self.respond_login(request, context, **kwargs)",
            "",
            "    def handle_authenticated(self, request: Request):",
            "        next_uri = self.get_next_uri(request)",
            "        if is_valid_redirect(next_uri, allowed_hosts=(request.get_host(),)):",
            "            return self.redirect(next_uri)",
            "        return self.redirect_to_org(request)",
            "",
            "    @never_cache",
            "    @transaction.atomic",
            "    def handle(self, request: Request, *args, **kwargs) -> Response:",
            "        return super().handle(request, *args, **kwargs)",
            "",
            "    # XXX(dcramer): OAuth provider hooks this view",
            "    def get(self, request: Request, **kwargs) -> Response:",
            "        next_uri = self.get_next_uri(request)",
            "        if request.user.is_authenticated:",
            "            return self.handle_authenticated(request)",
            "",
            "        request.session.set_test_cookie()",
            "",
            "        # we always reset the state on GET so you don't end up at an odd location",
            "        initiate_login(request, next_uri)",
            "",
            "        # Single org mode -- send them to the org-specific handler",
            "        if settings.SENTRY_SINGLE_ORGANIZATION:",
            "            org = Organization.get_default()",
            "            next_uri = reverse(\"sentry-auth-organization\", args=[org.slug])",
            "            return HttpResponseRedirect(next_uri)",
            "",
            "        session_expired = \"session_expired\" in request.COOKIES",
            "        if session_expired:",
            "            messages.add_message(request, messages.WARNING, WARN_SESSION_EXPIRED)",
            "",
            "        response = self.handle_basic_auth(request, **kwargs)",
            "",
            "        if session_expired:",
            "            response.delete_cookie(\"session_expired\")",
            "",
            "        return response",
            "",
            "    # XXX(dcramer): OAuth provider hooks this view",
            "    def post(self, request: Request, **kwargs) -> Response:",
            "        op = request.POST.get(\"op\")",
            "        if op == \"sso\" and request.POST.get(\"organization\"):",
            "            # if post is from \"Single Sign On tab\"",
            "            auth_provider = self.get_auth_provider(request.POST[\"organization\"])",
            "            if auth_provider:",
            "                next_uri = reverse(\"sentry-auth-organization\", args=[request.POST[\"organization\"]])",
            "            else:",
            "                # Redirect to the org login route",
            "                next_uri = request.get_full_path()",
            "                messages.add_message(request, messages.ERROR, ERR_NO_SSO)",
            "",
            "            return HttpResponseRedirect(next_uri)",
            "",
            "        return self.handle_basic_auth(request, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "14": [],
            "169": [
                "AuthLoginView",
                "handle_basic_auth"
            ],
            "185": [
                "AuthLoginView",
                "handle_basic_auth"
            ]
        },
        "addLocation": []
    }
}