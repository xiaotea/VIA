{
    "mobsf/MobSF/init.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-VERSION = '3.9.5'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+VERSION = '3.9.6'"
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " BANNER = \"\"\""
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "   __  __       _    ____  _____       _____ ___  "
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "  |  \\/  | ___ | |__/ ___||  ___|_   _|___ // _ \\ "
            }
        },
        "frontPatchFile": [
            "\"\"\"Initialize on first run.\"\"\"",
            "import logging",
            "import os",
            "import random",
            "import subprocess",
            "import sys",
            "import shutil",
            "",
            "from mobsf.install.windows.setup import windows_config_local",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "VERSION = '3.9.5'",
            "BANNER = \"\"\"",
            "  __  __       _    ____  _____       _____ ___  ",
            " |  \\/  | ___ | |__/ ___||  ___|_   _|___ // _ \\ ",
            " | |\\/| |/ _ \\| '_ \\___ \\| |_  \\ \\ / / |_ \\ (_) |",
            " | |  | | (_) | |_) |__) |  _|  \\ V / ___) \\__, |",
            " |_|  |_|\\___/|_.__/____/|_|     \\_/ |____(_)/_/ ",
            "\"\"\"  # noqa: W291",
            "# ASCII Font: Standard",
            "",
            "",
            "def first_run(secret_file, base_dir, mobsf_home):",
            "    # Based on https://gist.github.com/ndarville/3452907#file-secret-key-gen-py",
            "    if 'MOBSF_SECRET_KEY' in os.environ:",
            "        secret_key = os.environ['MOBSF_SECRET_KEY']",
            "    elif os.path.isfile(secret_file):",
            "        secret_key = open(secret_file).read().strip()",
            "    else:",
            "        try:",
            "            secret_key = get_random()",
            "            secret = open(secret_file, 'w')",
            "            secret.write(secret_key)",
            "            secret.close()",
            "        except IOError:",
            "            raise Exception('Secret file generation failed' % secret_file)",
            "        # Run Once",
            "        make_migrations(base_dir)",
            "        migrate(base_dir)",
            "        # Windows Setup",
            "        windows_config_local(mobsf_home)",
            "    return secret_key",
            "",
            "",
            "def create_user_conf(mobsf_home, base_dir):",
            "    try:",
            "        config_path = os.path.join(mobsf_home, 'config.py')",
            "        if not os.path.isfile(config_path):",
            "            sample_conf = os.path.join(base_dir, 'MobSF/settings.py')",
            "            with open(sample_conf, 'r') as f:",
            "                dat = f.readlines()",
            "            config = []",
            "            add = False",
            "            for line in dat:",
            "                if '^CONFIG-START^' in line:",
            "                    add = True",
            "                if '^CONFIG-END^' in line:",
            "                    break",
            "                if add:",
            "                    config.append(line.lstrip())",
            "            config.pop(0)",
            "            conf_str = ''.join(config)",
            "            with open(config_path, 'w') as f:",
            "                f.write(conf_str)",
            "    except Exception:",
            "        logger.exception('Cannot create config file')",
            "",
            "",
            "def django_operation(cmds, base_dir):",
            "    \"\"\"Generic Function for Djano operations.\"\"\"",
            "    manage = os.path.join(base_dir, '../manage.py')",
            "    if not os.path.exists(manage):",
            "        # Bail out for package",
            "        return",
            "    args = [sys.executable, manage]",
            "    args.extend(cmds)",
            "    subprocess.call(args)",
            "",
            "",
            "def make_migrations(base_dir):",
            "    \"\"\"Create Database Migrations.\"\"\"",
            "    try:",
            "        django_operation(['makemigrations'], base_dir)",
            "        django_operation(['makemigrations', 'StaticAnalyzer'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Make Migrations')",
            "",
            "",
            "def migrate(base_dir):",
            "    \"\"\"Migrate Database.\"\"\"",
            "    try:",
            "        django_operation(['migrate'], base_dir)",
            "        django_operation(['migrate', '--run-syncdb'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Migrate')",
            "",
            "",
            "def get_random():",
            "    choice = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'",
            "    return ''.join([random.SystemRandom().choice(choice) for i in range(50)])",
            "",
            "",
            "def get_mobsf_home(use_home, base_dir):",
            "    try:",
            "        mobsf_home = ''",
            "        if use_home:",
            "            mobsf_home = os.path.join(os.path.expanduser('~'), '.MobSF')",
            "            # MobSF Home Directory",
            "            if not os.path.exists(mobsf_home):",
            "                os.makedirs(mobsf_home)",
            "            create_user_conf(mobsf_home, base_dir)",
            "        else:",
            "            mobsf_home = base_dir",
            "        # Download Directory",
            "        dwd_dir = os.path.join(mobsf_home, 'downloads/')",
            "        if not os.path.exists(dwd_dir):",
            "            os.makedirs(dwd_dir)",
            "        # Screenshot Directory",
            "        screen_dir = os.path.join(dwd_dir, 'screen/')",
            "        if not os.path.exists(screen_dir):",
            "            os.makedirs(screen_dir)",
            "        # Upload Directory",
            "        upload_dir = os.path.join(mobsf_home, 'uploads/')",
            "        if not os.path.exists(upload_dir):",
            "            os.makedirs(upload_dir)",
            "        # Signature Directory",
            "        sig_dir = os.path.join(mobsf_home, 'signatures/')",
            "        if use_home:",
            "            src = os.path.join(base_dir, 'signatures/')",
            "            try:",
            "                shutil.copytree(src, sig_dir)",
            "            except Exception:",
            "                pass",
            "        elif not os.path.exists(sig_dir):",
            "            os.makedirs(sig_dir)",
            "        return mobsf_home",
            "    except Exception:",
            "        logger.exception('Creating MobSF Home Directory')",
            "",
            "",
            "def get_mobsf_version():",
            "    return BANNER, VERSION, f'v{VERSION} Beta'"
        ],
        "afterPatchFile": [
            "\"\"\"Initialize on first run.\"\"\"",
            "import logging",
            "import os",
            "import random",
            "import subprocess",
            "import sys",
            "import shutil",
            "",
            "from mobsf.install.windows.setup import windows_config_local",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "VERSION = '3.9.6'",
            "BANNER = \"\"\"",
            "  __  __       _    ____  _____       _____ ___  ",
            " |  \\/  | ___ | |__/ ___||  ___|_   _|___ // _ \\ ",
            " | |\\/| |/ _ \\| '_ \\___ \\| |_  \\ \\ / / |_ \\ (_) |",
            " | |  | | (_) | |_) |__) |  _|  \\ V / ___) \\__, |",
            " |_|  |_|\\___/|_.__/____/|_|     \\_/ |____(_)/_/ ",
            "\"\"\"  # noqa: W291",
            "# ASCII Font: Standard",
            "",
            "",
            "def first_run(secret_file, base_dir, mobsf_home):",
            "    # Based on https://gist.github.com/ndarville/3452907#file-secret-key-gen-py",
            "    if 'MOBSF_SECRET_KEY' in os.environ:",
            "        secret_key = os.environ['MOBSF_SECRET_KEY']",
            "    elif os.path.isfile(secret_file):",
            "        secret_key = open(secret_file).read().strip()",
            "    else:",
            "        try:",
            "            secret_key = get_random()",
            "            secret = open(secret_file, 'w')",
            "            secret.write(secret_key)",
            "            secret.close()",
            "        except IOError:",
            "            raise Exception('Secret file generation failed' % secret_file)",
            "        # Run Once",
            "        make_migrations(base_dir)",
            "        migrate(base_dir)",
            "        # Windows Setup",
            "        windows_config_local(mobsf_home)",
            "    return secret_key",
            "",
            "",
            "def create_user_conf(mobsf_home, base_dir):",
            "    try:",
            "        config_path = os.path.join(mobsf_home, 'config.py')",
            "        if not os.path.isfile(config_path):",
            "            sample_conf = os.path.join(base_dir, 'MobSF/settings.py')",
            "            with open(sample_conf, 'r') as f:",
            "                dat = f.readlines()",
            "            config = []",
            "            add = False",
            "            for line in dat:",
            "                if '^CONFIG-START^' in line:",
            "                    add = True",
            "                if '^CONFIG-END^' in line:",
            "                    break",
            "                if add:",
            "                    config.append(line.lstrip())",
            "            config.pop(0)",
            "            conf_str = ''.join(config)",
            "            with open(config_path, 'w') as f:",
            "                f.write(conf_str)",
            "    except Exception:",
            "        logger.exception('Cannot create config file')",
            "",
            "",
            "def django_operation(cmds, base_dir):",
            "    \"\"\"Generic Function for Djano operations.\"\"\"",
            "    manage = os.path.join(base_dir, '../manage.py')",
            "    if not os.path.exists(manage):",
            "        # Bail out for package",
            "        return",
            "    args = [sys.executable, manage]",
            "    args.extend(cmds)",
            "    subprocess.call(args)",
            "",
            "",
            "def make_migrations(base_dir):",
            "    \"\"\"Create Database Migrations.\"\"\"",
            "    try:",
            "        django_operation(['makemigrations'], base_dir)",
            "        django_operation(['makemigrations', 'StaticAnalyzer'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Make Migrations')",
            "",
            "",
            "def migrate(base_dir):",
            "    \"\"\"Migrate Database.\"\"\"",
            "    try:",
            "        django_operation(['migrate'], base_dir)",
            "        django_operation(['migrate', '--run-syncdb'], base_dir)",
            "    except Exception:",
            "        logger.exception('Cannot Migrate')",
            "",
            "",
            "def get_random():",
            "    choice = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'",
            "    return ''.join([random.SystemRandom().choice(choice) for i in range(50)])",
            "",
            "",
            "def get_mobsf_home(use_home, base_dir):",
            "    try:",
            "        mobsf_home = ''",
            "        if use_home:",
            "            mobsf_home = os.path.join(os.path.expanduser('~'), '.MobSF')",
            "            # MobSF Home Directory",
            "            if not os.path.exists(mobsf_home):",
            "                os.makedirs(mobsf_home)",
            "            create_user_conf(mobsf_home, base_dir)",
            "        else:",
            "            mobsf_home = base_dir",
            "        # Download Directory",
            "        dwd_dir = os.path.join(mobsf_home, 'downloads/')",
            "        if not os.path.exists(dwd_dir):",
            "            os.makedirs(dwd_dir)",
            "        # Screenshot Directory",
            "        screen_dir = os.path.join(dwd_dir, 'screen/')",
            "        if not os.path.exists(screen_dir):",
            "            os.makedirs(screen_dir)",
            "        # Upload Directory",
            "        upload_dir = os.path.join(mobsf_home, 'uploads/')",
            "        if not os.path.exists(upload_dir):",
            "            os.makedirs(upload_dir)",
            "        # Signature Directory",
            "        sig_dir = os.path.join(mobsf_home, 'signatures/')",
            "        if use_home:",
            "            src = os.path.join(base_dir, 'signatures/')",
            "            try:",
            "                shutil.copytree(src, sig_dir)",
            "            except Exception:",
            "                pass",
            "        elif not os.path.exists(sig_dir):",
            "            os.makedirs(sig_dir)",
            "        return mobsf_home",
            "    except Exception:",
            "        logger.exception('Creating MobSF Home Directory')",
            "",
            "",
            "def get_mobsf_version():",
            "    return BANNER, VERSION, f'v{VERSION} Beta'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [
                "VERSION"
            ]
        },
        "addLocation": []
    },
    "mobsf/MobSF/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import string"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import subprocess"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import stat"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+import socket"
            },
            "4": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import sqlite3"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import unicodedata"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import threading"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from urllib.parse import urlparse"
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from pathlib import Path"
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from distutils.version import StrictVersion"
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 848,
                "afterPatchRowNumber": 850,
                "PatchRowcode": " def id_generator(size=6, chars=string.ascii_uppercase + string.digits):"
            },
            "12": {
                "beforePatchRowNumber": 849,
                "afterPatchRowNumber": 851,
                "PatchRowcode": "     \"\"\"Generate random string.\"\"\""
            },
            "13": {
                "beforePatchRowNumber": 850,
                "afterPatchRowNumber": 852,
                "PatchRowcode": "     return ''.join(random.choice(chars) for _ in range(size))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 853,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 854,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 855,
                "PatchRowcode": "+def valid_host(host):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 856,
                "PatchRowcode": "+    \"\"\"Check if host is valid.\"\"\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 857,
                "PatchRowcode": "+    try:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 858,
                "PatchRowcode": "+        prefixs = ('http://', 'https://')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 859,
                "PatchRowcode": "+        if not host.startswith(prefixs):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 860,
                "PatchRowcode": "+            host = f'http://{host}'"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 861,
                "PatchRowcode": "+        parsed = urlparse(host)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 862,
                "PatchRowcode": "+        domain = parsed.netloc"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 863,
                "PatchRowcode": "+        path = parsed.path"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 864,
                "PatchRowcode": "+        if len(domain) == 0:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 865,
                "PatchRowcode": "+            # No valid domain"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 866,
                "PatchRowcode": "+            return False"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 867,
                "PatchRowcode": "+        if len(path) > 0:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 868,
                "PatchRowcode": "+            # Only host is allowed"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 869,
                "PatchRowcode": "+            return False"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 870,
                "PatchRowcode": "+        if ':' in domain:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 871,
                "PatchRowcode": "+            # IPv6"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 872,
                "PatchRowcode": "+            return False"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 873,
                "PatchRowcode": "+        # Local network"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 874,
                "PatchRowcode": "+        invalid_prefix = ("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 875,
                "PatchRowcode": "+            '127.',"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 876,
                "PatchRowcode": "+            '192.',"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 877,
                "PatchRowcode": "+            '10.',"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 878,
                "PatchRowcode": "+            '172.',"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 879,
                "PatchRowcode": "+            '169',"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 880,
                "PatchRowcode": "+            '0.',"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 881,
                "PatchRowcode": "+            'localhost')"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 882,
                "PatchRowcode": "+        if domain.startswith(invalid_prefix):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 883,
                "PatchRowcode": "+            return False"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 884,
                "PatchRowcode": "+        ip = socket.gethostbyname(domain)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 885,
                "PatchRowcode": "+        if ip.startswith(invalid_prefix):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 886,
                "PatchRowcode": "+            # Resolve dns to get IP"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 887,
                "PatchRowcode": "+            return False"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 888,
                "PatchRowcode": "+        return True"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 889,
                "PatchRowcode": "+    except Exception:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 890,
                "PatchRowcode": "+        return False"
            }
        },
        "frontPatchFile": [
            "\"\"\"Common Utils.\"\"\"",
            "import ast",
            "import base64",
            "import hashlib",
            "import io",
            "import json",
            "import logging",
            "import ntpath",
            "import os",
            "import platform",
            "import random",
            "import re",
            "import sys",
            "import shutil",
            "import signal",
            "import string",
            "import subprocess",
            "import stat",
            "import sqlite3",
            "import unicodedata",
            "import threading",
            "from pathlib import Path",
            "from distutils.version import StrictVersion",
            "",
            "import distro",
            "",
            "import psutil",
            "",
            "import requests",
            "",
            "from django.shortcuts import render",
            "",
            "from . import settings",
            "",
            "logger = logging.getLogger(__name__)",
            "ADB_PATH = None",
            "BASE64_REGEX = re.compile(r'^[-A-Za-z0-9+/]*={0,3}$')",
            "MD5_REGEX = re.compile(r'^[0-9a-f]{32}$')",
            "# Regex to capture strings between quotes or <string> tag",
            "STRINGS_REGEX = re.compile(r'(?<=\\\")(.+?)(?=\\\")|(?<=\\<string>)(.+?)(?=\\<)')",
            "# MobSF Custom regex to catch maximum URI like strings",
            "URL_REGEX = re.compile(",
            "    (",
            "        r'((?:https?://|s?ftps?://|'",
            "        r'file://|javascript:|data:|www\\d{0,3}[.])'",
            "        r'[\\w().=/;,#:@?&~*+!$%\\'{}-]+)'",
            "    ),",
            "    re.UNICODE)",
            "EMAIL_REGEX = re.compile(r'[\\w+.-]{1,20}@[\\w-]{1,20}\\.[\\w]{2,10}')",
            "",
            "",
            "class Color(object):",
            "    GREEN = '\\033[92m'",
            "    ORANGE = '\\033[33m'",
            "    RED = '\\033[91m'",
            "    BOLD = '\\033[1m'",
            "    END = '\\033[0m'",
            "",
            "",
            "def upstream_proxy(flaw_type):",
            "    \"\"\"Set upstream Proxy if needed.\"\"\"",
            "    if settings.UPSTREAM_PROXY_ENABLED:",
            "        if not settings.UPSTREAM_PROXY_USERNAME:",
            "            proxy_port = str(settings.UPSTREAM_PROXY_PORT)",
            "            proxy_host = '{}://{}:{}'.format(",
            "                settings.UPSTREAM_PROXY_TYPE,",
            "                docker_translate_proxy_ip(settings.UPSTREAM_PROXY_IP),",
            "                proxy_port)",
            "            proxies = {flaw_type: proxy_host}",
            "        else:",
            "            proxy_port = str(settings.UPSTREAM_PROXY_PORT)",
            "            proxy_host = '{}://{}:{}@{}:{}'.format(",
            "                settings.UPSTREAM_PROXY_TYPE,",
            "                settings.UPSTREAM_PROXY_USERNAME,",
            "                settings.UPSTREAM_PROXY_PASSWORD,",
            "                docker_translate_proxy_ip(settings.UPSTREAM_PROXY_IP),",
            "                proxy_port)",
            "            proxies = {flaw_type: proxy_host}",
            "    else:",
            "        proxies = {flaw_type: None}",
            "    verify = settings.UPSTREAM_PROXY_SSL_VERIFY in ('1', '\"1\"')",
            "    return proxies, verify",
            "",
            "",
            "def api_key():",
            "    \"\"\"Print REST API Key.\"\"\"",
            "    if os.environ.get('MOBSF_API_KEY'):",
            "        logger.info('\\nAPI Key read from environment variable')",
            "        return os.environ['MOBSF_API_KEY']",
            "",
            "    secret_file = os.path.join(settings.MobSF_HOME, 'secret')",
            "    if is_file_exists(secret_file):",
            "        try:",
            "            _api_key = open(secret_file).read().strip()",
            "            return gen_sha256_hash(_api_key)",
            "        except Exception:",
            "            logger.exception('Cannot Read API Key')",
            "",
            "",
            "def print_version():",
            "    \"\"\"Print MobSF Version.\"\"\"",
            "    logger.info(settings.BANNER)",
            "    ver = settings.MOBSF_VER",
            "    logger.info('Author: Ajin Abraham | opensecurity.in')",
            "    if platform.system() == 'Windows':",
            "        logger.info('Mobile Security Framework %s', ver)",
            "        print('REST API Key: ' + api_key())",
            "    else:",
            "        logger.info('\\033[1m\\033[34mMobile Security Framework %s\\033[0m', ver)",
            "        print('REST API Key: ' + Color.BOLD + api_key() + Color.END)",
            "    os = platform.system()",
            "    pltfm = platform.platform()",
            "    dist = ' '.join(distro.linux_distribution(",
            "        full_distribution_name=False)).strip()",
            "    dst_str = ' '",
            "    if dist:",
            "        dst_str = f' ({dist}) '",
            "    env_str = f'OS Environment: {os}{dst_str}{pltfm}'",
            "    logger.info(env_str)",
            "    find_java_binary()",
            "    check_basic_env()",
            "    thread = threading.Thread(target=check_update, name='check_update')",
            "    thread.start()",
            "",
            "",
            "def check_update():",
            "    try:",
            "        if not is_internet_available():",
            "            logger.warning('Internet Not Available. Skipping Update check')",
            "            return",
            "        logger.info('Checking for Update.')",
            "        github_url = settings.GITHUB_URL",
            "        try:",
            "            proxies, verify = upstream_proxy('https')",
            "        except Exception:",
            "            logger.exception('Setting upstream proxy')",
            "        local_version = settings.VERSION",
            "        response = requests.head(github_url, timeout=5,",
            "                                 proxies=proxies, verify=verify)",
            "        remote_version = response.next.path_url.split('v')[1]",
            "        if remote_version:",
            "            sem_loc = StrictVersion(local_version)",
            "            sem_rem = StrictVersion(remote_version)",
            "            if sem_loc < sem_rem:",
            "                logger.warning('A new version of MobSF is available, '",
            "                               'Please update to %s from master branch.',",
            "                               remote_version)",
            "            else:",
            "                logger.info('No updates available.')",
            "    except requests.exceptions.HTTPError:",
            "        logger.warning('\\nCannot check for updates..'",
            "                       ' No Internet Connection Found.')",
            "        return",
            "    except Exception:",
            "        logger.exception('Cannot Check for updates.')",
            "",
            "",
            "def find_java_binary():",
            "    \"\"\"Find Java.\"\"\"",
            "    # Respect user settings",
            "    if platform.system() == 'Windows':",
            "        jbin = 'java.exe'",
            "    else:",
            "        jbin = 'java'",
            "    if is_dir_exists(settings.JAVA_DIRECTORY):",
            "        if settings.JAVA_DIRECTORY.endswith('/'):",
            "            return settings.JAVA_DIRECTORY + jbin",
            "        elif settings.JAVA_DIRECTORY.endswith('\\\\'):",
            "            return settings.JAVA_DIRECTORY + jbin",
            "        else:",
            "            return settings.JAVA_DIRECTORY + '/' + jbin",
            "    if os.getenv('JAVA_HOME'):",
            "        java = os.path.join(",
            "            os.getenv('JAVA_HOME'),",
            "            'bin',",
            "            jbin)",
            "        if is_file_exists(java):",
            "            return java",
            "    return 'java'",
            "",
            "",
            "def print_n_send_error_response(request,",
            "                                msg,",
            "                                api=False,",
            "                                exp='Description'):",
            "    \"\"\"Print and log errors.\"\"\"",
            "    logger.error(msg)",
            "    if api:",
            "        api_response = {'error': msg}",
            "        return api_response",
            "    else:",
            "        context = {",
            "            'title': 'Error',",
            "            'exp': exp,",
            "            'doc': msg,",
            "            'version': settings.MOBSF_VER,",
            "        }",
            "        template = 'general/error.html'",
            "        return render(request, template, context, status=500)",
            "",
            "",
            "def filename_from_path(path):",
            "    head, tail = ntpath.split(path)",
            "    return tail or ntpath.basename(head)",
            "",
            "",
            "def get_md5(data):",
            "    return hashlib.md5(data).hexdigest()",
            "",
            "",
            "def find_between(s, first, last):",
            "    try:",
            "        start = s.index(first) + len(first)",
            "        end = s.index(last, start)",
            "        return s[start:end]",
            "    except ValueError:",
            "        return ''",
            "",
            "",
            "def is_number(s):",
            "    if not s:",
            "        return False",
            "    if s == 'NaN':",
            "        return False",
            "    try:",
            "        float(s)",
            "        return True",
            "    except ValueError:",
            "        pass",
            "    try:",
            "        unicodedata.numeric(s)",
            "        return True",
            "    except (TypeError, ValueError):",
            "        pass",
            "    return False",
            "",
            "",
            "def python_list(value):",
            "    if not value:",
            "        value = []",
            "    if isinstance(value, list):",
            "        return value",
            "    return ast.literal_eval(value)",
            "",
            "",
            "def python_dict(value):",
            "    if not value:",
            "        value = {}",
            "    if isinstance(value, dict):",
            "        return value",
            "    return ast.literal_eval(value)",
            "",
            "",
            "def is_base64(b_str):",
            "    return BASE64_REGEX.match(b_str)",
            "",
            "",
            "def is_internet_available():",
            "    try:",
            "        proxies, verify = upstream_proxy('https')",
            "    except Exception:",
            "        logger.exception('Setting upstream proxy')",
            "    try:",
            "        requests.get(settings.GOOGLE,",
            "                     timeout=5,",
            "                     proxies=proxies,",
            "                     verify=verify)",
            "        return True",
            "    except Exception:",
            "        try:",
            "            requests.get(settings.BAIDU,",
            "                         timeout=5,",
            "                         proxies=proxies,",
            "                         verify=verify)",
            "            return True",
            "        except Exception:",
            "            return False",
            "",
            "",
            "def sha256(file_path):",
            "    blocksize = 65536",
            "    hasher = hashlib.sha256()",
            "    with io.open(file_path, mode='rb') as afile:",
            "        buf = afile.read(blocksize)",
            "        while buf:",
            "            hasher.update(buf)",
            "            buf = afile.read(blocksize)",
            "    return hasher.hexdigest()",
            "",
            "",
            "def sha256_object(file_obj):",
            "    blocksize = 65536",
            "    hasher = hashlib.sha256()",
            "    buf = file_obj.read(blocksize)",
            "    while buf:",
            "        hasher.update(buf)",
            "        buf = file_obj.read(blocksize)",
            "    return hasher.hexdigest()",
            "",
            "",
            "def gen_sha256_hash(msg):",
            "    \"\"\"Generate SHA 256 Hash of the message.\"\"\"",
            "    if isinstance(msg, str):",
            "        msg = msg.encode('utf-8')",
            "    hash_object = hashlib.sha256(msg)",
            "    return hash_object.hexdigest()",
            "",
            "",
            "def is_file_exists(file_path):",
            "    if os.path.isfile(file_path):",
            "        return True",
            "    # This fix situation where a user just typed \"adb\" or another executable",
            "    # inside settings.py/config.py",
            "    if shutil.which(file_path):",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "def is_dir_exists(dir_path):",
            "    if os.path.isdir(dir_path):",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "def find_process_by(name):",
            "    \"\"\"Return a set of process path matching name.\"\"\"",
            "    proc = set()",
            "    for p in psutil.process_iter(attrs=['name']):",
            "        if (name == p.info['name']):",
            "            proc.add(p.exe())",
            "    return proc",
            "",
            "",
            "def docker_translate_localhost(identifier):",
            "    \"\"\"Convert localhost to host.docker.internal.\"\"\"",
            "    if not identifier:",
            "        return identifier",
            "    if not os.getenv('MOBSF_PLATFORM') == 'docker':",
            "        return identifier",
            "    try:",
            "        identifier = identifier.strip()",
            "        docker_internal = 'host.docker.internal:'",
            "        if re.match(r'^emulator-\\d{4}$', identifier):",
            "            adb_port = int(identifier.split('emulator-')[1]) + 1",
            "            # ADB port is console port + 1",
            "            return f'{docker_internal}{adb_port}'",
            "        m = re.match(r'^(localhost|127\\.0\\.0\\.1):\\d{1,5}$', identifier)",
            "        if m:",
            "            adb_port = int(identifier.split(m.group(1))[1].replace(':', ''))",
            "            return f'{docker_internal}{adb_port}'",
            "        return identifier",
            "    except Exception:",
            "        logger.exception('Failed to convert device '",
            "                         'identifier for docker connectivity')",
            "        return identifier",
            "",
            "",
            "def docker_translate_proxy_ip(ip):",
            "    \"\"\"Convert localhost proxy ip to host.docker.internal.\"\"\"",
            "    if not os.getenv('MOBSF_PLATFORM') == 'docker':",
            "        return ip",
            "    if ip and ip.strip() in ('127.0.0.1', 'localhost'):",
            "        return 'host.docker.internal'",
            "    return ip",
            "",
            "",
            "def get_device():",
            "    \"\"\"Get Device.\"\"\"",
            "    if os.getenv('ANALYZER_IDENTIFIER'):",
            "        return docker_translate_localhost(",
            "            os.getenv('ANALYZER_IDENTIFIER'))",
            "    elif settings.ANALYZER_IDENTIFIER:",
            "        return docker_translate_localhost(",
            "            settings.ANALYZER_IDENTIFIER)",
            "    else:",
            "        dev_id = ''",
            "        out = subprocess.check_output([get_adb(), 'devices']).splitlines()",
            "        if len(out) > 2:",
            "            dev_id = out[1].decode('utf-8').split('\\t')[0]",
            "            if 'daemon started successfully' not in dev_id:",
            "                return docker_translate_localhost(dev_id)",
            "    logger.error(get_android_dm_exception_msg())",
            "",
            "",
            "def get_adb():",
            "    \"\"\"Get ADB binary path.\"\"\"",
            "    try:",
            "        adb_loc = None",
            "        adb_msg = ('Set adb path, ADB_BINARY in'",
            "                   f' {get_config_loc()}'",
            "                   ' with same adb binary used'",
            "                   ' by Genymotion VM/Emulator AVD.')",
            "        global ADB_PATH",
            "        if (len(settings.ADB_BINARY) > 0",
            "                and is_file_exists(settings.ADB_BINARY)):",
            "            ADB_PATH = settings.ADB_BINARY",
            "            return ADB_PATH",
            "        if ADB_PATH:",
            "            return ADB_PATH",
            "        if platform.system() == 'Windows':",
            "            adb_loc = find_process_by('adb.exe')",
            "        else:",
            "            adb_loc = find_process_by('adb')",
            "        if len(adb_loc) > 1:",
            "            logger.warning('Multiple ADB locations found. %s', adb_msg)",
            "            logger.warning(adb_loc)",
            "        if adb_loc:",
            "            ADB_PATH = adb_loc.pop()",
            "            return ADB_PATH",
            "    except Exception:",
            "        if not adb_loc:",
            "            logger.warning('Cannot find adb! %s', adb_msg)",
            "        logger.exception('Getting ADB Location')",
            "    finally:",
            "        if ADB_PATH:",
            "            os.environ['MOBSF_ADB'] = ADB_PATH",
            "        else:",
            "            os.environ['MOBSF_ADB'] = 'adb'",
            "            logger.warning('Dynamic Analysis related '",
            "                           'functions will not work. '",
            "                           '\\nMake sure a Genymotion Android VM/'",
            "                           'Android Studio Emulator'",
            "                           ' is running before performing'",
            "                           ' Dynamic Analysis.')",
            "    return 'adb'",
            "",
            "",
            "def check_basic_env():",
            "    \"\"\"Check if we have basic env for MobSF to run.\"\"\"",
            "    logger.info('MobSF Basic Environment Check')",
            "    try:",
            "        import http_tools  # noqa F401",
            "    except ImportError:",
            "        logger.exception('httptools not installed!')",
            "        os.kill(os.getpid(), signal.SIGTERM)",
            "    try:",
            "        import lxml  # noqa F401",
            "    except ImportError:",
            "        logger.exception('lxml is not installed!')",
            "        os.kill(os.getpid(), signal.SIGTERM)",
            "    if not is_file_exists(find_java_binary()):",
            "        logger.error(",
            "            'JDK 8+ is not available. '",
            "            'Set JAVA_HOME environment variable'",
            "            ' or JAVA_DIRECTORY in '",
            "            '%s', get_config_loc())",
            "        logger.info('Current Configuration: '",
            "                    'JAVA_DIRECTORY=%s', settings.JAVA_DIRECTORY)",
            "        logger.info('Example Configuration:'",
            "                    '\\nJAVA_DIRECTORY = \"C:/Program Files/'",
            "                    'Java/jdk1.7.0_17/bin/\"'",
            "                    '\\nJAVA_DIRECTORY = \"/usr/bin/\"')",
            "        os.kill(os.getpid(), signal.SIGTERM)",
            "",
            "",
            "def update_local_db(db_name, url, local_file):",
            "    \"\"\"Update Local DBs.\"\"\"",
            "    update = None",
            "    inmemoryfile = None",
            "    try:",
            "        proxies, verify = upstream_proxy('https')",
            "    except Exception:",
            "        logger.exception('[ERROR] Setting upstream proxy')",
            "    try:",
            "        response = requests.get(url,",
            "                                timeout=3,",
            "                                proxies=proxies,",
            "                                verify=verify)",
            "        resp = response.content",
            "        inmemoryfile = io.BytesIO(resp)",
            "        # Create on first run",
            "        if not is_file_exists(local_file):",
            "            return resp",
            "        # Check1: SHA256 Change",
            "        if sha256_object(inmemoryfile) != sha256(local_file):",
            "            # Hash Changed",
            "            logger.info('%s Database is outdated!', db_name)",
            "            update = resp",
            "        else:",
            "            logger.info('%s Database is up-to-date', db_name)",
            "        return update",
            "    except (requests.exceptions.ReadTimeout,",
            "            requests.exceptions.ConnectionError):",
            "        logger.warning('Failed to download %s DB.', db_name)",
            "    except Exception:",
            "        logger.exception('[ERROR] %s DB Update', db_name)",
            "        return update",
            "    finally:",
            "        if inmemoryfile:",
            "            inmemoryfile.truncate(0)",
            "",
            "",
            "def read_sqlite(sqlite_file):",
            "    \"\"\"Sqlite Dump - Readable Text.\"\"\"",
            "    logger.info('Reading SQLite db')",
            "    table_dict = {}",
            "    try:",
            "        con = sqlite3.connect(sqlite_file)",
            "        cur = con.cursor()",
            "        cur.execute('SELECT name FROM sqlite_master WHERE type=\\'table\\';')",
            "        tables = cur.fetchall()",
            "        for table in tables:",
            "            table_dict[table[0]] = {'head': [], 'data': []}",
            "            cur.execute('PRAGMA table_info(\\'%s\\')' % table)",
            "            rows = cur.fetchall()",
            "            for sq_row in rows:",
            "                table_dict[table[0]]['head'].append(sq_row[1])",
            "            cur.execute('SELECT * FROM \\'%s\\'' % table)",
            "            rows = cur.fetchall()",
            "            for sq_row in rows:",
            "                tmp_row = []",
            "                for each_row in sq_row:",
            "                    tmp_row.append(str(each_row))",
            "                table_dict[table[0]]['data'].append(tmp_row)",
            "    except Exception:",
            "        logger.exception('Reading SQLite db')",
            "    return table_dict",
            "",
            "",
            "def is_pipe_or_link(path):",
            "    \"\"\"Check for named pipe.\"\"\"",
            "    return os.path.islink(path) or stat.S_ISFIFO(os.stat(path).st_mode)",
            "",
            "",
            "def get_network():",
            "    \"\"\"Get Network IPs.\"\"\"",
            "    ips = []",
            "    try:",
            "        for det in psutil.net_if_addrs().values():",
            "            ips.append(det[0].address)",
            "    except Exception:",
            "        logger.exception('Failed to enumerate network interfaces')",
            "    return ips",
            "",
            "",
            "def get_proxy_ip(identifier):",
            "    \"\"\"Get Proxy IP.\"\"\"",
            "    proxy_ip = None",
            "    try:",
            "        if not identifier:",
            "            return proxy_ip",
            "        ips = get_network()",
            "        if ':' not in identifier or not ips:",
            "            return proxy_ip",
            "        device_ip = identifier.split(':', 1)[0]",
            "        ip_range = device_ip.rsplit('.', 1)[0]",
            "        guess_ip = ip_range + '.1'",
            "        if guess_ip in ips:",
            "            return guess_ip",
            "        for ip_addr in ips:",
            "            to_check = ip_addr.rsplit('.', 1)[0]",
            "            if to_check == ip_range:",
            "                return ip_addr",
            "    except Exception:",
            "        logger.error('Error getting Proxy IP')",
            "    return proxy_ip",
            "",
            "",
            "def is_safe_path(safe_root, check_path):",
            "    \"\"\"Detect Path Traversal.\"\"\"",
            "    safe_root = os.path.realpath(os.path.normpath(safe_root))",
            "    check_path = os.path.realpath(os.path.normpath(check_path))",
            "    return os.path.commonprefix([check_path, safe_root]) == safe_root",
            "",
            "",
            "def file_size(app_path):",
            "    \"\"\"Return the size of the file.\"\"\"",
            "    return round(float(os.path.getsize(app_path)) / (1024 * 1024), 2)",
            "",
            "",
            "def is_md5(user_input):",
            "    \"\"\"Check if string is valid MD5.\"\"\"",
            "    stat = MD5_REGEX.match(user_input)",
            "    if not stat:",
            "        logger.error('Invalid scan hash')",
            "    return stat",
            "",
            "",
            "def get_config_loc():",
            "    \"\"\"Get config location.\"\"\"",
            "    if settings.USE_HOME:",
            "        return os.path.join(",
            "            os.path.expanduser('~'),",
            "            '.MobSF',",
            "            'config.py',",
            "        )",
            "    else:",
            "        return 'MobSF/settings.py'",
            "",
            "",
            "def clean_filename(filename, replace=' '):",
            "    if platform.system() == 'Windows':",
            "        whitelist = f'-_.() {string.ascii_letters}{string.digits}'",
            "        # replace spaces",
            "        for r in replace:",
            "            filename = filename.replace(r, '_')",
            "        # keep only valid ascii chars",
            "        cleaned_filename = unicodedata.normalize(",
            "            'NFKD', filename).encode('ASCII', 'ignore').decode()",
            "        # keep only whitelisted chars",
            "        return ''.join(c for c in cleaned_filename if c in whitelist)",
            "    return filename",
            "",
            "",
            "def cmd_injection_check(data):",
            "    \"\"\"OS Cmd Injection from Commix.\"\"\"",
            "    breakers = [",
            "        ';', '%3B', '&', '%26', '&&',",
            "        '%26%26', '|', '%7C', '||',",
            "        '%7C%7C', '%0a', '%0d%0a',",
            "    ]",
            "    return any(i in data for i in breakers)",
            "",
            "",
            "def strict_package_check(user_input):",
            "    \"\"\"Strict package name check.",
            "",
            "    For android package and ios bundle id",
            "    \"\"\"",
            "    pat = re.compile(r'^([\\w-]*\\.)+[\\w-]{2,155}$')",
            "    resp = re.match(pat, user_input)",
            "    if not resp or '..' in user_input:",
            "        logger.error('Invalid package name/bundle id/class name')",
            "    return resp",
            "",
            "",
            "def strict_ios_class(user_input):",
            "    \"\"\"Strict check to see if input is valid iOS class.\"\"\"",
            "    pat = re.compile(r'^([\\w\\.]+)$')",
            "    resp = re.match(pat, user_input)",
            "    if not resp:",
            "        logger.error('Invalid class name')",
            "    return resp",
            "",
            "",
            "def is_instance_id(user_input):",
            "    \"\"\"Check if string is valid instance id.\"\"\"",
            "    reg = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'",
            "    stat = re.match(reg, user_input)",
            "    if not stat:",
            "        logger.error('Invalid instance identifier')",
            "    return stat",
            "",
            "",
            "def common_check(instance_id):",
            "    \"\"\"Common checks for instance APIs.\"\"\"",
            "    if not getattr(settings, 'CORELLIUM_API_KEY', ''):",
            "        return {",
            "            'status': 'failed',",
            "            'message': 'Missing Corellium API key'}",
            "    elif not is_instance_id(instance_id):",
            "        return {",
            "            'status': 'failed',",
            "            'message': 'Invalid instance identifier'}",
            "    else:",
            "        return None",
            "",
            "",
            "def is_path_traversal(user_input):",
            "    \"\"\"Check for path traversal.\"\"\"",
            "    if (('../' in user_input)",
            "        or ('%2e%2e' in user_input)",
            "        or ('..' in user_input)",
            "            or ('%252e' in user_input)):",
            "        logger.error('Path traversal attack detected')",
            "        return True",
            "    return False",
            "",
            "",
            "def is_zip_magic(file_obj):",
            "    magic = file_obj.read(4)",
            "    file_obj.seek(0, 0)",
            "    # ZIP magic PK.. no support for spanned and empty arch",
            "    return bool(magic == b'\\x50\\x4B\\x03\\x04')",
            "",
            "",
            "def is_elf_so_magic(file_obj):",
            "    magic = file_obj.read(4)",
            "    file_obj.seek(0, 0)",
            "    # ELF/SO Magic",
            "    return bool(magic == b'\\x7F\\x45\\x4C\\x46')",
            "",
            "",
            "def is_dylib_magic(file_obj):",
            "    magic = file_obj.read(4)",
            "    file_obj.seek(0, 0)",
            "    # DYLIB Magic",
            "    magics = (",
            "        b'\\xCA\\xFE\\xBA\\xBE',  # 32 bit",
            "        b'\\xFE\\xED\\xFA\\xCE',  # 32 bit",
            "        b'\\xCE\\xFA\\xED\\xFE',  # 32 bit",
            "        b'\\xFE\\xED\\xFA\\xCF',  # 64 bit",
            "        b'\\xCF\\xFA\\xED\\xFE',  # 64 bit",
            "        b'\\xCA\\xFE\\xBA\\xBF',  # 64 bit",
            "    )",
            "    return bool(magic in magics)",
            "",
            "",
            "def is_a_magic(file_obj):",
            "    magic = file_obj.read(4)",
            "    file_obj.seek(0, 0)",
            "    magics = (",
            "        b'\\x21\\x3C\\x61\\x72',",
            "        b'\\xCA\\xFE\\xBA\\xBF',  # 64 bit",
            "        b'\\xCA\\xFE\\xBA\\xBE',  # 32 bit",
            "    )",
            "    return bool(magic in magics)",
            "",
            "",
            "def disable_print():",
            "    sys.stdout = open(os.devnull, 'w')",
            "",
            "",
            "# Restore",
            "def enable_print():",
            "    sys.stdout = sys.__stdout__",
            "",
            "",
            "def find_key_in_dict(key, var):",
            "    \"\"\"Recursively look up a key in a nested dict.\"\"\"",
            "    if hasattr(var, 'items'):",
            "        for k, v in var.items():",
            "            if k == key:",
            "                yield v",
            "            if isinstance(v, dict):",
            "                for result in find_key_in_dict(key, v):",
            "                    yield result",
            "            elif isinstance(v, list):",
            "                for d in v:",
            "                    for result in find_key_in_dict(key, d):",
            "                        yield result",
            "",
            "",
            "def key(data, key_name):",
            "    \"\"\"Return the data for a key_name.\"\"\"",
            "    return data.get(key_name)",
            "",
            "",
            "def replace(value, arg):",
            "    \"\"\"",
            "    Replacing filter.",
            "",
            "    Use `{{ \"aaa\"|replace:\"a|b\" }}`",
            "    \"\"\"",
            "    if len(arg.split('|')) != 2:",
            "        return value",
            "",
            "    what, to = arg.split('|')",
            "    return value.replace(what, to)",
            "",
            "",
            "def relative_path(value):",
            "    \"\"\"Show relative path to two parents.\"\"\"",
            "    sep = None",
            "    if '/' in value:",
            "        sep = '/'",
            "    elif '\\\\\\\\' in value:",
            "        sep = '\\\\\\\\'",
            "    elif '\\\\' in value:",
            "        sep = '\\\\'",
            "    if not sep or value.count(sep) < 2:",
            "        return value",
            "    path = Path(value)",
            "    return path.relative_to(path.parent.parent).as_posix()",
            "",
            "",
            "def pretty_json(value):",
            "    \"\"\"Pretty print JSON.\"\"\"",
            "    try:",
            "        return json.dumps(json.loads(value), indent=4)",
            "    except Exception:",
            "        return value",
            "",
            "",
            "def base64_decode(value):",
            "    \"\"\"Try Base64 decode.\"\"\"",
            "    commonb64s = ('eyJ0')",
            "    decoded = None",
            "    try:",
            "        if is_base64(value) or value.startswith(commonb64s):",
            "            decoded = base64.b64decode(",
            "                value).decode('ISO-8859-1')",
            "    except Exception:",
            "        pass",
            "    if decoded:",
            "        return f'{value}\\n\\nBase64 Decoded: {decoded}'",
            "    return value",
            "",
            "",
            "def base64_encode(value):",
            "    \"\"\"Base64 encode.\"\"\"",
            "    if isinstance(value, str):",
            "        value = value.encode('utf-8')",
            "    return base64.b64encode(value)",
            "",
            "",
            "def android_component(data):",
            "    \"\"\"Return Android component from data.\"\"\"",
            "    cmp = ''",
            "    if 'Activity-Alias' in data:",
            "        cmp = 'activity_alias_'",
            "    elif 'Activity' in data:",
            "        cmp = 'activity_'",
            "    elif 'Service' in data:",
            "        cmp = 'service_'",
            "    elif 'Content Provider' in data:",
            "        cmp = 'provider_'",
            "    elif 'Broadcast Receiver' in data:",
            "        cmp = 'receiver_'",
            "    return cmp",
            "",
            "",
            "def get_android_dm_exception_msg():",
            "    return (",
            "        'Is your Android VM/emulator running? MobSF cannot'",
            "        ' find the android device identifier.'",
            "        ' Please read official documentation.'",
            "        ' If this error persists, set ANALYZER_IDENTIFIER in '",
            "        f'{get_config_loc()} or via environment variable'",
            "        ' MOBSF_ANALYZER_IDENTIFIER')",
            "",
            "",
            "def get_android_src_dir(app_dir, typ):",
            "    \"\"\"Get Android source code location.\"\"\"",
            "    if typ == 'apk':",
            "        src = app_dir / 'java_source'",
            "    elif typ == 'studio':",
            "        src = app_dir / 'app' / 'src' / 'main' / 'java'",
            "        kt = app_dir / 'app' / 'src' / 'main' / 'kotlin'",
            "        if not src.exists() and kt.exists():",
            "            src = kt",
            "    elif typ == 'eclipse':",
            "        src = app_dir / 'src'",
            "    return src",
            "",
            "",
            "def settings_enabled(attr):",
            "    \"\"\"Get settings state if present.\"\"\"",
            "    disabled = ('', ' ', '\"\"', '\" \"', '0', '\"0\"', False)",
            "    try:",
            "        return getattr(settings, attr) not in disabled",
            "    except Exception:",
            "        return False",
            "",
            "",
            "def id_generator(size=6, chars=string.ascii_uppercase + string.digits):",
            "    \"\"\"Generate random string.\"\"\"",
            "    return ''.join(random.choice(chars) for _ in range(size))"
        ],
        "afterPatchFile": [
            "\"\"\"Common Utils.\"\"\"",
            "import ast",
            "import base64",
            "import hashlib",
            "import io",
            "import json",
            "import logging",
            "import ntpath",
            "import os",
            "import platform",
            "import random",
            "import re",
            "import sys",
            "import shutil",
            "import signal",
            "import string",
            "import subprocess",
            "import stat",
            "import socket",
            "import sqlite3",
            "import unicodedata",
            "import threading",
            "from urllib.parse import urlparse",
            "from pathlib import Path",
            "from distutils.version import StrictVersion",
            "",
            "import distro",
            "",
            "import psutil",
            "",
            "import requests",
            "",
            "from django.shortcuts import render",
            "",
            "from . import settings",
            "",
            "logger = logging.getLogger(__name__)",
            "ADB_PATH = None",
            "BASE64_REGEX = re.compile(r'^[-A-Za-z0-9+/]*={0,3}$')",
            "MD5_REGEX = re.compile(r'^[0-9a-f]{32}$')",
            "# Regex to capture strings between quotes or <string> tag",
            "STRINGS_REGEX = re.compile(r'(?<=\\\")(.+?)(?=\\\")|(?<=\\<string>)(.+?)(?=\\<)')",
            "# MobSF Custom regex to catch maximum URI like strings",
            "URL_REGEX = re.compile(",
            "    (",
            "        r'((?:https?://|s?ftps?://|'",
            "        r'file://|javascript:|data:|www\\d{0,3}[.])'",
            "        r'[\\w().=/;,#:@?&~*+!$%\\'{}-]+)'",
            "    ),",
            "    re.UNICODE)",
            "EMAIL_REGEX = re.compile(r'[\\w+.-]{1,20}@[\\w-]{1,20}\\.[\\w]{2,10}')",
            "",
            "",
            "class Color(object):",
            "    GREEN = '\\033[92m'",
            "    ORANGE = '\\033[33m'",
            "    RED = '\\033[91m'",
            "    BOLD = '\\033[1m'",
            "    END = '\\033[0m'",
            "",
            "",
            "def upstream_proxy(flaw_type):",
            "    \"\"\"Set upstream Proxy if needed.\"\"\"",
            "    if settings.UPSTREAM_PROXY_ENABLED:",
            "        if not settings.UPSTREAM_PROXY_USERNAME:",
            "            proxy_port = str(settings.UPSTREAM_PROXY_PORT)",
            "            proxy_host = '{}://{}:{}'.format(",
            "                settings.UPSTREAM_PROXY_TYPE,",
            "                docker_translate_proxy_ip(settings.UPSTREAM_PROXY_IP),",
            "                proxy_port)",
            "            proxies = {flaw_type: proxy_host}",
            "        else:",
            "            proxy_port = str(settings.UPSTREAM_PROXY_PORT)",
            "            proxy_host = '{}://{}:{}@{}:{}'.format(",
            "                settings.UPSTREAM_PROXY_TYPE,",
            "                settings.UPSTREAM_PROXY_USERNAME,",
            "                settings.UPSTREAM_PROXY_PASSWORD,",
            "                docker_translate_proxy_ip(settings.UPSTREAM_PROXY_IP),",
            "                proxy_port)",
            "            proxies = {flaw_type: proxy_host}",
            "    else:",
            "        proxies = {flaw_type: None}",
            "    verify = settings.UPSTREAM_PROXY_SSL_VERIFY in ('1', '\"1\"')",
            "    return proxies, verify",
            "",
            "",
            "def api_key():",
            "    \"\"\"Print REST API Key.\"\"\"",
            "    if os.environ.get('MOBSF_API_KEY'):",
            "        logger.info('\\nAPI Key read from environment variable')",
            "        return os.environ['MOBSF_API_KEY']",
            "",
            "    secret_file = os.path.join(settings.MobSF_HOME, 'secret')",
            "    if is_file_exists(secret_file):",
            "        try:",
            "            _api_key = open(secret_file).read().strip()",
            "            return gen_sha256_hash(_api_key)",
            "        except Exception:",
            "            logger.exception('Cannot Read API Key')",
            "",
            "",
            "def print_version():",
            "    \"\"\"Print MobSF Version.\"\"\"",
            "    logger.info(settings.BANNER)",
            "    ver = settings.MOBSF_VER",
            "    logger.info('Author: Ajin Abraham | opensecurity.in')",
            "    if platform.system() == 'Windows':",
            "        logger.info('Mobile Security Framework %s', ver)",
            "        print('REST API Key: ' + api_key())",
            "    else:",
            "        logger.info('\\033[1m\\033[34mMobile Security Framework %s\\033[0m', ver)",
            "        print('REST API Key: ' + Color.BOLD + api_key() + Color.END)",
            "    os = platform.system()",
            "    pltfm = platform.platform()",
            "    dist = ' '.join(distro.linux_distribution(",
            "        full_distribution_name=False)).strip()",
            "    dst_str = ' '",
            "    if dist:",
            "        dst_str = f' ({dist}) '",
            "    env_str = f'OS Environment: {os}{dst_str}{pltfm}'",
            "    logger.info(env_str)",
            "    find_java_binary()",
            "    check_basic_env()",
            "    thread = threading.Thread(target=check_update, name='check_update')",
            "    thread.start()",
            "",
            "",
            "def check_update():",
            "    try:",
            "        if not is_internet_available():",
            "            logger.warning('Internet Not Available. Skipping Update check')",
            "            return",
            "        logger.info('Checking for Update.')",
            "        github_url = settings.GITHUB_URL",
            "        try:",
            "            proxies, verify = upstream_proxy('https')",
            "        except Exception:",
            "            logger.exception('Setting upstream proxy')",
            "        local_version = settings.VERSION",
            "        response = requests.head(github_url, timeout=5,",
            "                                 proxies=proxies, verify=verify)",
            "        remote_version = response.next.path_url.split('v')[1]",
            "        if remote_version:",
            "            sem_loc = StrictVersion(local_version)",
            "            sem_rem = StrictVersion(remote_version)",
            "            if sem_loc < sem_rem:",
            "                logger.warning('A new version of MobSF is available, '",
            "                               'Please update to %s from master branch.',",
            "                               remote_version)",
            "            else:",
            "                logger.info('No updates available.')",
            "    except requests.exceptions.HTTPError:",
            "        logger.warning('\\nCannot check for updates..'",
            "                       ' No Internet Connection Found.')",
            "        return",
            "    except Exception:",
            "        logger.exception('Cannot Check for updates.')",
            "",
            "",
            "def find_java_binary():",
            "    \"\"\"Find Java.\"\"\"",
            "    # Respect user settings",
            "    if platform.system() == 'Windows':",
            "        jbin = 'java.exe'",
            "    else:",
            "        jbin = 'java'",
            "    if is_dir_exists(settings.JAVA_DIRECTORY):",
            "        if settings.JAVA_DIRECTORY.endswith('/'):",
            "            return settings.JAVA_DIRECTORY + jbin",
            "        elif settings.JAVA_DIRECTORY.endswith('\\\\'):",
            "            return settings.JAVA_DIRECTORY + jbin",
            "        else:",
            "            return settings.JAVA_DIRECTORY + '/' + jbin",
            "    if os.getenv('JAVA_HOME'):",
            "        java = os.path.join(",
            "            os.getenv('JAVA_HOME'),",
            "            'bin',",
            "            jbin)",
            "        if is_file_exists(java):",
            "            return java",
            "    return 'java'",
            "",
            "",
            "def print_n_send_error_response(request,",
            "                                msg,",
            "                                api=False,",
            "                                exp='Description'):",
            "    \"\"\"Print and log errors.\"\"\"",
            "    logger.error(msg)",
            "    if api:",
            "        api_response = {'error': msg}",
            "        return api_response",
            "    else:",
            "        context = {",
            "            'title': 'Error',",
            "            'exp': exp,",
            "            'doc': msg,",
            "            'version': settings.MOBSF_VER,",
            "        }",
            "        template = 'general/error.html'",
            "        return render(request, template, context, status=500)",
            "",
            "",
            "def filename_from_path(path):",
            "    head, tail = ntpath.split(path)",
            "    return tail or ntpath.basename(head)",
            "",
            "",
            "def get_md5(data):",
            "    return hashlib.md5(data).hexdigest()",
            "",
            "",
            "def find_between(s, first, last):",
            "    try:",
            "        start = s.index(first) + len(first)",
            "        end = s.index(last, start)",
            "        return s[start:end]",
            "    except ValueError:",
            "        return ''",
            "",
            "",
            "def is_number(s):",
            "    if not s:",
            "        return False",
            "    if s == 'NaN':",
            "        return False",
            "    try:",
            "        float(s)",
            "        return True",
            "    except ValueError:",
            "        pass",
            "    try:",
            "        unicodedata.numeric(s)",
            "        return True",
            "    except (TypeError, ValueError):",
            "        pass",
            "    return False",
            "",
            "",
            "def python_list(value):",
            "    if not value:",
            "        value = []",
            "    if isinstance(value, list):",
            "        return value",
            "    return ast.literal_eval(value)",
            "",
            "",
            "def python_dict(value):",
            "    if not value:",
            "        value = {}",
            "    if isinstance(value, dict):",
            "        return value",
            "    return ast.literal_eval(value)",
            "",
            "",
            "def is_base64(b_str):",
            "    return BASE64_REGEX.match(b_str)",
            "",
            "",
            "def is_internet_available():",
            "    try:",
            "        proxies, verify = upstream_proxy('https')",
            "    except Exception:",
            "        logger.exception('Setting upstream proxy')",
            "    try:",
            "        requests.get(settings.GOOGLE,",
            "                     timeout=5,",
            "                     proxies=proxies,",
            "                     verify=verify)",
            "        return True",
            "    except Exception:",
            "        try:",
            "            requests.get(settings.BAIDU,",
            "                         timeout=5,",
            "                         proxies=proxies,",
            "                         verify=verify)",
            "            return True",
            "        except Exception:",
            "            return False",
            "",
            "",
            "def sha256(file_path):",
            "    blocksize = 65536",
            "    hasher = hashlib.sha256()",
            "    with io.open(file_path, mode='rb') as afile:",
            "        buf = afile.read(blocksize)",
            "        while buf:",
            "            hasher.update(buf)",
            "            buf = afile.read(blocksize)",
            "    return hasher.hexdigest()",
            "",
            "",
            "def sha256_object(file_obj):",
            "    blocksize = 65536",
            "    hasher = hashlib.sha256()",
            "    buf = file_obj.read(blocksize)",
            "    while buf:",
            "        hasher.update(buf)",
            "        buf = file_obj.read(blocksize)",
            "    return hasher.hexdigest()",
            "",
            "",
            "def gen_sha256_hash(msg):",
            "    \"\"\"Generate SHA 256 Hash of the message.\"\"\"",
            "    if isinstance(msg, str):",
            "        msg = msg.encode('utf-8')",
            "    hash_object = hashlib.sha256(msg)",
            "    return hash_object.hexdigest()",
            "",
            "",
            "def is_file_exists(file_path):",
            "    if os.path.isfile(file_path):",
            "        return True",
            "    # This fix situation where a user just typed \"adb\" or another executable",
            "    # inside settings.py/config.py",
            "    if shutil.which(file_path):",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "def is_dir_exists(dir_path):",
            "    if os.path.isdir(dir_path):",
            "        return True",
            "    else:",
            "        return False",
            "",
            "",
            "def find_process_by(name):",
            "    \"\"\"Return a set of process path matching name.\"\"\"",
            "    proc = set()",
            "    for p in psutil.process_iter(attrs=['name']):",
            "        if (name == p.info['name']):",
            "            proc.add(p.exe())",
            "    return proc",
            "",
            "",
            "def docker_translate_localhost(identifier):",
            "    \"\"\"Convert localhost to host.docker.internal.\"\"\"",
            "    if not identifier:",
            "        return identifier",
            "    if not os.getenv('MOBSF_PLATFORM') == 'docker':",
            "        return identifier",
            "    try:",
            "        identifier = identifier.strip()",
            "        docker_internal = 'host.docker.internal:'",
            "        if re.match(r'^emulator-\\d{4}$', identifier):",
            "            adb_port = int(identifier.split('emulator-')[1]) + 1",
            "            # ADB port is console port + 1",
            "            return f'{docker_internal}{adb_port}'",
            "        m = re.match(r'^(localhost|127\\.0\\.0\\.1):\\d{1,5}$', identifier)",
            "        if m:",
            "            adb_port = int(identifier.split(m.group(1))[1].replace(':', ''))",
            "            return f'{docker_internal}{adb_port}'",
            "        return identifier",
            "    except Exception:",
            "        logger.exception('Failed to convert device '",
            "                         'identifier for docker connectivity')",
            "        return identifier",
            "",
            "",
            "def docker_translate_proxy_ip(ip):",
            "    \"\"\"Convert localhost proxy ip to host.docker.internal.\"\"\"",
            "    if not os.getenv('MOBSF_PLATFORM') == 'docker':",
            "        return ip",
            "    if ip and ip.strip() in ('127.0.0.1', 'localhost'):",
            "        return 'host.docker.internal'",
            "    return ip",
            "",
            "",
            "def get_device():",
            "    \"\"\"Get Device.\"\"\"",
            "    if os.getenv('ANALYZER_IDENTIFIER'):",
            "        return docker_translate_localhost(",
            "            os.getenv('ANALYZER_IDENTIFIER'))",
            "    elif settings.ANALYZER_IDENTIFIER:",
            "        return docker_translate_localhost(",
            "            settings.ANALYZER_IDENTIFIER)",
            "    else:",
            "        dev_id = ''",
            "        out = subprocess.check_output([get_adb(), 'devices']).splitlines()",
            "        if len(out) > 2:",
            "            dev_id = out[1].decode('utf-8').split('\\t')[0]",
            "            if 'daemon started successfully' not in dev_id:",
            "                return docker_translate_localhost(dev_id)",
            "    logger.error(get_android_dm_exception_msg())",
            "",
            "",
            "def get_adb():",
            "    \"\"\"Get ADB binary path.\"\"\"",
            "    try:",
            "        adb_loc = None",
            "        adb_msg = ('Set adb path, ADB_BINARY in'",
            "                   f' {get_config_loc()}'",
            "                   ' with same adb binary used'",
            "                   ' by Genymotion VM/Emulator AVD.')",
            "        global ADB_PATH",
            "        if (len(settings.ADB_BINARY) > 0",
            "                and is_file_exists(settings.ADB_BINARY)):",
            "            ADB_PATH = settings.ADB_BINARY",
            "            return ADB_PATH",
            "        if ADB_PATH:",
            "            return ADB_PATH",
            "        if platform.system() == 'Windows':",
            "            adb_loc = find_process_by('adb.exe')",
            "        else:",
            "            adb_loc = find_process_by('adb')",
            "        if len(adb_loc) > 1:",
            "            logger.warning('Multiple ADB locations found. %s', adb_msg)",
            "            logger.warning(adb_loc)",
            "        if adb_loc:",
            "            ADB_PATH = adb_loc.pop()",
            "            return ADB_PATH",
            "    except Exception:",
            "        if not adb_loc:",
            "            logger.warning('Cannot find adb! %s', adb_msg)",
            "        logger.exception('Getting ADB Location')",
            "    finally:",
            "        if ADB_PATH:",
            "            os.environ['MOBSF_ADB'] = ADB_PATH",
            "        else:",
            "            os.environ['MOBSF_ADB'] = 'adb'",
            "            logger.warning('Dynamic Analysis related '",
            "                           'functions will not work. '",
            "                           '\\nMake sure a Genymotion Android VM/'",
            "                           'Android Studio Emulator'",
            "                           ' is running before performing'",
            "                           ' Dynamic Analysis.')",
            "    return 'adb'",
            "",
            "",
            "def check_basic_env():",
            "    \"\"\"Check if we have basic env for MobSF to run.\"\"\"",
            "    logger.info('MobSF Basic Environment Check')",
            "    try:",
            "        import http_tools  # noqa F401",
            "    except ImportError:",
            "        logger.exception('httptools not installed!')",
            "        os.kill(os.getpid(), signal.SIGTERM)",
            "    try:",
            "        import lxml  # noqa F401",
            "    except ImportError:",
            "        logger.exception('lxml is not installed!')",
            "        os.kill(os.getpid(), signal.SIGTERM)",
            "    if not is_file_exists(find_java_binary()):",
            "        logger.error(",
            "            'JDK 8+ is not available. '",
            "            'Set JAVA_HOME environment variable'",
            "            ' or JAVA_DIRECTORY in '",
            "            '%s', get_config_loc())",
            "        logger.info('Current Configuration: '",
            "                    'JAVA_DIRECTORY=%s', settings.JAVA_DIRECTORY)",
            "        logger.info('Example Configuration:'",
            "                    '\\nJAVA_DIRECTORY = \"C:/Program Files/'",
            "                    'Java/jdk1.7.0_17/bin/\"'",
            "                    '\\nJAVA_DIRECTORY = \"/usr/bin/\"')",
            "        os.kill(os.getpid(), signal.SIGTERM)",
            "",
            "",
            "def update_local_db(db_name, url, local_file):",
            "    \"\"\"Update Local DBs.\"\"\"",
            "    update = None",
            "    inmemoryfile = None",
            "    try:",
            "        proxies, verify = upstream_proxy('https')",
            "    except Exception:",
            "        logger.exception('[ERROR] Setting upstream proxy')",
            "    try:",
            "        response = requests.get(url,",
            "                                timeout=3,",
            "                                proxies=proxies,",
            "                                verify=verify)",
            "        resp = response.content",
            "        inmemoryfile = io.BytesIO(resp)",
            "        # Create on first run",
            "        if not is_file_exists(local_file):",
            "            return resp",
            "        # Check1: SHA256 Change",
            "        if sha256_object(inmemoryfile) != sha256(local_file):",
            "            # Hash Changed",
            "            logger.info('%s Database is outdated!', db_name)",
            "            update = resp",
            "        else:",
            "            logger.info('%s Database is up-to-date', db_name)",
            "        return update",
            "    except (requests.exceptions.ReadTimeout,",
            "            requests.exceptions.ConnectionError):",
            "        logger.warning('Failed to download %s DB.', db_name)",
            "    except Exception:",
            "        logger.exception('[ERROR] %s DB Update', db_name)",
            "        return update",
            "    finally:",
            "        if inmemoryfile:",
            "            inmemoryfile.truncate(0)",
            "",
            "",
            "def read_sqlite(sqlite_file):",
            "    \"\"\"Sqlite Dump - Readable Text.\"\"\"",
            "    logger.info('Reading SQLite db')",
            "    table_dict = {}",
            "    try:",
            "        con = sqlite3.connect(sqlite_file)",
            "        cur = con.cursor()",
            "        cur.execute('SELECT name FROM sqlite_master WHERE type=\\'table\\';')",
            "        tables = cur.fetchall()",
            "        for table in tables:",
            "            table_dict[table[0]] = {'head': [], 'data': []}",
            "            cur.execute('PRAGMA table_info(\\'%s\\')' % table)",
            "            rows = cur.fetchall()",
            "            for sq_row in rows:",
            "                table_dict[table[0]]['head'].append(sq_row[1])",
            "            cur.execute('SELECT * FROM \\'%s\\'' % table)",
            "            rows = cur.fetchall()",
            "            for sq_row in rows:",
            "                tmp_row = []",
            "                for each_row in sq_row:",
            "                    tmp_row.append(str(each_row))",
            "                table_dict[table[0]]['data'].append(tmp_row)",
            "    except Exception:",
            "        logger.exception('Reading SQLite db')",
            "    return table_dict",
            "",
            "",
            "def is_pipe_or_link(path):",
            "    \"\"\"Check for named pipe.\"\"\"",
            "    return os.path.islink(path) or stat.S_ISFIFO(os.stat(path).st_mode)",
            "",
            "",
            "def get_network():",
            "    \"\"\"Get Network IPs.\"\"\"",
            "    ips = []",
            "    try:",
            "        for det in psutil.net_if_addrs().values():",
            "            ips.append(det[0].address)",
            "    except Exception:",
            "        logger.exception('Failed to enumerate network interfaces')",
            "    return ips",
            "",
            "",
            "def get_proxy_ip(identifier):",
            "    \"\"\"Get Proxy IP.\"\"\"",
            "    proxy_ip = None",
            "    try:",
            "        if not identifier:",
            "            return proxy_ip",
            "        ips = get_network()",
            "        if ':' not in identifier or not ips:",
            "            return proxy_ip",
            "        device_ip = identifier.split(':', 1)[0]",
            "        ip_range = device_ip.rsplit('.', 1)[0]",
            "        guess_ip = ip_range + '.1'",
            "        if guess_ip in ips:",
            "            return guess_ip",
            "        for ip_addr in ips:",
            "            to_check = ip_addr.rsplit('.', 1)[0]",
            "            if to_check == ip_range:",
            "                return ip_addr",
            "    except Exception:",
            "        logger.error('Error getting Proxy IP')",
            "    return proxy_ip",
            "",
            "",
            "def is_safe_path(safe_root, check_path):",
            "    \"\"\"Detect Path Traversal.\"\"\"",
            "    safe_root = os.path.realpath(os.path.normpath(safe_root))",
            "    check_path = os.path.realpath(os.path.normpath(check_path))",
            "    return os.path.commonprefix([check_path, safe_root]) == safe_root",
            "",
            "",
            "def file_size(app_path):",
            "    \"\"\"Return the size of the file.\"\"\"",
            "    return round(float(os.path.getsize(app_path)) / (1024 * 1024), 2)",
            "",
            "",
            "def is_md5(user_input):",
            "    \"\"\"Check if string is valid MD5.\"\"\"",
            "    stat = MD5_REGEX.match(user_input)",
            "    if not stat:",
            "        logger.error('Invalid scan hash')",
            "    return stat",
            "",
            "",
            "def get_config_loc():",
            "    \"\"\"Get config location.\"\"\"",
            "    if settings.USE_HOME:",
            "        return os.path.join(",
            "            os.path.expanduser('~'),",
            "            '.MobSF',",
            "            'config.py',",
            "        )",
            "    else:",
            "        return 'MobSF/settings.py'",
            "",
            "",
            "def clean_filename(filename, replace=' '):",
            "    if platform.system() == 'Windows':",
            "        whitelist = f'-_.() {string.ascii_letters}{string.digits}'",
            "        # replace spaces",
            "        for r in replace:",
            "            filename = filename.replace(r, '_')",
            "        # keep only valid ascii chars",
            "        cleaned_filename = unicodedata.normalize(",
            "            'NFKD', filename).encode('ASCII', 'ignore').decode()",
            "        # keep only whitelisted chars",
            "        return ''.join(c for c in cleaned_filename if c in whitelist)",
            "    return filename",
            "",
            "",
            "def cmd_injection_check(data):",
            "    \"\"\"OS Cmd Injection from Commix.\"\"\"",
            "    breakers = [",
            "        ';', '%3B', '&', '%26', '&&',",
            "        '%26%26', '|', '%7C', '||',",
            "        '%7C%7C', '%0a', '%0d%0a',",
            "    ]",
            "    return any(i in data for i in breakers)",
            "",
            "",
            "def strict_package_check(user_input):",
            "    \"\"\"Strict package name check.",
            "",
            "    For android package and ios bundle id",
            "    \"\"\"",
            "    pat = re.compile(r'^([\\w-]*\\.)+[\\w-]{2,155}$')",
            "    resp = re.match(pat, user_input)",
            "    if not resp or '..' in user_input:",
            "        logger.error('Invalid package name/bundle id/class name')",
            "    return resp",
            "",
            "",
            "def strict_ios_class(user_input):",
            "    \"\"\"Strict check to see if input is valid iOS class.\"\"\"",
            "    pat = re.compile(r'^([\\w\\.]+)$')",
            "    resp = re.match(pat, user_input)",
            "    if not resp:",
            "        logger.error('Invalid class name')",
            "    return resp",
            "",
            "",
            "def is_instance_id(user_input):",
            "    \"\"\"Check if string is valid instance id.\"\"\"",
            "    reg = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'",
            "    stat = re.match(reg, user_input)",
            "    if not stat:",
            "        logger.error('Invalid instance identifier')",
            "    return stat",
            "",
            "",
            "def common_check(instance_id):",
            "    \"\"\"Common checks for instance APIs.\"\"\"",
            "    if not getattr(settings, 'CORELLIUM_API_KEY', ''):",
            "        return {",
            "            'status': 'failed',",
            "            'message': 'Missing Corellium API key'}",
            "    elif not is_instance_id(instance_id):",
            "        return {",
            "            'status': 'failed',",
            "            'message': 'Invalid instance identifier'}",
            "    else:",
            "        return None",
            "",
            "",
            "def is_path_traversal(user_input):",
            "    \"\"\"Check for path traversal.\"\"\"",
            "    if (('../' in user_input)",
            "        or ('%2e%2e' in user_input)",
            "        or ('..' in user_input)",
            "            or ('%252e' in user_input)):",
            "        logger.error('Path traversal attack detected')",
            "        return True",
            "    return False",
            "",
            "",
            "def is_zip_magic(file_obj):",
            "    magic = file_obj.read(4)",
            "    file_obj.seek(0, 0)",
            "    # ZIP magic PK.. no support for spanned and empty arch",
            "    return bool(magic == b'\\x50\\x4B\\x03\\x04')",
            "",
            "",
            "def is_elf_so_magic(file_obj):",
            "    magic = file_obj.read(4)",
            "    file_obj.seek(0, 0)",
            "    # ELF/SO Magic",
            "    return bool(magic == b'\\x7F\\x45\\x4C\\x46')",
            "",
            "",
            "def is_dylib_magic(file_obj):",
            "    magic = file_obj.read(4)",
            "    file_obj.seek(0, 0)",
            "    # DYLIB Magic",
            "    magics = (",
            "        b'\\xCA\\xFE\\xBA\\xBE',  # 32 bit",
            "        b'\\xFE\\xED\\xFA\\xCE',  # 32 bit",
            "        b'\\xCE\\xFA\\xED\\xFE',  # 32 bit",
            "        b'\\xFE\\xED\\xFA\\xCF',  # 64 bit",
            "        b'\\xCF\\xFA\\xED\\xFE',  # 64 bit",
            "        b'\\xCA\\xFE\\xBA\\xBF',  # 64 bit",
            "    )",
            "    return bool(magic in magics)",
            "",
            "",
            "def is_a_magic(file_obj):",
            "    magic = file_obj.read(4)",
            "    file_obj.seek(0, 0)",
            "    magics = (",
            "        b'\\x21\\x3C\\x61\\x72',",
            "        b'\\xCA\\xFE\\xBA\\xBF',  # 64 bit",
            "        b'\\xCA\\xFE\\xBA\\xBE',  # 32 bit",
            "    )",
            "    return bool(magic in magics)",
            "",
            "",
            "def disable_print():",
            "    sys.stdout = open(os.devnull, 'w')",
            "",
            "",
            "# Restore",
            "def enable_print():",
            "    sys.stdout = sys.__stdout__",
            "",
            "",
            "def find_key_in_dict(key, var):",
            "    \"\"\"Recursively look up a key in a nested dict.\"\"\"",
            "    if hasattr(var, 'items'):",
            "        for k, v in var.items():",
            "            if k == key:",
            "                yield v",
            "            if isinstance(v, dict):",
            "                for result in find_key_in_dict(key, v):",
            "                    yield result",
            "            elif isinstance(v, list):",
            "                for d in v:",
            "                    for result in find_key_in_dict(key, d):",
            "                        yield result",
            "",
            "",
            "def key(data, key_name):",
            "    \"\"\"Return the data for a key_name.\"\"\"",
            "    return data.get(key_name)",
            "",
            "",
            "def replace(value, arg):",
            "    \"\"\"",
            "    Replacing filter.",
            "",
            "    Use `{{ \"aaa\"|replace:\"a|b\" }}`",
            "    \"\"\"",
            "    if len(arg.split('|')) != 2:",
            "        return value",
            "",
            "    what, to = arg.split('|')",
            "    return value.replace(what, to)",
            "",
            "",
            "def relative_path(value):",
            "    \"\"\"Show relative path to two parents.\"\"\"",
            "    sep = None",
            "    if '/' in value:",
            "        sep = '/'",
            "    elif '\\\\\\\\' in value:",
            "        sep = '\\\\\\\\'",
            "    elif '\\\\' in value:",
            "        sep = '\\\\'",
            "    if not sep or value.count(sep) < 2:",
            "        return value",
            "    path = Path(value)",
            "    return path.relative_to(path.parent.parent).as_posix()",
            "",
            "",
            "def pretty_json(value):",
            "    \"\"\"Pretty print JSON.\"\"\"",
            "    try:",
            "        return json.dumps(json.loads(value), indent=4)",
            "    except Exception:",
            "        return value",
            "",
            "",
            "def base64_decode(value):",
            "    \"\"\"Try Base64 decode.\"\"\"",
            "    commonb64s = ('eyJ0')",
            "    decoded = None",
            "    try:",
            "        if is_base64(value) or value.startswith(commonb64s):",
            "            decoded = base64.b64decode(",
            "                value).decode('ISO-8859-1')",
            "    except Exception:",
            "        pass",
            "    if decoded:",
            "        return f'{value}\\n\\nBase64 Decoded: {decoded}'",
            "    return value",
            "",
            "",
            "def base64_encode(value):",
            "    \"\"\"Base64 encode.\"\"\"",
            "    if isinstance(value, str):",
            "        value = value.encode('utf-8')",
            "    return base64.b64encode(value)",
            "",
            "",
            "def android_component(data):",
            "    \"\"\"Return Android component from data.\"\"\"",
            "    cmp = ''",
            "    if 'Activity-Alias' in data:",
            "        cmp = 'activity_alias_'",
            "    elif 'Activity' in data:",
            "        cmp = 'activity_'",
            "    elif 'Service' in data:",
            "        cmp = 'service_'",
            "    elif 'Content Provider' in data:",
            "        cmp = 'provider_'",
            "    elif 'Broadcast Receiver' in data:",
            "        cmp = 'receiver_'",
            "    return cmp",
            "",
            "",
            "def get_android_dm_exception_msg():",
            "    return (",
            "        'Is your Android VM/emulator running? MobSF cannot'",
            "        ' find the android device identifier.'",
            "        ' Please read official documentation.'",
            "        ' If this error persists, set ANALYZER_IDENTIFIER in '",
            "        f'{get_config_loc()} or via environment variable'",
            "        ' MOBSF_ANALYZER_IDENTIFIER')",
            "",
            "",
            "def get_android_src_dir(app_dir, typ):",
            "    \"\"\"Get Android source code location.\"\"\"",
            "    if typ == 'apk':",
            "        src = app_dir / 'java_source'",
            "    elif typ == 'studio':",
            "        src = app_dir / 'app' / 'src' / 'main' / 'java'",
            "        kt = app_dir / 'app' / 'src' / 'main' / 'kotlin'",
            "        if not src.exists() and kt.exists():",
            "            src = kt",
            "    elif typ == 'eclipse':",
            "        src = app_dir / 'src'",
            "    return src",
            "",
            "",
            "def settings_enabled(attr):",
            "    \"\"\"Get settings state if present.\"\"\"",
            "    disabled = ('', ' ', '\"\"', '\" \"', '0', '\"0\"', False)",
            "    try:",
            "        return getattr(settings, attr) not in disabled",
            "    except Exception:",
            "        return False",
            "",
            "",
            "def id_generator(size=6, chars=string.ascii_uppercase + string.digits):",
            "    \"\"\"Generate random string.\"\"\"",
            "    return ''.join(random.choice(chars) for _ in range(size))",
            "",
            "",
            "def valid_host(host):",
            "    \"\"\"Check if host is valid.\"\"\"",
            "    try:",
            "        prefixs = ('http://', 'https://')",
            "        if not host.startswith(prefixs):",
            "            host = f'http://{host}'",
            "        parsed = urlparse(host)",
            "        domain = parsed.netloc",
            "        path = parsed.path",
            "        if len(domain) == 0:",
            "            # No valid domain",
            "            return False",
            "        if len(path) > 0:",
            "            # Only host is allowed",
            "            return False",
            "        if ':' in domain:",
            "            # IPv6",
            "            return False",
            "        # Local network",
            "        invalid_prefix = (",
            "            '127.',",
            "            '192.',",
            "            '10.',",
            "            '172.',",
            "            '169',",
            "            '0.',",
            "            'localhost')",
            "        if domain.startswith(invalid_prefix):",
            "            return False",
            "        ip = socket.gethostbyname(domain)",
            "        if ip.startswith(invalid_prefix):",
            "            # Resolve dns to get IP",
            "            return False",
            "        return True",
            "    except Exception:",
            "        return False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "aiosmtpd.smtp.SMTP"
        ]
    },
    "mobsf/StaticAnalyzer/views/android/manifest_analysis.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from concurrent.futures import ThreadPoolExecutor"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from mobsf.MobSF.utils import ("
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+    is_number,"
            },
            "4": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     upstream_proxy,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+    valid_host,"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " )"
            },
            "7": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from mobsf.StaticAnalyzer.views.android import ("
            },
            "8": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     android_manifest_desc,"
            },
            "9": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "                           and scheme in ('http', 'https')"
            },
            "10": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "                           and host"
            },
            "11": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "                           and host != '*'):"
            },
            "12": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        host = host.replace('*.', '')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                        host = host.replace('*.', '').replace('#', '')"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                        if not valid_host(host):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                            continue"
            },
            "16": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "                         shost = f'{scheme}://{host}'"
            },
            "17": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        if port:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                        if port and is_number(port):"
            },
            "19": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "                             c_url = f'{shost}:{port}{well_known_path}'"
            },
            "20": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "                         else:"
            },
            "21": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "                             c_url = f'{shost}{well_known_path}'"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf_8 -*-",
            "# flake8: noqa",
            "\"\"\"Module for android manifest analysis.\"\"\"",
            "import logging",
            "",
            "import requests",
            "from concurrent.futures import ThreadPoolExecutor",
            "",
            "from mobsf.MobSF.utils import (",
            "    upstream_proxy,",
            ")",
            "from mobsf.StaticAnalyzer.views.android import (",
            "    android_manifest_desc,",
            "    network_security,",
            ")",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "ANDROID_4_2_LEVEL = 17",
            "ANDROID_5_0_LEVEL = 21",
            "ANDROID_8_0_LEVEL = 26",
            "ANDROID_9_0_LEVEL = 28",
            "ANDROID_10_0_LEVEL = 29",
            "ANDROID_MANIFEST_FILE = 'AndroidManifest.xml'",
            "ANDROID_API_LEVEL_MAP = {",
            "    '1': '1.0',",
            "    '2': '1.1',",
            "    '3': '1.5',",
            "    '4': '1.6',",
            "    '5': '2.0-2.1',",
            "    '8': '2.2-2.2.3',",
            "    '9': '2.3-2.3.2',",
            "    '10': '2.3.3-2.3.7',",
            "    '11': '3.0',",
            "    '12': '3.1',",
            "    '13': '3.2-3.2.6',",
            "    '14': '4.0-4.0.2',",
            "    '15': '4.0.3-4.0.4',",
            "    '16': '4.1-4.1.2',",
            "    '17': '4.2-4.2.2',",
            "    '18': '4.3-4.3.1',",
            "    '19': '4.4-4.4.4',",
            "    '20': '4.4W-4.4W.2',",
            "    '21': '5.0-5.0.2',",
            "    '22': '5.1-5.1.1',",
            "    '23': '6.0-6.0.1',",
            "    '24': '7.0',",
            "    '25': '7.1-7.1.2',",
            "    '26': '8.0',",
            "    '27': '8.1',",
            "    '28': '9',",
            "    '29': '10',",
            "    '30': '11',",
            "    '31': '12',",
            "    '32': '12L',",
            "    '33': '13',",
            "    '34': '14',",
            "}",
            "",
            "",
            "def assetlinks_check(act_name, well_knowns):",
            "    \"\"\"Well known assetlink check.\"\"\"",
            "    findings = []",
            "",
            "    with ThreadPoolExecutor() as executor:",
            "        futures = []",
            "        for w_url, host in well_knowns.items():",
            "            logger.info(",
            "                'App Link Assetlinks Check - [%s] %s', act_name, host)",
            "            futures.append(",
            "                executor.submit(_check_url, host, w_url))",
            "        for future in futures:",
            "            findings.append(future.result())",
            "",
            "    return findings",
            "",
            "def _check_url(host, w_url):",
            "    try:",
            "        iden = 'sha256_cert_fingerprints'",
            "        proxies, verify = upstream_proxy('https')",
            "        status = False",
            "        status_code = 0",
            "",
            "        r = requests.get(w_url,",
            "            allow_redirects=True,",
            "            proxies=proxies,",
            "            verify=verify,",
            "            timeout=5)",
            "",
            "        status_code = r.status_code",
            "        if (str(status_code).startswith('2') and iden in str(r.json())):",
            "            status = True",
            "",
            "        return {'url': w_url,",
            "                'host': host,",
            "                'status_code': status_code,",
            "                'status': status}",
            "",
            "    except Exception:",
            "        logger.error(f'Well Known Assetlinks Check for URL: {w_url}')",
            "        return {'url': w_url, ",
            "                'host': host,",
            "                'status_code': None,",
            "                'status': False}",
            "",
            "",
            "def get_browsable_activities(node, ns):",
            "    \"\"\"Get Browsable Activities.\"\"\"",
            "    try:",
            "        browse_dic = {}",
            "        schemes = []",
            "        mime_types = []",
            "        hosts = []",
            "        ports = []",
            "        paths = []",
            "        path_prefixs = []",
            "        path_patterns = []",
            "        well_known = {}",
            "        well_known_path = '/.well-known/assetlinks.json'",
            "        catg = node.getElementsByTagName('category')",
            "        for cat in catg:",
            "            if cat.getAttribute(f'{ns}:name') == 'android.intent.category.BROWSABLE':",
            "                data_tag = node.getElementsByTagName('data')",
            "                for data in data_tag:",
            "                    scheme = data.getAttribute(f'{ns}:scheme')",
            "                    if scheme and scheme not in schemes:",
            "                        schemes.append(scheme)",
            "                    mime = data.getAttribute(f'{ns}:mimeType')",
            "                    if mime and mime not in mime_types:",
            "                        mime_types.append(mime)",
            "                    host = data.getAttribute(f'{ns}:host')",
            "                    if host and host not in hosts:",
            "                        hosts.append(host)",
            "                    port = data.getAttribute(f'{ns}:port')",
            "                    if port and port not in ports:",
            "                        ports.append(port)",
            "                    path = data.getAttribute(f'{ns}:path')",
            "                    if path and path not in paths:",
            "                        paths.append(path)",
            "                    path_prefix = data.getAttribute(f'{ns}:pathPrefix')",
            "                    if path_prefix and path_prefix not in path_prefixs:",
            "                        path_prefixs.append(path_prefix)",
            "                    path_pattern = data.getAttribute(f'{ns}:pathPattern')",
            "                    if path_pattern and path_pattern not in path_patterns:",
            "                        path_patterns.append(path_pattern)",
            "                    # Collect possible well-known paths",
            "                    if (scheme",
            "                          and scheme in ('http', 'https')",
            "                          and host",
            "                          and host != '*'):",
            "                        host = host.replace('*.', '')",
            "                        shost = f'{scheme}://{host}'",
            "                        if port:",
            "                            c_url = f'{shost}:{port}{well_known_path}'",
            "                        else:",
            "                            c_url = f'{shost}{well_known_path}'",
            "                        well_known[c_url] = shost",
            "        schemes = [scheme + '://' for scheme in schemes]",
            "        browse_dic['schemes'] = schemes",
            "        browse_dic['mime_types'] = mime_types",
            "        browse_dic['hosts'] = hosts",
            "        browse_dic['ports'] = ports",
            "        browse_dic['paths'] = paths",
            "        browse_dic['path_prefixs'] = path_prefixs",
            "        browse_dic['path_patterns'] = path_patterns",
            "        browse_dic['browsable'] = bool(browse_dic['schemes'])",
            "        browse_dic['well_known'] = well_known",
            "        return browse_dic",
            "    except Exception:",
            "        logger.exception('Getting Browsable Activities')",
            "",
            "",
            "def manifest_analysis(mfxml, ns, man_data_dic, src_type, app_dir):",
            "    \"\"\"Analyse manifest file.\"\"\"",
            "    # pylint: disable=C0301",
            "    try:",
            "        logger.info('Manifest Analysis Started')",
            "        exp_count = dict.fromkeys(['act', 'ser', 'bro', 'cnt'], 0)",
            "        applications = mfxml.getElementsByTagName('application')",
            "        data_tag = mfxml.getElementsByTagName('data')",
            "        intents = mfxml.getElementsByTagName('intent-filter')",
            "        actions = mfxml.getElementsByTagName('action')",
            "        granturipermissions = mfxml.getElementsByTagName(",
            "            'grant-uri-permission')",
            "        permissions = mfxml.getElementsByTagName('permission')",
            "        ret_value = []",
            "        ret_list = []",
            "        exported = []",
            "        browsable_activities = {}",
            "        permission_dict = {}",
            "        do_netsec = False",
            "        debuggable = False",
            "        # PERMISSION",
            "        for permission in permissions:",
            "            if permission.getAttribute(f'{ns}:protectionLevel'):",
            "                protectionlevel = permission.getAttribute(",
            "                    f'{ns}:protectionLevel')",
            "                if protectionlevel == '0x00000000':",
            "                    protectionlevel = 'normal'",
            "                elif protectionlevel == '0x00000001':",
            "                    protectionlevel = 'dangerous'",
            "                elif protectionlevel == '0x00000002':",
            "                    protectionlevel = 'signature'",
            "                elif protectionlevel == '0x00000003':",
            "                    protectionlevel = 'signatureOrSystem'",
            "",
            "                permission_dict[permission.getAttribute(",
            "                    f'{ns}:name')] = protectionlevel",
            "            elif permission.getAttribute(f'{ns}:name'):",
            "                permission_dict[permission.getAttribute(",
            "                    f'{ns}:name')] = 'normal'",
            "        # GENERAL",
            "        if man_data_dic['min_sdk'] and int(man_data_dic['min_sdk']) < ANDROID_8_0_LEVEL:",
            "            minsdk = man_data_dic.get('min_sdk')",
            "            android_version = ANDROID_API_LEVEL_MAP.get(minsdk, 'XX')",
            "            ret_list.append(('vulnerable_os_version', (android_version, minsdk,), ()))",
            "        elif man_data_dic['min_sdk'] and int(man_data_dic['min_sdk']) < ANDROID_10_0_LEVEL:",
            "            minsdk = man_data_dic.get('min_sdk')",
            "            android_version = ANDROID_API_LEVEL_MAP.get(minsdk, 'XX')",
            "            ret_list.append(('vulnerable_os_version2', (android_version, minsdk,), ()))",
            "        # APPLICATIONS",
            "        # Handle multiple application tags in AAR",
            "        backupDisabled = False",
            "        for application in applications:",
            "            # Esteve 23.07.2016 - begin - identify permission at the",
            "            # application level",
            "            if application.getAttribute(f'{ns}:permission'):",
            "                perm_appl_level_exists = True",
            "                perm_appl_level = application.getAttribute(",
            "                    f'{ns}:permission')",
            "            else:",
            "                perm_appl_level_exists = False",
            "            # End",
            "            if application.getAttribute(f'{ns}:usesCleartextTraffic') == 'true':",
            "                ret_list.append(('clear_text_traffic', (), ()))",
            "            if application.getAttribute(f'{ns}:directBootAware') == 'true':",
            "                ret_list.append(('direct_boot_aware', (), ()))",
            "            if application.getAttribute(f'{ns}:networkSecurityConfig'):",
            "                item = application.getAttribute(f'{ns}:networkSecurityConfig')",
            "                ret_list.append(('has_network_security', (item,), ()))",
            "                do_netsec = item",
            "            if application.getAttribute(f'{ns}:debuggable') == 'true':",
            "                ret_list.append(('app_is_debuggable', (), ()))",
            "                debuggable = True",
            "            if application.getAttribute(f'{ns}:allowBackup') == 'true':",
            "                ret_list.append(('app_allowbackup', (), ()))",
            "            elif application.getAttribute(f'{ns}:allowBackup') == 'false':",
            "                backupDisabled = True",
            "            else:",
            "                if not backupDisabled:",
            "                    ret_list.append(('allowbackup_not_set', (), ()))",
            "            if application.getAttribute(f'{ns}:testOnly') == 'true':",
            "                ret_list.append(('app_in_test_mode', (), ()))",
            "            for node in application.childNodes:",
            "                an_or_a = ''",
            "                if node.nodeName == 'activity':",
            "                    itemname = 'Activity'",
            "                    cnt_id = 'act'",
            "                    an_or_a = 'n'",
            "                elif node.nodeName == 'activity-alias':",
            "                    itemname = 'Activity-Alias'",
            "                    cnt_id = 'act'",
            "                    an_or_a = 'n'",
            "                elif node.nodeName == 'provider':",
            "                    itemname = 'Content Provider'",
            "                    cnt_id = 'cnt'",
            "                elif node.nodeName == 'receiver':",
            "                    itemname = 'Broadcast Receiver'",
            "                    cnt_id = 'bro'",
            "                elif node.nodeName == 'service':",
            "                    itemname = 'Service'",
            "                    cnt_id = 'ser'",
            "                else:",
            "                    itemname = 'NIL'",
            "                item = ''",
            "                # Checks for Activities",
            "                if itemname in ['Activity', 'Activity-Alias']:",
            "                    item = node.getAttribute(f'{ns}:name')",
            "                    # Browsable Activities",
            "                    browse_dic = get_browsable_activities(node, ns)",
            "                    if browse_dic['browsable']:",
            "                        browsable_activities[node.getAttribute(",
            "                            f'{ns}:name')] = browse_dic",
            "                    for finding in assetlinks_check(item, browse_dic['well_known']):",
            "                        if not finding['status']:",
            "                            ret_list.append(('well_known_assetlinks',",
            "                                            (item, finding['host']),",
            "                                            (finding['url'],",
            "                                             finding['status_code'])))",
            "",
            "                    # Task Affinity",
            "                    task_affinity = node.getAttribute(f'{ns}:taskAffinity')",
            "                    if (task_affinity):",
            "                        ret_list.append(('task_affinity_set', (item,), ()))",
            "",
            "                    # LaunchMode",
            "                    try:",
            "                        affected_sdk = int(",
            "                            man_data_dic['min_sdk']) < ANDROID_5_0_LEVEL",
            "                    except Exception:",
            "                        # in case min_sdk is not defined we assume vulnerability",
            "                        affected_sdk = True",
            "                    launchmode = node.getAttribute(f'{ns}:launchMode')",
            "                    modes = ('singleTask', 'singleInstance')",
            "                    if (affected_sdk",
            "                            and launchmode in modes):",
            "                        ret_list.append(('non_standard_launchmode', (item,), ()))",
            "",
            "                    # Android Task Hijacking or StrandHogg 1.0",
            "                    try:",
            "                        target_sdk = int(man_data_dic['target_sdk'])",
            "                    except Exception:",
            "                        try:",
            "                            target_sdk = int(man_data_dic['min_sdk'])",
            "                        except Exception:",
            "                            target_sdk = ANDROID_8_0_LEVEL",
            "                    if (target_sdk < ANDROID_9_0_LEVEL",
            "                            and launchmode == 'singleTask'):",
            "                        ret_list.append(('task_hijacking', (item,), (target_sdk,)))",
            "",
            "                    # Android StrandHogg 2.0",
            "                    exported_act = node.getAttribute(f'{ns}:exported')",
            "                    if (target_sdk < ANDROID_10_0_LEVEL",
            "                            and exported_act == 'true'",
            "                            and (launchmode != 'singleInstance' or task_affinity != '')):",
            "                        ret_list.append(('task_hijacking2', (item,), (target_sdk,)))",
            "",
            "                # Exported Check",
            "                item = ''",
            "                is_inf = False",
            "                is_perm_exist = False",
            "                # Esteve 23.07.2016 - begin - initialise variables to identify",
            "                # the existence of a permission at the component level that",
            "                # matches a permission at the manifest level",
            "                prot_level_exist = False",
            "                protlevel = ''",
            "                # End",
            "                if itemname != 'NIL':",
            "                    if node.getAttribute(f'{ns}:exported') == 'true':",
            "                        perm = ''",
            "                        item = node.getAttribute(f'{ns}:name')",
            "                        if node.getAttribute(f'{ns}:permission'):",
            "                            # permission exists",
            "                            perm = ('<strong>Permission: </strong>'",
            "                                    + node.getAttribute(f'{ns}:permission'))",
            "                            is_perm_exist = True",
            "                        if item != man_data_dic['mainactivity']:",
            "                            if is_perm_exist:",
            "                                prot = ''",
            "                                if node.getAttribute(f'{ns}:permission') in permission_dict:",
            "                                    prot = ('</br><strong>protectionLevel: </strong>'",
            "                                            + permission_dict[node.getAttribute(f'{ns}:permission')])",
            "                                    # Esteve 23.07.2016 - begin - take into account protection level of the permission when claiming that a component is protected by it;",
            "                                    # - the permission might not be defined in the application being analysed, if so, the protection level is not known;",
            "                                    # - activities (or activity-alias) that are exported and have an unknown or normal or dangerous protection level are",
            "                                    # included in the EXPORTED data structure for further treatment; components in this situation are also",
            "                                    # counted as exported.",
            "                                    prot_level_exist = True",
            "                                    protlevel = permission_dict[",
            "                                        node.getAttribute(f'{ns}:permission')]",
            "                                if prot_level_exist:",
            "                                    if protlevel == 'normal':",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_normal', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                    elif protlevel == 'dangerous':",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_dangerous', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                    elif protlevel == 'signature':",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_signature', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                    elif protlevel == 'signatureOrSystem':",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_signatureorsystem', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                else:",
            "                                    ret_list.append(",
            "                                        ('exported_protected_permission_not_defined', (itemname, item, perm), (an_or_a, itemname)))",
            "                                    if itemname in ['Activity', 'Activity-Alias']:",
            "                                        exported.append(item)",
            "                                    exp_count[cnt_id] = exp_count[cnt_id] + 1",
            "                                # Esteve 23.07.2016 - end",
            "                            else:",
            "                                # Esteve 24.07.2016 - begin - At this point, we are dealing with components that do not have a permission neither at the component level nor at the",
            "                                # application level. As they are exported, they",
            "                                # are not protected.",
            "                                if perm_appl_level_exists is False:",
            "                                    ret_list.append(",
            "                                        ('explicitly_exported', (itemname, item), (an_or_a, itemname)))",
            "                                    if itemname in ['Activity', 'Activity-Alias']:",
            "                                        exported.append(item)",
            "                                    exp_count[cnt_id] = exp_count[cnt_id] + 1",
            "                                # Esteve 24.07.2016 - end",
            "                                # Esteve 24.07.2016 - begin - At this point, we are dealing with components that have a permission at the application level, but not at the component",
            "                                #  level. Two options are possible:",
            "                                #        1) The permission is defined at the manifest level, which allows us to differentiate the level of protection as",
            "                                #           we did just above for permissions specified at the component level.",
            "                                #        2) The permission is not defined at the manifest level, which means the protection level is unknown, as it is not",
            "                                # defined in the analysed application.",
            "                                else:",
            "                                    perm = '<strong>Permission: </strong>' + perm_appl_level",
            "                                    prot = ''",
            "                                    if perm_appl_level in permission_dict:",
            "                                        prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                + permission_dict[perm_appl_level])",
            "                                        prot_level_exist = True",
            "                                        protlevel = permission_dict[",
            "                                            perm_appl_level]",
            "                                    if prot_level_exist:",
            "                                        if protlevel == 'normal':",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission_normal_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            if itemname in ['Activity', 'Activity-Alias']:",
            "                                                exported.append(item)",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                        elif protlevel == 'dangerous':",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission_dangerous_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            if itemname in ['Activity', 'Activity-Alias']:",
            "                                                exported.append(item)",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                        elif protlevel == 'signature':",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        elif protlevel == 'signatureOrSystem':",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission_signatureorsystem_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                    else:",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_app_level', (itemname, item, perm), (an_or_a, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                # Esteve 24.07.2016 - end",
            "",
            "                    elif node.getAttribute(f'{ns}:exported') != 'false':",
            "                        # Check for Implicitly Exported",
            "                        # Logic to support intent-filter",
            "                        intentfilters = node.childNodes",
            "                        for i in intentfilters:",
            "                            inf = i.nodeName",
            "                            if inf == 'intent-filter':",
            "                                is_inf = True",
            "                        if is_inf:",
            "                            item = node.getAttribute(f'{ns}:name')",
            "                            if node.getAttribute(f'{ns}:permission'):",
            "                                # permission exists",
            "                                perm = ('<strong>Permission: </strong>'",
            "                                        + node.getAttribute(f'{ns}:permission'))",
            "                                is_perm_exist = True",
            "                            if item != man_data_dic['mainactivity']:",
            "                                if is_perm_exist:",
            "                                    prot = ''",
            "                                    if node.getAttribute(f'{ns}:permission') in permission_dict:",
            "                                        prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                + permission_dict[node.getAttribute(f'{ns}:permission')])",
            "                                        # Esteve 24.07.2016 - begin - take into account protection level of the permission when claiming that a component is protected by it;",
            "                                        # - the permission might not be defined in the application being analysed, if so, the protection level is not known;",
            "                                        # - activities (or activity-alias) that are exported and have an unknown or normal or dangerous protection level are",
            "                                        #  included in the EXPORTED data structure for further treatment; components in this situation are also",
            "                                        #  counted as exported.",
            "                                        prot_level_exist = True",
            "                                        protlevel = permission_dict[",
            "                                            node.getAttribute(f'{ns}:permission')]",
            "                                        if prot_level_exist:",
            "                                            if protlevel == 'normal':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_normal', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                if itemname in ['Activity', 'Activity-Alias']:",
            "                                                    exported.append(item)",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'dangerous':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_dangerous', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                if itemname in ['Activity', 'Activity-Alias']:",
            "                                                    exported.append(item)",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'signature':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_signature', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            elif protlevel == 'signatureOrSystem':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_signatureorsystem', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                    else:",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_not_defined', (itemname, item, perm), (an_or_a, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                    # Esteve 24.07.2016 - end",
            "                                else:",
            "                                    # Esteve 24.07.2016 - begin - At this point, we are dealing with components that do not have a permission neither at the component level nor at the",
            "                                    # application level. As they are exported,",
            "                                    # they are not protected.",
            "                                    if perm_appl_level_exists is False:",
            "                                        ret_list.append(",
            "                                            ('exported_intent_filter_exists', (itemname, item), (an_or_a, itemname, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                    # Esteve 24.07.2016 - end",
            "                                    # Esteve 24.07.2016 - begin - At this point, we are dealing with components that have a permission at the application level, but not at the component",
            "                                    # level. Two options are possible:",
            "                                    # 1) The permission is defined at the manifest level, which allows us to differentiate the level of protection as",
            "                                    #  we did just above for permissions specified at the component level.",
            "                                    # 2) The permission is not defined at the manifest level, which means the protection level is unknown, as it is not",
            "                                    #  defined in the analysed application.",
            "                                    else:",
            "                                        perm = '<strong>Permission: </strong>' + perm_appl_level",
            "                                        prot = ''",
            "                                        if perm_appl_level in permission_dict:",
            "                                            prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                    + permission_dict[perm_appl_level])",
            "                                            prot_level_exist = True",
            "                                            protlevel = permission_dict[",
            "                                                perm_appl_level]",
            "                                        if prot_level_exist:",
            "                                            if protlevel == 'normal':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_normal_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                if itemname in ['Activity', 'Activity-Alias']:",
            "                                                    exported.append(item)",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'dangerous':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_dangerous_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                if itemname in ['Activity', 'Activity-Alias']:",
            "                                                    exported.append(item)",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'signature':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            elif protlevel == 'signatureOrSystem':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_signatureorsystem_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        else:",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission_app_level', (itemname, item, perm), (an_or_a, itemname)))",
            "                                            if itemname in ['Activity', 'Activity-Alias']:",
            "                                                exported.append(item)",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                    # Esteve 24.07.2016 - end",
            "                                    # Esteve 29.07.2016 - begin The component is not explicitly exported (android:exported is not 'true'). It is not implicitly exported either (it does not",
            "                                    # make use of an intent filter). Despite that, it could still be exported by default, if it is a content provider and the android:targetSdkVersion",
            "                                    # is older than 17 (Jelly Bean, Android version 4.2). This is true regardless of the system's API level.",
            "                                    # Finally, it must also be taken into account that, if the minSdkVersion is greater or equal than 17, this check is unnecessary, because the",
            "                                    # app will not be run on a system where the",
            "                                    # system's API level is below 17.",
            "                        else:",
            "                            if man_data_dic['min_sdk'] and man_data_dic['target_sdk'] and int(man_data_dic['min_sdk']) < ANDROID_4_2_LEVEL:",
            "                                if itemname == 'Content Provider' and int(man_data_dic['target_sdk']) < ANDROID_4_2_LEVEL:",
            "                                    perm = ''",
            "                                    item = node.getAttribute(f'{ns}:name')",
            "                                    if node.getAttribute(f'{ns}:permission'):",
            "                                        # permission exists",
            "                                        perm = ('<strong>Permission: </strong>'",
            "                                                + node.getAttribute(f'{ns}:permission'))",
            "                                        is_perm_exist = True",
            "                                    if is_perm_exist:",
            "                                        prot = ''",
            "                                        if node.getAttribute(f'{ns}:permission') in permission_dict:",
            "                                            prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                    + permission_dict[node.getAttribute(f'{ns}:permission')])",
            "                                            prot_level_exist = True",
            "                                            protlevel = permission_dict[",
            "                                                node.getAttribute(f'{ns}:permission')]",
            "                                        if prot_level_exist:",
            "                                            if protlevel == 'normal':",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_normal', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'dangerous':",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_danger', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'signature':",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_signature', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            elif protlevel == 'signatureOrSystem':",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_signatureorsystem', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        else:",
            "                                            ret_list.append(",
            "                                                ('exported_provider_unknown', (itemname, item, perm), (an_or_a, itemname)))",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                    else:",
            "                                        if perm_appl_level_exists is False:",
            "                                            ret_list.append(",
            "                                                ('exported_provider', (itemname, item), (an_or_a, itemname)))",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                        else:",
            "                                            perm = '<strong>Permission: </strong>' + perm_appl_level",
            "                                            prot = ''",
            "                                            if perm_appl_level in permission_dict:",
            "                                                prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                        + permission_dict[perm_appl_level])",
            "                                                prot_level_exist = True",
            "                                                protlevel = permission_dict[",
            "                                                    perm_appl_level]",
            "                                            if prot_level_exist:",
            "                                                if protlevel == 'normal':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_normal_app', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                                elif protlevel == 'dangerous':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_danger_appl', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                                elif protlevel == 'signature':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_signature_appl', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                elif protlevel == 'signatureOrSystem':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_signatureorsystem_app', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            else:",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_unknown_app', (itemname, item, perm), (an_or_a, itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                    # Esteve 29.07.2016 - end",
            "                                    # Esteve 08.08.2016 - begin - If the content provider does not target an API version lower than 17, it could still be exported by default, depending",
            "                                    # on the API version of the platform. If it was below 17, the content",
            "                                    # provider would be exported by default.",
            "                                else:",
            "                                    if itemname == 'Content Provider' and int(man_data_dic['target_sdk']) >= 17:",
            "                                        perm = ''",
            "                                        item = node.getAttribute(",
            "                                            f'{ns}:name')",
            "                                        if node.getAttribute(f'{ns}:permission'):",
            "                                            # permission exists",
            "                                            perm = ('<strong>Permission: </strong>'",
            "                                                    + node.getAttribute(f'{ns}:permission'))",
            "                                            is_perm_exist = True",
            "                                        if is_perm_exist:",
            "                                            prot = ''",
            "                                            if node.getAttribute(f'{ns}:permission') in permission_dict:",
            "                                                prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                        + permission_dict[node.getAttribute(f'{ns}:permission')])",
            "                                                prot_level_exist = True",
            "                                                protlevel = permission_dict[",
            "                                                    node.getAttribute(f'{ns}:permission')]",
            "                                            if prot_level_exist:",
            "                                                if protlevel == 'normal':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_normal_new', (itemname, item, perm + prot), (itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                                if protlevel == 'dangerous':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_danger_new', (itemname, item, perm + prot), (itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                                if protlevel == 'signature':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_signature_new', (itemname, item, perm + prot), (itemname)))",
            "                                                if protlevel == 'signatureOrSystem':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_signatureorsystem_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            else:",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_unknown_new', (itemname, item, perm), (itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                        else:",
            "                                            if perm_appl_level_exists is False:",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_2', (itemname, item), (an_or_a, itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            else:",
            "                                                perm = '<strong>Permission: </strong>' + perm_appl_level",
            "                                                prot = ''",
            "                                                if perm_appl_level in permission_dict:",
            "                                                    prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                            + permission_dict[perm_appl_level])",
            "                                                    prot_level_exist = True",
            "                                                    protlevel = permission_dict[",
            "                                                        perm_appl_level]",
            "                                                if prot_level_exist:",
            "                                                    if protlevel == 'normal':",
            "                                                        ret_list.append(",
            "                                                            ('exported_provider_normal_app_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                        exp_count[cnt_id] = exp_count[",
            "                                                            cnt_id] + 1",
            "                                                    elif protlevel == 'dangerous':",
            "                                                        ret_list.append(",
            "                                                            ('exported_provider_danger_app_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                        exp_count[cnt_id] = exp_count[",
            "                                                            cnt_id] + 1",
            "                                                    elif protlevel == 'signature':",
            "                                                        ret_list.append(",
            "                                                            ('exported_provider_signature_app_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                    elif protlevel == 'signatureOrSystem':",
            "                                                        ret_list.append(",
            "                                                            ('exported_provider_signatureorsystem_app_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                else:",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_unknown_app_new', (itemname, item, perm), (an_or_a, itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                    # Esteve 08.08.2016 - end",
            "",
            "        # GRANT-URI-PERMISSIONS",
            "        for granturi in granturipermissions:",
            "            if granturi.getAttribute(f'{ns}:pathPrefix') == '/':",
            "                ret_list.append(",
            "                    ('improper_provider_permission', ('pathPrefix=/',), ()))",
            "            elif granturi.getAttribute(f'{ns}:path') == '/':",
            "                ret_list.append(('improper_provider_permission', ('path=/',), ()))",
            "            elif granturi.getAttribute(f'{ns}:pathPattern') == '*':",
            "                ret_list.append(('improper_provider_permission', ('path=*',), ()))",
            "        # DATA",
            "        for data in data_tag:",
            "            if data.getAttribute(f'{ns}:scheme') == 'android_secret_code':",
            "                xmlhost = data.getAttribute(f'{ns}:host')",
            "                ret_list.append(('dialer_code_found', (xmlhost,), ()))",
            "",
            "            elif data.getAttribute(f'{ns}:port'):",
            "                dataport = data.getAttribute(f'{ns}:port')",
            "                ret_list.append(('sms_receiver_port_found', (dataport,), ()))",
            "        # INTENTS",
            "        for intent in intents:",
            "            if intent.getAttribute(f'{ns}:priority').isdigit():",
            "                value = intent.getAttribute(f'{ns}:priority')",
            "                if int(value) > 100:",
            "                    ret_list.append(",
            "                        ('high_intent_priority_found', (value,), ()))",
            "        # ACTIONS",
            "        for action in actions:",
            "            if action.getAttribute(f'{ns}:priority').isdigit():",
            "                value = action.getAttribute(f'{ns}:priority')",
            "                if int(value) > 100:",
            "                    ret_list.append(",
            "                        ('high_action_priority_found', (value,), ()))",
            "        for a_key, t_name, t_desc in ret_list:",
            "            a_template = android_manifest_desc.MANIFEST_DESC.get(a_key)",
            "            if a_template:",
            "                ret_value.append({",
            "                    'rule': a_key,",
            "                    'title': a_template['title'] % t_name,",
            "                    'severity': a_template['level'],",
            "                    'description': a_template['description'] % t_desc,",
            "                    'name': a_template['name'] % t_name,",
            "                    'component': t_name,",
            "                })",
            "            else:",
            "                logger.warning(\"No template found for key '%s'\", a_key)",
            "",
            "        for category in man_data_dic['categories']:",
            "            if category == 'android.intent.category.LAUNCHER':",
            "                break",
            "",
            "        permissions = {}",
            "        for k, permission in man_data_dic['perm'].items():",
            "            permissions[k] = (",
            "                {",
            "                    'status': permission[0],",
            "                    'info': permission[1],",
            "                    'description': permission[2],",
            "                })",
            "        # Prepare return dict",
            "        exported_comp = {",
            "            'exported_activities': exp_count['act'],",
            "            'exported_services': exp_count['ser'],",
            "            'exported_receivers': exp_count['bro'],",
            "            'exported_providers': exp_count['cnt'],",
            "        }",
            "        man_an_dic = {",
            "            'manifest_anal': ret_value,",
            "            'exported_act': exported,",
            "            'exported_cnt': exported_comp,",
            "            'browsable_activities': browsable_activities,",
            "            'permissions': permissions,",
            "            'network_security': network_security.analysis(",
            "                app_dir,",
            "                do_netsec,",
            "                debuggable,",
            "                src_type),",
            "        }",
            "        return man_an_dic",
            "    except Exception:",
            "        logger.exception('Performing Manifest Analysis')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf_8 -*-",
            "# flake8: noqa",
            "\"\"\"Module for android manifest analysis.\"\"\"",
            "import logging",
            "",
            "import requests",
            "from concurrent.futures import ThreadPoolExecutor",
            "",
            "from mobsf.MobSF.utils import (",
            "    is_number,",
            "    upstream_proxy,",
            "    valid_host,",
            ")",
            "from mobsf.StaticAnalyzer.views.android import (",
            "    android_manifest_desc,",
            "    network_security,",
            ")",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "ANDROID_4_2_LEVEL = 17",
            "ANDROID_5_0_LEVEL = 21",
            "ANDROID_8_0_LEVEL = 26",
            "ANDROID_9_0_LEVEL = 28",
            "ANDROID_10_0_LEVEL = 29",
            "ANDROID_MANIFEST_FILE = 'AndroidManifest.xml'",
            "ANDROID_API_LEVEL_MAP = {",
            "    '1': '1.0',",
            "    '2': '1.1',",
            "    '3': '1.5',",
            "    '4': '1.6',",
            "    '5': '2.0-2.1',",
            "    '8': '2.2-2.2.3',",
            "    '9': '2.3-2.3.2',",
            "    '10': '2.3.3-2.3.7',",
            "    '11': '3.0',",
            "    '12': '3.1',",
            "    '13': '3.2-3.2.6',",
            "    '14': '4.0-4.0.2',",
            "    '15': '4.0.3-4.0.4',",
            "    '16': '4.1-4.1.2',",
            "    '17': '4.2-4.2.2',",
            "    '18': '4.3-4.3.1',",
            "    '19': '4.4-4.4.4',",
            "    '20': '4.4W-4.4W.2',",
            "    '21': '5.0-5.0.2',",
            "    '22': '5.1-5.1.1',",
            "    '23': '6.0-6.0.1',",
            "    '24': '7.0',",
            "    '25': '7.1-7.1.2',",
            "    '26': '8.0',",
            "    '27': '8.1',",
            "    '28': '9',",
            "    '29': '10',",
            "    '30': '11',",
            "    '31': '12',",
            "    '32': '12L',",
            "    '33': '13',",
            "    '34': '14',",
            "}",
            "",
            "",
            "def assetlinks_check(act_name, well_knowns):",
            "    \"\"\"Well known assetlink check.\"\"\"",
            "    findings = []",
            "",
            "    with ThreadPoolExecutor() as executor:",
            "        futures = []",
            "        for w_url, host in well_knowns.items():",
            "            logger.info(",
            "                'App Link Assetlinks Check - [%s] %s', act_name, host)",
            "            futures.append(",
            "                executor.submit(_check_url, host, w_url))",
            "        for future in futures:",
            "            findings.append(future.result())",
            "",
            "    return findings",
            "",
            "def _check_url(host, w_url):",
            "    try:",
            "        iden = 'sha256_cert_fingerprints'",
            "        proxies, verify = upstream_proxy('https')",
            "        status = False",
            "        status_code = 0",
            "",
            "        r = requests.get(w_url,",
            "            allow_redirects=True,",
            "            proxies=proxies,",
            "            verify=verify,",
            "            timeout=5)",
            "",
            "        status_code = r.status_code",
            "        if (str(status_code).startswith('2') and iden in str(r.json())):",
            "            status = True",
            "",
            "        return {'url': w_url,",
            "                'host': host,",
            "                'status_code': status_code,",
            "                'status': status}",
            "",
            "    except Exception:",
            "        logger.error(f'Well Known Assetlinks Check for URL: {w_url}')",
            "        return {'url': w_url, ",
            "                'host': host,",
            "                'status_code': None,",
            "                'status': False}",
            "",
            "",
            "def get_browsable_activities(node, ns):",
            "    \"\"\"Get Browsable Activities.\"\"\"",
            "    try:",
            "        browse_dic = {}",
            "        schemes = []",
            "        mime_types = []",
            "        hosts = []",
            "        ports = []",
            "        paths = []",
            "        path_prefixs = []",
            "        path_patterns = []",
            "        well_known = {}",
            "        well_known_path = '/.well-known/assetlinks.json'",
            "        catg = node.getElementsByTagName('category')",
            "        for cat in catg:",
            "            if cat.getAttribute(f'{ns}:name') == 'android.intent.category.BROWSABLE':",
            "                data_tag = node.getElementsByTagName('data')",
            "                for data in data_tag:",
            "                    scheme = data.getAttribute(f'{ns}:scheme')",
            "                    if scheme and scheme not in schemes:",
            "                        schemes.append(scheme)",
            "                    mime = data.getAttribute(f'{ns}:mimeType')",
            "                    if mime and mime not in mime_types:",
            "                        mime_types.append(mime)",
            "                    host = data.getAttribute(f'{ns}:host')",
            "                    if host and host not in hosts:",
            "                        hosts.append(host)",
            "                    port = data.getAttribute(f'{ns}:port')",
            "                    if port and port not in ports:",
            "                        ports.append(port)",
            "                    path = data.getAttribute(f'{ns}:path')",
            "                    if path and path not in paths:",
            "                        paths.append(path)",
            "                    path_prefix = data.getAttribute(f'{ns}:pathPrefix')",
            "                    if path_prefix and path_prefix not in path_prefixs:",
            "                        path_prefixs.append(path_prefix)",
            "                    path_pattern = data.getAttribute(f'{ns}:pathPattern')",
            "                    if path_pattern and path_pattern not in path_patterns:",
            "                        path_patterns.append(path_pattern)",
            "                    # Collect possible well-known paths",
            "                    if (scheme",
            "                          and scheme in ('http', 'https')",
            "                          and host",
            "                          and host != '*'):",
            "                        host = host.replace('*.', '').replace('#', '')",
            "                        if not valid_host(host):",
            "                            continue",
            "                        shost = f'{scheme}://{host}'",
            "                        if port and is_number(port):",
            "                            c_url = f'{shost}:{port}{well_known_path}'",
            "                        else:",
            "                            c_url = f'{shost}{well_known_path}'",
            "                        well_known[c_url] = shost",
            "        schemes = [scheme + '://' for scheme in schemes]",
            "        browse_dic['schemes'] = schemes",
            "        browse_dic['mime_types'] = mime_types",
            "        browse_dic['hosts'] = hosts",
            "        browse_dic['ports'] = ports",
            "        browse_dic['paths'] = paths",
            "        browse_dic['path_prefixs'] = path_prefixs",
            "        browse_dic['path_patterns'] = path_patterns",
            "        browse_dic['browsable'] = bool(browse_dic['schemes'])",
            "        browse_dic['well_known'] = well_known",
            "        return browse_dic",
            "    except Exception:",
            "        logger.exception('Getting Browsable Activities')",
            "",
            "",
            "def manifest_analysis(mfxml, ns, man_data_dic, src_type, app_dir):",
            "    \"\"\"Analyse manifest file.\"\"\"",
            "    # pylint: disable=C0301",
            "    try:",
            "        logger.info('Manifest Analysis Started')",
            "        exp_count = dict.fromkeys(['act', 'ser', 'bro', 'cnt'], 0)",
            "        applications = mfxml.getElementsByTagName('application')",
            "        data_tag = mfxml.getElementsByTagName('data')",
            "        intents = mfxml.getElementsByTagName('intent-filter')",
            "        actions = mfxml.getElementsByTagName('action')",
            "        granturipermissions = mfxml.getElementsByTagName(",
            "            'grant-uri-permission')",
            "        permissions = mfxml.getElementsByTagName('permission')",
            "        ret_value = []",
            "        ret_list = []",
            "        exported = []",
            "        browsable_activities = {}",
            "        permission_dict = {}",
            "        do_netsec = False",
            "        debuggable = False",
            "        # PERMISSION",
            "        for permission in permissions:",
            "            if permission.getAttribute(f'{ns}:protectionLevel'):",
            "                protectionlevel = permission.getAttribute(",
            "                    f'{ns}:protectionLevel')",
            "                if protectionlevel == '0x00000000':",
            "                    protectionlevel = 'normal'",
            "                elif protectionlevel == '0x00000001':",
            "                    protectionlevel = 'dangerous'",
            "                elif protectionlevel == '0x00000002':",
            "                    protectionlevel = 'signature'",
            "                elif protectionlevel == '0x00000003':",
            "                    protectionlevel = 'signatureOrSystem'",
            "",
            "                permission_dict[permission.getAttribute(",
            "                    f'{ns}:name')] = protectionlevel",
            "            elif permission.getAttribute(f'{ns}:name'):",
            "                permission_dict[permission.getAttribute(",
            "                    f'{ns}:name')] = 'normal'",
            "        # GENERAL",
            "        if man_data_dic['min_sdk'] and int(man_data_dic['min_sdk']) < ANDROID_8_0_LEVEL:",
            "            minsdk = man_data_dic.get('min_sdk')",
            "            android_version = ANDROID_API_LEVEL_MAP.get(minsdk, 'XX')",
            "            ret_list.append(('vulnerable_os_version', (android_version, minsdk,), ()))",
            "        elif man_data_dic['min_sdk'] and int(man_data_dic['min_sdk']) < ANDROID_10_0_LEVEL:",
            "            minsdk = man_data_dic.get('min_sdk')",
            "            android_version = ANDROID_API_LEVEL_MAP.get(minsdk, 'XX')",
            "            ret_list.append(('vulnerable_os_version2', (android_version, minsdk,), ()))",
            "        # APPLICATIONS",
            "        # Handle multiple application tags in AAR",
            "        backupDisabled = False",
            "        for application in applications:",
            "            # Esteve 23.07.2016 - begin - identify permission at the",
            "            # application level",
            "            if application.getAttribute(f'{ns}:permission'):",
            "                perm_appl_level_exists = True",
            "                perm_appl_level = application.getAttribute(",
            "                    f'{ns}:permission')",
            "            else:",
            "                perm_appl_level_exists = False",
            "            # End",
            "            if application.getAttribute(f'{ns}:usesCleartextTraffic') == 'true':",
            "                ret_list.append(('clear_text_traffic', (), ()))",
            "            if application.getAttribute(f'{ns}:directBootAware') == 'true':",
            "                ret_list.append(('direct_boot_aware', (), ()))",
            "            if application.getAttribute(f'{ns}:networkSecurityConfig'):",
            "                item = application.getAttribute(f'{ns}:networkSecurityConfig')",
            "                ret_list.append(('has_network_security', (item,), ()))",
            "                do_netsec = item",
            "            if application.getAttribute(f'{ns}:debuggable') == 'true':",
            "                ret_list.append(('app_is_debuggable', (), ()))",
            "                debuggable = True",
            "            if application.getAttribute(f'{ns}:allowBackup') == 'true':",
            "                ret_list.append(('app_allowbackup', (), ()))",
            "            elif application.getAttribute(f'{ns}:allowBackup') == 'false':",
            "                backupDisabled = True",
            "            else:",
            "                if not backupDisabled:",
            "                    ret_list.append(('allowbackup_not_set', (), ()))",
            "            if application.getAttribute(f'{ns}:testOnly') == 'true':",
            "                ret_list.append(('app_in_test_mode', (), ()))",
            "            for node in application.childNodes:",
            "                an_or_a = ''",
            "                if node.nodeName == 'activity':",
            "                    itemname = 'Activity'",
            "                    cnt_id = 'act'",
            "                    an_or_a = 'n'",
            "                elif node.nodeName == 'activity-alias':",
            "                    itemname = 'Activity-Alias'",
            "                    cnt_id = 'act'",
            "                    an_or_a = 'n'",
            "                elif node.nodeName == 'provider':",
            "                    itemname = 'Content Provider'",
            "                    cnt_id = 'cnt'",
            "                elif node.nodeName == 'receiver':",
            "                    itemname = 'Broadcast Receiver'",
            "                    cnt_id = 'bro'",
            "                elif node.nodeName == 'service':",
            "                    itemname = 'Service'",
            "                    cnt_id = 'ser'",
            "                else:",
            "                    itemname = 'NIL'",
            "                item = ''",
            "                # Checks for Activities",
            "                if itemname in ['Activity', 'Activity-Alias']:",
            "                    item = node.getAttribute(f'{ns}:name')",
            "                    # Browsable Activities",
            "                    browse_dic = get_browsable_activities(node, ns)",
            "                    if browse_dic['browsable']:",
            "                        browsable_activities[node.getAttribute(",
            "                            f'{ns}:name')] = browse_dic",
            "                    for finding in assetlinks_check(item, browse_dic['well_known']):",
            "                        if not finding['status']:",
            "                            ret_list.append(('well_known_assetlinks',",
            "                                            (item, finding['host']),",
            "                                            (finding['url'],",
            "                                             finding['status_code'])))",
            "",
            "                    # Task Affinity",
            "                    task_affinity = node.getAttribute(f'{ns}:taskAffinity')",
            "                    if (task_affinity):",
            "                        ret_list.append(('task_affinity_set', (item,), ()))",
            "",
            "                    # LaunchMode",
            "                    try:",
            "                        affected_sdk = int(",
            "                            man_data_dic['min_sdk']) < ANDROID_5_0_LEVEL",
            "                    except Exception:",
            "                        # in case min_sdk is not defined we assume vulnerability",
            "                        affected_sdk = True",
            "                    launchmode = node.getAttribute(f'{ns}:launchMode')",
            "                    modes = ('singleTask', 'singleInstance')",
            "                    if (affected_sdk",
            "                            and launchmode in modes):",
            "                        ret_list.append(('non_standard_launchmode', (item,), ()))",
            "",
            "                    # Android Task Hijacking or StrandHogg 1.0",
            "                    try:",
            "                        target_sdk = int(man_data_dic['target_sdk'])",
            "                    except Exception:",
            "                        try:",
            "                            target_sdk = int(man_data_dic['min_sdk'])",
            "                        except Exception:",
            "                            target_sdk = ANDROID_8_0_LEVEL",
            "                    if (target_sdk < ANDROID_9_0_LEVEL",
            "                            and launchmode == 'singleTask'):",
            "                        ret_list.append(('task_hijacking', (item,), (target_sdk,)))",
            "",
            "                    # Android StrandHogg 2.0",
            "                    exported_act = node.getAttribute(f'{ns}:exported')",
            "                    if (target_sdk < ANDROID_10_0_LEVEL",
            "                            and exported_act == 'true'",
            "                            and (launchmode != 'singleInstance' or task_affinity != '')):",
            "                        ret_list.append(('task_hijacking2', (item,), (target_sdk,)))",
            "",
            "                # Exported Check",
            "                item = ''",
            "                is_inf = False",
            "                is_perm_exist = False",
            "                # Esteve 23.07.2016 - begin - initialise variables to identify",
            "                # the existence of a permission at the component level that",
            "                # matches a permission at the manifest level",
            "                prot_level_exist = False",
            "                protlevel = ''",
            "                # End",
            "                if itemname != 'NIL':",
            "                    if node.getAttribute(f'{ns}:exported') == 'true':",
            "                        perm = ''",
            "                        item = node.getAttribute(f'{ns}:name')",
            "                        if node.getAttribute(f'{ns}:permission'):",
            "                            # permission exists",
            "                            perm = ('<strong>Permission: </strong>'",
            "                                    + node.getAttribute(f'{ns}:permission'))",
            "                            is_perm_exist = True",
            "                        if item != man_data_dic['mainactivity']:",
            "                            if is_perm_exist:",
            "                                prot = ''",
            "                                if node.getAttribute(f'{ns}:permission') in permission_dict:",
            "                                    prot = ('</br><strong>protectionLevel: </strong>'",
            "                                            + permission_dict[node.getAttribute(f'{ns}:permission')])",
            "                                    # Esteve 23.07.2016 - begin - take into account protection level of the permission when claiming that a component is protected by it;",
            "                                    # - the permission might not be defined in the application being analysed, if so, the protection level is not known;",
            "                                    # - activities (or activity-alias) that are exported and have an unknown or normal or dangerous protection level are",
            "                                    # included in the EXPORTED data structure for further treatment; components in this situation are also",
            "                                    # counted as exported.",
            "                                    prot_level_exist = True",
            "                                    protlevel = permission_dict[",
            "                                        node.getAttribute(f'{ns}:permission')]",
            "                                if prot_level_exist:",
            "                                    if protlevel == 'normal':",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_normal', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                    elif protlevel == 'dangerous':",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_dangerous', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                    elif protlevel == 'signature':",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_signature', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                    elif protlevel == 'signatureOrSystem':",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_signatureorsystem', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                else:",
            "                                    ret_list.append(",
            "                                        ('exported_protected_permission_not_defined', (itemname, item, perm), (an_or_a, itemname)))",
            "                                    if itemname in ['Activity', 'Activity-Alias']:",
            "                                        exported.append(item)",
            "                                    exp_count[cnt_id] = exp_count[cnt_id] + 1",
            "                                # Esteve 23.07.2016 - end",
            "                            else:",
            "                                # Esteve 24.07.2016 - begin - At this point, we are dealing with components that do not have a permission neither at the component level nor at the",
            "                                # application level. As they are exported, they",
            "                                # are not protected.",
            "                                if perm_appl_level_exists is False:",
            "                                    ret_list.append(",
            "                                        ('explicitly_exported', (itemname, item), (an_or_a, itemname)))",
            "                                    if itemname in ['Activity', 'Activity-Alias']:",
            "                                        exported.append(item)",
            "                                    exp_count[cnt_id] = exp_count[cnt_id] + 1",
            "                                # Esteve 24.07.2016 - end",
            "                                # Esteve 24.07.2016 - begin - At this point, we are dealing with components that have a permission at the application level, but not at the component",
            "                                #  level. Two options are possible:",
            "                                #        1) The permission is defined at the manifest level, which allows us to differentiate the level of protection as",
            "                                #           we did just above for permissions specified at the component level.",
            "                                #        2) The permission is not defined at the manifest level, which means the protection level is unknown, as it is not",
            "                                # defined in the analysed application.",
            "                                else:",
            "                                    perm = '<strong>Permission: </strong>' + perm_appl_level",
            "                                    prot = ''",
            "                                    if perm_appl_level in permission_dict:",
            "                                        prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                + permission_dict[perm_appl_level])",
            "                                        prot_level_exist = True",
            "                                        protlevel = permission_dict[",
            "                                            perm_appl_level]",
            "                                    if prot_level_exist:",
            "                                        if protlevel == 'normal':",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission_normal_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            if itemname in ['Activity', 'Activity-Alias']:",
            "                                                exported.append(item)",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                        elif protlevel == 'dangerous':",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission_dangerous_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            if itemname in ['Activity', 'Activity-Alias']:",
            "                                                exported.append(item)",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                        elif protlevel == 'signature':",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        elif protlevel == 'signatureOrSystem':",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission_signatureorsystem_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                    else:",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_app_level', (itemname, item, perm), (an_or_a, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                # Esteve 24.07.2016 - end",
            "",
            "                    elif node.getAttribute(f'{ns}:exported') != 'false':",
            "                        # Check for Implicitly Exported",
            "                        # Logic to support intent-filter",
            "                        intentfilters = node.childNodes",
            "                        for i in intentfilters:",
            "                            inf = i.nodeName",
            "                            if inf == 'intent-filter':",
            "                                is_inf = True",
            "                        if is_inf:",
            "                            item = node.getAttribute(f'{ns}:name')",
            "                            if node.getAttribute(f'{ns}:permission'):",
            "                                # permission exists",
            "                                perm = ('<strong>Permission: </strong>'",
            "                                        + node.getAttribute(f'{ns}:permission'))",
            "                                is_perm_exist = True",
            "                            if item != man_data_dic['mainactivity']:",
            "                                if is_perm_exist:",
            "                                    prot = ''",
            "                                    if node.getAttribute(f'{ns}:permission') in permission_dict:",
            "                                        prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                + permission_dict[node.getAttribute(f'{ns}:permission')])",
            "                                        # Esteve 24.07.2016 - begin - take into account protection level of the permission when claiming that a component is protected by it;",
            "                                        # - the permission might not be defined in the application being analysed, if so, the protection level is not known;",
            "                                        # - activities (or activity-alias) that are exported and have an unknown or normal or dangerous protection level are",
            "                                        #  included in the EXPORTED data structure for further treatment; components in this situation are also",
            "                                        #  counted as exported.",
            "                                        prot_level_exist = True",
            "                                        protlevel = permission_dict[",
            "                                            node.getAttribute(f'{ns}:permission')]",
            "                                        if prot_level_exist:",
            "                                            if protlevel == 'normal':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_normal', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                if itemname in ['Activity', 'Activity-Alias']:",
            "                                                    exported.append(item)",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'dangerous':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_dangerous', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                if itemname in ['Activity', 'Activity-Alias']:",
            "                                                    exported.append(item)",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'signature':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_signature', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            elif protlevel == 'signatureOrSystem':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_signatureorsystem', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                    else:",
            "                                        ret_list.append(",
            "                                            ('exported_protected_permission_not_defined', (itemname, item, perm), (an_or_a, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                    # Esteve 24.07.2016 - end",
            "                                else:",
            "                                    # Esteve 24.07.2016 - begin - At this point, we are dealing with components that do not have a permission neither at the component level nor at the",
            "                                    # application level. As they are exported,",
            "                                    # they are not protected.",
            "                                    if perm_appl_level_exists is False:",
            "                                        ret_list.append(",
            "                                            ('exported_intent_filter_exists', (itemname, item), (an_or_a, itemname, itemname)))",
            "                                        if itemname in ['Activity', 'Activity-Alias']:",
            "                                            exported.append(item)",
            "                                        exp_count[cnt_id] = exp_count[",
            "                                            cnt_id] + 1",
            "                                    # Esteve 24.07.2016 - end",
            "                                    # Esteve 24.07.2016 - begin - At this point, we are dealing with components that have a permission at the application level, but not at the component",
            "                                    # level. Two options are possible:",
            "                                    # 1) The permission is defined at the manifest level, which allows us to differentiate the level of protection as",
            "                                    #  we did just above for permissions specified at the component level.",
            "                                    # 2) The permission is not defined at the manifest level, which means the protection level is unknown, as it is not",
            "                                    #  defined in the analysed application.",
            "                                    else:",
            "                                        perm = '<strong>Permission: </strong>' + perm_appl_level",
            "                                        prot = ''",
            "                                        if perm_appl_level in permission_dict:",
            "                                            prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                    + permission_dict[perm_appl_level])",
            "                                            prot_level_exist = True",
            "                                            protlevel = permission_dict[",
            "                                                perm_appl_level]",
            "                                        if prot_level_exist:",
            "                                            if protlevel == 'normal':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_normal_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                if itemname in ['Activity', 'Activity-Alias']:",
            "                                                    exported.append(item)",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'dangerous':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_dangerous_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                if itemname in ['Activity', 'Activity-Alias']:",
            "                                                    exported.append(item)",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'signature':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            elif protlevel == 'signatureOrSystem':",
            "                                                ret_list.append(",
            "                                                    ('exported_protected_permission_signatureorsystem_app_level', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        else:",
            "                                            ret_list.append(",
            "                                                ('exported_protected_permission_app_level', (itemname, item, perm), (an_or_a, itemname)))",
            "                                            if itemname in ['Activity', 'Activity-Alias']:",
            "                                                exported.append(item)",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                    # Esteve 24.07.2016 - end",
            "                                    # Esteve 29.07.2016 - begin The component is not explicitly exported (android:exported is not 'true'). It is not implicitly exported either (it does not",
            "                                    # make use of an intent filter). Despite that, it could still be exported by default, if it is a content provider and the android:targetSdkVersion",
            "                                    # is older than 17 (Jelly Bean, Android version 4.2). This is true regardless of the system's API level.",
            "                                    # Finally, it must also be taken into account that, if the minSdkVersion is greater or equal than 17, this check is unnecessary, because the",
            "                                    # app will not be run on a system where the",
            "                                    # system's API level is below 17.",
            "                        else:",
            "                            if man_data_dic['min_sdk'] and man_data_dic['target_sdk'] and int(man_data_dic['min_sdk']) < ANDROID_4_2_LEVEL:",
            "                                if itemname == 'Content Provider' and int(man_data_dic['target_sdk']) < ANDROID_4_2_LEVEL:",
            "                                    perm = ''",
            "                                    item = node.getAttribute(f'{ns}:name')",
            "                                    if node.getAttribute(f'{ns}:permission'):",
            "                                        # permission exists",
            "                                        perm = ('<strong>Permission: </strong>'",
            "                                                + node.getAttribute(f'{ns}:permission'))",
            "                                        is_perm_exist = True",
            "                                    if is_perm_exist:",
            "                                        prot = ''",
            "                                        if node.getAttribute(f'{ns}:permission') in permission_dict:",
            "                                            prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                    + permission_dict[node.getAttribute(f'{ns}:permission')])",
            "                                            prot_level_exist = True",
            "                                            protlevel = permission_dict[",
            "                                                node.getAttribute(f'{ns}:permission')]",
            "                                        if prot_level_exist:",
            "                                            if protlevel == 'normal':",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_normal', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'dangerous':",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_danger', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            elif protlevel == 'signature':",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_signature', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            elif protlevel == 'signatureOrSystem':",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_signatureorsystem', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                        else:",
            "                                            ret_list.append(",
            "                                                ('exported_provider_unknown', (itemname, item, perm), (an_or_a, itemname)))",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                    else:",
            "                                        if perm_appl_level_exists is False:",
            "                                            ret_list.append(",
            "                                                ('exported_provider', (itemname, item), (an_or_a, itemname)))",
            "                                            exp_count[cnt_id] = exp_count[",
            "                                                cnt_id] + 1",
            "                                        else:",
            "                                            perm = '<strong>Permission: </strong>' + perm_appl_level",
            "                                            prot = ''",
            "                                            if perm_appl_level in permission_dict:",
            "                                                prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                        + permission_dict[perm_appl_level])",
            "                                                prot_level_exist = True",
            "                                                protlevel = permission_dict[",
            "                                                    perm_appl_level]",
            "                                            if prot_level_exist:",
            "                                                if protlevel == 'normal':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_normal_app', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                                elif protlevel == 'dangerous':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_danger_appl', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                                elif protlevel == 'signature':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_signature_appl', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                elif protlevel == 'signatureOrSystem':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_signatureorsystem_app', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            else:",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_unknown_app', (itemname, item, perm), (an_or_a, itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                    # Esteve 29.07.2016 - end",
            "                                    # Esteve 08.08.2016 - begin - If the content provider does not target an API version lower than 17, it could still be exported by default, depending",
            "                                    # on the API version of the platform. If it was below 17, the content",
            "                                    # provider would be exported by default.",
            "                                else:",
            "                                    if itemname == 'Content Provider' and int(man_data_dic['target_sdk']) >= 17:",
            "                                        perm = ''",
            "                                        item = node.getAttribute(",
            "                                            f'{ns}:name')",
            "                                        if node.getAttribute(f'{ns}:permission'):",
            "                                            # permission exists",
            "                                            perm = ('<strong>Permission: </strong>'",
            "                                                    + node.getAttribute(f'{ns}:permission'))",
            "                                            is_perm_exist = True",
            "                                        if is_perm_exist:",
            "                                            prot = ''",
            "                                            if node.getAttribute(f'{ns}:permission') in permission_dict:",
            "                                                prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                        + permission_dict[node.getAttribute(f'{ns}:permission')])",
            "                                                prot_level_exist = True",
            "                                                protlevel = permission_dict[",
            "                                                    node.getAttribute(f'{ns}:permission')]",
            "                                            if prot_level_exist:",
            "                                                if protlevel == 'normal':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_normal_new', (itemname, item, perm + prot), (itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                                if protlevel == 'dangerous':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_danger_new', (itemname, item, perm + prot), (itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                                if protlevel == 'signature':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_signature_new', (itemname, item, perm + prot), (itemname)))",
            "                                                if protlevel == 'signatureOrSystem':",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_signatureorsystem_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                            else:",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_unknown_new', (itemname, item, perm), (itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                        else:",
            "                                            if perm_appl_level_exists is False:",
            "                                                ret_list.append(",
            "                                                    ('exported_provider_2', (itemname, item), (an_or_a, itemname)))",
            "                                                exp_count[cnt_id] = exp_count[",
            "                                                    cnt_id] + 1",
            "                                            else:",
            "                                                perm = '<strong>Permission: </strong>' + perm_appl_level",
            "                                                prot = ''",
            "                                                if perm_appl_level in permission_dict:",
            "                                                    prot = ('</br><strong>protectionLevel: </strong>'",
            "                                                            + permission_dict[perm_appl_level])",
            "                                                    prot_level_exist = True",
            "                                                    protlevel = permission_dict[",
            "                                                        perm_appl_level]",
            "                                                if prot_level_exist:",
            "                                                    if protlevel == 'normal':",
            "                                                        ret_list.append(",
            "                                                            ('exported_provider_normal_app_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                        exp_count[cnt_id] = exp_count[",
            "                                                            cnt_id] + 1",
            "                                                    elif protlevel == 'dangerous':",
            "                                                        ret_list.append(",
            "                                                            ('exported_provider_danger_app_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                        exp_count[cnt_id] = exp_count[",
            "                                                            cnt_id] + 1",
            "                                                    elif protlevel == 'signature':",
            "                                                        ret_list.append(",
            "                                                            ('exported_provider_signature_app_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                    elif protlevel == 'signatureOrSystem':",
            "                                                        ret_list.append(",
            "                                                            ('exported_provider_signatureorsystem_app_new', (itemname, item, perm + prot), (an_or_a, itemname)))",
            "                                                else:",
            "                                                    ret_list.append(",
            "                                                        ('exported_provider_unknown_app_new', (itemname, item, perm), (an_or_a, itemname)))",
            "                                                    exp_count[cnt_id] = exp_count[",
            "                                                        cnt_id] + 1",
            "                                    # Esteve 08.08.2016 - end",
            "",
            "        # GRANT-URI-PERMISSIONS",
            "        for granturi in granturipermissions:",
            "            if granturi.getAttribute(f'{ns}:pathPrefix') == '/':",
            "                ret_list.append(",
            "                    ('improper_provider_permission', ('pathPrefix=/',), ()))",
            "            elif granturi.getAttribute(f'{ns}:path') == '/':",
            "                ret_list.append(('improper_provider_permission', ('path=/',), ()))",
            "            elif granturi.getAttribute(f'{ns}:pathPattern') == '*':",
            "                ret_list.append(('improper_provider_permission', ('path=*',), ()))",
            "        # DATA",
            "        for data in data_tag:",
            "            if data.getAttribute(f'{ns}:scheme') == 'android_secret_code':",
            "                xmlhost = data.getAttribute(f'{ns}:host')",
            "                ret_list.append(('dialer_code_found', (xmlhost,), ()))",
            "",
            "            elif data.getAttribute(f'{ns}:port'):",
            "                dataport = data.getAttribute(f'{ns}:port')",
            "                ret_list.append(('sms_receiver_port_found', (dataport,), ()))",
            "        # INTENTS",
            "        for intent in intents:",
            "            if intent.getAttribute(f'{ns}:priority').isdigit():",
            "                value = intent.getAttribute(f'{ns}:priority')",
            "                if int(value) > 100:",
            "                    ret_list.append(",
            "                        ('high_intent_priority_found', (value,), ()))",
            "        # ACTIONS",
            "        for action in actions:",
            "            if action.getAttribute(f'{ns}:priority').isdigit():",
            "                value = action.getAttribute(f'{ns}:priority')",
            "                if int(value) > 100:",
            "                    ret_list.append(",
            "                        ('high_action_priority_found', (value,), ()))",
            "        for a_key, t_name, t_desc in ret_list:",
            "            a_template = android_manifest_desc.MANIFEST_DESC.get(a_key)",
            "            if a_template:",
            "                ret_value.append({",
            "                    'rule': a_key,",
            "                    'title': a_template['title'] % t_name,",
            "                    'severity': a_template['level'],",
            "                    'description': a_template['description'] % t_desc,",
            "                    'name': a_template['name'] % t_name,",
            "                    'component': t_name,",
            "                })",
            "            else:",
            "                logger.warning(\"No template found for key '%s'\", a_key)",
            "",
            "        for category in man_data_dic['categories']:",
            "            if category == 'android.intent.category.LAUNCHER':",
            "                break",
            "",
            "        permissions = {}",
            "        for k, permission in man_data_dic['perm'].items():",
            "            permissions[k] = (",
            "                {",
            "                    'status': permission[0],",
            "                    'info': permission[1],",
            "                    'description': permission[2],",
            "                })",
            "        # Prepare return dict",
            "        exported_comp = {",
            "            'exported_activities': exp_count['act'],",
            "            'exported_services': exp_count['ser'],",
            "            'exported_receivers': exp_count['bro'],",
            "            'exported_providers': exp_count['cnt'],",
            "        }",
            "        man_an_dic = {",
            "            'manifest_anal': ret_value,",
            "            'exported_act': exported,",
            "            'exported_cnt': exported_comp,",
            "            'browsable_activities': browsable_activities,",
            "            'permissions': permissions,",
            "            'network_security': network_security.analysis(",
            "                app_dir,",
            "                do_netsec,",
            "                debuggable,",
            "                src_type),",
            "        }",
            "        return man_an_dic",
            "    except Exception:",
            "        logger.exception('Performing Manifest Analysis')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "151": [
                "get_browsable_activities"
            ],
            "153": [
                "get_browsable_activities"
            ]
        },
        "addLocation": []
    }
}