{
    "nvflare/lighter/impl/cert.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " # limitations under the License."
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import datetime"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import json"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import os"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import pickle"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from cryptography import x509"
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from cryptography.hazmat.backends import default_backend"
            },
            "9": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     def initialize(self, ctx):"
            },
            "11": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         state_dir = self.get_state_dir(ctx)"
            },
            "12": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cert_file = os.path.join(state_dir, \"cert.pkl\")"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        cert_file = os.path.join(state_dir, \"cert.json\")"
            },
            "14": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         if os.path.exists(cert_file):"
            },
            "15": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.persistent_state = pickle.load(open(cert_file, \"rb\"))"
            },
            "16": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.serialized_cert = self.persistent_state[\"root_cert\"]"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            self.persistent_state = json.load(open(cert_file, \"rt\"))"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            self.serialized_cert = self.persistent_state[\"root_cert\"].encode(\"ascii\")"
            },
            "19": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             self.root_cert = x509.load_pem_x509_certificate(self.serialized_cert, default_backend())"
            },
            "20": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             self.pri_key = serialization.load_pem_private_key("
            },
            "21": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.persistent_state[\"root_pri_key\"], password=None, backend=default_backend()"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+                self.persistent_state[\"root_pri_key\"].encode(\"ascii\"), password=None, backend=default_backend()"
            },
            "23": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "             )"
            },
            "24": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "             self.pub_key = self.pri_key.public_key()"
            },
            "25": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             self.subject = self.root_cert.subject"
            },
            "26": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "             self.pri_key = pri_key"
            },
            "27": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "             self.pub_key = pub_key"
            },
            "28": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             self.serialized_cert = serialize_cert(self.root_cert)"
            },
            "29": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.persistent_state[\"root_cert\"] = self.serialized_cert"
            },
            "30": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.persistent_state[\"root_pri_key\"] = serialize_pri_key(self.pri_key)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+            self.persistent_state[\"root_cert\"] = self.serialized_cert.decode(\"ascii\")"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            self.persistent_state[\"root_pri_key\"] = serialize_pri_key(self.pri_key).decode(\"ascii\")"
            },
            "33": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     def _build_write_cert_pair(self, participant, base_name, ctx):"
            },
            "35": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         subject = participant.subject"
            },
            "36": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         if self.persistent_state and subject in self.persistent_state:"
            },
            "37": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cert = x509.load_pem_x509_certificate(self.persistent_state[subject][\"cert\"], default_backend())"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+            cert = x509.load_pem_x509_certificate("
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                self.persistent_state[subject][\"cert\"].encode(\"ascii\"), default_backend()"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+            )"
            },
            "41": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "             pri_key = serialization.load_pem_private_key("
            },
            "42": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.persistent_state[subject][\"pri_key\"], password=None, backend=default_backend()"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+                self.persistent_state[subject][\"pri_key\"].encode(\"ascii\"), password=None, backend=default_backend()"
            },
            "44": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "             )"
            },
            "45": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         else:"
            },
            "46": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             pri_key, cert = self.get_pri_key_cert(participant)"
            },
            "47": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.persistent_state[subject] = dict(cert=serialize_cert(cert), pri_key=serialize_pri_key(pri_key))"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            self.persistent_state[subject] = dict("
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                cert=serialize_cert(cert).decode(\"ascii\"), pri_key=serialize_pri_key(pri_key).decode(\"ascii\")"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            )"
            },
            "51": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         dest_dir = self.get_kit_dir(participant, ctx)"
            },
            "52": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         with open(os.path.join(dest_dir, f\"{base_name}.crt\"), \"wb\") as f:"
            },
            "53": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "             f.write(serialize_cert(cert))"
            },
            "54": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         with open(os.path.join(dest_dir, f\"{base_name}.key\"), \"wb\") as f:"
            },
            "55": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             f.write(serialize_pri_key(pri_key))"
            },
            "56": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         pkcs12 = serialization.pkcs12.serialize_key_and_certificates("
            },
            "57": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            subject.encode(\"utf-8\"), pri_key, cert, None, serialization.BestAvailableEncryption(subject.encode(\"utf-8\"))"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+            subject.encode(\"ascii\"), pri_key, cert, None, serialization.BestAvailableEncryption(subject.encode(\"ascii\"))"
            },
            "59": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         )"
            },
            "60": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         with open(os.path.join(dest_dir, f\"{base_name}.pfx\"), \"wb\") as f:"
            },
            "61": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "             f.write(pkcs12)"
            },
            "62": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     def finalize(self, ctx):"
            },
            "64": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         state_dir = self.get_state_dir(ctx)"
            },
            "65": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cert_file = os.path.join(state_dir, \"cert.pkl\")"
            },
            "66": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pickle.dump(self.persistent_state, open(cert_file, \"wb\"))"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        cert_file = os.path.join(state_dir, \"cert.json\")"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        json.dump(self.persistent_state, open(cert_file, \"wt\"))"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2021-2022, NVIDIA CORPORATION.  All rights reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import datetime",
            "import os",
            "import pickle",
            "",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives import hashes, serialization",
            "from cryptography.hazmat.primitives.asymmetric import rsa",
            "from cryptography.x509.oid import NameOID",
            "",
            "from nvflare.lighter.spec import Builder",
            "",
            "",
            "def serialize_pri_key(pri_key):",
            "    return pri_key.private_bytes(",
            "        encoding=serialization.Encoding.PEM,",
            "        format=serialization.PrivateFormat.TraditionalOpenSSL,",
            "        encryption_algorithm=serialization.NoEncryption(),",
            "    )",
            "",
            "",
            "def serialize_cert(cert):",
            "    return cert.public_bytes(serialization.Encoding.PEM)",
            "",
            "",
            "class CertBuilder(Builder):",
            "    def __init__(self):",
            "        \"\"\"Build certificate chain for every participant.",
            "",
            "        Handles building (creating and self-signing) the root CA certificates, creating server, client and",
            "        admin certificates, and having them signed by the root CA for secure communication. If the state folder has",
            "        information about previously generated certs, it loads them back and reuses them.",
            "        \"\"\"",
            "        self.root_cert = None",
            "        self.persistent_state = dict()",
            "",
            "    def initialize(self, ctx):",
            "        state_dir = self.get_state_dir(ctx)",
            "        cert_file = os.path.join(state_dir, \"cert.pkl\")",
            "        if os.path.exists(cert_file):",
            "            self.persistent_state = pickle.load(open(cert_file, \"rb\"))",
            "            self.serialized_cert = self.persistent_state[\"root_cert\"]",
            "            self.root_cert = x509.load_pem_x509_certificate(self.serialized_cert, default_backend())",
            "            self.pri_key = serialization.load_pem_private_key(",
            "                self.persistent_state[\"root_pri_key\"], password=None, backend=default_backend()",
            "            )",
            "            self.pub_key = self.pri_key.public_key()",
            "            self.subject = self.root_cert.subject",
            "",
            "    def _build_root(self, subject):",
            "        if not self.persistent_state:",
            "            pri_key, pub_key = self._generate_keys()",
            "            self.issuer = subject",
            "            self.root_cert = self._generate_cert(subject, self.issuer, pri_key, pub_key, ca=True)",
            "            self.pri_key = pri_key",
            "            self.pub_key = pub_key",
            "            self.serialized_cert = serialize_cert(self.root_cert)",
            "            self.persistent_state[\"root_cert\"] = self.serialized_cert",
            "            self.persistent_state[\"root_pri_key\"] = serialize_pri_key(self.pri_key)",
            "",
            "    def _build_write_cert_pair(self, participant, base_name, ctx):",
            "        subject = participant.subject",
            "        if self.persistent_state and subject in self.persistent_state:",
            "            cert = x509.load_pem_x509_certificate(self.persistent_state[subject][\"cert\"], default_backend())",
            "            pri_key = serialization.load_pem_private_key(",
            "                self.persistent_state[subject][\"pri_key\"], password=None, backend=default_backend()",
            "            )",
            "        else:",
            "            pri_key, cert = self.get_pri_key_cert(participant)",
            "            self.persistent_state[subject] = dict(cert=serialize_cert(cert), pri_key=serialize_pri_key(pri_key))",
            "        dest_dir = self.get_kit_dir(participant, ctx)",
            "        with open(os.path.join(dest_dir, f\"{base_name}.crt\"), \"wb\") as f:",
            "            f.write(serialize_cert(cert))",
            "        with open(os.path.join(dest_dir, f\"{base_name}.key\"), \"wb\") as f:",
            "            f.write(serialize_pri_key(pri_key))",
            "        pkcs12 = serialization.pkcs12.serialize_key_and_certificates(",
            "            subject.encode(\"utf-8\"), pri_key, cert, None, serialization.BestAvailableEncryption(subject.encode(\"utf-8\"))",
            "        )",
            "        with open(os.path.join(dest_dir, f\"{base_name}.pfx\"), \"wb\") as f:",
            "            f.write(pkcs12)",
            "        with open(os.path.join(dest_dir, \"rootCA.pem\"), \"wb\") as f:",
            "            f.write(self.serialized_cert)",
            "",
            "    def build(self, project, ctx):",
            "        self._build_root(project.name)",
            "        ctx[\"root_cert\"] = self.root_cert",
            "        ctx[\"root_pri_key\"] = self.pri_key",
            "        overseer = project.get_participants_by_type(\"overseer\")",
            "        self._build_write_cert_pair(overseer, \"overseer\", ctx)",
            "",
            "        servers = project.get_participants_by_type(\"server\", first_only=False)",
            "        for server in servers:",
            "            self._build_write_cert_pair(server, \"server\", ctx)",
            "",
            "        for client in project.get_participants_by_type(\"client\", first_only=False):",
            "            self._build_write_cert_pair(client, \"client\", ctx)",
            "",
            "        for admin in project.get_participants_by_type(\"admin\", first_only=False):",
            "            self._build_write_cert_pair(admin, \"client\", ctx)",
            "",
            "    def get_pri_key_cert(self, participant):",
            "        pri_key, pub_key = self._generate_keys()",
            "        subject = participant.subject",
            "        cert = self._generate_cert(subject, self.issuer, self.pri_key, pub_key)",
            "        return pri_key, cert",
            "",
            "    def _generate_keys(self):",
            "        pri_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())",
            "        pub_key = pri_key.public_key()",
            "        return pri_key, pub_key",
            "",
            "    def _generate_cert(self, subject, issuer, signing_pri_key, subject_pub_key, valid_days=360, ca=False):",
            "        x509_subject = self._x509_name(subject)",
            "        x509_issuer = self._x509_name(issuer)",
            "        builder = (",
            "            x509.CertificateBuilder()",
            "            .subject_name(x509_subject)",
            "            .issuer_name(x509_issuer)",
            "            .public_key(subject_pub_key)",
            "            .serial_number(x509.random_serial_number())",
            "            .not_valid_before(datetime.datetime.utcnow())",
            "            .not_valid_after(",
            "                # Our certificate will be valid for 360 days",
            "                datetime.datetime.utcnow()",
            "                + datetime.timedelta(days=valid_days)",
            "                # Sign our certificate with our private key",
            "            )",
            "            .add_extension(x509.SubjectAlternativeName([x509.DNSName(subject)]), critical=False)",
            "        )",
            "        if ca:",
            "            builder = (",
            "                builder.add_extension(",
            "                    x509.SubjectKeyIdentifier.from_public_key(subject_pub_key),",
            "                    critical=False,",
            "                )",
            "                .add_extension(",
            "                    x509.AuthorityKeyIdentifier.from_issuer_public_key(subject_pub_key),",
            "                    critical=False,",
            "                )",
            "                .add_extension(x509.BasicConstraints(ca=True, path_length=None), critical=False)",
            "            )",
            "        return builder.sign(signing_pri_key, hashes.SHA256(), default_backend())",
            "",
            "    def _x509_name(self, cn_name, org_name=None):",
            "        name = [x509.NameAttribute(NameOID.COMMON_NAME, cn_name)]",
            "        if org_name is not None:",
            "            name.append(x509.NameAttribute(NameOID.ORGANIZATION_NAME, org_name))",
            "        return x509.Name(name)",
            "",
            "    def finalize(self, ctx):",
            "        state_dir = self.get_state_dir(ctx)",
            "        cert_file = os.path.join(state_dir, \"cert.pkl\")",
            "        pickle.dump(self.persistent_state, open(cert_file, \"wb\"))"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2021-2022, NVIDIA CORPORATION.  All rights reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import datetime",
            "import json",
            "import os",
            "",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives import hashes, serialization",
            "from cryptography.hazmat.primitives.asymmetric import rsa",
            "from cryptography.x509.oid import NameOID",
            "",
            "from nvflare.lighter.spec import Builder",
            "",
            "",
            "def serialize_pri_key(pri_key):",
            "    return pri_key.private_bytes(",
            "        encoding=serialization.Encoding.PEM,",
            "        format=serialization.PrivateFormat.TraditionalOpenSSL,",
            "        encryption_algorithm=serialization.NoEncryption(),",
            "    )",
            "",
            "",
            "def serialize_cert(cert):",
            "    return cert.public_bytes(serialization.Encoding.PEM)",
            "",
            "",
            "class CertBuilder(Builder):",
            "    def __init__(self):",
            "        \"\"\"Build certificate chain for every participant.",
            "",
            "        Handles building (creating and self-signing) the root CA certificates, creating server, client and",
            "        admin certificates, and having them signed by the root CA for secure communication. If the state folder has",
            "        information about previously generated certs, it loads them back and reuses them.",
            "        \"\"\"",
            "        self.root_cert = None",
            "        self.persistent_state = dict()",
            "",
            "    def initialize(self, ctx):",
            "        state_dir = self.get_state_dir(ctx)",
            "        cert_file = os.path.join(state_dir, \"cert.json\")",
            "        if os.path.exists(cert_file):",
            "            self.persistent_state = json.load(open(cert_file, \"rt\"))",
            "            self.serialized_cert = self.persistent_state[\"root_cert\"].encode(\"ascii\")",
            "            self.root_cert = x509.load_pem_x509_certificate(self.serialized_cert, default_backend())",
            "            self.pri_key = serialization.load_pem_private_key(",
            "                self.persistent_state[\"root_pri_key\"].encode(\"ascii\"), password=None, backend=default_backend()",
            "            )",
            "            self.pub_key = self.pri_key.public_key()",
            "            self.subject = self.root_cert.subject",
            "",
            "    def _build_root(self, subject):",
            "        if not self.persistent_state:",
            "            pri_key, pub_key = self._generate_keys()",
            "            self.issuer = subject",
            "            self.root_cert = self._generate_cert(subject, self.issuer, pri_key, pub_key, ca=True)",
            "            self.pri_key = pri_key",
            "            self.pub_key = pub_key",
            "            self.serialized_cert = serialize_cert(self.root_cert)",
            "            self.persistent_state[\"root_cert\"] = self.serialized_cert.decode(\"ascii\")",
            "            self.persistent_state[\"root_pri_key\"] = serialize_pri_key(self.pri_key).decode(\"ascii\")",
            "",
            "    def _build_write_cert_pair(self, participant, base_name, ctx):",
            "        subject = participant.subject",
            "        if self.persistent_state and subject in self.persistent_state:",
            "            cert = x509.load_pem_x509_certificate(",
            "                self.persistent_state[subject][\"cert\"].encode(\"ascii\"), default_backend()",
            "            )",
            "            pri_key = serialization.load_pem_private_key(",
            "                self.persistent_state[subject][\"pri_key\"].encode(\"ascii\"), password=None, backend=default_backend()",
            "            )",
            "        else:",
            "            pri_key, cert = self.get_pri_key_cert(participant)",
            "            self.persistent_state[subject] = dict(",
            "                cert=serialize_cert(cert).decode(\"ascii\"), pri_key=serialize_pri_key(pri_key).decode(\"ascii\")",
            "            )",
            "        dest_dir = self.get_kit_dir(participant, ctx)",
            "        with open(os.path.join(dest_dir, f\"{base_name}.crt\"), \"wb\") as f:",
            "            f.write(serialize_cert(cert))",
            "        with open(os.path.join(dest_dir, f\"{base_name}.key\"), \"wb\") as f:",
            "            f.write(serialize_pri_key(pri_key))",
            "        pkcs12 = serialization.pkcs12.serialize_key_and_certificates(",
            "            subject.encode(\"ascii\"), pri_key, cert, None, serialization.BestAvailableEncryption(subject.encode(\"ascii\"))",
            "        )",
            "        with open(os.path.join(dest_dir, f\"{base_name}.pfx\"), \"wb\") as f:",
            "            f.write(pkcs12)",
            "        with open(os.path.join(dest_dir, \"rootCA.pem\"), \"wb\") as f:",
            "            f.write(self.serialized_cert)",
            "",
            "    def build(self, project, ctx):",
            "        self._build_root(project.name)",
            "        ctx[\"root_cert\"] = self.root_cert",
            "        ctx[\"root_pri_key\"] = self.pri_key",
            "        overseer = project.get_participants_by_type(\"overseer\")",
            "        self._build_write_cert_pair(overseer, \"overseer\", ctx)",
            "",
            "        servers = project.get_participants_by_type(\"server\", first_only=False)",
            "        for server in servers:",
            "            self._build_write_cert_pair(server, \"server\", ctx)",
            "",
            "        for client in project.get_participants_by_type(\"client\", first_only=False):",
            "            self._build_write_cert_pair(client, \"client\", ctx)",
            "",
            "        for admin in project.get_participants_by_type(\"admin\", first_only=False):",
            "            self._build_write_cert_pair(admin, \"client\", ctx)",
            "",
            "    def get_pri_key_cert(self, participant):",
            "        pri_key, pub_key = self._generate_keys()",
            "        subject = participant.subject",
            "        cert = self._generate_cert(subject, self.issuer, self.pri_key, pub_key)",
            "        return pri_key, cert",
            "",
            "    def _generate_keys(self):",
            "        pri_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())",
            "        pub_key = pri_key.public_key()",
            "        return pri_key, pub_key",
            "",
            "    def _generate_cert(self, subject, issuer, signing_pri_key, subject_pub_key, valid_days=360, ca=False):",
            "        x509_subject = self._x509_name(subject)",
            "        x509_issuer = self._x509_name(issuer)",
            "        builder = (",
            "            x509.CertificateBuilder()",
            "            .subject_name(x509_subject)",
            "            .issuer_name(x509_issuer)",
            "            .public_key(subject_pub_key)",
            "            .serial_number(x509.random_serial_number())",
            "            .not_valid_before(datetime.datetime.utcnow())",
            "            .not_valid_after(",
            "                # Our certificate will be valid for 360 days",
            "                datetime.datetime.utcnow()",
            "                + datetime.timedelta(days=valid_days)",
            "                # Sign our certificate with our private key",
            "            )",
            "            .add_extension(x509.SubjectAlternativeName([x509.DNSName(subject)]), critical=False)",
            "        )",
            "        if ca:",
            "            builder = (",
            "                builder.add_extension(",
            "                    x509.SubjectKeyIdentifier.from_public_key(subject_pub_key),",
            "                    critical=False,",
            "                )",
            "                .add_extension(",
            "                    x509.AuthorityKeyIdentifier.from_issuer_public_key(subject_pub_key),",
            "                    critical=False,",
            "                )",
            "                .add_extension(x509.BasicConstraints(ca=True, path_length=None), critical=False)",
            "            )",
            "        return builder.sign(signing_pri_key, hashes.SHA256(), default_backend())",
            "",
            "    def _x509_name(self, cn_name, org_name=None):",
            "        name = [x509.NameAttribute(NameOID.COMMON_NAME, cn_name)]",
            "        if org_name is not None:",
            "            name.append(x509.NameAttribute(NameOID.ORGANIZATION_NAME, org_name))",
            "        return x509.Name(name)",
            "",
            "    def finalize(self, ctx):",
            "        state_dir = self.get_state_dir(ctx)",
            "        cert_file = os.path.join(state_dir, \"cert.json\")",
            "        json.dump(self.persistent_state, open(cert_file, \"wt\"))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "17": [],
            "53": [
                "CertBuilder",
                "initialize"
            ],
            "55": [
                "CertBuilder",
                "initialize"
            ],
            "56": [
                "CertBuilder",
                "initialize"
            ],
            "59": [
                "CertBuilder",
                "initialize"
            ],
            "72": [
                "CertBuilder",
                "_build_root"
            ],
            "73": [
                "CertBuilder",
                "_build_root"
            ],
            "78": [
                "CertBuilder",
                "_build_write_cert_pair"
            ],
            "80": [
                "CertBuilder",
                "_build_write_cert_pair"
            ],
            "84": [
                "CertBuilder",
                "_build_write_cert_pair"
            ],
            "91": [
                "CertBuilder",
                "_build_write_cert_pair"
            ],
            "166": [
                "CertBuilder",
                "finalize"
            ],
            "167": [
                "CertBuilder",
                "finalize"
            ]
        },
        "addLocation": []
    }
}