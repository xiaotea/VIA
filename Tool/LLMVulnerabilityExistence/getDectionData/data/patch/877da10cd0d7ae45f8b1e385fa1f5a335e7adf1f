{
    "jupyter_server/services/contents/filemanager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         os_path = self._get_os_path(path)"
            },
            "1": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         info = os.lstat(os_path)"
            },
            "2": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 190,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        four_o_four = \"file or directory does not exist: %r\" % path"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+            self.log.info(\"Refusing to serve hidden file or directory %r, via 404 Error\", os_path)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            raise web.HTTPError(404, four_o_four)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "         try:"
            },
            "10": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "             # size of file"
            },
            "11": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "             size = info.st_size"
            },
            "12": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "             of the file or directory as well."
            },
            "13": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "         \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "         path = path.strip(\"/\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+        os_path = self._get_os_path(path)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+        four_o_four = \"file or directory does not exist: %r\" % path"
            },
            "17": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 376,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "         if not self.exists(path):"
            },
            "19": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise web.HTTPError(404, \"No such file or directory: %s\" % path)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+            raise web.HTTPError(404, four_o_four)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+            self.log.info(\"Refusing to serve hidden file or directory %r, via 404 Error\", os_path)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+            raise web.HTTPError(404, four_o_four)"
            },
            "25": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 383,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os_path = self._get_os_path(path)"
            },
            "27": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "         if os.path.isdir(os_path):"
            },
            "28": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "             if type not in (None, \"directory\"):"
            },
            "29": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "                 raise web.HTTPError("
            },
            "30": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "     def _save_directory(self, os_path, model, path=\"\"):"
            },
            "31": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         \"\"\"create a directory\"\"\""
            },
            "32": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "         if is_hidden(os_path, self.root_dir) and not self.allow_hidden:"
            },
            "33": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise web.HTTPError(400, \"Cannot create hidden directory %r\" % os_path)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+            raise web.HTTPError(400, \"Cannot create directory %r\" % os_path)"
            },
            "35": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "         if not os.path.exists(os_path):"
            },
            "36": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "             with self.perm_to_403():"
            },
            "37": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "                 os.mkdir(os_path)"
            },
            "38": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 421,
                "PatchRowcode": "             raise web.HTTPError(400, \"No file content provided\")"
            },
            "39": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 422,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 423,
                "PatchRowcode": "         os_path = self._get_os_path(path)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+            raise web.HTTPError(400, f\"Cannot create file or directory {os_path!r}\")"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 428,
                "PatchRowcode": "         self.log.debug(\"Saving %s\", os_path)"
            },
            "46": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": 429,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 430,
                "PatchRowcode": "         validation_error: dict = {}"
            },
            "48": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "         path = path.strip(\"/\")"
            },
            "49": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "         os_path = self._get_os_path(path)"
            },
            "50": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "         rm = os.unlink"
            },
            "51": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not os.path.exists(os_path):"
            },
            "52": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise web.HTTPError(404, \"File or directory does not exist: %s\" % os_path)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+        four_o_four = \"file or directory does not exist: %r\" % path"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+        if not self.exists(path):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+            raise web.HTTPError(404, four_o_four)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+            raise web.HTTPError(400, f\"Cannot delete file or directory {os_path!r}\")"
            },
            "60": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 477,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 478,
                "PatchRowcode": "         def _check_trash(os_path):"
            },
            "62": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 479,
                "PatchRowcode": "             if sys.platform in {\"win32\", \"darwin\"}:"
            },
            "63": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 538,
                "PatchRowcode": "         new_os_path = self._get_os_path(new_path)"
            },
            "64": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": 539,
                "PatchRowcode": "         old_os_path = self._get_os_path(old_path)"
            },
            "65": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": 540,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 541,
                "PatchRowcode": "+        if ("
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 542,
                "PatchRowcode": "+            is_hidden(old_os_path, self.root_dir) or is_hidden(new_os_path, self.root_dir)"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 543,
                "PatchRowcode": "+        ) and not self.allow_hidden:"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 544,
                "PatchRowcode": "+            raise web.HTTPError(400, f\"Cannot rename file or directory {old_os_path!r}\")"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 545,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "         # Should we proceed with the move?"
            },
            "72": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": 547,
                "PatchRowcode": "         if os.path.exists(new_os_path) and not samefile(old_os_path, new_os_path):"
            },
            "73": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "             raise web.HTTPError(409, \"File already exists: %s\" % new_path)"
            }
        },
        "frontPatchFile": [
            "\"\"\"A contents manager that uses the local file system for storage.\"\"\"",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import errno",
            "import mimetypes",
            "import os",
            "import shutil",
            "import stat",
            "import sys",
            "from datetime import datetime",
            "",
            "import nbformat",
            "from anyio.to_thread import run_sync",
            "from jupyter_core.paths import exists, is_file_hidden, is_hidden",
            "from send2trash import send2trash",
            "from tornado import web",
            "from traitlets import Bool, TraitError, Unicode, default, validate",
            "",
            "from jupyter_server import _tz as tz",
            "from jupyter_server.base.handlers import AuthenticatedFileHandler",
            "from jupyter_server.transutils import _i18n",
            "",
            "from .filecheckpoints import AsyncFileCheckpoints, FileCheckpoints",
            "from .fileio import AsyncFileManagerMixin, FileManagerMixin",
            "from .manager import AsyncContentsManager, ContentsManager",
            "",
            "try:",
            "    from os.path import samefile",
            "except ImportError:",
            "    # windows + py2",
            "    from jupyter_server.utils import samefile_simple as samefile",
            "",
            "_script_exporter = None",
            "",
            "",
            "class FileContentsManager(FileManagerMixin, ContentsManager):",
            "",
            "    root_dir = Unicode(config=True)",
            "",
            "    @default(\"root_dir\")",
            "    def _default_root_dir(self):",
            "        try:",
            "            return self.parent.root_dir",
            "        except AttributeError:",
            "            return os.getcwd()",
            "",
            "    @validate(\"root_dir\")",
            "    def _validate_root_dir(self, proposal):",
            "        \"\"\"Do a bit of validation of the root_dir.\"\"\"",
            "        value = proposal[\"value\"]",
            "        if not os.path.isabs(value):",
            "            # If we receive a non-absolute path, make it absolute.",
            "            value = os.path.abspath(value)",
            "        if not os.path.isdir(value):",
            "            raise TraitError(\"%r is not a directory\" % value)",
            "        return value",
            "",
            "    @default(\"checkpoints_class\")",
            "    def _checkpoints_class_default(self):",
            "        return FileCheckpoints",
            "",
            "    delete_to_trash = Bool(",
            "        True,",
            "        config=True,",
            "        help=\"\"\"If True (default), deleting files will send them to the",
            "        platform's trash/recycle bin, where they can be recovered. If False,",
            "        deleting files really deletes them.\"\"\",",
            "    )",
            "",
            "    always_delete_dir = Bool(",
            "        False,",
            "        config=True,",
            "        help=\"\"\"If True, deleting a non-empty directory will always be allowed.",
            "        WARNING this may result in files being permanently removed; e.g. on Windows,",
            "        if the data size is too big for the trash/recycle bin the directory will be permanently",
            "        deleted. If False (default), the non-empty directory will be sent to the trash only",
            "        if safe. And if ``delete_to_trash`` is True, the directory won't be deleted.\"\"\",",
            "    )",
            "",
            "    @default(\"files_handler_class\")",
            "    def _files_handler_class_default(self):",
            "        return AuthenticatedFileHandler",
            "",
            "    @default(\"files_handler_params\")",
            "    def _files_handler_params_default(self):",
            "        return {\"path\": self.root_dir}",
            "",
            "    def is_hidden(self, path):",
            "        \"\"\"Does the API style path correspond to a hidden directory or file?",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        hidden : bool",
            "            Whether the path exists and is hidden.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return is_hidden(os_path, self.root_dir)",
            "",
            "    def is_writable(self, path):",
            "        \"\"\"Does the API style path correspond to a writable directory or file?",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        hidden : bool",
            "            Whether the path exists and is writable.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        try:",
            "            return os.access(os_path, os.W_OK)",
            "        except OSError:",
            "            self.log.error(\"Failed to check write permissions on %s\", os_path)",
            "            return False",
            "",
            "    def file_exists(self, path):",
            "        \"\"\"Returns True if the file exists, else returns False.",
            "",
            "        API-style wrapper for os.path.isfile",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The relative path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the file exists.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        return os.path.isfile(os_path)",
            "",
            "    def dir_exists(self, path):",
            "        \"\"\"Does the API-style path refer to an extant directory?",
            "",
            "        API-style wrapper for os.path.isdir",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the path is indeed a directory.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.isdir(os_path)",
            "",
            "    def exists(self, path):",
            "        \"\"\"Returns True if the path exists, else returns False.",
            "",
            "        API-style wrapper for os.path.exists",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The API path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the target exists.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return exists(os_path)",
            "",
            "    def _base_model(self, path):",
            "        \"\"\"Build the common base of a contents model\"\"\"",
            "        os_path = self._get_os_path(path)",
            "        info = os.lstat(os_path)",
            "",
            "        try:",
            "            # size of file",
            "            size = info.st_size",
            "        except (ValueError, OSError):",
            "            self.log.warning(\"Unable to get size.\")",
            "            size = None",
            "",
            "        try:",
            "            last_modified = tz.utcfromtimestamp(info.st_mtime)",
            "        except (ValueError, OSError):",
            "            # Files can rarely have an invalid timestamp",
            "            # https://github.com/jupyter/notebook/issues/2539",
            "            # https://github.com/jupyter/notebook/issues/2757",
            "            # Use the Unix epoch as a fallback so we don't crash.",
            "            self.log.warning(\"Invalid mtime %s for %s\", info.st_mtime, os_path)",
            "            last_modified = datetime(1970, 1, 1, 0, 0, tzinfo=tz.UTC)",
            "",
            "        try:",
            "            created = tz.utcfromtimestamp(info.st_ctime)",
            "        except (ValueError, OSError):  # See above",
            "            self.log.warning(\"Invalid ctime %s for %s\", info.st_ctime, os_path)",
            "            created = datetime(1970, 1, 1, 0, 0, tzinfo=tz.UTC)",
            "",
            "        # Create the base model.",
            "        model = {}",
            "        model[\"name\"] = path.rsplit(\"/\", 1)[-1]",
            "        model[\"path\"] = path",
            "        model[\"last_modified\"] = last_modified",
            "        model[\"created\"] = created",
            "        model[\"content\"] = None",
            "        model[\"format\"] = None",
            "        model[\"mimetype\"] = None",
            "        model[\"size\"] = size",
            "        model[\"writable\"] = self.is_writable(path)",
            "",
            "        return model",
            "",
            "    def _dir_model(self, path, content=True):",
            "        \"\"\"Build a model for a directory",
            "",
            "        if content is requested, will include a listing of the directory",
            "        \"\"\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = \"directory does not exist: %r\" % path",
            "",
            "        if not os.path.isdir(os_path):",
            "            raise web.HTTPError(404, four_o_four)",
            "        elif is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden directory %r, via 404 Error\", os_path)",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"directory\"",
            "        model[\"size\"] = None",
            "        if content:",
            "            model[\"content\"] = contents = []",
            "            os_dir = self._get_os_path(path)",
            "            for name in os.listdir(os_dir):",
            "                try:",
            "                    os_path = os.path.join(os_dir, name)",
            "                except UnicodeDecodeError as e:",
            "                    self.log.warning(\"failed to decode filename '%s': %s\", name, e)",
            "                    continue",
            "",
            "                try:",
            "                    st = os.lstat(os_path)",
            "                except OSError as e:",
            "                    # skip over broken symlinks in listing",
            "                    if e.errno == errno.ENOENT:",
            "                        self.log.warning(\"%s doesn't exist\", os_path)",
            "                    elif e.errno != errno.EACCES:  # Don't provide clues about protected files",
            "                        self.log.warning(\"Error stat-ing %s: %s\", os_path, e)",
            "                    continue",
            "",
            "                if (",
            "                    not stat.S_ISLNK(st.st_mode)",
            "                    and not stat.S_ISREG(st.st_mode)",
            "                    and not stat.S_ISDIR(st.st_mode)",
            "                ):",
            "                    self.log.debug(\"%s not a regular file\", os_path)",
            "                    continue",
            "",
            "                try:",
            "                    if self.should_list(name):",
            "                        if self.allow_hidden or not is_file_hidden(os_path, stat_res=st):",
            "                            contents.append(self.get(path=f\"{path}/{name}\", content=False))",
            "                except OSError as e:",
            "                    # ELOOP: recursive symlink, also don't show failure due to permissions",
            "                    if e.errno not in [errno.ELOOP, errno.EACCES]:",
            "                        self.log.warning(",
            "                            \"Unknown error checking if file %r is hidden\",",
            "                            os_path,",
            "                            exc_info=True,",
            "                        )",
            "",
            "            model[\"format\"] = \"json\"",
            "",
            "        return model",
            "",
            "    def _file_model(self, path, content=True, format=None):",
            "        \"\"\"Build a model for a file",
            "",
            "        if content is requested, include the file contents.",
            "",
            "        format:",
            "          If 'text', the contents will be decoded as UTF-8.",
            "          If 'base64', the raw bytes contents will be encoded as base64.",
            "          If not specified, try to decode as UTF-8, and fall back to base64",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"file\"",
            "",
            "        os_path = self._get_os_path(path)",
            "        model[\"mimetype\"] = mimetypes.guess_type(os_path)[0]",
            "",
            "        if content:",
            "            content, format = self._read_file(os_path, format)",
            "            if model[\"mimetype\"] is None:",
            "                default_mime = {",
            "                    \"text\": \"text/plain\",",
            "                    \"base64\": \"application/octet-stream\",",
            "                }[format]",
            "                model[\"mimetype\"] = default_mime",
            "",
            "            model.update(",
            "                content=content,",
            "                format=format,",
            "            )",
            "",
            "        return model",
            "",
            "    def _notebook_model(self, path, content=True):",
            "        \"\"\"Build a notebook model",
            "",
            "        if content is requested, the notebook content will be populated",
            "        as a JSON structure (not double-serialized)",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"notebook\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        if content:",
            "            validation_error: dict = {}",
            "            nb = self._read_notebook(",
            "                os_path, as_version=4, capture_validation_error=validation_error",
            "            )",
            "            self.mark_trusted_cells(nb, path)",
            "            model[\"content\"] = nb",
            "            model[\"format\"] = \"json\"",
            "            self.validate_notebook_model(model, validation_error)",
            "",
            "        return model",
            "",
            "    def get(self, path, content=True, type=None, format=None):",
            "        \"\"\"Takes a path for an entity and returns its model",
            "",
            "        Parameters",
            "        ----------",
            "        path : str",
            "            the API path that describes the relative path for the target",
            "        content : bool",
            "            Whether to include the contents in the reply",
            "        type : str, optional",
            "            The requested type - 'file', 'notebook', or 'directory'.",
            "            Will raise HTTPError 400 if the content doesn't match.",
            "        format : str, optional",
            "            The requested format for file contents. 'text' or 'base64'.",
            "            Ignored if this returns a notebook or directory model.",
            "",
            "        Returns",
            "        -------",
            "        model : dict",
            "            the contents model. If content=True, returns the contents",
            "            of the file or directory as well.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, \"No such file or directory: %s\" % path)",
            "",
            "        os_path = self._get_os_path(path)",
            "        if os.path.isdir(os_path):",
            "            if type not in (None, \"directory\"):",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"{path} is a directory, not a {type}\",",
            "                    reason=\"bad type\",",
            "                )",
            "            model = self._dir_model(path, content=content)",
            "        elif type == \"notebook\" or (type is None and path.endswith(\".ipynb\")):",
            "            model = self._notebook_model(path, content=content)",
            "        else:",
            "            if type == \"directory\":",
            "                raise web.HTTPError(400, \"%s is not a directory\" % path, reason=\"bad type\")",
            "            model = self._file_model(path, content=content, format=format)",
            "        return model",
            "",
            "    def _save_directory(self, os_path, model, path=\"\"):",
            "        \"\"\"create a directory\"\"\"",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            raise web.HTTPError(400, \"Cannot create hidden directory %r\" % os_path)",
            "        if not os.path.exists(os_path):",
            "            with self.perm_to_403():",
            "                os.mkdir(os_path)",
            "        elif not os.path.isdir(os_path):",
            "            raise web.HTTPError(400, \"Not a directory: %s\" % (os_path))",
            "        else:",
            "            self.log.debug(\"Directory %r already exists\", os_path)",
            "",
            "    def save(self, model, path=\"\"):",
            "        \"\"\"Save the file model and return the model with no content.\"\"\"",
            "        path = path.strip(\"/\")",
            "",
            "        self.run_pre_save_hooks(model=model, path=path)",
            "",
            "        if \"type\" not in model:",
            "            raise web.HTTPError(400, \"No file type provided\")",
            "        if \"content\" not in model and model[\"type\"] != \"directory\":",
            "            raise web.HTTPError(400, \"No file content provided\")",
            "",
            "        os_path = self._get_os_path(path)",
            "        self.log.debug(\"Saving %s\", os_path)",
            "",
            "        validation_error: dict = {}",
            "        try:",
            "            if model[\"type\"] == \"notebook\":",
            "                nb = nbformat.from_dict(model[\"content\"])",
            "                self.check_and_sign(nb, path)",
            "                self._save_notebook(os_path, nb, capture_validation_error=validation_error)",
            "                # One checkpoint should always exist for notebooks.",
            "                if not self.checkpoints.list_checkpoints(path):",
            "                    self.create_checkpoint(path)",
            "            elif model[\"type\"] == \"file\":",
            "                # Missing format will be handled internally by _save_file.",
            "                self._save_file(os_path, model[\"content\"], model.get(\"format\"))",
            "            elif model[\"type\"] == \"directory\":",
            "                self._save_directory(os_path, model, path)",
            "            else:",
            "                raise web.HTTPError(400, \"Unhandled contents type: %s\" % model[\"type\"])",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            self.log.error(\"Error while saving file: %s %s\", path, e, exc_info=True)",
            "            raise web.HTTPError(500, f\"Unexpected error while saving file: {path} {e}\") from e",
            "",
            "        validation_message = None",
            "        if model[\"type\"] == \"notebook\":",
            "            self.validate_notebook_model(model, validation_error=validation_error)",
            "            validation_message = model.get(\"message\", None)",
            "",
            "        model = self.get(path, content=False)",
            "        if validation_message:",
            "            model[\"message\"] = validation_message",
            "",
            "        self.run_post_save_hooks(model=model, os_path=os_path)",
            "",
            "        return model",
            "",
            "    def delete_file(self, path):",
            "        \"\"\"Delete file at path.\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        rm = os.unlink",
            "        if not os.path.exists(os_path):",
            "            raise web.HTTPError(404, \"File or directory does not exist: %s\" % os_path)",
            "",
            "        def _check_trash(os_path):",
            "            if sys.platform in {\"win32\", \"darwin\"}:",
            "                return True",
            "",
            "            # It's a bit more nuanced than this, but until we can better",
            "            # distinguish errors from send2trash, assume that we can only trash",
            "            # files on the same partition as the home directory.",
            "            file_dev = os.stat(os_path).st_dev",
            "            home_dev = os.stat(os.path.expanduser(\"~\")).st_dev",
            "            return file_dev == home_dev",
            "",
            "        def is_non_empty_dir(os_path):",
            "            if os.path.isdir(os_path):",
            "                # A directory containing only leftover checkpoints is",
            "                # considered empty.",
            "                cp_dir = getattr(self.checkpoints, \"checkpoint_dir\", None)",
            "                if set(os.listdir(os_path)) - {cp_dir}:",
            "                    return True",
            "",
            "            return False",
            "",
            "        if self.delete_to_trash:",
            "            if not self.always_delete_dir and sys.platform == \"win32\" and is_non_empty_dir(os_path):",
            "                # send2trash can really delete files on Windows, so disallow",
            "                # deleting non-empty files. See Github issue 3631.",
            "                raise web.HTTPError(400, \"Directory %s not empty\" % os_path)",
            "            if _check_trash(os_path):",
            "                # Looking at the code in send2trash, I don't think the errors it",
            "                # raises let us distinguish permission errors from other errors in",
            "                # code. So for now, the \"look before you leap\" approach is used.",
            "                if not self.is_writable(path):",
            "                    raise web.HTTPError(403, \"Permission denied: %s\" % path)",
            "                self.log.debug(\"Sending %s to trash\", os_path)",
            "                send2trash(os_path)",
            "                return",
            "            else:",
            "                self.log.warning(",
            "                    \"Skipping trash for %s, on different device to home directory\",",
            "                    os_path,",
            "                )",
            "",
            "        if os.path.isdir(os_path):",
            "            # Don't permanently delete non-empty directories.",
            "            if not self.always_delete_dir and is_non_empty_dir(os_path):",
            "                raise web.HTTPError(400, \"Directory %s not empty\" % os_path)",
            "            self.log.debug(\"Removing directory %s\", os_path)",
            "            with self.perm_to_403():",
            "                shutil.rmtree(os_path)",
            "        else:",
            "            self.log.debug(\"Unlinking file %s\", os_path)",
            "            with self.perm_to_403():",
            "                rm(os_path)",
            "",
            "    def rename_file(self, old_path, new_path):",
            "        \"\"\"Rename a file.\"\"\"",
            "        old_path = old_path.strip(\"/\")",
            "        new_path = new_path.strip(\"/\")",
            "        if new_path == old_path:",
            "            return",
            "",
            "        new_os_path = self._get_os_path(new_path)",
            "        old_os_path = self._get_os_path(old_path)",
            "",
            "        # Should we proceed with the move?",
            "        if os.path.exists(new_os_path) and not samefile(old_os_path, new_os_path):",
            "            raise web.HTTPError(409, \"File already exists: %s\" % new_path)",
            "",
            "        # Move the file",
            "        try:",
            "            with self.perm_to_403():",
            "                shutil.move(old_os_path, new_os_path)",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            raise web.HTTPError(500, f\"Unknown error renaming file: {old_path} {e}\") from e",
            "",
            "    def info_string(self):",
            "        return _i18n(\"Serving notebooks from local directory: %s\") % self.root_dir",
            "",
            "    def get_kernel_path(self, path, model=None):",
            "        \"\"\"Return the initial API path of  a kernel associated with a given notebook\"\"\"",
            "        if self.dir_exists(path):",
            "            return path",
            "        if \"/\" in path:",
            "            parent_dir = path.rsplit(\"/\", 1)[0]",
            "        else:",
            "            parent_dir = \"\"",
            "        return parent_dir",
            "",
            "",
            "class AsyncFileContentsManager(FileContentsManager, AsyncFileManagerMixin, AsyncContentsManager):",
            "    @default(\"checkpoints_class\")",
            "    def _checkpoints_class_default(self):",
            "        return AsyncFileCheckpoints",
            "",
            "    async def _dir_model(self, path, content=True):",
            "        \"\"\"Build a model for a directory",
            "",
            "        if content is requested, will include a listing of the directory",
            "        \"\"\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = \"directory does not exist: %r\" % path",
            "",
            "        if not os.path.isdir(os_path):",
            "            raise web.HTTPError(404, four_o_four)",
            "        elif is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden directory %r, via 404 Error\", os_path)",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"directory\"",
            "        model[\"size\"] = None",
            "        if content:",
            "            model[\"content\"] = contents = []",
            "            os_dir = self._get_os_path(path)",
            "            dir_contents = await run_sync(os.listdir, os_dir)",
            "            for name in dir_contents:",
            "                try:",
            "                    os_path = os.path.join(os_dir, name)",
            "                except UnicodeDecodeError as e:",
            "                    self.log.warning(\"failed to decode filename '%s': %s\", name, e)",
            "                    continue",
            "",
            "                try:",
            "                    st = await run_sync(os.lstat, os_path)",
            "                except OSError as e:",
            "                    # skip over broken symlinks in listing",
            "                    if e.errno == errno.ENOENT:",
            "                        self.log.warning(\"%s doesn't exist\", os_path)",
            "                    elif e.errno != errno.EACCES:  # Don't provide clues about protected files",
            "                        self.log.warning(\"Error stat-ing %s: %s\", os_path, e)",
            "                    continue",
            "",
            "                if (",
            "                    not stat.S_ISLNK(st.st_mode)",
            "                    and not stat.S_ISREG(st.st_mode)",
            "                    and not stat.S_ISDIR(st.st_mode)",
            "                ):",
            "                    self.log.debug(\"%s not a regular file\", os_path)",
            "                    continue",
            "",
            "                try:",
            "                    if self.should_list(name):",
            "                        if self.allow_hidden or not is_file_hidden(os_path, stat_res=st):",
            "                            contents.append(await self.get(path=f\"{path}/{name}\", content=False))",
            "                except OSError as e:",
            "                    # ELOOP: recursive symlink, also don't show failure due to permissions",
            "                    if e.errno not in [errno.ELOOP, errno.EACCES]:",
            "                        self.log.warning(",
            "                            \"Unknown error checking if file %r is hidden\",",
            "                            os_path,",
            "                            exc_info=True,",
            "                        )",
            "",
            "            model[\"format\"] = \"json\"",
            "",
            "        return model",
            "",
            "    async def _file_model(self, path, content=True, format=None):",
            "        \"\"\"Build a model for a file",
            "",
            "        if content is requested, include the file contents.",
            "",
            "        format:",
            "          If 'text', the contents will be decoded as UTF-8.",
            "          If 'base64', the raw bytes contents will be encoded as base64.",
            "          If not specified, try to decode as UTF-8, and fall back to base64",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"file\"",
            "",
            "        os_path = self._get_os_path(path)",
            "        model[\"mimetype\"] = mimetypes.guess_type(os_path)[0]",
            "",
            "        if content:",
            "            content, format = await self._read_file(os_path, format)",
            "            if model[\"mimetype\"] is None:",
            "                default_mime = {",
            "                    \"text\": \"text/plain\",",
            "                    \"base64\": \"application/octet-stream\",",
            "                }[format]",
            "                model[\"mimetype\"] = default_mime",
            "",
            "            model.update(",
            "                content=content,",
            "                format=format,",
            "            )",
            "",
            "        return model",
            "",
            "    async def _notebook_model(self, path, content=True):",
            "        \"\"\"Build a notebook model",
            "",
            "        if content is requested, the notebook content will be populated",
            "        as a JSON structure (not double-serialized)",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"notebook\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        if content:",
            "            validation_error: dict = {}",
            "            nb = await self._read_notebook(",
            "                os_path, as_version=4, capture_validation_error=validation_error",
            "            )",
            "            self.mark_trusted_cells(nb, path)",
            "            model[\"content\"] = nb",
            "            model[\"format\"] = \"json\"",
            "            self.validate_notebook_model(model, validation_error)",
            "",
            "        return model",
            "",
            "    async def get(self, path, content=True, type=None, format=None):",
            "        \"\"\"Takes a path for an entity and returns its model",
            "",
            "        Parameters",
            "        ----------",
            "        path : str",
            "            the API path that describes the relative path for the target",
            "        content : bool",
            "            Whether to include the contents in the reply",
            "        type : str, optional",
            "            The requested type - 'file', 'notebook', or 'directory'.",
            "            Will raise HTTPError 400 if the content doesn't match.",
            "        format : str, optional",
            "            The requested format for file contents. 'text' or 'base64'.",
            "            Ignored if this returns a notebook or directory model.",
            "",
            "        Returns",
            "        -------",
            "        model : dict",
            "            the contents model. If content=True, returns the contents",
            "            of the file or directory as well.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, \"No such file or directory: %s\" % path)",
            "",
            "        os_path = self._get_os_path(path)",
            "        if os.path.isdir(os_path):",
            "            if type not in (None, \"directory\"):",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"{path} is a directory, not a {type}\",",
            "                    reason=\"bad type\",",
            "                )",
            "            model = await self._dir_model(path, content=content)",
            "        elif type == \"notebook\" or (type is None and path.endswith(\".ipynb\")):",
            "            model = await self._notebook_model(path, content=content)",
            "        else:",
            "            if type == \"directory\":",
            "                raise web.HTTPError(400, \"%s is not a directory\" % path, reason=\"bad type\")",
            "            model = await self._file_model(path, content=content, format=format)",
            "        return model",
            "",
            "    async def _save_directory(self, os_path, model, path=\"\"):",
            "        \"\"\"create a directory\"\"\"",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            raise web.HTTPError(400, \"Cannot create hidden directory %r\" % os_path)",
            "        if not os.path.exists(os_path):",
            "            with self.perm_to_403():",
            "                await run_sync(os.mkdir, os_path)",
            "        elif not os.path.isdir(os_path):",
            "            raise web.HTTPError(400, \"Not a directory: %s\" % (os_path))",
            "        else:",
            "            self.log.debug(\"Directory %r already exists\", os_path)",
            "",
            "    async def save(self, model, path=\"\"):",
            "        \"\"\"Save the file model and return the model with no content.\"\"\"",
            "        path = path.strip(\"/\")",
            "",
            "        self.run_pre_save_hook(model=model, path=path)",
            "",
            "        if \"type\" not in model:",
            "            raise web.HTTPError(400, \"No file type provided\")",
            "        if \"content\" not in model and model[\"type\"] != \"directory\":",
            "            raise web.HTTPError(400, \"No file content provided\")",
            "",
            "        os_path = self._get_os_path(path)",
            "        self.log.debug(\"Saving %s\", os_path)",
            "",
            "        validation_error: dict = {}",
            "        try:",
            "            if model[\"type\"] == \"notebook\":",
            "                nb = nbformat.from_dict(model[\"content\"])",
            "                self.check_and_sign(nb, path)",
            "                await self._save_notebook(os_path, nb, capture_validation_error=validation_error)",
            "                # One checkpoint should always exist for notebooks.",
            "                if not (await self.checkpoints.list_checkpoints(path)):",
            "                    await self.create_checkpoint(path)",
            "            elif model[\"type\"] == \"file\":",
            "                # Missing format will be handled internally by _save_file.",
            "                await self._save_file(os_path, model[\"content\"], model.get(\"format\"))",
            "            elif model[\"type\"] == \"directory\":",
            "                await self._save_directory(os_path, model, path)",
            "            else:",
            "                raise web.HTTPError(400, \"Unhandled contents type: %s\" % model[\"type\"])",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            self.log.error(\"Error while saving file: %s %s\", path, e, exc_info=True)",
            "            raise web.HTTPError(500, f\"Unexpected error while saving file: {path} {e}\") from e",
            "",
            "        validation_message = None",
            "        if model[\"type\"] == \"notebook\":",
            "            self.validate_notebook_model(model, validation_error=validation_error)",
            "            validation_message = model.get(\"message\", None)",
            "",
            "        model = await self.get(path, content=False)",
            "        if validation_message:",
            "            model[\"message\"] = validation_message",
            "",
            "        self.run_post_save_hooks(model=model, os_path=os_path)",
            "",
            "        return model",
            "",
            "    async def delete_file(self, path):",
            "        \"\"\"Delete file at path.\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        rm = os.unlink",
            "        if not os.path.exists(os_path):",
            "            raise web.HTTPError(404, \"File or directory does not exist: %s\" % os_path)",
            "",
            "        async def _check_trash(os_path):",
            "            if sys.platform in {\"win32\", \"darwin\"}:",
            "                return True",
            "",
            "            # It's a bit more nuanced than this, but until we can better",
            "            # distinguish errors from send2trash, assume that we can only trash",
            "            # files on the same partition as the home directory.",
            "            file_dev = (await run_sync(os.stat, os_path)).st_dev",
            "            home_dev = (await run_sync(os.stat, os.path.expanduser(\"~\"))).st_dev",
            "            return file_dev == home_dev",
            "",
            "        async def is_non_empty_dir(os_path):",
            "            if os.path.isdir(os_path):",
            "                # A directory containing only leftover checkpoints is",
            "                # considered empty.",
            "                cp_dir = getattr(self.checkpoints, \"checkpoint_dir\", None)",
            "                dir_contents = set(await run_sync(os.listdir, os_path))",
            "                if dir_contents - {cp_dir}:",
            "                    return True",
            "",
            "            return False",
            "",
            "        if self.delete_to_trash:",
            "            if (",
            "                not self.always_delete_dir",
            "                and sys.platform == \"win32\"",
            "                and await is_non_empty_dir(os_path)",
            "            ):",
            "                # send2trash can really delete files on Windows, so disallow",
            "                # deleting non-empty files. See Github issue 3631.",
            "                raise web.HTTPError(400, \"Directory %s not empty\" % os_path)",
            "            if await _check_trash(os_path):",
            "                # Looking at the code in send2trash, I don't think the errors it",
            "                # raises let us distinguish permission errors from other errors in",
            "                # code. So for now, the \"look before you leap\" approach is used.",
            "                if not self.is_writable(path):",
            "                    raise web.HTTPError(403, \"Permission denied: %s\" % path)",
            "                self.log.debug(\"Sending %s to trash\", os_path)",
            "                send2trash(os_path)",
            "                return",
            "            else:",
            "                self.log.warning(",
            "                    \"Skipping trash for %s, on different device to home directory\",",
            "                    os_path,",
            "                )",
            "",
            "        if os.path.isdir(os_path):",
            "            # Don't permanently delete non-empty directories.",
            "            if not self.always_delete_dir and await is_non_empty_dir(os_path):",
            "                raise web.HTTPError(400, \"Directory %s not empty\" % os_path)",
            "            self.log.debug(\"Removing directory %s\", os_path)",
            "            with self.perm_to_403():",
            "                await run_sync(shutil.rmtree, os_path)",
            "        else:",
            "            self.log.debug(\"Unlinking file %s\", os_path)",
            "            with self.perm_to_403():",
            "                await run_sync(rm, os_path)",
            "",
            "    async def rename_file(self, old_path, new_path):",
            "        \"\"\"Rename a file.\"\"\"",
            "        old_path = old_path.strip(\"/\")",
            "        new_path = new_path.strip(\"/\")",
            "        if new_path == old_path:",
            "            return",
            "",
            "        new_os_path = self._get_os_path(new_path)",
            "        old_os_path = self._get_os_path(old_path)",
            "",
            "        # Should we proceed with the move?",
            "        if os.path.exists(new_os_path) and not samefile(old_os_path, new_os_path):",
            "            raise web.HTTPError(409, \"File already exists: %s\" % new_path)",
            "",
            "        # Move the file",
            "        try:",
            "            with self.perm_to_403():",
            "                await run_sync(shutil.move, old_os_path, new_os_path)",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            raise web.HTTPError(500, f\"Unknown error renaming file: {old_path} {e}\") from e",
            "",
            "    async def dir_exists(self, path):",
            "        \"\"\"Does a directory exist at the given path\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.isdir(os_path)",
            "",
            "    async def file_exists(self, path):",
            "        \"\"\"Does a file exist at the given path\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        return os.path.isfile(os_path)",
            "",
            "    async def is_hidden(self, path):",
            "        \"\"\"Is path a hidden directory or file\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return is_hidden(os_path, self.root_dir)"
        ],
        "afterPatchFile": [
            "\"\"\"A contents manager that uses the local file system for storage.\"\"\"",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import errno",
            "import mimetypes",
            "import os",
            "import shutil",
            "import stat",
            "import sys",
            "from datetime import datetime",
            "",
            "import nbformat",
            "from anyio.to_thread import run_sync",
            "from jupyter_core.paths import exists, is_file_hidden, is_hidden",
            "from send2trash import send2trash",
            "from tornado import web",
            "from traitlets import Bool, TraitError, Unicode, default, validate",
            "",
            "from jupyter_server import _tz as tz",
            "from jupyter_server.base.handlers import AuthenticatedFileHandler",
            "from jupyter_server.transutils import _i18n",
            "",
            "from .filecheckpoints import AsyncFileCheckpoints, FileCheckpoints",
            "from .fileio import AsyncFileManagerMixin, FileManagerMixin",
            "from .manager import AsyncContentsManager, ContentsManager",
            "",
            "try:",
            "    from os.path import samefile",
            "except ImportError:",
            "    # windows + py2",
            "    from jupyter_server.utils import samefile_simple as samefile",
            "",
            "_script_exporter = None",
            "",
            "",
            "class FileContentsManager(FileManagerMixin, ContentsManager):",
            "",
            "    root_dir = Unicode(config=True)",
            "",
            "    @default(\"root_dir\")",
            "    def _default_root_dir(self):",
            "        try:",
            "            return self.parent.root_dir",
            "        except AttributeError:",
            "            return os.getcwd()",
            "",
            "    @validate(\"root_dir\")",
            "    def _validate_root_dir(self, proposal):",
            "        \"\"\"Do a bit of validation of the root_dir.\"\"\"",
            "        value = proposal[\"value\"]",
            "        if not os.path.isabs(value):",
            "            # If we receive a non-absolute path, make it absolute.",
            "            value = os.path.abspath(value)",
            "        if not os.path.isdir(value):",
            "            raise TraitError(\"%r is not a directory\" % value)",
            "        return value",
            "",
            "    @default(\"checkpoints_class\")",
            "    def _checkpoints_class_default(self):",
            "        return FileCheckpoints",
            "",
            "    delete_to_trash = Bool(",
            "        True,",
            "        config=True,",
            "        help=\"\"\"If True (default), deleting files will send them to the",
            "        platform's trash/recycle bin, where they can be recovered. If False,",
            "        deleting files really deletes them.\"\"\",",
            "    )",
            "",
            "    always_delete_dir = Bool(",
            "        False,",
            "        config=True,",
            "        help=\"\"\"If True, deleting a non-empty directory will always be allowed.",
            "        WARNING this may result in files being permanently removed; e.g. on Windows,",
            "        if the data size is too big for the trash/recycle bin the directory will be permanently",
            "        deleted. If False (default), the non-empty directory will be sent to the trash only",
            "        if safe. And if ``delete_to_trash`` is True, the directory won't be deleted.\"\"\",",
            "    )",
            "",
            "    @default(\"files_handler_class\")",
            "    def _files_handler_class_default(self):",
            "        return AuthenticatedFileHandler",
            "",
            "    @default(\"files_handler_params\")",
            "    def _files_handler_params_default(self):",
            "        return {\"path\": self.root_dir}",
            "",
            "    def is_hidden(self, path):",
            "        \"\"\"Does the API style path correspond to a hidden directory or file?",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        hidden : bool",
            "            Whether the path exists and is hidden.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return is_hidden(os_path, self.root_dir)",
            "",
            "    def is_writable(self, path):",
            "        \"\"\"Does the API style path correspond to a writable directory or file?",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        hidden : bool",
            "            Whether the path exists and is writable.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        try:",
            "            return os.access(os_path, os.W_OK)",
            "        except OSError:",
            "            self.log.error(\"Failed to check write permissions on %s\", os_path)",
            "            return False",
            "",
            "    def file_exists(self, path):",
            "        \"\"\"Returns True if the file exists, else returns False.",
            "",
            "        API-style wrapper for os.path.isfile",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The relative path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the file exists.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        return os.path.isfile(os_path)",
            "",
            "    def dir_exists(self, path):",
            "        \"\"\"Does the API-style path refer to an extant directory?",
            "",
            "        API-style wrapper for os.path.isdir",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The path to check. This is an API path (`/` separated,",
            "            relative to root_dir).",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the path is indeed a directory.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.isdir(os_path)",
            "",
            "    def exists(self, path):",
            "        \"\"\"Returns True if the path exists, else returns False.",
            "",
            "        API-style wrapper for os.path.exists",
            "",
            "        Parameters",
            "        ----------",
            "        path : string",
            "            The API path to the file (with '/' as separator)",
            "",
            "        Returns",
            "        -------",
            "        exists : bool",
            "            Whether the target exists.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return exists(os_path)",
            "",
            "    def _base_model(self, path):",
            "        \"\"\"Build the common base of a contents model\"\"\"",
            "        os_path = self._get_os_path(path)",
            "        info = os.lstat(os_path)",
            "",
            "        four_o_four = \"file or directory does not exist: %r\" % path",
            "",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden file or directory %r, via 404 Error\", os_path)",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        try:",
            "            # size of file",
            "            size = info.st_size",
            "        except (ValueError, OSError):",
            "            self.log.warning(\"Unable to get size.\")",
            "            size = None",
            "",
            "        try:",
            "            last_modified = tz.utcfromtimestamp(info.st_mtime)",
            "        except (ValueError, OSError):",
            "            # Files can rarely have an invalid timestamp",
            "            # https://github.com/jupyter/notebook/issues/2539",
            "            # https://github.com/jupyter/notebook/issues/2757",
            "            # Use the Unix epoch as a fallback so we don't crash.",
            "            self.log.warning(\"Invalid mtime %s for %s\", info.st_mtime, os_path)",
            "            last_modified = datetime(1970, 1, 1, 0, 0, tzinfo=tz.UTC)",
            "",
            "        try:",
            "            created = tz.utcfromtimestamp(info.st_ctime)",
            "        except (ValueError, OSError):  # See above",
            "            self.log.warning(\"Invalid ctime %s for %s\", info.st_ctime, os_path)",
            "            created = datetime(1970, 1, 1, 0, 0, tzinfo=tz.UTC)",
            "",
            "        # Create the base model.",
            "        model = {}",
            "        model[\"name\"] = path.rsplit(\"/\", 1)[-1]",
            "        model[\"path\"] = path",
            "        model[\"last_modified\"] = last_modified",
            "        model[\"created\"] = created",
            "        model[\"content\"] = None",
            "        model[\"format\"] = None",
            "        model[\"mimetype\"] = None",
            "        model[\"size\"] = size",
            "        model[\"writable\"] = self.is_writable(path)",
            "",
            "        return model",
            "",
            "    def _dir_model(self, path, content=True):",
            "        \"\"\"Build a model for a directory",
            "",
            "        if content is requested, will include a listing of the directory",
            "        \"\"\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = \"directory does not exist: %r\" % path",
            "",
            "        if not os.path.isdir(os_path):",
            "            raise web.HTTPError(404, four_o_four)",
            "        elif is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden directory %r, via 404 Error\", os_path)",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"directory\"",
            "        model[\"size\"] = None",
            "        if content:",
            "            model[\"content\"] = contents = []",
            "            os_dir = self._get_os_path(path)",
            "            for name in os.listdir(os_dir):",
            "                try:",
            "                    os_path = os.path.join(os_dir, name)",
            "                except UnicodeDecodeError as e:",
            "                    self.log.warning(\"failed to decode filename '%s': %s\", name, e)",
            "                    continue",
            "",
            "                try:",
            "                    st = os.lstat(os_path)",
            "                except OSError as e:",
            "                    # skip over broken symlinks in listing",
            "                    if e.errno == errno.ENOENT:",
            "                        self.log.warning(\"%s doesn't exist\", os_path)",
            "                    elif e.errno != errno.EACCES:  # Don't provide clues about protected files",
            "                        self.log.warning(\"Error stat-ing %s: %s\", os_path, e)",
            "                    continue",
            "",
            "                if (",
            "                    not stat.S_ISLNK(st.st_mode)",
            "                    and not stat.S_ISREG(st.st_mode)",
            "                    and not stat.S_ISDIR(st.st_mode)",
            "                ):",
            "                    self.log.debug(\"%s not a regular file\", os_path)",
            "                    continue",
            "",
            "                try:",
            "                    if self.should_list(name):",
            "                        if self.allow_hidden or not is_file_hidden(os_path, stat_res=st):",
            "                            contents.append(self.get(path=f\"{path}/{name}\", content=False))",
            "                except OSError as e:",
            "                    # ELOOP: recursive symlink, also don't show failure due to permissions",
            "                    if e.errno not in [errno.ELOOP, errno.EACCES]:",
            "                        self.log.warning(",
            "                            \"Unknown error checking if file %r is hidden\",",
            "                            os_path,",
            "                            exc_info=True,",
            "                        )",
            "",
            "            model[\"format\"] = \"json\"",
            "",
            "        return model",
            "",
            "    def _file_model(self, path, content=True, format=None):",
            "        \"\"\"Build a model for a file",
            "",
            "        if content is requested, include the file contents.",
            "",
            "        format:",
            "          If 'text', the contents will be decoded as UTF-8.",
            "          If 'base64', the raw bytes contents will be encoded as base64.",
            "          If not specified, try to decode as UTF-8, and fall back to base64",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"file\"",
            "",
            "        os_path = self._get_os_path(path)",
            "        model[\"mimetype\"] = mimetypes.guess_type(os_path)[0]",
            "",
            "        if content:",
            "            content, format = self._read_file(os_path, format)",
            "            if model[\"mimetype\"] is None:",
            "                default_mime = {",
            "                    \"text\": \"text/plain\",",
            "                    \"base64\": \"application/octet-stream\",",
            "                }[format]",
            "                model[\"mimetype\"] = default_mime",
            "",
            "            model.update(",
            "                content=content,",
            "                format=format,",
            "            )",
            "",
            "        return model",
            "",
            "    def _notebook_model(self, path, content=True):",
            "        \"\"\"Build a notebook model",
            "",
            "        if content is requested, the notebook content will be populated",
            "        as a JSON structure (not double-serialized)",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"notebook\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        if content:",
            "            validation_error: dict = {}",
            "            nb = self._read_notebook(",
            "                os_path, as_version=4, capture_validation_error=validation_error",
            "            )",
            "            self.mark_trusted_cells(nb, path)",
            "            model[\"content\"] = nb",
            "            model[\"format\"] = \"json\"",
            "            self.validate_notebook_model(model, validation_error)",
            "",
            "        return model",
            "",
            "    def get(self, path, content=True, type=None, format=None):",
            "        \"\"\"Takes a path for an entity and returns its model",
            "",
            "        Parameters",
            "        ----------",
            "        path : str",
            "            the API path that describes the relative path for the target",
            "        content : bool",
            "            Whether to include the contents in the reply",
            "        type : str, optional",
            "            The requested type - 'file', 'notebook', or 'directory'.",
            "            Will raise HTTPError 400 if the content doesn't match.",
            "        format : str, optional",
            "            The requested format for file contents. 'text' or 'base64'.",
            "            Ignored if this returns a notebook or directory model.",
            "",
            "        Returns",
            "        -------",
            "        model : dict",
            "            the contents model. If content=True, returns the contents",
            "            of the file or directory as well.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        four_o_four = \"file or directory does not exist: %r\" % path",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden file or directory %r, via 404 Error\", os_path)",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        if os.path.isdir(os_path):",
            "            if type not in (None, \"directory\"):",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"{path} is a directory, not a {type}\",",
            "                    reason=\"bad type\",",
            "                )",
            "            model = self._dir_model(path, content=content)",
            "        elif type == \"notebook\" or (type is None and path.endswith(\".ipynb\")):",
            "            model = self._notebook_model(path, content=content)",
            "        else:",
            "            if type == \"directory\":",
            "                raise web.HTTPError(400, \"%s is not a directory\" % path, reason=\"bad type\")",
            "            model = self._file_model(path, content=content, format=format)",
            "        return model",
            "",
            "    def _save_directory(self, os_path, model, path=\"\"):",
            "        \"\"\"create a directory\"\"\"",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            raise web.HTTPError(400, \"Cannot create directory %r\" % os_path)",
            "        if not os.path.exists(os_path):",
            "            with self.perm_to_403():",
            "                os.mkdir(os_path)",
            "        elif not os.path.isdir(os_path):",
            "            raise web.HTTPError(400, \"Not a directory: %s\" % (os_path))",
            "        else:",
            "            self.log.debug(\"Directory %r already exists\", os_path)",
            "",
            "    def save(self, model, path=\"\"):",
            "        \"\"\"Save the file model and return the model with no content.\"\"\"",
            "        path = path.strip(\"/\")",
            "",
            "        self.run_pre_save_hooks(model=model, path=path)",
            "",
            "        if \"type\" not in model:",
            "            raise web.HTTPError(400, \"No file type provided\")",
            "        if \"content\" not in model and model[\"type\"] != \"directory\":",
            "            raise web.HTTPError(400, \"No file content provided\")",
            "",
            "        os_path = self._get_os_path(path)",
            "",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            raise web.HTTPError(400, f\"Cannot create file or directory {os_path!r}\")",
            "",
            "        self.log.debug(\"Saving %s\", os_path)",
            "",
            "        validation_error: dict = {}",
            "        try:",
            "            if model[\"type\"] == \"notebook\":",
            "                nb = nbformat.from_dict(model[\"content\"])",
            "                self.check_and_sign(nb, path)",
            "                self._save_notebook(os_path, nb, capture_validation_error=validation_error)",
            "                # One checkpoint should always exist for notebooks.",
            "                if not self.checkpoints.list_checkpoints(path):",
            "                    self.create_checkpoint(path)",
            "            elif model[\"type\"] == \"file\":",
            "                # Missing format will be handled internally by _save_file.",
            "                self._save_file(os_path, model[\"content\"], model.get(\"format\"))",
            "            elif model[\"type\"] == \"directory\":",
            "                self._save_directory(os_path, model, path)",
            "            else:",
            "                raise web.HTTPError(400, \"Unhandled contents type: %s\" % model[\"type\"])",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            self.log.error(\"Error while saving file: %s %s\", path, e, exc_info=True)",
            "            raise web.HTTPError(500, f\"Unexpected error while saving file: {path} {e}\") from e",
            "",
            "        validation_message = None",
            "        if model[\"type\"] == \"notebook\":",
            "            self.validate_notebook_model(model, validation_error=validation_error)",
            "            validation_message = model.get(\"message\", None)",
            "",
            "        model = self.get(path, content=False)",
            "        if validation_message:",
            "            model[\"message\"] = validation_message",
            "",
            "        self.run_post_save_hooks(model=model, os_path=os_path)",
            "",
            "        return model",
            "",
            "    def delete_file(self, path):",
            "        \"\"\"Delete file at path.\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        rm = os.unlink",
            "        four_o_four = \"file or directory does not exist: %r\" % path",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            raise web.HTTPError(400, f\"Cannot delete file or directory {os_path!r}\")",
            "",
            "        def _check_trash(os_path):",
            "            if sys.platform in {\"win32\", \"darwin\"}:",
            "                return True",
            "",
            "            # It's a bit more nuanced than this, but until we can better",
            "            # distinguish errors from send2trash, assume that we can only trash",
            "            # files on the same partition as the home directory.",
            "            file_dev = os.stat(os_path).st_dev",
            "            home_dev = os.stat(os.path.expanduser(\"~\")).st_dev",
            "            return file_dev == home_dev",
            "",
            "        def is_non_empty_dir(os_path):",
            "            if os.path.isdir(os_path):",
            "                # A directory containing only leftover checkpoints is",
            "                # considered empty.",
            "                cp_dir = getattr(self.checkpoints, \"checkpoint_dir\", None)",
            "                if set(os.listdir(os_path)) - {cp_dir}:",
            "                    return True",
            "",
            "            return False",
            "",
            "        if self.delete_to_trash:",
            "            if not self.always_delete_dir and sys.platform == \"win32\" and is_non_empty_dir(os_path):",
            "                # send2trash can really delete files on Windows, so disallow",
            "                # deleting non-empty files. See Github issue 3631.",
            "                raise web.HTTPError(400, \"Directory %s not empty\" % os_path)",
            "            if _check_trash(os_path):",
            "                # Looking at the code in send2trash, I don't think the errors it",
            "                # raises let us distinguish permission errors from other errors in",
            "                # code. So for now, the \"look before you leap\" approach is used.",
            "                if not self.is_writable(path):",
            "                    raise web.HTTPError(403, \"Permission denied: %s\" % path)",
            "                self.log.debug(\"Sending %s to trash\", os_path)",
            "                send2trash(os_path)",
            "                return",
            "            else:",
            "                self.log.warning(",
            "                    \"Skipping trash for %s, on different device to home directory\",",
            "                    os_path,",
            "                )",
            "",
            "        if os.path.isdir(os_path):",
            "            # Don't permanently delete non-empty directories.",
            "            if not self.always_delete_dir and is_non_empty_dir(os_path):",
            "                raise web.HTTPError(400, \"Directory %s not empty\" % os_path)",
            "            self.log.debug(\"Removing directory %s\", os_path)",
            "            with self.perm_to_403():",
            "                shutil.rmtree(os_path)",
            "        else:",
            "            self.log.debug(\"Unlinking file %s\", os_path)",
            "            with self.perm_to_403():",
            "                rm(os_path)",
            "",
            "    def rename_file(self, old_path, new_path):",
            "        \"\"\"Rename a file.\"\"\"",
            "        old_path = old_path.strip(\"/\")",
            "        new_path = new_path.strip(\"/\")",
            "        if new_path == old_path:",
            "            return",
            "",
            "        new_os_path = self._get_os_path(new_path)",
            "        old_os_path = self._get_os_path(old_path)",
            "",
            "        if (",
            "            is_hidden(old_os_path, self.root_dir) or is_hidden(new_os_path, self.root_dir)",
            "        ) and not self.allow_hidden:",
            "            raise web.HTTPError(400, f\"Cannot rename file or directory {old_os_path!r}\")",
            "",
            "        # Should we proceed with the move?",
            "        if os.path.exists(new_os_path) and not samefile(old_os_path, new_os_path):",
            "            raise web.HTTPError(409, \"File already exists: %s\" % new_path)",
            "",
            "        # Move the file",
            "        try:",
            "            with self.perm_to_403():",
            "                shutil.move(old_os_path, new_os_path)",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            raise web.HTTPError(500, f\"Unknown error renaming file: {old_path} {e}\") from e",
            "",
            "    def info_string(self):",
            "        return _i18n(\"Serving notebooks from local directory: %s\") % self.root_dir",
            "",
            "    def get_kernel_path(self, path, model=None):",
            "        \"\"\"Return the initial API path of  a kernel associated with a given notebook\"\"\"",
            "        if self.dir_exists(path):",
            "            return path",
            "        if \"/\" in path:",
            "            parent_dir = path.rsplit(\"/\", 1)[0]",
            "        else:",
            "            parent_dir = \"\"",
            "        return parent_dir",
            "",
            "",
            "class AsyncFileContentsManager(FileContentsManager, AsyncFileManagerMixin, AsyncContentsManager):",
            "    @default(\"checkpoints_class\")",
            "    def _checkpoints_class_default(self):",
            "        return AsyncFileCheckpoints",
            "",
            "    async def _dir_model(self, path, content=True):",
            "        \"\"\"Build a model for a directory",
            "",
            "        if content is requested, will include a listing of the directory",
            "        \"\"\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        four_o_four = \"directory does not exist: %r\" % path",
            "",
            "        if not os.path.isdir(os_path):",
            "            raise web.HTTPError(404, four_o_four)",
            "        elif is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            self.log.info(\"Refusing to serve hidden directory %r, via 404 Error\", os_path)",
            "            raise web.HTTPError(404, four_o_four)",
            "",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"directory\"",
            "        model[\"size\"] = None",
            "        if content:",
            "            model[\"content\"] = contents = []",
            "            os_dir = self._get_os_path(path)",
            "            dir_contents = await run_sync(os.listdir, os_dir)",
            "            for name in dir_contents:",
            "                try:",
            "                    os_path = os.path.join(os_dir, name)",
            "                except UnicodeDecodeError as e:",
            "                    self.log.warning(\"failed to decode filename '%s': %s\", name, e)",
            "                    continue",
            "",
            "                try:",
            "                    st = await run_sync(os.lstat, os_path)",
            "                except OSError as e:",
            "                    # skip over broken symlinks in listing",
            "                    if e.errno == errno.ENOENT:",
            "                        self.log.warning(\"%s doesn't exist\", os_path)",
            "                    elif e.errno != errno.EACCES:  # Don't provide clues about protected files",
            "                        self.log.warning(\"Error stat-ing %s: %s\", os_path, e)",
            "                    continue",
            "",
            "                if (",
            "                    not stat.S_ISLNK(st.st_mode)",
            "                    and not stat.S_ISREG(st.st_mode)",
            "                    and not stat.S_ISDIR(st.st_mode)",
            "                ):",
            "                    self.log.debug(\"%s not a regular file\", os_path)",
            "                    continue",
            "",
            "                try:",
            "                    if self.should_list(name):",
            "                        if self.allow_hidden or not is_file_hidden(os_path, stat_res=st):",
            "                            contents.append(await self.get(path=f\"{path}/{name}\", content=False))",
            "                except OSError as e:",
            "                    # ELOOP: recursive symlink, also don't show failure due to permissions",
            "                    if e.errno not in [errno.ELOOP, errno.EACCES]:",
            "                        self.log.warning(",
            "                            \"Unknown error checking if file %r is hidden\",",
            "                            os_path,",
            "                            exc_info=True,",
            "                        )",
            "",
            "            model[\"format\"] = \"json\"",
            "",
            "        return model",
            "",
            "    async def _file_model(self, path, content=True, format=None):",
            "        \"\"\"Build a model for a file",
            "",
            "        if content is requested, include the file contents.",
            "",
            "        format:",
            "          If 'text', the contents will be decoded as UTF-8.",
            "          If 'base64', the raw bytes contents will be encoded as base64.",
            "          If not specified, try to decode as UTF-8, and fall back to base64",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"file\"",
            "",
            "        os_path = self._get_os_path(path)",
            "        model[\"mimetype\"] = mimetypes.guess_type(os_path)[0]",
            "",
            "        if content:",
            "            content, format = await self._read_file(os_path, format)",
            "            if model[\"mimetype\"] is None:",
            "                default_mime = {",
            "                    \"text\": \"text/plain\",",
            "                    \"base64\": \"application/octet-stream\",",
            "                }[format]",
            "                model[\"mimetype\"] = default_mime",
            "",
            "            model.update(",
            "                content=content,",
            "                format=format,",
            "            )",
            "",
            "        return model",
            "",
            "    async def _notebook_model(self, path, content=True):",
            "        \"\"\"Build a notebook model",
            "",
            "        if content is requested, the notebook content will be populated",
            "        as a JSON structure (not double-serialized)",
            "        \"\"\"",
            "        model = self._base_model(path)",
            "        model[\"type\"] = \"notebook\"",
            "        os_path = self._get_os_path(path)",
            "",
            "        if content:",
            "            validation_error: dict = {}",
            "            nb = await self._read_notebook(",
            "                os_path, as_version=4, capture_validation_error=validation_error",
            "            )",
            "            self.mark_trusted_cells(nb, path)",
            "            model[\"content\"] = nb",
            "            model[\"format\"] = \"json\"",
            "            self.validate_notebook_model(model, validation_error)",
            "",
            "        return model",
            "",
            "    async def get(self, path, content=True, type=None, format=None):",
            "        \"\"\"Takes a path for an entity and returns its model",
            "",
            "        Parameters",
            "        ----------",
            "        path : str",
            "            the API path that describes the relative path for the target",
            "        content : bool",
            "            Whether to include the contents in the reply",
            "        type : str, optional",
            "            The requested type - 'file', 'notebook', or 'directory'.",
            "            Will raise HTTPError 400 if the content doesn't match.",
            "        format : str, optional",
            "            The requested format for file contents. 'text' or 'base64'.",
            "            Ignored if this returns a notebook or directory model.",
            "",
            "        Returns",
            "        -------",
            "        model : dict",
            "            the contents model. If content=True, returns the contents",
            "            of the file or directory as well.",
            "        \"\"\"",
            "        path = path.strip(\"/\")",
            "",
            "        if not self.exists(path):",
            "            raise web.HTTPError(404, \"No such file or directory: %s\" % path)",
            "",
            "        os_path = self._get_os_path(path)",
            "        if os.path.isdir(os_path):",
            "            if type not in (None, \"directory\"):",
            "                raise web.HTTPError(",
            "                    400,",
            "                    f\"{path} is a directory, not a {type}\",",
            "                    reason=\"bad type\",",
            "                )",
            "            model = await self._dir_model(path, content=content)",
            "        elif type == \"notebook\" or (type is None and path.endswith(\".ipynb\")):",
            "            model = await self._notebook_model(path, content=content)",
            "        else:",
            "            if type == \"directory\":",
            "                raise web.HTTPError(400, \"%s is not a directory\" % path, reason=\"bad type\")",
            "            model = await self._file_model(path, content=content, format=format)",
            "        return model",
            "",
            "    async def _save_directory(self, os_path, model, path=\"\"):",
            "        \"\"\"create a directory\"\"\"",
            "        if is_hidden(os_path, self.root_dir) and not self.allow_hidden:",
            "            raise web.HTTPError(400, \"Cannot create hidden directory %r\" % os_path)",
            "        if not os.path.exists(os_path):",
            "            with self.perm_to_403():",
            "                await run_sync(os.mkdir, os_path)",
            "        elif not os.path.isdir(os_path):",
            "            raise web.HTTPError(400, \"Not a directory: %s\" % (os_path))",
            "        else:",
            "            self.log.debug(\"Directory %r already exists\", os_path)",
            "",
            "    async def save(self, model, path=\"\"):",
            "        \"\"\"Save the file model and return the model with no content.\"\"\"",
            "        path = path.strip(\"/\")",
            "",
            "        self.run_pre_save_hook(model=model, path=path)",
            "",
            "        if \"type\" not in model:",
            "            raise web.HTTPError(400, \"No file type provided\")",
            "        if \"content\" not in model and model[\"type\"] != \"directory\":",
            "            raise web.HTTPError(400, \"No file content provided\")",
            "",
            "        os_path = self._get_os_path(path)",
            "        self.log.debug(\"Saving %s\", os_path)",
            "",
            "        validation_error: dict = {}",
            "        try:",
            "            if model[\"type\"] == \"notebook\":",
            "                nb = nbformat.from_dict(model[\"content\"])",
            "                self.check_and_sign(nb, path)",
            "                await self._save_notebook(os_path, nb, capture_validation_error=validation_error)",
            "                # One checkpoint should always exist for notebooks.",
            "                if not (await self.checkpoints.list_checkpoints(path)):",
            "                    await self.create_checkpoint(path)",
            "            elif model[\"type\"] == \"file\":",
            "                # Missing format will be handled internally by _save_file.",
            "                await self._save_file(os_path, model[\"content\"], model.get(\"format\"))",
            "            elif model[\"type\"] == \"directory\":",
            "                await self._save_directory(os_path, model, path)",
            "            else:",
            "                raise web.HTTPError(400, \"Unhandled contents type: %s\" % model[\"type\"])",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            self.log.error(\"Error while saving file: %s %s\", path, e, exc_info=True)",
            "            raise web.HTTPError(500, f\"Unexpected error while saving file: {path} {e}\") from e",
            "",
            "        validation_message = None",
            "        if model[\"type\"] == \"notebook\":",
            "            self.validate_notebook_model(model, validation_error=validation_error)",
            "            validation_message = model.get(\"message\", None)",
            "",
            "        model = await self.get(path, content=False)",
            "        if validation_message:",
            "            model[\"message\"] = validation_message",
            "",
            "        self.run_post_save_hooks(model=model, os_path=os_path)",
            "",
            "        return model",
            "",
            "    async def delete_file(self, path):",
            "        \"\"\"Delete file at path.\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        rm = os.unlink",
            "        if not os.path.exists(os_path):",
            "            raise web.HTTPError(404, \"File or directory does not exist: %s\" % os_path)",
            "",
            "        async def _check_trash(os_path):",
            "            if sys.platform in {\"win32\", \"darwin\"}:",
            "                return True",
            "",
            "            # It's a bit more nuanced than this, but until we can better",
            "            # distinguish errors from send2trash, assume that we can only trash",
            "            # files on the same partition as the home directory.",
            "            file_dev = (await run_sync(os.stat, os_path)).st_dev",
            "            home_dev = (await run_sync(os.stat, os.path.expanduser(\"~\"))).st_dev",
            "            return file_dev == home_dev",
            "",
            "        async def is_non_empty_dir(os_path):",
            "            if os.path.isdir(os_path):",
            "                # A directory containing only leftover checkpoints is",
            "                # considered empty.",
            "                cp_dir = getattr(self.checkpoints, \"checkpoint_dir\", None)",
            "                dir_contents = set(await run_sync(os.listdir, os_path))",
            "                if dir_contents - {cp_dir}:",
            "                    return True",
            "",
            "            return False",
            "",
            "        if self.delete_to_trash:",
            "            if (",
            "                not self.always_delete_dir",
            "                and sys.platform == \"win32\"",
            "                and await is_non_empty_dir(os_path)",
            "            ):",
            "                # send2trash can really delete files on Windows, so disallow",
            "                # deleting non-empty files. See Github issue 3631.",
            "                raise web.HTTPError(400, \"Directory %s not empty\" % os_path)",
            "            if await _check_trash(os_path):",
            "                # Looking at the code in send2trash, I don't think the errors it",
            "                # raises let us distinguish permission errors from other errors in",
            "                # code. So for now, the \"look before you leap\" approach is used.",
            "                if not self.is_writable(path):",
            "                    raise web.HTTPError(403, \"Permission denied: %s\" % path)",
            "                self.log.debug(\"Sending %s to trash\", os_path)",
            "                send2trash(os_path)",
            "                return",
            "            else:",
            "                self.log.warning(",
            "                    \"Skipping trash for %s, on different device to home directory\",",
            "                    os_path,",
            "                )",
            "",
            "        if os.path.isdir(os_path):",
            "            # Don't permanently delete non-empty directories.",
            "            if not self.always_delete_dir and await is_non_empty_dir(os_path):",
            "                raise web.HTTPError(400, \"Directory %s not empty\" % os_path)",
            "            self.log.debug(\"Removing directory %s\", os_path)",
            "            with self.perm_to_403():",
            "                await run_sync(shutil.rmtree, os_path)",
            "        else:",
            "            self.log.debug(\"Unlinking file %s\", os_path)",
            "            with self.perm_to_403():",
            "                await run_sync(rm, os_path)",
            "",
            "    async def rename_file(self, old_path, new_path):",
            "        \"\"\"Rename a file.\"\"\"",
            "        old_path = old_path.strip(\"/\")",
            "        new_path = new_path.strip(\"/\")",
            "        if new_path == old_path:",
            "            return",
            "",
            "        new_os_path = self._get_os_path(new_path)",
            "        old_os_path = self._get_os_path(old_path)",
            "",
            "        # Should we proceed with the move?",
            "        if os.path.exists(new_os_path) and not samefile(old_os_path, new_os_path):",
            "            raise web.HTTPError(409, \"File already exists: %s\" % new_path)",
            "",
            "        # Move the file",
            "        try:",
            "            with self.perm_to_403():",
            "                await run_sync(shutil.move, old_os_path, new_os_path)",
            "        except web.HTTPError:",
            "            raise",
            "        except Exception as e:",
            "            raise web.HTTPError(500, f\"Unknown error renaming file: {old_path} {e}\") from e",
            "",
            "    async def dir_exists(self, path):",
            "        \"\"\"Does a directory exist at the given path\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return os.path.isdir(os_path)",
            "",
            "    async def file_exists(self, path):",
            "        \"\"\"Does a file exist at the given path\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path)",
            "        return os.path.isfile(os_path)",
            "",
            "    async def is_hidden(self, path):",
            "        \"\"\"Is path a hidden directory or file\"\"\"",
            "        path = path.strip(\"/\")",
            "        os_path = self._get_os_path(path=path)",
            "        return is_hidden(os_path, self.root_dir)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "370": [
                "FileContentsManager",
                "get"
            ],
            "372": [
                "FileContentsManager",
                "get"
            ],
            "392": [
                "FileContentsManager",
                "_save_directory"
            ],
            "455": [
                "FileContentsManager",
                "delete_file"
            ],
            "456": [
                "FileContentsManager",
                "delete_file"
            ]
        },
        "addLocation": [
            "jupyter_server.services.contents.filemanager.FileContentsManager._dir_model",
            "jupyter_server.services.contents.filemanager.AsyncFileContentsManager._notebook_model",
            "jupyter_server.services.contents.filemanager.FileContentsManager._notebook_model",
            "jupyter_server.services.contents.filemanager.FileContentsManager._file_model",
            "jupyter_server.services.contents.filemanager.FileContentsManager.save",
            "jupyter_server.services.contents.filemanager.AsyncFileContentsManager._dir_model",
            "jupyter_server.services.contents.filemanager.FileContentsManager._base_model.model",
            "jupyter_server.services.contents.filemanager.AsyncFileContentsManager._file_model",
            "flower.command"
        ]
    },
    "jupyter_server/services/contents/handlers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         of the files and directories it contains."
            },
            "1": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         path = path or \"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        cm = self.contents_manager"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         type = self.get_query_argument(\"type\", default=None)"
            },
            "6": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         if type not in {None, \"directory\", \"file\", \"notebook\"}:"
            },
            "7": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "             raise web.HTTPError(400, \"Type %r is invalid\" % type)"
            },
            "8": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             raise web.HTTPError(400, \"Content %r is invalid\" % content_str)"
            },
            "9": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         content = int(content_str or \"\")"
            },
            "10": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        if await ensure_async(cm.is_hidden(path)) and not cm.allow_hidden:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+            raise web.HTTPError(404, f\"file or directory {path!r} does not exist\")"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         model = await ensure_async("
            },
            "15": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "             self.contents_manager.get("
            },
            "16": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "                 path=path,"
            },
            "17": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         model = self.get_json_body()"
            },
            "18": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         if model is None:"
            },
            "19": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "             raise web.HTTPError(400, \"JSON body missing\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        old_path = model.get(\"path\")"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        if ("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            old_path"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            and ("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+                await ensure_async(cm.is_hidden(path)) or await ensure_async(cm.is_hidden(old_path))"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+            )"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+            and not cm.allow_hidden"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        ):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            raise web.HTTPError(400, f\"Cannot rename file or directory {path!r}\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         model = await ensure_async(cm.update(model, path))"
            },
            "32": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         validate_model(model, expect_content=False)"
            },
            "33": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         self._finish_model(model)"
            },
            "34": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "             raise web.HTTPError(400, \"Cannot POST to files, use PUT instead.\")"
            },
            "35": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 208,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         model = self.get_json_body()"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        copy_from = model.get(\"copy_from\")"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+        if ("
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+            copy_from"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+            and ("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+                await ensure_async(cm.is_hidden(path))"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+                or await ensure_async(cm.is_hidden(copy_from))"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            )"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            and not cm.allow_hidden"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        ):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+            raise web.HTTPError(400, f\"Cannot copy file or directory {path!r}\")"
            },
            "47": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         if model is not None:"
            },
            "49": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "             copy_from = model.get(\"copy_from\")"
            },
            "50": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "           create a new empty notebook."
            },
            "51": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         \"\"\""
            },
            "52": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         model = self.get_json_body()"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        cm = self.contents_manager"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         if model:"
            },
            "56": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "             if model.get(\"copy_from\"):"
            },
            "57": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "                 raise web.HTTPError(400, \"Cannot copy with PUT, only POST\")"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+            if ("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+                (model.get(\"path\") and await ensure_async(cm.is_hidden(model.get(\"path\"))))"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+                or await ensure_async(cm.is_hidden(path))"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+            ) and not cm.allow_hidden:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+                raise web.HTTPError(400, f\"Cannot create file or directory {path!r}\")"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "             exists = await ensure_async(self.contents_manager.file_exists(path))"
            },
            "65": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "             if exists:"
            },
            "66": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "                 await self._save(model, path)"
            },
            "67": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "     async def delete(self, path=\"\"):"
            },
            "68": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "         \"\"\"delete a file in the given path\"\"\""
            },
            "69": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         cm = self.contents_manager"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+        if await ensure_async(cm.is_hidden(path)) and not cm.allow_hidden:"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+            raise web.HTTPError(400, f\"Cannot delete file or directory {path!r}\")"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "         self.log.warning(\"delete %s\", path)"
            },
            "75": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "         await ensure_async(cm.delete(path))"
            },
            "76": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         self.set_status(204)"
            }
        },
        "frontPatchFile": [
            "\"\"\"Tornado handlers for the contents web service.",
            "",
            "Preliminary documentation at https://github.com/ipython/ipython/wiki/IPEP-27%3A-Contents-Service",
            "\"\"\"",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import json",
            "",
            "try:",
            "    from jupyter_client.jsonutil import json_default",
            "except ImportError:",
            "    from jupyter_client.jsonutil import date_default as json_default",
            "",
            "from tornado import web",
            "",
            "from jupyter_server.auth import authorized",
            "from jupyter_server.base.handlers import APIHandler, JupyterHandler, path_regex",
            "from jupyter_server.utils import ensure_async, url_escape, url_path_join",
            "",
            "AUTH_RESOURCE = \"contents\"",
            "",
            "",
            "def validate_model(model, expect_content):",
            "    \"\"\"",
            "    Validate a model returned by a ContentsManager method.",
            "",
            "    If expect_content is True, then we expect non-null entries for 'content'",
            "    and 'format'.",
            "    \"\"\"",
            "    required_keys = {",
            "        \"name\",",
            "        \"path\",",
            "        \"type\",",
            "        \"writable\",",
            "        \"created\",",
            "        \"last_modified\",",
            "        \"mimetype\",",
            "        \"content\",",
            "        \"format\",",
            "    }",
            "    missing = required_keys - set(model.keys())",
            "    if missing:",
            "        raise web.HTTPError(",
            "            500,",
            "            f\"Missing Model Keys: {missing}\",",
            "        )",
            "",
            "    maybe_none_keys = [\"content\", \"format\"]",
            "    if expect_content:",
            "        errors = [key for key in maybe_none_keys if model[key] is None]",
            "        if errors:",
            "            raise web.HTTPError(",
            "                500,",
            "                f\"Keys unexpectedly None: {errors}\",",
            "            )",
            "    else:",
            "        errors = {key: model[key] for key in maybe_none_keys if model[key] is not None}  # type: ignore[assignment]",
            "        if errors:",
            "            raise web.HTTPError(",
            "                500,",
            "                f\"Keys unexpectedly not None: {errors}\",",
            "            )",
            "",
            "",
            "class ContentsAPIHandler(APIHandler):",
            "    auth_resource = AUTH_RESOURCE",
            "",
            "",
            "class ContentsHandler(ContentsAPIHandler):",
            "    def location_url(self, path):",
            "        \"\"\"Return the full URL location of a file.",
            "",
            "        Parameters",
            "        ----------",
            "        path : unicode",
            "            The API path of the file, such as \"foo/bar.txt\".",
            "        \"\"\"",
            "        return url_path_join(self.base_url, \"api\", \"contents\", url_escape(path))",
            "",
            "    def _finish_model(self, model, location=True):",
            "        \"\"\"Finish a JSON request with a model, setting relevant headers, etc.\"\"\"",
            "        if location:",
            "            location = self.location_url(model[\"path\"])",
            "            self.set_header(\"Location\", location)",
            "        self.set_header(\"Last-Modified\", model[\"last_modified\"])",
            "        self.set_header(\"Content-Type\", \"application/json\")",
            "        self.finish(json.dumps(model, default=json_default))",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def get(self, path=\"\"):",
            "        \"\"\"Return a model for a file or directory.",
            "",
            "        A directory model contains a list of models (without content)",
            "        of the files and directories it contains.",
            "        \"\"\"",
            "        path = path or \"\"",
            "        type = self.get_query_argument(\"type\", default=None)",
            "        if type not in {None, \"directory\", \"file\", \"notebook\"}:",
            "            raise web.HTTPError(400, \"Type %r is invalid\" % type)",
            "",
            "        format = self.get_query_argument(\"format\", default=None)",
            "        if format not in {None, \"text\", \"base64\"}:",
            "            raise web.HTTPError(400, \"Format %r is invalid\" % format)",
            "        content_str = self.get_query_argument(\"content\", default=\"1\")",
            "        if content_str not in {\"0\", \"1\"}:",
            "            raise web.HTTPError(400, \"Content %r is invalid\" % content_str)",
            "        content = int(content_str or \"\")",
            "",
            "        model = await ensure_async(",
            "            self.contents_manager.get(",
            "                path=path,",
            "                type=type,",
            "                format=format,",
            "                content=content,",
            "            )",
            "        )",
            "        validate_model(model, expect_content=content)",
            "        self._finish_model(model, location=False)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def patch(self, path=\"\"):",
            "        \"\"\"PATCH renames a file or directory without re-uploading content.\"\"\"",
            "        cm = self.contents_manager",
            "        model = self.get_json_body()",
            "        if model is None:",
            "            raise web.HTTPError(400, \"JSON body missing\")",
            "        model = await ensure_async(cm.update(model, path))",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    async def _copy(self, copy_from, copy_to=None):",
            "        \"\"\"Copy a file, optionally specifying a target directory.\"\"\"",
            "        self.log.info(",
            "            \"Copying {copy_from} to {copy_to}\".format(",
            "                copy_from=copy_from,",
            "                copy_to=copy_to or \"\",",
            "            )",
            "        )",
            "        model = await ensure_async(self.contents_manager.copy(copy_from, copy_to))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    async def _upload(self, model, path):",
            "        \"\"\"Handle upload of a new file to path\"\"\"",
            "        self.log.info(\"Uploading file to %s\", path)",
            "        model = await ensure_async(self.contents_manager.new(model, path))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    async def _new_untitled(self, path, type=\"\", ext=\"\"):",
            "        \"\"\"Create a new, empty untitled entity\"\"\"",
            "        self.log.info(\"Creating new %s in %s\", type or \"file\", path)",
            "        model = await ensure_async(",
            "            self.contents_manager.new_untitled(path=path, type=type, ext=ext)",
            "        )",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    async def _save(self, model, path):",
            "        \"\"\"Save an existing file.\"\"\"",
            "        chunk = model.get(\"chunk\", None)",
            "        if not chunk or chunk == -1:  # Avoid tedious log information",
            "            self.log.info(\"Saving file at %s\", path)",
            "        model = await ensure_async(self.contents_manager.save(model, path))",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def post(self, path=\"\"):",
            "        \"\"\"Create a new file in the specified path.",
            "",
            "        POST creates new files. The server always decides on the name.",
            "",
            "        POST /api/contents/path",
            "          New untitled, empty file or directory.",
            "        POST /api/contents/path",
            "          with body {\"copy_from\" : \"/path/to/OtherNotebook.ipynb\"}",
            "          New copy of OtherNotebook in path",
            "        \"\"\"",
            "",
            "        cm = self.contents_manager",
            "",
            "        file_exists = await ensure_async(cm.file_exists(path))",
            "        if file_exists:",
            "            raise web.HTTPError(400, \"Cannot POST to files, use PUT instead.\")",
            "",
            "        model = self.get_json_body()",
            "",
            "        if model is not None:",
            "            copy_from = model.get(\"copy_from\")",
            "            ext = model.get(\"ext\", \"\")",
            "            type = model.get(\"type\", \"\")",
            "            if copy_from:",
            "                await self._copy(copy_from, path)",
            "            else:",
            "                await self._new_untitled(path, type=type, ext=ext)",
            "        else:",
            "            await self._new_untitled(path)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def put(self, path=\"\"):",
            "        \"\"\"Saves the file in the location specified by name and path.",
            "",
            "        PUT is very similar to POST, but the requester specifies the name,",
            "        whereas with POST, the server picks the name.",
            "",
            "        PUT /api/contents/path/Name.ipynb",
            "          Save notebook at ``path/Name.ipynb``. Notebook structure is specified",
            "          in `content` key of JSON request body. If content is not specified,",
            "          create a new empty notebook.",
            "        \"\"\"",
            "        model = self.get_json_body()",
            "        if model:",
            "            if model.get(\"copy_from\"):",
            "                raise web.HTTPError(400, \"Cannot copy with PUT, only POST\")",
            "            exists = await ensure_async(self.contents_manager.file_exists(path))",
            "            if exists:",
            "                await self._save(model, path)",
            "            else:",
            "                await self._upload(model, path)",
            "        else:",
            "            await self._new_untitled(path)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def delete(self, path=\"\"):",
            "        \"\"\"delete a file in the given path\"\"\"",
            "        cm = self.contents_manager",
            "        self.log.warning(\"delete %s\", path)",
            "        await ensure_async(cm.delete(path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "",
            "class CheckpointsHandler(ContentsAPIHandler):",
            "    @web.authenticated",
            "    @authorized",
            "    async def get(self, path=\"\"):",
            "        \"\"\"get lists checkpoints for a file\"\"\"",
            "        cm = self.contents_manager",
            "        checkpoints = await ensure_async(cm.list_checkpoints(path))",
            "        data = json.dumps(checkpoints, default=json_default)",
            "        self.finish(data)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def post(self, path=\"\"):",
            "        \"\"\"post creates a new checkpoint\"\"\"",
            "        cm = self.contents_manager",
            "        checkpoint = await ensure_async(cm.create_checkpoint(path))",
            "        data = json.dumps(checkpoint, default=json_default)",
            "        location = url_path_join(",
            "            self.base_url,",
            "            \"api/contents\",",
            "            url_escape(path),",
            "            \"checkpoints\",",
            "            url_escape(checkpoint[\"id\"]),",
            "        )",
            "        self.set_header(\"Location\", location)",
            "        self.set_status(201)",
            "        self.finish(data)",
            "",
            "",
            "class ModifyCheckpointsHandler(ContentsAPIHandler):",
            "    @web.authenticated",
            "    @authorized",
            "    async def post(self, path, checkpoint_id):",
            "        \"\"\"post restores a file from a checkpoint\"\"\"",
            "        cm = self.contents_manager",
            "        await ensure_async(cm.restore_checkpoint(checkpoint_id, path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def delete(self, path, checkpoint_id):",
            "        \"\"\"delete clears a checkpoint for a given file\"\"\"",
            "        cm = self.contents_manager",
            "        await ensure_async(cm.delete_checkpoint(checkpoint_id, path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "",
            "class NotebooksRedirectHandler(JupyterHandler):",
            "    \"\"\"Redirect /api/notebooks to /api/contents\"\"\"",
            "",
            "    SUPPORTED_METHODS = (\"GET\", \"PUT\", \"PATCH\", \"POST\", \"DELETE\")",
            "",
            "    def get(self, path):",
            "        self.log.warning(\"/api/notebooks is deprecated, use /api/contents\")",
            "        self.redirect(url_path_join(self.base_url, \"api/contents\", url_escape(path)))",
            "",
            "    put = patch = post = delete = get",
            "",
            "",
            "class TrustNotebooksHandler(JupyterHandler):",
            "    \"\"\"Handles trust/signing of notebooks\"\"\"",
            "",
            "    @web.authenticated",
            "    @authorized(resource=AUTH_RESOURCE)",
            "    async def post(self, path=\"\"):",
            "        cm = self.contents_manager",
            "        await ensure_async(cm.trust_notebook(path))",
            "        self.set_status(201)",
            "        self.finish()",
            "",
            "",
            "# -----------------------------------------------------------------------------",
            "# URL to handler mappings",
            "# -----------------------------------------------------------------------------",
            "",
            "",
            "_checkpoint_id_regex = r\"(?P<checkpoint_id>[\\w-]+)\"",
            "",
            "",
            "default_handlers = [",
            "    (r\"/api/contents%s/checkpoints\" % path_regex, CheckpointsHandler),",
            "    (",
            "        rf\"/api/contents{path_regex}/checkpoints/{_checkpoint_id_regex}\",",
            "        ModifyCheckpointsHandler,",
            "    ),",
            "    (r\"/api/contents%s/trust\" % path_regex, TrustNotebooksHandler),",
            "    (r\"/api/contents%s\" % path_regex, ContentsHandler),",
            "    (r\"/api/notebooks/?(.*)\", NotebooksRedirectHandler),",
            "]"
        ],
        "afterPatchFile": [
            "\"\"\"Tornado handlers for the contents web service.",
            "",
            "Preliminary documentation at https://github.com/ipython/ipython/wiki/IPEP-27%3A-Contents-Service",
            "\"\"\"",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "import json",
            "",
            "try:",
            "    from jupyter_client.jsonutil import json_default",
            "except ImportError:",
            "    from jupyter_client.jsonutil import date_default as json_default",
            "",
            "from tornado import web",
            "",
            "from jupyter_server.auth import authorized",
            "from jupyter_server.base.handlers import APIHandler, JupyterHandler, path_regex",
            "from jupyter_server.utils import ensure_async, url_escape, url_path_join",
            "",
            "AUTH_RESOURCE = \"contents\"",
            "",
            "",
            "def validate_model(model, expect_content):",
            "    \"\"\"",
            "    Validate a model returned by a ContentsManager method.",
            "",
            "    If expect_content is True, then we expect non-null entries for 'content'",
            "    and 'format'.",
            "    \"\"\"",
            "    required_keys = {",
            "        \"name\",",
            "        \"path\",",
            "        \"type\",",
            "        \"writable\",",
            "        \"created\",",
            "        \"last_modified\",",
            "        \"mimetype\",",
            "        \"content\",",
            "        \"format\",",
            "    }",
            "    missing = required_keys - set(model.keys())",
            "    if missing:",
            "        raise web.HTTPError(",
            "            500,",
            "            f\"Missing Model Keys: {missing}\",",
            "        )",
            "",
            "    maybe_none_keys = [\"content\", \"format\"]",
            "    if expect_content:",
            "        errors = [key for key in maybe_none_keys if model[key] is None]",
            "        if errors:",
            "            raise web.HTTPError(",
            "                500,",
            "                f\"Keys unexpectedly None: {errors}\",",
            "            )",
            "    else:",
            "        errors = {key: model[key] for key in maybe_none_keys if model[key] is not None}  # type: ignore[assignment]",
            "        if errors:",
            "            raise web.HTTPError(",
            "                500,",
            "                f\"Keys unexpectedly not None: {errors}\",",
            "            )",
            "",
            "",
            "class ContentsAPIHandler(APIHandler):",
            "    auth_resource = AUTH_RESOURCE",
            "",
            "",
            "class ContentsHandler(ContentsAPIHandler):",
            "    def location_url(self, path):",
            "        \"\"\"Return the full URL location of a file.",
            "",
            "        Parameters",
            "        ----------",
            "        path : unicode",
            "            The API path of the file, such as \"foo/bar.txt\".",
            "        \"\"\"",
            "        return url_path_join(self.base_url, \"api\", \"contents\", url_escape(path))",
            "",
            "    def _finish_model(self, model, location=True):",
            "        \"\"\"Finish a JSON request with a model, setting relevant headers, etc.\"\"\"",
            "        if location:",
            "            location = self.location_url(model[\"path\"])",
            "            self.set_header(\"Location\", location)",
            "        self.set_header(\"Last-Modified\", model[\"last_modified\"])",
            "        self.set_header(\"Content-Type\", \"application/json\")",
            "        self.finish(json.dumps(model, default=json_default))",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def get(self, path=\"\"):",
            "        \"\"\"Return a model for a file or directory.",
            "",
            "        A directory model contains a list of models (without content)",
            "        of the files and directories it contains.",
            "        \"\"\"",
            "        path = path or \"\"",
            "        cm = self.contents_manager",
            "",
            "        type = self.get_query_argument(\"type\", default=None)",
            "        if type not in {None, \"directory\", \"file\", \"notebook\"}:",
            "            raise web.HTTPError(400, \"Type %r is invalid\" % type)",
            "",
            "        format = self.get_query_argument(\"format\", default=None)",
            "        if format not in {None, \"text\", \"base64\"}:",
            "            raise web.HTTPError(400, \"Format %r is invalid\" % format)",
            "        content_str = self.get_query_argument(\"content\", default=\"1\")",
            "        if content_str not in {\"0\", \"1\"}:",
            "            raise web.HTTPError(400, \"Content %r is invalid\" % content_str)",
            "        content = int(content_str or \"\")",
            "",
            "        if await ensure_async(cm.is_hidden(path)) and not cm.allow_hidden:",
            "            raise web.HTTPError(404, f\"file or directory {path!r} does not exist\")",
            "",
            "        model = await ensure_async(",
            "            self.contents_manager.get(",
            "                path=path,",
            "                type=type,",
            "                format=format,",
            "                content=content,",
            "            )",
            "        )",
            "        validate_model(model, expect_content=content)",
            "        self._finish_model(model, location=False)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def patch(self, path=\"\"):",
            "        \"\"\"PATCH renames a file or directory without re-uploading content.\"\"\"",
            "        cm = self.contents_manager",
            "        model = self.get_json_body()",
            "        if model is None:",
            "            raise web.HTTPError(400, \"JSON body missing\")",
            "",
            "        old_path = model.get(\"path\")",
            "        if (",
            "            old_path",
            "            and (",
            "                await ensure_async(cm.is_hidden(path)) or await ensure_async(cm.is_hidden(old_path))",
            "            )",
            "            and not cm.allow_hidden",
            "        ):",
            "            raise web.HTTPError(400, f\"Cannot rename file or directory {path!r}\")",
            "",
            "        model = await ensure_async(cm.update(model, path))",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    async def _copy(self, copy_from, copy_to=None):",
            "        \"\"\"Copy a file, optionally specifying a target directory.\"\"\"",
            "        self.log.info(",
            "            \"Copying {copy_from} to {copy_to}\".format(",
            "                copy_from=copy_from,",
            "                copy_to=copy_to or \"\",",
            "            )",
            "        )",
            "        model = await ensure_async(self.contents_manager.copy(copy_from, copy_to))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    async def _upload(self, model, path):",
            "        \"\"\"Handle upload of a new file to path\"\"\"",
            "        self.log.info(\"Uploading file to %s\", path)",
            "        model = await ensure_async(self.contents_manager.new(model, path))",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    async def _new_untitled(self, path, type=\"\", ext=\"\"):",
            "        \"\"\"Create a new, empty untitled entity\"\"\"",
            "        self.log.info(\"Creating new %s in %s\", type or \"file\", path)",
            "        model = await ensure_async(",
            "            self.contents_manager.new_untitled(path=path, type=type, ext=ext)",
            "        )",
            "        self.set_status(201)",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    async def _save(self, model, path):",
            "        \"\"\"Save an existing file.\"\"\"",
            "        chunk = model.get(\"chunk\", None)",
            "        if not chunk or chunk == -1:  # Avoid tedious log information",
            "            self.log.info(\"Saving file at %s\", path)",
            "        model = await ensure_async(self.contents_manager.save(model, path))",
            "        validate_model(model, expect_content=False)",
            "        self._finish_model(model)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def post(self, path=\"\"):",
            "        \"\"\"Create a new file in the specified path.",
            "",
            "        POST creates new files. The server always decides on the name.",
            "",
            "        POST /api/contents/path",
            "          New untitled, empty file or directory.",
            "        POST /api/contents/path",
            "          with body {\"copy_from\" : \"/path/to/OtherNotebook.ipynb\"}",
            "          New copy of OtherNotebook in path",
            "        \"\"\"",
            "",
            "        cm = self.contents_manager",
            "",
            "        file_exists = await ensure_async(cm.file_exists(path))",
            "        if file_exists:",
            "            raise web.HTTPError(400, \"Cannot POST to files, use PUT instead.\")",
            "",
            "        model = self.get_json_body()",
            "        copy_from = model.get(\"copy_from\")",
            "        if (",
            "            copy_from",
            "            and (",
            "                await ensure_async(cm.is_hidden(path))",
            "                or await ensure_async(cm.is_hidden(copy_from))",
            "            )",
            "            and not cm.allow_hidden",
            "        ):",
            "            raise web.HTTPError(400, f\"Cannot copy file or directory {path!r}\")",
            "",
            "        if model is not None:",
            "            copy_from = model.get(\"copy_from\")",
            "            ext = model.get(\"ext\", \"\")",
            "            type = model.get(\"type\", \"\")",
            "            if copy_from:",
            "                await self._copy(copy_from, path)",
            "            else:",
            "                await self._new_untitled(path, type=type, ext=ext)",
            "        else:",
            "            await self._new_untitled(path)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def put(self, path=\"\"):",
            "        \"\"\"Saves the file in the location specified by name and path.",
            "",
            "        PUT is very similar to POST, but the requester specifies the name,",
            "        whereas with POST, the server picks the name.",
            "",
            "        PUT /api/contents/path/Name.ipynb",
            "          Save notebook at ``path/Name.ipynb``. Notebook structure is specified",
            "          in `content` key of JSON request body. If content is not specified,",
            "          create a new empty notebook.",
            "        \"\"\"",
            "        model = self.get_json_body()",
            "        cm = self.contents_manager",
            "",
            "        if model:",
            "            if model.get(\"copy_from\"):",
            "                raise web.HTTPError(400, \"Cannot copy with PUT, only POST\")",
            "            if (",
            "                (model.get(\"path\") and await ensure_async(cm.is_hidden(model.get(\"path\"))))",
            "                or await ensure_async(cm.is_hidden(path))",
            "            ) and not cm.allow_hidden:",
            "                raise web.HTTPError(400, f\"Cannot create file or directory {path!r}\")",
            "",
            "            exists = await ensure_async(self.contents_manager.file_exists(path))",
            "            if exists:",
            "                await self._save(model, path)",
            "            else:",
            "                await self._upload(model, path)",
            "        else:",
            "            await self._new_untitled(path)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def delete(self, path=\"\"):",
            "        \"\"\"delete a file in the given path\"\"\"",
            "        cm = self.contents_manager",
            "",
            "        if await ensure_async(cm.is_hidden(path)) and not cm.allow_hidden:",
            "            raise web.HTTPError(400, f\"Cannot delete file or directory {path!r}\")",
            "",
            "        self.log.warning(\"delete %s\", path)",
            "        await ensure_async(cm.delete(path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "",
            "class CheckpointsHandler(ContentsAPIHandler):",
            "    @web.authenticated",
            "    @authorized",
            "    async def get(self, path=\"\"):",
            "        \"\"\"get lists checkpoints for a file\"\"\"",
            "        cm = self.contents_manager",
            "        checkpoints = await ensure_async(cm.list_checkpoints(path))",
            "        data = json.dumps(checkpoints, default=json_default)",
            "        self.finish(data)",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def post(self, path=\"\"):",
            "        \"\"\"post creates a new checkpoint\"\"\"",
            "        cm = self.contents_manager",
            "        checkpoint = await ensure_async(cm.create_checkpoint(path))",
            "        data = json.dumps(checkpoint, default=json_default)",
            "        location = url_path_join(",
            "            self.base_url,",
            "            \"api/contents\",",
            "            url_escape(path),",
            "            \"checkpoints\",",
            "            url_escape(checkpoint[\"id\"]),",
            "        )",
            "        self.set_header(\"Location\", location)",
            "        self.set_status(201)",
            "        self.finish(data)",
            "",
            "",
            "class ModifyCheckpointsHandler(ContentsAPIHandler):",
            "    @web.authenticated",
            "    @authorized",
            "    async def post(self, path, checkpoint_id):",
            "        \"\"\"post restores a file from a checkpoint\"\"\"",
            "        cm = self.contents_manager",
            "        await ensure_async(cm.restore_checkpoint(checkpoint_id, path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "    @web.authenticated",
            "    @authorized",
            "    async def delete(self, path, checkpoint_id):",
            "        \"\"\"delete clears a checkpoint for a given file\"\"\"",
            "        cm = self.contents_manager",
            "        await ensure_async(cm.delete_checkpoint(checkpoint_id, path))",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "",
            "class NotebooksRedirectHandler(JupyterHandler):",
            "    \"\"\"Redirect /api/notebooks to /api/contents\"\"\"",
            "",
            "    SUPPORTED_METHODS = (\"GET\", \"PUT\", \"PATCH\", \"POST\", \"DELETE\")",
            "",
            "    def get(self, path):",
            "        self.log.warning(\"/api/notebooks is deprecated, use /api/contents\")",
            "        self.redirect(url_path_join(self.base_url, \"api/contents\", url_escape(path)))",
            "",
            "    put = patch = post = delete = get",
            "",
            "",
            "class TrustNotebooksHandler(JupyterHandler):",
            "    \"\"\"Handles trust/signing of notebooks\"\"\"",
            "",
            "    @web.authenticated",
            "    @authorized(resource=AUTH_RESOURCE)",
            "    async def post(self, path=\"\"):",
            "        cm = self.contents_manager",
            "        await ensure_async(cm.trust_notebook(path))",
            "        self.set_status(201)",
            "        self.finish()",
            "",
            "",
            "# -----------------------------------------------------------------------------",
            "# URL to handler mappings",
            "# -----------------------------------------------------------------------------",
            "",
            "",
            "_checkpoint_id_regex = r\"(?P<checkpoint_id>[\\w-]+)\"",
            "",
            "",
            "default_handlers = [",
            "    (r\"/api/contents%s/checkpoints\" % path_regex, CheckpointsHandler),",
            "    (",
            "        rf\"/api/contents{path_regex}/checkpoints/{_checkpoint_id_regex}\",",
            "        ModifyCheckpointsHandler,",
            "    ),",
            "    (r\"/api/contents%s/trust\" % path_regex, TrustNotebooksHandler),",
            "    (r\"/api/contents%s\" % path_regex, ContentsHandler),",
            "    (r\"/api/notebooks/?(.*)\", NotebooksRedirectHandler),",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "jupyter_server.services.contents.handlers.ContentsHandler.self"
        ]
    }
}