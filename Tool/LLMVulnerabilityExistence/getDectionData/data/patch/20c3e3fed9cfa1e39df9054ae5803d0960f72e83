{
    "tcms/kiwi_auth/admin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "             \"username\","
            },
            "1": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "             \"last_login\","
            },
            "2": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "             \"date_joined\","
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            \"email\","
            },
            "4": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         ]"
            },
            "5": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         # only other superusers can set the is_superuser flag"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "from django import forms",
            "from django.contrib import admin, messages",
            "from django.contrib.admin.widgets import FilteredSelectMultiple",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.auth.admin import GroupAdmin, UserAdmin, sensitive_post_parameters_m",
            "from django.contrib.auth.forms import UserChangeForm",
            "from django.contrib.auth.models import Group, Permission",
            "from django.core.exceptions import PermissionDenied",
            "from django.http import HttpResponseRedirect",
            "from django.urls import reverse",
            "from django.utils.translation import gettext_lazy as _",
            "",
            "from tcms.utils.user import delete_user",
            "",
            "User = get_user_model()  # pylint: disable=invalid-name",
            "",
            "",
            "class MyUserChangeForm(UserChangeForm):",
            "    \"\"\"",
            "    Enforces unique user emails.",
            "    \"\"\"",
            "",
            "    email = forms.EmailField(required=True)",
            "",
            "    def clean_email(self):",
            "        query_set = User.objects.filter(email=self.cleaned_data[\"email\"])",
            "        if self.instance:",
            "            query_set = query_set.exclude(pk=self.instance.pk)",
            "        if query_set.count():",
            "            raise forms.ValidationError(_(\"This email address is already in use\"))",
            "",
            "        return self.cleaned_data[\"email\"]",
            "",
            "",
            "def _modifying_myself(request, object_id):",
            "    return request.user.pk == int(object_id)",
            "",
            "",
            "class GroupAdminForm(forms.ModelForm):",
            "    class Meta:",
            "        model = Group",
            "        fields = [\"name\", \"permissions\"]",
            "",
            "    users = forms.ModelMultipleChoiceField(",
            "        queryset=User.objects.all(),",
            "        required=False,",
            "        widget=FilteredSelectMultiple(\"users\", False),",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.fields[\"users\"].label = _(\"Users\")",
            "        if self.instance.pk:",
            "            self.fields[\"users\"].initial = self.instance.user_set.all()",
            "",
            "    def save(self, commit=True):",
            "        instance = super().save(commit=commit)",
            "        instance.save()",
            "",
            "        self.instance.user_set.set(self.cleaned_data[\"users\"])",
            "        self.save_m2m()",
            "",
            "        return instance",
            "",
            "",
            "class KiwiUserAdmin(UserAdmin):",
            "    list_display = UserAdmin.list_display + (",
            "        \"is_active\",",
            "        \"is_superuser\",",
            "        \"date_joined\",",
            "        \"last_login\",",
            "    )",
            "    ordering = [\"-pk\"]  # same as -date_joined",
            "",
            "    # override standard form and make the email address unique",
            "    # even when adding users via admin panel",
            "    form = MyUserChangeForm",
            "",
            "    def has_view_permission(self, request, obj=None):",
            "        return _modifying_myself(",
            "            request, getattr(obj, \"pk\", 0)",
            "        ) or super().has_view_permission(request, obj)",
            "",
            "    def has_change_permission(self, request, obj=None):",
            "        return _modifying_myself(",
            "            request, getattr(obj, \"pk\", 0)",
            "        ) or super().has_change_permission(request, obj)",
            "",
            "    def has_delete_permission(self, request, obj=None):",
            "        return _modifying_myself(",
            "            request, getattr(obj, \"pk\", 0)",
            "        ) or super().has_delete_permission(request, obj)",
            "",
            "    # pylint: disable=too-many-arguments",
            "    def render_change_form(",
            "        self, request, context, add=False, change=False, form_url=\"\", obj=None",
            "    ):",
            "        if not self.has_change_permission(request, obj):",
            "            context.update(",
            "                {",
            "                    \"show_save\": False,",
            "                    \"show_save_and_continue\": False,",
            "                }",
            "            )",
            "        context.update(",
            "            {",
            "                \"show_save_and_add_another\": self.has_add_permission(request),",
            "            }",
            "        )",
            "        return super().render_change_form(",
            "            request, context, add=add, change=change, form_url=form_url, obj=obj",
            "        )",
            "",
            "    def get_readonly_fields(self, request, obj=None):",
            "        # adding new user",
            "        if not obj:",
            "            return super().get_readonly_fields(request, obj)",
            "",
            "        readonly_fields = [",
            "            \"username\",",
            "            \"last_login\",",
            "            \"date_joined\",",
            "        ]",
            "",
            "        # only other superusers can set the is_superuser flag",
            "        if not request.user.is_superuser:",
            "            readonly_fields.append(\"is_superuser\")",
            "",
            "        # if you have explicit change_user permission you can modify these fields",
            "        # however users are not able to give themselves elevated permissions",
            "        if not self.has_change_permission(request, None):",
            "            readonly_fields.extend(",
            "                [",
            "                    \"is_staff\",",
            "                    \"is_active\",",
            "                    \"groups\",",
            "                    \"user_permissions\",",
            "                ]",
            "            )",
            "",
            "            # lastly users can't modify others unless they have the expolicit permission",
            "            if not _modifying_myself(request, obj.pk):",
            "                readonly_fields.extend([\"first_name\", \"last_name\", \"email\"])",
            "",
            "        return readonly_fields",
            "",
            "    def get_fieldsets(self, request, obj=None):",
            "        # adding new account b/c we have permissions",
            "        if not obj and self.has_add_permission(request):",
            "            return super().get_fieldsets(request, obj)",
            "",
            "        first_fieldset_fields = (\"username\",)",
            "        if obj and _modifying_myself(request, obj.pk):",
            "            first_fieldset_fields += (\"password\",)",
            "",
            "        remaining_fieldsets = (",
            "            (_(\"Personal info\"), {\"fields\": (\"first_name\", \"last_name\", \"email\")}),",
            "            (",
            "                _(\"Permissions\"),",
            "                {",
            "                    \"fields\": (",
            "                        \"is_active\",",
            "                        \"is_staff\",",
            "                        \"is_superuser\",",
            "                        \"groups\",",
            "                        \"user_permissions\",",
            "                    )",
            "                },",
            "            ),",
            "        )",
            "",
            "        if request.user.is_superuser:",
            "            field_sets = super().get_fieldsets(request, obj)",
            "            if field_sets[0][0] is None and \"password\" in field_sets[0][1][\"fields\"]:",
            "                remaining_fieldsets = field_sets[1:]",
            "",
            "        return ((None, {\"fields\": first_fieldset_fields}),) + remaining_fieldsets",
            "",
            "    @sensitive_post_parameters_m",
            "    def user_change_password(",
            "        self, request, id, form_url=\"\"",
            "    ):  # pylint: disable=redefined-builtin",
            "        if _modifying_myself(request, id):",
            "            return HttpResponseRedirect(reverse(\"admin:password_change\"))",
            "",
            "        raise PermissionDenied",
            "",
            "    @admin.options.csrf_protect_m",
            "    def delete_view(self, request, object_id, extra_context=None):",
            "        user = User.objects.get(pk=object_id)",
            "        # check whether the last superuser is being deleted",
            "        if user.is_superuser and User.objects.filter(is_superuser=True).count() == 1:",
            "            messages.add_message(",
            "                request,",
            "                messages.ERROR,",
            "                _(\"This is the last superuser, it cannot be deleted!\"),",
            "            )",
            "            return HttpResponseRedirect(",
            "                reverse(\"admin:auth_user_change\", args=[user.pk])",
            "            )",
            "",
            "        if not _modifying_myself(request, object_id):",
            "            return super().delete_view(request, object_id, extra_context)",
            "",
            "        # allow deletion of the user own account",
            "        permission = Permission.objects.get(",
            "            content_type__app_label=\"auth\", codename=\"delete_user\"",
            "        )",
            "        try:",
            "            request.user.user_permissions.add(permission)",
            "            return super().delete_view(request, object_id, extra_context)",
            "        finally:",
            "            request.user.user_permissions.remove(permission)",
            "",
            "    def response_delete(self, request, obj_display, obj_id):",
            "        result = super().response_delete(request, obj_display, obj_id)",
            "",
            "        if not _modifying_myself(request, obj_id):",
            "            return result",
            "",
            "        # user doesn't exist anymore so go to the login page",
            "        return HttpResponseRedirect(reverse(\"tcms-login\"))",
            "",
            "    def delete_model(self, request, obj):",
            "        delete_user(obj)",
            "",
            "",
            "class KiwiGroupAdmin(GroupAdmin):",
            "    form = GroupAdminForm",
            "",
            "    def has_delete_permission(self, request, obj=None):",
            "        if obj and obj.name in [\"Tester\", \"Administrator\"]:",
            "            return False",
            "        return super().has_delete_permission(request, obj)",
            "",
            "    def get_fields(self, request, obj=None):",
            "        fields = super().get_fields(request, obj=obj)",
            "        name_index = fields.index(\"name\")",
            "",
            "        # make sure Name is always the first field",
            "        if name_index > 0:",
            "            del fields[name_index]",
            "            fields.insert(0, \"name\")",
            "",
            "        return fields",
            "",
            "    def get_readonly_fields(self, request, obj=None):",
            "        readonly_fields = super().get_readonly_fields(request, obj)",
            "",
            "        if obj and obj.name in [\"Tester\", \"Administrator\"]:",
            "            readonly_fields += (\"name\",)",
            "",
            "        return readonly_fields",
            "",
            "",
            "# user admin extended functionality",
            "admin.site.unregister(User)",
            "admin.site.register(User, KiwiUserAdmin)",
            "admin.site.unregister(Group)",
            "admin.site.register(Group, KiwiGroupAdmin)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "from django import forms",
            "from django.contrib import admin, messages",
            "from django.contrib.admin.widgets import FilteredSelectMultiple",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.auth.admin import GroupAdmin, UserAdmin, sensitive_post_parameters_m",
            "from django.contrib.auth.forms import UserChangeForm",
            "from django.contrib.auth.models import Group, Permission",
            "from django.core.exceptions import PermissionDenied",
            "from django.http import HttpResponseRedirect",
            "from django.urls import reverse",
            "from django.utils.translation import gettext_lazy as _",
            "",
            "from tcms.utils.user import delete_user",
            "",
            "User = get_user_model()  # pylint: disable=invalid-name",
            "",
            "",
            "class MyUserChangeForm(UserChangeForm):",
            "    \"\"\"",
            "    Enforces unique user emails.",
            "    \"\"\"",
            "",
            "    email = forms.EmailField(required=True)",
            "",
            "    def clean_email(self):",
            "        query_set = User.objects.filter(email=self.cleaned_data[\"email\"])",
            "        if self.instance:",
            "            query_set = query_set.exclude(pk=self.instance.pk)",
            "        if query_set.count():",
            "            raise forms.ValidationError(_(\"This email address is already in use\"))",
            "",
            "        return self.cleaned_data[\"email\"]",
            "",
            "",
            "def _modifying_myself(request, object_id):",
            "    return request.user.pk == int(object_id)",
            "",
            "",
            "class GroupAdminForm(forms.ModelForm):",
            "    class Meta:",
            "        model = Group",
            "        fields = [\"name\", \"permissions\"]",
            "",
            "    users = forms.ModelMultipleChoiceField(",
            "        queryset=User.objects.all(),",
            "        required=False,",
            "        widget=FilteredSelectMultiple(\"users\", False),",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.fields[\"users\"].label = _(\"Users\")",
            "        if self.instance.pk:",
            "            self.fields[\"users\"].initial = self.instance.user_set.all()",
            "",
            "    def save(self, commit=True):",
            "        instance = super().save(commit=commit)",
            "        instance.save()",
            "",
            "        self.instance.user_set.set(self.cleaned_data[\"users\"])",
            "        self.save_m2m()",
            "",
            "        return instance",
            "",
            "",
            "class KiwiUserAdmin(UserAdmin):",
            "    list_display = UserAdmin.list_display + (",
            "        \"is_active\",",
            "        \"is_superuser\",",
            "        \"date_joined\",",
            "        \"last_login\",",
            "    )",
            "    ordering = [\"-pk\"]  # same as -date_joined",
            "",
            "    # override standard form and make the email address unique",
            "    # even when adding users via admin panel",
            "    form = MyUserChangeForm",
            "",
            "    def has_view_permission(self, request, obj=None):",
            "        return _modifying_myself(",
            "            request, getattr(obj, \"pk\", 0)",
            "        ) or super().has_view_permission(request, obj)",
            "",
            "    def has_change_permission(self, request, obj=None):",
            "        return _modifying_myself(",
            "            request, getattr(obj, \"pk\", 0)",
            "        ) or super().has_change_permission(request, obj)",
            "",
            "    def has_delete_permission(self, request, obj=None):",
            "        return _modifying_myself(",
            "            request, getattr(obj, \"pk\", 0)",
            "        ) or super().has_delete_permission(request, obj)",
            "",
            "    # pylint: disable=too-many-arguments",
            "    def render_change_form(",
            "        self, request, context, add=False, change=False, form_url=\"\", obj=None",
            "    ):",
            "        if not self.has_change_permission(request, obj):",
            "            context.update(",
            "                {",
            "                    \"show_save\": False,",
            "                    \"show_save_and_continue\": False,",
            "                }",
            "            )",
            "        context.update(",
            "            {",
            "                \"show_save_and_add_another\": self.has_add_permission(request),",
            "            }",
            "        )",
            "        return super().render_change_form(",
            "            request, context, add=add, change=change, form_url=form_url, obj=obj",
            "        )",
            "",
            "    def get_readonly_fields(self, request, obj=None):",
            "        # adding new user",
            "        if not obj:",
            "            return super().get_readonly_fields(request, obj)",
            "",
            "        readonly_fields = [",
            "            \"username\",",
            "            \"last_login\",",
            "            \"date_joined\",",
            "            \"email\",",
            "        ]",
            "",
            "        # only other superusers can set the is_superuser flag",
            "        if not request.user.is_superuser:",
            "            readonly_fields.append(\"is_superuser\")",
            "",
            "        # if you have explicit change_user permission you can modify these fields",
            "        # however users are not able to give themselves elevated permissions",
            "        if not self.has_change_permission(request, None):",
            "            readonly_fields.extend(",
            "                [",
            "                    \"is_staff\",",
            "                    \"is_active\",",
            "                    \"groups\",",
            "                    \"user_permissions\",",
            "                ]",
            "            )",
            "",
            "            # lastly users can't modify others unless they have the expolicit permission",
            "            if not _modifying_myself(request, obj.pk):",
            "                readonly_fields.extend([\"first_name\", \"last_name\", \"email\"])",
            "",
            "        return readonly_fields",
            "",
            "    def get_fieldsets(self, request, obj=None):",
            "        # adding new account b/c we have permissions",
            "        if not obj and self.has_add_permission(request):",
            "            return super().get_fieldsets(request, obj)",
            "",
            "        first_fieldset_fields = (\"username\",)",
            "        if obj and _modifying_myself(request, obj.pk):",
            "            first_fieldset_fields += (\"password\",)",
            "",
            "        remaining_fieldsets = (",
            "            (_(\"Personal info\"), {\"fields\": (\"first_name\", \"last_name\", \"email\")}),",
            "            (",
            "                _(\"Permissions\"),",
            "                {",
            "                    \"fields\": (",
            "                        \"is_active\",",
            "                        \"is_staff\",",
            "                        \"is_superuser\",",
            "                        \"groups\",",
            "                        \"user_permissions\",",
            "                    )",
            "                },",
            "            ),",
            "        )",
            "",
            "        if request.user.is_superuser:",
            "            field_sets = super().get_fieldsets(request, obj)",
            "            if field_sets[0][0] is None and \"password\" in field_sets[0][1][\"fields\"]:",
            "                remaining_fieldsets = field_sets[1:]",
            "",
            "        return ((None, {\"fields\": first_fieldset_fields}),) + remaining_fieldsets",
            "",
            "    @sensitive_post_parameters_m",
            "    def user_change_password(",
            "        self, request, id, form_url=\"\"",
            "    ):  # pylint: disable=redefined-builtin",
            "        if _modifying_myself(request, id):",
            "            return HttpResponseRedirect(reverse(\"admin:password_change\"))",
            "",
            "        raise PermissionDenied",
            "",
            "    @admin.options.csrf_protect_m",
            "    def delete_view(self, request, object_id, extra_context=None):",
            "        user = User.objects.get(pk=object_id)",
            "        # check whether the last superuser is being deleted",
            "        if user.is_superuser and User.objects.filter(is_superuser=True).count() == 1:",
            "            messages.add_message(",
            "                request,",
            "                messages.ERROR,",
            "                _(\"This is the last superuser, it cannot be deleted!\"),",
            "            )",
            "            return HttpResponseRedirect(",
            "                reverse(\"admin:auth_user_change\", args=[user.pk])",
            "            )",
            "",
            "        if not _modifying_myself(request, object_id):",
            "            return super().delete_view(request, object_id, extra_context)",
            "",
            "        # allow deletion of the user own account",
            "        permission = Permission.objects.get(",
            "            content_type__app_label=\"auth\", codename=\"delete_user\"",
            "        )",
            "        try:",
            "            request.user.user_permissions.add(permission)",
            "            return super().delete_view(request, object_id, extra_context)",
            "        finally:",
            "            request.user.user_permissions.remove(permission)",
            "",
            "    def response_delete(self, request, obj_display, obj_id):",
            "        result = super().response_delete(request, obj_display, obj_id)",
            "",
            "        if not _modifying_myself(request, obj_id):",
            "            return result",
            "",
            "        # user doesn't exist anymore so go to the login page",
            "        return HttpResponseRedirect(reverse(\"tcms-login\"))",
            "",
            "    def delete_model(self, request, obj):",
            "        delete_user(obj)",
            "",
            "",
            "class KiwiGroupAdmin(GroupAdmin):",
            "    form = GroupAdminForm",
            "",
            "    def has_delete_permission(self, request, obj=None):",
            "        if obj and obj.name in [\"Tester\", \"Administrator\"]:",
            "            return False",
            "        return super().has_delete_permission(request, obj)",
            "",
            "    def get_fields(self, request, obj=None):",
            "        fields = super().get_fields(request, obj=obj)",
            "        name_index = fields.index(\"name\")",
            "",
            "        # make sure Name is always the first field",
            "        if name_index > 0:",
            "            del fields[name_index]",
            "            fields.insert(0, \"name\")",
            "",
            "        return fields",
            "",
            "    def get_readonly_fields(self, request, obj=None):",
            "        readonly_fields = super().get_readonly_fields(request, obj)",
            "",
            "        if obj and obj.name in [\"Tester\", \"Administrator\"]:",
            "            readonly_fields += (\"name\",)",
            "",
            "        return readonly_fields",
            "",
            "",
            "# user admin extended functionality",
            "admin.site.unregister(User)",
            "admin.site.register(User, KiwiUserAdmin)",
            "admin.site.unregister(Group)",
            "admin.site.register(Group, KiwiGroupAdmin)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "openapi_python_client",
            "tcms.kiwi_auth.admin.KiwiUserAdmin.get_readonly_fields.readonly_fields"
        ]
    },
    "tcms/kiwi_auth/tests/test_admin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")"
            },
            "1": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)"
            },
            "2": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # 3 readonly fields"
            },
            "4": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(response_str.count(\"grp-readonly\"), 3)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        # 4 readonly fields"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        self.assertEqual(response_str.count(\"grp-readonly\"), 4)"
            },
            "7": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         # these fields can be edited"
            },
            "9": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         self.assertContains(response, \"id_first_name\")"
            },
            "10": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         self.assertContains(response, \"id_last_name\")"
            },
            "11": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertContains(response, \"id_email\")"
            },
            "12": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         self.assertContains(response, \"id_is_active\")"
            },
            "13": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         self.assertContains(response, \"id_is_staff\")"
            },
            "14": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         self.assertContains(response, \"id_is_superuser\")"
            },
            "15": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "                 \"first_name\": \"Changed by admin\","
            },
            "16": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "                 # required fields below"
            },
            "17": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "                 \"username\": self.tester.username,"
            },
            "18": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"email\": self.tester.email,"
            },
            "19": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "                 \"date_joined_0\": \"2018-09-03\","
            },
            "20": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "                 \"date_joined_1\": \"13:16:25\","
            },
            "21": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "             },"
            },
            "22": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")"
            },
            "23": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "         response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)"
            },
            "24": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # 2 readonly fields"
            },
            "26": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(response_str.count(\"grp-readonly\"), 2)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+        # 3 readonly fields"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+        self.assertEqual(response_str.count(\"grp-readonly\"), 3)"
            },
            "29": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 292,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "         # these fields can be edited"
            },
            "31": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "         self.assertContains(response, \"id_first_name\")"
            },
            "32": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         self.assertContains(response, \"id_last_name\")"
            },
            "33": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertContains(response, \"id_email\")"
            },
            "34": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "         self.assertContains(response, \"id_is_active\")"
            },
            "35": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         self.assertContains(response, \"id_is_staff\")"
            },
            "36": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "         self.assertContains(response, \"id_groups\")"
            },
            "37": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "                 \"first_name\": \"Changed by moderator\","
            },
            "38": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "                 # required fields below"
            },
            "39": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "                 \"username\": self.tester.username,"
            },
            "40": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"email\": self.tester.email,"
            },
            "41": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "                 \"date_joined_0\": \"2018-09-03\","
            },
            "42": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "                 \"date_joined_1\": \"13:16:25\","
            },
            "43": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "             },"
            },
            "44": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "         # only 1 hidden field for csrf"
            },
            "45": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "         self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')"
            },
            "46": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 390,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # 6 readonly fields"
            },
            "48": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(response_str.count(\"grp-readonly\"), 6)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+        # 7 readonly fields"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+        self.assertEqual(response_str.count(\"grp-readonly\"), 7)"
            },
            "51": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 393,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "         # only these fields can be edited"
            },
            "53": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "         self.assertContains(response, \"id_first_name\")"
            },
            "54": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "         self.assertContains(response, \"id_last_name\")"
            },
            "55": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertContains(response, \"id_email\")"
            },
            "56": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 397,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "         # Has Delete button"
            },
            "58": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "         self.assertContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")"
            }
        },
        "frontPatchFile": [
            "# pylint: disable=invalid-name",
            "import html",
            "from http import HTTPStatus",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.http import HttpResponseForbidden",
            "from django.urls import reverse",
            "from django.utils.translation import gettext_lazy as _",
            "",
            "from tcms.kiwi_auth.admin import Group",
            "from tcms.tests import LoggedInTestCase, user_should_have_perm",
            "from tcms.tests.factories import GroupFactory, UserFactory",
            "",
            "from . import __FOR_TESTING__",
            "",
            "",
            "class TestUserAdmin(LoggedInTestCase):  # pylint: disable=too-many-public-methods",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Note: by default the logged-in user is self.tester",
            "        # who is not given any permissions",
            "        super().setUpTestData()",
            "",
            "        cls.admin = UserFactory(username=\"admin\")",
            "        cls.admin.is_superuser = True",
            "        cls.admin.set_password(\"admin-password\")",
            "        cls.admin.save()",
            "",
            "        cls.admin2 = UserFactory(username=\"admin2\")",
            "        cls.admin2.is_superuser = True",
            "        cls.admin2.set_password(\"admin-password\")",
            "        cls.admin2.save()",
            "",
            "        # moderator is a non-superuser who is granted specific permissions",
            "        cls.moderator = UserFactory(username=\"moderator\")",
            "        cls.moderator.is_superuser = False",
            "        cls.moderator.set_password(\"admin-password\")",
            "        cls.moderator.save()",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        # self.tester doesn't have any permissions",
            "        self.assertEqual(0, self.tester.user_permissions.count())",
            "",
            "    def test_superuser_can_view_list_of_all_users(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(\"/admin/auth/user/\")",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertContains(response, self.admin.username)",
            "        self.assertContains(response, self.admin2.username)",
            "        self.assertContains(response, self.tester.username)",
            "        self.assertContains(response, self.moderator.username)",
            "",
            "    def test_superuser_can_view_user_profile(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        self.assertContains(response, self.tester.username)",
            "",
            "    def test_superuser_can_add_users(self):",
            "        # test for https://github.com/kiwitcms/Kiwi/issues/642",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(\"/admin/auth/user/add/\")",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        response = self.client.post(",
            "            \"/admin/auth/user/add/\",",
            "            {",
            "                \"username\": \"added-by-admin\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": __FOR_TESTING__,",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertTrue(",
            "            get_user_model().objects.filter(username=\"added-by-admin\").exists()",
            "        )",
            "",
            "    def test_superuser_can_change_other_users(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "",
            "        # 3 readonly fields",
            "        self.assertEqual(response_str.count(\"grp-readonly\"), 3)",
            "",
            "        # these fields can be edited",
            "        self.assertContains(response, \"id_first_name\")",
            "        self.assertContains(response, \"id_last_name\")",
            "        self.assertContains(response, \"id_email\")",
            "        self.assertContains(response, \"id_is_active\")",
            "        self.assertContains(response, \"id_is_staff\")",
            "        self.assertContains(response, \"id_is_superuser\")",
            "        self.assertContains(response, \"id_groups\")",
            "        self.assertContains(response, \"id_user_permissions\")",
            "",
            "        response = self.client.post(",
            "            f\"/admin/auth/user/{self.tester.pk}/change/\",",
            "            {",
            "                \"first_name\": \"Changed by admin\",",
            "                # required fields below",
            "                \"username\": self.tester.username,",
            "                \"email\": self.tester.email,",
            "                \"date_joined_0\": \"2018-09-03\",",
            "                \"date_joined_1\": \"13:16:25\",",
            "            },",
            "            follow=True,",
            "        )",
            "",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        self.tester.refresh_from_db()",
            "        self.assertEqual(self.tester.first_name, \"Changed by admin\")",
            "",
            "    def test_superuser_can_delete_itself(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.admin.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.admin.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertRedirects(response, \"/accounts/login/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.admin.pk).exists())",
            "",
            "    def test_superuser_can_delete_other_user(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertRedirects(response, \"/admin/auth/user/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())",
            "",
            "    def test_superuser_cannot_delete_the_last_superuser(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        # Check that we have more than one superuser",
            "        self.assertGreater(",
            "            get_user_model().objects.filter(is_superuser=True).count(), 1",
            "        )",
            "",
            "        self.client.get(reverse(\"admin:auth_user_delete\", args=[self.admin2.pk]))",
            "        self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.admin2.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        # Check that admin2 is deleted, and we have only one superuser left",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.admin2.pk).exists())",
            "        self.assertEqual(get_user_model().objects.filter(is_superuser=True).count(), 1)",
            "",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.admin.pk]),",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertRedirects(response, f\"/admin/auth/user/{self.admin.pk}/change/\")",
            "",
            "        response_text = html.unescape(",
            "            str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "        )",
            "        self.assertIn(",
            "            str(_(\"This is the last superuser, it cannot be deleted!\")), response_text",
            "        )",
            "        self.assertTrue(get_user_model().objects.filter(pk=self.admin.pk).exists())",
            "",
            "    def test_superuser_can_change_their_password(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/password/\")",
            "        # redirects to change password for themselves",
            "        self.assertRedirects(response, \"/admin/password_change/\")",
            "",
            "    def test_superuser_cant_change_password_for_others(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "    def test_moderator_can_view_list_of_all_users(self):",
            "        user_should_have_perm(self.moderator, \"auth.view_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(\"/admin/auth/user/\")",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertContains(response, self.admin.username)",
            "        self.assertContains(response, self.tester.username)",
            "        self.assertContains(response, self.moderator.username)",
            "",
            "    def test_moderator_can_view_user_profile(self):",
            "        user_should_have_perm(self.moderator, \"auth.view_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        self.assertContains(response, self.tester.username)",
            "",
            "        # some fields are read-only",
            "        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "",
            "        # only 1 hidden field for csrf",
            "        self.assertEqual(response_str.count(\"<input\"), 1)",
            "        self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')",
            "",
            "        # 9 readonly fields",
            "        self.assertEqual(response_str.count(\"grp-readonly\"), 9)",
            "",
            "        # no delete button",
            "        self.assertNotContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")",
            "",
            "        # no save buttons",
            "        self.assertNotContains(response, \"_save\")",
            "        self.assertNotContains(response, \"_addanother\")",
            "        self.assertNotContains(response, \"_continue\")",
            "",
            "    def test_moderator_can_add_users(self):",
            "        user_should_have_perm(self.moderator, \"auth.add_user\")",
            "        user_should_have_perm(self.moderator, \"auth.change_user\")",
            "",
            "        # test for https://github.com/kiwitcms/Kiwi/issues/642",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(\"/admin/auth/user/add/\")",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        # only these fields can be edited",
            "        self.assertContains(response, \"id_username\")",
            "        self.assertContains(response, \"id_password1\")",
            "        self.assertContains(response, \"id_password2\")",
            "",
            "        response = self.client.post(",
            "            \"/admin/auth/user/add/\",",
            "            {",
            "                \"username\": \"added-by-moderator\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": __FOR_TESTING__,",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertTrue(",
            "            get_user_model().objects.filter(username=\"added-by-moderator\").exists()",
            "        )",
            "",
            "    def test_moderator_can_change_other_users(self):",
            "        user_should_have_perm(self.moderator, \"auth.view_user\")",
            "        user_should_have_perm(self.moderator, \"auth.change_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "",
            "        # 2 readonly fields",
            "        self.assertEqual(response_str.count(\"grp-readonly\"), 2)",
            "",
            "        # these fields can be edited",
            "        self.assertContains(response, \"id_first_name\")",
            "        self.assertContains(response, \"id_last_name\")",
            "        self.assertContains(response, \"id_email\")",
            "        self.assertContains(response, \"id_is_active\")",
            "        self.assertContains(response, \"id_is_staff\")",
            "        self.assertContains(response, \"id_groups\")",
            "        self.assertContains(response, \"id_user_permissions\")",
            "",
            "        response = self.client.post(",
            "            f\"/admin/auth/user/{self.tester.pk}/change/\",",
            "            {",
            "                \"first_name\": \"Changed by moderator\",",
            "                # required fields below",
            "                \"username\": self.tester.username,",
            "                \"email\": self.tester.email,",
            "                \"date_joined_0\": \"2018-09-03\",",
            "                \"date_joined_1\": \"13:16:25\",",
            "            },",
            "            follow=True,",
            "        )",
            "",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        self.tester.refresh_from_db()",
            "        self.assertEqual(self.tester.first_name, \"Changed by moderator\")",
            "",
            "    def test_moderator_can_delete_itself(self):",
            "        user_should_have_perm(self.moderator, \"auth.delete_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.moderator.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.moderator.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertRedirects(response, \"/accounts/login/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.moderator.pk).exists())",
            "",
            "    def test_moderator_can_delete_other_user(self):",
            "        user_should_have_perm(self.moderator, \"auth.view_user\")",
            "        user_should_have_perm(self.moderator, \"auth.delete_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        # b/c our test has only view & delete perms",
            "        self.assertRedirects(response, \"/admin/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())",
            "",
            "    def test_moderator_can_change_their_password(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.moderator.pk}/password/\")",
            "        # redirects to change password for themselves",
            "        self.assertRedirects(response, \"/admin/password_change/\")",
            "",
            "    def test_moderator_cant_change_password_for_others(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "    def test_regular_user_cant_view_list_of_all_users(self):",
            "        response = self.client.get(\"/admin/auth/user/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "    def test_regular_user_cant_view_single_profile_without_permission(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/change/\")",
            "        self.assertIsInstance(response, HttpResponseForbidden)",
            "",
            "    def test_regular_user_can_view_themselves(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "",
            "        # only 1 hidden field for csrf",
            "        self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')",
            "",
            "        # 6 readonly fields",
            "        self.assertEqual(response_str.count(\"grp-readonly\"), 6)",
            "",
            "        # only these fields can be edited",
            "        self.assertContains(response, \"id_first_name\")",
            "        self.assertContains(response, \"id_last_name\")",
            "        self.assertContains(response, \"id_email\")",
            "",
            "        # Has Delete button",
            "        self.assertContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")",
            "",
            "        # Has Save buttons",
            "        self.assertContains(response, \"_save\")",
            "        self.assertContains(response, \"_continue\")",
            "        self.assertNotContains(response, \"_addanother\")",
            "",
            "    def test_regular_user_cant_add_users(self):",
            "        response = self.client.get(\"/admin/auth/user/add/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "        response = self.client.post(",
            "            \"/admin/auth/user/add/\",",
            "            {",
            "                \"username\": \"added-by-regular-user\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": __FOR_TESTING__,",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "        self.assertFalse(",
            "            get_user_model().objects.filter(username=\"added-by-regular-user\").exists()",
            "        )",
            "",
            "    def test_regular_user_cant_change_other_users(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/change/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "        response = self.client.post(",
            "            f\"/admin/auth/user/{self.admin.pk}/change/\",",
            "            {",
            "                \"first_name\": \"Changed by regular user\",",
            "                # required fields below",
            "                \"username\": self.admin.username,",
            "                \"email\": self.admin.email,",
            "                \"date_joined_0\": \"2018-09-03\",",
            "                \"date_joined_1\": \"13:16:25\",",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "        self.admin.refresh_from_db()",
            "        self.assertNotEqual(self.admin.first_name, \"Changed by regular user\")",
            "",
            "    def test_regular_user_can_change_themselves(self):",
            "        response = self.client.post(",
            "            f\"/admin/auth/user/{self.tester.pk}/change/\",",
            "            {",
            "                \"first_name\": \"Changed by myself\",",
            "                # required fields below",
            "                \"username\": self.tester.username,",
            "                \"email\": self.tester.email,",
            "                \"date_joined_0\": \"2018-09-03\",",
            "                \"date_joined_1\": \"13:16:25\",",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        self.tester.refresh_from_db()",
            "        self.assertEqual(self.tester.first_name, \"Changed by myself\")",
            "",
            "    def test_regular_user_cant_delete_others(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/delete/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "    def test_regular_user_can_delete_myself(self):",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertRedirects(response, \"/accounts/login/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())",
            "",
            "    def test_regular_user_can_change_their_password(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")",
            "        # redirects to change password for themselves",
            "        self.assertRedirects(response, \"/admin/password_change/\")",
            "",
            "    def test_regular_user_cant_change_password_for_others(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.moderator.pk}/password/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "",
            "class TestGroupAdmin(LoggedInTestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        super().setUpTestData()",
            "",
            "        cls.tester.is_superuser = True",
            "        cls.tester.save()",
            "",
            "        cls.group = GroupFactory(name=\"NewGroupName\")",
            "        cls.group.save()",
            "        cls.defaultGroups = Group.objects.filter(name__in=[\"Administrator\", \"Tester\"])",
            "",
            "    def test_should_not_be_allowed_to_change_groups_with_default_names(self):",
            "        for group in self.defaultGroups:",
            "            response = self.client.get(",
            "                reverse(\"admin:auth_group_change\", args=[group.id])",
            "            )",
            "            self.assertNotContains(",
            "                response,",
            "                f'<input type=\"text\" name=\"name\" value=\"{group.name}\" class=\"vTextField\"'",
            "                ' maxlength=\"150\" required=\"\" id=\"id_name\">',",
            "            )",
            "            self.assertContains(",
            "                response, f'<div class=\"grp-readonly\">{group.name}</div>'",
            "            )",
            "",
            "    def test_should_not_be_allowed_to_delete_default_groups(self):",
            "        for group in self.defaultGroups:",
            "            response = self.client.get(",
            "                reverse(\"admin:auth_group_change\", args=[group.id])",
            "            )",
            "            _expected_url = reverse(\"admin:auth_group_delete\", args=[self.group.id])",
            "            _delete = _(\"Delete\")",
            "            self.assertNotContains(",
            "                response,",
            "                f'<a href=\"{_expected_url}\" class=\"grp-button grp-delete-link\">{_delete}</a>',",
            "            )",
            "",
            "    def test_should_be_allowed_to_create_new_group(self):",
            "        response = self.client.get(reverse(\"admin:auth_group_add\"))",
            "        _add_group = _(\"Add %s\") % _(\"group\")",
            "        self.assertContains(response, f\"<h1>{_add_group}</h1>\")",
            "        self.assertContains(",
            "            response,",
            "            '<input type=\"text\" name=\"name\" class=\"vTextField\" '",
            "            'maxlength=\"150\" required id=\"id_name\">',",
            "        )",
            "",
            "        # check for the user widget",
            "        self.assertContains(",
            "            response,",
            "            '<select name=\"users\" id=\"id_users\" multiple '",
            "            'class=\"selectfilter\" data-field-name=\"users\" data-is-stacked=\"0\">',",
            "        )",
            "        _label = _(\"Users\")",
            "        self.assertContains(response, f'<label for=\"id_users\">{_label}')",
            "",
            "    def test_should_be_able_to_delete_a_non_default_group(self):",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_group_delete\", args=[self.group.id]), follow=True",
            "        )",
            "        _are_you_sure = _(\"Are you sure?\")",
            "        self.assertContains(response, f\"<h1>{_are_you_sure}</h1>\")",
            "",
            "    def test_should_be_able_to_edit_a_non_default_group(self):",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_group_change\", args=[self.group.id])",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            f'<input type=\"text\" name=\"name\" value=\"{self.group.name}\" class=\"vTextField\"'",
            "            ' maxlength=\"150\" required id=\"id_name\">',",
            "        )",
            "",
            "    def test_should_be_allowed_to_create_new_group_with_added_user(self):",
            "        self.assertFalse(self.tester.groups.filter(name=self.group.name).exists())",
            "",
            "        group_name = \"TestGroupName\"",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_group_add\"),",
            "            {\"name\": group_name, \"users\": [self.tester.id]},",
            "            follow=True,",
            "        )",
            "",
            "        group = self.tester.groups.get(name=group_name)",
            "",
            "        self.assertIsNotNone(group)",
            "        self.assertContains(response, group_name)",
            "        group_url = reverse(\"admin:auth_group_change\", args=[group.pk])",
            "        self.assertContains(",
            "            response,",
            "            f'<a href=\"{group_url}\">{group_name}</a>',",
            "        )",
            "",
            "    def test_should_be_able_to_add_user_while_editing_a_group(self):",
            "        self.assertFalse(self.tester.groups.filter(name=self.group.name).exists())",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_group_change\", args=[self.group.id]),",
            "            {\"name\": self.group.name, \"users\": [self.tester.id], \"_continue\": True},",
            "            follow=True,",
            "        )",
            "",
            "        self.assertContains(",
            "            response,",
            "            f'<option value=\"{self.tester.pk}\" selected>{self.tester.username}</option>',",
            "        )",
            "        self.assertTrue(self.tester.groups.filter(name=self.group.name).exists())"
        ],
        "afterPatchFile": [
            "# pylint: disable=invalid-name",
            "import html",
            "from http import HTTPStatus",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.http import HttpResponseForbidden",
            "from django.urls import reverse",
            "from django.utils.translation import gettext_lazy as _",
            "",
            "from tcms.kiwi_auth.admin import Group",
            "from tcms.tests import LoggedInTestCase, user_should_have_perm",
            "from tcms.tests.factories import GroupFactory, UserFactory",
            "",
            "from . import __FOR_TESTING__",
            "",
            "",
            "class TestUserAdmin(LoggedInTestCase):  # pylint: disable=too-many-public-methods",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Note: by default the logged-in user is self.tester",
            "        # who is not given any permissions",
            "        super().setUpTestData()",
            "",
            "        cls.admin = UserFactory(username=\"admin\")",
            "        cls.admin.is_superuser = True",
            "        cls.admin.set_password(\"admin-password\")",
            "        cls.admin.save()",
            "",
            "        cls.admin2 = UserFactory(username=\"admin2\")",
            "        cls.admin2.is_superuser = True",
            "        cls.admin2.set_password(\"admin-password\")",
            "        cls.admin2.save()",
            "",
            "        # moderator is a non-superuser who is granted specific permissions",
            "        cls.moderator = UserFactory(username=\"moderator\")",
            "        cls.moderator.is_superuser = False",
            "        cls.moderator.set_password(\"admin-password\")",
            "        cls.moderator.save()",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        # self.tester doesn't have any permissions",
            "        self.assertEqual(0, self.tester.user_permissions.count())",
            "",
            "    def test_superuser_can_view_list_of_all_users(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(\"/admin/auth/user/\")",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertContains(response, self.admin.username)",
            "        self.assertContains(response, self.admin2.username)",
            "        self.assertContains(response, self.tester.username)",
            "        self.assertContains(response, self.moderator.username)",
            "",
            "    def test_superuser_can_view_user_profile(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        self.assertContains(response, self.tester.username)",
            "",
            "    def test_superuser_can_add_users(self):",
            "        # test for https://github.com/kiwitcms/Kiwi/issues/642",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(\"/admin/auth/user/add/\")",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        response = self.client.post(",
            "            \"/admin/auth/user/add/\",",
            "            {",
            "                \"username\": \"added-by-admin\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": __FOR_TESTING__,",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertTrue(",
            "            get_user_model().objects.filter(username=\"added-by-admin\").exists()",
            "        )",
            "",
            "    def test_superuser_can_change_other_users(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "",
            "        # 4 readonly fields",
            "        self.assertEqual(response_str.count(\"grp-readonly\"), 4)",
            "",
            "        # these fields can be edited",
            "        self.assertContains(response, \"id_first_name\")",
            "        self.assertContains(response, \"id_last_name\")",
            "        self.assertContains(response, \"id_is_active\")",
            "        self.assertContains(response, \"id_is_staff\")",
            "        self.assertContains(response, \"id_is_superuser\")",
            "        self.assertContains(response, \"id_groups\")",
            "        self.assertContains(response, \"id_user_permissions\")",
            "",
            "        response = self.client.post(",
            "            f\"/admin/auth/user/{self.tester.pk}/change/\",",
            "            {",
            "                \"first_name\": \"Changed by admin\",",
            "                # required fields below",
            "                \"username\": self.tester.username,",
            "                \"date_joined_0\": \"2018-09-03\",",
            "                \"date_joined_1\": \"13:16:25\",",
            "            },",
            "            follow=True,",
            "        )",
            "",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        self.tester.refresh_from_db()",
            "        self.assertEqual(self.tester.first_name, \"Changed by admin\")",
            "",
            "    def test_superuser_can_delete_itself(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.admin.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.admin.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertRedirects(response, \"/accounts/login/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.admin.pk).exists())",
            "",
            "    def test_superuser_can_delete_other_user(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertRedirects(response, \"/admin/auth/user/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())",
            "",
            "    def test_superuser_cannot_delete_the_last_superuser(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "        # Check that we have more than one superuser",
            "        self.assertGreater(",
            "            get_user_model().objects.filter(is_superuser=True).count(), 1",
            "        )",
            "",
            "        self.client.get(reverse(\"admin:auth_user_delete\", args=[self.admin2.pk]))",
            "        self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.admin2.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        # Check that admin2 is deleted, and we have only one superuser left",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.admin2.pk).exists())",
            "        self.assertEqual(get_user_model().objects.filter(is_superuser=True).count(), 1)",
            "",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.admin.pk]),",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertRedirects(response, f\"/admin/auth/user/{self.admin.pk}/change/\")",
            "",
            "        response_text = html.unescape(",
            "            str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "        )",
            "        self.assertIn(",
            "            str(_(\"This is the last superuser, it cannot be deleted!\")), response_text",
            "        )",
            "        self.assertTrue(get_user_model().objects.filter(pk=self.admin.pk).exists())",
            "",
            "    def test_superuser_can_change_their_password(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/password/\")",
            "        # redirects to change password for themselves",
            "        self.assertRedirects(response, \"/admin/password_change/\")",
            "",
            "    def test_superuser_cant_change_password_for_others(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.admin.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "    def test_moderator_can_view_list_of_all_users(self):",
            "        user_should_have_perm(self.moderator, \"auth.view_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(\"/admin/auth/user/\")",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertContains(response, self.admin.username)",
            "        self.assertContains(response, self.tester.username)",
            "        self.assertContains(response, self.moderator.username)",
            "",
            "    def test_moderator_can_view_user_profile(self):",
            "        user_should_have_perm(self.moderator, \"auth.view_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        self.assertContains(response, self.tester.username)",
            "",
            "        # some fields are read-only",
            "        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "",
            "        # only 1 hidden field for csrf",
            "        self.assertEqual(response_str.count(\"<input\"), 1)",
            "        self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')",
            "",
            "        # 9 readonly fields",
            "        self.assertEqual(response_str.count(\"grp-readonly\"), 9)",
            "",
            "        # no delete button",
            "        self.assertNotContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")",
            "",
            "        # no save buttons",
            "        self.assertNotContains(response, \"_save\")",
            "        self.assertNotContains(response, \"_addanother\")",
            "        self.assertNotContains(response, \"_continue\")",
            "",
            "    def test_moderator_can_add_users(self):",
            "        user_should_have_perm(self.moderator, \"auth.add_user\")",
            "        user_should_have_perm(self.moderator, \"auth.change_user\")",
            "",
            "        # test for https://github.com/kiwitcms/Kiwi/issues/642",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(\"/admin/auth/user/add/\")",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        # only these fields can be edited",
            "        self.assertContains(response, \"id_username\")",
            "        self.assertContains(response, \"id_password1\")",
            "        self.assertContains(response, \"id_password2\")",
            "",
            "        response = self.client.post(",
            "            \"/admin/auth/user/add/\",",
            "            {",
            "                \"username\": \"added-by-moderator\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": __FOR_TESTING__,",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        self.assertTrue(",
            "            get_user_model().objects.filter(username=\"added-by-moderator\").exists()",
            "        )",
            "",
            "    def test_moderator_can_change_other_users(self):",
            "        user_should_have_perm(self.moderator, \"auth.view_user\")",
            "        user_should_have_perm(self.moderator, \"auth.change_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "",
            "        # 3 readonly fields",
            "        self.assertEqual(response_str.count(\"grp-readonly\"), 3)",
            "",
            "        # these fields can be edited",
            "        self.assertContains(response, \"id_first_name\")",
            "        self.assertContains(response, \"id_last_name\")",
            "        self.assertContains(response, \"id_is_active\")",
            "        self.assertContains(response, \"id_is_staff\")",
            "        self.assertContains(response, \"id_groups\")",
            "        self.assertContains(response, \"id_user_permissions\")",
            "",
            "        response = self.client.post(",
            "            f\"/admin/auth/user/{self.tester.pk}/change/\",",
            "            {",
            "                \"first_name\": \"Changed by moderator\",",
            "                # required fields below",
            "                \"username\": self.tester.username,",
            "                \"date_joined_0\": \"2018-09-03\",",
            "                \"date_joined_1\": \"13:16:25\",",
            "            },",
            "            follow=True,",
            "        )",
            "",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        self.tester.refresh_from_db()",
            "        self.assertEqual(self.tester.first_name, \"Changed by moderator\")",
            "",
            "    def test_moderator_can_delete_itself(self):",
            "        user_should_have_perm(self.moderator, \"auth.delete_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.moderator.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.moderator.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertRedirects(response, \"/accounts/login/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.moderator.pk).exists())",
            "",
            "    def test_moderator_can_delete_other_user(self):",
            "        user_should_have_perm(self.moderator, \"auth.view_user\")",
            "        user_should_have_perm(self.moderator, \"auth.delete_user\")",
            "",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "        # b/c our test has only view & delete perms",
            "        self.assertRedirects(response, \"/admin/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())",
            "",
            "    def test_moderator_can_change_their_password(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.moderator.pk}/password/\")",
            "        # redirects to change password for themselves",
            "        self.assertRedirects(response, \"/admin/password_change/\")",
            "",
            "    def test_moderator_cant_change_password_for_others(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.moderator.username, password=\"admin-password\"",
            "        )",
            "",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "    def test_regular_user_cant_view_list_of_all_users(self):",
            "        response = self.client.get(\"/admin/auth/user/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "    def test_regular_user_cant_view_single_profile_without_permission(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/change/\")",
            "        self.assertIsInstance(response, HttpResponseForbidden)",
            "",
            "    def test_regular_user_can_view_themselves(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/change/\")",
            "        response_str = str(response.content, encoding=settings.DEFAULT_CHARSET)",
            "",
            "        # only 1 hidden field for csrf",
            "        self.assertContains(response, '<input type=\"hidden\" name=\"csrfmiddlewaretoken\"')",
            "",
            "        # 7 readonly fields",
            "        self.assertEqual(response_str.count(\"grp-readonly\"), 7)",
            "",
            "        # only these fields can be edited",
            "        self.assertContains(response, \"id_first_name\")",
            "        self.assertContains(response, \"id_last_name\")",
            "",
            "        # Has Delete button",
            "        self.assertContains(response, f\"/admin/auth/user/{self.tester.pk}/delete/\")",
            "",
            "        # Has Save buttons",
            "        self.assertContains(response, \"_save\")",
            "        self.assertContains(response, \"_continue\")",
            "        self.assertNotContains(response, \"_addanother\")",
            "",
            "    def test_regular_user_cant_add_users(self):",
            "        response = self.client.get(\"/admin/auth/user/add/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "        response = self.client.post(",
            "            \"/admin/auth/user/add/\",",
            "            {",
            "                \"username\": \"added-by-regular-user\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": __FOR_TESTING__,",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "        self.assertFalse(",
            "            get_user_model().objects.filter(username=\"added-by-regular-user\").exists()",
            "        )",
            "",
            "    def test_regular_user_cant_change_other_users(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/change/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "        response = self.client.post(",
            "            f\"/admin/auth/user/{self.admin.pk}/change/\",",
            "            {",
            "                \"first_name\": \"Changed by regular user\",",
            "                # required fields below",
            "                \"username\": self.admin.username,",
            "                \"email\": self.admin.email,",
            "                \"date_joined_0\": \"2018-09-03\",",
            "                \"date_joined_1\": \"13:16:25\",",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "        self.admin.refresh_from_db()",
            "        self.assertNotEqual(self.admin.first_name, \"Changed by regular user\")",
            "",
            "    def test_regular_user_can_change_themselves(self):",
            "        response = self.client.post(",
            "            f\"/admin/auth/user/{self.tester.pk}/change/\",",
            "            {",
            "                \"first_name\": \"Changed by myself\",",
            "                # required fields below",
            "                \"username\": self.tester.username,",
            "                \"email\": self.tester.email,",
            "                \"date_joined_0\": \"2018-09-03\",",
            "                \"date_joined_1\": \"13:16:25\",",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertEqual(HTTPStatus.OK, response.status_code)",
            "",
            "        self.tester.refresh_from_db()",
            "        self.assertEqual(self.tester.first_name, \"Changed by myself\")",
            "",
            "    def test_regular_user_cant_delete_others(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.admin.pk}/delete/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "    def test_regular_user_can_delete_myself(self):",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk])",
            "        )",
            "        self.assertContains(response, _(\"Yes, I'm sure\"))",
            "",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_user_delete\", args=[self.tester.pk]),",
            "            {\"post\": \"yes\"},",
            "            follow=True,",
            "        )",
            "        self.assertRedirects(response, \"/accounts/login/\")",
            "        self.assertFalse(get_user_model().objects.filter(pk=self.tester.pk).exists())",
            "",
            "    def test_regular_user_can_change_their_password(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.tester.pk}/password/\")",
            "        # redirects to change password for themselves",
            "        self.assertRedirects(response, \"/admin/password_change/\")",
            "",
            "    def test_regular_user_cant_change_password_for_others(self):",
            "        response = self.client.get(f\"/admin/auth/user/{self.moderator.pk}/password/\")",
            "        self.assertEqual(HTTPStatus.FORBIDDEN, response.status_code)",
            "",
            "",
            "class TestGroupAdmin(LoggedInTestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        super().setUpTestData()",
            "",
            "        cls.tester.is_superuser = True",
            "        cls.tester.save()",
            "",
            "        cls.group = GroupFactory(name=\"NewGroupName\")",
            "        cls.group.save()",
            "        cls.defaultGroups = Group.objects.filter(name__in=[\"Administrator\", \"Tester\"])",
            "",
            "    def test_should_not_be_allowed_to_change_groups_with_default_names(self):",
            "        for group in self.defaultGroups:",
            "            response = self.client.get(",
            "                reverse(\"admin:auth_group_change\", args=[group.id])",
            "            )",
            "            self.assertNotContains(",
            "                response,",
            "                f'<input type=\"text\" name=\"name\" value=\"{group.name}\" class=\"vTextField\"'",
            "                ' maxlength=\"150\" required=\"\" id=\"id_name\">',",
            "            )",
            "            self.assertContains(",
            "                response, f'<div class=\"grp-readonly\">{group.name}</div>'",
            "            )",
            "",
            "    def test_should_not_be_allowed_to_delete_default_groups(self):",
            "        for group in self.defaultGroups:",
            "            response = self.client.get(",
            "                reverse(\"admin:auth_group_change\", args=[group.id])",
            "            )",
            "            _expected_url = reverse(\"admin:auth_group_delete\", args=[self.group.id])",
            "            _delete = _(\"Delete\")",
            "            self.assertNotContains(",
            "                response,",
            "                f'<a href=\"{_expected_url}\" class=\"grp-button grp-delete-link\">{_delete}</a>',",
            "            )",
            "",
            "    def test_should_be_allowed_to_create_new_group(self):",
            "        response = self.client.get(reverse(\"admin:auth_group_add\"))",
            "        _add_group = _(\"Add %s\") % _(\"group\")",
            "        self.assertContains(response, f\"<h1>{_add_group}</h1>\")",
            "        self.assertContains(",
            "            response,",
            "            '<input type=\"text\" name=\"name\" class=\"vTextField\" '",
            "            'maxlength=\"150\" required id=\"id_name\">',",
            "        )",
            "",
            "        # check for the user widget",
            "        self.assertContains(",
            "            response,",
            "            '<select name=\"users\" id=\"id_users\" multiple '",
            "            'class=\"selectfilter\" data-field-name=\"users\" data-is-stacked=\"0\">',",
            "        )",
            "        _label = _(\"Users\")",
            "        self.assertContains(response, f'<label for=\"id_users\">{_label}')",
            "",
            "    def test_should_be_able_to_delete_a_non_default_group(self):",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_group_delete\", args=[self.group.id]), follow=True",
            "        )",
            "        _are_you_sure = _(\"Are you sure?\")",
            "        self.assertContains(response, f\"<h1>{_are_you_sure}</h1>\")",
            "",
            "    def test_should_be_able_to_edit_a_non_default_group(self):",
            "        response = self.client.get(",
            "            reverse(\"admin:auth_group_change\", args=[self.group.id])",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            f'<input type=\"text\" name=\"name\" value=\"{self.group.name}\" class=\"vTextField\"'",
            "            ' maxlength=\"150\" required id=\"id_name\">',",
            "        )",
            "",
            "    def test_should_be_allowed_to_create_new_group_with_added_user(self):",
            "        self.assertFalse(self.tester.groups.filter(name=self.group.name).exists())",
            "",
            "        group_name = \"TestGroupName\"",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_group_add\"),",
            "            {\"name\": group_name, \"users\": [self.tester.id]},",
            "            follow=True,",
            "        )",
            "",
            "        group = self.tester.groups.get(name=group_name)",
            "",
            "        self.assertIsNotNone(group)",
            "        self.assertContains(response, group_name)",
            "        group_url = reverse(\"admin:auth_group_change\", args=[group.pk])",
            "        self.assertContains(",
            "            response,",
            "            f'<a href=\"{group_url}\">{group_name}</a>',",
            "        )",
            "",
            "    def test_should_be_able_to_add_user_while_editing_a_group(self):",
            "        self.assertFalse(self.tester.groups.filter(name=self.group.name).exists())",
            "        response = self.client.post(",
            "            reverse(\"admin:auth_group_change\", args=[self.group.id]),",
            "            {\"name\": self.group.name, \"users\": [self.tester.id], \"_continue\": True},",
            "            follow=True,",
            "        )",
            "",
            "        self.assertContains(",
            "            response,",
            "            f'<option value=\"{self.tester.pk}\" selected>{self.tester.username}</option>',",
            "        )",
            "        self.assertTrue(self.tester.groups.filter(name=self.group.name).exists())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "95": [
                "TestUserAdmin",
                "test_superuser_can_change_other_users"
            ],
            "96": [
                "TestUserAdmin",
                "test_superuser_can_change_other_users"
            ],
            "101": [
                "TestUserAdmin",
                "test_superuser_can_change_other_users"
            ],
            "114": [
                "TestUserAdmin",
                "test_superuser_can_change_other_users"
            ],
            "292": [
                "TestUserAdmin",
                "test_moderator_can_change_other_users"
            ],
            "293": [
                "TestUserAdmin",
                "test_moderator_can_change_other_users"
            ],
            "298": [
                "TestUserAdmin",
                "test_moderator_can_change_other_users"
            ],
            "310": [
                "TestUserAdmin",
                "test_moderator_can_change_other_users"
            ],
            "395": [
                "TestUserAdmin",
                "test_regular_user_can_view_themselves"
            ],
            "396": [
                "TestUserAdmin",
                "test_regular_user_can_view_themselves"
            ],
            "401": [
                "TestUserAdmin",
                "test_regular_user_can_view_themselves"
            ]
        },
        "addLocation": []
    }
}