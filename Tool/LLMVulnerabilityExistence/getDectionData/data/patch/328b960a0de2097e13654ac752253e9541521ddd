{
    "lollms/security.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         # This means we should only return the part up to the whitelisted command"
            },
            "1": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         return line[:command_end_index + len(sanitized_rest)].strip()"
            },
            "2": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+if not(PackageManager.check_package_installed(\"defusedxml\")):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+    PackageManager.install_or_update(\"defusedxml\")"
            },
            "5": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def sanitize_svg(svg_content):"
            },
            "7": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    try:"
            },
            "8": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser = ET.XMLParser(remove_comments=True, remove_pis=True)"
            },
            "9": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        tree = ET.fromstring(svg_content, parser=parser)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+import defusedxml.ElementTree as ET"
            },
            "11": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Remove any script elements"
            },
            "13": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for script in tree.xpath('//svg:script', namespaces={'svg': 'http://www.w3.org/2000/svg'}):"
            },
            "14": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            parent = script.getparent()"
            },
            "15": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if parent is not None:"
            },
            "16": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                parent.remove(script)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+from defusedxml import ElementTree as ET"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+from io import StringIO"
            },
            "19": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Remove any 'on*' event attributes"
            },
            "21": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for element in tree.xpath('//*[@*[starts-with(name(), \"on\")]]'):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+def sanitize_svg(svg_content):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    try:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        # Use defusedxml's parse function with a StringIO object"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        tree = ET.parse(StringIO(svg_content))"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        root = tree.getroot()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        # Define a list of allowed elements"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        allowed_elements = {"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            'svg', 'g', 'path', 'circle', 'rect', 'line', 'polyline', 'polygon',"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            'text', 'tspan', 'defs', 'filter', 'feGaussianBlur', 'feMerge',"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            'feMergeNode', 'linearGradient', 'radialGradient', 'stop'"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+        }"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        # Define a list of allowed attributes"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        allowed_attributes = {"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            'id', 'class', 'style', 'fill', 'stroke', 'stroke-width', 'cx', 'cy',"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+            'r', 'x', 'y', 'width', 'height', 'd', 'transform', 'viewBox',"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+            'xmlns', 'xmlns:xlink', 'version', 'stdDeviation', 'result', 'in',"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+            'x1', 'y1', 'x2', 'y2', 'offset', 'stop-color', 'stop-opacity'"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        }"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        # Remove any disallowed elements"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        for element in root.iter():"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            if element.tag.split('}')[-1] not in allowed_elements:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+                parent = element.getparent()"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+                if parent is not None:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+                    parent.remove(element)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        # Remove any disallowed attributes"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        for element in root.iter():"
            },
            "52": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "             for attr in list(element.attrib):"
            },
            "53": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if attr.startswith('on'):"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+                if attr not in allowed_attributes:"
            },
            "55": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "                     del element.attrib[attr]"
            },
            "56": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         # Convert the tree back to an SVG string"
            },
            "58": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sanitized_svg = ET.tostring(tree, encoding='unicode', method='xml')"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        sanitized_svg = ET.tostring(root, encoding='unicode', method='xml')"
            },
            "60": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         return sanitized_svg"
            },
            "61": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except ET.XMLSyntaxError as e:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    except ET.ParseError as e:"
            },
            "63": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         raise ValueError(\"Invalid SVG content\") from e"
            },
            "64": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " def sanitize_shell_code(code, whitelist=None):"
            },
            "68": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     \"\"\""
            },
            "69": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     Securely sanitizes a block of code by allowing commands from a provided whitelist,"
            }
        },
        "frontPatchFile": [
            "from fastapi import HTTPException",
            "from ascii_colors import ASCIIColors",
            "from urllib.parse import urlparse",
            "import socket",
            "from pathlib import Path",
            "from typing import List",
            "import os",
            "import re",
            "import platform",
            "import string",
            "from lollms.utilities import PackageManager",
            "",
            "if not PackageManager.check_package_installed(\"lxml\"):",
            "    PackageManager.install_package(\"lxml\")",
            "",
            "import lxml.etree as ET",
            "",
            "def check_access(lollmsElfServer, client_id):",
            "    client = lollmsElfServer.session.get_client(client_id)",
            "    if not client:",
            "        raise HTTPException(status_code=400, detail=f\"Not accessible without id\")",
            "    return client",
            "",
            "",
            "def sanitize_based_on_separators(line):",
            "    \"\"\"",
            "    Sanitizes a line of code based on common command separators.",
            "",
            "    Parameters:",
            "    - line (str): The line of code to be sanitized.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code.",
            "    \"\"\"",
            "    separators = ['&', '|', ';']",
            "    for sep in separators:",
            "        if sep in line:",
            "            line = line.split(sep)[0]  # Keep only the first command before the separator",
            "            break",
            "    return line.strip()",
            "",
            "def sanitize_after_whitelisted_command(line, command):",
            "    \"\"\"",
            "    Sanitizes the line after a whitelisted command, removing any following commands",
            "    if a command separator is present.",
            "",
            "    Parameters:",
            "    - line (str): The line of code containing the whitelisted command.",
            "    - command (str): The whitelisted command.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code, ensuring only the whitelisted command is executed.",
            "    \"\"\"",
            "    # Find the end of the whitelisted command in the line",
            "    command_end_index = line.find(command) + len(command)",
            "    # Extract the rest of the line after the whitelisted command",
            "    rest_of_line = line[command_end_index:]",
            "    # Sanitize the rest of the line based on separators",
            "    sanitized_rest = sanitize_based_on_separators(rest_of_line)",
            "    # If anything malicious was removed, sanitized_rest will be empty, so only return the whitelisted command part",
            "    if not sanitized_rest:",
            "        return line[:command_end_index].strip()",
            "    else:",
            "        # If rest_of_line starts directly with separators followed by malicious commands, sanitized_rest will be empty",
            "        # This means we should only return the part up to the whitelisted command",
            "        return line[:command_end_index + len(sanitized_rest)].strip()",
            "",
            "",
            "def sanitize_svg(svg_content):",
            "    try:",
            "        parser = ET.XMLParser(remove_comments=True, remove_pis=True)",
            "        tree = ET.fromstring(svg_content, parser=parser)",
            "",
            "        # Remove any script elements",
            "        for script in tree.xpath('//svg:script', namespaces={'svg': 'http://www.w3.org/2000/svg'}):",
            "            parent = script.getparent()",
            "            if parent is not None:",
            "                parent.remove(script)",
            "",
            "        # Remove any 'on*' event attributes",
            "        for element in tree.xpath('//*[@*[starts-with(name(), \"on\")]]'):",
            "            for attr in list(element.attrib):",
            "                if attr.startswith('on'):",
            "                    del element.attrib[attr]",
            "",
            "        # Convert the tree back to an SVG string",
            "        sanitized_svg = ET.tostring(tree, encoding='unicode', method='xml')",
            "        return sanitized_svg",
            "    except ET.XMLSyntaxError as e:",
            "        raise ValueError(\"Invalid SVG content\") from e",
            "",
            "",
            "def sanitize_shell_code(code, whitelist=None):",
            "    \"\"\"",
            "    Securely sanitizes a block of code by allowing commands from a provided whitelist,",
            "    but only up to the first command separator if followed by other commands.",
            "    Sanitizes based on common command separators if no whitelist is provided.",
            "",
            "    Parameters:",
            "    - code (str): The input code to be sanitized.",
            "    - whitelist (list): Optional. A list of whitelisted commands that are allowed.",
            "",
            "    Returns:",
            "    - str: The securely sanitized code.",
            "    \"\"\"",
            "    ",
            "    # Split the code by newline characters",
            "    lines = code.split('\\n')",
            "    ",
            "    # Initialize the sanitized code variable",
            "    sanitized_code = \"\"",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if the line is not empty",
            "            if whitelist:",
            "                for command in whitelist:",
            "                    if line.strip().startswith(command):",
            "                        # Check for command separators after the whitelisted command",
            "                        sanitized_code = sanitize_after_whitelisted_command(line, command)",
            "                        break",
            "            else:",
            "                # Sanitize based on separators if no whitelist is provided",
            "                sanitized_code = sanitize_based_on_separators(line)",
            "            break  # Only process the first non-empty line",
            "    ",
            "    return sanitized_code",
            "",
            "",
            "class InvalidFilePathError(Exception):",
            "    pass",
            "",
            "",
            "def sanitize_path(path: str, allow_absolute_path: bool = False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal or command injection. Are you kidding me?\"):",
            "    \"\"\"",
            "    Sanitize a given file path by checking for potentially dangerous patterns and unauthorized characters.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    allow_absolute_path (bool, optional): Whether to allow absolute paths. Default is False.",
            "    error_text (str, optional): The error message to display if an absolute path is detected. Default is \"Absolute database path detected\".",
            "    exception_text (str, optional): The exception message to display if a path traversal, command injection, or unauthorized character is detected. Default is \"Detected an attempt of path traversal or command injection. Are you kidding me?\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, command injection, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "",
            "    Note:",
            "    -----",
            "    This function checks for patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami). It also checks for unauthorized punctuation characters, excluding the dot (.) character.",
            "    \"\"\"    ",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if not allow_absolute_path and path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami)",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)|(\\$\\(.*\\))')",
            "",
            "    if suspicious_patterns.search(str(path)) or ((not allow_absolute_path) and Path(path).is_absolute()):",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if not allow_absolute_path:",
            "        path = path.lstrip('/')",
            "",
            "    return path",
            "",
            "    ",
            "def sanitize_path_from_endpoint(path: str, error_text: str = \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text: str = \"Invalid path!\") -> str:",
            "    \"\"\"",
            "    Sanitize a given file path from an endpoint by checking for potentially dangerous patterns and unauthorized characters,",
            "    and standardizing path separators to prevent directory traversal attacks.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    error_text (str, optional): Error message to display if a path traversal or unauthorized character is detected. Default is a warning about a suspected LFI attack.",
            "    exception_text (str, optional): Exception message to display if an absolute path or invalid character is detected. Default is \"Invalid path!\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "    \"\"\"",
            "",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if suspicious_patterns.search(path) or Path(path).is_absolute():",
            "        raise HTTPException(status_code=400, detail=error_text)",
            "",
            "    path = path.lstrip('/')",
            "    return path",
            "",
            "",
            "",
            "def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):",
            "    if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":",
            "        raise Exception(exception_text)",
            "",
            "def validate_path(path, allowed_paths:List[str|Path]):",
            "    # Convert the path to an absolute path",
            "    abs_path = os.path.realpath(str(path))",
            "",
            "    # Iterate over the allowed paths",
            "    for allowed_path in allowed_paths:",
            "        # Convert the allowed path to an absolute path",
            "        abs_allowed_path = os.path.realpath(allowed_path)",
            "",
            "        # Check if the absolute path starts with the absolute allowed path",
            "        if abs_path.startswith(abs_allowed_path):",
            "            return True",
            "",
            "    # If the path is not within any of the allowed paths, return False",
            "    return False",
            "",
            "def is_allowed_url(url):",
            "    # Check if url is legit",
            "    parsed_url = urlparse(url)        ",
            "    # Check if scheme is not http or https, return False",
            "    if parsed_url.scheme not in ['http', 'https']:",
            "        return False",
            "    ",
            "    hostname = parsed_url.hostname",
            "    ",
            "    try:",
            "        ip_address = socket.gethostbyname(hostname)",
            "    except socket.gaierror:",
            "        return False",
            "    ",
            "    return not ip_address.startswith('127.') or ip_address.startswith('192.168.') or ip_address.startswith('10.') or ip_address.startswith('172.')",
            "",
            "",
            "if __name__==\"__main__\":",
            "    sanitize_path_from_endpoint(\"main\")",
            "    sanitize_path_from_endpoint(\"cat/main\")",
            "    print(\"Main passed\")",
            "    sanitize_path_from_endpoint(\".../user\")",
            "    print(\"hi\")"
        ],
        "afterPatchFile": [
            "from fastapi import HTTPException",
            "from ascii_colors import ASCIIColors",
            "from urllib.parse import urlparse",
            "import socket",
            "from pathlib import Path",
            "from typing import List",
            "import os",
            "import re",
            "import platform",
            "import string",
            "from lollms.utilities import PackageManager",
            "",
            "if not PackageManager.check_package_installed(\"lxml\"):",
            "    PackageManager.install_package(\"lxml\")",
            "",
            "import lxml.etree as ET",
            "",
            "def check_access(lollmsElfServer, client_id):",
            "    client = lollmsElfServer.session.get_client(client_id)",
            "    if not client:",
            "        raise HTTPException(status_code=400, detail=f\"Not accessible without id\")",
            "    return client",
            "",
            "",
            "def sanitize_based_on_separators(line):",
            "    \"\"\"",
            "    Sanitizes a line of code based on common command separators.",
            "",
            "    Parameters:",
            "    - line (str): The line of code to be sanitized.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code.",
            "    \"\"\"",
            "    separators = ['&', '|', ';']",
            "    for sep in separators:",
            "        if sep in line:",
            "            line = line.split(sep)[0]  # Keep only the first command before the separator",
            "            break",
            "    return line.strip()",
            "",
            "def sanitize_after_whitelisted_command(line, command):",
            "    \"\"\"",
            "    Sanitizes the line after a whitelisted command, removing any following commands",
            "    if a command separator is present.",
            "",
            "    Parameters:",
            "    - line (str): The line of code containing the whitelisted command.",
            "    - command (str): The whitelisted command.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code, ensuring only the whitelisted command is executed.",
            "    \"\"\"",
            "    # Find the end of the whitelisted command in the line",
            "    command_end_index = line.find(command) + len(command)",
            "    # Extract the rest of the line after the whitelisted command",
            "    rest_of_line = line[command_end_index:]",
            "    # Sanitize the rest of the line based on separators",
            "    sanitized_rest = sanitize_based_on_separators(rest_of_line)",
            "    # If anything malicious was removed, sanitized_rest will be empty, so only return the whitelisted command part",
            "    if not sanitized_rest:",
            "        return line[:command_end_index].strip()",
            "    else:",
            "        # If rest_of_line starts directly with separators followed by malicious commands, sanitized_rest will be empty",
            "        # This means we should only return the part up to the whitelisted command",
            "        return line[:command_end_index + len(sanitized_rest)].strip()",
            "",
            "if not(PackageManager.check_package_installed(\"defusedxml\")):",
            "    PackageManager.install_or_update(\"defusedxml\")",
            "",
            "import defusedxml.ElementTree as ET",
            "",
            "from defusedxml import ElementTree as ET",
            "from io import StringIO",
            "",
            "def sanitize_svg(svg_content):",
            "    try:",
            "        # Use defusedxml's parse function with a StringIO object",
            "        tree = ET.parse(StringIO(svg_content))",
            "        root = tree.getroot()",
            "",
            "        # Define a list of allowed elements",
            "        allowed_elements = {",
            "            'svg', 'g', 'path', 'circle', 'rect', 'line', 'polyline', 'polygon',",
            "            'text', 'tspan', 'defs', 'filter', 'feGaussianBlur', 'feMerge',",
            "            'feMergeNode', 'linearGradient', 'radialGradient', 'stop'",
            "        }",
            "",
            "        # Define a list of allowed attributes",
            "        allowed_attributes = {",
            "            'id', 'class', 'style', 'fill', 'stroke', 'stroke-width', 'cx', 'cy',",
            "            'r', 'x', 'y', 'width', 'height', 'd', 'transform', 'viewBox',",
            "            'xmlns', 'xmlns:xlink', 'version', 'stdDeviation', 'result', 'in',",
            "            'x1', 'y1', 'x2', 'y2', 'offset', 'stop-color', 'stop-opacity'",
            "        }",
            "",
            "        # Remove any disallowed elements",
            "        for element in root.iter():",
            "            if element.tag.split('}')[-1] not in allowed_elements:",
            "                parent = element.getparent()",
            "                if parent is not None:",
            "                    parent.remove(element)",
            "",
            "        # Remove any disallowed attributes",
            "        for element in root.iter():",
            "            for attr in list(element.attrib):",
            "                if attr not in allowed_attributes:",
            "                    del element.attrib[attr]",
            "",
            "        # Convert the tree back to an SVG string",
            "        sanitized_svg = ET.tostring(root, encoding='unicode', method='xml')",
            "        return sanitized_svg",
            "    except ET.ParseError as e:",
            "        raise ValueError(\"Invalid SVG content\") from e",
            "",
            "",
            "",
            "def sanitize_shell_code(code, whitelist=None):",
            "    \"\"\"",
            "    Securely sanitizes a block of code by allowing commands from a provided whitelist,",
            "    but only up to the first command separator if followed by other commands.",
            "    Sanitizes based on common command separators if no whitelist is provided.",
            "",
            "    Parameters:",
            "    - code (str): The input code to be sanitized.",
            "    - whitelist (list): Optional. A list of whitelisted commands that are allowed.",
            "",
            "    Returns:",
            "    - str: The securely sanitized code.",
            "    \"\"\"",
            "    ",
            "    # Split the code by newline characters",
            "    lines = code.split('\\n')",
            "    ",
            "    # Initialize the sanitized code variable",
            "    sanitized_code = \"\"",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if the line is not empty",
            "            if whitelist:",
            "                for command in whitelist:",
            "                    if line.strip().startswith(command):",
            "                        # Check for command separators after the whitelisted command",
            "                        sanitized_code = sanitize_after_whitelisted_command(line, command)",
            "                        break",
            "            else:",
            "                # Sanitize based on separators if no whitelist is provided",
            "                sanitized_code = sanitize_based_on_separators(line)",
            "            break  # Only process the first non-empty line",
            "    ",
            "    return sanitized_code",
            "",
            "",
            "class InvalidFilePathError(Exception):",
            "    pass",
            "",
            "",
            "def sanitize_path(path: str, allow_absolute_path: bool = False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal or command injection. Are you kidding me?\"):",
            "    \"\"\"",
            "    Sanitize a given file path by checking for potentially dangerous patterns and unauthorized characters.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    allow_absolute_path (bool, optional): Whether to allow absolute paths. Default is False.",
            "    error_text (str, optional): The error message to display if an absolute path is detected. Default is \"Absolute database path detected\".",
            "    exception_text (str, optional): The exception message to display if a path traversal, command injection, or unauthorized character is detected. Default is \"Detected an attempt of path traversal or command injection. Are you kidding me?\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, command injection, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "",
            "    Note:",
            "    -----",
            "    This function checks for patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami). It also checks for unauthorized punctuation characters, excluding the dot (.) character.",
            "    \"\"\"    ",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if not allow_absolute_path and path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami)",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)|(\\$\\(.*\\))')",
            "",
            "    if suspicious_patterns.search(str(path)) or ((not allow_absolute_path) and Path(path).is_absolute()):",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if not allow_absolute_path:",
            "        path = path.lstrip('/')",
            "",
            "    return path",
            "",
            "    ",
            "def sanitize_path_from_endpoint(path: str, error_text: str = \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text: str = \"Invalid path!\") -> str:",
            "    \"\"\"",
            "    Sanitize a given file path from an endpoint by checking for potentially dangerous patterns and unauthorized characters,",
            "    and standardizing path separators to prevent directory traversal attacks.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    error_text (str, optional): Error message to display if a path traversal or unauthorized character is detected. Default is a warning about a suspected LFI attack.",
            "    exception_text (str, optional): Exception message to display if an absolute path or invalid character is detected. Default is \"Invalid path!\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "    \"\"\"",
            "",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if suspicious_patterns.search(path) or Path(path).is_absolute():",
            "        raise HTTPException(status_code=400, detail=error_text)",
            "",
            "    path = path.lstrip('/')",
            "    return path",
            "",
            "",
            "",
            "def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):",
            "    if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":",
            "        raise Exception(exception_text)",
            "",
            "def validate_path(path, allowed_paths:List[str|Path]):",
            "    # Convert the path to an absolute path",
            "    abs_path = os.path.realpath(str(path))",
            "",
            "    # Iterate over the allowed paths",
            "    for allowed_path in allowed_paths:",
            "        # Convert the allowed path to an absolute path",
            "        abs_allowed_path = os.path.realpath(allowed_path)",
            "",
            "        # Check if the absolute path starts with the absolute allowed path",
            "        if abs_path.startswith(abs_allowed_path):",
            "            return True",
            "",
            "    # If the path is not within any of the allowed paths, return False",
            "    return False",
            "",
            "def is_allowed_url(url):",
            "    # Check if url is legit",
            "    parsed_url = urlparse(url)        ",
            "    # Check if scheme is not http or https, return False",
            "    if parsed_url.scheme not in ['http', 'https']:",
            "        return False",
            "    ",
            "    hostname = parsed_url.hostname",
            "    ",
            "    try:",
            "        ip_address = socket.gethostbyname(hostname)",
            "    except socket.gaierror:",
            "        return False",
            "    ",
            "    return not ip_address.startswith('127.') or ip_address.startswith('192.168.') or ip_address.startswith('10.') or ip_address.startswith('172.')",
            "",
            "",
            "if __name__==\"__main__\":",
            "    sanitize_path_from_endpoint(\"main\")",
            "    sanitize_path_from_endpoint(\"cat/main\")",
            "    print(\"Main passed\")",
            "    sanitize_path_from_endpoint(\".../user\")",
            "    print(\"hi\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "69": [
                "sanitize_svg"
            ],
            "70": [
                "sanitize_svg"
            ],
            "71": [
                "sanitize_svg"
            ],
            "72": [
                "sanitize_svg"
            ],
            "74": [
                "sanitize_svg"
            ],
            "75": [
                "sanitize_svg"
            ],
            "76": [
                "sanitize_svg"
            ],
            "77": [
                "sanitize_svg"
            ],
            "78": [
                "sanitize_svg"
            ],
            "80": [
                "sanitize_svg"
            ],
            "81": [
                "sanitize_svg"
            ],
            "83": [
                "sanitize_svg"
            ],
            "87": [
                "sanitize_svg"
            ],
            "89": [
                "sanitize_svg"
            ]
        },
        "addLocation": []
    }
}