{
    "nova/openstack/common/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#    not use this file except in compliance with the License. You may obtain"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#    a copy of the License at"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#         http://www.apache.org/licenses/LICENSE-2.0"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#    Unless required by applicable law or agreed to in writing, software"
            },
            "8": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT"
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the"
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#    License for the specific language governing permissions and limitations"
            },
            "11": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#    under the License."
            },
            "12": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import six"
            },
            "14": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "16": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-six.add_move(six.MovedModule('mox', 'mox', 'mox3.mox'))"
            }
        },
        "frontPatchFile": [
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import six",
            "",
            "",
            "six.add_move(six.MovedModule('mox', 'mox', 'mox3.mox'))"
        ],
        "afterPatchFile": [],
        "action": [
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1"
        ],
        "dele_reviseLocation": {
            "1": [],
            "2": [],
            "3": [],
            "4": [],
            "5": [],
            "6": [],
            "7": [],
            "8": [],
            "9": [],
            "10": [],
            "11": [],
            "12": [],
            "13": [],
            "14": [],
            "15": [],
            "16": [],
            "17": []
        },
        "addLocation": []
    },
    "nova/openstack/common/processutils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import errno"
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import logging as stdlib_logging"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+import logging"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import multiprocessing"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import os"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " import random"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " import six"
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from nova.openstack.common.gettextutils import _"
            },
            "11": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from nova.openstack.common import log as logging"
            },
            "12": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from nova.openstack.common import strutils"
            },
            "13": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "                             execute this command. Defaults to false."
            },
            "16": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     :type shell:            boolean"
            },
            "17": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     :param loglevel:        log level for execute commands."
            },
            "18": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :type loglevel:         int.  (Should be stdlib_logging.DEBUG or"
            },
            "19": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            stdlib_logging.INFO)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    :type loglevel:         int.  (Should be logging.DEBUG or logging.INFO)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    :param on_execute:      This function will be called upon process creation"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                            with the object as a argument.  The Purpose of this"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+                            is to allow the caller of `processutils.execute` to"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                            track process creation asynchronously."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    :type on_execute:       function(:class:`subprocess.Popen`)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    :param on_completion:   This function will be called upon process"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+                            completion with the object as a argument.  The"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+                            Purpose of this is to allow the caller of"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+                            `processutils.execute` to track process completion"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+                            asynchronously."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+    :type on_completion:    function(:class:`subprocess.Popen`)"
            },
            "32": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "     :returns:               (stdout, stderr) from process execution"
            },
            "33": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     :raises:                :class:`UnknownArgumentError` on"
            },
            "34": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                             receiving unknown arguments"
            },
            "35": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     run_as_root = kwargs.pop('run_as_root', False)"
            },
            "36": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "     root_helper = kwargs.pop('root_helper', '')"
            },
            "37": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     shell = kwargs.pop('shell', False)"
            },
            "38": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    loglevel = kwargs.pop('loglevel', stdlib_logging.DEBUG)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    loglevel = kwargs.pop('loglevel', logging.DEBUG)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    on_execute = kwargs.pop('on_execute', None)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+    on_completion = kwargs.pop('on_completion', None)"
            },
            "42": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     if isinstance(check_exit_code, bool):"
            },
            "44": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         ignore_exit_code = not check_exit_code"
            },
            "45": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         check_exit_code = [check_exit_code]"
            },
            "46": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     if kwargs:"
            },
            "48": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise UnknownArgumentError(_('Got unknown keyword args '"
            },
            "49": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                     'to utils.execute: %r') % kwargs)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        raise UnknownArgumentError(_('Got unknown keyword args: %r') % kwargs)"
            },
            "51": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     if run_as_root and hasattr(os, 'geteuid') and os.geteuid() != 0:"
            },
            "53": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         if not root_helper:"
            },
            "54": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "                                    preexec_fn=preexec_fn,"
            },
            "55": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "                                    shell=shell,"
            },
            "56": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "                                    env=env_variables)"
            },
            "57": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result = None"
            },
            "58": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for _i in six.moves.range(20):"
            },
            "59": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # NOTE(russellb) 20 is an arbitrary number of retries to"
            },
            "60": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # prevent any chance of looping forever here."
            },
            "61": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "62": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if process_input is not None:"
            },
            "63": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        result = obj.communicate(process_input)"
            },
            "64": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    else:"
            },
            "65": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        result = obj.communicate()"
            },
            "66": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except OSError as e:"
            },
            "67": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if e.errno in (errno.EAGAIN, errno.EINTR):"
            },
            "68": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        continue"
            },
            "69": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise"
            },
            "70": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                break"
            },
            "71": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            obj.stdin.close()  # pylint: disable=E1101"
            },
            "72": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            _returncode = obj.returncode  # pylint: disable=E1101"
            },
            "73": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            LOG.log(loglevel, 'Result was %s' % _returncode)"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            if on_execute:"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                on_execute(obj)"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            try:"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+                result = None"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+                for _i in six.moves.range(20):"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+                    # NOTE(russellb) 20 is an arbitrary number of retries to"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+                    # prevent any chance of looping forever here."
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                    try:"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                        if process_input is not None:"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+                            result = obj.communicate(process_input)"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+                        else:"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+                            result = obj.communicate()"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+                    except OSError as e:"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+                        if e.errno in (errno.EAGAIN, errno.EINTR):"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+                            continue"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+                        raise"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+                    break"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+                obj.stdin.close()  # pylint: disable=E1101"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                _returncode = obj.returncode  # pylint: disable=E1101"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                LOG.log(loglevel, 'Result was %s' % _returncode)"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+            finally:"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                if on_completion:"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                    on_completion(obj)"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "             if not ignore_exit_code and _returncode not in check_exit_code:"
            },
            "101": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "                 (stdout, stderr) = result"
            },
            "102": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "                 sanitized_stdout = strutils.mask_password(stdout)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2011 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "System-level utilities and helper functions.",
            "\"\"\"",
            "",
            "import errno",
            "import logging as stdlib_logging",
            "import multiprocessing",
            "import os",
            "import random",
            "import shlex",
            "import signal",
            "",
            "from eventlet.green import subprocess",
            "from eventlet import greenthread",
            "import six",
            "",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common import strutils",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class InvalidArgumentError(Exception):",
            "    def __init__(self, message=None):",
            "        super(InvalidArgumentError, self).__init__(message)",
            "",
            "",
            "class UnknownArgumentError(Exception):",
            "    def __init__(self, message=None):",
            "        super(UnknownArgumentError, self).__init__(message)",
            "",
            "",
            "class ProcessExecutionError(Exception):",
            "    def __init__(self, stdout=None, stderr=None, exit_code=None, cmd=None,",
            "                 description=None):",
            "        self.exit_code = exit_code",
            "        self.stderr = stderr",
            "        self.stdout = stdout",
            "        self.cmd = cmd",
            "        self.description = description",
            "",
            "        if description is None:",
            "            description = _(\"Unexpected error while running command.\")",
            "        if exit_code is None:",
            "            exit_code = '-'",
            "        message = _('%(description)s\\n'",
            "                    'Command: %(cmd)s\\n'",
            "                    'Exit code: %(exit_code)s\\n'",
            "                    'Stdout: %(stdout)r\\n'",
            "                    'Stderr: %(stderr)r') % {'description': description,",
            "                                             'cmd': cmd,",
            "                                             'exit_code': exit_code,",
            "                                             'stdout': stdout,",
            "                                             'stderr': stderr}",
            "        super(ProcessExecutionError, self).__init__(message)",
            "",
            "",
            "class NoRootWrapSpecified(Exception):",
            "    def __init__(self, message=None):",
            "        super(NoRootWrapSpecified, self).__init__(message)",
            "",
            "",
            "def _subprocess_setup():",
            "    # Python installs a SIGPIPE handler by default. This is usually not what",
            "    # non-Python subprocesses expect.",
            "    signal.signal(signal.SIGPIPE, signal.SIG_DFL)",
            "",
            "",
            "def execute(*cmd, **kwargs):",
            "    \"\"\"Helper method to shell out and execute a command through subprocess.",
            "",
            "    Allows optional retry.",
            "",
            "    :param cmd:             Passed to subprocess.Popen.",
            "    :type cmd:              string",
            "    :param process_input:   Send to opened process.",
            "    :type process_input:    string",
            "    :param env_variables:   Environment variables and their values that",
            "                            will be set for the process.",
            "    :type env_variables:    dict",
            "    :param check_exit_code: Single bool, int, or list of allowed exit",
            "                            codes.  Defaults to [0].  Raise",
            "                            :class:`ProcessExecutionError` unless",
            "                            program exits with one of these code.",
            "    :type check_exit_code:  boolean, int, or [int]",
            "    :param delay_on_retry:  True | False. Defaults to True. If set to True,",
            "                            wait a short amount of time before retrying.",
            "    :type delay_on_retry:   boolean",
            "    :param attempts:        How many times to retry cmd.",
            "    :type attempts:         int",
            "    :param run_as_root:     True | False. Defaults to False. If set to True,",
            "                            the command is prefixed by the command specified",
            "                            in the root_helper kwarg.",
            "    :type run_as_root:      boolean",
            "    :param root_helper:     command to prefix to commands called with",
            "                            run_as_root=True",
            "    :type root_helper:      string",
            "    :param shell:           whether or not there should be a shell used to",
            "                            execute this command. Defaults to false.",
            "    :type shell:            boolean",
            "    :param loglevel:        log level for execute commands.",
            "    :type loglevel:         int.  (Should be stdlib_logging.DEBUG or",
            "                            stdlib_logging.INFO)",
            "    :returns:               (stdout, stderr) from process execution",
            "    :raises:                :class:`UnknownArgumentError` on",
            "                            receiving unknown arguments",
            "    :raises:                :class:`ProcessExecutionError`",
            "    \"\"\"",
            "",
            "    process_input = kwargs.pop('process_input', None)",
            "    env_variables = kwargs.pop('env_variables', None)",
            "    check_exit_code = kwargs.pop('check_exit_code', [0])",
            "    ignore_exit_code = False",
            "    delay_on_retry = kwargs.pop('delay_on_retry', True)",
            "    attempts = kwargs.pop('attempts', 1)",
            "    run_as_root = kwargs.pop('run_as_root', False)",
            "    root_helper = kwargs.pop('root_helper', '')",
            "    shell = kwargs.pop('shell', False)",
            "    loglevel = kwargs.pop('loglevel', stdlib_logging.DEBUG)",
            "",
            "    if isinstance(check_exit_code, bool):",
            "        ignore_exit_code = not check_exit_code",
            "        check_exit_code = [0]",
            "    elif isinstance(check_exit_code, int):",
            "        check_exit_code = [check_exit_code]",
            "",
            "    if kwargs:",
            "        raise UnknownArgumentError(_('Got unknown keyword args '",
            "                                     'to utils.execute: %r') % kwargs)",
            "",
            "    if run_as_root and hasattr(os, 'geteuid') and os.geteuid() != 0:",
            "        if not root_helper:",
            "            raise NoRootWrapSpecified(",
            "                message=_('Command requested root, but did not '",
            "                          'specify a root helper.'))",
            "        cmd = shlex.split(root_helper) + list(cmd)",
            "",
            "    cmd = map(str, cmd)",
            "    sanitized_cmd = strutils.mask_password(' '.join(cmd))",
            "",
            "    while attempts > 0:",
            "        attempts -= 1",
            "        try:",
            "            LOG.log(loglevel, _('Running cmd (subprocess): %s'), sanitized_cmd)",
            "            _PIPE = subprocess.PIPE  # pylint: disable=E1101",
            "",
            "            if os.name == 'nt':",
            "                preexec_fn = None",
            "                close_fds = False",
            "            else:",
            "                preexec_fn = _subprocess_setup",
            "                close_fds = True",
            "",
            "            obj = subprocess.Popen(cmd,",
            "                                   stdin=_PIPE,",
            "                                   stdout=_PIPE,",
            "                                   stderr=_PIPE,",
            "                                   close_fds=close_fds,",
            "                                   preexec_fn=preexec_fn,",
            "                                   shell=shell,",
            "                                   env=env_variables)",
            "            result = None",
            "            for _i in six.moves.range(20):",
            "                # NOTE(russellb) 20 is an arbitrary number of retries to",
            "                # prevent any chance of looping forever here.",
            "                try:",
            "                    if process_input is not None:",
            "                        result = obj.communicate(process_input)",
            "                    else:",
            "                        result = obj.communicate()",
            "                except OSError as e:",
            "                    if e.errno in (errno.EAGAIN, errno.EINTR):",
            "                        continue",
            "                    raise",
            "                break",
            "            obj.stdin.close()  # pylint: disable=E1101",
            "            _returncode = obj.returncode  # pylint: disable=E1101",
            "            LOG.log(loglevel, 'Result was %s' % _returncode)",
            "            if not ignore_exit_code and _returncode not in check_exit_code:",
            "                (stdout, stderr) = result",
            "                sanitized_stdout = strutils.mask_password(stdout)",
            "                sanitized_stderr = strutils.mask_password(stderr)",
            "                raise ProcessExecutionError(exit_code=_returncode,",
            "                                            stdout=sanitized_stdout,",
            "                                            stderr=sanitized_stderr,",
            "                                            cmd=sanitized_cmd)",
            "            return result",
            "        except ProcessExecutionError:",
            "            if not attempts:",
            "                raise",
            "            else:",
            "                LOG.log(loglevel, _('%r failed. Retrying.'), sanitized_cmd)",
            "                if delay_on_retry:",
            "                    greenthread.sleep(random.randint(20, 200) / 100.0)",
            "        finally:",
            "            # NOTE(termie): this appears to be necessary to let the subprocess",
            "            #               call clean something up in between calls, without",
            "            #               it two execute calls in a row hangs the second one",
            "            greenthread.sleep(0)",
            "",
            "",
            "def trycmd(*args, **kwargs):",
            "    \"\"\"A wrapper around execute() to more easily handle warnings and errors.",
            "",
            "    Returns an (out, err) tuple of strings containing the output of",
            "    the command's stdout and stderr.  If 'err' is not empty then the",
            "    command can be considered to have failed.",
            "",
            "    :discard_warnings   True | False. Defaults to False. If set to True,",
            "                        then for succeeding commands, stderr is cleared",
            "",
            "    \"\"\"",
            "    discard_warnings = kwargs.pop('discard_warnings', False)",
            "",
            "    try:",
            "        out, err = execute(*args, **kwargs)",
            "        failed = False",
            "    except ProcessExecutionError as exn:",
            "        out, err = '', six.text_type(exn)",
            "        failed = True",
            "",
            "    if not failed and discard_warnings and err:",
            "        # Handle commands that output to stderr but otherwise succeed",
            "        err = ''",
            "",
            "    return out, err",
            "",
            "",
            "def ssh_execute(ssh, cmd, process_input=None,",
            "                addl_env=None, check_exit_code=True):",
            "    sanitized_cmd = strutils.mask_password(cmd)",
            "    LOG.debug('Running cmd (SSH): %s', sanitized_cmd)",
            "    if addl_env:",
            "        raise InvalidArgumentError(_('Environment not supported over SSH'))",
            "",
            "    if process_input:",
            "        # This is (probably) fixable if we need it...",
            "        raise InvalidArgumentError(_('process_input not supported over SSH'))",
            "",
            "    stdin_stream, stdout_stream, stderr_stream = ssh.exec_command(cmd)",
            "    channel = stdout_stream.channel",
            "",
            "    # NOTE(justinsb): This seems suspicious...",
            "    # ...other SSH clients have buffering issues with this approach",
            "    stdout = stdout_stream.read()",
            "    sanitized_stdout = strutils.mask_password(stdout)",
            "    stderr = stderr_stream.read()",
            "    sanitized_stderr = strutils.mask_password(stderr)",
            "",
            "    stdin_stream.close()",
            "",
            "    exit_status = channel.recv_exit_status()",
            "",
            "    # exit_status == -1 if no exit code was returned",
            "    if exit_status != -1:",
            "        LOG.debug('Result was %s' % exit_status)",
            "        if check_exit_code and exit_status != 0:",
            "            raise ProcessExecutionError(exit_code=exit_status,",
            "                                        stdout=sanitized_stdout,",
            "                                        stderr=sanitized_stderr,",
            "                                        cmd=sanitized_cmd)",
            "",
            "    return (sanitized_stdout, sanitized_stderr)",
            "",
            "",
            "def get_worker_count():",
            "    \"\"\"Utility to get the default worker count.",
            "",
            "    @return: The number of CPUs if that can be determined, else a default",
            "             worker count of 1 is returned.",
            "    \"\"\"",
            "    try:",
            "        return multiprocessing.cpu_count()",
            "    except NotImplementedError:",
            "        return 1"
        ],
        "afterPatchFile": [
            "# Copyright 2011 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "System-level utilities and helper functions.",
            "\"\"\"",
            "",
            "import errno",
            "import logging",
            "import multiprocessing",
            "import os",
            "import random",
            "import shlex",
            "import signal",
            "",
            "from eventlet.green import subprocess",
            "from eventlet import greenthread",
            "import six",
            "",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import strutils",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class InvalidArgumentError(Exception):",
            "    def __init__(self, message=None):",
            "        super(InvalidArgumentError, self).__init__(message)",
            "",
            "",
            "class UnknownArgumentError(Exception):",
            "    def __init__(self, message=None):",
            "        super(UnknownArgumentError, self).__init__(message)",
            "",
            "",
            "class ProcessExecutionError(Exception):",
            "    def __init__(self, stdout=None, stderr=None, exit_code=None, cmd=None,",
            "                 description=None):",
            "        self.exit_code = exit_code",
            "        self.stderr = stderr",
            "        self.stdout = stdout",
            "        self.cmd = cmd",
            "        self.description = description",
            "",
            "        if description is None:",
            "            description = _(\"Unexpected error while running command.\")",
            "        if exit_code is None:",
            "            exit_code = '-'",
            "        message = _('%(description)s\\n'",
            "                    'Command: %(cmd)s\\n'",
            "                    'Exit code: %(exit_code)s\\n'",
            "                    'Stdout: %(stdout)r\\n'",
            "                    'Stderr: %(stderr)r') % {'description': description,",
            "                                             'cmd': cmd,",
            "                                             'exit_code': exit_code,",
            "                                             'stdout': stdout,",
            "                                             'stderr': stderr}",
            "        super(ProcessExecutionError, self).__init__(message)",
            "",
            "",
            "class NoRootWrapSpecified(Exception):",
            "    def __init__(self, message=None):",
            "        super(NoRootWrapSpecified, self).__init__(message)",
            "",
            "",
            "def _subprocess_setup():",
            "    # Python installs a SIGPIPE handler by default. This is usually not what",
            "    # non-Python subprocesses expect.",
            "    signal.signal(signal.SIGPIPE, signal.SIG_DFL)",
            "",
            "",
            "def execute(*cmd, **kwargs):",
            "    \"\"\"Helper method to shell out and execute a command through subprocess.",
            "",
            "    Allows optional retry.",
            "",
            "    :param cmd:             Passed to subprocess.Popen.",
            "    :type cmd:              string",
            "    :param process_input:   Send to opened process.",
            "    :type process_input:    string",
            "    :param env_variables:   Environment variables and their values that",
            "                            will be set for the process.",
            "    :type env_variables:    dict",
            "    :param check_exit_code: Single bool, int, or list of allowed exit",
            "                            codes.  Defaults to [0].  Raise",
            "                            :class:`ProcessExecutionError` unless",
            "                            program exits with one of these code.",
            "    :type check_exit_code:  boolean, int, or [int]",
            "    :param delay_on_retry:  True | False. Defaults to True. If set to True,",
            "                            wait a short amount of time before retrying.",
            "    :type delay_on_retry:   boolean",
            "    :param attempts:        How many times to retry cmd.",
            "    :type attempts:         int",
            "    :param run_as_root:     True | False. Defaults to False. If set to True,",
            "                            the command is prefixed by the command specified",
            "                            in the root_helper kwarg.",
            "    :type run_as_root:      boolean",
            "    :param root_helper:     command to prefix to commands called with",
            "                            run_as_root=True",
            "    :type root_helper:      string",
            "    :param shell:           whether or not there should be a shell used to",
            "                            execute this command. Defaults to false.",
            "    :type shell:            boolean",
            "    :param loglevel:        log level for execute commands.",
            "    :type loglevel:         int.  (Should be logging.DEBUG or logging.INFO)",
            "    :param on_execute:      This function will be called upon process creation",
            "                            with the object as a argument.  The Purpose of this",
            "                            is to allow the caller of `processutils.execute` to",
            "                            track process creation asynchronously.",
            "    :type on_execute:       function(:class:`subprocess.Popen`)",
            "    :param on_completion:   This function will be called upon process",
            "                            completion with the object as a argument.  The",
            "                            Purpose of this is to allow the caller of",
            "                            `processutils.execute` to track process completion",
            "                            asynchronously.",
            "    :type on_completion:    function(:class:`subprocess.Popen`)",
            "    :returns:               (stdout, stderr) from process execution",
            "    :raises:                :class:`UnknownArgumentError` on",
            "                            receiving unknown arguments",
            "    :raises:                :class:`ProcessExecutionError`",
            "    \"\"\"",
            "",
            "    process_input = kwargs.pop('process_input', None)",
            "    env_variables = kwargs.pop('env_variables', None)",
            "    check_exit_code = kwargs.pop('check_exit_code', [0])",
            "    ignore_exit_code = False",
            "    delay_on_retry = kwargs.pop('delay_on_retry', True)",
            "    attempts = kwargs.pop('attempts', 1)",
            "    run_as_root = kwargs.pop('run_as_root', False)",
            "    root_helper = kwargs.pop('root_helper', '')",
            "    shell = kwargs.pop('shell', False)",
            "    loglevel = kwargs.pop('loglevel', logging.DEBUG)",
            "    on_execute = kwargs.pop('on_execute', None)",
            "    on_completion = kwargs.pop('on_completion', None)",
            "",
            "    if isinstance(check_exit_code, bool):",
            "        ignore_exit_code = not check_exit_code",
            "        check_exit_code = [0]",
            "    elif isinstance(check_exit_code, int):",
            "        check_exit_code = [check_exit_code]",
            "",
            "    if kwargs:",
            "        raise UnknownArgumentError(_('Got unknown keyword args: %r') % kwargs)",
            "",
            "    if run_as_root and hasattr(os, 'geteuid') and os.geteuid() != 0:",
            "        if not root_helper:",
            "            raise NoRootWrapSpecified(",
            "                message=_('Command requested root, but did not '",
            "                          'specify a root helper.'))",
            "        cmd = shlex.split(root_helper) + list(cmd)",
            "",
            "    cmd = map(str, cmd)",
            "    sanitized_cmd = strutils.mask_password(' '.join(cmd))",
            "",
            "    while attempts > 0:",
            "        attempts -= 1",
            "        try:",
            "            LOG.log(loglevel, _('Running cmd (subprocess): %s'), sanitized_cmd)",
            "            _PIPE = subprocess.PIPE  # pylint: disable=E1101",
            "",
            "            if os.name == 'nt':",
            "                preexec_fn = None",
            "                close_fds = False",
            "            else:",
            "                preexec_fn = _subprocess_setup",
            "                close_fds = True",
            "",
            "            obj = subprocess.Popen(cmd,",
            "                                   stdin=_PIPE,",
            "                                   stdout=_PIPE,",
            "                                   stderr=_PIPE,",
            "                                   close_fds=close_fds,",
            "                                   preexec_fn=preexec_fn,",
            "                                   shell=shell,",
            "                                   env=env_variables)",
            "",
            "            if on_execute:",
            "                on_execute(obj)",
            "",
            "            try:",
            "                result = None",
            "                for _i in six.moves.range(20):",
            "                    # NOTE(russellb) 20 is an arbitrary number of retries to",
            "                    # prevent any chance of looping forever here.",
            "                    try:",
            "                        if process_input is not None:",
            "                            result = obj.communicate(process_input)",
            "                        else:",
            "                            result = obj.communicate()",
            "                    except OSError as e:",
            "                        if e.errno in (errno.EAGAIN, errno.EINTR):",
            "                            continue",
            "                        raise",
            "                    break",
            "                obj.stdin.close()  # pylint: disable=E1101",
            "                _returncode = obj.returncode  # pylint: disable=E1101",
            "                LOG.log(loglevel, 'Result was %s' % _returncode)",
            "            finally:",
            "                if on_completion:",
            "                    on_completion(obj)",
            "",
            "            if not ignore_exit_code and _returncode not in check_exit_code:",
            "                (stdout, stderr) = result",
            "                sanitized_stdout = strutils.mask_password(stdout)",
            "                sanitized_stderr = strutils.mask_password(stderr)",
            "                raise ProcessExecutionError(exit_code=_returncode,",
            "                                            stdout=sanitized_stdout,",
            "                                            stderr=sanitized_stderr,",
            "                                            cmd=sanitized_cmd)",
            "            return result",
            "        except ProcessExecutionError:",
            "            if not attempts:",
            "                raise",
            "            else:",
            "                LOG.log(loglevel, _('%r failed. Retrying.'), sanitized_cmd)",
            "                if delay_on_retry:",
            "                    greenthread.sleep(random.randint(20, 200) / 100.0)",
            "        finally:",
            "            # NOTE(termie): this appears to be necessary to let the subprocess",
            "            #               call clean something up in between calls, without",
            "            #               it two execute calls in a row hangs the second one",
            "            greenthread.sleep(0)",
            "",
            "",
            "def trycmd(*args, **kwargs):",
            "    \"\"\"A wrapper around execute() to more easily handle warnings and errors.",
            "",
            "    Returns an (out, err) tuple of strings containing the output of",
            "    the command's stdout and stderr.  If 'err' is not empty then the",
            "    command can be considered to have failed.",
            "",
            "    :discard_warnings   True | False. Defaults to False. If set to True,",
            "                        then for succeeding commands, stderr is cleared",
            "",
            "    \"\"\"",
            "    discard_warnings = kwargs.pop('discard_warnings', False)",
            "",
            "    try:",
            "        out, err = execute(*args, **kwargs)",
            "        failed = False",
            "    except ProcessExecutionError as exn:",
            "        out, err = '', six.text_type(exn)",
            "        failed = True",
            "",
            "    if not failed and discard_warnings and err:",
            "        # Handle commands that output to stderr but otherwise succeed",
            "        err = ''",
            "",
            "    return out, err",
            "",
            "",
            "def ssh_execute(ssh, cmd, process_input=None,",
            "                addl_env=None, check_exit_code=True):",
            "    sanitized_cmd = strutils.mask_password(cmd)",
            "    LOG.debug('Running cmd (SSH): %s', sanitized_cmd)",
            "    if addl_env:",
            "        raise InvalidArgumentError(_('Environment not supported over SSH'))",
            "",
            "    if process_input:",
            "        # This is (probably) fixable if we need it...",
            "        raise InvalidArgumentError(_('process_input not supported over SSH'))",
            "",
            "    stdin_stream, stdout_stream, stderr_stream = ssh.exec_command(cmd)",
            "    channel = stdout_stream.channel",
            "",
            "    # NOTE(justinsb): This seems suspicious...",
            "    # ...other SSH clients have buffering issues with this approach",
            "    stdout = stdout_stream.read()",
            "    sanitized_stdout = strutils.mask_password(stdout)",
            "    stderr = stderr_stream.read()",
            "    sanitized_stderr = strutils.mask_password(stderr)",
            "",
            "    stdin_stream.close()",
            "",
            "    exit_status = channel.recv_exit_status()",
            "",
            "    # exit_status == -1 if no exit code was returned",
            "    if exit_status != -1:",
            "        LOG.debug('Result was %s' % exit_status)",
            "        if check_exit_code and exit_status != 0:",
            "            raise ProcessExecutionError(exit_code=exit_status,",
            "                                        stdout=sanitized_stdout,",
            "                                        stderr=sanitized_stderr,",
            "                                        cmd=sanitized_cmd)",
            "",
            "    return (sanitized_stdout, sanitized_stderr)",
            "",
            "",
            "def get_worker_count():",
            "    \"\"\"Utility to get the default worker count.",
            "",
            "    @return: The number of CPUs if that can be determined, else a default",
            "             worker count of 1 is returned.",
            "    \"\"\"",
            "    try:",
            "        return multiprocessing.cpu_count()",
            "    except NotImplementedError:",
            "        return 1"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [],
            "33": [],
            "119": [
                "execute"
            ],
            "120": [
                "execute"
            ],
            "136": [
                "execute"
            ],
            "145": [
                "execute"
            ],
            "146": [
                "execute"
            ],
            "179": [
                "execute"
            ],
            "180": [
                "execute"
            ],
            "181": [
                "execute"
            ],
            "182": [
                "execute"
            ],
            "183": [
                "execute"
            ],
            "184": [
                "execute"
            ],
            "185": [
                "execute"
            ],
            "186": [
                "execute"
            ],
            "187": [
                "execute"
            ],
            "188": [
                "execute"
            ],
            "189": [
                "execute"
            ],
            "190": [
                "execute"
            ],
            "191": [
                "execute"
            ],
            "192": [
                "execute"
            ],
            "193": [
                "execute"
            ],
            "194": [
                "execute"
            ],
            "195": [
                "execute"
            ]
        },
        "addLocation": []
    }
}