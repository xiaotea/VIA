{
    "django/contrib/auth/middleware.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from django.contrib import auth"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from django.contrib.auth.backends import RemoteUserBackend"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from django.core.exceptions import ImproperlyConfigured"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django.utils.functional import SimpleLazyObject"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         try:"
            },
            "6": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             username = request.META[self.header]"
            },
            "7": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         except KeyError:"
            },
            "8": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # If specified header doesn't exist then return (leaving"
            },
            "9": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # request.user set to AnonymousUser by the"
            },
            "10": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # AuthenticationMiddleware)."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            # If specified header doesn't exist then remove any existing"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            # authenticated remote-user, or return (leaving request.user set to"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            # AnonymousUser by the AuthenticationMiddleware)."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            if request.user.is_authenticated():"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                self._remove_invalid_user(request)"
            },
            "16": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "             return"
            },
            "17": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         # If the user is already authenticated and that user is the user we are"
            },
            "18": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         # getting passed in the headers, then the correct user is already"
            },
            "19": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         # persisted in the session and we don't need to continue."
            },
            "20": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         if request.user.is_authenticated():"
            },
            "21": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "             if request.user.username == self.clean_username(username, request):"
            },
            "22": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "                 return"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            else:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                # An authenticated user is associated with the request, but"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+                # it does not match the authorized user in the header."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+                self._remove_invalid_user(request)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         # We are seeing this user for the first time in this session, attempt"
            },
            "29": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         # to authenticate the user."
            },
            "30": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         user = auth.authenticate(remote_user=username)"
            },
            "31": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         except AttributeError: # Backend has no clean_username method."
            },
            "32": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             pass"
            },
            "33": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         return username"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+    def _remove_invalid_user(self, request):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        \"\"\""
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        Removes the current authenticated user in the request which is invalid"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        but only if the user is authenticated via the RemoteUserBackend."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        \"\"\""
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        try:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            stored_backend = auth.load_backend(request.session.get(auth.BACKEND_SESSION_KEY, ''))"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        except ImproperlyConfigured:"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            # backend failed to load"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            auth.logout(request)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        else:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            if isinstance(stored_backend, RemoteUserBackend):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+                auth.logout(request)"
            }
        },
        "frontPatchFile": [
            "from django.contrib import auth",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.functional import SimpleLazyObject",
            "",
            "",
            "def get_user(request):",
            "    if not hasattr(request, '_cached_user'):",
            "        request._cached_user = auth.get_user(request)",
            "    return request._cached_user",
            "",
            "",
            "class AuthenticationMiddleware(object):",
            "    def process_request(self, request):",
            "        assert hasattr(request, 'session'), \"The Django authentication middleware requires session middleware to be installed. Edit your MIDDLEWARE_CLASSES setting to insert 'django.contrib.sessions.middleware.SessionMiddleware'.\"",
            "",
            "        request.user = SimpleLazyObject(lambda: get_user(request))",
            "",
            "",
            "class RemoteUserMiddleware(object):",
            "    \"\"\"",
            "    Middleware for utilizing Web-server-provided authentication.",
            "",
            "    If request.user is not authenticated, then this middleware attempts to",
            "    authenticate the username passed in the ``REMOTE_USER`` request header.",
            "    If authentication is successful, the user is automatically logged in to",
            "    persist the user in the session.",
            "",
            "    The header used is configurable and defaults to ``REMOTE_USER``.  Subclass",
            "    this class and change the ``header`` attribute if you need to use a",
            "    different header.",
            "    \"\"\"",
            "",
            "    # Name of request header to grab username from.  This will be the key as",
            "    # used in the request.META dictionary, i.e. the normalization of headers to",
            "    # all uppercase and the addition of \"HTTP_\" prefix apply.",
            "    header = \"REMOTE_USER\"",
            "",
            "    def process_request(self, request):",
            "        # AuthenticationMiddleware is required so that request.user exists.",
            "        if not hasattr(request, 'user'):",
            "            raise ImproperlyConfigured(",
            "                \"The Django remote user auth middleware requires the\"",
            "                \" authentication middleware to be installed.  Edit your\"",
            "                \" MIDDLEWARE_CLASSES setting to insert\"",
            "                \" 'django.contrib.auth.middleware.AuthenticationMiddleware'\"",
            "                \" before the RemoteUserMiddleware class.\")",
            "        try:",
            "            username = request.META[self.header]",
            "        except KeyError:",
            "            # If specified header doesn't exist then return (leaving",
            "            # request.user set to AnonymousUser by the",
            "            # AuthenticationMiddleware).",
            "            return",
            "        # If the user is already authenticated and that user is the user we are",
            "        # getting passed in the headers, then the correct user is already",
            "        # persisted in the session and we don't need to continue.",
            "        if request.user.is_authenticated():",
            "            if request.user.username == self.clean_username(username, request):",
            "                return",
            "        # We are seeing this user for the first time in this session, attempt",
            "        # to authenticate the user.",
            "        user = auth.authenticate(remote_user=username)",
            "        if user:",
            "            # User is valid.  Set request.user and persist user in the session",
            "            # by logging the user in.",
            "            request.user = user",
            "            auth.login(request, user)",
            "",
            "    def clean_username(self, username, request):",
            "        \"\"\"",
            "        Allows the backend to clean the username, if the backend defines a",
            "        clean_username method.",
            "        \"\"\"",
            "        backend_str = request.session[auth.BACKEND_SESSION_KEY]",
            "        backend = auth.load_backend(backend_str)",
            "        try:",
            "            username = backend.clean_username(username)",
            "        except AttributeError: # Backend has no clean_username method.",
            "            pass",
            "        return username"
        ],
        "afterPatchFile": [
            "from django.contrib import auth",
            "from django.contrib.auth.backends import RemoteUserBackend",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.functional import SimpleLazyObject",
            "",
            "",
            "def get_user(request):",
            "    if not hasattr(request, '_cached_user'):",
            "        request._cached_user = auth.get_user(request)",
            "    return request._cached_user",
            "",
            "",
            "class AuthenticationMiddleware(object):",
            "    def process_request(self, request):",
            "        assert hasattr(request, 'session'), \"The Django authentication middleware requires session middleware to be installed. Edit your MIDDLEWARE_CLASSES setting to insert 'django.contrib.sessions.middleware.SessionMiddleware'.\"",
            "",
            "        request.user = SimpleLazyObject(lambda: get_user(request))",
            "",
            "",
            "class RemoteUserMiddleware(object):",
            "    \"\"\"",
            "    Middleware for utilizing Web-server-provided authentication.",
            "",
            "    If request.user is not authenticated, then this middleware attempts to",
            "    authenticate the username passed in the ``REMOTE_USER`` request header.",
            "    If authentication is successful, the user is automatically logged in to",
            "    persist the user in the session.",
            "",
            "    The header used is configurable and defaults to ``REMOTE_USER``.  Subclass",
            "    this class and change the ``header`` attribute if you need to use a",
            "    different header.",
            "    \"\"\"",
            "",
            "    # Name of request header to grab username from.  This will be the key as",
            "    # used in the request.META dictionary, i.e. the normalization of headers to",
            "    # all uppercase and the addition of \"HTTP_\" prefix apply.",
            "    header = \"REMOTE_USER\"",
            "",
            "    def process_request(self, request):",
            "        # AuthenticationMiddleware is required so that request.user exists.",
            "        if not hasattr(request, 'user'):",
            "            raise ImproperlyConfigured(",
            "                \"The Django remote user auth middleware requires the\"",
            "                \" authentication middleware to be installed.  Edit your\"",
            "                \" MIDDLEWARE_CLASSES setting to insert\"",
            "                \" 'django.contrib.auth.middleware.AuthenticationMiddleware'\"",
            "                \" before the RemoteUserMiddleware class.\")",
            "        try:",
            "            username = request.META[self.header]",
            "        except KeyError:",
            "            # If specified header doesn't exist then remove any existing",
            "            # authenticated remote-user, or return (leaving request.user set to",
            "            # AnonymousUser by the AuthenticationMiddleware).",
            "            if request.user.is_authenticated():",
            "                self._remove_invalid_user(request)",
            "            return",
            "        # If the user is already authenticated and that user is the user we are",
            "        # getting passed in the headers, then the correct user is already",
            "        # persisted in the session and we don't need to continue.",
            "        if request.user.is_authenticated():",
            "            if request.user.username == self.clean_username(username, request):",
            "                return",
            "            else:",
            "                # An authenticated user is associated with the request, but",
            "                # it does not match the authorized user in the header.",
            "                self._remove_invalid_user(request)",
            "",
            "        # We are seeing this user for the first time in this session, attempt",
            "        # to authenticate the user.",
            "        user = auth.authenticate(remote_user=username)",
            "        if user:",
            "            # User is valid.  Set request.user and persist user in the session",
            "            # by logging the user in.",
            "            request.user = user",
            "            auth.login(request, user)",
            "",
            "    def clean_username(self, username, request):",
            "        \"\"\"",
            "        Allows the backend to clean the username, if the backend defines a",
            "        clean_username method.",
            "        \"\"\"",
            "        backend_str = request.session[auth.BACKEND_SESSION_KEY]",
            "        backend = auth.load_backend(backend_str)",
            "        try:",
            "            username = backend.clean_username(username)",
            "        except AttributeError: # Backend has no clean_username method.",
            "            pass",
            "        return username",
            "",
            "    def _remove_invalid_user(self, request):",
            "        \"\"\"",
            "        Removes the current authenticated user in the request which is invalid",
            "        but only if the user is authenticated via the RemoteUserBackend.",
            "        \"\"\"",
            "        try:",
            "            stored_backend = auth.load_backend(request.session.get(auth.BACKEND_SESSION_KEY, ''))",
            "        except ImproperlyConfigured:",
            "            # backend failed to load",
            "            auth.logout(request)",
            "        else:",
            "            if isinstance(stored_backend, RemoteUserBackend):",
            "                auth.logout(request)"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "50": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "51": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "52": [
                "RemoteUserMiddleware",
                "process_request"
            ]
        },
        "addLocation": []
    },
    "django/contrib/auth/tests/remote_user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         response = self.client.get('/remote_user/', REMOTE_USER=self.known_user)"
            },
            "1": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         self.assertEqual(default_login, response.context['user'].last_login)"
            },
            "2": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+    def test_user_switch_forces_new_login(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        Tests that if the username in the header changes between requests"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        that the original user is logged out"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        \"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        User.objects.create(username='knownuser')"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        # Known user authenticates"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        response = self.client.get('/remote_user/',"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+                                   **{'REMOTE_USER': self.known_user})"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        self.assertEqual(response.context['user'].username, 'knownuser')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        # During the session, the REMOTE_USER changes to a different user."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+        response = self.client.get('/remote_user/',"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+                                   **{'REMOTE_USER': \"newnewuser\"})"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        # Ensure that the current user is not the prior remote_user"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        # In backends that create a new user, username is \"newnewuser\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        # In backends that do not create new users, it is '' (anonymous user)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        self.assertNotEqual(response.context['user'].username, 'knownuser')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     def tearDown(self):"
            },
            "22": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         \"\"\"Restores settings to avoid breaking other tests.\"\"\""
            },
            "23": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         settings.MIDDLEWARE_CLASSES = self.curr_middleware"
            }
        },
        "frontPatchFile": [
            "from datetime import datetime",
            "",
            "from django.conf import settings",
            "from django.contrib.auth.backends import RemoteUserBackend",
            "from django.contrib.auth.models import User",
            "from django.test import TestCase",
            "from django.utils import timezone",
            "",
            "",
            "class RemoteUserTest(TestCase):",
            "",
            "    urls = 'django.contrib.auth.tests.urls'",
            "    middleware = 'django.contrib.auth.middleware.RemoteUserMiddleware'",
            "    backend = 'django.contrib.auth.backends.RemoteUserBackend'",
            "",
            "    # Usernames to be passed in REMOTE_USER for the test_known_user test case.",
            "    known_user = 'knownuser'",
            "    known_user2 = 'knownuser2'",
            "",
            "    def setUp(self):",
            "        self.curr_middleware = settings.MIDDLEWARE_CLASSES",
            "        self.curr_auth = settings.AUTHENTICATION_BACKENDS",
            "        settings.MIDDLEWARE_CLASSES += (self.middleware,)",
            "        settings.AUTHENTICATION_BACKENDS = (self.backend,)",
            "",
            "    def test_no_remote_user(self):",
            "        \"\"\"",
            "        Tests requests where no remote user is specified and insures that no",
            "        users get created.",
            "        \"\"\"",
            "        num_users = User.objects.count()",
            "",
            "        response = self.client.get('/remote_user/')",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "        response = self.client.get('/remote_user/', REMOTE_USER=None)",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "        response = self.client.get('/remote_user/', REMOTE_USER='')",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "    def test_unknown_user(self):",
            "        \"\"\"",
            "        Tests the case where the username passed in the header does not exist",
            "        as a User.",
            "        \"\"\"",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', REMOTE_USER='newuser')",
            "        self.assertEqual(response.context['user'].username, 'newuser')",
            "        self.assertEqual(User.objects.count(), num_users + 1)",
            "        User.objects.get(username='newuser')",
            "",
            "        # Another request with same user should not create any new users.",
            "        response = self.client.get('/remote_user/', REMOTE_USER='newuser')",
            "        self.assertEqual(User.objects.count(), num_users + 1)",
            "",
            "    def test_known_user(self):",
            "        \"\"\"",
            "        Tests the case where the username passed in the header is a valid User.",
            "        \"\"\"",
            "        User.objects.create(username='knownuser')",
            "        User.objects.create(username='knownuser2')",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', REMOTE_USER=self.known_user)",
            "        self.assertEqual(response.context['user'].username, 'knownuser')",
            "        self.assertEqual(User.objects.count(), num_users)",
            "        # Test that a different user passed in the headers causes the new user",
            "        # to be logged in.",
            "        response = self.client.get('/remote_user/', REMOTE_USER=self.known_user2)",
            "        self.assertEqual(response.context['user'].username, 'knownuser2')",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "    def test_last_login(self):",
            "        \"\"\"",
            "        Tests that a user's last_login is set the first time they make a",
            "        request but not updated in subsequent requests with the same session.",
            "        \"\"\"",
            "        user = User.objects.create(username='knownuser')",
            "        # Set last_login to something so we can determine if it changes.",
            "        default_login = datetime(2000, 1, 1)",
            "        if settings.USE_TZ:",
            "            default_login = default_login.replace(tzinfo=timezone.utc)",
            "        user.last_login = default_login",
            "        user.save()",
            "",
            "        response = self.client.get('/remote_user/', REMOTE_USER=self.known_user)",
            "        self.assertNotEqual(default_login, response.context['user'].last_login)",
            "",
            "        user = User.objects.get(username='knownuser')",
            "        user.last_login = default_login",
            "        user.save()",
            "        response = self.client.get('/remote_user/', REMOTE_USER=self.known_user)",
            "        self.assertEqual(default_login, response.context['user'].last_login)",
            "",
            "    def tearDown(self):",
            "        \"\"\"Restores settings to avoid breaking other tests.\"\"\"",
            "        settings.MIDDLEWARE_CLASSES = self.curr_middleware",
            "        settings.AUTHENTICATION_BACKENDS = self.curr_auth",
            "",
            "",
            "class RemoteUserNoCreateBackend(RemoteUserBackend):",
            "    \"\"\"Backend that doesn't create unknown users.\"\"\"",
            "    create_unknown_user = False",
            "",
            "",
            "class RemoteUserNoCreateTest(RemoteUserTest):",
            "    \"\"\"",
            "    Contains the same tests as RemoteUserTest, but using a custom auth backend",
            "    class that doesn't create unknown users.",
            "    \"\"\"",
            "",
            "    backend =\\",
            "        'django.contrib.auth.tests.remote_user.RemoteUserNoCreateBackend'",
            "",
            "    def test_unknown_user(self):",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', REMOTE_USER='newuser')",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "",
            "class CustomRemoteUserBackend(RemoteUserBackend):",
            "    \"\"\"",
            "    Backend that overrides RemoteUserBackend methods.",
            "    \"\"\"",
            "",
            "    def clean_username(self, username):",
            "        \"\"\"",
            "        Grabs username before the @ character.",
            "        \"\"\"",
            "        return username.split('@')[0]",
            "",
            "    def configure_user(self, user):",
            "        \"\"\"",
            "        Sets user's email address.",
            "        \"\"\"",
            "        user.email = 'user@example.com'",
            "        user.save()",
            "        return user",
            "",
            "",
            "class RemoteUserCustomTest(RemoteUserTest):",
            "    \"\"\"",
            "    Tests a custom RemoteUserBackend subclass that overrides the clean_username",
            "    and configure_user methods.",
            "    \"\"\"",
            "",
            "    backend =\\",
            "        'django.contrib.auth.tests.remote_user.CustomRemoteUserBackend'",
            "    # REMOTE_USER strings with email addresses for the custom backend to",
            "    # clean.",
            "    known_user = 'knownuser@example.com'",
            "    known_user2 = 'knownuser2@example.com'",
            "",
            "    def test_known_user(self):",
            "        \"\"\"",
            "        The strings passed in REMOTE_USER should be cleaned and the known users",
            "        should not have been configured with an email address.",
            "        \"\"\"",
            "        super(RemoteUserCustomTest, self).test_known_user()",
            "        self.assertEqual(User.objects.get(username='knownuser').email, '')",
            "        self.assertEqual(User.objects.get(username='knownuser2').email, '')",
            "",
            "    def test_unknown_user(self):",
            "        \"\"\"",
            "        The unknown user created should be configured with an email address.",
            "        \"\"\"",
            "        super(RemoteUserCustomTest, self).test_unknown_user()",
            "        newuser = User.objects.get(username='newuser')",
            "        self.assertEqual(newuser.email, 'user@example.com')"
        ],
        "afterPatchFile": [
            "from datetime import datetime",
            "",
            "from django.conf import settings",
            "from django.contrib.auth.backends import RemoteUserBackend",
            "from django.contrib.auth.models import User",
            "from django.test import TestCase",
            "from django.utils import timezone",
            "",
            "",
            "class RemoteUserTest(TestCase):",
            "",
            "    urls = 'django.contrib.auth.tests.urls'",
            "    middleware = 'django.contrib.auth.middleware.RemoteUserMiddleware'",
            "    backend = 'django.contrib.auth.backends.RemoteUserBackend'",
            "",
            "    # Usernames to be passed in REMOTE_USER for the test_known_user test case.",
            "    known_user = 'knownuser'",
            "    known_user2 = 'knownuser2'",
            "",
            "    def setUp(self):",
            "        self.curr_middleware = settings.MIDDLEWARE_CLASSES",
            "        self.curr_auth = settings.AUTHENTICATION_BACKENDS",
            "        settings.MIDDLEWARE_CLASSES += (self.middleware,)",
            "        settings.AUTHENTICATION_BACKENDS = (self.backend,)",
            "",
            "    def test_no_remote_user(self):",
            "        \"\"\"",
            "        Tests requests where no remote user is specified and insures that no",
            "        users get created.",
            "        \"\"\"",
            "        num_users = User.objects.count()",
            "",
            "        response = self.client.get('/remote_user/')",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "        response = self.client.get('/remote_user/', REMOTE_USER=None)",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "        response = self.client.get('/remote_user/', REMOTE_USER='')",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "    def test_unknown_user(self):",
            "        \"\"\"",
            "        Tests the case where the username passed in the header does not exist",
            "        as a User.",
            "        \"\"\"",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', REMOTE_USER='newuser')",
            "        self.assertEqual(response.context['user'].username, 'newuser')",
            "        self.assertEqual(User.objects.count(), num_users + 1)",
            "        User.objects.get(username='newuser')",
            "",
            "        # Another request with same user should not create any new users.",
            "        response = self.client.get('/remote_user/', REMOTE_USER='newuser')",
            "        self.assertEqual(User.objects.count(), num_users + 1)",
            "",
            "    def test_known_user(self):",
            "        \"\"\"",
            "        Tests the case where the username passed in the header is a valid User.",
            "        \"\"\"",
            "        User.objects.create(username='knownuser')",
            "        User.objects.create(username='knownuser2')",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', REMOTE_USER=self.known_user)",
            "        self.assertEqual(response.context['user'].username, 'knownuser')",
            "        self.assertEqual(User.objects.count(), num_users)",
            "        # Test that a different user passed in the headers causes the new user",
            "        # to be logged in.",
            "        response = self.client.get('/remote_user/', REMOTE_USER=self.known_user2)",
            "        self.assertEqual(response.context['user'].username, 'knownuser2')",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "    def test_last_login(self):",
            "        \"\"\"",
            "        Tests that a user's last_login is set the first time they make a",
            "        request but not updated in subsequent requests with the same session.",
            "        \"\"\"",
            "        user = User.objects.create(username='knownuser')",
            "        # Set last_login to something so we can determine if it changes.",
            "        default_login = datetime(2000, 1, 1)",
            "        if settings.USE_TZ:",
            "            default_login = default_login.replace(tzinfo=timezone.utc)",
            "        user.last_login = default_login",
            "        user.save()",
            "",
            "        response = self.client.get('/remote_user/', REMOTE_USER=self.known_user)",
            "        self.assertNotEqual(default_login, response.context['user'].last_login)",
            "",
            "        user = User.objects.get(username='knownuser')",
            "        user.last_login = default_login",
            "        user.save()",
            "        response = self.client.get('/remote_user/', REMOTE_USER=self.known_user)",
            "        self.assertEqual(default_login, response.context['user'].last_login)",
            "",
            "    def test_user_switch_forces_new_login(self):",
            "        \"\"\"",
            "        Tests that if the username in the header changes between requests",
            "        that the original user is logged out",
            "        \"\"\"",
            "        User.objects.create(username='knownuser')",
            "        # Known user authenticates",
            "        response = self.client.get('/remote_user/',",
            "                                   **{'REMOTE_USER': self.known_user})",
            "        self.assertEqual(response.context['user'].username, 'knownuser')",
            "        # During the session, the REMOTE_USER changes to a different user.",
            "        response = self.client.get('/remote_user/',",
            "                                   **{'REMOTE_USER': \"newnewuser\"})",
            "        # Ensure that the current user is not the prior remote_user",
            "        # In backends that create a new user, username is \"newnewuser\"",
            "        # In backends that do not create new users, it is '' (anonymous user)",
            "        self.assertNotEqual(response.context['user'].username, 'knownuser')",
            "",
            "    def tearDown(self):",
            "        \"\"\"Restores settings to avoid breaking other tests.\"\"\"",
            "        settings.MIDDLEWARE_CLASSES = self.curr_middleware",
            "        settings.AUTHENTICATION_BACKENDS = self.curr_auth",
            "",
            "",
            "class RemoteUserNoCreateBackend(RemoteUserBackend):",
            "    \"\"\"Backend that doesn't create unknown users.\"\"\"",
            "    create_unknown_user = False",
            "",
            "",
            "class RemoteUserNoCreateTest(RemoteUserTest):",
            "    \"\"\"",
            "    Contains the same tests as RemoteUserTest, but using a custom auth backend",
            "    class that doesn't create unknown users.",
            "    \"\"\"",
            "",
            "    backend =\\",
            "        'django.contrib.auth.tests.remote_user.RemoteUserNoCreateBackend'",
            "",
            "    def test_unknown_user(self):",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', REMOTE_USER='newuser')",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "",
            "class CustomRemoteUserBackend(RemoteUserBackend):",
            "    \"\"\"",
            "    Backend that overrides RemoteUserBackend methods.",
            "    \"\"\"",
            "",
            "    def clean_username(self, username):",
            "        \"\"\"",
            "        Grabs username before the @ character.",
            "        \"\"\"",
            "        return username.split('@')[0]",
            "",
            "    def configure_user(self, user):",
            "        \"\"\"",
            "        Sets user's email address.",
            "        \"\"\"",
            "        user.email = 'user@example.com'",
            "        user.save()",
            "        return user",
            "",
            "",
            "class RemoteUserCustomTest(RemoteUserTest):",
            "    \"\"\"",
            "    Tests a custom RemoteUserBackend subclass that overrides the clean_username",
            "    and configure_user methods.",
            "    \"\"\"",
            "",
            "    backend =\\",
            "        'django.contrib.auth.tests.remote_user.CustomRemoteUserBackend'",
            "    # REMOTE_USER strings with email addresses for the custom backend to",
            "    # clean.",
            "    known_user = 'knownuser@example.com'",
            "    known_user2 = 'knownuser2@example.com'",
            "",
            "    def test_known_user(self):",
            "        \"\"\"",
            "        The strings passed in REMOTE_USER should be cleaned and the known users",
            "        should not have been configured with an email address.",
            "        \"\"\"",
            "        super(RemoteUserCustomTest, self).test_known_user()",
            "        self.assertEqual(User.objects.get(username='knownuser').email, '')",
            "        self.assertEqual(User.objects.get(username='knownuser2').email, '')",
            "",
            "    def test_unknown_user(self):",
            "        \"\"\"",
            "        The unknown user created should be configured with an email address.",
            "        \"\"\"",
            "        super(RemoteUserCustomTest, self).test_unknown_user()",
            "        newuser = User.objects.get(username='newuser')",
            "        self.assertEqual(newuser.email, 'user@example.com')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "shuup.front.urls",
            "django.contrib.auth.tests.remote_user.RemoteUserTest.self"
        ]
    }
}