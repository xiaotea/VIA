{
    "anymail/webhooks/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import six"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django.http import HttpResponse"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from django.utils.crypto import constant_time_compare"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.utils.decorators import method_decorator"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from django.views.decorators.csrf import csrf_exempt"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.views.generic import View"
            },
            "7": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     def validate_request(self, request):"
            },
            "8": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         \"\"\"If configured for webhook basic auth, validate request has correct auth.\"\"\""
            },
            "9": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         if self.basic_auth:"
            },
            "10": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            basic_auth = get_request_basic_auth(request)"
            },
            "11": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if basic_auth is None or basic_auth not in self.basic_auth:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            request_auth = get_request_basic_auth(request)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            # can terminate early: we're not trying to protect how many auth strings are allowed,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+            # just the contents of each individual auth string.)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            auth_ok = any(constant_time_compare(request_auth, allowed_auth)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                          for allowed_auth in self.basic_auth)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            if not auth_ok:"
            },
            "19": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                 # noinspection PyUnresolvedReferences"
            },
            "20": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 raise AnymailWebhookValidationFailure("
            },
            "21": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "                     \"Missing or invalid basic auth in Anymail %s webhook\" % self.esp_name)"
            },
            "22": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         *All* definitions of this method in the class chain (including mixins)"
            },
            "23": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         will be called. There is no need to chain to the superclass."
            },
            "24": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         (See self.run_validators and collect_all_methods.)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+        Security note: use django.utils.crypto.constant_time_compare for string"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        comparisons, to avoid exposing your validation to a timing attack."
            },
            "28": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         \"\"\""
            },
            "29": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # if request.POST['signature'] != expected_signature:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        # if not constant_time_compare(request.POST['signature'], expected_signature):"
            },
            "31": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         #     raise AnymailWebhookValidationFailure(\"...message...\")"
            },
            "32": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         # (else just do nothing)"
            },
            "33": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         pass"
            }
        },
        "frontPatchFile": [
            "import warnings",
            "",
            "import six",
            "from django.http import HttpResponse",
            "from django.utils.decorators import method_decorator",
            "from django.views.decorators.csrf import csrf_exempt",
            "from django.views.generic import View",
            "",
            "from ..exceptions import AnymailInsecureWebhookWarning, AnymailWebhookValidationFailure",
            "from ..utils import get_anymail_setting, collect_all_methods, get_request_basic_auth",
            "",
            "",
            "class AnymailBasicAuthMixin(object):",
            "    \"\"\"Implements webhook basic auth as mixin to AnymailBaseWebhookView.\"\"\"",
            "",
            "    # Whether to warn if basic auth is not configured.",
            "    # For most ESPs, basic auth is the only webhook security,",
            "    # so the default is True. Subclasses can set False if",
            "    # they enforce other security (like signed webhooks).",
            "    warn_if_no_basic_auth = True",
            "",
            "    # List of allowable HTTP basic-auth 'user:pass' strings.",
            "    basic_auth = None  # (Declaring class attr allows override by kwargs in View.as_view.)",
            "",
            "    def __init__(self, **kwargs):",
            "        self.basic_auth = get_anymail_setting('webhook_authorization', default=[],",
            "                                              kwargs=kwargs)  # no esp_name -- auth is shared between ESPs",
            "        # Allow a single string:",
            "        if isinstance(self.basic_auth, six.string_types):",
            "            self.basic_auth = [self.basic_auth]",
            "        if self.warn_if_no_basic_auth and len(self.basic_auth) < 1:",
            "            warnings.warn(",
            "                \"Your Anymail webhooks are insecure and open to anyone on the web. \"",
            "                \"You should set WEBHOOK_AUTHORIZATION in your ANYMAIL settings. \"",
            "                \"See 'Securing webhooks' in the Anymail docs.\",",
            "                AnymailInsecureWebhookWarning)",
            "        # noinspection PyArgumentList",
            "        super(AnymailBasicAuthMixin, self).__init__(**kwargs)",
            "",
            "    def validate_request(self, request):",
            "        \"\"\"If configured for webhook basic auth, validate request has correct auth.\"\"\"",
            "        if self.basic_auth:",
            "            basic_auth = get_request_basic_auth(request)",
            "            if basic_auth is None or basic_auth not in self.basic_auth:",
            "                # noinspection PyUnresolvedReferences",
            "                raise AnymailWebhookValidationFailure(",
            "                    \"Missing or invalid basic auth in Anymail %s webhook\" % self.esp_name)",
            "",
            "",
            "# Mixin note: Django's View.__init__ doesn't cooperate with chaining,",
            "# so all mixins that need __init__ must appear before View in MRO.",
            "class AnymailBaseWebhookView(AnymailBasicAuthMixin, View):",
            "    \"\"\"Base view for processing ESP event webhooks",
            "",
            "    ESP-specific implementations should subclass",
            "    and implement parse_events. They may also",
            "    want to implement validate_request",
            "    if additional security is available.",
            "    \"\"\"",
            "",
            "    def __init__(self, **kwargs):",
            "        super(AnymailBaseWebhookView, self).__init__(**kwargs)",
            "        self.validators = collect_all_methods(self.__class__, 'validate_request')",
            "",
            "    # Subclass implementation:",
            "",
            "    # Where to send events: either ..signals.inbound or ..signals.tracking",
            "    signal = None",
            "",
            "    def validate_request(self, request):",
            "        \"\"\"Check validity of webhook post, or raise AnymailWebhookValidationFailure.",
            "",
            "        AnymailBaseWebhookView includes basic auth validation.",
            "        Subclasses can implement (or provide via mixins) if the ESP supports",
            "        additional validation (such as signature checking).",
            "",
            "        *All* definitions of this method in the class chain (including mixins)",
            "        will be called. There is no need to chain to the superclass.",
            "        (See self.run_validators and collect_all_methods.)",
            "        \"\"\"",
            "        # if request.POST['signature'] != expected_signature:",
            "        #     raise AnymailWebhookValidationFailure(\"...message...\")",
            "        # (else just do nothing)",
            "        pass",
            "",
            "    def parse_events(self, request):",
            "        \"\"\"Return a list of normalized AnymailWebhookEvent extracted from ESP post data.",
            "",
            "        Subclasses must implement.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    # HTTP handlers (subclasses shouldn't need to override):",
            "",
            "    http_method_names = [\"post\", \"head\", \"options\"]",
            "",
            "    @method_decorator(csrf_exempt)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        return super(AnymailBaseWebhookView, self).dispatch(request, *args, **kwargs)",
            "",
            "    def head(self, request, *args, **kwargs):",
            "        # Some ESPs verify the webhook with a HEAD request at configuration time",
            "        return HttpResponse()",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        # Normal Django exception handling will do the right thing:",
            "        # - AnymailWebhookValidationFailure will turn into an HTTP 400 response",
            "        #   (via Django SuspiciousOperation handling)",
            "        # - Any other errors (e.g., in signal dispatch) will turn into HTTP 500",
            "        #   responses (via normal Django error handling). ESPs generally",
            "        #   treat that as \"try again later\".",
            "        self.run_validators(request)",
            "        events = self.parse_events(request)",
            "        esp_name = self.esp_name",
            "        for event in events:",
            "            self.signal.send(sender=self.__class__, event=event, esp_name=esp_name)",
            "        return HttpResponse()",
            "",
            "    # Request validation (subclasses shouldn't need to override):",
            "",
            "    def run_validators(self, request):",
            "        for validator in self.validators:",
            "            validator(self, request)",
            "",
            "    @property",
            "    def esp_name(self):",
            "        \"\"\"",
            "        Read-only name of the ESP for this webhook view.",
            "",
            "        Subclasses must override with class attr. E.g.:",
            "            esp_name = \"Postmark\"",
            "            esp_name = \"SendGrid\"  # (use ESP's preferred capitalization)",
            "        \"\"\"",
            "        raise NotImplementedError(\"%s.%s must declare esp_name class attr\" %",
            "                                  (self.__class__.__module__, self.__class__.__name__))"
        ],
        "afterPatchFile": [
            "import warnings",
            "",
            "import six",
            "from django.http import HttpResponse",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.decorators import method_decorator",
            "from django.views.decorators.csrf import csrf_exempt",
            "from django.views.generic import View",
            "",
            "from ..exceptions import AnymailInsecureWebhookWarning, AnymailWebhookValidationFailure",
            "from ..utils import get_anymail_setting, collect_all_methods, get_request_basic_auth",
            "",
            "",
            "class AnymailBasicAuthMixin(object):",
            "    \"\"\"Implements webhook basic auth as mixin to AnymailBaseWebhookView.\"\"\"",
            "",
            "    # Whether to warn if basic auth is not configured.",
            "    # For most ESPs, basic auth is the only webhook security,",
            "    # so the default is True. Subclasses can set False if",
            "    # they enforce other security (like signed webhooks).",
            "    warn_if_no_basic_auth = True",
            "",
            "    # List of allowable HTTP basic-auth 'user:pass' strings.",
            "    basic_auth = None  # (Declaring class attr allows override by kwargs in View.as_view.)",
            "",
            "    def __init__(self, **kwargs):",
            "        self.basic_auth = get_anymail_setting('webhook_authorization', default=[],",
            "                                              kwargs=kwargs)  # no esp_name -- auth is shared between ESPs",
            "        # Allow a single string:",
            "        if isinstance(self.basic_auth, six.string_types):",
            "            self.basic_auth = [self.basic_auth]",
            "        if self.warn_if_no_basic_auth and len(self.basic_auth) < 1:",
            "            warnings.warn(",
            "                \"Your Anymail webhooks are insecure and open to anyone on the web. \"",
            "                \"You should set WEBHOOK_AUTHORIZATION in your ANYMAIL settings. \"",
            "                \"See 'Securing webhooks' in the Anymail docs.\",",
            "                AnymailInsecureWebhookWarning)",
            "        # noinspection PyArgumentList",
            "        super(AnymailBasicAuthMixin, self).__init__(**kwargs)",
            "",
            "    def validate_request(self, request):",
            "        \"\"\"If configured for webhook basic auth, validate request has correct auth.\"\"\"",
            "        if self.basic_auth:",
            "            request_auth = get_request_basic_auth(request)",
            "            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()",
            "            # can terminate early: we're not trying to protect how many auth strings are allowed,",
            "            # just the contents of each individual auth string.)",
            "            auth_ok = any(constant_time_compare(request_auth, allowed_auth)",
            "                          for allowed_auth in self.basic_auth)",
            "            if not auth_ok:",
            "                # noinspection PyUnresolvedReferences",
            "                raise AnymailWebhookValidationFailure(",
            "                    \"Missing or invalid basic auth in Anymail %s webhook\" % self.esp_name)",
            "",
            "",
            "# Mixin note: Django's View.__init__ doesn't cooperate with chaining,",
            "# so all mixins that need __init__ must appear before View in MRO.",
            "class AnymailBaseWebhookView(AnymailBasicAuthMixin, View):",
            "    \"\"\"Base view for processing ESP event webhooks",
            "",
            "    ESP-specific implementations should subclass",
            "    and implement parse_events. They may also",
            "    want to implement validate_request",
            "    if additional security is available.",
            "    \"\"\"",
            "",
            "    def __init__(self, **kwargs):",
            "        super(AnymailBaseWebhookView, self).__init__(**kwargs)",
            "        self.validators = collect_all_methods(self.__class__, 'validate_request')",
            "",
            "    # Subclass implementation:",
            "",
            "    # Where to send events: either ..signals.inbound or ..signals.tracking",
            "    signal = None",
            "",
            "    def validate_request(self, request):",
            "        \"\"\"Check validity of webhook post, or raise AnymailWebhookValidationFailure.",
            "",
            "        AnymailBaseWebhookView includes basic auth validation.",
            "        Subclasses can implement (or provide via mixins) if the ESP supports",
            "        additional validation (such as signature checking).",
            "",
            "        *All* definitions of this method in the class chain (including mixins)",
            "        will be called. There is no need to chain to the superclass.",
            "        (See self.run_validators and collect_all_methods.)",
            "",
            "        Security note: use django.utils.crypto.constant_time_compare for string",
            "        comparisons, to avoid exposing your validation to a timing attack.",
            "        \"\"\"",
            "        # if not constant_time_compare(request.POST['signature'], expected_signature):",
            "        #     raise AnymailWebhookValidationFailure(\"...message...\")",
            "        # (else just do nothing)",
            "        pass",
            "",
            "    def parse_events(self, request):",
            "        \"\"\"Return a list of normalized AnymailWebhookEvent extracted from ESP post data.",
            "",
            "        Subclasses must implement.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    # HTTP handlers (subclasses shouldn't need to override):",
            "",
            "    http_method_names = [\"post\", \"head\", \"options\"]",
            "",
            "    @method_decorator(csrf_exempt)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        return super(AnymailBaseWebhookView, self).dispatch(request, *args, **kwargs)",
            "",
            "    def head(self, request, *args, **kwargs):",
            "        # Some ESPs verify the webhook with a HEAD request at configuration time",
            "        return HttpResponse()",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        # Normal Django exception handling will do the right thing:",
            "        # - AnymailWebhookValidationFailure will turn into an HTTP 400 response",
            "        #   (via Django SuspiciousOperation handling)",
            "        # - Any other errors (e.g., in signal dispatch) will turn into HTTP 500",
            "        #   responses (via normal Django error handling). ESPs generally",
            "        #   treat that as \"try again later\".",
            "        self.run_validators(request)",
            "        events = self.parse_events(request)",
            "        esp_name = self.esp_name",
            "        for event in events:",
            "            self.signal.send(sender=self.__class__, event=event, esp_name=esp_name)",
            "        return HttpResponse()",
            "",
            "    # Request validation (subclasses shouldn't need to override):",
            "",
            "    def run_validators(self, request):",
            "        for validator in self.validators:",
            "            validator(self, request)",
            "",
            "    @property",
            "    def esp_name(self):",
            "        \"\"\"",
            "        Read-only name of the ESP for this webhook view.",
            "",
            "        Subclasses must override with class attr. E.g.:",
            "            esp_name = \"Postmark\"",
            "            esp_name = \"SendGrid\"  # (use ESP's preferred capitalization)",
            "        \"\"\"",
            "        raise NotImplementedError(\"%s.%s must declare esp_name class attr\" %",
            "                                  (self.__class__.__module__, self.__class__.__name__))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "43": [
                "AnymailBasicAuthMixin",
                "validate_request"
            ],
            "44": [
                "AnymailBasicAuthMixin",
                "validate_request"
            ],
            "81": [
                "AnymailBaseWebhookView",
                "validate_request"
            ]
        },
        "addLocation": []
    }
}