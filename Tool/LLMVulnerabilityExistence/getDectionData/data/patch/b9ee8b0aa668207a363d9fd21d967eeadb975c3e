{
    "src/webargs/bottleparser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     def load_form(self, req, schema):"
            },
            "2": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         \"\"\"Return form values from the request as a MultiDictProxy.\"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        # For consistency with other parsers' behavior, don't attempt to"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        #  parse if content-type is mismatched."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        #  TODO: Make this check more specific"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        if core.is_json(req.content_type):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            return core.missing"
            },
            "8": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         return MultiDictProxy(req.forms, schema)"
            },
            "9": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     def load_headers(self, req, schema):"
            }
        },
        "frontPatchFile": [
            "\"\"\"Bottle request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    from bottle import route, run",
            "    from marshmallow import fields",
            "    from webargs.bottleparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "    @route('/', method='GET', apply=use_args(hello_args))",
            "    def index(args):",
            "        return 'Hello ' + args['name']",
            "",
            "    if __name__ == '__main__':",
            "        run(debug=True)",
            "\"\"\"",
            "import bottle",
            "",
            "from webargs import core",
            "from webargs.multidictproxy import MultiDictProxy",
            "",
            "",
            "class BottleParser(core.Parser):",
            "    \"\"\"Bottle.py request argument parser.\"\"\"",
            "",
            "    def _handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        raise bottle.HTTPError(",
            "            status=400, body={\"json\": [\"Invalid JSON body.\"]}, exception=error",
            "        )",
            "",
            "    def _raw_load_json(self, req):",
            "        \"\"\"Read a json payload from the request.\"\"\"",
            "        try:",
            "            data = req.json",
            "        except AttributeError:",
            "            return core.missing",
            "",
            "        # unfortunately, bottle does not distinguish between an emtpy body, \"\",",
            "        # and a body containing the valid JSON value null, \"null\"",
            "        # so these can't be properly disambiguated",
            "        # as our best-effort solution, treat None as missing and ignore the",
            "        # (admittedly unusual) \"null\" case",
            "        # see: https://github.com/bottlepy/bottle/issues/1160",
            "        if data is None:",
            "            return core.missing",
            "        else:",
            "            return data",
            "",
            "    def load_querystring(self, req, schema):",
            "        \"\"\"Return query params from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.query, schema)",
            "",
            "    def load_form(self, req, schema):",
            "        \"\"\"Return form values from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.forms, schema)",
            "",
            "    def load_headers(self, req, schema):",
            "        \"\"\"Return headers from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.headers, schema)",
            "",
            "    def load_cookies(self, req, schema):",
            "        \"\"\"Return cookies from the request.\"\"\"",
            "        return req.cookies",
            "",
            "    def load_files(self, req, schema):",
            "        \"\"\"Return files from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.files, schema)",
            "",
            "    def handle_error(self, error, req, schema, error_status_code, error_headers):",
            "        \"\"\"Handles errors during parsing. Aborts the current request with a",
            "        400 error.",
            "        \"\"\"",
            "        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS",
            "        raise bottle.HTTPError(",
            "            status=status_code,",
            "            body=error.messages,",
            "            headers=error_headers,",
            "            exception=error,",
            "        )",
            "",
            "    def get_default_request(self):",
            "        \"\"\"Override to use bottle's thread-local request object by default.\"\"\"",
            "        return bottle.request",
            "",
            "",
            "parser = BottleParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "afterPatchFile": [
            "\"\"\"Bottle request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    from bottle import route, run",
            "    from marshmallow import fields",
            "    from webargs.bottleparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "    @route('/', method='GET', apply=use_args(hello_args))",
            "    def index(args):",
            "        return 'Hello ' + args['name']",
            "",
            "    if __name__ == '__main__':",
            "        run(debug=True)",
            "\"\"\"",
            "import bottle",
            "",
            "from webargs import core",
            "from webargs.multidictproxy import MultiDictProxy",
            "",
            "",
            "class BottleParser(core.Parser):",
            "    \"\"\"Bottle.py request argument parser.\"\"\"",
            "",
            "    def _handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        raise bottle.HTTPError(",
            "            status=400, body={\"json\": [\"Invalid JSON body.\"]}, exception=error",
            "        )",
            "",
            "    def _raw_load_json(self, req):",
            "        \"\"\"Read a json payload from the request.\"\"\"",
            "        try:",
            "            data = req.json",
            "        except AttributeError:",
            "            return core.missing",
            "",
            "        # unfortunately, bottle does not distinguish between an emtpy body, \"\",",
            "        # and a body containing the valid JSON value null, \"null\"",
            "        # so these can't be properly disambiguated",
            "        # as our best-effort solution, treat None as missing and ignore the",
            "        # (admittedly unusual) \"null\" case",
            "        # see: https://github.com/bottlepy/bottle/issues/1160",
            "        if data is None:",
            "            return core.missing",
            "        else:",
            "            return data",
            "",
            "    def load_querystring(self, req, schema):",
            "        \"\"\"Return query params from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.query, schema)",
            "",
            "    def load_form(self, req, schema):",
            "        \"\"\"Return form values from the request as a MultiDictProxy.\"\"\"",
            "        # For consistency with other parsers' behavior, don't attempt to",
            "        #  parse if content-type is mismatched.",
            "        #  TODO: Make this check more specific",
            "        if core.is_json(req.content_type):",
            "            return core.missing",
            "        return MultiDictProxy(req.forms, schema)",
            "",
            "    def load_headers(self, req, schema):",
            "        \"\"\"Return headers from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.headers, schema)",
            "",
            "    def load_cookies(self, req, schema):",
            "        \"\"\"Return cookies from the request.\"\"\"",
            "        return req.cookies",
            "",
            "    def load_files(self, req, schema):",
            "        \"\"\"Return files from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.files, schema)",
            "",
            "    def handle_error(self, error, req, schema, error_status_code, error_headers):",
            "        \"\"\"Handles errors during parsing. Aborts the current request with a",
            "        400 error.",
            "        \"\"\"",
            "        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS",
            "        raise bottle.HTTPError(",
            "            status=status_code,",
            "            body=error.messages,",
            "            headers=error_headers,",
            "            exception=error,",
            "        )",
            "",
            "    def get_default_request(self):",
            "        \"\"\"Override to use bottle's thread-local request object by default.\"\"\"",
            "        return bottle.request",
            "",
            "",
            "parser = BottleParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "hpack"
        ]
    },
    "src/webargs/testing.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         )"
            },
            "1": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "         assert res.status_code == 400"
            },
            "2": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         assert res.json == {\"json\": [\"Invalid JSON body.\"]}"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+    @pytest.mark.parametrize("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+        (\"path\", \"payload\", \"content_type\"),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+        ["
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+            ("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+                \"/echo_json\","
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+                json.dumps({\"name\": \"foo\"}),"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+                \"application/x-www-form-urlencoded\","
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+            ),"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+            (\"/echo_form\", {\"name\": \"foo\"}, \"application/json\"),"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+        ],"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+    )"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+    def test_content_type_mismatch(self, testapp, path, payload, content_type):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+        res = testapp.post(path, payload, headers={\"Content-Type\": content_type})"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+        assert res.json == {\"name\": \"World\"}"
            }
        },
        "frontPatchFile": [
            "\"\"\"Utilities for testing. Includes a base test class",
            "for testing parsers.",
            "",
            ".. warning::",
            "",
            "    Methods and functions in this module may change without",
            "    warning and without a major version change.",
            "\"\"\"",
            "import pytest",
            "import webtest",
            "",
            "from webargs.core import json",
            "",
            "",
            "class CommonTestCase:",
            "    \"\"\"Base test class that defines test methods for common functionality across all",
            "    parsers. Subclasses must define `create_app`, which returns a WSGI-like app.",
            "    \"\"\"",
            "",
            "    def create_app(self):",
            "        \"\"\"Return a WSGI app\"\"\"",
            "        raise NotImplementedError(\"Must define create_app()\")",
            "",
            "    def create_testapp(self, app):",
            "        return webtest.TestApp(app)",
            "",
            "    def before_create_app(self):",
            "        pass",
            "",
            "    def after_create_app(self):",
            "        pass",
            "",
            "    @pytest.fixture(scope=\"class\")",
            "    def testapp(self):",
            "        self.before_create_app()",
            "        yield self.create_testapp(self.create_app())",
            "        self.after_create_app()",
            "",
            "    def test_parse_querystring_args(self, testapp):",
            "        assert testapp.get(\"/echo?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_parse_form(self, testapp):",
            "        assert testapp.post(\"/echo_form\", {\"name\": \"Joe\"}).json == {\"name\": \"Joe\"}",
            "",
            "    def test_parse_json(self, testapp):",
            "        assert testapp.post_json(\"/echo_json\", {\"name\": \"Fred\"}).json == {",
            "            \"name\": \"Fred\"",
            "        }",
            "",
            "    def test_parse_json_missing(self, testapp):",
            "        assert testapp.post(\"/echo_json\", \"\").json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_or_form(self, testapp):",
            "        assert testapp.post_json(\"/echo_json_or_form\", {\"name\": \"Fred\"}).json == {",
            "            \"name\": \"Fred\"",
            "        }",
            "        assert testapp.post(\"/echo_json_or_form\", {\"name\": \"Joe\"}).json == {",
            "            \"name\": \"Joe\"",
            "        }",
            "        assert testapp.post(\"/echo_json_or_form\", \"\").json == {\"name\": \"World\"}",
            "",
            "    def test_parse_querystring_default(self, testapp):",
            "        assert testapp.get(\"/echo\").json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_default(self, testapp):",
            "        assert testapp.post_json(\"/echo_json\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_with_charset(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            json.dumps({\"name\": \"Steve\"}),",
            "            content_type=\"application/json;charset=UTF-8\",",
            "        )",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_json_with_vendor_media_type(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            json.dumps({\"name\": \"Steve\"}),",
            "            content_type=\"application/vnd.api+json;charset=UTF-8\",",
            "        )",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_ignore_extra_data(self, testapp):",
            "        assert testapp.post_json(",
            "            \"/echo_ignoring_extra_data\", {\"extra\": \"data\"}",
            "        ).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_empty(self, testapp):",
            "        assert testapp.post_json(\"/echo_json\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_error_unexpected_int(self, testapp):",
            "        res = testapp.post_json(\"/echo_json\", 1, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_error_unexpected_list(self, testapp):",
            "        res = testapp.post_json(\"/echo_json\", [{\"extra\": \"data\"}], expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_many_schema_invalid_input(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_many_schema\", [{\"name\": \"a\"}], expect_errors=True",
            "        )",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_many_schema(self, testapp):",
            "        res = testapp.post_json(\"/echo_many_schema\", [{\"name\": \"Steve\"}]).json",
            "        assert res == [{\"name\": \"Steve\"}]",
            "",
            "    def test_parse_json_many_schema_error_malformed_data(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_many_schema\", {\"extra\": \"data\"}, expect_errors=True",
            "        )",
            "        assert res.status_code == 422",
            "",
            "    def test_parsing_form_default(self, testapp):",
            "        assert testapp.post(\"/echo_form\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_querystring_multiple(self, testapp):",
            "        expected = {\"name\": [\"steve\", \"Loria\"]}",
            "        assert testapp.get(\"/echo_multi?name=steve&name=Loria\").json == expected",
            "",
            "    # test that passing a single value parses correctly",
            "    # on parsers like falconparser, where there is no native MultiDict type,",
            "    # this verifies the usage of MultiDictProxy to ensure that single values",
            "    # are \"listified\"",
            "    def test_parse_querystring_multiple_single_value(self, testapp):",
            "        expected = {\"name\": [\"steve\"]}",
            "        assert testapp.get(\"/echo_multi?name=steve\").json == expected",
            "",
            "    def test_parse_form_multiple(self, testapp):",
            "        expected = {\"name\": [\"steve\", \"Loria\"]}",
            "        assert (",
            "            testapp.post(\"/echo_multi_form\", {\"name\": [\"steve\", \"Loria\"]}).json",
            "            == expected",
            "        )",
            "",
            "    def test_parse_json_list(self, testapp):",
            "        expected = {\"name\": [\"Steve\"]}",
            "        assert (",
            "            testapp.post_json(\"/echo_multi_json\", {\"name\": [\"Steve\"]}).json == expected",
            "        )",
            "",
            "    def test_parse_json_list_error_malformed_data(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_multi_json\", {\"name\": \"Steve\"}, expect_errors=True",
            "        )",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_with_nonascii_chars(self, testapp):",
            "        text = \"\u00f8\u02c6\u0192\u00a3\u00ba\u00ba\u2206\u0192\u02c6\u2206\"",
            "        assert testapp.post_json(\"/echo_json\", {\"name\": text}).json == {\"name\": text}",
            "",
            "    # https://github.com/marshmallow-code/webargs/issues/427",
            "    def test_parse_json_with_nonutf8_chars(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            b\"\\xfe\",",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "            expect_errors=True,",
            "        )",
            "",
            "        assert res.status_code == 400",
            "        assert res.json == {\"json\": [\"Invalid JSON body.\"]}",
            "",
            "    def test_validation_error_returns_422_response(self, testapp):",
            "        res = testapp.post_json(\"/echo_json\", {\"name\": \"b\"}, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_user_validation_error_returns_422_response_by_default(self, testapp):",
            "        res = testapp.post_json(\"/error\", {\"text\": \"foo\"}, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_use_args_decorator(self, testapp):",
            "        assert testapp.get(\"/echo_use_args?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_use_args_with_path_param(self, testapp):",
            "        url = \"/echo_use_args_with_path_param/foo\"",
            "        res = testapp.get(url + \"?value=42\")",
            "        assert res.json == {\"value\": 42}",
            "",
            "    def test_use_args_with_validation(self, testapp):",
            "        result = testapp.post(\"/echo_use_args_validated\", {\"value\": 43})",
            "        assert result.status_code == 200",
            "        result = testapp.post(",
            "            \"/echo_use_args_validated\", {\"value\": 41}, expect_errors=True",
            "        )",
            "        assert result.status_code == 422",
            "",
            "    def test_use_kwargs_decorator(self, testapp):",
            "        assert testapp.get(\"/echo_use_kwargs?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_use_kwargs_with_path_param(self, testapp):",
            "        url = \"/echo_use_kwargs_with_path_param/foo\"",
            "        res = testapp.get(url + \"?value=42\")",
            "        assert res.json == {\"value\": 42}",
            "",
            "    def test_parsing_headers(self, testapp):",
            "        res = testapp.get(\"/echo_headers\", headers={\"name\": \"Fred\"})",
            "        assert res.json == {\"name\": \"Fred\"}",
            "",
            "    def test_parsing_cookies(self, testapp):",
            "        testapp.set_cookie(\"name\", \"Steve\")",
            "        res = testapp.get(\"/echo_cookie\")",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_nested_json(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_nested\", {\"name\": {\"first\": \"Steve\", \"last\": \"Loria\"}}",
            "        )",
            "        assert res.json == {\"name\": {\"first\": \"Steve\", \"last\": \"Loria\"}}",
            "",
            "    def test_parse_nested_many_json(self, testapp):",
            "        in_data = {\"users\": [{\"id\": 1, \"name\": \"foo\"}, {\"id\": 2, \"name\": \"bar\"}]}",
            "        res = testapp.post_json(\"/echo_nested_many\", in_data)",
            "        assert res.json == in_data",
            "",
            "    # Regression test for https://github.com/marshmallow-code/webargs/issues/120",
            "    def test_parse_nested_many_missing(self, testapp):",
            "        in_data = {}",
            "        res = testapp.post_json(\"/echo_nested_many\", in_data)",
            "        assert res.json == {}",
            "",
            "    def test_parse_files(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_file\", {\"myfile\": webtest.Upload(\"README.rst\", b\"data\")}",
            "        )",
            "        assert res.json == {\"myfile\": \"data\"}",
            "",
            "    # https://github.com/sloria/webargs/pull/297",
            "    def test_empty_json(self, testapp):",
            "        res = testapp.post(\"/echo_json\")",
            "        assert res.status_code == 200",
            "        assert res.json == {\"name\": \"World\"}",
            "",
            "    # https://github.com/sloria/webargs/pull/297",
            "    def test_empty_json_with_headers(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            \"\",",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "        )",
            "        assert res.status_code == 200",
            "        assert res.json == {\"name\": \"World\"}",
            "",
            "    # https://github.com/sloria/webargs/issues/329",
            "    def test_invalid_json(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            '{\"foo\": \"bar\", }',",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "            expect_errors=True,",
            "        )",
            "        assert res.status_code == 400",
            "        assert res.json == {\"json\": [\"Invalid JSON body.\"]}"
        ],
        "afterPatchFile": [
            "\"\"\"Utilities for testing. Includes a base test class",
            "for testing parsers.",
            "",
            ".. warning::",
            "",
            "    Methods and functions in this module may change without",
            "    warning and without a major version change.",
            "\"\"\"",
            "import pytest",
            "import webtest",
            "",
            "from webargs.core import json",
            "",
            "",
            "class CommonTestCase:",
            "    \"\"\"Base test class that defines test methods for common functionality across all",
            "    parsers. Subclasses must define `create_app`, which returns a WSGI-like app.",
            "    \"\"\"",
            "",
            "    def create_app(self):",
            "        \"\"\"Return a WSGI app\"\"\"",
            "        raise NotImplementedError(\"Must define create_app()\")",
            "",
            "    def create_testapp(self, app):",
            "        return webtest.TestApp(app)",
            "",
            "    def before_create_app(self):",
            "        pass",
            "",
            "    def after_create_app(self):",
            "        pass",
            "",
            "    @pytest.fixture(scope=\"class\")",
            "    def testapp(self):",
            "        self.before_create_app()",
            "        yield self.create_testapp(self.create_app())",
            "        self.after_create_app()",
            "",
            "    def test_parse_querystring_args(self, testapp):",
            "        assert testapp.get(\"/echo?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_parse_form(self, testapp):",
            "        assert testapp.post(\"/echo_form\", {\"name\": \"Joe\"}).json == {\"name\": \"Joe\"}",
            "",
            "    def test_parse_json(self, testapp):",
            "        assert testapp.post_json(\"/echo_json\", {\"name\": \"Fred\"}).json == {",
            "            \"name\": \"Fred\"",
            "        }",
            "",
            "    def test_parse_json_missing(self, testapp):",
            "        assert testapp.post(\"/echo_json\", \"\").json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_or_form(self, testapp):",
            "        assert testapp.post_json(\"/echo_json_or_form\", {\"name\": \"Fred\"}).json == {",
            "            \"name\": \"Fred\"",
            "        }",
            "        assert testapp.post(\"/echo_json_or_form\", {\"name\": \"Joe\"}).json == {",
            "            \"name\": \"Joe\"",
            "        }",
            "        assert testapp.post(\"/echo_json_or_form\", \"\").json == {\"name\": \"World\"}",
            "",
            "    def test_parse_querystring_default(self, testapp):",
            "        assert testapp.get(\"/echo\").json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_default(self, testapp):",
            "        assert testapp.post_json(\"/echo_json\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_with_charset(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            json.dumps({\"name\": \"Steve\"}),",
            "            content_type=\"application/json;charset=UTF-8\",",
            "        )",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_json_with_vendor_media_type(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            json.dumps({\"name\": \"Steve\"}),",
            "            content_type=\"application/vnd.api+json;charset=UTF-8\",",
            "        )",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_ignore_extra_data(self, testapp):",
            "        assert testapp.post_json(",
            "            \"/echo_ignoring_extra_data\", {\"extra\": \"data\"}",
            "        ).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_empty(self, testapp):",
            "        assert testapp.post_json(\"/echo_json\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_error_unexpected_int(self, testapp):",
            "        res = testapp.post_json(\"/echo_json\", 1, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_error_unexpected_list(self, testapp):",
            "        res = testapp.post_json(\"/echo_json\", [{\"extra\": \"data\"}], expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_many_schema_invalid_input(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_many_schema\", [{\"name\": \"a\"}], expect_errors=True",
            "        )",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_many_schema(self, testapp):",
            "        res = testapp.post_json(\"/echo_many_schema\", [{\"name\": \"Steve\"}]).json",
            "        assert res == [{\"name\": \"Steve\"}]",
            "",
            "    def test_parse_json_many_schema_error_malformed_data(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_many_schema\", {\"extra\": \"data\"}, expect_errors=True",
            "        )",
            "        assert res.status_code == 422",
            "",
            "    def test_parsing_form_default(self, testapp):",
            "        assert testapp.post(\"/echo_form\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_querystring_multiple(self, testapp):",
            "        expected = {\"name\": [\"steve\", \"Loria\"]}",
            "        assert testapp.get(\"/echo_multi?name=steve&name=Loria\").json == expected",
            "",
            "    # test that passing a single value parses correctly",
            "    # on parsers like falconparser, where there is no native MultiDict type,",
            "    # this verifies the usage of MultiDictProxy to ensure that single values",
            "    # are \"listified\"",
            "    def test_parse_querystring_multiple_single_value(self, testapp):",
            "        expected = {\"name\": [\"steve\"]}",
            "        assert testapp.get(\"/echo_multi?name=steve\").json == expected",
            "",
            "    def test_parse_form_multiple(self, testapp):",
            "        expected = {\"name\": [\"steve\", \"Loria\"]}",
            "        assert (",
            "            testapp.post(\"/echo_multi_form\", {\"name\": [\"steve\", \"Loria\"]}).json",
            "            == expected",
            "        )",
            "",
            "    def test_parse_json_list(self, testapp):",
            "        expected = {\"name\": [\"Steve\"]}",
            "        assert (",
            "            testapp.post_json(\"/echo_multi_json\", {\"name\": [\"Steve\"]}).json == expected",
            "        )",
            "",
            "    def test_parse_json_list_error_malformed_data(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_multi_json\", {\"name\": \"Steve\"}, expect_errors=True",
            "        )",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_with_nonascii_chars(self, testapp):",
            "        text = \"\u00f8\u02c6\u0192\u00a3\u00ba\u00ba\u2206\u0192\u02c6\u2206\"",
            "        assert testapp.post_json(\"/echo_json\", {\"name\": text}).json == {\"name\": text}",
            "",
            "    # https://github.com/marshmallow-code/webargs/issues/427",
            "    def test_parse_json_with_nonutf8_chars(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            b\"\\xfe\",",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "            expect_errors=True,",
            "        )",
            "",
            "        assert res.status_code == 400",
            "        assert res.json == {\"json\": [\"Invalid JSON body.\"]}",
            "",
            "    def test_validation_error_returns_422_response(self, testapp):",
            "        res = testapp.post_json(\"/echo_json\", {\"name\": \"b\"}, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_user_validation_error_returns_422_response_by_default(self, testapp):",
            "        res = testapp.post_json(\"/error\", {\"text\": \"foo\"}, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_use_args_decorator(self, testapp):",
            "        assert testapp.get(\"/echo_use_args?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_use_args_with_path_param(self, testapp):",
            "        url = \"/echo_use_args_with_path_param/foo\"",
            "        res = testapp.get(url + \"?value=42\")",
            "        assert res.json == {\"value\": 42}",
            "",
            "    def test_use_args_with_validation(self, testapp):",
            "        result = testapp.post(\"/echo_use_args_validated\", {\"value\": 43})",
            "        assert result.status_code == 200",
            "        result = testapp.post(",
            "            \"/echo_use_args_validated\", {\"value\": 41}, expect_errors=True",
            "        )",
            "        assert result.status_code == 422",
            "",
            "    def test_use_kwargs_decorator(self, testapp):",
            "        assert testapp.get(\"/echo_use_kwargs?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_use_kwargs_with_path_param(self, testapp):",
            "        url = \"/echo_use_kwargs_with_path_param/foo\"",
            "        res = testapp.get(url + \"?value=42\")",
            "        assert res.json == {\"value\": 42}",
            "",
            "    def test_parsing_headers(self, testapp):",
            "        res = testapp.get(\"/echo_headers\", headers={\"name\": \"Fred\"})",
            "        assert res.json == {\"name\": \"Fred\"}",
            "",
            "    def test_parsing_cookies(self, testapp):",
            "        testapp.set_cookie(\"name\", \"Steve\")",
            "        res = testapp.get(\"/echo_cookie\")",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_nested_json(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_nested\", {\"name\": {\"first\": \"Steve\", \"last\": \"Loria\"}}",
            "        )",
            "        assert res.json == {\"name\": {\"first\": \"Steve\", \"last\": \"Loria\"}}",
            "",
            "    def test_parse_nested_many_json(self, testapp):",
            "        in_data = {\"users\": [{\"id\": 1, \"name\": \"foo\"}, {\"id\": 2, \"name\": \"bar\"}]}",
            "        res = testapp.post_json(\"/echo_nested_many\", in_data)",
            "        assert res.json == in_data",
            "",
            "    # Regression test for https://github.com/marshmallow-code/webargs/issues/120",
            "    def test_parse_nested_many_missing(self, testapp):",
            "        in_data = {}",
            "        res = testapp.post_json(\"/echo_nested_many\", in_data)",
            "        assert res.json == {}",
            "",
            "    def test_parse_files(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_file\", {\"myfile\": webtest.Upload(\"README.rst\", b\"data\")}",
            "        )",
            "        assert res.json == {\"myfile\": \"data\"}",
            "",
            "    # https://github.com/sloria/webargs/pull/297",
            "    def test_empty_json(self, testapp):",
            "        res = testapp.post(\"/echo_json\")",
            "        assert res.status_code == 200",
            "        assert res.json == {\"name\": \"World\"}",
            "",
            "    # https://github.com/sloria/webargs/pull/297",
            "    def test_empty_json_with_headers(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            \"\",",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "        )",
            "        assert res.status_code == 200",
            "        assert res.json == {\"name\": \"World\"}",
            "",
            "    # https://github.com/sloria/webargs/issues/329",
            "    def test_invalid_json(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_json\",",
            "            '{\"foo\": \"bar\", }',",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "            expect_errors=True,",
            "        )",
            "        assert res.status_code == 400",
            "        assert res.json == {\"json\": [\"Invalid JSON body.\"]}",
            "",
            "    @pytest.mark.parametrize(",
            "        (\"path\", \"payload\", \"content_type\"),",
            "        [",
            "            (",
            "                \"/echo_json\",",
            "                json.dumps({\"name\": \"foo\"}),",
            "                \"application/x-www-form-urlencoded\",",
            "            ),",
            "            (\"/echo_form\", {\"name\": \"foo\"}, \"application/json\"),",
            "        ],",
            "    )",
            "    def test_content_type_mismatch(self, testapp, path, payload, content_type):",
            "        res = testapp.post(path, payload, headers={\"Content-Type\": content_type})",
            "        assert res.json == {\"name\": \"World\"}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.webargs.testing.CommonTestCase.self",
            "hpack"
        ]
    },
    "src/webargs/webapp2parser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     \"\"\"webapp2 request argument parser.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     def _raw_load_json(self, req):"
            },
            "3": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Return a json payload from the request for the core parser's"
            },
            "4": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        load_json\"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        \"\"\"Return a json payload from the request for the core parser's load_json.\"\"\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        if not core.is_json(req.content_type):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+            return core.missing"
            },
            "8": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         return core.parse_json(req.body)"
            },
            "9": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     def load_querystring(self, req, schema):"
            }
        },
        "frontPatchFile": [
            "\"\"\"Webapp2 request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    import webapp2",
            "",
            "    from marshmallow import fields",
            "    from webargs.webobparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "",
            "    class MainPage(webapp2.RequestHandler):",
            "",
            "        @use_args(hello_args)",
            "        def get_args(self, args):",
            "            self.response.write('Hello, {name}!'.format(name=args['name']))",
            "",
            "        @use_kwargs(hello_args)",
            "        def get_kwargs(self, name=None):",
            "            self.response.write('Hello, {name}!'.format(name=name))",
            "",
            "    app = webapp2.WSGIApplication([",
            "        webapp2.Route(r'/hello', MainPage, handler_method='get_args'),",
            "        webapp2.Route(r'/hello_dict', MainPage, handler_method='get_kwargs'),",
            "    ], debug=True)",
            "\"\"\"",
            "import webapp2",
            "import webob.multidict",
            "",
            "from webargs import core",
            "from webargs.multidictproxy import MultiDictProxy",
            "",
            "",
            "class Webapp2Parser(core.Parser):",
            "    \"\"\"webapp2 request argument parser.\"\"\"",
            "",
            "    def _raw_load_json(self, req):",
            "        \"\"\"Return a json payload from the request for the core parser's",
            "        load_json\"\"\"",
            "        return core.parse_json(req.body)",
            "",
            "    def load_querystring(self, req, schema):",
            "        \"\"\"Return query params from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.GET, schema)",
            "",
            "    def load_form(self, req, schema):",
            "        \"\"\"Return form values from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.POST, schema)",
            "",
            "    def load_cookies(self, req, schema):",
            "        \"\"\"Return cookies from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.cookies, schema)",
            "",
            "    def load_headers(self, req, schema):",
            "        \"\"\"Return headers from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.headers, schema)",
            "",
            "    def load_files(self, req, schema):",
            "        \"\"\"Return files from the request as a MultiDictProxy.\"\"\"",
            "        files = ((k, v) for k, v in req.POST.items() if hasattr(v, \"file\"))",
            "        return MultiDictProxy(webob.multidict.MultiDict(files), schema)",
            "",
            "    def get_default_request(self):",
            "        return webapp2.get_request()",
            "",
            "",
            "parser = Webapp2Parser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "afterPatchFile": [
            "\"\"\"Webapp2 request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    import webapp2",
            "",
            "    from marshmallow import fields",
            "    from webargs.webobparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "",
            "    class MainPage(webapp2.RequestHandler):",
            "",
            "        @use_args(hello_args)",
            "        def get_args(self, args):",
            "            self.response.write('Hello, {name}!'.format(name=args['name']))",
            "",
            "        @use_kwargs(hello_args)",
            "        def get_kwargs(self, name=None):",
            "            self.response.write('Hello, {name}!'.format(name=name))",
            "",
            "    app = webapp2.WSGIApplication([",
            "        webapp2.Route(r'/hello', MainPage, handler_method='get_args'),",
            "        webapp2.Route(r'/hello_dict', MainPage, handler_method='get_kwargs'),",
            "    ], debug=True)",
            "\"\"\"",
            "import webapp2",
            "import webob.multidict",
            "",
            "from webargs import core",
            "from webargs.multidictproxy import MultiDictProxy",
            "",
            "",
            "class Webapp2Parser(core.Parser):",
            "    \"\"\"webapp2 request argument parser.\"\"\"",
            "",
            "    def _raw_load_json(self, req):",
            "        \"\"\"Return a json payload from the request for the core parser's load_json.\"\"\"",
            "        if not core.is_json(req.content_type):",
            "            return core.missing",
            "        return core.parse_json(req.body)",
            "",
            "    def load_querystring(self, req, schema):",
            "        \"\"\"Return query params from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.GET, schema)",
            "",
            "    def load_form(self, req, schema):",
            "        \"\"\"Return form values from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.POST, schema)",
            "",
            "    def load_cookies(self, req, schema):",
            "        \"\"\"Return cookies from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.cookies, schema)",
            "",
            "    def load_headers(self, req, schema):",
            "        \"\"\"Return headers from the request as a MultiDictProxy.\"\"\"",
            "        return MultiDictProxy(req.headers, schema)",
            "",
            "    def load_files(self, req, schema):",
            "        \"\"\"Return files from the request as a MultiDictProxy.\"\"\"",
            "        files = ((k, v) for k, v in req.POST.items() if hasattr(v, \"file\"))",
            "        return MultiDictProxy(webob.multidict.MultiDict(files), schema)",
            "",
            "    def get_default_request(self):",
            "        return webapp2.get_request()",
            "",
            "",
            "parser = Webapp2Parser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "40": [
                "Webapp2Parser",
                "_raw_load_json"
            ],
            "41": [
                "Webapp2Parser",
                "_raw_load_json"
            ]
        },
        "addLocation": []
    }
}