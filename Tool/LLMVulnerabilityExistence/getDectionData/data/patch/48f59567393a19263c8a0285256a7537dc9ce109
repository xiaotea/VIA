{
    "src/pyload/core/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         # otherwise save setting to config dir"
            },
            "1": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         if storagedir is None:"
            },
            "2": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "             storagedir = self.config.get(\"general\", \"storage_folder\")"
            },
            "3": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Make sure storage_folder is not empty"
            },
            "4": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not storagedir:"
            },
            "5": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.config.set(\"general\", \"storage_folder\", \"~/Downloads/pyLoad\")"
            },
            "6": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                storagedir = self.config.get(\"general\", \"storage_folder\")"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         else:"
            },
            "9": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "             self.config.set(\"general\", \"storage_folder\", storagedir)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        # Make sure storage_folder is not empty"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        # and also not inside dangerous locations"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        correct_case = lambda x: x.lower() if os.name == \"nt\" else x"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        directories = ["
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            correct_case(os.path.join(os.path.realpath(d), \"\") )"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            for d in [storagedir or PKGDIR, PKGDIR, userdir]"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        ]"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        is_bad_dir = any(directories[0].startswith(d) for d in directories[1:])"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        if not storagedir or is_bad_dir:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            self.config.set(\"general\", \"storage_folder\", \"~/Downloads/pyLoad\")"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            storagedir = self.config.get(\"general\", \"storage_folder\")"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         os.makedirs(storagedir, exist_ok=True)"
            },
            "25": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         if not self._dry_run:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#       ____________",
            "#   ___/       |    \\_____________ _                 _ ___",
            "#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\",
            "# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\",
            "# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /",
            "#  \\_______\\    /_______|_|   |__/________________________/",
            "#           \\  /",
            "#            \\/",
            "",
            "import atexit",
            "import gettext",
            "import locale",
            "import os",
            "import signal",
            "import subprocess",
            "import sys",
            "import tempfile",
            "import time",
            "from threading import Event",
            "",
            "from pyload import APPID, PKGDIR, USERHOMEDIR",
            "",
            "from .. import __version__ as PYLOAD_VERSION",
            "from .. import __version_info__ as PYLOAD_VERSION_INFO",
            "from .utils import format, fs",
            "from .utils.misc import reversemap",
            "",
            "",
            "class Restart(Exception):",
            "    __slots__ = []",
            "",
            "",
            "class Exit(Exception):",
            "    __slots__ = []",
            "",
            "",
            "# TODO:",
            "#  configurable auth system ldap/mysql",
            "#  cron job like scheduler",
            "#  plugin stack / multi decrypter",
            "#  content attribute for files / sync status",
            "#  sync with disk content / file manager / nested packages",
            "#  sync between pyload cores",
            "#  new attributes (date|sync status)",
            "#  improve external scripts",
            "class Core:",
            "    LOCALE_DOMAIN = APPID",
            "    DEFAULT_USERNAME = APPID",
            "    DEFAULT_PASSWORD = APPID",
            "    DEFAULT_DATADIR = os.path.join(",
            "        os.getenv(\"APPDATA\") or USERHOMEDIR, \"pyLoad\" if os.name == \"nt\" else \".pyload\"",
            "    )",
            "    DEFAULT_TMPDIR = os.path.join(tempfile.gettempdir(), \"pyLoad\")",
            "    DEFAULT_STORAGEDIR = os.path.join(USERHOMEDIR, \"Downloads\", \"pyLoad\")",
            "    DEBUG_LEVEL_MAP = {\"debug\": 1, \"trace\": 2, \"stack\": 3}",
            "",
            "    @property",
            "    def version(self):",
            "        return PYLOAD_VERSION",
            "",
            "    @property",
            "    def version_info(self):",
            "        return PYLOAD_VERSION_INFO",
            "",
            "    @property",
            "    def running(self):",
            "        return self._running.is_set()",
            "",
            "    #: addons can check this property when deactivated to tell the reason for deactivation (unload or exit)",
            "    @property",
            "    def exiting(self):",
            "        return self._exiting",
            "",
            "    @property",
            "    def debug(self):",
            "        return self._debug",
            "",
            "    # NOTE: should `reset` restore the user config as well?",
            "    def __init__(self, userdir, tempdir, storagedir, debug=None, reset=False, dry=False):",
            "        self._running = Event()",
            "        self._exiting = False",
            "        self._do_restart = False",
            "        self._do_exit = False",
            "        self._ = lambda x: x",
            "        self._debug = 0",
            "        self._dry_run = dry",
            "",
            "        # if self.tmpdir not in sys.path:",
            "        # sys.path.append(self.tmpdir)",
            "",
            "        # if refresh:",
            "        # cleanpy(PACKDIR)",
            "",
            "        datadir = os.path.join(os.path.realpath(userdir), \"data\")",
            "        os.makedirs(datadir, exist_ok=True)",
            "        os.chdir(datadir)",
            "",
            "        self._init_config(userdir, tempdir, storagedir, debug)",
            "        self._init_log()",
            "        if storagedir is not None:",
            "            self.log.warning(\"Download folder was specified from the commandline\")",
            "        self._init_database(reset and not dry)",
            "        self._init_network()",
            "        self._init_api()",
            "        self._init_managers()",
            "        self._init_webserver()",
            "",
            "        atexit.register(self.terminate)",
            "",
            "        # TODO: Remove...",
            "        self.last_client_connected = 0",
            "",
            "    def _init_config(self, userdir, tempdir, storagedir, debug):",
            "        from .config.parser import ConfigParser",
            "",
            "        self.userdir = os.path.realpath(userdir)",
            "        self.tempdir = os.path.realpath(tempdir)",
            "        os.makedirs(self.userdir, exist_ok=True)",
            "        os.makedirs(self.tempdir, exist_ok=True)",
            "",
            "        self.config = ConfigParser(self.userdir)",
            "",
            "        if debug is None:",
            "            if self.config.get(\"general\", \"debug_mode\"):",
            "                debug_level = self.config.get(\"general\", \"debug_level\")",
            "                self._debug = self.DEBUG_LEVEL_MAP[debug_level]",
            "        else:",
            "            self._debug = max(0, int(debug))",
            "",
            "        # If no argument set, read storage dir from config file,",
            "        # otherwise save setting to config dir",
            "        if storagedir is None:",
            "            storagedir = self.config.get(\"general\", \"storage_folder\")",
            "            # Make sure storage_folder is not empty",
            "            if not storagedir:",
            "                self.config.set(\"general\", \"storage_folder\", \"~/Downloads/pyLoad\")",
            "                storagedir = self.config.get(\"general\", \"storage_folder\")",
            "        else:",
            "            self.config.set(\"general\", \"storage_folder\", storagedir)",
            "        os.makedirs(storagedir, exist_ok=True)",
            "",
            "        if not self._dry_run:",
            "            self.config.save()  #: save so config files gets filled",
            "",
            "    def _init_log(self):",
            "        from .log_factory import LogFactory",
            "",
            "        self.logfactory = LogFactory(self)",
            "        self.log = self.logfactory.get_logger(",
            "            \"pyload\"",
            "        )  # NOTE: forced debug mode from console is not working actually",
            "",
            "        self.log.info(f\"*** Welcome to pyLoad {self.version} ***\")",
            "        if self._dry_run:",
            "            self.log.info(\"*** TEST RUN ***\")",
            "",
            "    def _init_network(self):",
            "        from .network import request_factory",
            "        from .network.request_factory import RequestFactory",
            "",
            "        self.req = self.request_factory = RequestFactory(self)",
            "",
            "    def _init_api(self):",
            "        from .api import Api",
            "",
            "        self.api = Api(self)",
            "",
            "    def _init_webserver(self):",
            "        from pyload.webui.webserver_thread import WebServerThread",
            "",
            "        self.webserver = WebServerThread(self)",
            "",
            "    def _init_database(self, reset):",
            "        from .threads.database_thread import DatabaseThread",
            "",
            "        db_path = os.path.join(self.userdir, \"data\", DatabaseThread.DB_FILENAME)",
            "        newdb = not os.path.isfile(db_path)",
            "",
            "        self.db = DatabaseThread(self)",
            "        self.db.setup()",
            "",
            "        userpw = (self.DEFAULT_USERNAME, self.DEFAULT_PASSWORD)",
            "        # nousers = bool(self.db.list_users())",
            "        if reset or newdb:",
            "            self.db.add_user(*userpw, reset=True)",
            "",
            "        if reset:",
            "            self.log.info(",
            "                self._(",
            "                    \"Successfully reset default login credentials `{}|{}`\"",
            "                ).format(*userpw)",
            "            )",
            "",
            "    def _init_managers(self):",
            "        from .managers.account_manager import AccountManager",
            "        from .managers.addon_manager import AddonManager",
            "        from .managers.captcha_manager import CaptchaManager",
            "        from .managers.event_manager import EventManager",
            "        from .managers.file_manager import FileManager",
            "        from .managers.plugin_manager import PluginManager",
            "        from .managers.thread_manager import ThreadManager",
            "        from .scheduler import Scheduler",
            "",
            "        self.files = self.file_manager = FileManager(self)",
            "        self.scheduler = Scheduler(self)",
            "",
            "        self.pgm = self.plugin_manager = PluginManager(self)",
            "        self.evm = self.event_manager = EventManager(self)",
            "        self.acm = self.account_manager = AccountManager(self)",
            "        self.thm = self.thread_manager = ThreadManager(self)",
            "        self.cpm = self.captcha_manager = CaptchaManager(self)",
            "        self.adm = self.addon_manager = AddonManager(self)",
            "",
            "    def _setup_permissions(self):",
            "        self.log.debug(\"Setup permissions...\")",
            "",
            "        if os.name == \"nt\":",
            "            return",
            "",
            "        change_group = self.config.get(\"permission\", \"change_group\")",
            "        change_user = self.config.get(\"permission\", \"change_user\")",
            "",
            "        if change_group:",
            "            try:",
            "                from grp import getgrnam",
            "",
            "                group = getgrnam(self.config.get(\"permission\", \"group\"))",
            "                os.setgid(group[2])",
            "            except Exception:",
            "                self.log.warning(",
            "                    self._(\"Unable to change gid\"),",
            "                    exc_info=self.debug > 1,",
            "                    stack_info=self.debug > 2,",
            "                )",
            "",
            "        if change_user:",
            "            try:",
            "                from pwd import getpwnam",
            "",
            "                user = getpwnam(self.config.get(\"permission\", \"user\"))",
            "                os.setuid(user[2])",
            "            except Exception:",
            "                self.log.warning(",
            "                    self._(\"Unable to change uid\"),",
            "                    exc_info=self.debug > 1,",
            "                    stack_info=self.debug > 2,",
            "                )",
            "",
            "    def set_language(self, lang):",
            "        localedir = os.path.join(PKGDIR, \"locale\")",
            "        languages = (locale.locale_alias[lang.lower()].split(\"_\", 1)[0],)",
            "        self._set_language(self.LOCALE_DOMAIN, localedir, languages)",
            "",
            "    def _set_language(self, *args, **kwargs):",
            "        trans = gettext.translation(*args, **kwargs)",
            "        try:",
            "            self._ = trans.ugettext",
            "        except AttributeError:",
            "            self._ = trans.gettext",
            "",
            "    def _setup_language(self):",
            "        self.log.debug(\"Setup language...\")",
            "",
            "        lang = self.config.get(\"general\", \"language\")",
            "        if not lang:",
            "            lc = locale.getlocale()[0] or locale.getdefaultlocale()[0]",
            "            lang = lc.split(\"_\", 1)[0] if lc else \"en\"",
            "",
            "        try:",
            "            self.set_language(lang)",
            "        except IOError as exc:",
            "            if lang != \"en\":",
            "                self.log.warning(exc, exc_info=self.debug > 1, stack_info=self.debug > 2)",
            "            self._set_language(self.LOCALE_DOMAIN, fallback=True)",
            "",
            "    # def _setup_niceness(self):",
            "    # niceness = self.config.get('general', 'niceness')",
            "    # renice(niceness=niceness)",
            "    # ioniceness = int(self.config.get('general', 'ioniceness'))",
            "    # ionice(niceness=ioniceness)",
            "",
            "    def _setup_network(self):",
            "        self.log.debug(\"Setup network...\")",
            "",
            "        # TODO: Move to AccountManager",
            "        self.log.info(self._(\"Activating accounts...\"))",
            "        self.acm.get_account_infos()",
            "        # self.scheduler.add_job(0, self.acm.get_account_infos)",
            "",
            "        self.log.info(self._(\"Activating plugins...\"))",
            "        self.adm.core_ready()",
            "",
            "    def _start_webserver(self):",
            "        if not self.config.get(\"webui\", \"enabled\"):",
            "            return",
            "        self.webserver.start()",
            "",
            "    def _stop_webserver(self):",
            "        if not self.config.get(\"webui\", \"enabled\"):",
            "            return",
            "        self.webserver.stop()",
            "",
            "    def _get_args_for_reloading(self):",
            "        \"\"\"Determine how the script was executed, and return the args needed",
            "        to execute it again in a new process.",
            "        \"\"\"",
            "        rv = [sys.executable]",
            "        py_script = sys.argv[0]",
            "        args = sys.argv[1:]",
            "        # Need to look at main module to determine how it was executed.",
            "        __main__ = sys.modules[\"__main__\"]",
            "",
            "        # The value of __package__ indicates how Python was called. It may",
            "        # not exist if a setuptools script is installed as an egg. It may be",
            "        # set incorrectly for entry points created with pip on Windows.",
            "        if getattr(__main__, \"__package__\", None) is None or (",
            "            os.name == \"nt\"",
            "            and __main__.__package__ == \"\"",
            "            and not os.path.exists(py_script)",
            "            and os.path.exists(f\"{py_script}.exe\")",
            "        ):",
            "            # Executed a file, like \"python app.py\".",
            "            py_script = os.path.abspath(py_script)",
            "",
            "            if os.name == \"nt\":",
            "                # Windows entry points have \".exe\" extension and should be",
            "                # called directly.",
            "                if not os.path.exists(py_script) and os.path.exists(f\"{py_script}.exe\"):",
            "                    py_script += \".exe\"",
            "",
            "                if (",
            "                    os.path.splitext(sys.executable)[1] == \".exe\"",
            "                    and os.path.splitext(py_script)[1] == \".exe\"",
            "                ):",
            "                    rv.pop(0)",
            "",
            "            rv.append(py_script)",
            "        else:",
            "            # Executed a module, like \"python -m module\".",
            "            if sys.argv[0] == \"-m\":",
            "                args = sys.argv",
            "            else:",
            "                if os.path.isfile(py_script):",
            "                    # Rewritten by Python from \"-m script\" to \"/path/to/script.py\".",
            "                    py_module = __main__.__package__",
            "                    name = os.path.splitext(os.path.basename(py_script))[0]",
            "",
            "                    if name != \"__main__\":",
            "                        py_module += f\".{name}\"",
            "                else:",
            "                    # Incorrectly rewritten by pydevd debugger from \"-m script\" to \"script\".",
            "                    py_module = py_script",
            "",
            "                rv.extend((\"-m\", py_module.lstrip(\".\")))",
            "",
            "        rv.extend(args)",
            "        return rv",
            "",
            "    def start(self):",
            "        try:",
            "            try:",
            "                signal.signal(signal.SIGQUIT, self.sigquit)",
            "                signal.signal(signal.SIGTERM, self.sigterm)",
            "            except Exception:",
            "                pass",
            "",
            "            self.log.debug(\"Starting core...\")",
            "",
            "            if self.debug:",
            "                debug_level = reversemap(self.DEBUG_LEVEL_MAP)[self.debug].upper()",
            "                self.log.debug(f\"Debug level: {debug_level}\")",
            "",
            "            # self.evm.fire('pyload:starting')",
            "            self._running.set()",
            "",
            "            self._setup_language()",
            "            self._setup_permissions()",
            "",
            "            self.log.info(self._(\"User directory: {}\").format(self.userdir))",
            "            self.log.info(self._(\"Cache directory: {}\").format(self.tempdir))",
            "",
            "            storage_folder = self.config.get(\"general\", \"storage_folder\")",
            "            self.log.info(self._(\"Storage directory: {}\").format(storage_folder))",
            "",
            "            avail_space = format.size(fs.free_space(storage_folder))",
            "            self.log.info(self._(\"Storage free space: {}\").format(avail_space))",
            "",
            "            self._setup_network()",
            "            # self._setup_niceness()",
            "",
            "            # # some memory stats",
            "            # from guppy import hpy",
            "            # hp=hpy()",
            "            # print(hp.heap())",
            "            # import objgraph",
            "            # objgraph.show_most_common_types(limit=30)",
            "            # import memdebug",
            "            # memdebug.start(8002)",
            "            # from meliae import scanner",
            "            # scanner.dump_all_objects(os.path.join(PACKDIR, 'objs.json'))",
            "",
            "            self._start_webserver()",
            "",
            "            self.log.debug(\"*** pyLoad is up and running ***\")",
            "            # self.evm.fire('pyload:started')",
            "",
            "            self.thm.pause = False  # NOTE: Recheck...",
            "",
            "            if self._dry_run:",
            "                raise Exit",
            "",
            "            while True:",
            "                self._running.wait()",
            "                self.thread_manager.run()",
            "                if self._do_restart:",
            "                    raise Restart",
            "                if self._do_exit:",
            "                    raise Exit",
            "                self.scheduler.run()",
            "                time.sleep(1)",
            "",
            "        except Restart:",
            "            self.restart()",
            "",
            "        except (Exit, KeyboardInterrupt, SystemExit):",
            "            self.terminate()",
            "",
            "        except Exception as exc:",
            "            self.log.critical(exc, exc_info=True, stack_info=self.debug > 2)",
            "            self.terminate()",
            "            if os.name == \"nt\":",
            "                sys.exit(70)",
            "            else:",
            "                sys.exit(os.EX_SOFTWARE)  #: this kind of stuff should not be here!",
            "",
            "    def is_client_connected(self):",
            "        return (self.last_client_connected + 30) > time.time()",
            "",
            "    def restart(self):",
            "        self.log.info(self._(\"pyLoad is restarting...\"))",
            "        # self.evm.fire('pyload:restarting')",
            "        self.terminate()",
            "",
            "        if sys.path[0]:",
            "            os.chdir(sys.path[0])",
            "",
            "        args = self._get_args_for_reloading()",
            "        subprocess.Popen(args, close_fds=True)",
            "",
            "        sys.exit()",
            "",
            "    def sigquit(self, a, b):",
            "        self.log.info(self._(\"Received Quit signal\"))",
            "        self.terminate()",
            "        sys.exit()",
            "",
            "    def sigterm(self, a, b):",
            "        self.log.info(self._(\"Received Terminate signal\"))",
            "        self.terminate()",
            "        sys.exit()",
            "",
            "    def terminate(self):",
            "        if self.running:",
            "            self.stop()",
            "            self.log.info(self._(\"Exiting core...\"))",
            "            # self.tsm.exit()",
            "            # self.db.exit()  # NOTE: Why here?",
            "            self.logfactory.shutdown()",
            "            # if cleanup:",
            "            # self.log.info(self._(\"Deleting temp files...\"))",
            "            # remove(self.tmpdir)",
            "",
            "    def stop(self):",
            "        try:",
            "            self.log.debug(\"Stopping core...\")",
            "            # self.evm.fire('pyload:stopping')",
            "",
            "            for thread in self.thread_manager.threads:",
            "                thread.put(\"quit\")",
            "",
            "            for pyfile in list(self.files.cache.values()):",
            "                pyfile.abort_download()",
            "",
            "            self._exiting = True",
            "            self.addon_manager.core_exiting()",
            "",
            "        finally:",
            "            self.files.sync_save()",
            "            self._running.clear()",
            "            # self.evm.fire('pyload:stopped')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#       ____________",
            "#   ___/       |    \\_____________ _                 _ ___",
            "#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\",
            "# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\",
            "# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /",
            "#  \\_______\\    /_______|_|   |__/________________________/",
            "#           \\  /",
            "#            \\/",
            "",
            "import atexit",
            "import gettext",
            "import locale",
            "import os",
            "import signal",
            "import subprocess",
            "import sys",
            "import tempfile",
            "import time",
            "from threading import Event",
            "",
            "from pyload import APPID, PKGDIR, USERHOMEDIR",
            "",
            "from .. import __version__ as PYLOAD_VERSION",
            "from .. import __version_info__ as PYLOAD_VERSION_INFO",
            "from .utils import format, fs",
            "from .utils.misc import reversemap",
            "",
            "",
            "class Restart(Exception):",
            "    __slots__ = []",
            "",
            "",
            "class Exit(Exception):",
            "    __slots__ = []",
            "",
            "",
            "# TODO:",
            "#  configurable auth system ldap/mysql",
            "#  cron job like scheduler",
            "#  plugin stack / multi decrypter",
            "#  content attribute for files / sync status",
            "#  sync with disk content / file manager / nested packages",
            "#  sync between pyload cores",
            "#  new attributes (date|sync status)",
            "#  improve external scripts",
            "class Core:",
            "    LOCALE_DOMAIN = APPID",
            "    DEFAULT_USERNAME = APPID",
            "    DEFAULT_PASSWORD = APPID",
            "    DEFAULT_DATADIR = os.path.join(",
            "        os.getenv(\"APPDATA\") or USERHOMEDIR, \"pyLoad\" if os.name == \"nt\" else \".pyload\"",
            "    )",
            "    DEFAULT_TMPDIR = os.path.join(tempfile.gettempdir(), \"pyLoad\")",
            "    DEFAULT_STORAGEDIR = os.path.join(USERHOMEDIR, \"Downloads\", \"pyLoad\")",
            "    DEBUG_LEVEL_MAP = {\"debug\": 1, \"trace\": 2, \"stack\": 3}",
            "",
            "    @property",
            "    def version(self):",
            "        return PYLOAD_VERSION",
            "",
            "    @property",
            "    def version_info(self):",
            "        return PYLOAD_VERSION_INFO",
            "",
            "    @property",
            "    def running(self):",
            "        return self._running.is_set()",
            "",
            "    #: addons can check this property when deactivated to tell the reason for deactivation (unload or exit)",
            "    @property",
            "    def exiting(self):",
            "        return self._exiting",
            "",
            "    @property",
            "    def debug(self):",
            "        return self._debug",
            "",
            "    # NOTE: should `reset` restore the user config as well?",
            "    def __init__(self, userdir, tempdir, storagedir, debug=None, reset=False, dry=False):",
            "        self._running = Event()",
            "        self._exiting = False",
            "        self._do_restart = False",
            "        self._do_exit = False",
            "        self._ = lambda x: x",
            "        self._debug = 0",
            "        self._dry_run = dry",
            "",
            "        # if self.tmpdir not in sys.path:",
            "        # sys.path.append(self.tmpdir)",
            "",
            "        # if refresh:",
            "        # cleanpy(PACKDIR)",
            "",
            "        datadir = os.path.join(os.path.realpath(userdir), \"data\")",
            "        os.makedirs(datadir, exist_ok=True)",
            "        os.chdir(datadir)",
            "",
            "        self._init_config(userdir, tempdir, storagedir, debug)",
            "        self._init_log()",
            "        if storagedir is not None:",
            "            self.log.warning(\"Download folder was specified from the commandline\")",
            "        self._init_database(reset and not dry)",
            "        self._init_network()",
            "        self._init_api()",
            "        self._init_managers()",
            "        self._init_webserver()",
            "",
            "        atexit.register(self.terminate)",
            "",
            "        # TODO: Remove...",
            "        self.last_client_connected = 0",
            "",
            "    def _init_config(self, userdir, tempdir, storagedir, debug):",
            "        from .config.parser import ConfigParser",
            "",
            "        self.userdir = os.path.realpath(userdir)",
            "        self.tempdir = os.path.realpath(tempdir)",
            "        os.makedirs(self.userdir, exist_ok=True)",
            "        os.makedirs(self.tempdir, exist_ok=True)",
            "",
            "        self.config = ConfigParser(self.userdir)",
            "",
            "        if debug is None:",
            "            if self.config.get(\"general\", \"debug_mode\"):",
            "                debug_level = self.config.get(\"general\", \"debug_level\")",
            "                self._debug = self.DEBUG_LEVEL_MAP[debug_level]",
            "        else:",
            "            self._debug = max(0, int(debug))",
            "",
            "        # If no argument set, read storage dir from config file,",
            "        # otherwise save setting to config dir",
            "        if storagedir is None:",
            "            storagedir = self.config.get(\"general\", \"storage_folder\")",
            "",
            "        else:",
            "            self.config.set(\"general\", \"storage_folder\", storagedir)",
            "",
            "        # Make sure storage_folder is not empty",
            "        # and also not inside dangerous locations",
            "        correct_case = lambda x: x.lower() if os.name == \"nt\" else x",
            "        directories = [",
            "            correct_case(os.path.join(os.path.realpath(d), \"\") )",
            "            for d in [storagedir or PKGDIR, PKGDIR, userdir]",
            "        ]",
            "        is_bad_dir = any(directories[0].startswith(d) for d in directories[1:])",
            "",
            "        if not storagedir or is_bad_dir:",
            "            self.config.set(\"general\", \"storage_folder\", \"~/Downloads/pyLoad\")",
            "            storagedir = self.config.get(\"general\", \"storage_folder\")",
            "",
            "        os.makedirs(storagedir, exist_ok=True)",
            "",
            "        if not self._dry_run:",
            "            self.config.save()  #: save so config files gets filled",
            "",
            "    def _init_log(self):",
            "        from .log_factory import LogFactory",
            "",
            "        self.logfactory = LogFactory(self)",
            "        self.log = self.logfactory.get_logger(",
            "            \"pyload\"",
            "        )  # NOTE: forced debug mode from console is not working actually",
            "",
            "        self.log.info(f\"*** Welcome to pyLoad {self.version} ***\")",
            "        if self._dry_run:",
            "            self.log.info(\"*** TEST RUN ***\")",
            "",
            "    def _init_network(self):",
            "        from .network import request_factory",
            "        from .network.request_factory import RequestFactory",
            "",
            "        self.req = self.request_factory = RequestFactory(self)",
            "",
            "    def _init_api(self):",
            "        from .api import Api",
            "",
            "        self.api = Api(self)",
            "",
            "    def _init_webserver(self):",
            "        from pyload.webui.webserver_thread import WebServerThread",
            "",
            "        self.webserver = WebServerThread(self)",
            "",
            "    def _init_database(self, reset):",
            "        from .threads.database_thread import DatabaseThread",
            "",
            "        db_path = os.path.join(self.userdir, \"data\", DatabaseThread.DB_FILENAME)",
            "        newdb = not os.path.isfile(db_path)",
            "",
            "        self.db = DatabaseThread(self)",
            "        self.db.setup()",
            "",
            "        userpw = (self.DEFAULT_USERNAME, self.DEFAULT_PASSWORD)",
            "        # nousers = bool(self.db.list_users())",
            "        if reset or newdb:",
            "            self.db.add_user(*userpw, reset=True)",
            "",
            "        if reset:",
            "            self.log.info(",
            "                self._(",
            "                    \"Successfully reset default login credentials `{}|{}`\"",
            "                ).format(*userpw)",
            "            )",
            "",
            "    def _init_managers(self):",
            "        from .managers.account_manager import AccountManager",
            "        from .managers.addon_manager import AddonManager",
            "        from .managers.captcha_manager import CaptchaManager",
            "        from .managers.event_manager import EventManager",
            "        from .managers.file_manager import FileManager",
            "        from .managers.plugin_manager import PluginManager",
            "        from .managers.thread_manager import ThreadManager",
            "        from .scheduler import Scheduler",
            "",
            "        self.files = self.file_manager = FileManager(self)",
            "        self.scheduler = Scheduler(self)",
            "",
            "        self.pgm = self.plugin_manager = PluginManager(self)",
            "        self.evm = self.event_manager = EventManager(self)",
            "        self.acm = self.account_manager = AccountManager(self)",
            "        self.thm = self.thread_manager = ThreadManager(self)",
            "        self.cpm = self.captcha_manager = CaptchaManager(self)",
            "        self.adm = self.addon_manager = AddonManager(self)",
            "",
            "    def _setup_permissions(self):",
            "        self.log.debug(\"Setup permissions...\")",
            "",
            "        if os.name == \"nt\":",
            "            return",
            "",
            "        change_group = self.config.get(\"permission\", \"change_group\")",
            "        change_user = self.config.get(\"permission\", \"change_user\")",
            "",
            "        if change_group:",
            "            try:",
            "                from grp import getgrnam",
            "",
            "                group = getgrnam(self.config.get(\"permission\", \"group\"))",
            "                os.setgid(group[2])",
            "            except Exception:",
            "                self.log.warning(",
            "                    self._(\"Unable to change gid\"),",
            "                    exc_info=self.debug > 1,",
            "                    stack_info=self.debug > 2,",
            "                )",
            "",
            "        if change_user:",
            "            try:",
            "                from pwd import getpwnam",
            "",
            "                user = getpwnam(self.config.get(\"permission\", \"user\"))",
            "                os.setuid(user[2])",
            "            except Exception:",
            "                self.log.warning(",
            "                    self._(\"Unable to change uid\"),",
            "                    exc_info=self.debug > 1,",
            "                    stack_info=self.debug > 2,",
            "                )",
            "",
            "    def set_language(self, lang):",
            "        localedir = os.path.join(PKGDIR, \"locale\")",
            "        languages = (locale.locale_alias[lang.lower()].split(\"_\", 1)[0],)",
            "        self._set_language(self.LOCALE_DOMAIN, localedir, languages)",
            "",
            "    def _set_language(self, *args, **kwargs):",
            "        trans = gettext.translation(*args, **kwargs)",
            "        try:",
            "            self._ = trans.ugettext",
            "        except AttributeError:",
            "            self._ = trans.gettext",
            "",
            "    def _setup_language(self):",
            "        self.log.debug(\"Setup language...\")",
            "",
            "        lang = self.config.get(\"general\", \"language\")",
            "        if not lang:",
            "            lc = locale.getlocale()[0] or locale.getdefaultlocale()[0]",
            "            lang = lc.split(\"_\", 1)[0] if lc else \"en\"",
            "",
            "        try:",
            "            self.set_language(lang)",
            "        except IOError as exc:",
            "            if lang != \"en\":",
            "                self.log.warning(exc, exc_info=self.debug > 1, stack_info=self.debug > 2)",
            "            self._set_language(self.LOCALE_DOMAIN, fallback=True)",
            "",
            "    # def _setup_niceness(self):",
            "    # niceness = self.config.get('general', 'niceness')",
            "    # renice(niceness=niceness)",
            "    # ioniceness = int(self.config.get('general', 'ioniceness'))",
            "    # ionice(niceness=ioniceness)",
            "",
            "    def _setup_network(self):",
            "        self.log.debug(\"Setup network...\")",
            "",
            "        # TODO: Move to AccountManager",
            "        self.log.info(self._(\"Activating accounts...\"))",
            "        self.acm.get_account_infos()",
            "        # self.scheduler.add_job(0, self.acm.get_account_infos)",
            "",
            "        self.log.info(self._(\"Activating plugins...\"))",
            "        self.adm.core_ready()",
            "",
            "    def _start_webserver(self):",
            "        if not self.config.get(\"webui\", \"enabled\"):",
            "            return",
            "        self.webserver.start()",
            "",
            "    def _stop_webserver(self):",
            "        if not self.config.get(\"webui\", \"enabled\"):",
            "            return",
            "        self.webserver.stop()",
            "",
            "    def _get_args_for_reloading(self):",
            "        \"\"\"Determine how the script was executed, and return the args needed",
            "        to execute it again in a new process.",
            "        \"\"\"",
            "        rv = [sys.executable]",
            "        py_script = sys.argv[0]",
            "        args = sys.argv[1:]",
            "        # Need to look at main module to determine how it was executed.",
            "        __main__ = sys.modules[\"__main__\"]",
            "",
            "        # The value of __package__ indicates how Python was called. It may",
            "        # not exist if a setuptools script is installed as an egg. It may be",
            "        # set incorrectly for entry points created with pip on Windows.",
            "        if getattr(__main__, \"__package__\", None) is None or (",
            "            os.name == \"nt\"",
            "            and __main__.__package__ == \"\"",
            "            and not os.path.exists(py_script)",
            "            and os.path.exists(f\"{py_script}.exe\")",
            "        ):",
            "            # Executed a file, like \"python app.py\".",
            "            py_script = os.path.abspath(py_script)",
            "",
            "            if os.name == \"nt\":",
            "                # Windows entry points have \".exe\" extension and should be",
            "                # called directly.",
            "                if not os.path.exists(py_script) and os.path.exists(f\"{py_script}.exe\"):",
            "                    py_script += \".exe\"",
            "",
            "                if (",
            "                    os.path.splitext(sys.executable)[1] == \".exe\"",
            "                    and os.path.splitext(py_script)[1] == \".exe\"",
            "                ):",
            "                    rv.pop(0)",
            "",
            "            rv.append(py_script)",
            "        else:",
            "            # Executed a module, like \"python -m module\".",
            "            if sys.argv[0] == \"-m\":",
            "                args = sys.argv",
            "            else:",
            "                if os.path.isfile(py_script):",
            "                    # Rewritten by Python from \"-m script\" to \"/path/to/script.py\".",
            "                    py_module = __main__.__package__",
            "                    name = os.path.splitext(os.path.basename(py_script))[0]",
            "",
            "                    if name != \"__main__\":",
            "                        py_module += f\".{name}\"",
            "                else:",
            "                    # Incorrectly rewritten by pydevd debugger from \"-m script\" to \"script\".",
            "                    py_module = py_script",
            "",
            "                rv.extend((\"-m\", py_module.lstrip(\".\")))",
            "",
            "        rv.extend(args)",
            "        return rv",
            "",
            "    def start(self):",
            "        try:",
            "            try:",
            "                signal.signal(signal.SIGQUIT, self.sigquit)",
            "                signal.signal(signal.SIGTERM, self.sigterm)",
            "            except Exception:",
            "                pass",
            "",
            "            self.log.debug(\"Starting core...\")",
            "",
            "            if self.debug:",
            "                debug_level = reversemap(self.DEBUG_LEVEL_MAP)[self.debug].upper()",
            "                self.log.debug(f\"Debug level: {debug_level}\")",
            "",
            "            # self.evm.fire('pyload:starting')",
            "            self._running.set()",
            "",
            "            self._setup_language()",
            "            self._setup_permissions()",
            "",
            "            self.log.info(self._(\"User directory: {}\").format(self.userdir))",
            "            self.log.info(self._(\"Cache directory: {}\").format(self.tempdir))",
            "",
            "            storage_folder = self.config.get(\"general\", \"storage_folder\")",
            "            self.log.info(self._(\"Storage directory: {}\").format(storage_folder))",
            "",
            "            avail_space = format.size(fs.free_space(storage_folder))",
            "            self.log.info(self._(\"Storage free space: {}\").format(avail_space))",
            "",
            "            self._setup_network()",
            "            # self._setup_niceness()",
            "",
            "            # # some memory stats",
            "            # from guppy import hpy",
            "            # hp=hpy()",
            "            # print(hp.heap())",
            "            # import objgraph",
            "            # objgraph.show_most_common_types(limit=30)",
            "            # import memdebug",
            "            # memdebug.start(8002)",
            "            # from meliae import scanner",
            "            # scanner.dump_all_objects(os.path.join(PACKDIR, 'objs.json'))",
            "",
            "            self._start_webserver()",
            "",
            "            self.log.debug(\"*** pyLoad is up and running ***\")",
            "            # self.evm.fire('pyload:started')",
            "",
            "            self.thm.pause = False  # NOTE: Recheck...",
            "",
            "            if self._dry_run:",
            "                raise Exit",
            "",
            "            while True:",
            "                self._running.wait()",
            "                self.thread_manager.run()",
            "                if self._do_restart:",
            "                    raise Restart",
            "                if self._do_exit:",
            "                    raise Exit",
            "                self.scheduler.run()",
            "                time.sleep(1)",
            "",
            "        except Restart:",
            "            self.restart()",
            "",
            "        except (Exit, KeyboardInterrupt, SystemExit):",
            "            self.terminate()",
            "",
            "        except Exception as exc:",
            "            self.log.critical(exc, exc_info=True, stack_info=self.debug > 2)",
            "            self.terminate()",
            "            if os.name == \"nt\":",
            "                sys.exit(70)",
            "            else:",
            "                sys.exit(os.EX_SOFTWARE)  #: this kind of stuff should not be here!",
            "",
            "    def is_client_connected(self):",
            "        return (self.last_client_connected + 30) > time.time()",
            "",
            "    def restart(self):",
            "        self.log.info(self._(\"pyLoad is restarting...\"))",
            "        # self.evm.fire('pyload:restarting')",
            "        self.terminate()",
            "",
            "        if sys.path[0]:",
            "            os.chdir(sys.path[0])",
            "",
            "        args = self._get_args_for_reloading()",
            "        subprocess.Popen(args, close_fds=True)",
            "",
            "        sys.exit()",
            "",
            "    def sigquit(self, a, b):",
            "        self.log.info(self._(\"Received Quit signal\"))",
            "        self.terminate()",
            "        sys.exit()",
            "",
            "    def sigterm(self, a, b):",
            "        self.log.info(self._(\"Received Terminate signal\"))",
            "        self.terminate()",
            "        sys.exit()",
            "",
            "    def terminate(self):",
            "        if self.running:",
            "            self.stop()",
            "            self.log.info(self._(\"Exiting core...\"))",
            "            # self.tsm.exit()",
            "            # self.db.exit()  # NOTE: Why here?",
            "            self.logfactory.shutdown()",
            "            # if cleanup:",
            "            # self.log.info(self._(\"Deleting temp files...\"))",
            "            # remove(self.tmpdir)",
            "",
            "    def stop(self):",
            "        try:",
            "            self.log.debug(\"Stopping core...\")",
            "            # self.evm.fire('pyload:stopping')",
            "",
            "            for thread in self.thread_manager.threads:",
            "                thread.put(\"quit\")",
            "",
            "            for pyfile in list(self.files.cache.values()):",
            "                pyfile.abort_download()",
            "",
            "            self._exiting = True",
            "            self.addon_manager.core_exiting()",
            "",
            "        finally:",
            "            self.files.sync_save()",
            "            self._running.clear()",
            "            # self.evm.fire('pyload:stopped')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "135": [
                "Core",
                "_init_config"
            ],
            "136": [
                "Core",
                "_init_config"
            ],
            "137": [
                "Core",
                "_init_config"
            ],
            "138": [
                "Core",
                "_init_config"
            ]
        },
        "addLocation": []
    },
    "src/pyload/core/api/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import time"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from enum import IntFlag"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from pyload import PKGDIR"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from ..datatypes.data import *"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from ..datatypes.enums import *"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from ..datatypes.exceptions import *"
            },
            "8": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "         )"
            },
            "9": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         if section == \"core\":"
            },
            "11": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.pyload.config[category][option] = value"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            if category == \"general\" and option == \"storage_folder\":"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                # Forbid setting the download folder inside dangerous locations"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+                correct_case = lambda x: x.lower() if os.name == \"nt\" else x"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+                directories = ["
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+                    correct_case(os.path.join(os.path.realpath(d), \"\"))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+                    for d in [value, PKGDIR, self.pyload.userdir]"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+                ]"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+                if any(directories[0].startswith(d) for d in directories[1:]):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                    return"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+            self.pyload.config.set(category, option, value)"
            },
            "23": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 201,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if option in ("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            if category == \"download\" and option in ("
            },
            "26": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "                 \"limit_speed\","
            },
            "27": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "                 \"max_speed\","
            },
            "28": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ):  #: not so nice to update the limit"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            ):  #: not such a nice method to update the limit"
            },
            "30": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "                 self.pyload.request_factory.update_bucket()"
            },
            "31": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 207,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         elif section == \"plugin\":"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#       ____________",
            "#   ___/       |    \\_____________ _                 _ ___",
            "#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\",
            "# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\",
            "# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /",
            "#  \\_______\\    /_______|_|   |__/________________________/",
            "#           \\  /",
            "#            \\/",
            "",
            "import json",
            "import os",
            "import re",
            "import time",
            "from enum import IntFlag",
            "",
            "from ..datatypes.data import *",
            "from ..datatypes.enums import *",
            "from ..datatypes.exceptions import *",
            "from ..datatypes.pyfile import PyFile",
            "from ..log_factory import LogFactory",
            "from ..network.request_factory import get_url",
            "from ..utils import fs, seconds",
            "from ..utils.old.packagetools import parse_names",
            "",
            "# contains function names mapped to their permissions",
            "# unlisted functions are for admins only",
            "perm_map = {}",
            "",
            "# contains function names mapped to their legacy name",
            "legacy_map = {}",
            "",
            "",
            "# decorator only called on init, never initialized, so has no effect on runtime",
            "def permission(bits):",
            "    class Wrapper:",
            "        def __new__(cls, func, *args, **kwargs):",
            "            perm_map[func.__name__] = bits",
            "            return func",
            "",
            "    return Wrapper",
            "",
            "",
            "def legacy(legacy_name):",
            "    class Wrapper:",
            "        def __new__(cls, func, *args, **kwargs):",
            "            legacy_map[func.__name__] = legacy_name",
            "            return func",
            "",
            "    return Wrapper",
            "",
            "",
            "urlmatcher = re.compile(",
            "    r\"(?:https?|ftps?|xdcc|sftp):(?://|\\\\\\\\)+[\\w\\-._~:/?#\\[\\]@!$&'()*+,;=]*|magnet:\\?.+\",",
            "    re.IGNORECASE,",
            ")",
            "",
            "",
            "class Perms(IntFlag):",
            "    ANY = 0  #: requires no permission, but login",
            "    ADD = 1  #: can add packages",
            "    DELETE = 2  #: can delete packages",
            "    STATUS = 4  #: see and change server status",
            "    LIST = 16  #: see queue and collector",
            "    MODIFY = 32  #: modify some attribute of downloads",
            "    DOWNLOAD = 64  #: can download from webinterface",
            "    SETTINGS = 128  #: can access settings",
            "    ACCOUNTS = 256  #: can access accounts",
            "    LOGS = 512  #: can see server logs",
            "",
            "",
            "class Role(IntFlag):",
            "    ADMIN = 0  #: admin has all permissions implicit",
            "    USER = 1",
            "",
            "",
            "def has_permission(userperms, perms):",
            "    # bitwise or perms before if needed",
            "    return perms == (userperms & perms)",
            "",
            "",
            "# API VERSION",
            "__version__ = 1",
            "",
            "",
            "class Api:",
            "    \"\"\"",
            "    **pyLoads API**",
            "",
            "    This is accessible either internal via core.api or via thrift backend.",
            "",
            "    see Thrift specification file remote/thriftbackend/pyload.thrift\\",
            "    for information about data structures and what methods are usable with rpc.",
            "",
            "    Most methods requires specific permissions, please look at the source code if you need to know.\\",
            "    These can be configured via webinterface.",
            "    Admin user have all permissions, and are the only ones who can access the methods with no specific permission.",
            "    \"\"\"",
            "",
            "    def __new__(cls, core):",
            "        obj = super(Api, cls).__new__(cls)",
            "",
            "        # add methods specified by the @legacy decorator",
            "        # also set legacy method permissions according to the @permissions decorator",
            "        for func_name, legacy_name in legacy_map.items():",
            "            func = getattr(obj, func_name)",
            "            setattr(obj, legacy_name, func)",
            "",
            "            permissions = perm_map.get(func_name)",
            "            if permissions is not None:",
            "                perm_map[legacy_name] = permissions",
            "",
            "        return obj",
            "",
            "    def __init__(self, core):",
            "        self.pyload = core",
            "        self._ = core._",
            "",
            "    def _convert_py_file(self, p):",
            "        f = FileData(",
            "            p[\"id\"],",
            "            p[\"url\"],",
            "            p[\"name\"],",
            "            p[\"plugin\"],",
            "            p[\"size\"],",
            "            p[\"format_size\"],",
            "            p[\"status\"],",
            "            p[\"statusmsg\"],",
            "            p[\"package\"],",
            "            p[\"error\"],",
            "            p[\"order\"],",
            "        )",
            "        return f",
            "",
            "    def _convert_config_format(self, c):",
            "        sections = {}",
            "        for section_name, sub in c.items():",
            "            section = ConfigSection(section_name, sub[\"desc\"])",
            "            items = []",
            "            for key, data in sub.items():",
            "                if key in (\"desc\", \"outline\"):",
            "                    continue",
            "                item = ConfigItem()",
            "                item.name = key",
            "                item.description = data[\"desc\"]",
            "                item.value = str(data[\"value\"])",
            "                item.type = data[\"type\"]",
            "                items.append(item)",
            "            section.items = items",
            "            sections[section_name] = section",
            "            if \"outline\" in sub:",
            "                section.outline = sub[\"outline\"]",
            "        return sections",
            "",
            "    @legacy(\"getConfigValue\")",
            "    @permission(Perms.SETTINGS)",
            "    def get_config_value(self, category, option, section=\"core\"):",
            "        \"\"\"",
            "        Retrieve config value.",
            "",
            "        :param category: name of category, or plugin",
            "        :param option: config option",
            "        :param section: 'plugin' or 'core'",
            "        :return: config value",
            "        \"\"\"",
            "        if section == \"core\":",
            "            value = self.pyload.config[category][option]",
            "        else:",
            "            value = self.pyload.config.get_plugin(category, option)",
            "        return value",
            "",
            "    @legacy(\"setConfigValue\")",
            "    @permission(Perms.SETTINGS)",
            "    def set_config_value(self, category, option, value, section=\"core\"):",
            "        \"\"\"",
            "        Set new config value.",
            "",
            "        :param category:",
            "        :param option:",
            "        :param value: new config value",
            "        :param section: 'plugin' or 'core",
            "        \"\"\"",
            "        self.pyload.addon_manager.dispatch_event(",
            "            \"config_changed\", category, option, value, section",
            "        )",
            "",
            "        if section == \"core\":",
            "            self.pyload.config[category][option] = value",
            "",
            "            if option in (",
            "                \"limit_speed\",",
            "                \"max_speed\",",
            "            ):  #: not so nice to update the limit",
            "                self.pyload.request_factory.update_bucket()",
            "",
            "        elif section == \"plugin\":",
            "            self.pyload.config.set_plugin(category, option, value)",
            "",
            "    @legacy(\"getConfig\")",
            "    @permission(Perms.SETTINGS)",
            "    def get_config(self):",
            "        \"\"\"",
            "        Retrieves complete config of core.",
            "",
            "        :return: list of `ConfigSection`",
            "        \"\"\"",
            "        return self._convert_config_format(self.pyload.config.config)",
            "",
            "    @legacy(\"getConfigDict\")",
            "    def get_config_dict(self):",
            "        \"\"\"",
            "        Retrieves complete config in dict format, not for RPC.",
            "",
            "        :return: dict",
            "        \"\"\"",
            "        return self.pyload.config.config",
            "",
            "    @legacy(\"getPluginConfig\")",
            "    @permission(Perms.SETTINGS)",
            "    def get_plugin_config(self):",
            "        \"\"\"",
            "        Retrieves complete config for all plugins.",
            "",
            "        :return: list of `ConfigSection`",
            "        \"\"\"",
            "        return self._convert_config_format(self.pyload.config.plugin)",
            "",
            "    @legacy(\"getPluginConfigDict\")",
            "    def get_plugin_config_dict(self):",
            "        \"\"\"",
            "        Plugin config as dict, not for RPC.",
            "",
            "        :return: dict",
            "        \"\"\"",
            "        return self.pyload.config.plugin",
            "",
            "    @legacy(\"pauseServer\")",
            "    @permission(Perms.STATUS)",
            "    def pause_server(self):",
            "        \"\"\"",
            "        Pause server: It won't start any new downloads, but nothing gets aborted.",
            "        \"\"\"",
            "        self.pyload.thread_manager.pause = True",
            "",
            "    @legacy(\"unpauseServer\")",
            "    @permission(Perms.STATUS)",
            "    def unpause_server(self):",
            "        \"\"\"",
            "        Unpause server: New Downloads will be started.",
            "        \"\"\"",
            "        self.pyload.thread_manager.pause = False",
            "",
            "    @legacy(\"togglePause\")",
            "    @permission(Perms.STATUS)",
            "    def toggle_pause(self):",
            "        \"\"\"",
            "        Toggle pause state.",
            "",
            "        :return: new pause state",
            "        \"\"\"",
            "        self.pyload.thread_manager.pause ^= True",
            "        return self.pyload.thread_manager.pause",
            "",
            "    @legacy(\"toggleReconnect\")",
            "    @permission(Perms.STATUS)",
            "    def toggle_reconnect(self):",
            "        \"\"\"",
            "        Toggle reconnect activation.",
            "",
            "        :return: new reconnect state",
            "        \"\"\"",
            "        self.pyload.config.toggle(\"reconnect\", \"enabled\")",
            "        return self.pyload.config.get(\"reconnect\", \"enabled\")",
            "",
            "    @legacy(\"statusServer\")",
            "    @permission(Perms.LIST)",
            "    def status_server(self):",
            "        \"\"\"",
            "        Some general information about the current status of pyLoad.",
            "",
            "        :return: `ServerStatus`",
            "        \"\"\"",
            "        server_status = ServerStatus(",
            "            self.pyload.thread_manager.pause,",
            "            len(self.pyload.thread_manager.processing_ids()),",
            "            self.pyload.files.get_queue_count(),",
            "            self.pyload.files.get_file_count(),",
            "            0,",
            "            not self.pyload.thread_manager.pause and self.is_time_download(),",
            "            self.pyload.config.get(\"reconnect\", \"enabled\") and self.is_time_reconnect(),",
            "            self.is_captcha_waiting(),",
            "        )",
            "",
            "        for pyfile in [",
            "            x.active",
            "            for x in self.pyload.thread_manager.threads",
            "            if x.active and isinstance(x.active, PyFile)",
            "        ]:",
            "            server_status.speed += pyfile.get_speed()  #: bytes/s",
            "",
            "        return server_status",
            "",
            "    @legacy(\"freeSpace\")",
            "    @permission(Perms.STATUS)",
            "    def free_space(self):",
            "        \"\"\"",
            "        Available free space at download directory in bytes.",
            "        \"\"\"",
            "        return fs.free_space(self.pyload.config.get(\"general\", \"storage_folder\"))",
            "",
            "    @legacy(\"getServerVersion\")",
            "    @permission(Perms.ANY)",
            "    def get_server_version(self):",
            "        \"\"\"",
            "        pyLoad Core version.",
            "        \"\"\"",
            "        return self.pyload.version",
            "",
            "    def kill(self):",
            "        \"\"\"",
            "        Clean way to quit pyLoad.",
            "        \"\"\"",
            "        self.pyload._do_exit = True",
            "",
            "    def restart(self):",
            "        \"\"\"",
            "        Restart pyload core.",
            "        \"\"\"",
            "        self.pyload._do_restart = True",
            "",
            "    @legacy(\"getLog\")",
            "    @permission(Perms.LOGS)",
            "    def get_log(self, offset=0):",
            "        \"\"\"",
            "        Returns most recent log entries.",
            "",
            "        :param offset: line offset",
            "        :return: List of log entries",
            "        \"\"\"",
            "        filelog_folder = self.pyload.config.get(\"log\", \"filelog_folder\")",
            "        if not filelog_folder:",
            "            filelog_folder = os.path.join(self.pyload.userdir, \"logs\")",
            "",
            "        path = os.path.join(filelog_folder, \"pyload\" + LogFactory.FILE_EXTENSION)",
            "        try:",
            "            with open(path) as fh:",
            "                lines = fh.readlines()",
            "            if offset >= len(lines):",
            "                return []",
            "            return lines[offset:]",
            "        except Exception:",
            "            return [\"No log available\"]",
            "",
            "    @legacy(\"isTimeDownload\")",
            "    @permission(Perms.STATUS)",
            "    def is_time_download(self):",
            "        \"\"\"",
            "        Checks if pyload will start new downloads according to time in config.",
            "",
            "        :return: bool",
            "        \"\"\"",
            "        start = self.pyload.config.get(\"download\", \"start_time\").split(\":\")",
            "        end = self.pyload.config.get(\"download\", \"end_time\").split(\":\")",
            "        return seconds.compare(start, end)",
            "",
            "    @legacy(\"isTimeReconnect\")",
            "    @permission(Perms.STATUS)",
            "    def is_time_reconnect(self):",
            "        \"\"\"",
            "        Checks if pyload will try to make a reconnect.",
            "",
            "        :return: bool",
            "        \"\"\"",
            "        start = self.pyload.config.get(\"reconnect\", \"start_time\").split(\":\")",
            "        end = self.pyload.config.get(\"reconnect\", \"end_time\").split(\":\")",
            "        return seconds.compare(start, end) and self.pyload.config.get(",
            "            \"reconnect\", \"enabled\"",
            "        )",
            "",
            "    @legacy(\"statusDownloads\")",
            "    @permission(Perms.LIST)",
            "    def status_downloads(self):",
            "        \"\"\"",
            "        Status off all currently running downloads.",
            "",
            "        :return: list of `DownloadStatus`",
            "        \"\"\"",
            "        data = []",
            "        for pyfile in self.pyload.thread_manager.get_active_files():",
            "            if not isinstance(pyfile, PyFile):",
            "                continue",
            "",
            "            data.append(",
            "                DownloadInfo(",
            "                    pyfile.id,",
            "                    pyfile.name,",
            "                    pyfile.get_speed(),",
            "                    pyfile.get_eta(),",
            "                    pyfile.format_eta(),",
            "                    pyfile.get_bytes_left(),",
            "                    pyfile.get_size(),",
            "                    pyfile.format_size(),",
            "                    pyfile.get_percent(),",
            "                    pyfile.status,",
            "                    pyfile.get_status_name(),",
            "                    pyfile.format_wait(),",
            "                    pyfile.wait_until,",
            "                    pyfile.packageid,",
            "                    pyfile.package().name,",
            "                    pyfile.pluginname,",
            "                )",
            "            )",
            "",
            "        return data",
            "",
            "    @legacy(\"addPackage\")",
            "    @permission(Perms.ADD)",
            "    def add_package(self, name, links, dest=Destination.QUEUE):",
            "        \"\"\"",
            "        Adds a package, with links to desired destination.",
            "",
            "        :param name: name of the new package",
            "        :param links: list of urls",
            "        :param dest: `Destination`",
            "        :return: package id of the new package",
            "        \"\"\"",
            "        if self.pyload.config.get(\"general\", \"folder_per_package\"):",
            "            folder = name",
            "        else:",
            "            folder = \"\"",
            "",
            "        folder = (",
            "            folder.replace(\"http://\", \"\")",
            "            .replace(\"https://\", \"\")",
            "            .replace(\"../\", \"_\")",
            "            .replace(\"..\\\\\", \"_\")",
            "            .replace(\":\", \"\")",
            "            .replace(\"/\", \"_\")",
            "            .replace(\"\\\\\", \"_\")",
            "        )",
            "",
            "        package_id = self.pyload.files.add_package(name, folder, Destination(dest))",
            "",
            "        self.pyload.files.add_links(links, package_id)",
            "",
            "        self.pyload.log.info(",
            "            self._(\"Added package {name} containing {count:d} links\").format(",
            "                name=name, count=len(links)",
            "            )",
            "        )",
            "",
            "        self.pyload.files.save()",
            "",
            "        return package_id",
            "",
            "    @legacy(\"parseURLs\")",
            "    @permission(Perms.ADD)",
            "    def parse_urls(self, html=None, url=None):",
            "        \"\"\"",
            "        Parses html content or any arbitrary text for links and returns result of",
            "        `check_urls`",
            "",
            "        :param html: html source",
            "        :param url: url to load html source from",
            "        :return:",
            "        \"\"\"",
            "        urls = []",
            "",
            "        if html:",
            "            urls += urlmatcher.findall(html)",
            "",
            "        if url:",
            "            page = get_url(url)",
            "            urls += urlmatcher.findall(page)",
            "",
            "        # remove duplicates",
            "        return self.check_urls(set(urls))",
            "",
            "    @legacy(\"checkURLs\")",
            "    @permission(Perms.ADD)",
            "    def check_urls(self, urls):",
            "        \"\"\"",
            "        Gets urls and returns pluginname mapped to list of matches urls.",
            "",
            "        :param urls:",
            "        :return: {plugin: urls}",
            "        \"\"\"",
            "        data = self.pyload.plugin_manager.parse_urls(urls)",
            "        plugins = {}",
            "",
            "        for url, plugin in data:",
            "            if plugin in plugins:",
            "                plugins[plugin].append(url)",
            "            else:",
            "                plugins[plugin] = [url]",
            "",
            "        return plugins",
            "",
            "    @legacy(\"checkOnlineStatus\")",
            "    @permission(Perms.ADD)",
            "    def check_online_status(self, urls):",
            "        \"\"\"",
            "        initiates online status check.",
            "",
            "        :param urls:",
            "        :return: initial set of data as `OnlineCheck` instance containing the result id",
            "        \"\"\"",
            "        data = self.pyload.plugin_manager.parse_urls(urls)",
            "",
            "        rid = self.pyload.thread_manager.create_result_thread(data, False)",
            "",
            "        tmp = [",
            "            (url, (url, OnlineStatus(url, pluginname, \"unknown\", 3, 0)))",
            "            for url, pluginname in data",
            "        ]",
            "        data = parse_names(tmp)",
            "        result = {}",
            "",
            "        for k, v in data.items():",
            "            for url, status in v:",
            "                status.packagename = k",
            "                result[url] = status",
            "",
            "        return OnlineCheck(rid, result)",
            "",
            "    @legacy(\"checkOnlineStatusContainer\")",
            "    @permission(Perms.ADD)",
            "    def check_online_status_container(self, urls, container, data):",
            "        \"\"\"",
            "        checks online status of urls and a submitted container file.",
            "",
            "        :param urls: list of urls",
            "        :param container: container file name",
            "        :param data: file content",
            "        :return: online check",
            "        \"\"\"",
            "        with open(",
            "            os.path.join(",
            "                self.pyload.config.get(\"general\", \"storage_folder\"), \"tmp_\" + container",
            "            ),",
            "            \"wb\",",
            "        ) as th:",
            "            th.write(data)",
            "",
            "        return self.check_online_status(urls + [th.name])",
            "",
            "    @legacy(\"pollResults\")",
            "    @permission(Perms.ADD)",
            "    def poll_results(self, rid):",
            "        \"\"\"",
            "        Polls the result available for ResultID.",
            "",
            "        :param rid: `ResultID`",
            "        :return: `OnlineCheck`, if rid is -1 then no more data available",
            "        \"\"\"",
            "        result = self.pyload.thread_manager.get_info_result(rid)",
            "",
            "        if \"ALL_INFO_FETCHED\" in result:",
            "            del result[\"ALL_INFO_FETCHED\"]",
            "            return OnlineCheck(-1, result)",
            "        else:",
            "            return OnlineCheck(rid, result)",
            "",
            "    @legacy(\"generatePackages\")",
            "    @permission(Perms.ADD)",
            "    def generate_packages(self, links):",
            "        \"\"\"",
            "        Parses links, generates packages names from urls.",
            "",
            "        :param links: list of urls",
            "        :return: package names mapped to urls",
            "        \"\"\"",
            "        result = parse_names((x, x) for x in links)",
            "        return result",
            "",
            "    @legacy(\"generateAndAddPackages\")",
            "    @permission(Perms.ADD)",
            "    def generate_and_add_packages(self, links, dest=Destination.COLLECTOR):",
            "        \"\"\"",
            "        Generates and add packages.",
            "",
            "        :param links: list of urls",
            "        :param dest: `Destination`",
            "        :return: list of package ids",
            "        \"\"\"",
            "        return [",
            "            self.add_package(name, urls, dest)",
            "            for name, urls in self.generate_packages(links).items()",
            "        ]",
            "",
            "    @legacy(\"checkAndAddPackages\")",
            "    @permission(Perms.ADD)",
            "    def check_and_add_packages(self, links, dest=Destination.COLLECTOR):",
            "        \"\"\"",
            "        Checks online status, retrieves names, and will add packages.",
            "        Because of these packages are not added immediately, only for internal use.",
            "",
            "        :param links: list of urls",
            "        :param dest: `Destination`",
            "        :return: None",
            "        \"\"\"",
            "        data = self.pyload.plugin_manager.parse_urls(links)",
            "        self.pyload.thread_manager.create_result_thread(data, True)",
            "",
            "    @legacy(\"getPackageData\")",
            "    @permission(Perms.LIST)",
            "    def get_package_data(self, package_id):",
            "        \"\"\"",
            "        Returns complete information about package, and included files.",
            "",
            "        :param package_id: package id",
            "        :return: `PackageData` with .links attribute",
            "        \"\"\"",
            "        data = self.pyload.files.get_package_data(int(package_id))",
            "",
            "        if not data:",
            "            raise PackageDoesNotExists(package_id)",
            "",
            "        pdata = PackageData(",
            "            data[\"id\"],",
            "            data[\"name\"],",
            "            data[\"folder\"],",
            "            data[\"site\"],",
            "            data[\"password\"],",
            "            data[\"queue\"],",
            "            data[\"order\"],",
            "            links=[self._convert_py_file(x) for x in data[\"links\"].values()],",
            "        )",
            "",
            "        return pdata",
            "",
            "    @legacy(\"getPackageInfo\")",
            "    @permission(Perms.LIST)",
            "    def get_package_info(self, package_id):",
            "        \"\"\"",
            "        Returns information about package, without detailed information about containing",
            "        files.",
            "",
            "        :param package_id: package id",
            "        :return: `PackageData` with .fid attribute",
            "        \"\"\"",
            "        data = self.pyload.files.get_package_data(int(package_id))",
            "",
            "        if not data:",
            "            raise PackageDoesNotExists(package_id)",
            "",
            "        pdata = PackageData(",
            "            data[\"id\"],",
            "            data[\"name\"],",
            "            data[\"folder\"],",
            "            data[\"site\"],",
            "            data[\"password\"],",
            "            data[\"queue\"],",
            "            data[\"order\"],",
            "            fids=[int(x) for x in data[\"links\"]],",
            "        )",
            "",
            "        return pdata",
            "",
            "    @legacy(\"getFileData\")",
            "    @permission(Perms.LIST)",
            "    def get_file_data(self, file_id):",
            "        \"\"\"",
            "        Get complete information about a specific file.",
            "",
            "        :param file_id: file id",
            "        :return: `FileData`",
            "        \"\"\"",
            "        info = self.pyload.files.get_file_data(int(file_id))",
            "        if not info:",
            "            raise FileDoesNotExists(file_id)",
            "",
            "        fileinfo = list(info.values())[0]",
            "        fdata = self._convert_py_file(fileinfo)",
            "        return fdata",
            "",
            "    @legacy(\"deleteFiles\")",
            "    @permission(Perms.DELETE)",
            "    def delete_files(self, file_ids):",
            "        \"\"\"",
            "        Deletes several file entries from pyload.",
            "",
            "        :param file_ids: list of file ids",
            "        \"\"\"",
            "        for id in file_ids:",
            "            self.pyload.files.delete_link(int(id))",
            "",
            "        self.pyload.files.save()",
            "",
            "    @legacy(\"deletePackages\")",
            "    @permission(Perms.DELETE)",
            "    def delete_packages(self, package_ids):",
            "        \"\"\"",
            "        Deletes packages and containing links.",
            "",
            "        :param package_ids: list of package ids",
            "        \"\"\"",
            "        for id in package_ids:",
            "            self.pyload.files.delete_package(int(id))",
            "",
            "        self.pyload.files.save()",
            "",
            "    @legacy(\"getQueue\")",
            "    @permission(Perms.LIST)",
            "    def get_queue(self):",
            "        \"\"\"",
            "        Returns info about queue and packages, **not** about files, see `get_queue_data` \\",
            "        or `get_package_data` instead.",
            "",
            "        :return: list of `PackageInfo`",
            "        \"\"\"",
            "        return [",
            "            PackageData(",
            "                pack[\"id\"],",
            "                pack[\"name\"],",
            "                pack[\"folder\"],",
            "                pack[\"site\"],",
            "                pack[\"password\"],",
            "                pack[\"queue\"],",
            "                pack[\"order\"],",
            "                pack[\"linksdone\"],",
            "                pack[\"sizedone\"],",
            "                pack[\"sizetotal\"],",
            "                pack[\"linkstotal\"],",
            "            )",
            "            for pack in self.pyload.files.get_info_data(Destination.QUEUE).values()",
            "        ]",
            "",
            "    @legacy(\"getQueueData\")",
            "    @permission(Perms.LIST)",
            "    def get_queue_data(self):",
            "        \"\"\"",
            "        Return complete data about everything in queue, this is very expensive use it",
            "        sparely.",
            "        See `get_queue` for alternative.",
            "",
            "        :return: list of `PackageData`",
            "        \"\"\"",
            "        return [",
            "            PackageData(",
            "                pack[\"id\"],",
            "                pack[\"name\"],",
            "                pack[\"folder\"],",
            "                pack[\"site\"],",
            "                pack[\"password\"],",
            "                pack[\"queue\"],",
            "                pack[\"order\"],",
            "                pack[\"linksdone\"],",
            "                pack[\"sizedone\"],",
            "                pack[\"sizetotal\"],",
            "                links=[self._convert_py_file(x) for x in pack[\"links\"].values()],",
            "            )",
            "            for pack in self.pyload.files.get_complete_data(Destination.QUEUE).values()",
            "        ]",
            "",
            "    @legacy(\"getCollector\")",
            "    @permission(Perms.LIST)",
            "    def get_collector(self):",
            "        \"\"\"",
            "        same as `get_queue` for collector.",
            "",
            "        :return: list of `PackageInfo`",
            "        \"\"\"",
            "        return [",
            "            PackageData(",
            "                pack[\"id\"],",
            "                pack[\"name\"],",
            "                pack[\"folder\"],",
            "                pack[\"site\"],",
            "                pack[\"password\"],",
            "                pack[\"queue\"],",
            "                pack[\"order\"],",
            "                pack[\"linksdone\"],",
            "                pack[\"sizedone\"],",
            "                pack[\"sizetotal\"],",
            "                pack[\"linkstotal\"],",
            "            )",
            "            for pack in self.pyload.files.get_info_data(Destination.COLLECTOR).values()",
            "        ]",
            "",
            "    @legacy(\"getCollectorData\")",
            "    @permission(Perms.LIST)",
            "    def get_collector_data(self):",
            "        \"\"\"",
            "        same as `get_queue_data` for collector.",
            "",
            "        :return: list of `PackageInfo`",
            "        \"\"\"",
            "        return [",
            "            PackageData(",
            "                pack[\"id\"],",
            "                pack[\"name\"],",
            "                pack[\"folder\"],",
            "                pack[\"site\"],",
            "                pack[\"password\"],",
            "                pack[\"queue\"],",
            "                pack[\"order\"],",
            "                pack[\"linksdone\"],",
            "                pack[\"sizedone\"],",
            "                pack[\"sizetotal\"],",
            "                links=[self._convert_py_file(x) for x in pack[\"links\"].values()],",
            "            )",
            "            for pack in self.pyload.files.get_complete_data(",
            "                Destination.COLLECTOR",
            "            ).values()",
            "        ]",
            "",
            "    @legacy(\"addFiles\")",
            "    @permission(Perms.ADD)",
            "    def add_files(self, package_id, links):",
            "        \"\"\"",
            "        Adds files to specific package.",
            "",
            "        :param package_id: package id",
            "        :param links: list of urls",
            "        \"\"\"",
            "        self.pyload.files.add_links(links, int(package_id))",
            "",
            "        self.pyload.log.info(",
            "            self._(\"Added {count:d} links to package #{package:d} \").format(",
            "                count=len(links), package=package_id",
            "            )",
            "        )",
            "        self.pyload.files.save()",
            "",
            "    @legacy(\"pushToQueue\")",
            "    @permission(Perms.MODIFY)",
            "    def push_to_queue(self, package_id):",
            "        \"\"\"",
            "        Moves package from Collector to Queue.",
            "",
            "        :param package_id: package id",
            "        \"\"\"",
            "        self.pyload.files.set_package_location(package_id, Destination.QUEUE)",
            "",
            "    @legacy(\"pullFromQueue\")",
            "    @permission(Perms.MODIFY)",
            "    def pull_from_queue(self, package_id):",
            "        \"\"\"",
            "        Moves package from Queue to Collector.",
            "",
            "        :param package_id: package id",
            "        \"\"\"",
            "        self.pyload.files.set_package_location(package_id, Destination.COLLECTOR)",
            "",
            "    @legacy(\"restartPackage\")",
            "    @permission(Perms.MODIFY)",
            "    def restart_package(self, package_id):",
            "        \"\"\"",
            "        Restarts a package, resets every containing files.",
            "",
            "        :param package_id: package id",
            "        \"\"\"",
            "        self.pyload.files.restart_package(int(package_id))",
            "",
            "    @legacy(\"restartFile\")",
            "    @permission(Perms.MODIFY)",
            "    def restart_file(self, file_id):",
            "        \"\"\"",
            "        Resets file status, so it will be downloaded again.",
            "",
            "        :param file_id:  file id",
            "        \"\"\"",
            "        self.pyload.files.restart_file(int(file_id))",
            "",
            "    @legacy(\"recheckPackage\")",
            "    @permission(Perms.MODIFY)",
            "    def recheck_package(self, package_id):",
            "        \"\"\"",
            "        Probes online status of all files in a package, also a default action when",
            "        package is added.",
            "",
            "        :param package_id:",
            "        :return:",
            "        \"\"\"",
            "        self.pyload.files.recheck_package(int(package_id))",
            "",
            "    @legacy(\"stopAllDownloads\")",
            "    @permission(Perms.MODIFY)",
            "    def stop_all_downloads(self):",
            "        \"\"\"",
            "        Aborts all running downloads.",
            "        \"\"\"",
            "        pyfiles = list(self.pyload.files.cache.values())",
            "        for pyfile in pyfiles:",
            "            pyfile.abort_download()",
            "",
            "    @legacy(\"stopDownloads\")",
            "    @permission(Perms.MODIFY)",
            "    def stop_downloads(self, file_ids):",
            "        \"\"\"",
            "        Aborts specific downloads.",
            "",
            "        :param file_ids: list of file ids",
            "        :return:",
            "        \"\"\"",
            "        pyfiles = list(self.pyload.files.cache.values())",
            "        for pyfile in pyfiles:",
            "            if pyfile.id in file_ids:",
            "                pyfile.abort_download()",
            "",
            "    @legacy(\"setPackageName\")",
            "    @permission(Perms.MODIFY)",
            "    def set_package_name(self, package_id, name):",
            "        \"\"\"",
            "        Renames a package.",
            "",
            "        :param package_id: package id",
            "        :param name: new package name",
            "        \"\"\"",
            "        pack = self.pyload.files.get_package(package_id)",
            "        pack.name = name",
            "        pack.sync()",
            "",
            "    @legacy(\"movePackage\")",
            "    @permission(Perms.MODIFY)",
            "    def move_package(self, destination, package_id):",
            "        \"\"\"",
            "        Set a new package location.",
            "",
            "        :param destination: `Destination`",
            "        :param package_id: package id",
            "        \"\"\"",
            "        try:",
            "            dest = Destination(destination)",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            self.pyload.files.set_package_location(package_id, dest)",
            "",
            "    @legacy(\"moveFiles\")",
            "    @permission(Perms.MODIFY)",
            "    def move_files(self, file_ids, package_id):",
            "        \"\"\"",
            "        Move multiple files to another package.",
            "",
            "        :param file_ids: list of file ids",
            "        :param package_id: destination package",
            "        :return:",
            "        \"\"\"",
            "        # TODO: implement",
            "        pass",
            "",
            "    @legacy(\"uploadContainer\")",
            "    @permission(Perms.ADD)",
            "    def upload_container(self, filename, data):",
            "        \"\"\"",
            "        Uploads and adds a container file to pyLoad.",
            "",
            "        :param filename: file name - extension is important, so it can correctly decrypt",
            "        :param data: file content",
            "        \"\"\"",
            "        with open(",
            "            os.path.join(",
            "                self.pyload.config.get(\"general\", \"storage_folder\"), \"tmp_\" + filename",
            "            ),",
            "            \"wb\",",
            "        ) as th:",
            "            th.write(data)",
            "",
            "        self.add_package(th.name, [th.name], Destination.COLLECTOR)",
            "",
            "    @legacy(\"orderPackage\")",
            "    @permission(Perms.MODIFY)",
            "    def order_package(self, package_id, position):",
            "        \"\"\"",
            "        Gives a package a new position.",
            "",
            "        :param package_id: package id",
            "        :param position:",
            "        \"\"\"",
            "        self.pyload.files.reorder_package(package_id, position)",
            "",
            "    @legacy(\"orderFile\")",
            "    @permission(Perms.MODIFY)",
            "    def order_file(self, file_id, position):",
            "        \"\"\"",
            "        Gives a new position to a file within its package.",
            "",
            "        :param file_id: file id",
            "        :param position:",
            "        \"\"\"",
            "        self.pyload.files.reorder_file(file_id, position)",
            "",
            "    @legacy(\"setPackageData\")",
            "    @permission(Perms.MODIFY)",
            "    def set_package_data(self, package_id, data):",
            "        \"\"\"",
            "        Allows to modify several package attributes.",
            "",
            "        :param package_id: package id",
            "        :param data: dict that maps attribute to desired value",
            "        \"\"\"",
            "        p = self.pyload.files.get_package(package_id)",
            "        if not p:",
            "            raise PackageDoesNotExists(package_id)",
            "",
            "        for key, value in data.items():",
            "            if key == \"id\":",
            "                continue",
            "            setattr(p, key, value)",
            "",
            "        p.sync()",
            "        self.pyload.files.save()",
            "",
            "    @legacy(\"deleteFinished\")",
            "    @permission(Perms.DELETE)",
            "    def delete_finished(self):",
            "        \"\"\"",
            "        Deletes all finished files and completely finished packages.",
            "",
            "        :return: list of deleted package ids",
            "        \"\"\"",
            "        return self.pyload.files.delete_finished_links()",
            "",
            "    @legacy(\"restartFailed\")",
            "    @permission(Perms.MODIFY)",
            "    def restart_failed(self):",
            "        \"\"\"",
            "        Restarts all failed failes.",
            "        \"\"\"",
            "        self.pyload.files.restart_failed()",
            "",
            "    @legacy(\"getPackageOrder\")",
            "    @permission(Perms.LIST)",
            "    def get_package_order(self, destination):",
            "        \"\"\"",
            "        Returns information about package order.",
            "",
            "        :param destination: `Destination`",
            "        :return: dict mapping order to package id",
            "        \"\"\"",
            "        packages = self.pyload.files.get_info_data(Destination(destination))",
            "        order = {}",
            "",
            "        for package_id in packages:",
            "            pack = self.pyload.files.get_package_data(int(package_id))",
            "            while pack[\"order\"] in order.keys():  #: just in case",
            "                pack[\"order\"] += 1",
            "            order[pack[\"order\"]] = pack[\"id\"]",
            "        return order",
            "",
            "    @legacy(\"getFileOrder\")",
            "    @permission(Perms.LIST)",
            "    def get_file_order(self, package_id):",
            "        \"\"\"",
            "        Information about file order within package.",
            "",
            "        :param package_id:",
            "        :return: dict mapping order to file id",
            "        \"\"\"",
            "        raw_data = self.pyload.files.get_package_data(int(package_id))",
            "        order = {}",
            "        for id, pyfile in raw_data[\"links\"].items():",
            "            while pyfile[\"order\"] in order.keys():  #: just in case",
            "                pyfile[\"order\"] += 1",
            "            order[pyfile[\"order\"]] = pyfile[\"id\"]",
            "        return order",
            "",
            "    @legacy(\"isCaptchaWaiting\")",
            "    @permission(Perms.STATUS)",
            "    def is_captcha_waiting(self):",
            "        \"\"\"",
            "        Indicates wether a captcha task is available.",
            "",
            "        :return: bool",
            "        \"\"\"",
            "        self.pyload.last_client_connected = time.time()",
            "        task = self.pyload.captcha_manager.get_task()",
            "        return task is not None",
            "",
            "    @legacy(\"getCaptchaTask\")",
            "    @permission(Perms.STATUS)",
            "    def get_captcha_task(self, exclusive=False):",
            "        \"\"\"",
            "        Returns a captcha task.",
            "",
            "        :param exclusive: unused",
            "        :return: `CaptchaTask`",
            "        \"\"\"",
            "        self.pyload.last_client_connected = time.time()",
            "        task = self.pyload.captcha_manager.get_task()",
            "        if task:",
            "            task.set_waiting_for_user(exclusive=exclusive)",
            "            data, type, result = task.get_captcha()",
            "            t = CaptchaTask(int(task.id), json.dumps(data), type, result)",
            "            return t",
            "        else:",
            "            return CaptchaTask(-1)",
            "",
            "    @legacy(\"getCaptchaTaskStatus\")",
            "    @permission(Perms.STATUS)",
            "    def get_captcha_task_status(self, tid):",
            "        \"\"\"",
            "        Get information about captcha task.",
            "",
            "        :param tid: task id",
            "        :return: string",
            "        \"\"\"",
            "        self.pyload.last_client_connected = time.time()",
            "        t = self.pyload.captcha_manager.get_task_by_id(tid)",
            "        return t.get_status() if t else \"\"",
            "",
            "    @legacy(\"setCaptchaResult\")",
            "    @permission(Perms.STATUS)",
            "    def set_captcha_result(self, tid, result):",
            "        \"\"\"",
            "        Set result for a captcha task.",
            "",
            "        :param tid: task id",
            "        :param result: captcha result",
            "        \"\"\"",
            "        self.pyload.last_client_connected = time.time()",
            "        task = self.pyload.captcha_manager.get_task_by_id(tid)",
            "        if task:",
            "            task.set_result(result)",
            "            self.pyload.captcha_manager.remove_task(task)",
            "",
            "    @legacy(\"getEvents\")",
            "    @permission(Perms.STATUS)",
            "    def get_events(self, uuid):",
            "        \"\"\"",
            "        Lists occurred events, may be affected to changes in the future.",
            "",
            "        :param uuid:",
            "        :return: list of `Events`",
            "        \"\"\"",
            "        events = self.pyload.event_manager.get_events(uuid)",
            "        new_events = []",
            "",
            "        def conv_dest(d):",
            "            return (Destination.QUEUE if d == \"queue\" else Destination.COLLECTOR).value",
            "",
            "        for e in events:",
            "            event = EventInfo()",
            "            event.eventname = e[0]",
            "            if e[0] in (\"update\", \"remove\", \"insert\"):",
            "                event.id = e[3]",
            "                event.type = (",
            "                    ElementType.PACKAGE if e[2] == \"pack\" else ElementType.FILE",
            "                ).value",
            "                event.destination = conv_dest(e[1])",
            "            elif e[0] == \"order\":",
            "                if e[1]:",
            "                    event.id = e[1]",
            "                    event.type = (",
            "                        ElementType.PACKAGE if e[2] == \"pack\" else ElementType.FILE",
            "                    )",
            "                    event.destination = conv_dest(e[3])",
            "            elif e[0] == \"reload\":",
            "                event.destination = conv_dest(e[1])",
            "            new_events.append(event)",
            "        return new_events",
            "",
            "    @legacy(\"getAccounts\")",
            "    @permission(Perms.ACCOUNTS)",
            "    def get_accounts(self, refresh):",
            "        \"\"\"",
            "        Get information about all entered accounts.",
            "",
            "        :param refresh: reload account info",
            "        :return: list of `AccountInfo`",
            "        \"\"\"",
            "        accs = self.pyload.account_manager.get_account_infos(False, refresh)",
            "        accounts = []",
            "        for group in accs.values():",
            "            accounts.extend(",
            "                [",
            "                    AccountInfo(",
            "                        acc[\"validuntil\"],",
            "                        acc[\"login\"],",
            "                        acc[\"options\"],",
            "                        acc[\"valid\"],",
            "                        acc[\"trafficleft\"],",
            "                        acc[\"premium\"],",
            "                        acc[\"type\"],",
            "                    )",
            "                    for acc in group",
            "                ]",
            "            )",
            "        return accounts",
            "",
            "    @legacy(\"getAccountTypes\")",
            "    @permission(Perms.ANY)",
            "    def get_account_types(self):",
            "        \"\"\"",
            "        All available account types.",
            "",
            "        :return: list",
            "        \"\"\"",
            "        return list(self.pyload.account_manager.accounts.keys())",
            "",
            "    @legacy(\"updateAccount\")",
            "    @permission(Perms.ACCOUNTS)",
            "    def update_account(self, plugin, account, password=None, options={}):",
            "        \"\"\"",
            "        Changes pw/options for specific account.",
            "        \"\"\"",
            "        self.pyload.account_manager.update_account(plugin, account, password, options)",
            "",
            "    @legacy(\"removeAccount\")",
            "    @permission(Perms.ACCOUNTS)",
            "    def remove_account(self, plugin, account):",
            "        \"\"\"",
            "        Remove account from pyload.",
            "",
            "        :param plugin: pluginname",
            "        :param account: accountname",
            "        \"\"\"",
            "        self.pyload.account_manager.remove_account(plugin, account)",
            "",
            "    @permission(Perms.ANY)",
            "    def login(self, username, password):",
            "        \"\"\"",
            "        Login into pyLoad, this **must** be called when using rpc before any methods can",
            "        be used.",
            "",
            "        :param username:",
            "        :param password:",
            "        :return: bool indicating login was successful",
            "        \"\"\"",
            "        return True if self.check_auth(username, password) else False",
            "",
            "    @legacy(\"checkAuth\")",
            "    def check_auth(self, username, password):",
            "        \"\"\"",
            "        Check authentication and returns details.",
            "",
            "        :param username:",
            "        :param password:",
            "        :return: dict with info, empty when login is incorrect",
            "        \"\"\"",
            "        return self.pyload.db.check_auth(username, password)",
            "",
            "    def user_exists(self, username):",
            "        \"\"\"",
            "        Check if a user actually exists in the database.",
            "",
            "        :param username:",
            "        :return: boolean",
            "        \"\"\"",
            "        return self.pyload.db.user_exists(username)",
            "",
            "    @legacy(\"isAuthorized\")",
            "    def is_authorized(self, func, userdata):",
            "        \"\"\"",
            "        checks if the user is authorized for specific method.",
            "",
            "        :param func: function name",
            "        :param userdata: dictionary of user data",
            "        :return: boolean",
            "        \"\"\"",
            "        if userdata[\"role\"] == Role.ADMIN:",
            "            return True",
            "        elif func in perm_map and has_permission(",
            "            userdata[\"permission\"], perm_map[func]",
            "        ):",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    @permission(Perms.SETTINGS)",
            "    def get_userdir(self):",
            "        return os.path.realpath(self.pyload.userdir)",
            "",
            "    @permission(Perms.SETTINGS)",
            "    def get_cachedir(self):",
            "        return os.path.realpath(self.pyload.tempdir)",
            "",
            "    #: Old API",
            "    @permission(Perms.ANY)",
            "    def getUserData(self, username, password):",
            "        \"\"\"",
            "        similar to `check_auth` but returns UserData thrift type.",
            "        \"\"\"",
            "        user = self.check_auth(username, password)",
            "        if user:",
            "            return OldUserData(",
            "                user[\"name\"],",
            "                user[\"email\"],",
            "                user[\"role\"],",
            "                user[\"permission\"],",
            "                user[\"template\"],",
            "            )",
            "        else:",
            "            return OldUserData()",
            "",
            "    @permission(Perms.ANY)",
            "    def get_userdata(self, username, password):",
            "        \"\"\"",
            "        similar to `check_auth` but returns UserData thrift type.",
            "        \"\"\"",
            "        user = self.check_auth(username, password)",
            "        if user:",
            "            return UserData(",
            "                user[\"id\"],",
            "                user[\"name\"],",
            "                user[\"email\"],",
            "                user[\"role\"],",
            "                user[\"permission\"],",
            "                user[\"template\"],",
            "            )",
            "        else:",
            "            return UserData()",
            "",
            "    #: Old API",
            "    def getAllUserData(self):",
            "        \"\"\"",
            "        returns all known user and info.",
            "        \"\"\"",
            "        res = {}",
            "        for id, data in self.pyload.db.get_all_user_data().items():",
            "            res[data[\"name\"]] = OldUserData(",
            "                data[\"name\"],",
            "                data[\"email\"],",
            "                data[\"role\"],",
            "                data[\"permission\"],",
            "                data[\"template\"],",
            "            )",
            "",
            "        return res",
            "",
            "    def get_all_userdata(self):",
            "        \"\"\"",
            "        returns all known user and info.",
            "        \"\"\"",
            "        res = {}",
            "        for id, data in self.pyload.db.get_all_user_data().items():",
            "            res[id] = UserData(",
            "                id,",
            "                data[\"name\"],",
            "                data[\"email\"],",
            "                data[\"role\"],",
            "                data[\"permission\"],",
            "                data[\"template\"],",
            "            )",
            "        return res",
            "",
            "    @legacy(\"getServices\")",
            "    @permission(Perms.STATUS)",
            "    def get_services(self):",
            "        \"\"\"",
            "        A dict of available services, these can be defined by addon plugins.",
            "",
            "        :return: dict with this style: {\"plugin\": {\"method\": \"description\"}}",
            "        \"\"\"",
            "        data = {}",
            "        for plugin, funcs in self.pyload.addon_manager.methods.items():",
            "            data[plugin] = funcs",
            "",
            "        return data",
            "",
            "    @legacy(\"hasService\")",
            "    @permission(Perms.STATUS)",
            "    def has_service(self, plugin, func):",
            "        \"\"\"",
            "        Checks whether a service is available.",
            "",
            "        :param plugin:",
            "        :param func:",
            "        :return: bool",
            "        \"\"\"",
            "        cont = self.pyload.addon_manager.methods",
            "        return plugin in cont and func in cont[plugin]",
            "",
            "    @permission(Perms.STATUS)",
            "    def call(self, info):",
            "        \"\"\"",
            "        Calls a service (a method in addon plugin).",
            "",
            "        :param info: `ServiceCall`",
            "        :return: result",
            "        :raises: ServiceDoesNotExists, when it's not available",
            "        :raises: ServiceException, when an exception was raised",
            "        \"\"\"",
            "        plugin = info.plugin",
            "        func = info.func",
            "        args = info.arguments",
            "        parse = info.parse_arguments",
            "",
            "        if not self.has_service(plugin, func):",
            "            raise ServiceDoesNotExists(plugin, func)",
            "",
            "        try:",
            "            ret = self.pyload.addon_manager.call_rpc(plugin, func, args, parse)",
            "            return str(ret)",
            "        except Exception as exc:",
            "            raise ServiceException(exc)",
            "",
            "    @legacy(\"getAllInfo\")",
            "    @permission(Perms.STATUS)",
            "    def get_all_info(self):",
            "        \"\"\"",
            "        Returns all information stored by addon plugins. Values are always strings.",
            "",
            "        :return: {\"plugin\": {\"name\": value } }",
            "        \"\"\"",
            "        return self.pyload.addon_manager.get_all_info()",
            "",
            "    @legacy(\"getInfoByPlugin\")",
            "    @permission(Perms.STATUS)",
            "    def get_info_by_plugin(self, plugin):",
            "        \"\"\"",
            "        Returns information stored by a specific plugin.",
            "",
            "        :param plugin: pluginname",
            "        :return: dict of attr names mapped to value {\"name\": value}",
            "        \"\"\"",
            "        return self.pyload.addon_manager.get_info(plugin)",
            "",
            "    def add_user(self, user, newpw, role=0, perms=0):",
            "        \"\"\"",
            "        creates new user login.",
            "        \"\"\"",
            "        return self.pyload.db.add_user(user, newpw, role, perms)",
            "",
            "    def remove_user(self, user):",
            "        \"\"\"",
            "        deletes a user login.",
            "        \"\"\"",
            "        return self.pyload.db.remove_user(user)",
            "",
            "    @legacy(\"changePassword\")",
            "    def change_password(self, user, oldpw, newpw):",
            "        \"\"\"",
            "        changes password for specific user.",
            "        \"\"\"",
            "        return self.pyload.db.change_password(user, oldpw, newpw)",
            "",
            "    @legacy(\"setUserPermission\")",
            "    def set_user_permission(self, user, permission, role):",
            "        self.pyload.db.set_permission(user, permission)",
            "        self.pyload.db.set_role(user, role)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#       ____________",
            "#   ___/       |    \\_____________ _                 _ ___",
            "#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\",
            "# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\",
            "# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /",
            "#  \\_______\\    /_______|_|   |__/________________________/",
            "#           \\  /",
            "#            \\/",
            "",
            "import json",
            "import os",
            "import re",
            "import time",
            "from enum import IntFlag",
            "",
            "from pyload import PKGDIR",
            "",
            "from ..datatypes.data import *",
            "from ..datatypes.enums import *",
            "from ..datatypes.exceptions import *",
            "from ..datatypes.pyfile import PyFile",
            "from ..log_factory import LogFactory",
            "from ..network.request_factory import get_url",
            "from ..utils import fs, seconds",
            "from ..utils.old.packagetools import parse_names",
            "",
            "# contains function names mapped to their permissions",
            "# unlisted functions are for admins only",
            "perm_map = {}",
            "",
            "# contains function names mapped to their legacy name",
            "legacy_map = {}",
            "",
            "",
            "# decorator only called on init, never initialized, so has no effect on runtime",
            "def permission(bits):",
            "    class Wrapper:",
            "        def __new__(cls, func, *args, **kwargs):",
            "            perm_map[func.__name__] = bits",
            "            return func",
            "",
            "    return Wrapper",
            "",
            "",
            "def legacy(legacy_name):",
            "    class Wrapper:",
            "        def __new__(cls, func, *args, **kwargs):",
            "            legacy_map[func.__name__] = legacy_name",
            "            return func",
            "",
            "    return Wrapper",
            "",
            "",
            "urlmatcher = re.compile(",
            "    r\"(?:https?|ftps?|xdcc|sftp):(?://|\\\\\\\\)+[\\w\\-._~:/?#\\[\\]@!$&'()*+,;=]*|magnet:\\?.+\",",
            "    re.IGNORECASE,",
            ")",
            "",
            "",
            "class Perms(IntFlag):",
            "    ANY = 0  #: requires no permission, but login",
            "    ADD = 1  #: can add packages",
            "    DELETE = 2  #: can delete packages",
            "    STATUS = 4  #: see and change server status",
            "    LIST = 16  #: see queue and collector",
            "    MODIFY = 32  #: modify some attribute of downloads",
            "    DOWNLOAD = 64  #: can download from webinterface",
            "    SETTINGS = 128  #: can access settings",
            "    ACCOUNTS = 256  #: can access accounts",
            "    LOGS = 512  #: can see server logs",
            "",
            "",
            "class Role(IntFlag):",
            "    ADMIN = 0  #: admin has all permissions implicit",
            "    USER = 1",
            "",
            "",
            "def has_permission(userperms, perms):",
            "    # bitwise or perms before if needed",
            "    return perms == (userperms & perms)",
            "",
            "",
            "# API VERSION",
            "__version__ = 1",
            "",
            "",
            "class Api:",
            "    \"\"\"",
            "    **pyLoads API**",
            "",
            "    This is accessible either internal via core.api or via thrift backend.",
            "",
            "    see Thrift specification file remote/thriftbackend/pyload.thrift\\",
            "    for information about data structures and what methods are usable with rpc.",
            "",
            "    Most methods requires specific permissions, please look at the source code if you need to know.\\",
            "    These can be configured via webinterface.",
            "    Admin user have all permissions, and are the only ones who can access the methods with no specific permission.",
            "    \"\"\"",
            "",
            "    def __new__(cls, core):",
            "        obj = super(Api, cls).__new__(cls)",
            "",
            "        # add methods specified by the @legacy decorator",
            "        # also set legacy method permissions according to the @permissions decorator",
            "        for func_name, legacy_name in legacy_map.items():",
            "            func = getattr(obj, func_name)",
            "            setattr(obj, legacy_name, func)",
            "",
            "            permissions = perm_map.get(func_name)",
            "            if permissions is not None:",
            "                perm_map[legacy_name] = permissions",
            "",
            "        return obj",
            "",
            "    def __init__(self, core):",
            "        self.pyload = core",
            "        self._ = core._",
            "",
            "    def _convert_py_file(self, p):",
            "        f = FileData(",
            "            p[\"id\"],",
            "            p[\"url\"],",
            "            p[\"name\"],",
            "            p[\"plugin\"],",
            "            p[\"size\"],",
            "            p[\"format_size\"],",
            "            p[\"status\"],",
            "            p[\"statusmsg\"],",
            "            p[\"package\"],",
            "            p[\"error\"],",
            "            p[\"order\"],",
            "        )",
            "        return f",
            "",
            "    def _convert_config_format(self, c):",
            "        sections = {}",
            "        for section_name, sub in c.items():",
            "            section = ConfigSection(section_name, sub[\"desc\"])",
            "            items = []",
            "            for key, data in sub.items():",
            "                if key in (\"desc\", \"outline\"):",
            "                    continue",
            "                item = ConfigItem()",
            "                item.name = key",
            "                item.description = data[\"desc\"]",
            "                item.value = str(data[\"value\"])",
            "                item.type = data[\"type\"]",
            "                items.append(item)",
            "            section.items = items",
            "            sections[section_name] = section",
            "            if \"outline\" in sub:",
            "                section.outline = sub[\"outline\"]",
            "        return sections",
            "",
            "    @legacy(\"getConfigValue\")",
            "    @permission(Perms.SETTINGS)",
            "    def get_config_value(self, category, option, section=\"core\"):",
            "        \"\"\"",
            "        Retrieve config value.",
            "",
            "        :param category: name of category, or plugin",
            "        :param option: config option",
            "        :param section: 'plugin' or 'core'",
            "        :return: config value",
            "        \"\"\"",
            "        if section == \"core\":",
            "            value = self.pyload.config[category][option]",
            "        else:",
            "            value = self.pyload.config.get_plugin(category, option)",
            "        return value",
            "",
            "    @legacy(\"setConfigValue\")",
            "    @permission(Perms.SETTINGS)",
            "    def set_config_value(self, category, option, value, section=\"core\"):",
            "        \"\"\"",
            "        Set new config value.",
            "",
            "        :param category:",
            "        :param option:",
            "        :param value: new config value",
            "        :param section: 'plugin' or 'core",
            "        \"\"\"",
            "        self.pyload.addon_manager.dispatch_event(",
            "            \"config_changed\", category, option, value, section",
            "        )",
            "",
            "        if section == \"core\":",
            "            if category == \"general\" and option == \"storage_folder\":",
            "                # Forbid setting the download folder inside dangerous locations",
            "                correct_case = lambda x: x.lower() if os.name == \"nt\" else x",
            "                directories = [",
            "                    correct_case(os.path.join(os.path.realpath(d), \"\"))",
            "                    for d in [value, PKGDIR, self.pyload.userdir]",
            "                ]",
            "                if any(directories[0].startswith(d) for d in directories[1:]):",
            "                    return",
            "",
            "            self.pyload.config.set(category, option, value)",
            "",
            "            if category == \"download\" and option in (",
            "                \"limit_speed\",",
            "                \"max_speed\",",
            "            ):  #: not such a nice method to update the limit",
            "                self.pyload.request_factory.update_bucket()",
            "",
            "        elif section == \"plugin\":",
            "            self.pyload.config.set_plugin(category, option, value)",
            "",
            "    @legacy(\"getConfig\")",
            "    @permission(Perms.SETTINGS)",
            "    def get_config(self):",
            "        \"\"\"",
            "        Retrieves complete config of core.",
            "",
            "        :return: list of `ConfigSection`",
            "        \"\"\"",
            "        return self._convert_config_format(self.pyload.config.config)",
            "",
            "    @legacy(\"getConfigDict\")",
            "    def get_config_dict(self):",
            "        \"\"\"",
            "        Retrieves complete config in dict format, not for RPC.",
            "",
            "        :return: dict",
            "        \"\"\"",
            "        return self.pyload.config.config",
            "",
            "    @legacy(\"getPluginConfig\")",
            "    @permission(Perms.SETTINGS)",
            "    def get_plugin_config(self):",
            "        \"\"\"",
            "        Retrieves complete config for all plugins.",
            "",
            "        :return: list of `ConfigSection`",
            "        \"\"\"",
            "        return self._convert_config_format(self.pyload.config.plugin)",
            "",
            "    @legacy(\"getPluginConfigDict\")",
            "    def get_plugin_config_dict(self):",
            "        \"\"\"",
            "        Plugin config as dict, not for RPC.",
            "",
            "        :return: dict",
            "        \"\"\"",
            "        return self.pyload.config.plugin",
            "",
            "    @legacy(\"pauseServer\")",
            "    @permission(Perms.STATUS)",
            "    def pause_server(self):",
            "        \"\"\"",
            "        Pause server: It won't start any new downloads, but nothing gets aborted.",
            "        \"\"\"",
            "        self.pyload.thread_manager.pause = True",
            "",
            "    @legacy(\"unpauseServer\")",
            "    @permission(Perms.STATUS)",
            "    def unpause_server(self):",
            "        \"\"\"",
            "        Unpause server: New Downloads will be started.",
            "        \"\"\"",
            "        self.pyload.thread_manager.pause = False",
            "",
            "    @legacy(\"togglePause\")",
            "    @permission(Perms.STATUS)",
            "    def toggle_pause(self):",
            "        \"\"\"",
            "        Toggle pause state.",
            "",
            "        :return: new pause state",
            "        \"\"\"",
            "        self.pyload.thread_manager.pause ^= True",
            "        return self.pyload.thread_manager.pause",
            "",
            "    @legacy(\"toggleReconnect\")",
            "    @permission(Perms.STATUS)",
            "    def toggle_reconnect(self):",
            "        \"\"\"",
            "        Toggle reconnect activation.",
            "",
            "        :return: new reconnect state",
            "        \"\"\"",
            "        self.pyload.config.toggle(\"reconnect\", \"enabled\")",
            "        return self.pyload.config.get(\"reconnect\", \"enabled\")",
            "",
            "    @legacy(\"statusServer\")",
            "    @permission(Perms.LIST)",
            "    def status_server(self):",
            "        \"\"\"",
            "        Some general information about the current status of pyLoad.",
            "",
            "        :return: `ServerStatus`",
            "        \"\"\"",
            "        server_status = ServerStatus(",
            "            self.pyload.thread_manager.pause,",
            "            len(self.pyload.thread_manager.processing_ids()),",
            "            self.pyload.files.get_queue_count(),",
            "            self.pyload.files.get_file_count(),",
            "            0,",
            "            not self.pyload.thread_manager.pause and self.is_time_download(),",
            "            self.pyload.config.get(\"reconnect\", \"enabled\") and self.is_time_reconnect(),",
            "            self.is_captcha_waiting(),",
            "        )",
            "",
            "        for pyfile in [",
            "            x.active",
            "            for x in self.pyload.thread_manager.threads",
            "            if x.active and isinstance(x.active, PyFile)",
            "        ]:",
            "            server_status.speed += pyfile.get_speed()  #: bytes/s",
            "",
            "        return server_status",
            "",
            "    @legacy(\"freeSpace\")",
            "    @permission(Perms.STATUS)",
            "    def free_space(self):",
            "        \"\"\"",
            "        Available free space at download directory in bytes.",
            "        \"\"\"",
            "        return fs.free_space(self.pyload.config.get(\"general\", \"storage_folder\"))",
            "",
            "    @legacy(\"getServerVersion\")",
            "    @permission(Perms.ANY)",
            "    def get_server_version(self):",
            "        \"\"\"",
            "        pyLoad Core version.",
            "        \"\"\"",
            "        return self.pyload.version",
            "",
            "    def kill(self):",
            "        \"\"\"",
            "        Clean way to quit pyLoad.",
            "        \"\"\"",
            "        self.pyload._do_exit = True",
            "",
            "    def restart(self):",
            "        \"\"\"",
            "        Restart pyload core.",
            "        \"\"\"",
            "        self.pyload._do_restart = True",
            "",
            "    @legacy(\"getLog\")",
            "    @permission(Perms.LOGS)",
            "    def get_log(self, offset=0):",
            "        \"\"\"",
            "        Returns most recent log entries.",
            "",
            "        :param offset: line offset",
            "        :return: List of log entries",
            "        \"\"\"",
            "        filelog_folder = self.pyload.config.get(\"log\", \"filelog_folder\")",
            "        if not filelog_folder:",
            "            filelog_folder = os.path.join(self.pyload.userdir, \"logs\")",
            "",
            "        path = os.path.join(filelog_folder, \"pyload\" + LogFactory.FILE_EXTENSION)",
            "        try:",
            "            with open(path) as fh:",
            "                lines = fh.readlines()",
            "            if offset >= len(lines):",
            "                return []",
            "            return lines[offset:]",
            "        except Exception:",
            "            return [\"No log available\"]",
            "",
            "    @legacy(\"isTimeDownload\")",
            "    @permission(Perms.STATUS)",
            "    def is_time_download(self):",
            "        \"\"\"",
            "        Checks if pyload will start new downloads according to time in config.",
            "",
            "        :return: bool",
            "        \"\"\"",
            "        start = self.pyload.config.get(\"download\", \"start_time\").split(\":\")",
            "        end = self.pyload.config.get(\"download\", \"end_time\").split(\":\")",
            "        return seconds.compare(start, end)",
            "",
            "    @legacy(\"isTimeReconnect\")",
            "    @permission(Perms.STATUS)",
            "    def is_time_reconnect(self):",
            "        \"\"\"",
            "        Checks if pyload will try to make a reconnect.",
            "",
            "        :return: bool",
            "        \"\"\"",
            "        start = self.pyload.config.get(\"reconnect\", \"start_time\").split(\":\")",
            "        end = self.pyload.config.get(\"reconnect\", \"end_time\").split(\":\")",
            "        return seconds.compare(start, end) and self.pyload.config.get(",
            "            \"reconnect\", \"enabled\"",
            "        )",
            "",
            "    @legacy(\"statusDownloads\")",
            "    @permission(Perms.LIST)",
            "    def status_downloads(self):",
            "        \"\"\"",
            "        Status off all currently running downloads.",
            "",
            "        :return: list of `DownloadStatus`",
            "        \"\"\"",
            "        data = []",
            "        for pyfile in self.pyload.thread_manager.get_active_files():",
            "            if not isinstance(pyfile, PyFile):",
            "                continue",
            "",
            "            data.append(",
            "                DownloadInfo(",
            "                    pyfile.id,",
            "                    pyfile.name,",
            "                    pyfile.get_speed(),",
            "                    pyfile.get_eta(),",
            "                    pyfile.format_eta(),",
            "                    pyfile.get_bytes_left(),",
            "                    pyfile.get_size(),",
            "                    pyfile.format_size(),",
            "                    pyfile.get_percent(),",
            "                    pyfile.status,",
            "                    pyfile.get_status_name(),",
            "                    pyfile.format_wait(),",
            "                    pyfile.wait_until,",
            "                    pyfile.packageid,",
            "                    pyfile.package().name,",
            "                    pyfile.pluginname,",
            "                )",
            "            )",
            "",
            "        return data",
            "",
            "    @legacy(\"addPackage\")",
            "    @permission(Perms.ADD)",
            "    def add_package(self, name, links, dest=Destination.QUEUE):",
            "        \"\"\"",
            "        Adds a package, with links to desired destination.",
            "",
            "        :param name: name of the new package",
            "        :param links: list of urls",
            "        :param dest: `Destination`",
            "        :return: package id of the new package",
            "        \"\"\"",
            "        if self.pyload.config.get(\"general\", \"folder_per_package\"):",
            "            folder = name",
            "        else:",
            "            folder = \"\"",
            "",
            "        folder = (",
            "            folder.replace(\"http://\", \"\")",
            "            .replace(\"https://\", \"\")",
            "            .replace(\"../\", \"_\")",
            "            .replace(\"..\\\\\", \"_\")",
            "            .replace(\":\", \"\")",
            "            .replace(\"/\", \"_\")",
            "            .replace(\"\\\\\", \"_\")",
            "        )",
            "",
            "        package_id = self.pyload.files.add_package(name, folder, Destination(dest))",
            "",
            "        self.pyload.files.add_links(links, package_id)",
            "",
            "        self.pyload.log.info(",
            "            self._(\"Added package {name} containing {count:d} links\").format(",
            "                name=name, count=len(links)",
            "            )",
            "        )",
            "",
            "        self.pyload.files.save()",
            "",
            "        return package_id",
            "",
            "    @legacy(\"parseURLs\")",
            "    @permission(Perms.ADD)",
            "    def parse_urls(self, html=None, url=None):",
            "        \"\"\"",
            "        Parses html content or any arbitrary text for links and returns result of",
            "        `check_urls`",
            "",
            "        :param html: html source",
            "        :param url: url to load html source from",
            "        :return:",
            "        \"\"\"",
            "        urls = []",
            "",
            "        if html:",
            "            urls += urlmatcher.findall(html)",
            "",
            "        if url:",
            "            page = get_url(url)",
            "            urls += urlmatcher.findall(page)",
            "",
            "        # remove duplicates",
            "        return self.check_urls(set(urls))",
            "",
            "    @legacy(\"checkURLs\")",
            "    @permission(Perms.ADD)",
            "    def check_urls(self, urls):",
            "        \"\"\"",
            "        Gets urls and returns pluginname mapped to list of matches urls.",
            "",
            "        :param urls:",
            "        :return: {plugin: urls}",
            "        \"\"\"",
            "        data = self.pyload.plugin_manager.parse_urls(urls)",
            "        plugins = {}",
            "",
            "        for url, plugin in data:",
            "            if plugin in plugins:",
            "                plugins[plugin].append(url)",
            "            else:",
            "                plugins[plugin] = [url]",
            "",
            "        return plugins",
            "",
            "    @legacy(\"checkOnlineStatus\")",
            "    @permission(Perms.ADD)",
            "    def check_online_status(self, urls):",
            "        \"\"\"",
            "        initiates online status check.",
            "",
            "        :param urls:",
            "        :return: initial set of data as `OnlineCheck` instance containing the result id",
            "        \"\"\"",
            "        data = self.pyload.plugin_manager.parse_urls(urls)",
            "",
            "        rid = self.pyload.thread_manager.create_result_thread(data, False)",
            "",
            "        tmp = [",
            "            (url, (url, OnlineStatus(url, pluginname, \"unknown\", 3, 0)))",
            "            for url, pluginname in data",
            "        ]",
            "        data = parse_names(tmp)",
            "        result = {}",
            "",
            "        for k, v in data.items():",
            "            for url, status in v:",
            "                status.packagename = k",
            "                result[url] = status",
            "",
            "        return OnlineCheck(rid, result)",
            "",
            "    @legacy(\"checkOnlineStatusContainer\")",
            "    @permission(Perms.ADD)",
            "    def check_online_status_container(self, urls, container, data):",
            "        \"\"\"",
            "        checks online status of urls and a submitted container file.",
            "",
            "        :param urls: list of urls",
            "        :param container: container file name",
            "        :param data: file content",
            "        :return: online check",
            "        \"\"\"",
            "        with open(",
            "            os.path.join(",
            "                self.pyload.config.get(\"general\", \"storage_folder\"), \"tmp_\" + container",
            "            ),",
            "            \"wb\",",
            "        ) as th:",
            "            th.write(data)",
            "",
            "        return self.check_online_status(urls + [th.name])",
            "",
            "    @legacy(\"pollResults\")",
            "    @permission(Perms.ADD)",
            "    def poll_results(self, rid):",
            "        \"\"\"",
            "        Polls the result available for ResultID.",
            "",
            "        :param rid: `ResultID`",
            "        :return: `OnlineCheck`, if rid is -1 then no more data available",
            "        \"\"\"",
            "        result = self.pyload.thread_manager.get_info_result(rid)",
            "",
            "        if \"ALL_INFO_FETCHED\" in result:",
            "            del result[\"ALL_INFO_FETCHED\"]",
            "            return OnlineCheck(-1, result)",
            "        else:",
            "            return OnlineCheck(rid, result)",
            "",
            "    @legacy(\"generatePackages\")",
            "    @permission(Perms.ADD)",
            "    def generate_packages(self, links):",
            "        \"\"\"",
            "        Parses links, generates packages names from urls.",
            "",
            "        :param links: list of urls",
            "        :return: package names mapped to urls",
            "        \"\"\"",
            "        result = parse_names((x, x) for x in links)",
            "        return result",
            "",
            "    @legacy(\"generateAndAddPackages\")",
            "    @permission(Perms.ADD)",
            "    def generate_and_add_packages(self, links, dest=Destination.COLLECTOR):",
            "        \"\"\"",
            "        Generates and add packages.",
            "",
            "        :param links: list of urls",
            "        :param dest: `Destination`",
            "        :return: list of package ids",
            "        \"\"\"",
            "        return [",
            "            self.add_package(name, urls, dest)",
            "            for name, urls in self.generate_packages(links).items()",
            "        ]",
            "",
            "    @legacy(\"checkAndAddPackages\")",
            "    @permission(Perms.ADD)",
            "    def check_and_add_packages(self, links, dest=Destination.COLLECTOR):",
            "        \"\"\"",
            "        Checks online status, retrieves names, and will add packages.",
            "        Because of these packages are not added immediately, only for internal use.",
            "",
            "        :param links: list of urls",
            "        :param dest: `Destination`",
            "        :return: None",
            "        \"\"\"",
            "        data = self.pyload.plugin_manager.parse_urls(links)",
            "        self.pyload.thread_manager.create_result_thread(data, True)",
            "",
            "    @legacy(\"getPackageData\")",
            "    @permission(Perms.LIST)",
            "    def get_package_data(self, package_id):",
            "        \"\"\"",
            "        Returns complete information about package, and included files.",
            "",
            "        :param package_id: package id",
            "        :return: `PackageData` with .links attribute",
            "        \"\"\"",
            "        data = self.pyload.files.get_package_data(int(package_id))",
            "",
            "        if not data:",
            "            raise PackageDoesNotExists(package_id)",
            "",
            "        pdata = PackageData(",
            "            data[\"id\"],",
            "            data[\"name\"],",
            "            data[\"folder\"],",
            "            data[\"site\"],",
            "            data[\"password\"],",
            "            data[\"queue\"],",
            "            data[\"order\"],",
            "            links=[self._convert_py_file(x) for x in data[\"links\"].values()],",
            "        )",
            "",
            "        return pdata",
            "",
            "    @legacy(\"getPackageInfo\")",
            "    @permission(Perms.LIST)",
            "    def get_package_info(self, package_id):",
            "        \"\"\"",
            "        Returns information about package, without detailed information about containing",
            "        files.",
            "",
            "        :param package_id: package id",
            "        :return: `PackageData` with .fid attribute",
            "        \"\"\"",
            "        data = self.pyload.files.get_package_data(int(package_id))",
            "",
            "        if not data:",
            "            raise PackageDoesNotExists(package_id)",
            "",
            "        pdata = PackageData(",
            "            data[\"id\"],",
            "            data[\"name\"],",
            "            data[\"folder\"],",
            "            data[\"site\"],",
            "            data[\"password\"],",
            "            data[\"queue\"],",
            "            data[\"order\"],",
            "            fids=[int(x) for x in data[\"links\"]],",
            "        )",
            "",
            "        return pdata",
            "",
            "    @legacy(\"getFileData\")",
            "    @permission(Perms.LIST)",
            "    def get_file_data(self, file_id):",
            "        \"\"\"",
            "        Get complete information about a specific file.",
            "",
            "        :param file_id: file id",
            "        :return: `FileData`",
            "        \"\"\"",
            "        info = self.pyload.files.get_file_data(int(file_id))",
            "        if not info:",
            "            raise FileDoesNotExists(file_id)",
            "",
            "        fileinfo = list(info.values())[0]",
            "        fdata = self._convert_py_file(fileinfo)",
            "        return fdata",
            "",
            "    @legacy(\"deleteFiles\")",
            "    @permission(Perms.DELETE)",
            "    def delete_files(self, file_ids):",
            "        \"\"\"",
            "        Deletes several file entries from pyload.",
            "",
            "        :param file_ids: list of file ids",
            "        \"\"\"",
            "        for id in file_ids:",
            "            self.pyload.files.delete_link(int(id))",
            "",
            "        self.pyload.files.save()",
            "",
            "    @legacy(\"deletePackages\")",
            "    @permission(Perms.DELETE)",
            "    def delete_packages(self, package_ids):",
            "        \"\"\"",
            "        Deletes packages and containing links.",
            "",
            "        :param package_ids: list of package ids",
            "        \"\"\"",
            "        for id in package_ids:",
            "            self.pyload.files.delete_package(int(id))",
            "",
            "        self.pyload.files.save()",
            "",
            "    @legacy(\"getQueue\")",
            "    @permission(Perms.LIST)",
            "    def get_queue(self):",
            "        \"\"\"",
            "        Returns info about queue and packages, **not** about files, see `get_queue_data` \\",
            "        or `get_package_data` instead.",
            "",
            "        :return: list of `PackageInfo`",
            "        \"\"\"",
            "        return [",
            "            PackageData(",
            "                pack[\"id\"],",
            "                pack[\"name\"],",
            "                pack[\"folder\"],",
            "                pack[\"site\"],",
            "                pack[\"password\"],",
            "                pack[\"queue\"],",
            "                pack[\"order\"],",
            "                pack[\"linksdone\"],",
            "                pack[\"sizedone\"],",
            "                pack[\"sizetotal\"],",
            "                pack[\"linkstotal\"],",
            "            )",
            "            for pack in self.pyload.files.get_info_data(Destination.QUEUE).values()",
            "        ]",
            "",
            "    @legacy(\"getQueueData\")",
            "    @permission(Perms.LIST)",
            "    def get_queue_data(self):",
            "        \"\"\"",
            "        Return complete data about everything in queue, this is very expensive use it",
            "        sparely.",
            "        See `get_queue` for alternative.",
            "",
            "        :return: list of `PackageData`",
            "        \"\"\"",
            "        return [",
            "            PackageData(",
            "                pack[\"id\"],",
            "                pack[\"name\"],",
            "                pack[\"folder\"],",
            "                pack[\"site\"],",
            "                pack[\"password\"],",
            "                pack[\"queue\"],",
            "                pack[\"order\"],",
            "                pack[\"linksdone\"],",
            "                pack[\"sizedone\"],",
            "                pack[\"sizetotal\"],",
            "                links=[self._convert_py_file(x) for x in pack[\"links\"].values()],",
            "            )",
            "            for pack in self.pyload.files.get_complete_data(Destination.QUEUE).values()",
            "        ]",
            "",
            "    @legacy(\"getCollector\")",
            "    @permission(Perms.LIST)",
            "    def get_collector(self):",
            "        \"\"\"",
            "        same as `get_queue` for collector.",
            "",
            "        :return: list of `PackageInfo`",
            "        \"\"\"",
            "        return [",
            "            PackageData(",
            "                pack[\"id\"],",
            "                pack[\"name\"],",
            "                pack[\"folder\"],",
            "                pack[\"site\"],",
            "                pack[\"password\"],",
            "                pack[\"queue\"],",
            "                pack[\"order\"],",
            "                pack[\"linksdone\"],",
            "                pack[\"sizedone\"],",
            "                pack[\"sizetotal\"],",
            "                pack[\"linkstotal\"],",
            "            )",
            "            for pack in self.pyload.files.get_info_data(Destination.COLLECTOR).values()",
            "        ]",
            "",
            "    @legacy(\"getCollectorData\")",
            "    @permission(Perms.LIST)",
            "    def get_collector_data(self):",
            "        \"\"\"",
            "        same as `get_queue_data` for collector.",
            "",
            "        :return: list of `PackageInfo`",
            "        \"\"\"",
            "        return [",
            "            PackageData(",
            "                pack[\"id\"],",
            "                pack[\"name\"],",
            "                pack[\"folder\"],",
            "                pack[\"site\"],",
            "                pack[\"password\"],",
            "                pack[\"queue\"],",
            "                pack[\"order\"],",
            "                pack[\"linksdone\"],",
            "                pack[\"sizedone\"],",
            "                pack[\"sizetotal\"],",
            "                links=[self._convert_py_file(x) for x in pack[\"links\"].values()],",
            "            )",
            "            for pack in self.pyload.files.get_complete_data(",
            "                Destination.COLLECTOR",
            "            ).values()",
            "        ]",
            "",
            "    @legacy(\"addFiles\")",
            "    @permission(Perms.ADD)",
            "    def add_files(self, package_id, links):",
            "        \"\"\"",
            "        Adds files to specific package.",
            "",
            "        :param package_id: package id",
            "        :param links: list of urls",
            "        \"\"\"",
            "        self.pyload.files.add_links(links, int(package_id))",
            "",
            "        self.pyload.log.info(",
            "            self._(\"Added {count:d} links to package #{package:d} \").format(",
            "                count=len(links), package=package_id",
            "            )",
            "        )",
            "        self.pyload.files.save()",
            "",
            "    @legacy(\"pushToQueue\")",
            "    @permission(Perms.MODIFY)",
            "    def push_to_queue(self, package_id):",
            "        \"\"\"",
            "        Moves package from Collector to Queue.",
            "",
            "        :param package_id: package id",
            "        \"\"\"",
            "        self.pyload.files.set_package_location(package_id, Destination.QUEUE)",
            "",
            "    @legacy(\"pullFromQueue\")",
            "    @permission(Perms.MODIFY)",
            "    def pull_from_queue(self, package_id):",
            "        \"\"\"",
            "        Moves package from Queue to Collector.",
            "",
            "        :param package_id: package id",
            "        \"\"\"",
            "        self.pyload.files.set_package_location(package_id, Destination.COLLECTOR)",
            "",
            "    @legacy(\"restartPackage\")",
            "    @permission(Perms.MODIFY)",
            "    def restart_package(self, package_id):",
            "        \"\"\"",
            "        Restarts a package, resets every containing files.",
            "",
            "        :param package_id: package id",
            "        \"\"\"",
            "        self.pyload.files.restart_package(int(package_id))",
            "",
            "    @legacy(\"restartFile\")",
            "    @permission(Perms.MODIFY)",
            "    def restart_file(self, file_id):",
            "        \"\"\"",
            "        Resets file status, so it will be downloaded again.",
            "",
            "        :param file_id:  file id",
            "        \"\"\"",
            "        self.pyload.files.restart_file(int(file_id))",
            "",
            "    @legacy(\"recheckPackage\")",
            "    @permission(Perms.MODIFY)",
            "    def recheck_package(self, package_id):",
            "        \"\"\"",
            "        Probes online status of all files in a package, also a default action when",
            "        package is added.",
            "",
            "        :param package_id:",
            "        :return:",
            "        \"\"\"",
            "        self.pyload.files.recheck_package(int(package_id))",
            "",
            "    @legacy(\"stopAllDownloads\")",
            "    @permission(Perms.MODIFY)",
            "    def stop_all_downloads(self):",
            "        \"\"\"",
            "        Aborts all running downloads.",
            "        \"\"\"",
            "        pyfiles = list(self.pyload.files.cache.values())",
            "        for pyfile in pyfiles:",
            "            pyfile.abort_download()",
            "",
            "    @legacy(\"stopDownloads\")",
            "    @permission(Perms.MODIFY)",
            "    def stop_downloads(self, file_ids):",
            "        \"\"\"",
            "        Aborts specific downloads.",
            "",
            "        :param file_ids: list of file ids",
            "        :return:",
            "        \"\"\"",
            "        pyfiles = list(self.pyload.files.cache.values())",
            "        for pyfile in pyfiles:",
            "            if pyfile.id in file_ids:",
            "                pyfile.abort_download()",
            "",
            "    @legacy(\"setPackageName\")",
            "    @permission(Perms.MODIFY)",
            "    def set_package_name(self, package_id, name):",
            "        \"\"\"",
            "        Renames a package.",
            "",
            "        :param package_id: package id",
            "        :param name: new package name",
            "        \"\"\"",
            "        pack = self.pyload.files.get_package(package_id)",
            "        pack.name = name",
            "        pack.sync()",
            "",
            "    @legacy(\"movePackage\")",
            "    @permission(Perms.MODIFY)",
            "    def move_package(self, destination, package_id):",
            "        \"\"\"",
            "        Set a new package location.",
            "",
            "        :param destination: `Destination`",
            "        :param package_id: package id",
            "        \"\"\"",
            "        try:",
            "            dest = Destination(destination)",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            self.pyload.files.set_package_location(package_id, dest)",
            "",
            "    @legacy(\"moveFiles\")",
            "    @permission(Perms.MODIFY)",
            "    def move_files(self, file_ids, package_id):",
            "        \"\"\"",
            "        Move multiple files to another package.",
            "",
            "        :param file_ids: list of file ids",
            "        :param package_id: destination package",
            "        :return:",
            "        \"\"\"",
            "        # TODO: implement",
            "        pass",
            "",
            "    @legacy(\"uploadContainer\")",
            "    @permission(Perms.ADD)",
            "    def upload_container(self, filename, data):",
            "        \"\"\"",
            "        Uploads and adds a container file to pyLoad.",
            "",
            "        :param filename: file name - extension is important, so it can correctly decrypt",
            "        :param data: file content",
            "        \"\"\"",
            "        with open(",
            "            os.path.join(",
            "                self.pyload.config.get(\"general\", \"storage_folder\"), \"tmp_\" + filename",
            "            ),",
            "            \"wb\",",
            "        ) as th:",
            "            th.write(data)",
            "",
            "        self.add_package(th.name, [th.name], Destination.COLLECTOR)",
            "",
            "    @legacy(\"orderPackage\")",
            "    @permission(Perms.MODIFY)",
            "    def order_package(self, package_id, position):",
            "        \"\"\"",
            "        Gives a package a new position.",
            "",
            "        :param package_id: package id",
            "        :param position:",
            "        \"\"\"",
            "        self.pyload.files.reorder_package(package_id, position)",
            "",
            "    @legacy(\"orderFile\")",
            "    @permission(Perms.MODIFY)",
            "    def order_file(self, file_id, position):",
            "        \"\"\"",
            "        Gives a new position to a file within its package.",
            "",
            "        :param file_id: file id",
            "        :param position:",
            "        \"\"\"",
            "        self.pyload.files.reorder_file(file_id, position)",
            "",
            "    @legacy(\"setPackageData\")",
            "    @permission(Perms.MODIFY)",
            "    def set_package_data(self, package_id, data):",
            "        \"\"\"",
            "        Allows to modify several package attributes.",
            "",
            "        :param package_id: package id",
            "        :param data: dict that maps attribute to desired value",
            "        \"\"\"",
            "        p = self.pyload.files.get_package(package_id)",
            "        if not p:",
            "            raise PackageDoesNotExists(package_id)",
            "",
            "        for key, value in data.items():",
            "            if key == \"id\":",
            "                continue",
            "            setattr(p, key, value)",
            "",
            "        p.sync()",
            "        self.pyload.files.save()",
            "",
            "    @legacy(\"deleteFinished\")",
            "    @permission(Perms.DELETE)",
            "    def delete_finished(self):",
            "        \"\"\"",
            "        Deletes all finished files and completely finished packages.",
            "",
            "        :return: list of deleted package ids",
            "        \"\"\"",
            "        return self.pyload.files.delete_finished_links()",
            "",
            "    @legacy(\"restartFailed\")",
            "    @permission(Perms.MODIFY)",
            "    def restart_failed(self):",
            "        \"\"\"",
            "        Restarts all failed failes.",
            "        \"\"\"",
            "        self.pyload.files.restart_failed()",
            "",
            "    @legacy(\"getPackageOrder\")",
            "    @permission(Perms.LIST)",
            "    def get_package_order(self, destination):",
            "        \"\"\"",
            "        Returns information about package order.",
            "",
            "        :param destination: `Destination`",
            "        :return: dict mapping order to package id",
            "        \"\"\"",
            "        packages = self.pyload.files.get_info_data(Destination(destination))",
            "        order = {}",
            "",
            "        for package_id in packages:",
            "            pack = self.pyload.files.get_package_data(int(package_id))",
            "            while pack[\"order\"] in order.keys():  #: just in case",
            "                pack[\"order\"] += 1",
            "            order[pack[\"order\"]] = pack[\"id\"]",
            "        return order",
            "",
            "    @legacy(\"getFileOrder\")",
            "    @permission(Perms.LIST)",
            "    def get_file_order(self, package_id):",
            "        \"\"\"",
            "        Information about file order within package.",
            "",
            "        :param package_id:",
            "        :return: dict mapping order to file id",
            "        \"\"\"",
            "        raw_data = self.pyload.files.get_package_data(int(package_id))",
            "        order = {}",
            "        for id, pyfile in raw_data[\"links\"].items():",
            "            while pyfile[\"order\"] in order.keys():  #: just in case",
            "                pyfile[\"order\"] += 1",
            "            order[pyfile[\"order\"]] = pyfile[\"id\"]",
            "        return order",
            "",
            "    @legacy(\"isCaptchaWaiting\")",
            "    @permission(Perms.STATUS)",
            "    def is_captcha_waiting(self):",
            "        \"\"\"",
            "        Indicates wether a captcha task is available.",
            "",
            "        :return: bool",
            "        \"\"\"",
            "        self.pyload.last_client_connected = time.time()",
            "        task = self.pyload.captcha_manager.get_task()",
            "        return task is not None",
            "",
            "    @legacy(\"getCaptchaTask\")",
            "    @permission(Perms.STATUS)",
            "    def get_captcha_task(self, exclusive=False):",
            "        \"\"\"",
            "        Returns a captcha task.",
            "",
            "        :param exclusive: unused",
            "        :return: `CaptchaTask`",
            "        \"\"\"",
            "        self.pyload.last_client_connected = time.time()",
            "        task = self.pyload.captcha_manager.get_task()",
            "        if task:",
            "            task.set_waiting_for_user(exclusive=exclusive)",
            "            data, type, result = task.get_captcha()",
            "            t = CaptchaTask(int(task.id), json.dumps(data), type, result)",
            "            return t",
            "        else:",
            "            return CaptchaTask(-1)",
            "",
            "    @legacy(\"getCaptchaTaskStatus\")",
            "    @permission(Perms.STATUS)",
            "    def get_captcha_task_status(self, tid):",
            "        \"\"\"",
            "        Get information about captcha task.",
            "",
            "        :param tid: task id",
            "        :return: string",
            "        \"\"\"",
            "        self.pyload.last_client_connected = time.time()",
            "        t = self.pyload.captcha_manager.get_task_by_id(tid)",
            "        return t.get_status() if t else \"\"",
            "",
            "    @legacy(\"setCaptchaResult\")",
            "    @permission(Perms.STATUS)",
            "    def set_captcha_result(self, tid, result):",
            "        \"\"\"",
            "        Set result for a captcha task.",
            "",
            "        :param tid: task id",
            "        :param result: captcha result",
            "        \"\"\"",
            "        self.pyload.last_client_connected = time.time()",
            "        task = self.pyload.captcha_manager.get_task_by_id(tid)",
            "        if task:",
            "            task.set_result(result)",
            "            self.pyload.captcha_manager.remove_task(task)",
            "",
            "    @legacy(\"getEvents\")",
            "    @permission(Perms.STATUS)",
            "    def get_events(self, uuid):",
            "        \"\"\"",
            "        Lists occurred events, may be affected to changes in the future.",
            "",
            "        :param uuid:",
            "        :return: list of `Events`",
            "        \"\"\"",
            "        events = self.pyload.event_manager.get_events(uuid)",
            "        new_events = []",
            "",
            "        def conv_dest(d):",
            "            return (Destination.QUEUE if d == \"queue\" else Destination.COLLECTOR).value",
            "",
            "        for e in events:",
            "            event = EventInfo()",
            "            event.eventname = e[0]",
            "            if e[0] in (\"update\", \"remove\", \"insert\"):",
            "                event.id = e[3]",
            "                event.type = (",
            "                    ElementType.PACKAGE if e[2] == \"pack\" else ElementType.FILE",
            "                ).value",
            "                event.destination = conv_dest(e[1])",
            "            elif e[0] == \"order\":",
            "                if e[1]:",
            "                    event.id = e[1]",
            "                    event.type = (",
            "                        ElementType.PACKAGE if e[2] == \"pack\" else ElementType.FILE",
            "                    )",
            "                    event.destination = conv_dest(e[3])",
            "            elif e[0] == \"reload\":",
            "                event.destination = conv_dest(e[1])",
            "            new_events.append(event)",
            "        return new_events",
            "",
            "    @legacy(\"getAccounts\")",
            "    @permission(Perms.ACCOUNTS)",
            "    def get_accounts(self, refresh):",
            "        \"\"\"",
            "        Get information about all entered accounts.",
            "",
            "        :param refresh: reload account info",
            "        :return: list of `AccountInfo`",
            "        \"\"\"",
            "        accs = self.pyload.account_manager.get_account_infos(False, refresh)",
            "        accounts = []",
            "        for group in accs.values():",
            "            accounts.extend(",
            "                [",
            "                    AccountInfo(",
            "                        acc[\"validuntil\"],",
            "                        acc[\"login\"],",
            "                        acc[\"options\"],",
            "                        acc[\"valid\"],",
            "                        acc[\"trafficleft\"],",
            "                        acc[\"premium\"],",
            "                        acc[\"type\"],",
            "                    )",
            "                    for acc in group",
            "                ]",
            "            )",
            "        return accounts",
            "",
            "    @legacy(\"getAccountTypes\")",
            "    @permission(Perms.ANY)",
            "    def get_account_types(self):",
            "        \"\"\"",
            "        All available account types.",
            "",
            "        :return: list",
            "        \"\"\"",
            "        return list(self.pyload.account_manager.accounts.keys())",
            "",
            "    @legacy(\"updateAccount\")",
            "    @permission(Perms.ACCOUNTS)",
            "    def update_account(self, plugin, account, password=None, options={}):",
            "        \"\"\"",
            "        Changes pw/options for specific account.",
            "        \"\"\"",
            "        self.pyload.account_manager.update_account(plugin, account, password, options)",
            "",
            "    @legacy(\"removeAccount\")",
            "    @permission(Perms.ACCOUNTS)",
            "    def remove_account(self, plugin, account):",
            "        \"\"\"",
            "        Remove account from pyload.",
            "",
            "        :param plugin: pluginname",
            "        :param account: accountname",
            "        \"\"\"",
            "        self.pyload.account_manager.remove_account(plugin, account)",
            "",
            "    @permission(Perms.ANY)",
            "    def login(self, username, password):",
            "        \"\"\"",
            "        Login into pyLoad, this **must** be called when using rpc before any methods can",
            "        be used.",
            "",
            "        :param username:",
            "        :param password:",
            "        :return: bool indicating login was successful",
            "        \"\"\"",
            "        return True if self.check_auth(username, password) else False",
            "",
            "    @legacy(\"checkAuth\")",
            "    def check_auth(self, username, password):",
            "        \"\"\"",
            "        Check authentication and returns details.",
            "",
            "        :param username:",
            "        :param password:",
            "        :return: dict with info, empty when login is incorrect",
            "        \"\"\"",
            "        return self.pyload.db.check_auth(username, password)",
            "",
            "    def user_exists(self, username):",
            "        \"\"\"",
            "        Check if a user actually exists in the database.",
            "",
            "        :param username:",
            "        :return: boolean",
            "        \"\"\"",
            "        return self.pyload.db.user_exists(username)",
            "",
            "    @legacy(\"isAuthorized\")",
            "    def is_authorized(self, func, userdata):",
            "        \"\"\"",
            "        checks if the user is authorized for specific method.",
            "",
            "        :param func: function name",
            "        :param userdata: dictionary of user data",
            "        :return: boolean",
            "        \"\"\"",
            "        if userdata[\"role\"] == Role.ADMIN:",
            "            return True",
            "        elif func in perm_map and has_permission(",
            "            userdata[\"permission\"], perm_map[func]",
            "        ):",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    @permission(Perms.SETTINGS)",
            "    def get_userdir(self):",
            "        return os.path.realpath(self.pyload.userdir)",
            "",
            "    @permission(Perms.SETTINGS)",
            "    def get_cachedir(self):",
            "        return os.path.realpath(self.pyload.tempdir)",
            "",
            "    #: Old API",
            "    @permission(Perms.ANY)",
            "    def getUserData(self, username, password):",
            "        \"\"\"",
            "        similar to `check_auth` but returns UserData thrift type.",
            "        \"\"\"",
            "        user = self.check_auth(username, password)",
            "        if user:",
            "            return OldUserData(",
            "                user[\"name\"],",
            "                user[\"email\"],",
            "                user[\"role\"],",
            "                user[\"permission\"],",
            "                user[\"template\"],",
            "            )",
            "        else:",
            "            return OldUserData()",
            "",
            "    @permission(Perms.ANY)",
            "    def get_userdata(self, username, password):",
            "        \"\"\"",
            "        similar to `check_auth` but returns UserData thrift type.",
            "        \"\"\"",
            "        user = self.check_auth(username, password)",
            "        if user:",
            "            return UserData(",
            "                user[\"id\"],",
            "                user[\"name\"],",
            "                user[\"email\"],",
            "                user[\"role\"],",
            "                user[\"permission\"],",
            "                user[\"template\"],",
            "            )",
            "        else:",
            "            return UserData()",
            "",
            "    #: Old API",
            "    def getAllUserData(self):",
            "        \"\"\"",
            "        returns all known user and info.",
            "        \"\"\"",
            "        res = {}",
            "        for id, data in self.pyload.db.get_all_user_data().items():",
            "            res[data[\"name\"]] = OldUserData(",
            "                data[\"name\"],",
            "                data[\"email\"],",
            "                data[\"role\"],",
            "                data[\"permission\"],",
            "                data[\"template\"],",
            "            )",
            "",
            "        return res",
            "",
            "    def get_all_userdata(self):",
            "        \"\"\"",
            "        returns all known user and info.",
            "        \"\"\"",
            "        res = {}",
            "        for id, data in self.pyload.db.get_all_user_data().items():",
            "            res[id] = UserData(",
            "                id,",
            "                data[\"name\"],",
            "                data[\"email\"],",
            "                data[\"role\"],",
            "                data[\"permission\"],",
            "                data[\"template\"],",
            "            )",
            "        return res",
            "",
            "    @legacy(\"getServices\")",
            "    @permission(Perms.STATUS)",
            "    def get_services(self):",
            "        \"\"\"",
            "        A dict of available services, these can be defined by addon plugins.",
            "",
            "        :return: dict with this style: {\"plugin\": {\"method\": \"description\"}}",
            "        \"\"\"",
            "        data = {}",
            "        for plugin, funcs in self.pyload.addon_manager.methods.items():",
            "            data[plugin] = funcs",
            "",
            "        return data",
            "",
            "    @legacy(\"hasService\")",
            "    @permission(Perms.STATUS)",
            "    def has_service(self, plugin, func):",
            "        \"\"\"",
            "        Checks whether a service is available.",
            "",
            "        :param plugin:",
            "        :param func:",
            "        :return: bool",
            "        \"\"\"",
            "        cont = self.pyload.addon_manager.methods",
            "        return plugin in cont and func in cont[plugin]",
            "",
            "    @permission(Perms.STATUS)",
            "    def call(self, info):",
            "        \"\"\"",
            "        Calls a service (a method in addon plugin).",
            "",
            "        :param info: `ServiceCall`",
            "        :return: result",
            "        :raises: ServiceDoesNotExists, when it's not available",
            "        :raises: ServiceException, when an exception was raised",
            "        \"\"\"",
            "        plugin = info.plugin",
            "        func = info.func",
            "        args = info.arguments",
            "        parse = info.parse_arguments",
            "",
            "        if not self.has_service(plugin, func):",
            "            raise ServiceDoesNotExists(plugin, func)",
            "",
            "        try:",
            "            ret = self.pyload.addon_manager.call_rpc(plugin, func, args, parse)",
            "            return str(ret)",
            "        except Exception as exc:",
            "            raise ServiceException(exc)",
            "",
            "    @legacy(\"getAllInfo\")",
            "    @permission(Perms.STATUS)",
            "    def get_all_info(self):",
            "        \"\"\"",
            "        Returns all information stored by addon plugins. Values are always strings.",
            "",
            "        :return: {\"plugin\": {\"name\": value } }",
            "        \"\"\"",
            "        return self.pyload.addon_manager.get_all_info()",
            "",
            "    @legacy(\"getInfoByPlugin\")",
            "    @permission(Perms.STATUS)",
            "    def get_info_by_plugin(self, plugin):",
            "        \"\"\"",
            "        Returns information stored by a specific plugin.",
            "",
            "        :param plugin: pluginname",
            "        :return: dict of attr names mapped to value {\"name\": value}",
            "        \"\"\"",
            "        return self.pyload.addon_manager.get_info(plugin)",
            "",
            "    def add_user(self, user, newpw, role=0, perms=0):",
            "        \"\"\"",
            "        creates new user login.",
            "        \"\"\"",
            "        return self.pyload.db.add_user(user, newpw, role, perms)",
            "",
            "    def remove_user(self, user):",
            "        \"\"\"",
            "        deletes a user login.",
            "        \"\"\"",
            "        return self.pyload.db.remove_user(user)",
            "",
            "    @legacy(\"changePassword\")",
            "    def change_password(self, user, oldpw, newpw):",
            "        \"\"\"",
            "        changes password for specific user.",
            "        \"\"\"",
            "        return self.pyload.db.change_password(user, oldpw, newpw)",
            "",
            "    @legacy(\"setUserPermission\")",
            "    def set_user_permission(self, user, permission, role):",
            "        self.pyload.db.set_permission(user, permission)",
            "        self.pyload.db.set_role(user, role)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "188": [
                "Api",
                "set_config_value"
            ],
            "190": [
                "Api",
                "set_config_value"
            ],
            "193": [
                "Api",
                "set_config_value"
            ]
        },
        "addLocation": []
    },
    "src/pyload/webui/app/blueprints/json_blueprint.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "     for key, value in flask.request.form.items():"
            },
            "1": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         try:"
            },
            "2": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "             section, option = key.split(\"|\")"
            },
            "3": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except Exception:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+        except ValueError:"
            },
            "5": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "             continue"
            },
            "6": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 273,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if section == 'general' and option=='storage_folder':"
            },
            "8": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            abs_path_value = os.path.join(os.path.abspath(value).lower(), \"\")"
            },
            "9": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            abs_PKGDIR = os.path.join(os.path.abspath(PKGDIR).lower(), \"\")"
            },
            "10": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if abs_path_value.startswith(abs_PKGDIR):"
            },
            "11": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                continue"
            },
            "12": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "         api.set_config_value(section, option, value, category)"
            },
            "14": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 275,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "     return jsonify(True)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "import os",
            "",
            "import flask",
            "from flask.json import jsonify",
            "from pyload import PKGDIR",
            "from pyload.core.api import Role",
            "from pyload.core.utils import format",
            "",
            "from ..helpers import get_permission, login_required, permlist, render_template, set_permission",
            "",
            "bp = flask.Blueprint(\"json\", __name__)",
            "",
            "",
            "@bp.route(\"/json/status\", methods=[\"GET\", \"POST\"], endpoint=\"status\")",
            "# @apiver_check",
            "@login_required(\"LIST\")",
            "def status():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    data = api.status_server()",
            "    return jsonify(data)",
            "",
            "",
            "@bp.route(\"/json/links\", methods=[\"GET\", \"POST\"], endpoint=\"links\")",
            "# @apiver_check",
            "@login_required(\"LIST\")",
            "def links():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        links = api.status_downloads()",
            "        ids = []",
            "        for link in links:",
            "            ids.append(link[\"fid\"])",
            "",
            "            if link[\"status\"] == 12:  #: downloading",
            "                formatted_eta = link[\"format_eta\"]",
            "                formatted_speed = format.speed(link[\"speed\"])",
            "                link[\"info\"] = f\"{formatted_eta} @ {formatted_speed}\"",
            "",
            "            elif link[\"status\"] == 5:  #: waiting",
            "                link[\"percent\"] = 0",
            "                link[\"size\"] = 0",
            "                link[\"bleft\"] = 0",
            "                link[\"info\"] = api._(\"waiting {}\").format(link[\"format_wait\"])",
            "            else:",
            "                link[\"info\"] = \"\"",
            "",
            "        return jsonify(links=links, ids=ids)",
            "",
            "    except Exception as exc:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/packages\", endpoint=\"packages\")",
            "# @apiver_check",
            "@login_required(\"LIST\")",
            "def packages():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        data = api.get_queue()",
            "",
            "        for package in data:",
            "            package[\"links\"] = []",
            "            for file in api.get_package_files(package[\"id\"]):",
            "                package[\"links\"].append(api.get_file_info(file))",
            "",
            "        return jsonify(data)",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/package\", endpoint=\"package\")",
            "# @apiver_check",
            "@login_required(\"LIST\")",
            "def package():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        id = int(flask.request.args.get('id'))",
            "        data = api.get_package_data(id)",
            "",
            "        tmp = data[\"links\"]",
            "        tmp.sort(key=lambda entry: entry[\"order\"])",
            "        data[\"links\"] = tmp",
            "        return jsonify(data)",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/package_order\", endpoint=\"package_order\")",
            "# @apiver_check",
            "@login_required(\"ADD\")",
            "def package_order():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        pid = int(flask.request.args.get('pid'))",
            "        pos = int(flask.request.args.get('pos'))",
            "        api.order_package(pid, pos)",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/abort_link\", endpoint=\"abort_link\")",
            "# @apiver_check",
            "@login_required(\"DELETE\")",
            "def abort_link():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        id = int(flask.request.args.get('id'))",
            "        api.stop_downloads([id])",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/link_order\", endpoint=\"link_order\")",
            "# @apiver_check",
            "@login_required(\"ADD\")",
            "def link_order():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        fid = int(flask.request.args.get('fid'))",
            "        pos = int(flask.request.args.get('pos'))",
            "        api.order_file(fid, pos)",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/add_package\", methods=[\"POST\"], endpoint=\"add_package\")",
            "# @apiver_check",
            "@login_required(\"ADD\")",
            "def add_package():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    package_name = flask.request.form.get(\"add_name\", \"New Package\").strip()",
            "    queue = int(flask.request.form[\"add_dest\"])",
            "    links = [l.strip() for l in flask.request.form[\"add_links\"].splitlines()]",
            "    pw = flask.request.form.get(\"add_password\", \"\").strip(\"\\n\\r\")",
            "",
            "    try:",
            "        file = flask.request.files[\"add_file\"]",
            "",
            "        if file.filename:",
            "            if not package_name or package_name == \"New Package\":",
            "                package_name = file.filename",
            "",
            "            file_path = os.path.join(",
            "                api.get_config_value(\"general\", \"storage_folder\"), \"tmp_\" + file.filename",
            "            )",
            "            file.save(file_path)",
            "            links.insert(0, file_path)",
            "",
            "    except Exception:",
            "        pass",
            "",
            "    urls = [url for url in links if url.strip()]",
            "    pack = api.add_package(package_name, urls, queue)",
            "    if pw:",
            "        data = {\"password\": pw}",
            "        api.set_package_data(pack, data)",
            "",
            "    return jsonify(True)",
            "",
            "",
            "@bp.route(\"/json/move_package\", endpoint=\"move_package\")",
            "# @apiver_check",
            "@login_required(\"MODIFY\")",
            "def move_package():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        id = int(flask.request.args.get('id'))",
            "        dest = int(flask.request.args.get('dest'))",
            "        api.move_package(dest, id)",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/edit_package\", methods=[\"POST\"], endpoint=\"edit_package\")",
            "# @apiver_check",
            "@login_required(\"MODIFY\")",
            "def edit_package():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        pack_id = int(flask.request.form[\"pack_id\"])",
            "        pack_folder = flask.request.form[\"pack_folder\"].lstrip(f\"{os.path.sep}\").replace(f\"..{os.path.sep}\", f\"\")",
            "        data = {",
            "            \"name\": flask.request.form[\"pack_name\"],",
            "            \"_folder\": pack_folder,",
            "            \"password\": flask.request.form[\"pack_pws\"],",
            "        }",
            "",
            "        api.set_package_data(pack_id, data)",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/set_captcha\", methods=[\"GET\", \"POST\"], endpoint=\"set_captcha\")",
            "# @apiver_check",
            "@login_required(\"ADD\")",
            "def set_captcha():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    if flask.request.method == \"POST\":",
            "        tid = int(flask.request.form[\"cap_id\"])",
            "        result = flask.request.form[\"cap_result\"]",
            "        api.set_captcha_result(tid, result)",
            "",
            "    task = api.get_captcha_task()",
            "    if task.tid >= 0:",
            "        data = {",
            "            \"captcha\": True,",
            "            \"id\": task.tid,",
            "            \"params\": task.data,",
            "            \"result_type\": task.result_type,",
            "        }",
            "    else:",
            "        data = {\"captcha\": False}",
            "",
            "    return jsonify(data)",
            "",
            "",
            "@bp.route(\"/json/load_config\", endpoint=\"load_config\")",
            "# @apiver_check",
            "@login_required(\"SETTINGS\")",
            "def load_config():",
            "    category = flask.request.args.get('category')",
            "    section = flask.request.args.get('section')",
            "    if category not in (\"core\", \"plugin\") or not section:",
            "        return jsonify(False), 500",
            "",
            "    conf = None",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    if category == \"core\":",
            "        conf = api.get_config_dict()",
            "    elif category == \"plugin\":",
            "        conf = api.get_plugin_config_dict()",
            "",
            "    for key, option in conf[section].items():",
            "        if key in (\"desc\", \"outline\"):",
            "            continue",
            "",
            "        if \";\" in option[\"type\"]:",
            "            option[\"list\"] = option[\"type\"].split(\";\")",
            "",
            "    return render_template(\"settings_item.html\", skey=section, section=conf[section])",
            "",
            "",
            "@bp.route(\"/json/save_config\", methods=[\"POST\"], endpoint=\"save_config\")",
            "# @apiver_check",
            "@login_required(\"SETTINGS\")",
            "def save_config():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    category = flask.request.args.get('category')",
            "    if category not in (\"core\", \"plugin\"):",
            "        return jsonify(False), 500",
            "",
            "    for key, value in flask.request.form.items():",
            "        try:",
            "            section, option = key.split(\"|\")",
            "        except Exception:",
            "            continue",
            "",
            "        if section == 'general' and option=='storage_folder':",
            "            abs_path_value = os.path.join(os.path.abspath(value).lower(), \"\")",
            "            abs_PKGDIR = os.path.join(os.path.abspath(PKGDIR).lower(), \"\")",
            "            if abs_path_value.startswith(abs_PKGDIR):",
            "                continue",
            "",
            "        api.set_config_value(section, option, value, category)",
            "",
            "    return jsonify(True)",
            "",
            "",
            "@bp.route(\"/json/add_account\", methods=[\"POST\"], endpoint=\"add_account\")",
            "# @apiver_check",
            "@login_required(\"ACCOUNTS\")",
            "# @fresh_login_required",
            "def add_account():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    login = flask.request.form[\"account_login\"]",
            "    password = flask.request.form[\"account_password\"]",
            "    account_type = flask.request.form[\"account_type\"]",
            "",
            "    if login:",
            "        api.update_account(account_type, login, password)",
            "        return jsonify(True)",
            "",
            "    else:",
            "        return jsonify(False)",
            "",
            "",
            "@bp.route(\"/json/update_accounts\", methods=[\"POST\"], endpoint=\"update_accounts\")",
            "# @apiver_check",
            "@login_required(\"ACCOUNTS\")",
            "# @fresh_login_required",
            "def update_accounts():",
            "    deleted = []  #: don't update deleted accounts, or they will be created again",
            "    updated = {}",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    for name, value in flask.request.form.items():",
            "        value = value.strip()",
            "        if not value:",
            "            continue",
            "",
            "        tmp, user = name.split(\";\")",
            "        plugin, action = tmp.split(\"|\")",
            "",
            "        if action == \"delete\":",
            "            deleted.append((plugin,user, ))",
            "            api.remove_account(plugin, user)",
            "",
            "        elif action == \"password\":",
            "            password, options = updated.get((plugin, user,), (None, {}))",
            "            password = value",
            "            updated[(plugin, user,)] = (password, options)",
            "        elif action == \"time\" and \"-\" in value:",
            "            password, options = updated.get((plugin, user,), (None, {}))",
            "            options[\"time\"] = [value]",
            "            updated[(plugin, user,)] = (password, options)",
            "        elif action == \"limitdl\" and value.isdigit():",
            "            password, options = updated.get((plugin, user,), (None, {}))",
            "            options[\"limit_dl\"] = [value]",
            "            updated[(plugin, user,)] = (password, options)",
            "",
            "    for tmp, options in updated.items():",
            "        plugin, user = tmp",
            "        if (plugin, user,) in deleted:",
            "            continue",
            "        password, options = options",
            "        api.update_account(plugin, user, password, options=options)",
            "",
            "    return jsonify(True)",
            "",
            "",
            "@bp.route(\"/json/change_password\", methods=[\"POST\"], endpoint=\"change_password\")",
            "# @apiver_check",
            "# @fresh_login_required",
            "@login_required(\"ACCOUNTS\")",
            "def change_password():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    user = flask.request.form[\"user_login\"]",
            "    oldpw = flask.request.form[\"login_current_password\"]",
            "    newpw = flask.request.form[\"login_new_password\"]",
            "",
            "    done = api.change_password(user, oldpw, newpw)",
            "    if not done:",
            "        return jsonify(False), 500  #: Wrong password",
            "",
            "    return jsonify(True)",
            "",
            "@bp.route(\"/json/add_user\", methods=[\"POST\"], endpoint=\"add_user\")",
            "# @apiver_check",
            "@login_required(\"ADMIN\")",
            "# @fresh_login_required",
            "def add_user():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    user = flask.request.form[\"new_user\"]",
            "    password = flask.request.form[\"new_password\"]",
            "    role = Role.ADMIN if flask.request.form.get(\"new_role\") == \"on\" else Role.USER",
            "    perms = {}",
            "    for perm in permlist():",
            "        perms[perm] = False",
            "    for perm in flask.request.form.getlist(\"new_perms\"):",
            "        perms[perm] = True",
            "",
            "    perms = set_permission(perms)",
            "",
            "    done = api.add_user(user, password, role, perms)",
            "    if not done:",
            "        return jsonify(False), 500  #: Duplicate user",
            "",
            "    return jsonify(True)",
            "",
            "@bp.route(\"/json/update_users\", methods=[\"POST\"], endpoint=\"update_users\")",
            "# @apiver_check",
            "# @fresh_login_required",
            "@login_required(\"ADMIN\")",
            "def update_users():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    all_users = api.get_all_userdata()",
            "",
            "    users = {}",
            "",
            "    # NOTE: messy code...",
            "    for data in all_users.values():",
            "        name = data[\"name\"]",
            "        users[name] = {\"perms\": get_permission(data[\"permission\"])}",
            "        users[name][\"perms\"][\"admin\"] = data[\"role\"] == 0",
            "",
            "    s = flask.session",
            "    for name in list(users):",
            "        data = users[name]",
            "        if flask.request.form.get(f\"{name}|delete\"):",
            "            api.remove_user(name)",
            "            del users[name]",
            "            continue",
            "        if flask.request.form.get(f\"{name}|admin\"):",
            "            data[\"role\"] = 0",
            "            data[\"perms\"][\"admin\"] = True",
            "        elif name != s[\"name\"]:",
            "            data[\"role\"] = 1",
            "            data[\"perms\"][\"admin\"] = False",
            "",
            "        # set all perms to false",
            "        for perm in permlist():",
            "            data[\"perms\"][perm] = False",
            "",
            "        for perm in flask.request.form.getlist(f\"{name}|perms\"):",
            "            data[\"perms\"][perm] = True",
            "",
            "        data[\"permission\"] = set_permission(data[\"perms\"])",
            "",
            "        api.set_user_permission(name, data[\"permission\"], data[\"role\"])",
            "",
            "    return jsonify(True)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "import os",
            "",
            "import flask",
            "from flask.json import jsonify",
            "from pyload import PKGDIR",
            "from pyload.core.api import Role",
            "from pyload.core.utils import format",
            "",
            "from ..helpers import get_permission, login_required, permlist, render_template, set_permission",
            "",
            "bp = flask.Blueprint(\"json\", __name__)",
            "",
            "",
            "@bp.route(\"/json/status\", methods=[\"GET\", \"POST\"], endpoint=\"status\")",
            "# @apiver_check",
            "@login_required(\"LIST\")",
            "def status():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    data = api.status_server()",
            "    return jsonify(data)",
            "",
            "",
            "@bp.route(\"/json/links\", methods=[\"GET\", \"POST\"], endpoint=\"links\")",
            "# @apiver_check",
            "@login_required(\"LIST\")",
            "def links():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        links = api.status_downloads()",
            "        ids = []",
            "        for link in links:",
            "            ids.append(link[\"fid\"])",
            "",
            "            if link[\"status\"] == 12:  #: downloading",
            "                formatted_eta = link[\"format_eta\"]",
            "                formatted_speed = format.speed(link[\"speed\"])",
            "                link[\"info\"] = f\"{formatted_eta} @ {formatted_speed}\"",
            "",
            "            elif link[\"status\"] == 5:  #: waiting",
            "                link[\"percent\"] = 0",
            "                link[\"size\"] = 0",
            "                link[\"bleft\"] = 0",
            "                link[\"info\"] = api._(\"waiting {}\").format(link[\"format_wait\"])",
            "            else:",
            "                link[\"info\"] = \"\"",
            "",
            "        return jsonify(links=links, ids=ids)",
            "",
            "    except Exception as exc:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/packages\", endpoint=\"packages\")",
            "# @apiver_check",
            "@login_required(\"LIST\")",
            "def packages():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        data = api.get_queue()",
            "",
            "        for package in data:",
            "            package[\"links\"] = []",
            "            for file in api.get_package_files(package[\"id\"]):",
            "                package[\"links\"].append(api.get_file_info(file))",
            "",
            "        return jsonify(data)",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/package\", endpoint=\"package\")",
            "# @apiver_check",
            "@login_required(\"LIST\")",
            "def package():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        id = int(flask.request.args.get('id'))",
            "        data = api.get_package_data(id)",
            "",
            "        tmp = data[\"links\"]",
            "        tmp.sort(key=lambda entry: entry[\"order\"])",
            "        data[\"links\"] = tmp",
            "        return jsonify(data)",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/package_order\", endpoint=\"package_order\")",
            "# @apiver_check",
            "@login_required(\"ADD\")",
            "def package_order():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        pid = int(flask.request.args.get('pid'))",
            "        pos = int(flask.request.args.get('pos'))",
            "        api.order_package(pid, pos)",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/abort_link\", endpoint=\"abort_link\")",
            "# @apiver_check",
            "@login_required(\"DELETE\")",
            "def abort_link():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        id = int(flask.request.args.get('id'))",
            "        api.stop_downloads([id])",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/link_order\", endpoint=\"link_order\")",
            "# @apiver_check",
            "@login_required(\"ADD\")",
            "def link_order():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        fid = int(flask.request.args.get('fid'))",
            "        pos = int(flask.request.args.get('pos'))",
            "        api.order_file(fid, pos)",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/add_package\", methods=[\"POST\"], endpoint=\"add_package\")",
            "# @apiver_check",
            "@login_required(\"ADD\")",
            "def add_package():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    package_name = flask.request.form.get(\"add_name\", \"New Package\").strip()",
            "    queue = int(flask.request.form[\"add_dest\"])",
            "    links = [l.strip() for l in flask.request.form[\"add_links\"].splitlines()]",
            "    pw = flask.request.form.get(\"add_password\", \"\").strip(\"\\n\\r\")",
            "",
            "    try:",
            "        file = flask.request.files[\"add_file\"]",
            "",
            "        if file.filename:",
            "            if not package_name or package_name == \"New Package\":",
            "                package_name = file.filename",
            "",
            "            file_path = os.path.join(",
            "                api.get_config_value(\"general\", \"storage_folder\"), \"tmp_\" + file.filename",
            "            )",
            "            file.save(file_path)",
            "            links.insert(0, file_path)",
            "",
            "    except Exception:",
            "        pass",
            "",
            "    urls = [url for url in links if url.strip()]",
            "    pack = api.add_package(package_name, urls, queue)",
            "    if pw:",
            "        data = {\"password\": pw}",
            "        api.set_package_data(pack, data)",
            "",
            "    return jsonify(True)",
            "",
            "",
            "@bp.route(\"/json/move_package\", endpoint=\"move_package\")",
            "# @apiver_check",
            "@login_required(\"MODIFY\")",
            "def move_package():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        id = int(flask.request.args.get('id'))",
            "        dest = int(flask.request.args.get('dest'))",
            "        api.move_package(dest, id)",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/edit_package\", methods=[\"POST\"], endpoint=\"edit_package\")",
            "# @apiver_check",
            "@login_required(\"MODIFY\")",
            "def edit_package():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    try:",
            "        pack_id = int(flask.request.form[\"pack_id\"])",
            "        pack_folder = flask.request.form[\"pack_folder\"].lstrip(f\"{os.path.sep}\").replace(f\"..{os.path.sep}\", f\"\")",
            "        data = {",
            "            \"name\": flask.request.form[\"pack_name\"],",
            "            \"_folder\": pack_folder,",
            "            \"password\": flask.request.form[\"pack_pws\"],",
            "        }",
            "",
            "        api.set_package_data(pack_id, data)",
            "        return jsonify(response=\"success\")",
            "",
            "    except Exception:",
            "        return jsonify(False), 500",
            "",
            "",
            "@bp.route(\"/json/set_captcha\", methods=[\"GET\", \"POST\"], endpoint=\"set_captcha\")",
            "# @apiver_check",
            "@login_required(\"ADD\")",
            "def set_captcha():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    if flask.request.method == \"POST\":",
            "        tid = int(flask.request.form[\"cap_id\"])",
            "        result = flask.request.form[\"cap_result\"]",
            "        api.set_captcha_result(tid, result)",
            "",
            "    task = api.get_captcha_task()",
            "    if task.tid >= 0:",
            "        data = {",
            "            \"captcha\": True,",
            "            \"id\": task.tid,",
            "            \"params\": task.data,",
            "            \"result_type\": task.result_type,",
            "        }",
            "    else:",
            "        data = {\"captcha\": False}",
            "",
            "    return jsonify(data)",
            "",
            "",
            "@bp.route(\"/json/load_config\", endpoint=\"load_config\")",
            "# @apiver_check",
            "@login_required(\"SETTINGS\")",
            "def load_config():",
            "    category = flask.request.args.get('category')",
            "    section = flask.request.args.get('section')",
            "    if category not in (\"core\", \"plugin\") or not section:",
            "        return jsonify(False), 500",
            "",
            "    conf = None",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    if category == \"core\":",
            "        conf = api.get_config_dict()",
            "    elif category == \"plugin\":",
            "        conf = api.get_plugin_config_dict()",
            "",
            "    for key, option in conf[section].items():",
            "        if key in (\"desc\", \"outline\"):",
            "            continue",
            "",
            "        if \";\" in option[\"type\"]:",
            "            option[\"list\"] = option[\"type\"].split(\";\")",
            "",
            "    return render_template(\"settings_item.html\", skey=section, section=conf[section])",
            "",
            "",
            "@bp.route(\"/json/save_config\", methods=[\"POST\"], endpoint=\"save_config\")",
            "# @apiver_check",
            "@login_required(\"SETTINGS\")",
            "def save_config():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    category = flask.request.args.get('category')",
            "    if category not in (\"core\", \"plugin\"):",
            "        return jsonify(False), 500",
            "",
            "    for key, value in flask.request.form.items():",
            "        try:",
            "            section, option = key.split(\"|\")",
            "        except ValueError:",
            "            continue",
            "",
            "        api.set_config_value(section, option, value, category)",
            "",
            "    return jsonify(True)",
            "",
            "",
            "@bp.route(\"/json/add_account\", methods=[\"POST\"], endpoint=\"add_account\")",
            "# @apiver_check",
            "@login_required(\"ACCOUNTS\")",
            "# @fresh_login_required",
            "def add_account():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    login = flask.request.form[\"account_login\"]",
            "    password = flask.request.form[\"account_password\"]",
            "    account_type = flask.request.form[\"account_type\"]",
            "",
            "    if login:",
            "        api.update_account(account_type, login, password)",
            "        return jsonify(True)",
            "",
            "    else:",
            "        return jsonify(False)",
            "",
            "",
            "@bp.route(\"/json/update_accounts\", methods=[\"POST\"], endpoint=\"update_accounts\")",
            "# @apiver_check",
            "@login_required(\"ACCOUNTS\")",
            "# @fresh_login_required",
            "def update_accounts():",
            "    deleted = []  #: don't update deleted accounts, or they will be created again",
            "    updated = {}",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    for name, value in flask.request.form.items():",
            "        value = value.strip()",
            "        if not value:",
            "            continue",
            "",
            "        tmp, user = name.split(\";\")",
            "        plugin, action = tmp.split(\"|\")",
            "",
            "        if action == \"delete\":",
            "            deleted.append((plugin,user, ))",
            "            api.remove_account(plugin, user)",
            "",
            "        elif action == \"password\":",
            "            password, options = updated.get((plugin, user,), (None, {}))",
            "            password = value",
            "            updated[(plugin, user,)] = (password, options)",
            "        elif action == \"time\" and \"-\" in value:",
            "            password, options = updated.get((plugin, user,), (None, {}))",
            "            options[\"time\"] = [value]",
            "            updated[(plugin, user,)] = (password, options)",
            "        elif action == \"limitdl\" and value.isdigit():",
            "            password, options = updated.get((plugin, user,), (None, {}))",
            "            options[\"limit_dl\"] = [value]",
            "            updated[(plugin, user,)] = (password, options)",
            "",
            "    for tmp, options in updated.items():",
            "        plugin, user = tmp",
            "        if (plugin, user,) in deleted:",
            "            continue",
            "        password, options = options",
            "        api.update_account(plugin, user, password, options=options)",
            "",
            "    return jsonify(True)",
            "",
            "",
            "@bp.route(\"/json/change_password\", methods=[\"POST\"], endpoint=\"change_password\")",
            "# @apiver_check",
            "# @fresh_login_required",
            "@login_required(\"ACCOUNTS\")",
            "def change_password():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    user = flask.request.form[\"user_login\"]",
            "    oldpw = flask.request.form[\"login_current_password\"]",
            "    newpw = flask.request.form[\"login_new_password\"]",
            "",
            "    done = api.change_password(user, oldpw, newpw)",
            "    if not done:",
            "        return jsonify(False), 500  #: Wrong password",
            "",
            "    return jsonify(True)",
            "",
            "@bp.route(\"/json/add_user\", methods=[\"POST\"], endpoint=\"add_user\")",
            "# @apiver_check",
            "@login_required(\"ADMIN\")",
            "# @fresh_login_required",
            "def add_user():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    user = flask.request.form[\"new_user\"]",
            "    password = flask.request.form[\"new_password\"]",
            "    role = Role.ADMIN if flask.request.form.get(\"new_role\") == \"on\" else Role.USER",
            "    perms = {}",
            "    for perm in permlist():",
            "        perms[perm] = False",
            "    for perm in flask.request.form.getlist(\"new_perms\"):",
            "        perms[perm] = True",
            "",
            "    perms = set_permission(perms)",
            "",
            "    done = api.add_user(user, password, role, perms)",
            "    if not done:",
            "        return jsonify(False), 500  #: Duplicate user",
            "",
            "    return jsonify(True)",
            "",
            "@bp.route(\"/json/update_users\", methods=[\"POST\"], endpoint=\"update_users\")",
            "# @apiver_check",
            "# @fresh_login_required",
            "@login_required(\"ADMIN\")",
            "def update_users():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    all_users = api.get_all_userdata()",
            "",
            "    users = {}",
            "",
            "    # NOTE: messy code...",
            "    for data in all_users.values():",
            "        name = data[\"name\"]",
            "        users[name] = {\"perms\": get_permission(data[\"permission\"])}",
            "        users[name][\"perms\"][\"admin\"] = data[\"role\"] == 0",
            "",
            "    s = flask.session",
            "    for name in list(users):",
            "        data = users[name]",
            "        if flask.request.form.get(f\"{name}|delete\"):",
            "            api.remove_user(name)",
            "            del users[name]",
            "            continue",
            "        if flask.request.form.get(f\"{name}|admin\"):",
            "            data[\"role\"] = 0",
            "            data[\"perms\"][\"admin\"] = True",
            "        elif name != s[\"name\"]:",
            "            data[\"role\"] = 1",
            "            data[\"perms\"][\"admin\"] = False",
            "",
            "        # set all perms to false",
            "        for perm in permlist():",
            "            data[\"perms\"][perm] = False",
            "",
            "        for perm in flask.request.form.getlist(f\"{name}|perms\"):",
            "            data[\"perms\"][perm] = True",
            "",
            "        data[\"permission\"] = set_permission(data[\"perms\"])",
            "",
            "        api.set_user_permission(name, data[\"permission\"], data[\"role\"])",
            "",
            "    return jsonify(True)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "271": [
                "save_config"
            ],
            "274": [
                "save_config"
            ],
            "275": [
                "save_config"
            ],
            "276": [
                "save_config"
            ],
            "277": [
                "save_config"
            ],
            "278": [
                "save_config"
            ],
            "279": [
                "save_config"
            ]
        },
        "addLocation": []
    }
}