{
    "Tests/test_file_blp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " def test_load_blp2_dxt1a():"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     with Image.open(\"Tests/images/blp/blp2_dxt1a.blp\") as im:"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "         assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1a.png\")"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+@pytest.mark.parametrize("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    \"test_file\","
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    ["
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+        \"Tests/images/timeout-060745d3f534ad6e4128c51d336ea5489182c69d.blp\","
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+        \"Tests/images/timeout-31c8f86233ea728339c6e586be7af661a09b5b98.blp\","
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        \"Tests/images/timeout-60d8b7c8469d59fc9ffff6b3a3dc0faeae6ea8ee.blp\","
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        \"Tests/images/timeout-8073b430977660cdd48d96f6406ddfd4114e69c7.blp\","
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        \"Tests/images/timeout-bba4f2e026b5786529370e5dfe9a11b1bf991f07.blp\","
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        \"Tests/images/timeout-d6ec061c4afdef39d3edf6da8927240bb07fe9b7.blp\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        \"Tests/images/timeout-ef9112a065e7183fa7faa2e18929b03e44ee16bf.blp\","
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    ],"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+def test_crashes(test_file):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    with open(test_file, \"rb\") as f:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        with Image.open(f) as im:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+            with pytest.raises(OSError):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+                im.load()"
            }
        },
        "frontPatchFile": [
            "from PIL import Image",
            "import pytest",
            "",
            "from .helper import assert_image_equal_tofile",
            "",
            "",
            "def test_load_blp2_raw():",
            "    with Image.open(\"Tests/images/blp/blp2_raw.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_raw.png\")",
            "",
            "",
            "def test_load_blp2_dxt1():",
            "    with Image.open(\"Tests/images/blp/blp2_dxt1.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1.png\")",
            "",
            "",
            "def test_load_blp2_dxt1a():",
            "    with Image.open(\"Tests/images/blp/blp2_dxt1a.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1a.png\")"
        ],
        "afterPatchFile": [
            "from PIL import Image",
            "import pytest",
            "",
            "from .helper import assert_image_equal_tofile",
            "",
            "",
            "def test_load_blp2_raw():",
            "    with Image.open(\"Tests/images/blp/blp2_raw.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_raw.png\")",
            "",
            "",
            "def test_load_blp2_dxt1():",
            "    with Image.open(\"Tests/images/blp/blp2_dxt1.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1.png\")",
            "",
            "",
            "def test_load_blp2_dxt1a():",
            "    with Image.open(\"Tests/images/blp/blp2_dxt1a.blp\") as im:",
            "        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1a.png\")",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"test_file\",",
            "    [",
            "        \"Tests/images/timeout-060745d3f534ad6e4128c51d336ea5489182c69d.blp\",",
            "        \"Tests/images/timeout-31c8f86233ea728339c6e586be7af661a09b5b98.blp\",",
            "        \"Tests/images/timeout-60d8b7c8469d59fc9ffff6b3a3dc0faeae6ea8ee.blp\",",
            "        \"Tests/images/timeout-8073b430977660cdd48d96f6406ddfd4114e69c7.blp\",",
            "        \"Tests/images/timeout-bba4f2e026b5786529370e5dfe9a11b1bf991f07.blp\",",
            "        \"Tests/images/timeout-d6ec061c4afdef39d3edf6da8927240bb07fe9b7.blp\",",
            "        \"Tests/images/timeout-ef9112a065e7183fa7faa2e18929b03e44ee16bf.blp\",",
            "    ],",
            ")",
            "def test_crashes(test_file):",
            "    with open(test_file, \"rb\") as f:",
            "        with Image.open(f) as im:",
            "            with pytest.raises(OSError):",
            "                im.load()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "jinja2.nodes.Const.from_untrusted"
        ]
    },
    "src/PIL/BlpImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "             raise OSError(\"Truncated Blp file\") from e"
            },
            "1": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         return 0, 0"
            },
            "2": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 288,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+    def _safe_read(self, length):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+        return ImageFile._safe_read(self.fd, length)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "     def _read_palette(self):"
            },
            "7": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "         ret = []"
            },
            "8": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "         for i in range(256):"
            },
            "9": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "             try:"
            },
            "10": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                b, g, r, a = struct.unpack(\"<4B\", self.fd.read(4))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+                b, g, r, a = struct.unpack(\"<4B\", self._safe_read(4))"
            },
            "12": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "             except struct.error:"
            },
            "13": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "                 break"
            },
            "14": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "             ret.append((b, g, r, a))"
            },
            "15": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         return ret"
            },
            "16": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 301,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "     def _read_blp_header(self):"
            },
            "18": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        (self._blp_compression,) = struct.unpack(\"<i\", self.fd.read(4))"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+        (self._blp_compression,) = struct.unpack(\"<i\", self._safe_read(4))"
            },
            "20": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 304,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        (self._blp_encoding,) = struct.unpack(\"<b\", self.fd.read(1))"
            },
            "22": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fd.read(1))"
            },
            "23": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self.fd.read(1))"
            },
            "24": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        (self._blp_mips,) = struct.unpack(\"<b\", self.fd.read(1))"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        (self._blp_encoding,) = struct.unpack(\"<b\", self._safe_read(1))"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self._safe_read(1))"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self._safe_read(1))"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+        (self._blp_mips,) = struct.unpack(\"<b\", self._safe_read(1))"
            },
            "29": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 309,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.size = struct.unpack(\"<II\", self.fd.read(8))"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+        self.size = struct.unpack(\"<II\", self._safe_read(8))"
            },
            "32": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 311,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "         if self.magic == b\"BLP1\":"
            },
            "34": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "             # Only present for BLP1"
            },
            "35": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            (self._blp_encoding,) = struct.unpack(\"<i\", self.fd.read(4))"
            },
            "36": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            (self._blp_subtype,) = struct.unpack(\"<i\", self.fd.read(4))"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+            (self._blp_encoding,) = struct.unpack(\"<i\", self._safe_read(4))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+            (self._blp_subtype,) = struct.unpack(\"<i\", self._safe_read(4))"
            },
            "39": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 316,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._blp_offsets = struct.unpack(\"<16I\", self.fd.read(16 * 4))"
            },
            "41": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._blp_lengths = struct.unpack(\"<16I\", self.fd.read(16 * 4))"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+        self._blp_offsets = struct.unpack(\"<16I\", self._safe_read(16 * 4))"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+        self._blp_lengths = struct.unpack(\"<16I\", self._safe_read(16 * 4))"
            },
            "44": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 319,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 320,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 321,
                "PatchRowcode": " class BLP1Decoder(_BLPBaseDecoder):"
            },
            "47": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "             if self._blp_encoding in (4, 5):"
            },
            "48": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "                 data = bytearray()"
            },
            "49": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "                 palette = self._read_palette()"
            },
            "50": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                _data = BytesIO(self.fd.read(self._blp_lengths[0]))"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+                _data = BytesIO(self._safe_read(self._blp_lengths[0]))"
            },
            "52": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "                 while True:"
            },
            "53": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "                     try:"
            },
            "54": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "                         (offset,) = struct.unpack(\"<B\", _data.read(1))"
            },
            "55": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "     def _decode_jpeg_stream(self):"
            },
            "56": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "         from PIL.JpegImagePlugin import JpegImageFile"
            },
            "57": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 351,
                "PatchRowcode": " "
            },
            "58": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        (jpeg_header_size,) = struct.unpack(\"<I\", self.fd.read(4))"
            },
            "59": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        jpeg_header = self.fd.read(jpeg_header_size)"
            },
            "60": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.fd.read(self._blp_offsets[0] - self.fd.tell())  # What IS this?"
            },
            "61": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        data = self.fd.read(self._blp_lengths[0])"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+        (jpeg_header_size,) = struct.unpack(\"<I\", self._safe_read(4))"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+        jpeg_header = self._safe_read(jpeg_header_size)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+        self._safe_read(self._blp_offsets[0] - self.fd.tell())  # What IS this?"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        data = self._safe_read(self._blp_lengths[0])"
            },
            "66": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         data = jpeg_header + data"
            },
            "67": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "         data = BytesIO(data)"
            },
            "68": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "         image = JpegImageFile(data)"
            },
            "69": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "             # Uncompressed or DirectX compression"
            },
            "70": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 374,
                "PatchRowcode": " "
            },
            "71": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "             if self._blp_encoding == BLP_ENCODING_UNCOMPRESSED:"
            },
            "72": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                _data = BytesIO(self.fd.read(self._blp_lengths[0]))"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+                _data = BytesIO(self._safe_read(self._blp_lengths[0]))"
            },
            "74": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "                 while True:"
            },
            "75": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "                     try:"
            },
            "76": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "                         (offset,) = struct.unpack(\"<B\", _data.read(1))"
            },
            "77": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "                     linesize = (self.size[0] + 3) // 4 * 8"
            },
            "78": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "                     for yb in range((self.size[1] + 3) // 4):"
            },
            "79": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "                         for d in decode_dxt1("
            },
            "80": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            self.fd.read(linesize), alpha=bool(self._blp_alpha_depth)"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+                            self._safe_read(linesize), alpha=bool(self._blp_alpha_depth)"
            },
            "82": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "                         ):"
            },
            "83": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 392,
                "PatchRowcode": "                             data += d"
            },
            "84": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 393,
                "PatchRowcode": " "
            },
            "85": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "                 elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT3:"
            },
            "86": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "                     linesize = (self.size[0] + 3) // 4 * 16"
            },
            "87": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "                     for yb in range((self.size[1] + 3) // 4):"
            },
            "88": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        for d in decode_dxt3(self.fd.read(linesize)):"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+                        for d in decode_dxt3(self._safe_read(linesize)):"
            },
            "90": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "                             data += d"
            },
            "91": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 399,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "                 elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT5:"
            },
            "93": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "                     linesize = (self.size[0] + 3) // 4 * 16"
            },
            "94": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "                     for yb in range((self.size[1] + 3) // 4):"
            },
            "95": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        for d in decode_dxt5(self.fd.read(linesize)):"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+                        for d in decode_dxt5(self._safe_read(linesize)):"
            },
            "97": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "                             data += d"
            },
            "98": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "                 else:"
            },
            "99": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "                     raise BLPFormatError("
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Blizzard Mipmap Format (.blp)",
            "Jerome Leclanche <jerome@leclan.ch>",
            "",
            "The contents of this file are hereby released in the public domain (CC0)",
            "Full text of the CC0 license:",
            "  https://creativecommons.org/publicdomain/zero/1.0/",
            "",
            "BLP1 files, used mostly in Warcraft III, are not fully supported.",
            "All types of BLP2 files used in World of Warcraft are supported.",
            "",
            "The BLP file structure consists of a header, up to 16 mipmaps of the",
            "texture",
            "",
            "Texture sizes must be powers of two, though the two dimensions do",
            "not have to be equal; 512x256 is valid, but 512x200 is not.",
            "The first mipmap (mipmap #0) is the full size image; each subsequent",
            "mipmap halves both dimensions. The final mipmap should be 1x1.",
            "",
            "BLP files come in many different flavours:",
            "* JPEG-compressed (type == 0) - only supported for BLP1.",
            "* RAW images (type == 1, encoding == 1). Each mipmap is stored as an",
            "  array of 8-bit values, one per pixel, left to right, top to bottom.",
            "  Each value is an index to the palette.",
            "* DXT-compressed (type == 1, encoding == 2):",
            "- DXT1 compression is used if alpha_encoding == 0.",
            "  - An additional alpha bit is used if alpha_depth == 1.",
            "  - DXT3 compression is used if alpha_encoding == 1.",
            "  - DXT5 compression is used if alpha_encoding == 7.",
            "\"\"\"",
            "",
            "import struct",
            "from io import BytesIO",
            "",
            "from . import Image, ImageFile",
            "",
            "BLP_FORMAT_JPEG = 0",
            "",
            "BLP_ENCODING_UNCOMPRESSED = 1",
            "BLP_ENCODING_DXT = 2",
            "BLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3",
            "",
            "BLP_ALPHA_ENCODING_DXT1 = 0",
            "BLP_ALPHA_ENCODING_DXT3 = 1",
            "BLP_ALPHA_ENCODING_DXT5 = 7",
            "",
            "",
            "def unpack_565(i):",
            "    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)",
            "",
            "",
            "def decode_dxt1(data, alpha=False):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4*width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 8  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        # Decode next 8-byte block.",
            "        idx = block * 8",
            "        color0, color1, bits = struct.unpack_from(\"<HHI\", data, idx)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        # Decode this block into 4x4 pixels",
            "        # Accumulate the results onto our 4 row accumulators",
            "        for j in range(4):",
            "            for i in range(4):",
            "                # get next control op and generate a pixel",
            "",
            "                control = bits & 3",
            "                bits = bits >> 2",
            "",
            "                a = 0xFF",
            "                if control == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif control == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif control == 2:",
            "                    if color0 > color1:",
            "                        r = (2 * r0 + r1) // 3",
            "                        g = (2 * g0 + g1) // 3",
            "                        b = (2 * b0 + b1) // 3",
            "                    else:",
            "                        r = (r0 + r1) // 2",
            "                        g = (g0 + g1) // 2",
            "                        b = (b0 + b1) // 2",
            "                elif control == 3:",
            "                    if color0 > color1:",
            "                        r = (2 * r1 + r0) // 3",
            "                        g = (2 * g1 + g0) // 3",
            "                        b = (2 * b1 + b0) // 3",
            "                    else:",
            "                        r, g, b, a = 0, 0, 0, 0",
            "",
            "                if alpha:",
            "                    ret[j].extend([r, g, b, a])",
            "                else:",
            "                    ret[j].extend([r, g, b])",
            "",
            "    return ret",
            "",
            "",
            "def decode_dxt3(data):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4*width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 16  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        idx = block * 16",
            "        block = data[idx : idx + 16]",
            "        # Decode next 16-byte block.",
            "        bits = struct.unpack_from(\"<8B\", block)",
            "        color0, color1 = struct.unpack_from(\"<HH\", block, 8)",
            "",
            "        (code,) = struct.unpack_from(\"<I\", block, 12)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        for j in range(4):",
            "            high = False  # Do we want the higher bits?",
            "            for i in range(4):",
            "                alphacode_index = (4 * j + i) // 2",
            "                a = bits[alphacode_index]",
            "                if high:",
            "                    high = False",
            "                    a >>= 4",
            "                else:",
            "                    high = True",
            "                    a &= 0xF",
            "                a *= 17  # We get a value between 0 and 15",
            "",
            "                color_code = (code >> 2 * (4 * j + i)) & 0x03",
            "",
            "                if color_code == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif color_code == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif color_code == 2:",
            "                    r = (2 * r0 + r1) // 3",
            "                    g = (2 * g0 + g1) // 3",
            "                    b = (2 * b0 + b1) // 3",
            "                elif color_code == 3:",
            "                    r = (2 * r1 + r0) // 3",
            "                    g = (2 * g1 + g0) // 3",
            "                    b = (2 * b1 + b0) // 3",
            "",
            "                ret[j].extend([r, g, b, a])",
            "",
            "    return ret",
            "",
            "",
            "def decode_dxt5(data):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4 * width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 16  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        idx = block * 16",
            "        block = data[idx : idx + 16]",
            "        # Decode next 16-byte block.",
            "        a0, a1 = struct.unpack_from(\"<BB\", block)",
            "",
            "        bits = struct.unpack_from(\"<6B\", block, 2)",
            "        alphacode1 = bits[2] | (bits[3] << 8) | (bits[4] << 16) | (bits[5] << 24)",
            "        alphacode2 = bits[0] | (bits[1] << 8)",
            "",
            "        color0, color1 = struct.unpack_from(\"<HH\", block, 8)",
            "",
            "        (code,) = struct.unpack_from(\"<I\", block, 12)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        for j in range(4):",
            "            for i in range(4):",
            "                # get next control op and generate a pixel",
            "                alphacode_index = 3 * (4 * j + i)",
            "",
            "                if alphacode_index <= 12:",
            "                    alphacode = (alphacode2 >> alphacode_index) & 0x07",
            "                elif alphacode_index == 15:",
            "                    alphacode = (alphacode2 >> 15) | ((alphacode1 << 1) & 0x06)",
            "                else:  # alphacode_index >= 18 and alphacode_index <= 45",
            "                    alphacode = (alphacode1 >> (alphacode_index - 16)) & 0x07",
            "",
            "                if alphacode == 0:",
            "                    a = a0",
            "                elif alphacode == 1:",
            "                    a = a1",
            "                elif a0 > a1:",
            "                    a = ((8 - alphacode) * a0 + (alphacode - 1) * a1) // 7",
            "                elif alphacode == 6:",
            "                    a = 0",
            "                elif alphacode == 7:",
            "                    a = 255",
            "                else:",
            "                    a = ((6 - alphacode) * a0 + (alphacode - 1) * a1) // 5",
            "",
            "                color_code = (code >> 2 * (4 * j + i)) & 0x03",
            "",
            "                if color_code == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif color_code == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif color_code == 2:",
            "                    r = (2 * r0 + r1) // 3",
            "                    g = (2 * g0 + g1) // 3",
            "                    b = (2 * b0 + b1) // 3",
            "                elif color_code == 3:",
            "                    r = (2 * r1 + r0) // 3",
            "                    g = (2 * g1 + g0) // 3",
            "                    b = (2 * b1 + b0) // 3",
            "",
            "                ret[j].extend([r, g, b, a])",
            "",
            "    return ret",
            "",
            "",
            "class BLPFormatError(NotImplementedError):",
            "    pass",
            "",
            "",
            "class BlpImageFile(ImageFile.ImageFile):",
            "    \"\"\"",
            "    Blizzard Mipmap Format",
            "    \"\"\"",
            "",
            "    format = \"BLP\"",
            "    format_description = \"Blizzard Mipmap Format\"",
            "",
            "    def _open(self):",
            "        self.magic = self.fp.read(4)",
            "        self._read_blp_header()",
            "",
            "        if self.magic == b\"BLP1\":",
            "            decoder = \"BLP1\"",
            "            self.mode = \"RGB\"",
            "        elif self.magic == b\"BLP2\":",
            "            decoder = \"BLP2\"",
            "            self.mode = \"RGBA\" if self._blp_alpha_depth else \"RGB\"",
            "        else:",
            "            raise BLPFormatError(f\"Bad BLP magic {repr(self.magic)}\")",
            "",
            "        self.tile = [(decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]",
            "",
            "    def _read_blp_header(self):",
            "        (self._blp_compression,) = struct.unpack(\"<i\", self.fp.read(4))",
            "",
            "        (self._blp_encoding,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_mips,) = struct.unpack(\"<b\", self.fp.read(1))",
            "",
            "        self._size = struct.unpack(\"<II\", self.fp.read(8))",
            "",
            "        if self.magic == b\"BLP1\":",
            "            # Only present for BLP1",
            "            (self._blp_encoding,) = struct.unpack(\"<i\", self.fp.read(4))",
            "            (self._blp_subtype,) = struct.unpack(\"<i\", self.fp.read(4))",
            "",
            "        self._blp_offsets = struct.unpack(\"<16I\", self.fp.read(16 * 4))",
            "        self._blp_lengths = struct.unpack(\"<16I\", self.fp.read(16 * 4))",
            "",
            "",
            "class _BLPBaseDecoder(ImageFile.PyDecoder):",
            "    _pulls_fd = True",
            "",
            "    def decode(self, buffer):",
            "        try:",
            "            self.fd.seek(0)",
            "            self.magic = self.fd.read(4)",
            "            self._read_blp_header()",
            "            self._load()",
            "        except struct.error as e:",
            "            raise OSError(\"Truncated Blp file\") from e",
            "        return 0, 0",
            "",
            "    def _read_palette(self):",
            "        ret = []",
            "        for i in range(256):",
            "            try:",
            "                b, g, r, a = struct.unpack(\"<4B\", self.fd.read(4))",
            "            except struct.error:",
            "                break",
            "            ret.append((b, g, r, a))",
            "        return ret",
            "",
            "    def _read_blp_header(self):",
            "        (self._blp_compression,) = struct.unpack(\"<i\", self.fd.read(4))",
            "",
            "        (self._blp_encoding,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_mips,) = struct.unpack(\"<b\", self.fd.read(1))",
            "",
            "        self.size = struct.unpack(\"<II\", self.fd.read(8))",
            "",
            "        if self.magic == b\"BLP1\":",
            "            # Only present for BLP1",
            "            (self._blp_encoding,) = struct.unpack(\"<i\", self.fd.read(4))",
            "            (self._blp_subtype,) = struct.unpack(\"<i\", self.fd.read(4))",
            "",
            "        self._blp_offsets = struct.unpack(\"<16I\", self.fd.read(16 * 4))",
            "        self._blp_lengths = struct.unpack(\"<16I\", self.fd.read(16 * 4))",
            "",
            "",
            "class BLP1Decoder(_BLPBaseDecoder):",
            "    def _load(self):",
            "        if self._blp_compression == BLP_FORMAT_JPEG:",
            "            self._decode_jpeg_stream()",
            "",
            "        elif self._blp_compression == 1:",
            "            if self._blp_encoding in (4, 5):",
            "                data = bytearray()",
            "                palette = self._read_palette()",
            "                _data = BytesIO(self.fd.read(self._blp_lengths[0]))",
            "                while True:",
            "                    try:",
            "                        (offset,) = struct.unpack(\"<B\", _data.read(1))",
            "                    except struct.error:",
            "                        break",
            "                    b, g, r, a = palette[offset]",
            "                    data.extend([r, g, b])",
            "",
            "                self.set_as_raw(bytes(data))",
            "            else:",
            "                raise BLPFormatError(",
            "                    f\"Unsupported BLP encoding {repr(self._blp_encoding)}\"",
            "                )",
            "        else:",
            "            raise BLPFormatError(",
            "                f\"Unsupported BLP compression {repr(self._blp_encoding)}\"",
            "            )",
            "",
            "    def _decode_jpeg_stream(self):",
            "        from PIL.JpegImagePlugin import JpegImageFile",
            "",
            "        (jpeg_header_size,) = struct.unpack(\"<I\", self.fd.read(4))",
            "        jpeg_header = self.fd.read(jpeg_header_size)",
            "        self.fd.read(self._blp_offsets[0] - self.fd.tell())  # What IS this?",
            "        data = self.fd.read(self._blp_lengths[0])",
            "        data = jpeg_header + data",
            "        data = BytesIO(data)",
            "        image = JpegImageFile(data)",
            "        Image._decompression_bomb_check(image.size)",
            "        self.tile = image.tile  # :/",
            "        self.fd = image.fp",
            "        self.mode = image.mode",
            "",
            "",
            "class BLP2Decoder(_BLPBaseDecoder):",
            "    def _load(self):",
            "        palette = self._read_palette()",
            "",
            "        data = bytearray()",
            "        self.fd.seek(self._blp_offsets[0])",
            "",
            "        if self._blp_compression == 1:",
            "            # Uncompressed or DirectX compression",
            "",
            "            if self._blp_encoding == BLP_ENCODING_UNCOMPRESSED:",
            "                _data = BytesIO(self.fd.read(self._blp_lengths[0]))",
            "                while True:",
            "                    try:",
            "                        (offset,) = struct.unpack(\"<B\", _data.read(1))",
            "                    except struct.error:",
            "                        break",
            "                    b, g, r, a = palette[offset]",
            "                    data.extend((r, g, b))",
            "",
            "            elif self._blp_encoding == BLP_ENCODING_DXT:",
            "                if self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT1:",
            "                    linesize = (self.size[0] + 3) // 4 * 8",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt1(",
            "                            self.fd.read(linesize), alpha=bool(self._blp_alpha_depth)",
            "                        ):",
            "                            data += d",
            "",
            "                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT3:",
            "                    linesize = (self.size[0] + 3) // 4 * 16",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt3(self.fd.read(linesize)):",
            "                            data += d",
            "",
            "                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT5:",
            "                    linesize = (self.size[0] + 3) // 4 * 16",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt5(self.fd.read(linesize)):",
            "                            data += d",
            "                else:",
            "                    raise BLPFormatError(",
            "                        f\"Unsupported alpha encoding {repr(self._blp_alpha_encoding)}\"",
            "                    )",
            "            else:",
            "                raise BLPFormatError(f\"Unknown BLP encoding {repr(self._blp_encoding)}\")",
            "",
            "        else:",
            "            raise BLPFormatError(",
            "                f\"Unknown BLP compression {repr(self._blp_compression)}\"",
            "            )",
            "",
            "        self.set_as_raw(bytes(data))",
            "",
            "",
            "Image.register_open(",
            "    BlpImageFile.format, BlpImageFile, lambda p: p[:4] in (b\"BLP1\", b\"BLP2\")",
            ")",
            "Image.register_extension(BlpImageFile.format, \".blp\")",
            "",
            "Image.register_decoder(\"BLP1\", BLP1Decoder)",
            "Image.register_decoder(\"BLP2\", BLP2Decoder)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Blizzard Mipmap Format (.blp)",
            "Jerome Leclanche <jerome@leclan.ch>",
            "",
            "The contents of this file are hereby released in the public domain (CC0)",
            "Full text of the CC0 license:",
            "  https://creativecommons.org/publicdomain/zero/1.0/",
            "",
            "BLP1 files, used mostly in Warcraft III, are not fully supported.",
            "All types of BLP2 files used in World of Warcraft are supported.",
            "",
            "The BLP file structure consists of a header, up to 16 mipmaps of the",
            "texture",
            "",
            "Texture sizes must be powers of two, though the two dimensions do",
            "not have to be equal; 512x256 is valid, but 512x200 is not.",
            "The first mipmap (mipmap #0) is the full size image; each subsequent",
            "mipmap halves both dimensions. The final mipmap should be 1x1.",
            "",
            "BLP files come in many different flavours:",
            "* JPEG-compressed (type == 0) - only supported for BLP1.",
            "* RAW images (type == 1, encoding == 1). Each mipmap is stored as an",
            "  array of 8-bit values, one per pixel, left to right, top to bottom.",
            "  Each value is an index to the palette.",
            "* DXT-compressed (type == 1, encoding == 2):",
            "- DXT1 compression is used if alpha_encoding == 0.",
            "  - An additional alpha bit is used if alpha_depth == 1.",
            "  - DXT3 compression is used if alpha_encoding == 1.",
            "  - DXT5 compression is used if alpha_encoding == 7.",
            "\"\"\"",
            "",
            "import struct",
            "from io import BytesIO",
            "",
            "from . import Image, ImageFile",
            "",
            "BLP_FORMAT_JPEG = 0",
            "",
            "BLP_ENCODING_UNCOMPRESSED = 1",
            "BLP_ENCODING_DXT = 2",
            "BLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3",
            "",
            "BLP_ALPHA_ENCODING_DXT1 = 0",
            "BLP_ALPHA_ENCODING_DXT3 = 1",
            "BLP_ALPHA_ENCODING_DXT5 = 7",
            "",
            "",
            "def unpack_565(i):",
            "    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)",
            "",
            "",
            "def decode_dxt1(data, alpha=False):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4*width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 8  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        # Decode next 8-byte block.",
            "        idx = block * 8",
            "        color0, color1, bits = struct.unpack_from(\"<HHI\", data, idx)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        # Decode this block into 4x4 pixels",
            "        # Accumulate the results onto our 4 row accumulators",
            "        for j in range(4):",
            "            for i in range(4):",
            "                # get next control op and generate a pixel",
            "",
            "                control = bits & 3",
            "                bits = bits >> 2",
            "",
            "                a = 0xFF",
            "                if control == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif control == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif control == 2:",
            "                    if color0 > color1:",
            "                        r = (2 * r0 + r1) // 3",
            "                        g = (2 * g0 + g1) // 3",
            "                        b = (2 * b0 + b1) // 3",
            "                    else:",
            "                        r = (r0 + r1) // 2",
            "                        g = (g0 + g1) // 2",
            "                        b = (b0 + b1) // 2",
            "                elif control == 3:",
            "                    if color0 > color1:",
            "                        r = (2 * r1 + r0) // 3",
            "                        g = (2 * g1 + g0) // 3",
            "                        b = (2 * b1 + b0) // 3",
            "                    else:",
            "                        r, g, b, a = 0, 0, 0, 0",
            "",
            "                if alpha:",
            "                    ret[j].extend([r, g, b, a])",
            "                else:",
            "                    ret[j].extend([r, g, b])",
            "",
            "    return ret",
            "",
            "",
            "def decode_dxt3(data):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4*width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 16  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        idx = block * 16",
            "        block = data[idx : idx + 16]",
            "        # Decode next 16-byte block.",
            "        bits = struct.unpack_from(\"<8B\", block)",
            "        color0, color1 = struct.unpack_from(\"<HH\", block, 8)",
            "",
            "        (code,) = struct.unpack_from(\"<I\", block, 12)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        for j in range(4):",
            "            high = False  # Do we want the higher bits?",
            "            for i in range(4):",
            "                alphacode_index = (4 * j + i) // 2",
            "                a = bits[alphacode_index]",
            "                if high:",
            "                    high = False",
            "                    a >>= 4",
            "                else:",
            "                    high = True",
            "                    a &= 0xF",
            "                a *= 17  # We get a value between 0 and 15",
            "",
            "                color_code = (code >> 2 * (4 * j + i)) & 0x03",
            "",
            "                if color_code == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif color_code == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif color_code == 2:",
            "                    r = (2 * r0 + r1) // 3",
            "                    g = (2 * g0 + g1) // 3",
            "                    b = (2 * b0 + b1) // 3",
            "                elif color_code == 3:",
            "                    r = (2 * r1 + r0) // 3",
            "                    g = (2 * g1 + g0) // 3",
            "                    b = (2 * b1 + b0) // 3",
            "",
            "                ret[j].extend([r, g, b, a])",
            "",
            "    return ret",
            "",
            "",
            "def decode_dxt5(data):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4 * width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 16  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        idx = block * 16",
            "        block = data[idx : idx + 16]",
            "        # Decode next 16-byte block.",
            "        a0, a1 = struct.unpack_from(\"<BB\", block)",
            "",
            "        bits = struct.unpack_from(\"<6B\", block, 2)",
            "        alphacode1 = bits[2] | (bits[3] << 8) | (bits[4] << 16) | (bits[5] << 24)",
            "        alphacode2 = bits[0] | (bits[1] << 8)",
            "",
            "        color0, color1 = struct.unpack_from(\"<HH\", block, 8)",
            "",
            "        (code,) = struct.unpack_from(\"<I\", block, 12)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        for j in range(4):",
            "            for i in range(4):",
            "                # get next control op and generate a pixel",
            "                alphacode_index = 3 * (4 * j + i)",
            "",
            "                if alphacode_index <= 12:",
            "                    alphacode = (alphacode2 >> alphacode_index) & 0x07",
            "                elif alphacode_index == 15:",
            "                    alphacode = (alphacode2 >> 15) | ((alphacode1 << 1) & 0x06)",
            "                else:  # alphacode_index >= 18 and alphacode_index <= 45",
            "                    alphacode = (alphacode1 >> (alphacode_index - 16)) & 0x07",
            "",
            "                if alphacode == 0:",
            "                    a = a0",
            "                elif alphacode == 1:",
            "                    a = a1",
            "                elif a0 > a1:",
            "                    a = ((8 - alphacode) * a0 + (alphacode - 1) * a1) // 7",
            "                elif alphacode == 6:",
            "                    a = 0",
            "                elif alphacode == 7:",
            "                    a = 255",
            "                else:",
            "                    a = ((6 - alphacode) * a0 + (alphacode - 1) * a1) // 5",
            "",
            "                color_code = (code >> 2 * (4 * j + i)) & 0x03",
            "",
            "                if color_code == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif color_code == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif color_code == 2:",
            "                    r = (2 * r0 + r1) // 3",
            "                    g = (2 * g0 + g1) // 3",
            "                    b = (2 * b0 + b1) // 3",
            "                elif color_code == 3:",
            "                    r = (2 * r1 + r0) // 3",
            "                    g = (2 * g1 + g0) // 3",
            "                    b = (2 * b1 + b0) // 3",
            "",
            "                ret[j].extend([r, g, b, a])",
            "",
            "    return ret",
            "",
            "",
            "class BLPFormatError(NotImplementedError):",
            "    pass",
            "",
            "",
            "class BlpImageFile(ImageFile.ImageFile):",
            "    \"\"\"",
            "    Blizzard Mipmap Format",
            "    \"\"\"",
            "",
            "    format = \"BLP\"",
            "    format_description = \"Blizzard Mipmap Format\"",
            "",
            "    def _open(self):",
            "        self.magic = self.fp.read(4)",
            "        self._read_blp_header()",
            "",
            "        if self.magic == b\"BLP1\":",
            "            decoder = \"BLP1\"",
            "            self.mode = \"RGB\"",
            "        elif self.magic == b\"BLP2\":",
            "            decoder = \"BLP2\"",
            "            self.mode = \"RGBA\" if self._blp_alpha_depth else \"RGB\"",
            "        else:",
            "            raise BLPFormatError(f\"Bad BLP magic {repr(self.magic)}\")",
            "",
            "        self.tile = [(decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]",
            "",
            "    def _read_blp_header(self):",
            "        (self._blp_compression,) = struct.unpack(\"<i\", self.fp.read(4))",
            "",
            "        (self._blp_encoding,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_mips,) = struct.unpack(\"<b\", self.fp.read(1))",
            "",
            "        self._size = struct.unpack(\"<II\", self.fp.read(8))",
            "",
            "        if self.magic == b\"BLP1\":",
            "            # Only present for BLP1",
            "            (self._blp_encoding,) = struct.unpack(\"<i\", self.fp.read(4))",
            "            (self._blp_subtype,) = struct.unpack(\"<i\", self.fp.read(4))",
            "",
            "        self._blp_offsets = struct.unpack(\"<16I\", self.fp.read(16 * 4))",
            "        self._blp_lengths = struct.unpack(\"<16I\", self.fp.read(16 * 4))",
            "",
            "",
            "class _BLPBaseDecoder(ImageFile.PyDecoder):",
            "    _pulls_fd = True",
            "",
            "    def decode(self, buffer):",
            "        try:",
            "            self.fd.seek(0)",
            "            self.magic = self.fd.read(4)",
            "            self._read_blp_header()",
            "            self._load()",
            "        except struct.error as e:",
            "            raise OSError(\"Truncated Blp file\") from e",
            "        return 0, 0",
            "",
            "    def _safe_read(self, length):",
            "        return ImageFile._safe_read(self.fd, length)",
            "",
            "    def _read_palette(self):",
            "        ret = []",
            "        for i in range(256):",
            "            try:",
            "                b, g, r, a = struct.unpack(\"<4B\", self._safe_read(4))",
            "            except struct.error:",
            "                break",
            "            ret.append((b, g, r, a))",
            "        return ret",
            "",
            "    def _read_blp_header(self):",
            "        (self._blp_compression,) = struct.unpack(\"<i\", self._safe_read(4))",
            "",
            "        (self._blp_encoding,) = struct.unpack(\"<b\", self._safe_read(1))",
            "        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self._safe_read(1))",
            "        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self._safe_read(1))",
            "        (self._blp_mips,) = struct.unpack(\"<b\", self._safe_read(1))",
            "",
            "        self.size = struct.unpack(\"<II\", self._safe_read(8))",
            "",
            "        if self.magic == b\"BLP1\":",
            "            # Only present for BLP1",
            "            (self._blp_encoding,) = struct.unpack(\"<i\", self._safe_read(4))",
            "            (self._blp_subtype,) = struct.unpack(\"<i\", self._safe_read(4))",
            "",
            "        self._blp_offsets = struct.unpack(\"<16I\", self._safe_read(16 * 4))",
            "        self._blp_lengths = struct.unpack(\"<16I\", self._safe_read(16 * 4))",
            "",
            "",
            "class BLP1Decoder(_BLPBaseDecoder):",
            "    def _load(self):",
            "        if self._blp_compression == BLP_FORMAT_JPEG:",
            "            self._decode_jpeg_stream()",
            "",
            "        elif self._blp_compression == 1:",
            "            if self._blp_encoding in (4, 5):",
            "                data = bytearray()",
            "                palette = self._read_palette()",
            "                _data = BytesIO(self._safe_read(self._blp_lengths[0]))",
            "                while True:",
            "                    try:",
            "                        (offset,) = struct.unpack(\"<B\", _data.read(1))",
            "                    except struct.error:",
            "                        break",
            "                    b, g, r, a = palette[offset]",
            "                    data.extend([r, g, b])",
            "",
            "                self.set_as_raw(bytes(data))",
            "            else:",
            "                raise BLPFormatError(",
            "                    f\"Unsupported BLP encoding {repr(self._blp_encoding)}\"",
            "                )",
            "        else:",
            "            raise BLPFormatError(",
            "                f\"Unsupported BLP compression {repr(self._blp_encoding)}\"",
            "            )",
            "",
            "    def _decode_jpeg_stream(self):",
            "        from PIL.JpegImagePlugin import JpegImageFile",
            "",
            "        (jpeg_header_size,) = struct.unpack(\"<I\", self._safe_read(4))",
            "        jpeg_header = self._safe_read(jpeg_header_size)",
            "        self._safe_read(self._blp_offsets[0] - self.fd.tell())  # What IS this?",
            "        data = self._safe_read(self._blp_lengths[0])",
            "        data = jpeg_header + data",
            "        data = BytesIO(data)",
            "        image = JpegImageFile(data)",
            "        Image._decompression_bomb_check(image.size)",
            "        self.tile = image.tile  # :/",
            "        self.fd = image.fp",
            "        self.mode = image.mode",
            "",
            "",
            "class BLP2Decoder(_BLPBaseDecoder):",
            "    def _load(self):",
            "        palette = self._read_palette()",
            "",
            "        data = bytearray()",
            "        self.fd.seek(self._blp_offsets[0])",
            "",
            "        if self._blp_compression == 1:",
            "            # Uncompressed or DirectX compression",
            "",
            "            if self._blp_encoding == BLP_ENCODING_UNCOMPRESSED:",
            "                _data = BytesIO(self._safe_read(self._blp_lengths[0]))",
            "                while True:",
            "                    try:",
            "                        (offset,) = struct.unpack(\"<B\", _data.read(1))",
            "                    except struct.error:",
            "                        break",
            "                    b, g, r, a = palette[offset]",
            "                    data.extend((r, g, b))",
            "",
            "            elif self._blp_encoding == BLP_ENCODING_DXT:",
            "                if self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT1:",
            "                    linesize = (self.size[0] + 3) // 4 * 8",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt1(",
            "                            self._safe_read(linesize), alpha=bool(self._blp_alpha_depth)",
            "                        ):",
            "                            data += d",
            "",
            "                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT3:",
            "                    linesize = (self.size[0] + 3) // 4 * 16",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt3(self._safe_read(linesize)):",
            "                            data += d",
            "",
            "                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT5:",
            "                    linesize = (self.size[0] + 3) // 4 * 16",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt5(self._safe_read(linesize)):",
            "                            data += d",
            "                else:",
            "                    raise BLPFormatError(",
            "                        f\"Unsupported alpha encoding {repr(self._blp_alpha_encoding)}\"",
            "                    )",
            "            else:",
            "                raise BLPFormatError(f\"Unknown BLP encoding {repr(self._blp_encoding)}\")",
            "",
            "        else:",
            "            raise BLPFormatError(",
            "                f\"Unknown BLP compression {repr(self._blp_compression)}\"",
            "            )",
            "",
            "        self.set_as_raw(bytes(data))",
            "",
            "",
            "Image.register_open(",
            "    BlpImageFile.format, BlpImageFile, lambda p: p[:4] in (b\"BLP1\", b\"BLP2\")",
            ")",
            "Image.register_extension(BlpImageFile.format, \".blp\")",
            "",
            "Image.register_decoder(\"BLP1\", BLP1Decoder)",
            "Image.register_decoder(\"BLP2\", BLP2Decoder)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "293": [
                "_BLPBaseDecoder",
                "_read_palette"
            ],
            "300": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "302": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "303": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "304": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "305": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "307": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "311": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "312": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "314": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "315": [
                "_BLPBaseDecoder",
                "_read_blp_header"
            ],
            "327": [
                "BLP1Decoder",
                "_load"
            ],
            "349": [
                "BLP1Decoder",
                "_decode_jpeg_stream"
            ],
            "350": [
                "BLP1Decoder",
                "_decode_jpeg_stream"
            ],
            "351": [
                "BLP1Decoder",
                "_decode_jpeg_stream"
            ],
            "352": [
                "BLP1Decoder",
                "_decode_jpeg_stream"
            ],
            "373": [
                "BLP2Decoder",
                "_load"
            ],
            "387": [
                "BLP2Decoder",
                "_load"
            ],
            "394": [
                "BLP2Decoder",
                "_load"
            ],
            "400": [
                "BLP2Decoder",
                "_load"
            ]
        },
        "addLocation": [
            "src.PIL.BlpImagePlugin.BLP1Decoder._load",
            "src.PIL.BlpImagePlugin.BLP1Decoder._decode_jpeg_stream",
            "src.PIL.BlpImagePlugin._BLPBaseDecoder._read_palette",
            "src.PIL.BlpImagePlugin._BLPBaseDecoder.self",
            "src.PIL.BlpImagePlugin._BLPBaseDecoder._read_blp_header",
            "src.PIL.BlpImagePlugin.BLP2Decoder._load",
            "jinja2.nodes.Const.from_untrusted"
        ]
    }
}