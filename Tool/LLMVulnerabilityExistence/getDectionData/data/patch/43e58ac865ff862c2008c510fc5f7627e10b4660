{
    "qutebrowser/browser/qutescheme.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " import mimetypes"
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " import urllib"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " import collections"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+import base64"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+try:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    import secrets"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+except ImportError:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    # New in Python 3.6"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    secrets = None"
            },
            "10": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " import pkg_resources"
            },
            "12": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " from PyQt5.QtCore import QUrlQuery, QUrl"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+from PyQt5.QtNetwork import QNetworkReply"
            },
            "14": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " import qutebrowser"
            },
            "16": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " from qutebrowser.config import config, configdata, configexc, configdiff"
            },
            "17": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " pyeval_output = \":pyeval was never called\""
            },
            "19": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " spawn_output = \":spawn was never called\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+csrf_token = None"
            },
            "21": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " _HANDLERS = {}"
            },
            "24": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 458,
                "PatchRowcode": " @add_handler('settings')"
            },
            "25": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 459,
                "PatchRowcode": " def qute_settings(url):"
            },
            "26": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 460,
                "PatchRowcode": "     \"\"\"Handler for qute://settings. View/change qute configuration.\"\"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+    global csrf_token"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "     if url.path() == '/set':"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+        if url.password() != csrf_token:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+            message.error(\"Invalid CSRF token for qute://settings!\")"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+            raise QuteSchemeError(\"Invalid CSRF token!\","
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+                                  QNetworkReply.ContentAccessDenied)"
            },
            "34": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "         return _qute_settings_set(url)"
            },
            "35": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 469,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+    # Requests to qute://settings/set should only be allowed from"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+    # qute://settings. As an additional security precaution, we generate a CSRF"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+    # token to use here."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+    if secrets:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+        csrf_token = secrets.token_urlsafe()"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+    else:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+        # On Python < 3.6, from secrets.py"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+        token = base64.urlsafe_b64encode(os.urandom(32))"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+        csrf_token = token.rstrip(b'=').decode('ascii')"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "     src = jinja.render('settings.html', title='settings',"
            },
            "47": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "                        configdata=configdata,"
            },
            "48": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       confget=config.instance.get_str)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+                       confget=config.instance.get_str,"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 483,
                "PatchRowcode": "+                       csrf_token=csrf_token)"
            },
            "51": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 484,
                "PatchRowcode": "     return 'text/html', src"
            },
            "52": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 485,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": 486,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Backend-independent qute://* code.",
            "",
            "Module attributes:",
            "    pyeval_output: The output of the last :pyeval command.",
            "    _HANDLERS: The handlers registered via decorators.",
            "\"\"\"",
            "",
            "import html",
            "import json",
            "import os",
            "import time",
            "import textwrap",
            "import mimetypes",
            "import urllib",
            "import collections",
            "",
            "import pkg_resources",
            "from PyQt5.QtCore import QUrlQuery, QUrl",
            "",
            "import qutebrowser",
            "from qutebrowser.config import config, configdata, configexc, configdiff",
            "from qutebrowser.utils import (version, utils, jinja, log, message, docutils,",
            "                               objreg, urlutils)",
            "from qutebrowser.misc import objects",
            "from qutebrowser.qt import sip",
            "",
            "",
            "pyeval_output = \":pyeval was never called\"",
            "spawn_output = \":spawn was never called\"",
            "",
            "",
            "_HANDLERS = {}",
            "",
            "",
            "class NoHandlerFound(Exception):",
            "",
            "    \"\"\"Raised when no handler was found for the given URL.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class QuteSchemeOSError(Exception):",
            "",
            "    \"\"\"Called when there was an OSError inside a handler.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class QuteSchemeError(Exception):",
            "",
            "    \"\"\"Exception to signal that a handler should return an ErrorReply.",
            "",
            "    Attributes correspond to the arguments in",
            "    networkreply.ErrorNetworkReply.",
            "",
            "    Attributes:",
            "        errorstring: Error string to print.",
            "        error: Numerical error value.",
            "    \"\"\"",
            "",
            "    def __init__(self, errorstring, error):",
            "        self.errorstring = errorstring",
            "        self.error = error",
            "        super().__init__(errorstring)",
            "",
            "",
            "class Redirect(Exception):",
            "",
            "    \"\"\"Exception to signal a redirect should happen.",
            "",
            "    Attributes:",
            "        url: The URL to redirect to, as a QUrl.",
            "    \"\"\"",
            "",
            "    def __init__(self, url):",
            "        super().__init__(url.toDisplayString())",
            "        self.url = url",
            "",
            "",
            "class add_handler:  # noqa: N801,N806 pylint: disable=invalid-name",
            "",
            "    \"\"\"Decorator to register a qute://* URL handler.",
            "",
            "    Attributes:",
            "        _name: The 'foo' part of qute://foo",
            "        backend: Limit which backends the handler can run with.",
            "    \"\"\"",
            "",
            "    def __init__(self, name, backend=None):",
            "        self._name = name",
            "        self._backend = backend",
            "        self._function = None",
            "",
            "    def __call__(self, function):",
            "        self._function = function",
            "        _HANDLERS[self._name] = self.wrapper",
            "        return function",
            "",
            "    def wrapper(self, *args, **kwargs):",
            "        \"\"\"Call the underlying function.\"\"\"",
            "        if self._backend is not None and objects.backend != self._backend:",
            "            return self.wrong_backend_handler(*args, **kwargs)",
            "        else:",
            "            return self._function(*args, **kwargs)",
            "",
            "    def wrong_backend_handler(self, url):",
            "        \"\"\"Show an error page about using the invalid backend.\"\"\"",
            "        src = jinja.render('error.html',",
            "                           title=\"Error while opening qute://url\",",
            "                           url=url.toDisplayString(),",
            "                           error='{} is not available with this '",
            "                                 'backend'.format(url.toDisplayString()))",
            "        return 'text/html', src",
            "",
            "",
            "def data_for_url(url):",
            "    \"\"\"Get the data to show for the given URL.",
            "",
            "    Args:",
            "        url: The QUrl to show.",
            "",
            "    Return:",
            "        A (mimetype, data) tuple.",
            "    \"\"\"",
            "    norm_url = url.adjusted(QUrl.NormalizePathSegments |",
            "                            QUrl.StripTrailingSlash)",
            "    if norm_url != url:",
            "        raise Redirect(norm_url)",
            "",
            "    path = url.path()",
            "    host = url.host()",
            "    query = urlutils.query_string(url)",
            "    # A url like \"qute:foo\" is split as \"scheme:path\", not \"scheme:host\".",
            "    log.misc.debug(\"url: {}, path: {}, host {}\".format(",
            "        url.toDisplayString(), path, host))",
            "    if not path or not host:",
            "        new_url = QUrl()",
            "        new_url.setScheme('qute')",
            "        # When path is absent, e.g. qute://help (with no trailing slash)",
            "        if host:",
            "            new_url.setHost(host)",
            "        # When host is absent, e.g. qute:help",
            "        else:",
            "            new_url.setHost(path)",
            "",
            "        new_url.setPath('/')",
            "        if query:",
            "            new_url.setQuery(query)",
            "        if new_url.host():  # path was a valid host",
            "            raise Redirect(new_url)",
            "",
            "    try:",
            "        handler = _HANDLERS[host]",
            "    except KeyError:",
            "        raise NoHandlerFound(url)",
            "",
            "    try:",
            "        mimetype, data = handler(url)",
            "    except OSError as e:",
            "        # FIXME:qtwebengine how to handle this?",
            "        raise QuteSchemeOSError(e)",
            "    except QuteSchemeError:",
            "        raise",
            "",
            "    assert mimetype is not None, url",
            "    if mimetype == 'text/html' and isinstance(data, str):",
            "        # We let handlers return HTML as text",
            "        data = data.encode('utf-8', errors='xmlcharrefreplace')",
            "",
            "    return mimetype, data",
            "",
            "",
            "@add_handler('bookmarks')",
            "def qute_bookmarks(_url):",
            "    \"\"\"Handler for qute://bookmarks. Display all quickmarks / bookmarks.\"\"\"",
            "    bookmarks = sorted(objreg.get('bookmark-manager').marks.items(),",
            "                       key=lambda x: x[1])  # Sort by title",
            "    quickmarks = sorted(objreg.get('quickmark-manager').marks.items(),",
            "                        key=lambda x: x[0])  # Sort by name",
            "",
            "    src = jinja.render('bookmarks.html',",
            "                       title='Bookmarks',",
            "                       bookmarks=bookmarks,",
            "                       quickmarks=quickmarks)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('tabs')",
            "def qute_tabs(_url):",
            "    \"\"\"Handler for qute://tabs. Display information about all open tabs.\"\"\"",
            "    tabs = collections.defaultdict(list)",
            "    for win_id, window in objreg.window_registry.items():",
            "        if sip.isdeleted(window):",
            "            continue",
            "        tabbed_browser = objreg.get('tabbed-browser',",
            "                                    scope='window',",
            "                                    window=win_id)",
            "        for tab in tabbed_browser.widgets():",
            "            if tab.url() not in [QUrl(\"qute://tabs/\"), QUrl(\"qute://tabs\")]:",
            "                urlstr = tab.url().toDisplayString()",
            "                tabs[str(win_id)].append((tab.title(), urlstr))",
            "",
            "    src = jinja.render('tabs.html',",
            "                       title='Tabs',",
            "                       tab_list_by_window=tabs)",
            "    return 'text/html', src",
            "",
            "",
            "def history_data(start_time, offset=None):",
            "    \"\"\"Return history data.",
            "",
            "    Arguments:",
            "        start_time: select history starting from this timestamp.",
            "        offset: number of items to skip",
            "    \"\"\"",
            "    # history atimes are stored as ints, ensure start_time is not a float",
            "    start_time = int(start_time)",
            "    hist = objreg.get('web-history')",
            "    if offset is not None:",
            "        entries = hist.entries_before(start_time, limit=1000, offset=offset)",
            "    else:",
            "        # end is 24hrs earlier than start",
            "        end_time = start_time - 24*60*60",
            "        entries = hist.entries_between(end_time, start_time)",
            "",
            "    return [{\"url\": e.url,",
            "             \"title\": html.escape(e.title) or html.escape(e.url),",
            "             \"time\": e.atime} for e in entries]",
            "",
            "",
            "@add_handler('history')",
            "def qute_history(url):",
            "    \"\"\"Handler for qute://history. Display and serve history.\"\"\"",
            "    if url.path() == '/data':",
            "        try:",
            "            offset = QUrlQuery(url).queryItemValue(\"offset\")",
            "            offset = int(offset) if offset else None",
            "        except ValueError as e:",
            "            raise QuteSchemeError(\"Query parameter offset is invalid\", e)",
            "        # Use start_time in query or current time.",
            "        try:",
            "            start_time = QUrlQuery(url).queryItemValue(\"start_time\")",
            "            start_time = float(start_time) if start_time else time.time()",
            "        except ValueError as e:",
            "            raise QuteSchemeError(\"Query parameter start_time is invalid\", e)",
            "",
            "        return 'text/html', json.dumps(history_data(start_time, offset))",
            "    else:",
            "        return 'text/html', jinja.render(",
            "            'history.html',",
            "            title='History',",
            "            gap_interval=config.val.history_gap_interval",
            "        )",
            "",
            "",
            "@add_handler('javascript')",
            "def qute_javascript(url):",
            "    \"\"\"Handler for qute://javascript.",
            "",
            "    Return content of file given as query parameter.",
            "    \"\"\"",
            "    path = url.path()",
            "    if path:",
            "        path = \"javascript\" + os.sep.join(path.split('/'))",
            "        return 'text/html', utils.read_file(path, binary=False)",
            "    else:",
            "        raise QuteSchemeError(\"No file specified\", ValueError())",
            "",
            "",
            "@add_handler('pyeval')",
            "def qute_pyeval(_url):",
            "    \"\"\"Handler for qute://pyeval.\"\"\"",
            "    src = jinja.render('pre.html', title='pyeval', content=pyeval_output)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('spawn-output')",
            "def qute_spawn_output(_url):",
            "    \"\"\"Handler for qute://spawn-output.\"\"\"",
            "    src = jinja.render('pre.html', title='spawn output', content=spawn_output)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('version')",
            "@add_handler('verizon')",
            "def qute_version(_url):",
            "    \"\"\"Handler for qute://version.\"\"\"",
            "    src = jinja.render('version.html', title='Version info',",
            "                       version=version.version(),",
            "                       copyright=qutebrowser.__copyright__)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('plainlog')",
            "def qute_plainlog(url):",
            "    \"\"\"Handler for qute://plainlog.",
            "",
            "    An optional query parameter specifies the minimum log level to print.",
            "    For example, qute://log?level=warning prints warnings and errors.",
            "    Level can be one of: vdebug, debug, info, warning, error, critical.",
            "    \"\"\"",
            "    if log.ram_handler is None:",
            "        text = \"Log output was disabled.\"",
            "    else:",
            "        level = QUrlQuery(url).queryItemValue('level')",
            "        if not level:",
            "            level = 'vdebug'",
            "        text = log.ram_handler.dump_log(html=False, level=level)",
            "    src = jinja.render('pre.html', title='log', content=text)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('log')",
            "def qute_log(url):",
            "    \"\"\"Handler for qute://log.",
            "",
            "    An optional query parameter specifies the minimum log level to print.",
            "    For example, qute://log?level=warning prints warnings and errors.",
            "    Level can be one of: vdebug, debug, info, warning, error, critical.",
            "    \"\"\"",
            "    if log.ram_handler is None:",
            "        html_log = None",
            "    else:",
            "        level = QUrlQuery(url).queryItemValue('level')",
            "        if not level:",
            "            level = 'vdebug'",
            "        html_log = log.ram_handler.dump_log(html=True, level=level)",
            "",
            "    src = jinja.render('log.html', title='log', content=html_log)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('gpl')",
            "def qute_gpl(_url):",
            "    \"\"\"Handler for qute://gpl. Return HTML content as string.\"\"\"",
            "    return 'text/html', utils.read_file('html/license.html')",
            "",
            "",
            "@add_handler('help')",
            "def qute_help(url):",
            "    \"\"\"Handler for qute://help.\"\"\"",
            "    urlpath = url.path()",
            "    if not urlpath or urlpath == '/':",
            "        urlpath = 'index.html'",
            "    else:",
            "        urlpath = urlpath.lstrip('/')",
            "    if not docutils.docs_up_to_date(urlpath):",
            "        message.error(\"Your documentation is outdated! Please re-run \"",
            "                      \"scripts/asciidoc2html.py.\")",
            "",
            "    path = 'html/doc/{}'.format(urlpath)",
            "    if not urlpath.endswith('.html'):",
            "        try:",
            "            bdata = utils.read_file(path, binary=True)",
            "        except OSError as e:",
            "            raise QuteSchemeOSError(e)",
            "        mimetype, _encoding = mimetypes.guess_type(urlpath)",
            "        assert mimetype is not None, url",
            "        return mimetype, bdata",
            "",
            "    try:",
            "        data = utils.read_file(path)",
            "    except OSError:",
            "        # No .html around, let's see if we find the asciidoc",
            "        asciidoc_path = path.replace('.html', '.asciidoc')",
            "        if asciidoc_path.startswith('html/doc/'):",
            "            asciidoc_path = asciidoc_path.replace('html/doc/', '../doc/help/')",
            "",
            "        try:",
            "            asciidoc = utils.read_file(asciidoc_path)",
            "        except OSError:",
            "            asciidoc = None",
            "",
            "        if asciidoc is None:",
            "            raise",
            "",
            "        preamble = textwrap.dedent(\"\"\"",
            "            There was an error loading the documentation!",
            "",
            "            This most likely means the documentation was not generated",
            "            properly. If you are running qutebrowser from the git repository,",
            "            please (re)run scripts/asciidoc2html.py and reload this page.",
            "",
            "            If you're running a released version this is a bug, please use",
            "            :report to report it.",
            "",
            "            Falling back to the plaintext version.",
            "",
            "            ---------------------------------------------------------------",
            "",
            "",
            "        \"\"\")",
            "        return 'text/plain', (preamble + asciidoc).encode('utf-8')",
            "    else:",
            "        return 'text/html', data",
            "",
            "",
            "@add_handler('backend-warning')",
            "def qute_backend_warning(_url):",
            "    \"\"\"Handler for qute://backend-warning.\"\"\"",
            "    src = jinja.render('backend-warning.html',",
            "                       distribution=version.distribution(),",
            "                       Distribution=version.Distribution,",
            "                       version=pkg_resources.parse_version,",
            "                       title=\"Legacy backend warning\")",
            "    return 'text/html', src",
            "",
            "",
            "def _qute_settings_set(url):",
            "    \"\"\"Handler for qute://settings/set.\"\"\"",
            "    query = QUrlQuery(url)",
            "    option = query.queryItemValue('option', QUrl.FullyDecoded)",
            "    value = query.queryItemValue('value', QUrl.FullyDecoded)",
            "",
            "    # https://github.com/qutebrowser/qutebrowser/issues/727",
            "    if option == 'content.javascript.enabled' and value == 'false':",
            "        msg = (\"Refusing to disable javascript via qute://settings \"",
            "               \"as it needs javascript support.\")",
            "        message.error(msg)",
            "        return 'text/html', b'error: ' + msg.encode('utf-8')",
            "",
            "    try:",
            "        config.instance.set_str(option, value, save_yaml=True)",
            "        return 'text/html', b'ok'",
            "    except configexc.Error as e:",
            "        message.error(str(e))",
            "        return 'text/html', b'error: ' + str(e).encode('utf-8')",
            "",
            "",
            "@add_handler('settings')",
            "def qute_settings(url):",
            "    \"\"\"Handler for qute://settings. View/change qute configuration.\"\"\"",
            "    if url.path() == '/set':",
            "        return _qute_settings_set(url)",
            "",
            "    src = jinja.render('settings.html', title='settings',",
            "                       configdata=configdata,",
            "                       confget=config.instance.get_str)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('bindings')",
            "def qute_bindings(_url):",
            "    \"\"\"Handler for qute://bindings. View keybindings.\"\"\"",
            "    bindings = {}",
            "    defaults = config.val.bindings.default",
            "    modes = set(defaults.keys()).union(config.val.bindings.commands)",
            "    modes.remove('normal')",
            "    modes = ['normal'] + sorted(list(modes))",
            "    for mode in modes:",
            "        bindings[mode] = config.key_instance.get_bindings_for(mode)",
            "",
            "    src = jinja.render('bindings.html', title='Bindings',",
            "                       bindings=bindings)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('back')",
            "def qute_back(url):",
            "    \"\"\"Handler for qute://back.",
            "",
            "    Simple page to free ram / lazy load a site, goes back on focusing the tab.",
            "    \"\"\"",
            "    src = jinja.render(",
            "        'back.html',",
            "        title='Suspended: ' + urllib.parse.unquote(url.fragment()))",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('configdiff')",
            "def qute_configdiff(url):",
            "    \"\"\"Handler for qute://configdiff.\"\"\"",
            "    if url.path() == '/old':",
            "        try:",
            "            return 'text/html', configdiff.get_diff()",
            "        except OSError as e:",
            "            error = (b'Failed to read old config: ' +",
            "                     str(e.strerror).encode('utf-8'))",
            "            return 'text/plain', error",
            "    else:",
            "        data = config.instance.dump_userconfig().encode('utf-8')",
            "        return 'text/plain', data",
            "",
            "",
            "@add_handler('pastebin-version')",
            "def qute_pastebin_version(_url):",
            "    \"\"\"Handler that pastebins the version string.\"\"\"",
            "    version.pastebin_version()",
            "    return 'text/plain', b'Paste called.'"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Backend-independent qute://* code.",
            "",
            "Module attributes:",
            "    pyeval_output: The output of the last :pyeval command.",
            "    _HANDLERS: The handlers registered via decorators.",
            "\"\"\"",
            "",
            "import html",
            "import json",
            "import os",
            "import time",
            "import textwrap",
            "import mimetypes",
            "import urllib",
            "import collections",
            "import base64",
            "",
            "try:",
            "    import secrets",
            "except ImportError:",
            "    # New in Python 3.6",
            "    secrets = None",
            "",
            "import pkg_resources",
            "from PyQt5.QtCore import QUrlQuery, QUrl",
            "from PyQt5.QtNetwork import QNetworkReply",
            "",
            "import qutebrowser",
            "from qutebrowser.config import config, configdata, configexc, configdiff",
            "from qutebrowser.utils import (version, utils, jinja, log, message, docutils,",
            "                               objreg, urlutils)",
            "from qutebrowser.misc import objects",
            "from qutebrowser.qt import sip",
            "",
            "",
            "pyeval_output = \":pyeval was never called\"",
            "spawn_output = \":spawn was never called\"",
            "csrf_token = None",
            "",
            "",
            "_HANDLERS = {}",
            "",
            "",
            "class NoHandlerFound(Exception):",
            "",
            "    \"\"\"Raised when no handler was found for the given URL.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class QuteSchemeOSError(Exception):",
            "",
            "    \"\"\"Called when there was an OSError inside a handler.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class QuteSchemeError(Exception):",
            "",
            "    \"\"\"Exception to signal that a handler should return an ErrorReply.",
            "",
            "    Attributes correspond to the arguments in",
            "    networkreply.ErrorNetworkReply.",
            "",
            "    Attributes:",
            "        errorstring: Error string to print.",
            "        error: Numerical error value.",
            "    \"\"\"",
            "",
            "    def __init__(self, errorstring, error):",
            "        self.errorstring = errorstring",
            "        self.error = error",
            "        super().__init__(errorstring)",
            "",
            "",
            "class Redirect(Exception):",
            "",
            "    \"\"\"Exception to signal a redirect should happen.",
            "",
            "    Attributes:",
            "        url: The URL to redirect to, as a QUrl.",
            "    \"\"\"",
            "",
            "    def __init__(self, url):",
            "        super().__init__(url.toDisplayString())",
            "        self.url = url",
            "",
            "",
            "class add_handler:  # noqa: N801,N806 pylint: disable=invalid-name",
            "",
            "    \"\"\"Decorator to register a qute://* URL handler.",
            "",
            "    Attributes:",
            "        _name: The 'foo' part of qute://foo",
            "        backend: Limit which backends the handler can run with.",
            "    \"\"\"",
            "",
            "    def __init__(self, name, backend=None):",
            "        self._name = name",
            "        self._backend = backend",
            "        self._function = None",
            "",
            "    def __call__(self, function):",
            "        self._function = function",
            "        _HANDLERS[self._name] = self.wrapper",
            "        return function",
            "",
            "    def wrapper(self, *args, **kwargs):",
            "        \"\"\"Call the underlying function.\"\"\"",
            "        if self._backend is not None and objects.backend != self._backend:",
            "            return self.wrong_backend_handler(*args, **kwargs)",
            "        else:",
            "            return self._function(*args, **kwargs)",
            "",
            "    def wrong_backend_handler(self, url):",
            "        \"\"\"Show an error page about using the invalid backend.\"\"\"",
            "        src = jinja.render('error.html',",
            "                           title=\"Error while opening qute://url\",",
            "                           url=url.toDisplayString(),",
            "                           error='{} is not available with this '",
            "                                 'backend'.format(url.toDisplayString()))",
            "        return 'text/html', src",
            "",
            "",
            "def data_for_url(url):",
            "    \"\"\"Get the data to show for the given URL.",
            "",
            "    Args:",
            "        url: The QUrl to show.",
            "",
            "    Return:",
            "        A (mimetype, data) tuple.",
            "    \"\"\"",
            "    norm_url = url.adjusted(QUrl.NormalizePathSegments |",
            "                            QUrl.StripTrailingSlash)",
            "    if norm_url != url:",
            "        raise Redirect(norm_url)",
            "",
            "    path = url.path()",
            "    host = url.host()",
            "    query = urlutils.query_string(url)",
            "    # A url like \"qute:foo\" is split as \"scheme:path\", not \"scheme:host\".",
            "    log.misc.debug(\"url: {}, path: {}, host {}\".format(",
            "        url.toDisplayString(), path, host))",
            "    if not path or not host:",
            "        new_url = QUrl()",
            "        new_url.setScheme('qute')",
            "        # When path is absent, e.g. qute://help (with no trailing slash)",
            "        if host:",
            "            new_url.setHost(host)",
            "        # When host is absent, e.g. qute:help",
            "        else:",
            "            new_url.setHost(path)",
            "",
            "        new_url.setPath('/')",
            "        if query:",
            "            new_url.setQuery(query)",
            "        if new_url.host():  # path was a valid host",
            "            raise Redirect(new_url)",
            "",
            "    try:",
            "        handler = _HANDLERS[host]",
            "    except KeyError:",
            "        raise NoHandlerFound(url)",
            "",
            "    try:",
            "        mimetype, data = handler(url)",
            "    except OSError as e:",
            "        # FIXME:qtwebengine how to handle this?",
            "        raise QuteSchemeOSError(e)",
            "    except QuteSchemeError:",
            "        raise",
            "",
            "    assert mimetype is not None, url",
            "    if mimetype == 'text/html' and isinstance(data, str):",
            "        # We let handlers return HTML as text",
            "        data = data.encode('utf-8', errors='xmlcharrefreplace')",
            "",
            "    return mimetype, data",
            "",
            "",
            "@add_handler('bookmarks')",
            "def qute_bookmarks(_url):",
            "    \"\"\"Handler for qute://bookmarks. Display all quickmarks / bookmarks.\"\"\"",
            "    bookmarks = sorted(objreg.get('bookmark-manager').marks.items(),",
            "                       key=lambda x: x[1])  # Sort by title",
            "    quickmarks = sorted(objreg.get('quickmark-manager').marks.items(),",
            "                        key=lambda x: x[0])  # Sort by name",
            "",
            "    src = jinja.render('bookmarks.html',",
            "                       title='Bookmarks',",
            "                       bookmarks=bookmarks,",
            "                       quickmarks=quickmarks)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('tabs')",
            "def qute_tabs(_url):",
            "    \"\"\"Handler for qute://tabs. Display information about all open tabs.\"\"\"",
            "    tabs = collections.defaultdict(list)",
            "    for win_id, window in objreg.window_registry.items():",
            "        if sip.isdeleted(window):",
            "            continue",
            "        tabbed_browser = objreg.get('tabbed-browser',",
            "                                    scope='window',",
            "                                    window=win_id)",
            "        for tab in tabbed_browser.widgets():",
            "            if tab.url() not in [QUrl(\"qute://tabs/\"), QUrl(\"qute://tabs\")]:",
            "                urlstr = tab.url().toDisplayString()",
            "                tabs[str(win_id)].append((tab.title(), urlstr))",
            "",
            "    src = jinja.render('tabs.html',",
            "                       title='Tabs',",
            "                       tab_list_by_window=tabs)",
            "    return 'text/html', src",
            "",
            "",
            "def history_data(start_time, offset=None):",
            "    \"\"\"Return history data.",
            "",
            "    Arguments:",
            "        start_time: select history starting from this timestamp.",
            "        offset: number of items to skip",
            "    \"\"\"",
            "    # history atimes are stored as ints, ensure start_time is not a float",
            "    start_time = int(start_time)",
            "    hist = objreg.get('web-history')",
            "    if offset is not None:",
            "        entries = hist.entries_before(start_time, limit=1000, offset=offset)",
            "    else:",
            "        # end is 24hrs earlier than start",
            "        end_time = start_time - 24*60*60",
            "        entries = hist.entries_between(end_time, start_time)",
            "",
            "    return [{\"url\": e.url,",
            "             \"title\": html.escape(e.title) or html.escape(e.url),",
            "             \"time\": e.atime} for e in entries]",
            "",
            "",
            "@add_handler('history')",
            "def qute_history(url):",
            "    \"\"\"Handler for qute://history. Display and serve history.\"\"\"",
            "    if url.path() == '/data':",
            "        try:",
            "            offset = QUrlQuery(url).queryItemValue(\"offset\")",
            "            offset = int(offset) if offset else None",
            "        except ValueError as e:",
            "            raise QuteSchemeError(\"Query parameter offset is invalid\", e)",
            "        # Use start_time in query or current time.",
            "        try:",
            "            start_time = QUrlQuery(url).queryItemValue(\"start_time\")",
            "            start_time = float(start_time) if start_time else time.time()",
            "        except ValueError as e:",
            "            raise QuteSchemeError(\"Query parameter start_time is invalid\", e)",
            "",
            "        return 'text/html', json.dumps(history_data(start_time, offset))",
            "    else:",
            "        return 'text/html', jinja.render(",
            "            'history.html',",
            "            title='History',",
            "            gap_interval=config.val.history_gap_interval",
            "        )",
            "",
            "",
            "@add_handler('javascript')",
            "def qute_javascript(url):",
            "    \"\"\"Handler for qute://javascript.",
            "",
            "    Return content of file given as query parameter.",
            "    \"\"\"",
            "    path = url.path()",
            "    if path:",
            "        path = \"javascript\" + os.sep.join(path.split('/'))",
            "        return 'text/html', utils.read_file(path, binary=False)",
            "    else:",
            "        raise QuteSchemeError(\"No file specified\", ValueError())",
            "",
            "",
            "@add_handler('pyeval')",
            "def qute_pyeval(_url):",
            "    \"\"\"Handler for qute://pyeval.\"\"\"",
            "    src = jinja.render('pre.html', title='pyeval', content=pyeval_output)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('spawn-output')",
            "def qute_spawn_output(_url):",
            "    \"\"\"Handler for qute://spawn-output.\"\"\"",
            "    src = jinja.render('pre.html', title='spawn output', content=spawn_output)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('version')",
            "@add_handler('verizon')",
            "def qute_version(_url):",
            "    \"\"\"Handler for qute://version.\"\"\"",
            "    src = jinja.render('version.html', title='Version info',",
            "                       version=version.version(),",
            "                       copyright=qutebrowser.__copyright__)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('plainlog')",
            "def qute_plainlog(url):",
            "    \"\"\"Handler for qute://plainlog.",
            "",
            "    An optional query parameter specifies the minimum log level to print.",
            "    For example, qute://log?level=warning prints warnings and errors.",
            "    Level can be one of: vdebug, debug, info, warning, error, critical.",
            "    \"\"\"",
            "    if log.ram_handler is None:",
            "        text = \"Log output was disabled.\"",
            "    else:",
            "        level = QUrlQuery(url).queryItemValue('level')",
            "        if not level:",
            "            level = 'vdebug'",
            "        text = log.ram_handler.dump_log(html=False, level=level)",
            "    src = jinja.render('pre.html', title='log', content=text)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('log')",
            "def qute_log(url):",
            "    \"\"\"Handler for qute://log.",
            "",
            "    An optional query parameter specifies the minimum log level to print.",
            "    For example, qute://log?level=warning prints warnings and errors.",
            "    Level can be one of: vdebug, debug, info, warning, error, critical.",
            "    \"\"\"",
            "    if log.ram_handler is None:",
            "        html_log = None",
            "    else:",
            "        level = QUrlQuery(url).queryItemValue('level')",
            "        if not level:",
            "            level = 'vdebug'",
            "        html_log = log.ram_handler.dump_log(html=True, level=level)",
            "",
            "    src = jinja.render('log.html', title='log', content=html_log)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('gpl')",
            "def qute_gpl(_url):",
            "    \"\"\"Handler for qute://gpl. Return HTML content as string.\"\"\"",
            "    return 'text/html', utils.read_file('html/license.html')",
            "",
            "",
            "@add_handler('help')",
            "def qute_help(url):",
            "    \"\"\"Handler for qute://help.\"\"\"",
            "    urlpath = url.path()",
            "    if not urlpath or urlpath == '/':",
            "        urlpath = 'index.html'",
            "    else:",
            "        urlpath = urlpath.lstrip('/')",
            "    if not docutils.docs_up_to_date(urlpath):",
            "        message.error(\"Your documentation is outdated! Please re-run \"",
            "                      \"scripts/asciidoc2html.py.\")",
            "",
            "    path = 'html/doc/{}'.format(urlpath)",
            "    if not urlpath.endswith('.html'):",
            "        try:",
            "            bdata = utils.read_file(path, binary=True)",
            "        except OSError as e:",
            "            raise QuteSchemeOSError(e)",
            "        mimetype, _encoding = mimetypes.guess_type(urlpath)",
            "        assert mimetype is not None, url",
            "        return mimetype, bdata",
            "",
            "    try:",
            "        data = utils.read_file(path)",
            "    except OSError:",
            "        # No .html around, let's see if we find the asciidoc",
            "        asciidoc_path = path.replace('.html', '.asciidoc')",
            "        if asciidoc_path.startswith('html/doc/'):",
            "            asciidoc_path = asciidoc_path.replace('html/doc/', '../doc/help/')",
            "",
            "        try:",
            "            asciidoc = utils.read_file(asciidoc_path)",
            "        except OSError:",
            "            asciidoc = None",
            "",
            "        if asciidoc is None:",
            "            raise",
            "",
            "        preamble = textwrap.dedent(\"\"\"",
            "            There was an error loading the documentation!",
            "",
            "            This most likely means the documentation was not generated",
            "            properly. If you are running qutebrowser from the git repository,",
            "            please (re)run scripts/asciidoc2html.py and reload this page.",
            "",
            "            If you're running a released version this is a bug, please use",
            "            :report to report it.",
            "",
            "            Falling back to the plaintext version.",
            "",
            "            ---------------------------------------------------------------",
            "",
            "",
            "        \"\"\")",
            "        return 'text/plain', (preamble + asciidoc).encode('utf-8')",
            "    else:",
            "        return 'text/html', data",
            "",
            "",
            "@add_handler('backend-warning')",
            "def qute_backend_warning(_url):",
            "    \"\"\"Handler for qute://backend-warning.\"\"\"",
            "    src = jinja.render('backend-warning.html',",
            "                       distribution=version.distribution(),",
            "                       Distribution=version.Distribution,",
            "                       version=pkg_resources.parse_version,",
            "                       title=\"Legacy backend warning\")",
            "    return 'text/html', src",
            "",
            "",
            "def _qute_settings_set(url):",
            "    \"\"\"Handler for qute://settings/set.\"\"\"",
            "    query = QUrlQuery(url)",
            "    option = query.queryItemValue('option', QUrl.FullyDecoded)",
            "    value = query.queryItemValue('value', QUrl.FullyDecoded)",
            "",
            "    # https://github.com/qutebrowser/qutebrowser/issues/727",
            "    if option == 'content.javascript.enabled' and value == 'false':",
            "        msg = (\"Refusing to disable javascript via qute://settings \"",
            "               \"as it needs javascript support.\")",
            "        message.error(msg)",
            "        return 'text/html', b'error: ' + msg.encode('utf-8')",
            "",
            "    try:",
            "        config.instance.set_str(option, value, save_yaml=True)",
            "        return 'text/html', b'ok'",
            "    except configexc.Error as e:",
            "        message.error(str(e))",
            "        return 'text/html', b'error: ' + str(e).encode('utf-8')",
            "",
            "",
            "@add_handler('settings')",
            "def qute_settings(url):",
            "    \"\"\"Handler for qute://settings. View/change qute configuration.\"\"\"",
            "    global csrf_token",
            "",
            "    if url.path() == '/set':",
            "        if url.password() != csrf_token:",
            "            message.error(\"Invalid CSRF token for qute://settings!\")",
            "            raise QuteSchemeError(\"Invalid CSRF token!\",",
            "                                  QNetworkReply.ContentAccessDenied)",
            "        return _qute_settings_set(url)",
            "",
            "    # Requests to qute://settings/set should only be allowed from",
            "    # qute://settings. As an additional security precaution, we generate a CSRF",
            "    # token to use here.",
            "    if secrets:",
            "        csrf_token = secrets.token_urlsafe()",
            "    else:",
            "        # On Python < 3.6, from secrets.py",
            "        token = base64.urlsafe_b64encode(os.urandom(32))",
            "        csrf_token = token.rstrip(b'=').decode('ascii')",
            "",
            "    src = jinja.render('settings.html', title='settings',",
            "                       configdata=configdata,",
            "                       confget=config.instance.get_str,",
            "                       csrf_token=csrf_token)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('bindings')",
            "def qute_bindings(_url):",
            "    \"\"\"Handler for qute://bindings. View keybindings.\"\"\"",
            "    bindings = {}",
            "    defaults = config.val.bindings.default",
            "    modes = set(defaults.keys()).union(config.val.bindings.commands)",
            "    modes.remove('normal')",
            "    modes = ['normal'] + sorted(list(modes))",
            "    for mode in modes:",
            "        bindings[mode] = config.key_instance.get_bindings_for(mode)",
            "",
            "    src = jinja.render('bindings.html', title='Bindings',",
            "                       bindings=bindings)",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('back')",
            "def qute_back(url):",
            "    \"\"\"Handler for qute://back.",
            "",
            "    Simple page to free ram / lazy load a site, goes back on focusing the tab.",
            "    \"\"\"",
            "    src = jinja.render(",
            "        'back.html',",
            "        title='Suspended: ' + urllib.parse.unquote(url.fragment()))",
            "    return 'text/html', src",
            "",
            "",
            "@add_handler('configdiff')",
            "def qute_configdiff(url):",
            "    \"\"\"Handler for qute://configdiff.\"\"\"",
            "    if url.path() == '/old':",
            "        try:",
            "            return 'text/html', configdiff.get_diff()",
            "        except OSError as e:",
            "            error = (b'Failed to read old config: ' +",
            "                     str(e.strerror).encode('utf-8'))",
            "            return 'text/plain', error",
            "    else:",
            "        data = config.instance.dump_userconfig().encode('utf-8')",
            "        return 'text/plain', data",
            "",
            "",
            "@add_handler('pastebin-version')",
            "def qute_pastebin_version(_url):",
            "    \"\"\"Handler that pastebins the version string.\"\"\"",
            "    version.pastebin_version()",
            "    return 'text/plain', b'Paste called.'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "457": [
                "qute_settings"
            ]
        },
        "addLocation": [
            "pypdf.generic._data_structures",
            "qutebrowser.browser.qutescheme.add_handler.__init__.name"
        ]
    },
    "qutebrowser/browser/webengine/interceptor.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " \"\"\"A request interceptor taking care of adblocking and custom headers.\"\"\""
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from PyQt5.QtCore import QUrl"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from PyQt5.QtWebEngineCore import (QWebEngineUrlRequestInterceptor,"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "                                    QWebEngineUrlRequestInfo)"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "                                   resource_type, navigation_type))"
            },
            "8": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         url = info.requestUrl()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        firstparty = info.firstPartyUrl()"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        if ((url.scheme(), url.host(), url.path()) =="
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                ('qute', 'settings', '/set')):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+            if (firstparty != QUrl('qute://settings/') or"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                    info.resourceType() !="
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                    QWebEngineUrlRequestInfo.ResourceTypeXhr):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                log.webview.warning(\"Blocking malicious request from {} to {}\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+                                    .format(firstparty.toDisplayString(),"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+                                            url.toDisplayString()))"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+                info.block(True)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+                return"
            },
            "22": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         # FIXME:qtwebengine only block ads for NavigationTypeOther?"
            },
            "24": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         if self._host_blocker.is_blocked(url):"
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"A request interceptor taking care of adblocking and custom headers.\"\"\"",
            "",
            "from PyQt5.QtWebEngineCore import (QWebEngineUrlRequestInterceptor,",
            "                                   QWebEngineUrlRequestInfo)",
            "",
            "from qutebrowser.config import config",
            "from qutebrowser.browser import shared",
            "from qutebrowser.utils import utils, log, debug",
            "",
            "",
            "class RequestInterceptor(QWebEngineUrlRequestInterceptor):",
            "",
            "    \"\"\"Handle ad blocking and custom headers.\"\"\"",
            "",
            "    def __init__(self, host_blocker, args, parent=None):",
            "        super().__init__(parent)",
            "        self._host_blocker = host_blocker",
            "        self._args = args",
            "",
            "    def install(self, profile):",
            "        \"\"\"Install the interceptor on the given QWebEngineProfile.\"\"\"",
            "        profile.setRequestInterceptor(self)",
            "",
            "    # Gets called in the IO thread -> showing crash window will fail",
            "    @utils.prevent_exceptions(None)",
            "    def interceptRequest(self, info):",
            "        \"\"\"Handle the given request.",
            "",
            "        Reimplementing this virtual function and setting the interceptor on a",
            "        profile makes it possible to intercept URL requests. This function is",
            "        executed on the IO thread, and therefore running long tasks here will",
            "        block networking.",
            "",
            "        info contains the information about the URL request and will track",
            "        internally whether its members have been altered.",
            "",
            "        Args:",
            "            info: QWebEngineUrlRequestInfo &info",
            "        \"\"\"",
            "        if 'log-requests' in self._args.debug_flags:",
            "            resource_type = debug.qenum_key(QWebEngineUrlRequestInfo,",
            "                                            info.resourceType())",
            "            navigation_type = debug.qenum_key(QWebEngineUrlRequestInfo,",
            "                                              info.navigationType())",
            "            log.webview.debug(\"{} {}, first-party {}, resource {}, \"",
            "                              \"navigation {}\".format(",
            "                                  bytes(info.requestMethod()).decode('ascii'),",
            "                                  info.requestUrl().toDisplayString(),",
            "                                  info.firstPartyUrl().toDisplayString(),",
            "                                  resource_type, navigation_type))",
            "",
            "        url = info.requestUrl()",
            "",
            "        # FIXME:qtwebengine only block ads for NavigationTypeOther?",
            "        if self._host_blocker.is_blocked(url):",
            "            log.webview.info(\"Request to {} blocked by host blocker.\".format(",
            "                url.host()))",
            "            info.block(True)",
            "",
            "        for header, value in shared.custom_headers(url=url):",
            "            info.setHttpHeader(header, value)",
            "",
            "        user_agent = config.instance.get('content.headers.user_agent', url=url)",
            "        if user_agent is not None:",
            "            info.setHttpHeader(b'User-Agent', user_agent.encode('ascii'))"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"A request interceptor taking care of adblocking and custom headers.\"\"\"",
            "",
            "from PyQt5.QtCore import QUrl",
            "from PyQt5.QtWebEngineCore import (QWebEngineUrlRequestInterceptor,",
            "                                   QWebEngineUrlRequestInfo)",
            "",
            "from qutebrowser.config import config",
            "from qutebrowser.browser import shared",
            "from qutebrowser.utils import utils, log, debug",
            "",
            "",
            "class RequestInterceptor(QWebEngineUrlRequestInterceptor):",
            "",
            "    \"\"\"Handle ad blocking and custom headers.\"\"\"",
            "",
            "    def __init__(self, host_blocker, args, parent=None):",
            "        super().__init__(parent)",
            "        self._host_blocker = host_blocker",
            "        self._args = args",
            "",
            "    def install(self, profile):",
            "        \"\"\"Install the interceptor on the given QWebEngineProfile.\"\"\"",
            "        profile.setRequestInterceptor(self)",
            "",
            "    # Gets called in the IO thread -> showing crash window will fail",
            "    @utils.prevent_exceptions(None)",
            "    def interceptRequest(self, info):",
            "        \"\"\"Handle the given request.",
            "",
            "        Reimplementing this virtual function and setting the interceptor on a",
            "        profile makes it possible to intercept URL requests. This function is",
            "        executed on the IO thread, and therefore running long tasks here will",
            "        block networking.",
            "",
            "        info contains the information about the URL request and will track",
            "        internally whether its members have been altered.",
            "",
            "        Args:",
            "            info: QWebEngineUrlRequestInfo &info",
            "        \"\"\"",
            "        if 'log-requests' in self._args.debug_flags:",
            "            resource_type = debug.qenum_key(QWebEngineUrlRequestInfo,",
            "                                            info.resourceType())",
            "            navigation_type = debug.qenum_key(QWebEngineUrlRequestInfo,",
            "                                              info.navigationType())",
            "            log.webview.debug(\"{} {}, first-party {}, resource {}, \"",
            "                              \"navigation {}\".format(",
            "                                  bytes(info.requestMethod()).decode('ascii'),",
            "                                  info.requestUrl().toDisplayString(),",
            "                                  info.firstPartyUrl().toDisplayString(),",
            "                                  resource_type, navigation_type))",
            "",
            "        url = info.requestUrl()",
            "        firstparty = info.firstPartyUrl()",
            "",
            "        if ((url.scheme(), url.host(), url.path()) ==",
            "                ('qute', 'settings', '/set')):",
            "            if (firstparty != QUrl('qute://settings/') or",
            "                    info.resourceType() !=",
            "                    QWebEngineUrlRequestInfo.ResourceTypeXhr):",
            "                log.webview.warning(\"Blocking malicious request from {} to {}\"",
            "                                    .format(firstparty.toDisplayString(),",
            "                                            url.toDisplayString()))",
            "                info.block(True)",
            "                return",
            "",
            "        # FIXME:qtwebengine only block ads for NavigationTypeOther?",
            "        if self._host_blocker.is_blocked(url):",
            "            log.webview.info(\"Request to {} blocked by host blocker.\".format(",
            "                url.host()))",
            "            info.block(True)",
            "",
            "        for header, value in shared.custom_headers(url=url):",
            "            info.setHttpHeader(header, value)",
            "",
            "        user_agent = config.instance.get('content.headers.user_agent', url=url)",
            "        if user_agent is not None:",
            "            info.setHttpHeader(b'User-Agent', user_agent.encode('ascii'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "pypdf.generic._data_structures"
        ]
    },
    "qutebrowser/browser/webengine/webenginequtescheme.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             job.fail(QWebEngineUrlRequestJob.UrlInvalid)"
            },
            "1": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "             return"
            },
            "2": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert job.requestMethod() == b'GET'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        # Only the browser itself or qute:// pages should access any of those"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        # URLs."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        # The request interceptor further locks down qute://settings/set."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        try:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            initiator = job.initiator()"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        except AttributeError:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            # Added in Qt 5.11"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            pass"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        else:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            if initiator.isValid() and initiator.scheme() != 'qute':"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                log.misc.warning(\"Blocking malicious request from {} to {}\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                                 .format(initiator.toDisplayString(),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                                         url.toDisplayString()))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                job.fail(QWebEngineUrlRequestJob.RequestDenied)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                return"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        if job.requestMethod() != b'GET':"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+            job.fail(QWebEngineUrlRequestJob.RequestDenied)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+            return"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         assert url.scheme() == 'qute'"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         log.misc.debug(\"Got request for {}\".format(url.toDisplayString()))"
            },
            "27": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         try:"
            },
            "28": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             mimetype, data = qutescheme.data_for_url(url)"
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"QtWebEngine specific qute://* handlers and glue code.\"\"\"",
            "",
            "from PyQt5.QtCore import QBuffer, QIODevice",
            "from PyQt5.QtWebEngineCore import (QWebEngineUrlSchemeHandler,",
            "                                   QWebEngineUrlRequestJob)",
            "",
            "from qutebrowser.browser import qutescheme",
            "from qutebrowser.utils import log, qtutils",
            "",
            "",
            "class QuteSchemeHandler(QWebEngineUrlSchemeHandler):",
            "",
            "    \"\"\"Handle qute://* requests on QtWebEngine.\"\"\"",
            "",
            "    def install(self, profile):",
            "        \"\"\"Install the handler for qute:// URLs on the given profile.\"\"\"",
            "        profile.installUrlSchemeHandler(b'qute', self)",
            "        if qtutils.version_check('5.11', compiled=False):",
            "            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-63378",
            "            profile.installUrlSchemeHandler(b'chrome-error', self)",
            "            profile.installUrlSchemeHandler(b'chrome-extension', self)",
            "",
            "    def requestStarted(self, job):",
            "        \"\"\"Handle a request for a qute: scheme.",
            "",
            "        This method must be reimplemented by all custom URL scheme handlers.",
            "        The request is asynchronous and does not need to be handled right away.",
            "",
            "        Args:",
            "            job: QWebEngineUrlRequestJob",
            "        \"\"\"",
            "        url = job.requestUrl()",
            "",
            "        if url.scheme() in ['chrome-error', 'chrome-extension']:",
            "            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-63378",
            "            job.fail(QWebEngineUrlRequestJob.UrlInvalid)",
            "            return",
            "",
            "        assert job.requestMethod() == b'GET'",
            "        assert url.scheme() == 'qute'",
            "        log.misc.debug(\"Got request for {}\".format(url.toDisplayString()))",
            "        try:",
            "            mimetype, data = qutescheme.data_for_url(url)",
            "        except qutescheme.NoHandlerFound:",
            "            log.misc.debug(\"No handler found for {}\".format(",
            "                url.toDisplayString()))",
            "            job.fail(QWebEngineUrlRequestJob.UrlNotFound)",
            "        except qutescheme.QuteSchemeOSError:",
            "            # FIXME:qtwebengine how do we show a better error here?",
            "            log.misc.exception(\"OSError while handling qute://* URL\")",
            "            job.fail(QWebEngineUrlRequestJob.UrlNotFound)",
            "        except qutescheme.QuteSchemeError:",
            "            # FIXME:qtwebengine how do we show a better error here?",
            "            log.misc.exception(\"Error while handling qute://* URL\")",
            "            job.fail(QWebEngineUrlRequestJob.RequestFailed)",
            "        except qutescheme.Redirect as e:",
            "            qtutils.ensure_valid(e.url)",
            "            job.redirect(e.url)",
            "        else:",
            "            log.misc.debug(\"Returning {} data\".format(mimetype))",
            "",
            "            # We can't just use the QBuffer constructor taking a QByteArray,",
            "            # because that somehow segfaults...",
            "            # https://www.riverbankcomputing.com/pipermail/pyqt/2016-September/038075.html",
            "            buf = QBuffer(parent=self)",
            "            buf.open(QIODevice.WriteOnly)",
            "            buf.write(data)",
            "            buf.seek(0)",
            "            buf.close()",
            "            job.reply(mimetype.encode('ascii'), buf)"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"QtWebEngine specific qute://* handlers and glue code.\"\"\"",
            "",
            "from PyQt5.QtCore import QBuffer, QIODevice",
            "from PyQt5.QtWebEngineCore import (QWebEngineUrlSchemeHandler,",
            "                                   QWebEngineUrlRequestJob)",
            "",
            "from qutebrowser.browser import qutescheme",
            "from qutebrowser.utils import log, qtutils",
            "",
            "",
            "class QuteSchemeHandler(QWebEngineUrlSchemeHandler):",
            "",
            "    \"\"\"Handle qute://* requests on QtWebEngine.\"\"\"",
            "",
            "    def install(self, profile):",
            "        \"\"\"Install the handler for qute:// URLs on the given profile.\"\"\"",
            "        profile.installUrlSchemeHandler(b'qute', self)",
            "        if qtutils.version_check('5.11', compiled=False):",
            "            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-63378",
            "            profile.installUrlSchemeHandler(b'chrome-error', self)",
            "            profile.installUrlSchemeHandler(b'chrome-extension', self)",
            "",
            "    def requestStarted(self, job):",
            "        \"\"\"Handle a request for a qute: scheme.",
            "",
            "        This method must be reimplemented by all custom URL scheme handlers.",
            "        The request is asynchronous and does not need to be handled right away.",
            "",
            "        Args:",
            "            job: QWebEngineUrlRequestJob",
            "        \"\"\"",
            "        url = job.requestUrl()",
            "",
            "        if url.scheme() in ['chrome-error', 'chrome-extension']:",
            "            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-63378",
            "            job.fail(QWebEngineUrlRequestJob.UrlInvalid)",
            "            return",
            "",
            "        # Only the browser itself or qute:// pages should access any of those",
            "        # URLs.",
            "        # The request interceptor further locks down qute://settings/set.",
            "        try:",
            "            initiator = job.initiator()",
            "        except AttributeError:",
            "            # Added in Qt 5.11",
            "            pass",
            "        else:",
            "            if initiator.isValid() and initiator.scheme() != 'qute':",
            "                log.misc.warning(\"Blocking malicious request from {} to {}\"",
            "                                 .format(initiator.toDisplayString(),",
            "                                         url.toDisplayString()))",
            "                job.fail(QWebEngineUrlRequestJob.RequestDenied)",
            "                return",
            "",
            "        if job.requestMethod() != b'GET':",
            "            job.fail(QWebEngineUrlRequestJob.RequestDenied)",
            "            return",
            "",
            "        assert url.scheme() == 'qute'",
            "",
            "        log.misc.debug(\"Got request for {}\".format(url.toDisplayString()))",
            "        try:",
            "            mimetype, data = qutescheme.data_for_url(url)",
            "        except qutescheme.NoHandlerFound:",
            "            log.misc.debug(\"No handler found for {}\".format(",
            "                url.toDisplayString()))",
            "            job.fail(QWebEngineUrlRequestJob.UrlNotFound)",
            "        except qutescheme.QuteSchemeOSError:",
            "            # FIXME:qtwebengine how do we show a better error here?",
            "            log.misc.exception(\"OSError while handling qute://* URL\")",
            "            job.fail(QWebEngineUrlRequestJob.UrlNotFound)",
            "        except qutescheme.QuteSchemeError:",
            "            # FIXME:qtwebengine how do we show a better error here?",
            "            log.misc.exception(\"Error while handling qute://* URL\")",
            "            job.fail(QWebEngineUrlRequestJob.RequestFailed)",
            "        except qutescheme.Redirect as e:",
            "            qtutils.ensure_valid(e.url)",
            "            job.redirect(e.url)",
            "        else:",
            "            log.misc.debug(\"Returning {} data\".format(mimetype))",
            "",
            "            # We can't just use the QBuffer constructor taking a QByteArray,",
            "            # because that somehow segfaults...",
            "            # https://www.riverbankcomputing.com/pipermail/pyqt/2016-September/038075.html",
            "            buf = QBuffer(parent=self)",
            "            buf.open(QIODevice.WriteOnly)",
            "            buf.write(data)",
            "            buf.seek(0)",
            "            buf.close()",
            "            job.reply(mimetype.encode('ascii'), buf)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "58": [
                "QuteSchemeHandler",
                "requestStarted"
            ]
        },
        "addLocation": []
    },
    "qutebrowser/browser/webkit/network/filescheme.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "     return html.encode('UTF-8', errors='xmlcharrefreplace')"
            },
            "1": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def handler(request):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+def handler(request, _operation, _current_url):"
            },
            "5": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "     \"\"\"Handler for a file:// URL."
            },
            "6": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     Args:"
            },
            "8": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         request: QNetworkRequest to answer to."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        _operation: The HTTP operation being done."
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        _current_url: The page we're on currently."
            },
            "11": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "     Return:"
            },
            "13": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         A QNetworkReply for directories, None for files."
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2014-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "# Copyright 2015-2018 Antoni Boucher (antoyo) <bouanto@zoho.com>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "# pylint complains when using .render() on jinja templates, so we make it shut",
            "# up for this whole module.",
            "",
            "\"\"\"Handler functions for file:... pages.\"\"\"",
            "",
            "import os",
            "",
            "from qutebrowser.browser.webkit.network import networkreply",
            "from qutebrowser.utils import jinja",
            "",
            "",
            "def get_file_list(basedir, all_files, filterfunc):",
            "    \"\"\"Get a list of files filtered by a filter function and sorted by name.",
            "",
            "    Args:",
            "        basedir: The parent directory of all files.",
            "        all_files: The list of files to filter and sort.",
            "        filterfunc: The filter function.",
            "",
            "    Return:",
            "        A list of dicts. Each dict contains the name and absname keys.",
            "    \"\"\"",
            "    items = []",
            "    for filename in all_files:",
            "        absname = os.path.join(basedir, filename)",
            "        if filterfunc(absname):",
            "            items.append({'name': filename, 'absname': absname})",
            "    return sorted(items, key=lambda v: v['name'].lower())",
            "",
            "",
            "def is_root(directory):",
            "    \"\"\"Check if the directory is the root directory.",
            "",
            "    Args:",
            "        directory: The directory to check.",
            "",
            "    Return:",
            "        Whether the directory is a root directory or not.",
            "    \"\"\"",
            "    # If you're curious as why this works:",
            "    # dirname('/') = '/'",
            "    # dirname('/home') = '/'",
            "    # dirname('/home/') = '/home'",
            "    # dirname('/home/foo') = '/home'",
            "    # basically, for files (no trailing slash) it removes the file part, and",
            "    # for directories, it removes the trailing slash, so the only way for this",
            "    # to be equal is if the directory is the root directory.",
            "    return os.path.dirname(directory) == directory",
            "",
            "",
            "def parent_dir(directory):",
            "    \"\"\"Return the parent directory for the given directory.",
            "",
            "    Args:",
            "        directory: The path to the directory.",
            "",
            "    Return:",
            "        The path to the parent directory.",
            "    \"\"\"",
            "    return os.path.normpath(os.path.join(directory, os.pardir))",
            "",
            "",
            "def dirbrowser_html(path):",
            "    \"\"\"Get the directory browser web page.",
            "",
            "    Args:",
            "        path: The directory path.",
            "",
            "    Return:",
            "        The HTML of the web page.",
            "    \"\"\"",
            "    title = \"Browse directory: {}\".format(path)",
            "",
            "    if is_root(path):",
            "        parent = None",
            "    else:",
            "        parent = parent_dir(path)",
            "",
            "    try:",
            "        all_files = os.listdir(path)",
            "    except OSError as e:",
            "        html = jinja.render('error.html',",
            "                            title=\"Error while reading directory\",",
            "                            url='file:///{}'.format(path), error=str(e))",
            "        return html.encode('UTF-8', errors='xmlcharrefreplace')",
            "",
            "    files = get_file_list(path, all_files, os.path.isfile)",
            "    directories = get_file_list(path, all_files, os.path.isdir)",
            "    html = jinja.render('dirbrowser.html', title=title, url=path,",
            "                        parent=parent, files=files, directories=directories)",
            "    return html.encode('UTF-8', errors='xmlcharrefreplace')",
            "",
            "",
            "def handler(request):",
            "    \"\"\"Handler for a file:// URL.",
            "",
            "    Args:",
            "        request: QNetworkRequest to answer to.",
            "",
            "    Return:",
            "        A QNetworkReply for directories, None for files.",
            "    \"\"\"",
            "    path = request.url().toLocalFile()",
            "    try:",
            "        if os.path.isdir(path):",
            "            data = dirbrowser_html(path)",
            "            return networkreply.FixedDataNetworkReply(",
            "                request, data, 'text/html')",
            "        return None",
            "    except UnicodeEncodeError:",
            "        return None"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2014-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "# Copyright 2015-2018 Antoni Boucher (antoyo) <bouanto@zoho.com>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "#",
            "# pylint complains when using .render() on jinja templates, so we make it shut",
            "# up for this whole module.",
            "",
            "\"\"\"Handler functions for file:... pages.\"\"\"",
            "",
            "import os",
            "",
            "from qutebrowser.browser.webkit.network import networkreply",
            "from qutebrowser.utils import jinja",
            "",
            "",
            "def get_file_list(basedir, all_files, filterfunc):",
            "    \"\"\"Get a list of files filtered by a filter function and sorted by name.",
            "",
            "    Args:",
            "        basedir: The parent directory of all files.",
            "        all_files: The list of files to filter and sort.",
            "        filterfunc: The filter function.",
            "",
            "    Return:",
            "        A list of dicts. Each dict contains the name and absname keys.",
            "    \"\"\"",
            "    items = []",
            "    for filename in all_files:",
            "        absname = os.path.join(basedir, filename)",
            "        if filterfunc(absname):",
            "            items.append({'name': filename, 'absname': absname})",
            "    return sorted(items, key=lambda v: v['name'].lower())",
            "",
            "",
            "def is_root(directory):",
            "    \"\"\"Check if the directory is the root directory.",
            "",
            "    Args:",
            "        directory: The directory to check.",
            "",
            "    Return:",
            "        Whether the directory is a root directory or not.",
            "    \"\"\"",
            "    # If you're curious as why this works:",
            "    # dirname('/') = '/'",
            "    # dirname('/home') = '/'",
            "    # dirname('/home/') = '/home'",
            "    # dirname('/home/foo') = '/home'",
            "    # basically, for files (no trailing slash) it removes the file part, and",
            "    # for directories, it removes the trailing slash, so the only way for this",
            "    # to be equal is if the directory is the root directory.",
            "    return os.path.dirname(directory) == directory",
            "",
            "",
            "def parent_dir(directory):",
            "    \"\"\"Return the parent directory for the given directory.",
            "",
            "    Args:",
            "        directory: The path to the directory.",
            "",
            "    Return:",
            "        The path to the parent directory.",
            "    \"\"\"",
            "    return os.path.normpath(os.path.join(directory, os.pardir))",
            "",
            "",
            "def dirbrowser_html(path):",
            "    \"\"\"Get the directory browser web page.",
            "",
            "    Args:",
            "        path: The directory path.",
            "",
            "    Return:",
            "        The HTML of the web page.",
            "    \"\"\"",
            "    title = \"Browse directory: {}\".format(path)",
            "",
            "    if is_root(path):",
            "        parent = None",
            "    else:",
            "        parent = parent_dir(path)",
            "",
            "    try:",
            "        all_files = os.listdir(path)",
            "    except OSError as e:",
            "        html = jinja.render('error.html',",
            "                            title=\"Error while reading directory\",",
            "                            url='file:///{}'.format(path), error=str(e))",
            "        return html.encode('UTF-8', errors='xmlcharrefreplace')",
            "",
            "    files = get_file_list(path, all_files, os.path.isfile)",
            "    directories = get_file_list(path, all_files, os.path.isdir)",
            "    html = jinja.render('dirbrowser.html', title=title, url=path,",
            "                        parent=parent, files=files, directories=directories)",
            "    return html.encode('UTF-8', errors='xmlcharrefreplace')",
            "",
            "",
            "def handler(request, _operation, _current_url):",
            "    \"\"\"Handler for a file:// URL.",
            "",
            "    Args:",
            "        request: QNetworkRequest to answer to.",
            "        _operation: The HTTP operation being done.",
            "        _current_url: The page we're on currently.",
            "",
            "    Return:",
            "        A QNetworkReply for directories, None for files.",
            "    \"\"\"",
            "    path = request.url().toLocalFile()",
            "    try:",
            "        if os.path.isdir(path):",
            "            data = dirbrowser_html(path)",
            "            return networkreply.FixedDataNetworkReply(",
            "                request, data, 'text/html')",
            "        return None",
            "    except UnicodeEncodeError:",
            "        return None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "114": [
                "handler"
            ]
        },
        "addLocation": []
    },
    "qutebrowser/browser/webkit/network/networkmanager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "                     req, proxy_error, QNetworkReply.UnknownProxyError,"
            },
            "1": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "                     self)"
            },
            "2": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 375,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        scheme = req.url().scheme()"
            },
            "4": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if scheme in self._scheme_handlers:"
            },
            "5": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result = self._scheme_handlers[scheme](req)"
            },
            "6": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if result is not None:"
            },
            "7": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result.setParent(self)"
            },
            "8": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return result"
            },
            "9": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "10": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "         for header, value in shared.custom_headers(url=req.url()):"
            },
            "11": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "             req.setRawHeader(header, value)"
            },
            "12": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 378,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "                 req.url().toDisplayString(),"
            },
            "14": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "                 current_url.toDisplayString()))"
            },
            "15": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 411,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+        scheme = req.url().scheme()"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+        if scheme in self._scheme_handlers:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+            result = self._scheme_handlers[scheme](req, op, current_url)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+            if result is not None:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+                result.setParent(self)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+                return result"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": 419,
                "PatchRowcode": "         self.set_referer(req, current_url)"
            },
            "24": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 420,
                "PatchRowcode": "         return super().createRequest(op, req, outgoing_data)"
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2014-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Our own QNetworkAccessManager.\"\"\"",
            "",
            "import collections",
            "import html",
            "",
            "import attr",
            "from PyQt5.QtCore import (pyqtSlot, pyqtSignal, QCoreApplication, QUrl,",
            "                          QByteArray)",
            "from PyQt5.QtNetwork import QNetworkAccessManager, QNetworkReply, QSslSocket",
            "",
            "from qutebrowser.config import config",
            "from qutebrowser.utils import (message, log, usertypes, utils, objreg,",
            "                               urlutils, debug)",
            "from qutebrowser.browser import shared",
            "from qutebrowser.browser.webkit import certificateerror",
            "from qutebrowser.browser.webkit.network import (webkitqutescheme, networkreply,",
            "                                                filescheme)",
            "",
            "",
            "HOSTBLOCK_ERROR_STRING = '%HOSTBLOCK%'",
            "_proxy_auth_cache = {}",
            "",
            "",
            "@attr.s(frozen=True)",
            "class ProxyId:",
            "",
            "    \"\"\"Information identifying a proxy server.\"\"\"",
            "",
            "    type = attr.ib()",
            "    hostname = attr.ib()",
            "    port = attr.ib()",
            "",
            "",
            "def _is_secure_cipher(cipher):",
            "    \"\"\"Check if a given SSL cipher (hopefully) isn't broken yet.\"\"\"",
            "    tokens = [e.upper() for e in cipher.name().split('-')]",
            "    if cipher.usedBits() < 128:",
            "        # https://codereview.qt-project.org/#/c/75943/",
            "        return False",
            "    # OpenSSL should already protect against this in a better way",
            "    elif cipher.keyExchangeMethod() == 'DH' and utils.is_windows:",
            "        # https://weakdh.org/",
            "        return False",
            "    elif cipher.encryptionMethod().upper().startswith('RC4'):",
            "        # http://en.wikipedia.org/wiki/RC4#Security",
            "        # https://codereview.qt-project.org/#/c/148906/",
            "        return False",
            "    elif cipher.encryptionMethod().upper().startswith('DES'):",
            "        # http://en.wikipedia.org/wiki/Data_Encryption_Standard#Security_and_cryptanalysis",
            "        return False",
            "    elif 'MD5' in tokens:",
            "        # http://www.win.tue.nl/hashclash/rogue-ca/",
            "        return False",
            "    # OpenSSL should already protect against this in a better way",
            "    # elif (('CBC3' in tokens or 'CBC' in tokens) and (cipher.protocol() not in",
            "    #         [QSsl.TlsV1_0, QSsl.TlsV1_1, QSsl.TlsV1_2])):",
            "    #     # http://en.wikipedia.org/wiki/POODLE",
            "    #     return False",
            "    ### These things should never happen as those are already filtered out by",
            "    ### either the SSL libraries or Qt - but let's be sure.",
            "    elif cipher.authenticationMethod() in ['aNULL', 'NULL']:",
            "        # Ciphers without authentication.",
            "        return False",
            "    elif cipher.encryptionMethod() in ['eNULL', 'NULL']:",
            "        # Ciphers without encryption.",
            "        return False",
            "    elif 'EXP' in tokens or 'EXPORT' in tokens:",
            "        # Weak export-grade ciphers",
            "        return False",
            "    elif 'ADH' in tokens:",
            "        # No MITM protection",
            "        return False",
            "    ### This *should* happen ;)",
            "    else:",
            "        return True",
            "",
            "",
            "def init():",
            "    \"\"\"Disable insecure SSL ciphers on old Qt versions.\"\"\"",
            "    default_ciphers = QSslSocket.defaultCiphers()",
            "    log.init.debug(\"Default Qt ciphers: {}\".format(",
            "        ', '.join(c.name() for c in default_ciphers)))",
            "",
            "    good_ciphers = []",
            "    bad_ciphers = []",
            "    for cipher in default_ciphers:",
            "        if _is_secure_cipher(cipher):",
            "            good_ciphers.append(cipher)",
            "        else:",
            "            bad_ciphers.append(cipher)",
            "",
            "    log.init.debug(\"Disabling bad ciphers: {}\".format(",
            "        ', '.join(c.name() for c in bad_ciphers)))",
            "    QSslSocket.setDefaultCiphers(good_ciphers)",
            "",
            "",
            "class NetworkManager(QNetworkAccessManager):",
            "",
            "    \"\"\"Our own QNetworkAccessManager.",
            "",
            "    Attributes:",
            "        adopted_downloads: If downloads are running with this QNAM but the",
            "                           associated tab gets closed already, the NAM gets",
            "                           reparented to the DownloadManager. This counts the",
            "                           still running downloads, so the QNAM can clean",
            "                           itself up when this reaches zero again.",
            "        _scheme_handlers: A dictionary (scheme -> handler) of supported custom",
            "                          schemes.",
            "        _win_id: The window ID this NetworkManager is associated with.",
            "                 (or None for generic network managers)",
            "        _tab_id: The tab ID this NetworkManager is associated with.",
            "                 (or None for generic network managers)",
            "        _rejected_ssl_errors: A {QUrl: [SslError]} dict of rejected errors.",
            "        _accepted_ssl_errors: A {QUrl: [SslError]} dict of accepted errors.",
            "        _private: Whether we're in private browsing mode.",
            "        netrc_used: Whether netrc authentication was performed.",
            "",
            "    Signals:",
            "        shutting_down: Emitted when the QNAM is shutting down.",
            "    \"\"\"",
            "",
            "    shutting_down = pyqtSignal()",
            "",
            "    def __init__(self, *, win_id, tab_id, private, parent=None):",
            "        log.init.debug(\"Initializing NetworkManager\")",
            "        with log.disable_qt_msghandler():",
            "            # WORKAROUND for a hang when a message is printed - See:",
            "            # http://www.riverbankcomputing.com/pipermail/pyqt/2014-November/035045.html",
            "            super().__init__(parent)",
            "        log.init.debug(\"NetworkManager init done\")",
            "        self.adopted_downloads = 0",
            "        self._args = objreg.get('args')",
            "        self._win_id = win_id",
            "        self._tab_id = tab_id",
            "        self._private = private",
            "        self._scheme_handlers = {",
            "            'qute': webkitqutescheme.handler,",
            "            'file': filescheme.handler,",
            "        }",
            "        self._set_cookiejar()",
            "        self._set_cache()",
            "        self.sslErrors.connect(self.on_ssl_errors)",
            "        self._rejected_ssl_errors = collections.defaultdict(list)",
            "        self._accepted_ssl_errors = collections.defaultdict(list)",
            "        self.authenticationRequired.connect(self.on_authentication_required)",
            "        self.proxyAuthenticationRequired.connect(",
            "            self.on_proxy_authentication_required)",
            "        self.netrc_used = False",
            "",
            "    def _set_cookiejar(self):",
            "        \"\"\"Set the cookie jar of the NetworkManager correctly.\"\"\"",
            "        if self._private:",
            "            cookie_jar = objreg.get('ram-cookie-jar')",
            "        else:",
            "            cookie_jar = objreg.get('cookie-jar')",
            "",
            "        # We have a shared cookie jar - we restore its parent so we don't",
            "        # take ownership of it.",
            "        self.setCookieJar(cookie_jar)",
            "        app = QCoreApplication.instance()",
            "        cookie_jar.setParent(app)",
            "",
            "    def _set_cache(self):",
            "        \"\"\"Set the cache of the NetworkManager correctly.\"\"\"",
            "        if self._private:",
            "            return",
            "        # We have a shared cache - we restore its parent so we don't take",
            "        # ownership of it.",
            "        app = QCoreApplication.instance()",
            "        cache = objreg.get('cache')",
            "        self.setCache(cache)",
            "        cache.setParent(app)",
            "",
            "    def _get_abort_signals(self, owner=None):",
            "        \"\"\"Get a list of signals which should abort a question.\"\"\"",
            "        abort_on = [self.shutting_down]",
            "        if owner is not None:",
            "            abort_on.append(owner.destroyed)",
            "        # This might be a generic network manager, e.g. one belonging to a",
            "        # DownloadManager. In this case, just skip the webview thing.",
            "        if self._tab_id is not None:",
            "            assert self._win_id is not None",
            "            tab = objreg.get('tab', scope='tab', window=self._win_id,",
            "                             tab=self._tab_id)",
            "            abort_on.append(tab.load_started)",
            "        return abort_on",
            "",
            "    def shutdown(self):",
            "        \"\"\"Abort all running requests.\"\"\"",
            "        self.setNetworkAccessible(QNetworkAccessManager.NotAccessible)",
            "        self.shutting_down.emit()",
            "",
            "    # No @pyqtSlot here, see",
            "    # https://github.com/qutebrowser/qutebrowser/issues/2213",
            "    def on_ssl_errors(self, reply, errors):  # noqa: C901 pragma: no mccabe",
            "        \"\"\"Decide if SSL errors should be ignored or not.",
            "",
            "        This slot is called on SSL/TLS errors by the self.sslErrors signal.",
            "",
            "        Args:",
            "            reply: The QNetworkReply that is encountering the errors.",
            "            errors: A list of errors.",
            "        \"\"\"",
            "        errors = [certificateerror.CertificateErrorWrapper(e) for e in errors]",
            "        log.webview.debug(\"Certificate errors: {!r}\".format(",
            "            ' / '.join(str(err) for err in errors)))",
            "        try:",
            "            host_tpl = urlutils.host_tuple(reply.url())",
            "        except ValueError:",
            "            host_tpl = None",
            "            is_accepted = False",
            "            is_rejected = False",
            "        else:",
            "            is_accepted = set(errors).issubset(",
            "                self._accepted_ssl_errors[host_tpl])",
            "            is_rejected = set(errors).issubset(",
            "                self._rejected_ssl_errors[host_tpl])",
            "",
            "        log.webview.debug(\"Already accepted: {} / \"",
            "                          \"rejected {}\".format(is_accepted, is_rejected))",
            "",
            "        if is_rejected:",
            "            return",
            "        elif is_accepted:",
            "            reply.ignoreSslErrors()",
            "            return",
            "",
            "        abort_on = self._get_abort_signals(reply)",
            "        ignore = shared.ignore_certificate_errors(reply.url(), errors,",
            "                                                  abort_on=abort_on)",
            "        if ignore:",
            "            reply.ignoreSslErrors()",
            "            err_dict = self._accepted_ssl_errors",
            "        else:",
            "            err_dict = self._rejected_ssl_errors",
            "        if host_tpl is not None:",
            "            err_dict[host_tpl] += errors",
            "",
            "    def clear_all_ssl_errors(self):",
            "        \"\"\"Clear all remembered SSL errors.\"\"\"",
            "        self._accepted_ssl_errors.clear()",
            "        self._rejected_ssl_errors.clear()",
            "",
            "    @pyqtSlot(QUrl)",
            "    def clear_rejected_ssl_errors(self, url):",
            "        \"\"\"Clear the rejected SSL errors on a reload.",
            "",
            "        Args:",
            "            url: The URL to remove.",
            "        \"\"\"",
            "        try:",
            "            del self._rejected_ssl_errors[url]",
            "        except KeyError:",
            "            pass",
            "",
            "    @pyqtSlot('QNetworkReply*', 'QAuthenticator*')",
            "    def on_authentication_required(self, reply, authenticator):",
            "        \"\"\"Called when a website needs authentication.\"\"\"",
            "        netrc_success = False",
            "        if not self.netrc_used:",
            "            self.netrc_used = True",
            "            netrc_success = shared.netrc_authentication(reply.url(),",
            "                                                        authenticator)",
            "        if not netrc_success:",
            "            abort_on = self._get_abort_signals(reply)",
            "            shared.authentication_required(reply.url(), authenticator,",
            "                                           abort_on=abort_on)",
            "",
            "    @pyqtSlot('QNetworkProxy', 'QAuthenticator*')",
            "    def on_proxy_authentication_required(self, proxy, authenticator):",
            "        \"\"\"Called when a proxy needs authentication.\"\"\"",
            "        proxy_id = ProxyId(proxy.type(), proxy.hostName(), proxy.port())",
            "        if proxy_id in _proxy_auth_cache:",
            "            user, password = _proxy_auth_cache[proxy_id]",
            "            authenticator.setUser(user)",
            "            authenticator.setPassword(password)",
            "        else:",
            "            msg = '<b>{}</b> says:<br/>{}'.format(",
            "                html.escape(proxy.hostName()),",
            "                html.escape(authenticator.realm()))",
            "            abort_on = self._get_abort_signals()",
            "            answer = message.ask(",
            "                title=\"Proxy authentication required\", text=msg,",
            "                mode=usertypes.PromptMode.user_pwd, abort_on=abort_on)",
            "            if answer is not None:",
            "                authenticator.setUser(answer.user)",
            "                authenticator.setPassword(answer.password)",
            "                _proxy_auth_cache[proxy_id] = answer",
            "",
            "    @pyqtSlot()",
            "    def on_adopted_download_destroyed(self):",
            "        \"\"\"Check if we can clean up if an adopted download was destroyed.",
            "",
            "        See the description for adopted_downloads for details.",
            "        \"\"\"",
            "        self.adopted_downloads -= 1",
            "        log.downloads.debug(\"Adopted download destroyed, {} left.\".format(",
            "            self.adopted_downloads))",
            "        assert self.adopted_downloads >= 0",
            "        if self.adopted_downloads == 0:",
            "            self.deleteLater()",
            "",
            "    @pyqtSlot(object)  # DownloadItem",
            "    def adopt_download(self, download):",
            "        \"\"\"Adopt a new DownloadItem.\"\"\"",
            "        self.adopted_downloads += 1",
            "        log.downloads.debug(\"Adopted download, {} adopted.\".format(",
            "            self.adopted_downloads))",
            "        download.destroyed.connect(self.on_adopted_download_destroyed)",
            "        download.adopt_download.connect(self.adopt_download)",
            "",
            "    def set_referer(self, req, current_url):",
            "        \"\"\"Set the referer header.\"\"\"",
            "        referer_header_conf = config.val.content.headers.referer",
            "",
            "        try:",
            "            if referer_header_conf == 'never':",
            "                # Note: using ''.encode('ascii') sends a header with no value,",
            "                # instead of no header at all",
            "                req.setRawHeader('Referer'.encode('ascii'), QByteArray())",
            "            elif (referer_header_conf == 'same-domain' and",
            "                  not urlutils.same_domain(req.url(), current_url)):",
            "                req.setRawHeader('Referer'.encode('ascii'), QByteArray())",
            "            # If refer_header_conf is set to 'always', we leave the header",
            "            # alone as QtWebKit did set it.",
            "        except urlutils.InvalidUrlError:",
            "            # req.url() or current_url can be invalid - this happens on",
            "            # https://www.playstation.com/ for example.",
            "            pass",
            "",
            "    # WORKAROUND for:",
            "    # http://www.riverbankcomputing.com/pipermail/pyqt/2014-September/034806.html",
            "    #",
            "    # By returning False, we provoke a TypeError because of a wrong return",
            "    # type, which does *not* trigger a segfault but invoke our return handler",
            "    # immediately.",
            "    @utils.prevent_exceptions(False)",
            "    def createRequest(self, op, req, outgoing_data):",
            "        \"\"\"Return a new QNetworkReply object.",
            "",
            "        Args:",
            "             op: Operation op",
            "             req: const QNetworkRequest & req",
            "             outgoing_data: QIODevice * outgoingData",
            "",
            "        Return:",
            "            A QNetworkReply.",
            "        \"\"\"",
            "        proxy_factory = objreg.get('proxy-factory', None)",
            "        if proxy_factory is not None:",
            "            proxy_error = proxy_factory.get_error()",
            "            if proxy_error is not None:",
            "                return networkreply.ErrorNetworkReply(",
            "                    req, proxy_error, QNetworkReply.UnknownProxyError,",
            "                    self)",
            "",
            "        scheme = req.url().scheme()",
            "        if scheme in self._scheme_handlers:",
            "            result = self._scheme_handlers[scheme](req)",
            "            if result is not None:",
            "                result.setParent(self)",
            "                return result",
            "",
            "        for header, value in shared.custom_headers(url=req.url()):",
            "            req.setRawHeader(header, value)",
            "",
            "        host_blocker = objreg.get('host-blocker')",
            "        if host_blocker.is_blocked(req.url()):",
            "            log.webview.info(\"Request to {} blocked by host blocker.\".format(",
            "                req.url().host()))",
            "            return networkreply.ErrorNetworkReply(",
            "                req, HOSTBLOCK_ERROR_STRING, QNetworkReply.ContentAccessDenied,",
            "                self)",
            "",
            "        # There are some scenarios where we can't figure out current_url:",
            "        # - There's a generic NetworkManager, e.g. for downloads",
            "        # - The download was in a tab which is now closed.",
            "        current_url = QUrl()",
            "",
            "        if self._tab_id is not None:",
            "            assert self._win_id is not None",
            "            try:",
            "                tab = objreg.get('tab', scope='tab', window=self._win_id,",
            "                                 tab=self._tab_id)",
            "                current_url = tab.url()",
            "            except (KeyError, RuntimeError):",
            "                # https://github.com/qutebrowser/qutebrowser/issues/889",
            "                # Catching RuntimeError because we could be in the middle of",
            "                # the webpage shutdown here.",
            "                current_url = QUrl()",
            "",
            "        if 'log-requests' in self._args.debug_flags:",
            "            operation = debug.qenum_key(QNetworkAccessManager, op)",
            "            operation = operation.replace('Operation', '').upper()",
            "            log.webview.debug(\"{} {}, first-party {}\".format(",
            "                operation,",
            "                req.url().toDisplayString(),",
            "                current_url.toDisplayString()))",
            "",
            "        self.set_referer(req, current_url)",
            "        return super().createRequest(op, req, outgoing_data)"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2014-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Our own QNetworkAccessManager.\"\"\"",
            "",
            "import collections",
            "import html",
            "",
            "import attr",
            "from PyQt5.QtCore import (pyqtSlot, pyqtSignal, QCoreApplication, QUrl,",
            "                          QByteArray)",
            "from PyQt5.QtNetwork import QNetworkAccessManager, QNetworkReply, QSslSocket",
            "",
            "from qutebrowser.config import config",
            "from qutebrowser.utils import (message, log, usertypes, utils, objreg,",
            "                               urlutils, debug)",
            "from qutebrowser.browser import shared",
            "from qutebrowser.browser.webkit import certificateerror",
            "from qutebrowser.browser.webkit.network import (webkitqutescheme, networkreply,",
            "                                                filescheme)",
            "",
            "",
            "HOSTBLOCK_ERROR_STRING = '%HOSTBLOCK%'",
            "_proxy_auth_cache = {}",
            "",
            "",
            "@attr.s(frozen=True)",
            "class ProxyId:",
            "",
            "    \"\"\"Information identifying a proxy server.\"\"\"",
            "",
            "    type = attr.ib()",
            "    hostname = attr.ib()",
            "    port = attr.ib()",
            "",
            "",
            "def _is_secure_cipher(cipher):",
            "    \"\"\"Check if a given SSL cipher (hopefully) isn't broken yet.\"\"\"",
            "    tokens = [e.upper() for e in cipher.name().split('-')]",
            "    if cipher.usedBits() < 128:",
            "        # https://codereview.qt-project.org/#/c/75943/",
            "        return False",
            "    # OpenSSL should already protect against this in a better way",
            "    elif cipher.keyExchangeMethod() == 'DH' and utils.is_windows:",
            "        # https://weakdh.org/",
            "        return False",
            "    elif cipher.encryptionMethod().upper().startswith('RC4'):",
            "        # http://en.wikipedia.org/wiki/RC4#Security",
            "        # https://codereview.qt-project.org/#/c/148906/",
            "        return False",
            "    elif cipher.encryptionMethod().upper().startswith('DES'):",
            "        # http://en.wikipedia.org/wiki/Data_Encryption_Standard#Security_and_cryptanalysis",
            "        return False",
            "    elif 'MD5' in tokens:",
            "        # http://www.win.tue.nl/hashclash/rogue-ca/",
            "        return False",
            "    # OpenSSL should already protect against this in a better way",
            "    # elif (('CBC3' in tokens or 'CBC' in tokens) and (cipher.protocol() not in",
            "    #         [QSsl.TlsV1_0, QSsl.TlsV1_1, QSsl.TlsV1_2])):",
            "    #     # http://en.wikipedia.org/wiki/POODLE",
            "    #     return False",
            "    ### These things should never happen as those are already filtered out by",
            "    ### either the SSL libraries or Qt - but let's be sure.",
            "    elif cipher.authenticationMethod() in ['aNULL', 'NULL']:",
            "        # Ciphers without authentication.",
            "        return False",
            "    elif cipher.encryptionMethod() in ['eNULL', 'NULL']:",
            "        # Ciphers without encryption.",
            "        return False",
            "    elif 'EXP' in tokens or 'EXPORT' in tokens:",
            "        # Weak export-grade ciphers",
            "        return False",
            "    elif 'ADH' in tokens:",
            "        # No MITM protection",
            "        return False",
            "    ### This *should* happen ;)",
            "    else:",
            "        return True",
            "",
            "",
            "def init():",
            "    \"\"\"Disable insecure SSL ciphers on old Qt versions.\"\"\"",
            "    default_ciphers = QSslSocket.defaultCiphers()",
            "    log.init.debug(\"Default Qt ciphers: {}\".format(",
            "        ', '.join(c.name() for c in default_ciphers)))",
            "",
            "    good_ciphers = []",
            "    bad_ciphers = []",
            "    for cipher in default_ciphers:",
            "        if _is_secure_cipher(cipher):",
            "            good_ciphers.append(cipher)",
            "        else:",
            "            bad_ciphers.append(cipher)",
            "",
            "    log.init.debug(\"Disabling bad ciphers: {}\".format(",
            "        ', '.join(c.name() for c in bad_ciphers)))",
            "    QSslSocket.setDefaultCiphers(good_ciphers)",
            "",
            "",
            "class NetworkManager(QNetworkAccessManager):",
            "",
            "    \"\"\"Our own QNetworkAccessManager.",
            "",
            "    Attributes:",
            "        adopted_downloads: If downloads are running with this QNAM but the",
            "                           associated tab gets closed already, the NAM gets",
            "                           reparented to the DownloadManager. This counts the",
            "                           still running downloads, so the QNAM can clean",
            "                           itself up when this reaches zero again.",
            "        _scheme_handlers: A dictionary (scheme -> handler) of supported custom",
            "                          schemes.",
            "        _win_id: The window ID this NetworkManager is associated with.",
            "                 (or None for generic network managers)",
            "        _tab_id: The tab ID this NetworkManager is associated with.",
            "                 (or None for generic network managers)",
            "        _rejected_ssl_errors: A {QUrl: [SslError]} dict of rejected errors.",
            "        _accepted_ssl_errors: A {QUrl: [SslError]} dict of accepted errors.",
            "        _private: Whether we're in private browsing mode.",
            "        netrc_used: Whether netrc authentication was performed.",
            "",
            "    Signals:",
            "        shutting_down: Emitted when the QNAM is shutting down.",
            "    \"\"\"",
            "",
            "    shutting_down = pyqtSignal()",
            "",
            "    def __init__(self, *, win_id, tab_id, private, parent=None):",
            "        log.init.debug(\"Initializing NetworkManager\")",
            "        with log.disable_qt_msghandler():",
            "            # WORKAROUND for a hang when a message is printed - See:",
            "            # http://www.riverbankcomputing.com/pipermail/pyqt/2014-November/035045.html",
            "            super().__init__(parent)",
            "        log.init.debug(\"NetworkManager init done\")",
            "        self.adopted_downloads = 0",
            "        self._args = objreg.get('args')",
            "        self._win_id = win_id",
            "        self._tab_id = tab_id",
            "        self._private = private",
            "        self._scheme_handlers = {",
            "            'qute': webkitqutescheme.handler,",
            "            'file': filescheme.handler,",
            "        }",
            "        self._set_cookiejar()",
            "        self._set_cache()",
            "        self.sslErrors.connect(self.on_ssl_errors)",
            "        self._rejected_ssl_errors = collections.defaultdict(list)",
            "        self._accepted_ssl_errors = collections.defaultdict(list)",
            "        self.authenticationRequired.connect(self.on_authentication_required)",
            "        self.proxyAuthenticationRequired.connect(",
            "            self.on_proxy_authentication_required)",
            "        self.netrc_used = False",
            "",
            "    def _set_cookiejar(self):",
            "        \"\"\"Set the cookie jar of the NetworkManager correctly.\"\"\"",
            "        if self._private:",
            "            cookie_jar = objreg.get('ram-cookie-jar')",
            "        else:",
            "            cookie_jar = objreg.get('cookie-jar')",
            "",
            "        # We have a shared cookie jar - we restore its parent so we don't",
            "        # take ownership of it.",
            "        self.setCookieJar(cookie_jar)",
            "        app = QCoreApplication.instance()",
            "        cookie_jar.setParent(app)",
            "",
            "    def _set_cache(self):",
            "        \"\"\"Set the cache of the NetworkManager correctly.\"\"\"",
            "        if self._private:",
            "            return",
            "        # We have a shared cache - we restore its parent so we don't take",
            "        # ownership of it.",
            "        app = QCoreApplication.instance()",
            "        cache = objreg.get('cache')",
            "        self.setCache(cache)",
            "        cache.setParent(app)",
            "",
            "    def _get_abort_signals(self, owner=None):",
            "        \"\"\"Get a list of signals which should abort a question.\"\"\"",
            "        abort_on = [self.shutting_down]",
            "        if owner is not None:",
            "            abort_on.append(owner.destroyed)",
            "        # This might be a generic network manager, e.g. one belonging to a",
            "        # DownloadManager. In this case, just skip the webview thing.",
            "        if self._tab_id is not None:",
            "            assert self._win_id is not None",
            "            tab = objreg.get('tab', scope='tab', window=self._win_id,",
            "                             tab=self._tab_id)",
            "            abort_on.append(tab.load_started)",
            "        return abort_on",
            "",
            "    def shutdown(self):",
            "        \"\"\"Abort all running requests.\"\"\"",
            "        self.setNetworkAccessible(QNetworkAccessManager.NotAccessible)",
            "        self.shutting_down.emit()",
            "",
            "    # No @pyqtSlot here, see",
            "    # https://github.com/qutebrowser/qutebrowser/issues/2213",
            "    def on_ssl_errors(self, reply, errors):  # noqa: C901 pragma: no mccabe",
            "        \"\"\"Decide if SSL errors should be ignored or not.",
            "",
            "        This slot is called on SSL/TLS errors by the self.sslErrors signal.",
            "",
            "        Args:",
            "            reply: The QNetworkReply that is encountering the errors.",
            "            errors: A list of errors.",
            "        \"\"\"",
            "        errors = [certificateerror.CertificateErrorWrapper(e) for e in errors]",
            "        log.webview.debug(\"Certificate errors: {!r}\".format(",
            "            ' / '.join(str(err) for err in errors)))",
            "        try:",
            "            host_tpl = urlutils.host_tuple(reply.url())",
            "        except ValueError:",
            "            host_tpl = None",
            "            is_accepted = False",
            "            is_rejected = False",
            "        else:",
            "            is_accepted = set(errors).issubset(",
            "                self._accepted_ssl_errors[host_tpl])",
            "            is_rejected = set(errors).issubset(",
            "                self._rejected_ssl_errors[host_tpl])",
            "",
            "        log.webview.debug(\"Already accepted: {} / \"",
            "                          \"rejected {}\".format(is_accepted, is_rejected))",
            "",
            "        if is_rejected:",
            "            return",
            "        elif is_accepted:",
            "            reply.ignoreSslErrors()",
            "            return",
            "",
            "        abort_on = self._get_abort_signals(reply)",
            "        ignore = shared.ignore_certificate_errors(reply.url(), errors,",
            "                                                  abort_on=abort_on)",
            "        if ignore:",
            "            reply.ignoreSslErrors()",
            "            err_dict = self._accepted_ssl_errors",
            "        else:",
            "            err_dict = self._rejected_ssl_errors",
            "        if host_tpl is not None:",
            "            err_dict[host_tpl] += errors",
            "",
            "    def clear_all_ssl_errors(self):",
            "        \"\"\"Clear all remembered SSL errors.\"\"\"",
            "        self._accepted_ssl_errors.clear()",
            "        self._rejected_ssl_errors.clear()",
            "",
            "    @pyqtSlot(QUrl)",
            "    def clear_rejected_ssl_errors(self, url):",
            "        \"\"\"Clear the rejected SSL errors on a reload.",
            "",
            "        Args:",
            "            url: The URL to remove.",
            "        \"\"\"",
            "        try:",
            "            del self._rejected_ssl_errors[url]",
            "        except KeyError:",
            "            pass",
            "",
            "    @pyqtSlot('QNetworkReply*', 'QAuthenticator*')",
            "    def on_authentication_required(self, reply, authenticator):",
            "        \"\"\"Called when a website needs authentication.\"\"\"",
            "        netrc_success = False",
            "        if not self.netrc_used:",
            "            self.netrc_used = True",
            "            netrc_success = shared.netrc_authentication(reply.url(),",
            "                                                        authenticator)",
            "        if not netrc_success:",
            "            abort_on = self._get_abort_signals(reply)",
            "            shared.authentication_required(reply.url(), authenticator,",
            "                                           abort_on=abort_on)",
            "",
            "    @pyqtSlot('QNetworkProxy', 'QAuthenticator*')",
            "    def on_proxy_authentication_required(self, proxy, authenticator):",
            "        \"\"\"Called when a proxy needs authentication.\"\"\"",
            "        proxy_id = ProxyId(proxy.type(), proxy.hostName(), proxy.port())",
            "        if proxy_id in _proxy_auth_cache:",
            "            user, password = _proxy_auth_cache[proxy_id]",
            "            authenticator.setUser(user)",
            "            authenticator.setPassword(password)",
            "        else:",
            "            msg = '<b>{}</b> says:<br/>{}'.format(",
            "                html.escape(proxy.hostName()),",
            "                html.escape(authenticator.realm()))",
            "            abort_on = self._get_abort_signals()",
            "            answer = message.ask(",
            "                title=\"Proxy authentication required\", text=msg,",
            "                mode=usertypes.PromptMode.user_pwd, abort_on=abort_on)",
            "            if answer is not None:",
            "                authenticator.setUser(answer.user)",
            "                authenticator.setPassword(answer.password)",
            "                _proxy_auth_cache[proxy_id] = answer",
            "",
            "    @pyqtSlot()",
            "    def on_adopted_download_destroyed(self):",
            "        \"\"\"Check if we can clean up if an adopted download was destroyed.",
            "",
            "        See the description for adopted_downloads for details.",
            "        \"\"\"",
            "        self.adopted_downloads -= 1",
            "        log.downloads.debug(\"Adopted download destroyed, {} left.\".format(",
            "            self.adopted_downloads))",
            "        assert self.adopted_downloads >= 0",
            "        if self.adopted_downloads == 0:",
            "            self.deleteLater()",
            "",
            "    @pyqtSlot(object)  # DownloadItem",
            "    def adopt_download(self, download):",
            "        \"\"\"Adopt a new DownloadItem.\"\"\"",
            "        self.adopted_downloads += 1",
            "        log.downloads.debug(\"Adopted download, {} adopted.\".format(",
            "            self.adopted_downloads))",
            "        download.destroyed.connect(self.on_adopted_download_destroyed)",
            "        download.adopt_download.connect(self.adopt_download)",
            "",
            "    def set_referer(self, req, current_url):",
            "        \"\"\"Set the referer header.\"\"\"",
            "        referer_header_conf = config.val.content.headers.referer",
            "",
            "        try:",
            "            if referer_header_conf == 'never':",
            "                # Note: using ''.encode('ascii') sends a header with no value,",
            "                # instead of no header at all",
            "                req.setRawHeader('Referer'.encode('ascii'), QByteArray())",
            "            elif (referer_header_conf == 'same-domain' and",
            "                  not urlutils.same_domain(req.url(), current_url)):",
            "                req.setRawHeader('Referer'.encode('ascii'), QByteArray())",
            "            # If refer_header_conf is set to 'always', we leave the header",
            "            # alone as QtWebKit did set it.",
            "        except urlutils.InvalidUrlError:",
            "            # req.url() or current_url can be invalid - this happens on",
            "            # https://www.playstation.com/ for example.",
            "            pass",
            "",
            "    # WORKAROUND for:",
            "    # http://www.riverbankcomputing.com/pipermail/pyqt/2014-September/034806.html",
            "    #",
            "    # By returning False, we provoke a TypeError because of a wrong return",
            "    # type, which does *not* trigger a segfault but invoke our return handler",
            "    # immediately.",
            "    @utils.prevent_exceptions(False)",
            "    def createRequest(self, op, req, outgoing_data):",
            "        \"\"\"Return a new QNetworkReply object.",
            "",
            "        Args:",
            "             op: Operation op",
            "             req: const QNetworkRequest & req",
            "             outgoing_data: QIODevice * outgoingData",
            "",
            "        Return:",
            "            A QNetworkReply.",
            "        \"\"\"",
            "        proxy_factory = objreg.get('proxy-factory', None)",
            "        if proxy_factory is not None:",
            "            proxy_error = proxy_factory.get_error()",
            "            if proxy_error is not None:",
            "                return networkreply.ErrorNetworkReply(",
            "                    req, proxy_error, QNetworkReply.UnknownProxyError,",
            "                    self)",
            "",
            "        for header, value in shared.custom_headers(url=req.url()):",
            "            req.setRawHeader(header, value)",
            "",
            "        host_blocker = objreg.get('host-blocker')",
            "        if host_blocker.is_blocked(req.url()):",
            "            log.webview.info(\"Request to {} blocked by host blocker.\".format(",
            "                req.url().host()))",
            "            return networkreply.ErrorNetworkReply(",
            "                req, HOSTBLOCK_ERROR_STRING, QNetworkReply.ContentAccessDenied,",
            "                self)",
            "",
            "        # There are some scenarios where we can't figure out current_url:",
            "        # - There's a generic NetworkManager, e.g. for downloads",
            "        # - The download was in a tab which is now closed.",
            "        current_url = QUrl()",
            "",
            "        if self._tab_id is not None:",
            "            assert self._win_id is not None",
            "            try:",
            "                tab = objreg.get('tab', scope='tab', window=self._win_id,",
            "                                 tab=self._tab_id)",
            "                current_url = tab.url()",
            "            except (KeyError, RuntimeError):",
            "                # https://github.com/qutebrowser/qutebrowser/issues/889",
            "                # Catching RuntimeError because we could be in the middle of",
            "                # the webpage shutdown here.",
            "                current_url = QUrl()",
            "",
            "        if 'log-requests' in self._args.debug_flags:",
            "            operation = debug.qenum_key(QNetworkAccessManager, op)",
            "            operation = operation.replace('Operation', '').upper()",
            "            log.webview.debug(\"{} {}, first-party {}\".format(",
            "                operation,",
            "                req.url().toDisplayString(),",
            "                current_url.toDisplayString()))",
            "",
            "        scheme = req.url().scheme()",
            "        if scheme in self._scheme_handlers:",
            "            result = self._scheme_handlers[scheme](req, op, current_url)",
            "            if result is not None:",
            "                result.setParent(self)",
            "                return result",
            "",
            "        self.set_referer(req, current_url)",
            "        return super().createRequest(op, req, outgoing_data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "376": [
                "NetworkManager",
                "createRequest"
            ],
            "377": [
                "NetworkManager",
                "createRequest"
            ],
            "378": [
                "NetworkManager",
                "createRequest"
            ],
            "379": [
                "NetworkManager",
                "createRequest"
            ],
            "380": [
                "NetworkManager",
                "createRequest"
            ],
            "381": [
                "NetworkManager",
                "createRequest"
            ],
            "382": [
                "NetworkManager",
                "createRequest"
            ]
        },
        "addLocation": []
    },
    "qutebrowser/browser/webkit/network/webkitqutescheme.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import mimetypes"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from PyQt5.QtNetwork import QNetworkReply"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from PyQt5.QtCore import QUrl"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+from PyQt5.QtNetwork import QNetworkReply, QNetworkAccessManager"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from qutebrowser.browser import pdfjs, qutescheme"
            },
            "8": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from qutebrowser.browser.webkit.network import networkreply"
            },
            "9": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from qutebrowser.utils import log, usertypes, qtutils"
            },
            "10": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def handler(request):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+def handler(request, operation, current_url):"
            },
            "14": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     \"\"\"Scheme handler for qute:// URLs."
            },
            "15": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     Args:"
            },
            "17": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         request: QNetworkRequest to answer to."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        operation: The HTTP operation being done."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        current_url: The page we're on currently."
            },
            "20": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     Return:"
            },
            "22": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         A QNetworkReply."
            },
            "23": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     \"\"\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    if operation != QNetworkAccessManager.GetOperation:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        return networkreply.ErrorNetworkReply("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            request, \"Unsupported request type\","
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            QNetworkReply.ContentOperationNotPermittedError)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    url = request.url()"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    if ((url.scheme(), url.host(), url.path()) =="
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            ('qute', 'settings', '/set')):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        if current_url != QUrl('qute://settings/'):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            log.webview.warning(\"Blocking malicious request from {} to {}\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                                .format(current_url.toDisplayString(),"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                                        url.toDisplayString()))"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            return networkreply.ErrorNetworkReply("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+                request, \"Invalid qute://settings request\","
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+                QNetworkReply.ContentAccessDenied)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     try:"
            },
            "42": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mimetype, data = qutescheme.data_for_url(request.url())"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        mimetype, data = qutescheme.data_for_url(url)"
            },
            "44": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     except qutescheme.NoHandlerFound:"
            },
            "45": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        errorstr = \"No handler found for {}!\".format("
            },
            "46": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            request.url().toDisplayString())"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        errorstr = \"No handler found for {}!\".format(url.toDisplayString())"
            },
            "48": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         return networkreply.ErrorNetworkReply("
            },
            "49": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "             request, errorstr, QNetworkReply.ContentNotFoundError)"
            },
            "50": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "     except qutescheme.QuteSchemeOSError as e:"
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2014-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"QtWebKit specific qute://* handlers and glue code.\"\"\"",
            "",
            "import mimetypes",
            "",
            "from PyQt5.QtNetwork import QNetworkReply",
            "",
            "from qutebrowser.browser import pdfjs, qutescheme",
            "from qutebrowser.browser.webkit.network import networkreply",
            "from qutebrowser.utils import log, usertypes, qtutils",
            "",
            "",
            "def handler(request):",
            "    \"\"\"Scheme handler for qute:// URLs.",
            "",
            "    Args:",
            "        request: QNetworkRequest to answer to.",
            "",
            "    Return:",
            "        A QNetworkReply.",
            "    \"\"\"",
            "    try:",
            "        mimetype, data = qutescheme.data_for_url(request.url())",
            "    except qutescheme.NoHandlerFound:",
            "        errorstr = \"No handler found for {}!\".format(",
            "            request.url().toDisplayString())",
            "        return networkreply.ErrorNetworkReply(",
            "            request, errorstr, QNetworkReply.ContentNotFoundError)",
            "    except qutescheme.QuteSchemeOSError as e:",
            "        return networkreply.ErrorNetworkReply(",
            "            request, str(e), QNetworkReply.ContentNotFoundError)",
            "    except qutescheme.QuteSchemeError as e:",
            "        return networkreply.ErrorNetworkReply(request, e.errorstring, e.error)",
            "    except qutescheme.Redirect as e:",
            "        qtutils.ensure_valid(e.url)",
            "        return networkreply.RedirectNetworkReply(e.url)",
            "",
            "    return networkreply.FixedDataNetworkReply(request, data, mimetype)",
            "",
            "",
            "@qutescheme.add_handler('pdfjs', backend=usertypes.Backend.QtWebKit)",
            "def qute_pdfjs(url):",
            "    \"\"\"Handler for qute://pdfjs. Return the pdf.js viewer.\"\"\"",
            "    try:",
            "        data = pdfjs.get_pdfjs_res(url.path())",
            "    except pdfjs.PDFJSNotFound as e:",
            "        # Logging as the error might get lost otherwise since we're not showing",
            "        # the error page if a single asset is missing. This way we don't lose",
            "        # information, as the failed pdfjs requests are still in the log.",
            "        log.misc.warning(",
            "            \"pdfjs resource requested but not found: {}\".format(e.path))",
            "        raise qutescheme.QuteSchemeError(\"Can't find pdfjs resource \"",
            "                                         \"'{}'\".format(e.path),",
            "                                         QNetworkReply.ContentNotFoundError)",
            "    else:",
            "        mimetype, _encoding = mimetypes.guess_type(url.fileName())",
            "        assert mimetype is not None, url",
            "        return mimetype, data"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2014-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"QtWebKit specific qute://* handlers and glue code.\"\"\"",
            "",
            "import mimetypes",
            "",
            "from PyQt5.QtCore import QUrl",
            "from PyQt5.QtNetwork import QNetworkReply, QNetworkAccessManager",
            "",
            "from qutebrowser.browser import pdfjs, qutescheme",
            "from qutebrowser.browser.webkit.network import networkreply",
            "from qutebrowser.utils import log, usertypes, qtutils",
            "",
            "",
            "def handler(request, operation, current_url):",
            "    \"\"\"Scheme handler for qute:// URLs.",
            "",
            "    Args:",
            "        request: QNetworkRequest to answer to.",
            "        operation: The HTTP operation being done.",
            "        current_url: The page we're on currently.",
            "",
            "    Return:",
            "        A QNetworkReply.",
            "    \"\"\"",
            "    if operation != QNetworkAccessManager.GetOperation:",
            "        return networkreply.ErrorNetworkReply(",
            "            request, \"Unsupported request type\",",
            "            QNetworkReply.ContentOperationNotPermittedError)",
            "",
            "    url = request.url()",
            "",
            "    if ((url.scheme(), url.host(), url.path()) ==",
            "            ('qute', 'settings', '/set')):",
            "        if current_url != QUrl('qute://settings/'):",
            "            log.webview.warning(\"Blocking malicious request from {} to {}\"",
            "                                .format(current_url.toDisplayString(),",
            "                                        url.toDisplayString()))",
            "            return networkreply.ErrorNetworkReply(",
            "                request, \"Invalid qute://settings request\",",
            "                QNetworkReply.ContentAccessDenied)",
            "",
            "    try:",
            "        mimetype, data = qutescheme.data_for_url(url)",
            "    except qutescheme.NoHandlerFound:",
            "        errorstr = \"No handler found for {}!\".format(url.toDisplayString())",
            "        return networkreply.ErrorNetworkReply(",
            "            request, errorstr, QNetworkReply.ContentNotFoundError)",
            "    except qutescheme.QuteSchemeOSError as e:",
            "        return networkreply.ErrorNetworkReply(",
            "            request, str(e), QNetworkReply.ContentNotFoundError)",
            "    except qutescheme.QuteSchemeError as e:",
            "        return networkreply.ErrorNetworkReply(request, e.errorstring, e.error)",
            "    except qutescheme.Redirect as e:",
            "        qtutils.ensure_valid(e.url)",
            "        return networkreply.RedirectNetworkReply(e.url)",
            "",
            "    return networkreply.FixedDataNetworkReply(request, data, mimetype)",
            "",
            "",
            "@qutescheme.add_handler('pdfjs', backend=usertypes.Backend.QtWebKit)",
            "def qute_pdfjs(url):",
            "    \"\"\"Handler for qute://pdfjs. Return the pdf.js viewer.\"\"\"",
            "    try:",
            "        data = pdfjs.get_pdfjs_res(url.path())",
            "    except pdfjs.PDFJSNotFound as e:",
            "        # Logging as the error might get lost otherwise since we're not showing",
            "        # the error page if a single asset is missing. This way we don't lose",
            "        # information, as the failed pdfjs requests are still in the log.",
            "        log.misc.warning(",
            "            \"pdfjs resource requested but not found: {}\".format(e.path))",
            "        raise qutescheme.QuteSchemeError(\"Can't find pdfjs resource \"",
            "                                         \"'{}'\".format(e.path),",
            "                                         QNetworkReply.ContentNotFoundError)",
            "    else:",
            "        mimetype, _encoding = mimetypes.guess_type(url.fileName())",
            "        assert mimetype is not None, url",
            "        return mimetype, data"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "24": [],
            "31": [
                "handler"
            ],
            "41": [
                "handler"
            ],
            "43": [
                "handler"
            ],
            "44": [
                "handler"
            ]
        },
        "addLocation": []
    }
}