{
    "vantage6-server/tests_server/test_resources.py": {
        "Patch": {},
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from uuid import uuid1",
            "import yaml",
            "import unittest",
            "import logging",
            "import json",
            "import uuid",
            "",
            "from http import HTTPStatus",
            "from unittest.mock import patch",
            "from flask import Response as BaseResponse",
            "from flask.testing import FlaskClient",
            "from flask_socketio import SocketIO",
            "from werkzeug.utils import cached_property",
            "",
            "from vantage6.common import logger_name",
            "from vantage6.common.globals import APPNAME",
            "from vantage6.common.task_status import TaskStatus",
            "from vantage6.server.globals import PACKAGE_FOLDER",
            "from vantage6.server import ServerApp, session",
            "from vantage6.server.model import (Rule, Role, Organization, User, Node,",
            "                                   Collaboration, Task, Run)",
            "from vantage6.server.model.rule import Scope, Operation",
            "from vantage6.server import context",
            "from vantage6.server._version import __version__",
            "from vantage6.server.model.base import Database, DatabaseSessionManager",
            "from vantage6.server.controller.fixture import load",
            "",
            "",
            "logger = logger_name(__name__)",
            "log = logging.getLogger(logger)",
            "",
            "",
            "class Response(BaseResponse):",
            "    @cached_property",
            "    def json(self):",
            "        return json.loads(self.data)",
            "",
            "",
            "class TestNode(FlaskClient):",
            "    def open(self, *args, **kwargs):",
            "        if 'json' in kwargs:",
            "            kwargs['data'] = json.dumps(kwargs.pop('json'))",
            "            kwargs['content_type'] = 'application/json'",
            "        return super().open(*args, **kwargs)",
            "",
            "",
            "class TestResources(unittest.TestCase):",
            "",
            "    @classmethod",
            "    def setUpClass(cls):",
            "        \"\"\"Called immediately before running a test method.\"\"\"",
            "        Database().connect(\"sqlite://\", allow_drop_all=True)",
            "",
            "        ctx = context.TestContext.from_external_config_file()",
            "",
            "        # create server instance. Patch the start_background_task method",
            "        # to prevent the server from starting a ping/pong thread that will",
            "        # prevent the tests from starting",
            "        with patch.object(SocketIO, 'start_background_task'):",
            "            server = ServerApp(ctx)",
            "        cls.server = server",
            "",
            "        file_ = str(PACKAGE_FOLDER / APPNAME / \"server\" / \"_data\" /",
            "                    \"unittest_fixtures.yaml\")",
            "        with open(file_) as f:",
            "            cls.entities = yaml.safe_load(f.read())",
            "        load(cls.entities)",
            "",
            "        server.app.testing = True",
            "        cls.app = server.app.test_client()",
            "",
            "        cls.credentials = {",
            "            'root': {",
            "                'username': 'root',",
            "                'password': 'root'",
            "            },",
            "            'admin': {",
            "                'username': 'frank@iknl.nl',",
            "                'password': 'password'",
            "            },",
            "            'user': {",
            "                'username': 'melle@iknl.nl',",
            "                'password': 'password'",
            "            },",
            "            'user-to-delete': {",
            "                'username': 'dont-use-me',",
            "                'password': 'password'",
            "            }",
            "        }",
            "",
            "    @classmethod",
            "    def tearDownClass(cls):",
            "        Database().clear_data()",
            "",
            "    @classmethod",
            "    def setUp(cls):",
            "        # set session.session",
            "        DatabaseSessionManager.get_session()",
            "",
            "    @classmethod",
            "    def tearDown(cls):",
            "        # unset session.session",
            "        DatabaseSessionManager.clear_session()",
            "",
            "    def login(self, type_='root'):",
            "        with self.server.app.test_client() as client:",
            "            tokens = client.post(",
            "                '/api/token/user',",
            "                json=self.credentials[type_]",
            "            ).json",
            "        if 'access_token' in tokens:",
            "            headers = {",
            "                'Authorization': 'Bearer {}'.format(tokens['access_token'])",
            "            }",
            "            return headers",
            "        else:",
            "            print('something wrong, during login:')",
            "            print(tokens)",
            "            return None",
            "",
            "    def create_user(self, organization=None, rules=[], password=\"password\"):",
            "",
            "        if not organization:",
            "            organization = Organization(name=str(uuid.uuid1()))",
            "            organization.save()",
            "",
            "        # user details",
            "        username = str(uuid.uuid1())",
            "",
            "        # create a temporary organization",
            "        user = User(username=username, password=password,",
            "                    organization=organization, email=f\"{username}@test.org\",",
            "                    rules=rules)",
            "        user.save()",
            "",
            "        self.credentials[username] = {",
            "            \"username\": username,",
            "            \"password\": password",
            "        }",
            "",
            "        return user",
            "",
            "    def create_node(self, organization=None, collaboration=None):",
            "        if not organization:",
            "            organization = Organization(name=str(uuid.uuid1()))",
            "",
            "        if not collaboration:",
            "            collaboration = Collaboration(name=str(uuid.uuid1()))",
            "",
            "        api_key = str(uuid1())",
            "        node = Node(",
            "            name=str(uuid1()),",
            "            api_key=api_key,",
            "            organization=organization,",
            "            collaboration=collaboration",
            "        )",
            "        node.save()",
            "",
            "        return node, api_key",
            "",
            "    def login_node(self, api_key):",
            "        tokens = self.app.post(",
            "            '/api/token/node',",
            "            json={\"api_key\": api_key}",
            "        ).json",
            "        if 'access_token' in tokens:",
            "            headers = {",
            "                'Authorization': 'Bearer {}'.format(tokens['access_token'])",
            "            }",
            "        else:",
            "            print(tokens)",
            "",
            "        return headers",
            "",
            "    def login_container(self, collaboration=None, organization=None,",
            "                        node=None, task=None, api_key=None):",
            "        if not node:",
            "            if not collaboration:",
            "                collaboration = Collaboration(name=str(uuid.uuid1()))",
            "            if not organization:",
            "                organization = Organization(name=str(uuid.uuid1()))",
            "            api_key = str(uuid1())",
            "            node = Node(organization=organization, collaboration=collaboration,",
            "                        api_key=api_key)",
            "            node.save()",
            "        else:",
            "            collaboration = node.collaboration",
            "            organization = node.organization",
            "",
            "        if not task:",
            "            task = Task(image=\"some-image\", collaboration=collaboration,",
            "                        runs=[Run(status=TaskStatus.PENDING)])",
            "            task.save()",
            "",
            "        headers = self.login_node(api_key)",
            "        tokens = self.app.post('/api/token/container', headers=headers, json={",
            "            \"image\": \"some-image\",",
            "            \"task_id\": task.id",
            "        }",
            "        ).json",
            "",
            "        if 'msg' in tokens:",
            "            print(tokens['msg'])",
            "",
            "        headers = {",
            "            'Authorization': 'Bearer {}'.format(tokens['container_token'])",
            "        }",
            "        return headers",
            "",
            "    def paginated_list(",
            "        self, url: str, headers: dict = None",
            "    ) -> tuple[Response, list]:",
            "        \"\"\"",
            "        Get all resources of a list endpoint by browsing through all pages",
            "",
            "        Parameters",
            "        ----------",
            "        url: str",
            "            The url of the list endpoint",
            "        headers: dict",
            "            The headers to use for the request",
            "",
            "        Returns",
            "        -------",
            "        tuple[flask.Response, list]",
            "            The response and the list of all resources",
            "        \"\"\"",
            "        result = self.app.get(url, headers=headers)",
            "        links = result.json.get('links')",
            "        page = 1",
            "        json_data = result.json['data']",
            "        while links and links.get('next'):",
            "            page += 1",
            "            new_response = self.app.get(",
            "                links.get('next'), headers=headers",
            "            )",
            "            json_data += new_response.json.get('data')",
            "            links = new_response.json.get('links')",
            "        return result, json_data",
            "",
            "    def create_node_and_login(self, *args, **kwargs):",
            "        node, api_key = self.create_node(*args, **kwargs)",
            "        return self.login_node(api_key)",
            "",
            "    def create_user_and_login(self, organization=None, rules=[]):",
            "        user = self.create_user(organization, rules)",
            "        return self.login(user.username)",
            "",
            "    def test_version(self):",
            "        rv = self.app.get('/api/version')",
            "        r = json.loads(rv.data)",
            "        self.assertIn('version', r)",
            "        self.assertEqual(r['version'], __version__)",
            "",
            "    def test_token_different_users(self):",
            "        for type_ in [\"root\", \"admin\", \"user\"]:",
            "            tokens = self.app.post(",
            "                '/api/token/user',",
            "                json=self.credentials[type_]",
            "            ).json",
            "            self.assertIn('access_token', tokens)",
            "            self.assertIn('refresh_token', tokens)",
            "",
            "    def test_organization(self):",
            "",
            "        rule = Rule.get_by_(\"organization\", Scope.GLOBAL,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "",
            "        # First retrieve a list of all organizations",
            "        _response, orgs = self.paginated_list('/api/organization', headers)",
            "        self.assertEqual(len(orgs), len(Organization.get()))",
            "",
            "        attrs = [",
            "            'id',",
            "            'name',",
            "            'domain',",
            "            'name',",
            "            'address1',",
            "            'address2',",
            "            'zipcode',",
            "            'country',",
            "        ]",
            "",
            "        org = orgs[0]",
            "        for attr in attrs:",
            "            self.assertIn(attr, org)",
            "",
            "        # Retrieve a single organization",
            "        url = f'/api/organization/{org[\"id\"]}'",
            "        org = self.app.get(url, headers=headers).json",
            "        self.assertEqual(org['id'], orgs[0]['id'])",
            "        self.assertEqual(org['name'], orgs[0]['name'])",
            "",
            "        # Create a new organization",
            "        org_details = {",
            "            'name': 'Umbrella Corporation',",
            "            'address1': 'Resident Evil Pike'",
            "        }",
            "",
            "        org = self.app.post(",
            "            '/api/organization',",
            "            json=org_details,",
            "            headers=headers",
            "        ).json",
            "",
            "        # for attr in attrs:",
            "        #     self.assertIn(attr, org)",
            "",
            "        # self.assertGreater(org['id'], 0)",
            "",
            "        orgs = self.app.get('/api/organization', headers=headers).json",
            "        # self.assertEqual(len(orgs), 4)",
            "",
            "    def test_collaboration(self):",
            "        org = Organization()",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "",
            "        collaborations = self.app.get(",
            "            '/api/collaboration', headers=headers",
            "        )",
            "        self.assertEqual(collaborations.status_code, HTTPStatus.OK)",
            "        db_cols = Collaboration.get()",
            "        self.assertEqual(len(collaborations.json['data']), len(db_cols))",
            "",
            "    def test_node_without_id(self):",
            "",
            "        # GET",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        nodes = self.app.get(\"/api/node\", headers=headers).json['data']",
            "        expected_fields = [",
            "            'name',",
            "            'collaboration',",
            "            'organization',",
            "            'status',",
            "            'id',",
            "            'type',",
            "            'last_seen',",
            "            'ip'",
            "        ]",
            "        for node in nodes:",
            "            for key in expected_fields:",
            "                self.assertIn(key, node)",
            "",
            "        nodes = self.app.get(\"/api/node\", headers=headers).json",
            "        self.assertIsNotNone(nodes)",
            "",
            "        # POST",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        # unknown collaboration id should fail",
            "        response = self.app.post(\"/api/node\", headers=headers, json={",
            "            \"collaboration_id\": 99999",
            "        })",
            "        response_json = response.json",
            "        self.assertIn(\"msg\", response_json)",
            "        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # succesfully create a node",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        response = self.app.post(\"/api/node\", headers=headers, json={",
            "            \"collaboration_id\": col.id",
            "        })",
            "        self.assertEqual(response.status_code, HTTPStatus.CREATED)",
            "",
            "    def test_node_with_id(self):",
            "",
            "        # root user can access all nodes",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        node = self.app.get(\"/api/node/8\", headers=headers).json",
            "        expected_fields = [",
            "            'name',",
            "            'collaboration',",
            "            'organization',",
            "            'status',",
            "            'id',",
            "            'type',",
            "            'last_seen',",
            "            'ip'",
            "        ]",
            "        for key in expected_fields:",
            "            self.assertIn(key, node)",
            "",
            "        # user cannot access all",
            "        headers = self.create_user_and_login()",
            "        node = self.app.get(\"/api/node/8\", headers=headers)",
            "        self.assertEqual(node.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # some nodes just don't exist",
            "        node = self.app.get(\"/api/node/9999\", headers=headers)",
            "        self.assertEqual(node.status_code, 404)",
            "",
            "    def test_result_with_id(self):",
            "        headers = self.login(\"root\")",
            "        run = self.app.get(\"/api/run/1\", headers=headers)",
            "        self.assertEqual(run.status_code, 200)",
            "",
            "        run = self.app.get(\"/api/run/1?include=task\", headers=headers)",
            "        self.assertEqual(run.status_code, 200)",
            "",
            "    def test_run_without_id(self):",
            "        headers = self.login(\"root\")",
            "        result1 = self.app.get(\"/api/run\", headers=headers)",
            "        self.assertEqual(result1.status_code, 200)",
            "",
            "        result2 = self.app.get(\"/api/run?state=open&&node_id=1\",",
            "                               headers=headers)",
            "        self.assertEqual(result2.status_code, 200)",
            "",
            "        result3 = self.app.get(\"/api/run?task_id=1\", headers=headers)",
            "        self.assertEqual(result3.status_code, 200)",
            "",
            "        result4 = self.app.get(\"/api/run?task_id=1&&node_id=1\",",
            "                               headers=headers)",
            "        self.assertEqual(result4.status_code, 200)",
            "",
            "    def test_stats(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/run\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_task_with_id(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/task/1\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_task_witout_id(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/task\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_task_including_runs(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/task?include=runs\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_task_unknown(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/task/9999\", headers=headers)",
            "        self.assertEqual(result.status_code, 404)",
            "",
            "    def test_user_with_id(self):",
            "        headers = self.login(\"admin\")",
            "        result = self.app.get(\"/api/user/1\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "        user = result.json",
            "",
            "        expected_fields = [",
            "            \"username\",",
            "            \"firstname\",",
            "            \"lastname\",",
            "            \"roles\"",
            "        ]",
            "        for field in expected_fields:",
            "            self.assertIn(field, user)",
            "",
            "    def test_user_unknown(self):",
            "        headers = self.login(\"admin\")",
            "        result = self.app.get(\"/api/user/9999\", headers=headers)",
            "        self.assertEqual(result.status_code, 404)",
            "",
            "    def test_user_without_id(self):",
            "        for role in [\"user\", \"admin\", \"root\"]:",
            "            headers = self.login(role)",
            "            result = self.app.get(\"/api/user\", headers=headers)",
            "            self.assertEqual(result.status_code, 200)",
            "",
            "    def test_user_post(self):",
            "        headers = self.login(\"root\")",
            "        new_user = {",
            "            \"username\": \"unittest\",",
            "            \"firstname\": \"unit\",",
            "            \"lastname\": \"test\",",
            "            \"email\": \"unit@test.org\",",
            "        }",
            "        # with a bad password, user should not be created",
            "        new_user['password'] = \"1234\"",
            "        result = self.app.post('/api/user', headers=headers, json=new_user)",
            "        self.assertEqual(result.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        new_user['password'] = \"Welkom01!\"",
            "        result = self.app.post(\"/api/user\", headers=headers,",
            "                               json=new_user)",
            "        self.assertEqual(result.status_code, 201)",
            "",
            "        result = self.app.post(\"/api/user\", headers=headers,",
            "                               json=new_user)",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "    def test_user_delete(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.delete(\"/api/user/5\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_user_delete_unknown(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.delete(\"/api/user/99999\", headers=headers)",
            "        self.assertEqual(result.status_code, 404)",
            "",
            "    def test_user_patch(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.patch(\"/api/user/2\", headers=headers, json={",
            "            \"firstname\": \"Henk\",",
            "            \"lastname\": \"Martin\"",
            "        })",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_user_patch_unknown(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.patch(\"/api/user/9999\", headers=headers, json={",
            "            \"username\": \"root2\"",
            "        })",
            "        self.assertEqual(result.status_code, 404)",
            "",
            "    def test_root_role_forbidden(self):",
            "        headers = self.login(\"root\")",
            "        new_user = {",
            "            \"username\": \"some\",",
            "            \"firstname\": \"guy\",",
            "            \"lastname\": \"there\",",
            "            \"roles\":  \"root\",",
            "            \"password\": \"super-secret\"",
            "        }",
            "        result = self.app.post(\"/api/user\", headers=headers,",
            "                               json=new_user)",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "    @patch(\"vantage6.server.mail_service.MailService.send_email\")",
            "    def test_reset_password(self, send_email):",
            "        user_ = {",
            "            \"username\": \"root\"",
            "        }",
            "        result = self.app.post(\"/api/recover/lost\", json=user_)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    @patch(\"vantage6.server.mail_service.MailService.send_email\")",
            "    def test_reset_password_missing_error(self, send_email):",
            "        result = self.app.post(\"/api/recover/lost\", json={})",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "    @patch(\"vantage6.server.resource.recover.decode_token\")",
            "    def test_recover_password(self, decode_token):",
            "        decode_token.return_value = {'sub': {'id': 1}}",
            "        new_password = {",
            "            \"password\": \"$Ecret88!\",",
            "            \"reset_token\": \"token\"",
            "        }",
            "        result = self.app.post(\"/api/recover/reset\", json=new_password)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "        # verify that the new password works",
            "        result = self.app.post(\"/api/token/user\", json={",
            "            \"username\": \"root\",",
            "            \"password\": \"$Ecret88!\"",
            "        })",
            "        self.assertIn(\"access_token\", result.json)",
            "        self.credentials[\"root\"][\"password\"] = \"$Ecret88!\"",
            "",
            "    def test_fail_recover_password(self):",
            "        result = self.app.post(\"/api/recover/reset\", json={})",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "    def test_change_password(self):",
            "        user = self.create_user(password=\"Password1!\")",
            "        headers = self.login(user.username)",
            "",
            "        # test if fails when not providing correct data",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"current_password\": \"Password1!\"",
            "        })",
            "        self.assertEqual(result.status_code, 400)",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"new_password\": \"a_new_password\"",
            "        })",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "        # test if fails when wrong password is provided",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"current_password\": \"Wrong_password1!\",",
            "            \"new_password\": \"A_new_password1!\"",
            "        })",
            "        self.assertEqual(result.status_code, 401)",
            "",
            "        # test if fails when new password is the same",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"current_password\": \"Password1!\",",
            "            \"new_password\": \"Password1!\"",
            "        })",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "        # test if it works when used as intended",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"current_password\": \"Password1!\",",
            "            \"new_password\": \"A_new_password1\"",
            "        })",
            "        self.assertEqual(result.status_code, 200)",
            "        session.session.refresh(user)",
            "        self.assertTrue(user.check_password(\"A_new_password1\"))",
            "",
            "    def test_view_rules(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/rule\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_view_roles(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/role\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "        body = result.json['data']",
            "        expected_fields = ['organization', 'name', 'description', 'users']",
            "        for field in expected_fields:",
            "            self.assertIn(field, body[0])",
            "",
            "    def test_create_role_as_root(self):",
            "        headers = self.login(\"root\")",
            "",
            "        # obtain available rules",
            "        rules = self.app.get(\"/api/rule\", headers=headers,",
            "                             query_string={'no_pagination': 1}).json['data']",
            "        rule_ids = [rule.get(\"id\") for rule in rules]",
            "",
            "        # assign first two rules to role",
            "        body = {",
            "            \"name\": \"some-role-name\",",
            "            \"description\": \"Testing if we can create a role\",",
            "            \"rules\": rule_ids[:2]",
            "        }",
            "",
            "        # create role",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "",
            "        # check that server responded ok",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # verify the values",
            "        self.assertEqual(result.json.get(\"name\"), body[\"name\"])",
            "        self.assertEqual(result.json.get(\"description\"), body[\"description\"])",
            "        result = self.app.get(",
            "            \"/api/rule\", headers=headers,",
            "            query_string={'role_id': result.json.get(\"id\")}",
            "        )",
            "        self.assertEqual(len(result.json.get('data')), 2)",
            "",
            "    def test_create_role_as_root_for_different_organization(self):",
            "        headers = self.login(\"root\")",
            "",
            "        # obtain available rules",
            "        rules = self.app.get(\"/api/rule\", headers=headers,",
            "                             query_string={'no_pagination': 1}).json['data']",
            "        # create new organization, so we're sure that the current user",
            "        # is not assigned to the same organization",
            "        org = Organization(name=\"Some-random-organization\")",
            "        org.save()",
            "",
            "        body = {",
            "            \"name\": \"some-role-name\",",
            "            \"description\": \"Testing if we can create a rol for another org\",",
            "            \"rules\": [rule.get(\"id\") for rule in rules],",
            "            \"organization_id\": org.id",
            "        }",
            "",
            "        # create role",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "",
            "        # check that server responded ok",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # verify the organization",
            "        self.assertEqual(org.id, result.json[\"organization\"][\"id\"])",
            "",
            "    def test_create_role_permissions(self):",
            "        all_rules = Rule.get()",
            "",
            "        # check user without any permissions",
            "        headers = self.create_user_and_login()",
            "",
            "        body = {",
            "            \"name\": \"some-role-name\",",
            "            \"description\": \"Testing if we can create a rol for another org\",",
            "            \"rules\": [rule.id for rule in all_rules],",
            "        }",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # check that user with a missing rule cannot create a role with that",
            "        # missing rule",
            "        headers = self.create_user_and_login(rules=(all_rules[:-2]))",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # check that user can create role within his organization",
            "        rule = Rule.get_by_(\"role\", scope=Scope.ORGANIZATION,",
            "                            operation=Operation.CREATE)",
            "",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        body[\"rules\"] = [rule.id]",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # check a non-existing organization",
            "        headers = self.login(\"root\")",
            "        body[\"organization_id\"] = 9999",
            "        result = self.app.post('/api/role', headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # check that assigning an unexisting rule is not possible",
            "        headers = self.create_user_and_login()",
            "        body[\"rules\"] = [9999]",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "    def test_edit_role(self):",
            "        headers = self.login('root')",
            "",
            "        # create testing entities",
            "        org = Organization(name=\"some-organization-name\")",
            "        org.save()",
            "        role = Role(name=\"some-role-name\", organization=org)",
            "        role.save()",
            "",
            "        # test name, description",
            "        result = self.app.patch(f'/api/role/{role.id}', headers=headers, json={",
            "            \"name\": \"a-different-role-name\",",
            "            \"description\": \"some description of this role...\"",
            "        })",
            "",
            "        session.session.refresh(role)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(role.name, \"a-different-role-name\")",
            "        self.assertEqual(role.description, \"some description of this role...\")",
            "",
            "        # test modifying rules",
            "        all_rule_ids = [rule.id for rule in Rule.get()]",
            "        result = self.app.patch(f'/api/role/{role.id}', headers=headers, json={",
            "            \"rules\": all_rule_ids",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertListEqual(all_rule_ids, [rule.id for rule in role.rules])",
            "",
            "        # test non owning rules",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION,",
            "                            Operation.EDIT)",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.patch(f\"/api/role/{role.id}\", headers=headers, json={",
            "            \"rules\": all_rule_ids",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test modifying role of another organization, without global",
            "        # permission",
            "        org2 = Organization(name=\"another-organization\")",
            "        headers = self.create_user_and_login(org2, [rule])",
            "        result = self.app.patch(f'/api/role/{role.id}', headers=headers, json={",
            "            \"name\": \"this-will-not-be-updated\"",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test modifying role with global permissions",
            "        rule = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(org2, [rule])",
            "        result = self.app.patch(f'/api/role/{role.id}', headers=headers, json={",
            "            \"name\": \"this-will-not-be-updated\"",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "    def test_remove_role(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        role = Role(organization=org)",
            "        role.save()",
            "",
            "        # test removal without permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.delete(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test removal with organization permissions",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION,",
            "                            Operation.DELETE)",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.delete(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test failed removal with organization permissions",
            "        role = Role(organization=org)  # because we removed it...",
            "        role.save()",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test removal with global permissions",
            "        rule = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "    def test_rules_from_role(self):",
            "        headers = self.login('root')",
            "        role = Role.get()[0]",
            "",
            "        result, json_data = self.paginated_list(",
            "            f'/api/role/{role.id}/rule', headers=headers",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(role.rules), len(json_data))",
            "",
            "        result = self.app.get('/api/role/9999/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "    def test_add_single_rule_to_role(self):",
            "        headers = self.login('root')",
            "",
            "        role = Role(name=\"empty\", organization=Organization())",
            "        role.save()",
            "",
            "        # role without rules",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(result.json['data']), 0)",
            "",
            "        rule = Rule.get()[0]",
            "",
            "        # try to add rule to non existing role",
            "        result = self.app.post(f'/api/role/9999/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to add non existent rule",
            "        result = self.app.post(f'/api/role/{role.id}/rule/9999',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # add a rule to a role",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # check that the role now has one rule",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(result.json['data']), 1)",
            "",
            "    def test_remove_single_rule_from_role(self):",
            "        headers = self.login('root')",
            "",
            "        rule = Rule.get()[0]",
            "        role = Role(name=\"unit\", organization=Organization(), rules=[rule])",
            "        role.save()",
            "",
            "        # try to add rule to non existing role",
            "        result = self.app.delete(f'/api/role/9999/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to add non existent rule",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/9999',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(result.json['data']), 1)",
            "",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(result.json), 0)",
            "",
            "    def test_view_permission_rules(self):",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION, Operation.VIEW)",
            "",
            "        role = Role(name=\"some-role\", organization=Organization())",
            "        role.save()",
            "",
            "        # user does not belong to organization",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # user does belong to the organization",
            "        headers = self.create_user_and_login(organization=role.organization,",
            "                                             rules=[rule])",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # user has global permissions",
            "        rule = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        role.delete()",
            "",
            "    def test_add_rule_to_role_permission(self):",
            "",
            "        role = Role(name=\"new-role\", organization=Organization())",
            "        role.save()",
            "",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION, Operation.EDIT)",
            "",
            "        # try adding a rule without any permission",
            "        headers = self.create_user_and_login()",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # you cant edit other organizations roles",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # you can edit other organizations with the global permission",
            "        rule = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # however you can only assign rules that you own",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION, Operation.EDIT)",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        role.delete()",
            "",
            "    def test_remove_rule_from_role_permissions(self):",
            "",
            "        role = Role(name=\"new-role\", organization=Organization())",
            "        role.save()",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION,",
            "                            Operation.DELETE)",
            "",
            "        # try removing without any permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try removing rule from other organization",
            "        headers = self.create_user_and_login(organization=Organization(),",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try removing rule which is not in the role",
            "        headers = self.create_user_and_login(organization=role.organization,",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        role.rules.append(rule)",
            "        role.save()",
            "",
            "        # lets try that again",
            "        headers = self.create_user_and_login(organization=role.organization,",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        role.rules.append(rule)",
            "        role.save()",
            "",
            "        # power users can edit other organization rules",
            "        power_rule = Rule.get_by_(\"role\", Scope.GLOBAL,",
            "                                  Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[power_rule, rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        role.delete()",
            "",
            "    def test_view_permission_user(self):",
            "",
            "        # user not found",
            "        headers = self.create_user_and_login()",
            "        result = self.app.get('/api/user/9999', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to view users without any permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.get('/api/user', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # root user can view all users",
            "        headers = self.login('root')",
            "        result, json_data = self.paginated_list('/api/user', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(json_data), len(User.get()))",
            "",
            "        # view users of your organization",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION, Operation.VIEW)",
            "        org = Organization.get(1)",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        result, json_data = self.paginated_list('/api/user', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(json_data), len(org.users))",
            "",
            "        # view a single user of your organization",
            "        user_id = org.users[0].id",
            "        result = self.app.get(f'/api/user/{user_id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # user can view their own data. This should always be possible",
            "        user = self.create_user(rules=[])",
            "        headers = self.login(user.username)",
            "        result = self.app.get(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "    def test_bounce_existing_username_and_email(self):",
            "        headers = self.create_user_and_login()",
            "        User(username=\"something\", email=\"mail@me.org\").save()",
            "        userdata = {",
            "            \"username\": \"not-important\",",
            "            \"firstname\": \"name\",",
            "            \"lastname\": \"lastname\",",
            "            \"password\": \"welkom01\",",
            "            \"email\": \"mail@me.org\"",
            "        }",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        userdata['username'] = 'not-important'",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "    def test_new_permission_user(self):",
            "        userdata = {",
            "            \"username\": \"smarty\",",
            "            \"firstname\": \"Smart\",",
            "            \"lastname\": \"Pants\",",
            "            \"password\": \"Welkom01!\",",
            "            \"email\": \"mail-us@me.org\"",
            "        }",
            "",
            "        # Creating users for other organizations can only be by global scope",
            "        org = Organization()",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION,",
            "                            Operation.CREATE)",
            "        userdata['organization_id'] = 1",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # you can do that when you have the global scope",
            "        gl_rule = Rule.get_by_(\"user\", Scope.GLOBAL, Operation.CREATE)",
            "        userdata['rules'] = [gl_rule.id]",
            "        headers = self.create_user_and_login(org, rules=[gl_rule])",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # you need to own all rules in order to assign them",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        userdata['username'] = 'smarty2'",
            "        userdata['email'] = 'mail2@me.org'",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # you can only assign roles in which you have all rules",
            "        rule_view_roles = Rule.get_by_(",
            "            \"role\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(",
            "            org, rules=[rule, rule_view_roles])",
            "        role = Role(rules=[rule], organization=org)",
            "        role.save()",
            "        userdata['username'] = 'smarty3'",
            "        userdata['email'] = 'mail3@me.org'",
            "        userdata['roles'] = [role.id]",
            "        del userdata['organization_id']",
            "        del userdata['rules']",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "        # verify that user has the role",
            "        result = self.app.get('/api/role', headers=headers,",
            "                              query_string={'user_id': result.json['id']})",
            "        self.assertEqual(len(result.json['data']), 1)",
            "",
            "    def test_patch_user_permissions(self):",
            "",
            "        org = Organization()",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=org)",
            "        user.save()",
            "        self.credentials[user.username] = {'username': user.username,",
            "                                           'password': \"Password\"}",
            "",
            "        # check non-existing user",
            "        headers = self.create_user_and_login()",
            "        result = self.app.patch('/api/user/9999', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # patching without permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'this-aint-gonna-fly'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        self.assertEqual(\"Username\", user.username)",
            "",
            "        # patch as a user of other organization",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION, Operation.EDIT)",
            "        self.create_user_and_login(rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'this-aint-gonna-fly'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        self.assertEqual(\"Username\", user.username)",
            "",
            "        # patch as another user from the same organization",
            "        rule = Rule.get_by_(\"user\", Scope.OWN, Operation.EDIT)",
            "        self.create_user_and_login(user.organization, [rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'this-aint-gonna-fly'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        self.assertEqual(\"Username\", user.username)",
            "",
            "        # edit 'simple' fields",
            "        rule = Rule.get_by_(\"user\", Scope.OWN, Operation.EDIT)",
            "        user.rules.append(rule)",
            "        user.save()",
            "        headers = self.login(user.username)",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'yeah'",
            "        })",
            "        session.session.refresh(user)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(\"yeah\", user.firstname)",
            "",
            "        # edit other user within your organization",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION, Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=user.organization,",
            "                                             rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'whatever'",
            "        })",
            "        session.session.refresh(user)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(\"whatever\", user.firstname)",
            "",
            "        # check that password cannot be edited",
            "        rule = Rule.get_by_(\"user\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'password': 'keep-it-safe'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # edit user from different organization, and test other edit fields",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'again',",
            "            'lastname': 'and again',",
            "        })",
            "        session.session.refresh(user)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(\"again\", user.firstname)",
            "        self.assertEqual(\"and again\", user.lastname)",
            "",
            "        # test that you cannot assign rules that you not own",
            "        not_owning_rule = Rule.get_by_(\"user\", Scope.OWN,",
            "                                       Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [not_owning_rule.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you cannot assign role that has rules that you do not own",
            "        role = Role(name=\"somename\", rules=[not_owning_rule],",
            "                    organization=org)",
            "        role.save()",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [role.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you cannot assign rules if you don't have all the rules",
            "        # that the other user has",
            "        headers = self.create_user_and_login(rules=[rule, not_owning_rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [not_owning_rule.id, rule.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you CAN change the rules. To do so, a user is generated",
            "        # that has same rules as current user, but also rule to edit other",
            "        # users and another one current user does not possess",
            "        assigning_user_rules = user.rules",
            "        assigning_user_rules.append(",
            "            Rule.get_by_(\"user\", Scope.GLOBAL, Operation.EDIT),",
            "        )",
            "        assigning_user_rules.append(not_owning_rule)",
            "        headers = self.create_user_and_login(rules=assigning_user_rules)",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [not_owning_rule.id, rule.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        result = self.app.get('/api/rule', headers=headers,",
            "                              query_string={'user_id': user.id})",
            "        user_rule_ids = [",
            "            rule['id'] for rule in result.json.get('data')",
            "        ]",
            "        self.assertIn(not_owning_rule.id, user_rule_ids)",
            "",
            "        # test that you cannot assign roles if you don't have all the",
            "        # permissions for that role yourself (even though you have permission",
            "        # to assign roles)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'roles': [role.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you CAN assign roles",
            "        rule_global_view = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(",
            "            rules=[rule, not_owning_rule, rule_global_view]",
            "        )",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'roles': [role.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        result = self.app.get('/api/role', headers=headers,",
            "                              query_string={'user_id': user.id})",
            "        user_role_ids = [",
            "            role['id'] for role in result.json.get('data')",
            "        ]",
            "        self.assertIn(role.id, user_role_ids)",
            "",
            "        # test that you CANNOT assign roles from different organization",
            "        other_org_role = Role(name=\"somename\", rules=[not_owning_rule],",
            "                              organization=Organization())",
            "        headers = self.create_user_and_login(rules=[rule, not_owning_rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'roles': [other_org_role.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test missing role",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'roles': [9999]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test missing rule",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [9999]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        user.delete()",
            "        role.delete()",
            "",
            "    def test_delete_user_permissions(self):",
            "",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=Organization())",
            "        user.save()",
            "        self.credentials[user.username] = {'username': user.username,",
            "                                           'password': \"Password\"}",
            "",
            "        # check non-exsitsing user",
            "        headers = self.create_user_and_login()",
            "        result = self.app.delete('/api/user/9999', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to delete without any permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # same organization but missing permissions",
            "        rule = Rule.get_by_(\"user\", Scope.OWN, Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=user.organization,",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # other organization with organization scope",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION,",
            "                            Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=Organization(),",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # delete yourself",
            "        rule = Rule.get_by_(\"user\", Scope.OWN, Operation.DELETE)",
            "        user.rules.append(rule)",
            "        user.save()",
            "        headers = self.login(user.username)",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        # User is deleted by the endpoint! user.delete()",
            "",
            "        # delete colleague",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=Organization())",
            "        user.save()",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION,",
            "                            Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule],",
            "                                             organization=user.organization)",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        # User is deleted by the endpoint user.delete()",
            "",
            "        # delete as root",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=Organization())",
            "        user.save()",
            "        rule = Rule.get_by_(\"user\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        # user is deleted by endpoint! user.delete()",
            "",
            "    def test_view_organization_as_user_permissions(self):",
            "",
            "        # view without any permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.get('/api/organization', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # view your own organization",
            "        rule = Rule.get_by_(\"organization\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        user = self.create_user(rules=[rule])",
            "        headers = self.login(user.username)",
            "        result = self.app.get(f'/api/organization/{user.organization.id}',",
            "                              headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # try to view another organization without permission",
            "        org = Organization()",
            "        org.save()",
            "        result = self.app.get(f'/api/organization/{org.id}',",
            "                              headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # Missing organization with global view",
            "        rule = Rule.get_by_(\"organization\", Scope.GLOBAL,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get('/api/organization/9999',",
            "                              headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test global view",
            "        result = self.app.get(f'/api/organization/{org.id}',",
            "                              headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_organization_as_node_permission(self):",
            "        node, api_key = self.create_node()",
            "        headers = self.login_node(api_key)",
            "",
            "        # test list organization with only your organization",
            "        result = self.app.get('/api/organization', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(result.json['data'][0]['id'], node.organization.id)",
            "",
            "        # test list organization",
            "        result = self.app.get(",
            "            f'/api/organization/{node.organization.id}',",
            "            headers=headers",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(result.json['id'], node.organization.id)",
            "        node.delete()",
            "",
            "    def test_view_organization_as_container_permission(self):",
            "        node, api_key = self.create_node()",
            "        headers = self.login_container(node=node, api_key=api_key)",
            "",
            "        # try to get organization where he runs",
            "        result = self.app.get(",
            "            f'/api/organization/{node.organization.id}',",
            "            headers=headers",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(result.json['id'], node.organization.id)",
            "",
            "        # get all organizations in the collaboration",
            "        result = self.app.get(",
            "            '/api/organization',",
            "            headers=headers",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertIsInstance(result.json['data'], list)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_create_organization_permissions(self):",
            "",
            "        # try creating an organization without permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.post('/api/organization', headers=headers, json={",
            "            'name': 'this-aint-gonna-happen'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # create an organization",
            "        rule = Rule.get_by_(\"organization\", Scope.GLOBAL,",
            "                            Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.post('/api/organization', headers=headers, json={",
            "            'name': 'this-is-gonna-happen'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "        self.assertIsNotNone(Organization.get_by_name(\"this-is-gonna-happen\"))",
            "",
            "    def test_patch_organization_permissions(self):",
            "",
            "        # unknown organization",
            "        headers = self.create_user_and_login()",
            "        results = self.app.patch('/api/organization/9999', headers=headers,",
            "                                 json={})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to change anything without permissions",
            "        org = Organization(name=\"first-name\")",
            "        org.save()",
            "        results = self.app.patch(f'/api/organization/{org.id}',",
            "                                 headers=headers, json={})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # change as super user",
            "        rule = Rule.get_by_(\"organization\", Scope.GLOBAL,",
            "                            Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f'/api/organization/{org.id}',",
            "                                 headers=headers, json={",
            "                                     \"name\": \"second-name\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], \"second-name\")",
            "",
            "        # change as organization editor",
            "        rule = Rule.get_by_(\"organization\", Scope.ORGANIZATION,",
            "                            Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.patch(f'/api/organization/{org.id}',",
            "                                 headers=headers, json={",
            "                                     \"name\": \"third-name\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], \"third-name\")",
            "",
            "        # change other organization as organization editor",
            "        rule = Rule.get_by_(\"organization\", Scope.ORGANIZATION,",
            "                            Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f'/api/organization/{org.id}',",
            "                                 headers=headers, json={",
            "                                     \"name\": \"third-name\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "    def test_organization_view_nodes(self):",
            "",
            "        # create organization, collaboration and node",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        org.save()",
            "        col = Collaboration(name=str(uuid.uuid1()), organizations=[org])",
            "        col.save()",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        # try to view without permissions",
            "        headers = self.create_user_and_login(org)",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view with organization permissions",
            "        rule = Rule.get_by_(\"node\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # try to view other organization",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view with global permissions",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # try to view as node",
            "        headers = self.create_node_and_login(organization=org)",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # try to view as node from another organization",
            "        headers = self.create_node_and_login()",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_organization_view_collaboration_permissions(self):",
            "",
            "        # test unknown organization",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get('/api/organization/9999/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test view without any permission",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test view with organization scope",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test view with organization scope other organiation",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test view with global scope",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test as node",
            "        headers = self.create_node_and_login(organization=org,",
            "                                             collaboration=col)",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_collaboration_permissions(self):",
            "",
            "        # setup organization and collaboration",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # try view the collaboration without any permissions",
            "        headers = self.create_user_and_login(organization=org)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view it with organization permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # try to view it from an outside organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # view it with global view permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test access as node",
            "        headers = self.create_node_and_login(organization=org,",
            "                                             collaboration=col)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test access as container",
            "        headers = self.login_container(collaboration=col, organization=org)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        org.delete()",
            "        col.delete()",
            "",
            "    def test_edit_collaboration_permissions(self):",
            "",
            "        # test an unknown collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.patch(\"/api/collaboration/9999\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test editing without any permission",
            "        col = Collaboration(name=\"collaboration-1\")",
            "        col.save()",
            "        headers = self.create_user_and_login()",
            "        results = self.app.patch(f\"/api/collaboration/{col.id}\",",
            "                                 headers=headers, json={",
            "                                     \"name\": \"this-aint-gonna-fly\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test editing with global permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f\"/api/collaboration/{col.id}\",",
            "                                 headers=headers, json={",
            "                                     \"name\": \"this-is-gonna-fly\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json[\"name\"], \"this-is-gonna-fly\")",
            "",
            "    def test_delete_collaboration_permissions(self):",
            "",
            "        col = Collaboration()",
            "        col.save()",
            "",
            "        # test deleting unknown collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.delete(\"/api/collaboration/9999\",",
            "                                  headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test deleting without permission",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}\",",
            "                                  headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test deleting with permission",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}\",",
            "                                  headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_collaboration_organization_permissions_as_user(self):",
            "        headers = self.create_user_and_login()",
            "",
            "        # non-existing collaboration",
            "        results = self.app.get(\"/api/collaboration/9999/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # access without the proper permissions",
            "        headers = self.create_user_and_login(organization=org)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # global permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # organization permissions of another organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # now with the correct organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_collaboration_organization_permissions_as_node(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # node of a different organization",
            "        headers = self.create_node_and_login()",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # node of the correct organization",
            "        headers = self.create_node_and_login(organization=org,",
            "                                             collaboration=col)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_collaboration_organization_permissions_as_container(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # node of a different organization",
            "        headers = self.login_container()",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        headers = self.login_container(organization=org, collaboration=col)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_edit_collaboration_organization_permissions(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        org2 = Organization()",
            "        org2.save()",
            "",
            "        # try to do it without permission",
            "        headers = self.create_user_and_login()",
            "        results = self.app.post(f\"/api/collaboration/{col.id}/organization\",",
            "                                headers=headers, json={'id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # edit permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post(f\"/api/collaboration/{col.id}/organization\",",
            "                                headers=headers, json={'id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json), 2)",
            "",
            "    def test_delete_collaboration_organization_pesmissions(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # try to do it without permission",
            "        headers = self.create_user_and_login()",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}/organization\",",
            "                                  headers=headers, json={'id': org.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # delete it!",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}/organization\",",
            "                                  headers=headers, json={'id': org.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json, [])",
            "",
            "    def test_view_collaboration_node_permissions(self):",
            "",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        col = Collaboration(name=str(uuid.uuid1()), organizations=[org])",
            "        node = Node(collaboration=col, organization=org)",
            "        node.save()",
            "",
            "        # try to view an non-existant collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get(\"/api/collaboration/9999/node\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to view without any permissions",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view from another organzization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view from another organization with global permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.nodes))",
            "",
            "        # try to view from your organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule], organization=org)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_add_collaboration_node_permissions(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "        node = Node(organization=org)",
            "        node.save()",
            "",
            "        # try non-existant collaboration",
            "        headers = self.create_user_and_login()",
            "",
            "        results = self.app.post('/api/collaboration/9999/node',",
            "                                headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try without proper permissions",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to add non-existing node",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': 9999})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # add a node!",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "        self.assertEqual(len(results.json), len(col.nodes))",
            "",
            "        # try to add a node thats already in there",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_delete_collaboration_node_permissions(self):",
            "",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        # try non-existant collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.delete('/api/collaboration/9999/node',",
            "                                  headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try without proper permissions",
            "        results = self.app.delete(f'/api/collaboration/{col.id}/node',",
            "                                  headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to add non-existing node",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/collaboration/{col.id}/node',",
            "                                  headers=headers, json={'id': 9999})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to add a node thats not in there",
            "        node2 = Node()",
            "        node2.save()",
            "        results = self.app.delete(f'/api/collaboration/{col.id}/node',",
            "                                  headers=headers, json={'id': node2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # delete a node!",
            "        results = self.app.delete(f'/api/collaboration/{col.id}/node',",
            "                                  headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        node.delete()",
            "        node2.delete()",
            "",
            "    def test_view_collaboration_task_permissions_as_user(self):",
            "",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        task = Task(collaboration=col)",
            "        task.save()",
            "",
            "        # view non existing collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get('/api/collaboration/9999/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # view without any permission",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # view from another organization",
            "        rule = Rule.get_by_(\"task\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # view from your own organization",
            "        headers = self.create_user_and_login(rules=[rule], organization=org)",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.tasks))",
            "",
            "        # view with global permissions",
            "        rule = Rule.get_by_(\"task\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.tasks))",
            "",
            "    def test_view_collaboration_task_permissions_as_node(self):",
            "",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        node, api_key = self.create_node(org, col)",
            "        task = Task(collaboration=col)",
            "        task.save()",
            "",
            "        headers = self.login_node(api_key)",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_view_node_permissions_as_user(self):",
            "",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        # view non existing node",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get('/api/node/9999', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # missing permissions",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # organization permissions",
            "        rule1 = Rule.get_by_(\"node\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule1])",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # organization permissions from another organization",
            "        headers = self.create_user_and_login(rules=[rule1])",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # global permissions",
            "        rule2 = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule2])",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # list organization permissions",
            "        headers = self.create_user_and_login(organization=org, rules=[rule1])",
            "        results = self.app.get('/api/node', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.nodes))",
            "",
            "        # list global permissions",
            "        headers = self.create_user_and_login(rules=[rule2])",
            "        results, json_data = self.paginated_list('/api/node', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(json_data), len(Node.get()))",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_view_node_permissions_as_node(self):",
            "",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        node, api_key = self.create_node(org, col)",
            "",
            "        headers = self.login_node(api_key)",
            "",
            "        # global permissions",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # list organization permissions",
            "        results = self.app.get('/api/node', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(org.nodes))",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_create_node_permissions(self):",
            "",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "        org2 = Organization(name=str(uuid.uuid1()))",
            "        org2.save()",
            "",
            "        # test non existing collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.post('/api/node', headers=headers,",
            "                                json={'collaboration_id': 9999})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test creating a node without any permissions",
            "        headers = self.create_user_and_login()",
            "        results = self.app.post('/api/node', headers=headers,",
            "                                json={'collaboration_id': col.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # testing creating a node with organization permissions and supplying",
            "        # an organization id",
            "        rule = Rule.get_by_(\"node\", Scope.ORGANIZATION, Operation.CREATE)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id,",
            "            'organization_id': org.id",
            "        })",
            "",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "        node_id = results.json.get('id')",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id,",
            "            'organization_id': org2.id  # <-------",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test adding a node to an collaboration from an organization witch",
            "        # does not belong to the collaboration",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # check an creating an already existing node",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # lets retry that",
            "        node = Node.get(node_id)",
            "        node.delete()",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "        # test global permissions",
            "        col.organizations.append(org2)",
            "        col.save()",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id,",
            "            'organization_id': org2.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "    def test_delete_node_permissions(self):",
            "",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        col = Collaboration(name=str(uuid.uuid1()), organizations=[org])",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        # unexisting node",
            "        headers = self.create_user_and_login()",
            "        results = self.app.delete('/api/node/9999', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # organization permission other organization",
            "        rule = Rule.get_by_('node', Scope.ORGANIZATION, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # organization permission",
            "        rule = Rule.get_by_('node', Scope.ORGANIZATION, Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.delete(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # global permission",
            "        org2 = Organization(name=str(uuid.uuid1()))",
            "        node2 = Node(organization=org2, collaboration=col)",
            "        node2.save()",
            "        rule = Rule.get_by_('node', Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/node/{node2.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_patch_node_permissions_as_user(self):",
            "        # test patching non-existant node",
            "        headers = self.create_user_and_login()",
            "        results = self.app.patch(\"/api/node/9999\", headers=headers, json={})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test user without any permissions",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test user with global permissions",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={\"name\": \"A\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], \"A\")",
            "",
            "        # test user with org permissions and own organization",
            "        rule = Rule.get_by_(\"node\", Scope.ORGANIZATION, Operation.EDIT)",
            "        headers = self.create_user_and_login(org, [rule])",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={'name': 'B'})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], \"B\")",
            "",
            "        # test user with org permissions and other organization",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={'name': 'C'})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test updatin the `organization_id` with organization permissions",
            "        org2 = Organization()",
            "        org2.save()",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={'organization_id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test assigning it to a node thats not part of the collaborat",
            "        col2 = Collaboration(organizations=[org2])",
            "        col2.save()",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={'collaboration_id': col2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # collaboration_id and organization_id. Note that the organization",
            "        # is assigned before the collaboration is defined.",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(org2, rules=[rule])",
            "        results = self.app.patch(f'/api/node/{node.id}', headers=headers,",
            "                                 json={'collaboration_id': col2.id,",
            "                                       'organization_id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['organization']['id'], org2.id)",
            "        self.assertEqual(results.json['collaboration']['id'], col2.id)",
            "",
            "        # try to patch the node's VPN IP address",
            "        results = self.app.patch(f'/api/node/{node.id}', headers=headers,",
            "                                 json={'ip': '0.0.0.0'})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['ip'], '0.0.0.0')",
            "",
            "        # assign unknow organization",
            "        results = self.app.patch(f'/api/node/{node.id}', headers=headers,",
            "                                 json={'organization_id': 9999})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_view_task_permissions_as_user(self):",
            "        # non existing task",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get('/api/task/9999', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test user without any permissions and id",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        task = Task(name=\"unit\", collaboration=col)",
            "        task.save()",
            "",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test user with org permissions with id",
            "        rule = Rule.get_by_(\"task\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], 'unit')",
            "",
            "        # test user with org permissions with id from another org",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test user with org permissions without id",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test user with global permissions and id",
            "        rule = Rule.get_by_(\"task\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test user with global permissions without id",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_task_permissions_as_node_and_container(self):",
            "        # test node with id",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "        task = Task(collaboration=col, image=\"some-image\")",
            "        task.save()",
            "        res = Run(task=task, status=TaskStatus.PENDING)",
            "        res.save()",
            "",
            "        headers = self.create_node_and_login(organization=org)",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test node without id",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test container with id",
            "        headers = self.login_container(collaboration=col, organization=org,",
            "                                       task=task)",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test container without id",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_create_task_permission_as_user(self):",
            "        # non existant collaboration",
            "        headers = self.create_user_and_login()",
            "        input_ = {'method': 'dummy'}",
            "        task_json = {",
            "            \"collaboration_id\": 9999,",
            "            \"organizations\": [{'id': 9999, 'input': input_}],",
            "            \"image\": \"some-image\"",
            "        }",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # organizations outside of collaboration",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # task without any node created",
            "        task_json[\"organizations\"] = [{'id': org.id, 'input': input_}]",
            "        task_json[\"collaboration_id\"] = col.id",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # node is used implicitly as in further checks, can only create task",
            "        # if node has been created",
            "        node = Node(organization=org, collaboration=col)",
            "",
            "        org2 = Organization()",
            "        org2.save()",
            "",
            "        task_json[\"organizations\"] = [{'id': org2.id, 'input': input_}]",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # user without any permissions",
            "        task_json[\"organizations\"] = [{'id': org.id, 'input': input_}]",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # user with organization permissions for other organization",
            "        rule = Rule.get_by_(\"task\", Scope.ORGANIZATION, Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # user with organization permissions",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "        # user with global permissions but outside of the collaboration. They",
            "        # should *not* be allowed to create a task in a collaboration that",
            "        # they're not a part of",
            "        # TODO add test for user with global permission that creates a task for",
            "        # another organization than their own in the same collaboration",
            "        rule = Rule.get_by_(\"task\", Scope.GLOBAL, Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_create_task_permissions_as_container(self):",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        parent_task = Task(collaboration=col, image=\"some-image\")",
            "        parent_task.save()",
            "        parent_res = Run(organization=org, task=parent_task,",
            "                         status=TaskStatus.PENDING)",
            "        parent_res.save()",
            "",
            "        # test wrong image name",
            "        input_ = {'method': 'dummy'}",
            "        headers = self.login_container(collaboration=col, organization=org,",
            "                                       task=parent_task)",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col.id,",
            "            'image': 'other-image'",
            "        })",
            "",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test other collaboration_id",
            "        col2 = Collaboration(organizations=[org])",
            "        col2.save()",
            "        node2 = Node(organization=org, collaboration=col2)",
            "        node2.save()",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col2.id,",
            "            'image': 'some-image'",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test with correct parameters",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col.id,",
            "            'image': 'some-image'",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "        # test already completed task",
            "        parent_res.status = TaskStatus.COMPLETED",
            "        parent_res.save()",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col.id,",
            "            'image': 'some-image'",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test a failed task",
            "        parent_res.status = TaskStatus.FAILED",
            "        parent_res.save()",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col.id,",
            "            'image': 'some-image'",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node2.delete()",
            "",
            "    def test_delete_task_permissions(self):",
            "",
            "        # test non-existing task",
            "        headers = self.create_user_and_login()",
            "        self.app.delete('/api/task/9999', headers=headers)",
            "",
            "        # test with organization permissions from other organization",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        task = Task(collaboration=col)",
            "        task.save()",
            "",
            "        rule = Rule.get_by_(\"task\", Scope.ORGANIZATION, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test with organization permissions",
            "        headers = self.create_user_and_login(org, [rule])",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test with global permissions",
            "        task = Task(collaboration=col)",
            "        task.save()",
            "        rule = Rule.get_by_(\"task\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test that all results are also deleted",
            "        task = Task(collaboration=col)",
            "        run = Run(task=task)",
            "        run.save()",
            "        run_id = run.id  # cannot access this after deletion",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertIsNone(Task.get(run_id))",
            "",
            "    def test_view_task_result_permissions_as_user(self):",
            "",
            "        # non-existing task",
            "        headers = self.create_user_and_login()",
            "        result = self.app.get('/api/task/9999/run', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test with organization permissions from other organization",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        task = Task(collaboration=col)",
            "        # NB: node is used implicitly in task/{id}/result schema",
            "        node = Node(organization=org, collaboration=col)",
            "        res = Run(task=task, organization=org)",
            "        res.save()",
            "",
            "        rule = Rule.get_by_(\"run\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(len(result.json['data']), 0)",
            "",
            "        # test with organization permission",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test with global permission",
            "        rule = Rule.get_by_(\"run\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test also result endpoint",
            "        rule = Rule.get_by_(\"run\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(",
            "            f'/api/result?task_id={task.id}', headers=headers)",
            "        self.assertEqual(len(result.json['data']), 0)",
            "",
            "        # test with organization permission",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.get(",
            "            f'/api/result?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test with global permission",
            "        rule = Rule.get_by_(\"run\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(",
            "            f'/api/result?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_view_task_run_permissions_as_container(self):",
            "        # test if container can",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        task = Task(collaboration=col, image=\"some-image\")",
            "        task.save()",
            "        res = Run(task=task, organization=org, status=TaskStatus.PENDING)",
            "        res.save()",
            "",
            "        headers = self.login_container(collaboration=col, organization=org,",
            "                                       task=task)",
            "        results = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from uuid import uuid1",
            "import yaml",
            "import unittest",
            "import logging",
            "import json",
            "import uuid",
            "",
            "from http import HTTPStatus",
            "from unittest.mock import patch",
            "from flask import Response as BaseResponse",
            "from flask.testing import FlaskClient",
            "from flask_socketio import SocketIO",
            "from werkzeug.utils import cached_property",
            "",
            "from vantage6.common import logger_name",
            "from vantage6.common.globals import APPNAME",
            "from vantage6.common.task_status import TaskStatus",
            "from vantage6.server.globals import PACKAGE_FOLDER",
            "from vantage6.server import ServerApp, session",
            "from vantage6.server.model import (Rule, Role, Organization, User, Node,",
            "                                   Collaboration, Task, Run)",
            "from vantage6.server.model.rule import Scope, Operation",
            "from vantage6.server import context",
            "from vantage6.server._version import __version__",
            "from vantage6.server.model.base import Database, DatabaseSessionManager",
            "from vantage6.server.controller.fixture import load",
            "",
            "",
            "logger = logger_name(__name__)",
            "log = logging.getLogger(logger)",
            "",
            "",
            "class Response(BaseResponse):",
            "    @cached_property",
            "    def json(self):",
            "        return json.loads(self.data)",
            "",
            "",
            "class TestNode(FlaskClient):",
            "    def open(self, *args, **kwargs):",
            "        if 'json' in kwargs:",
            "            kwargs['data'] = json.dumps(kwargs.pop('json'))",
            "            kwargs['content_type'] = 'application/json'",
            "        return super().open(*args, **kwargs)",
            "",
            "",
            "class TestResources(unittest.TestCase):",
            "",
            "    @classmethod",
            "    def setUpClass(cls):",
            "        \"\"\"Called immediately before running a test method.\"\"\"",
            "        Database().connect(\"sqlite://\", allow_drop_all=True)",
            "",
            "        ctx = context.TestContext.from_external_config_file()",
            "",
            "        # create server instance. Patch the start_background_task method",
            "        # to prevent the server from starting a ping/pong thread that will",
            "        # prevent the tests from starting",
            "        with patch.object(SocketIO, 'start_background_task'):",
            "            server = ServerApp(ctx)",
            "        cls.server = server",
            "",
            "        file_ = str(PACKAGE_FOLDER / APPNAME / \"server\" / \"_data\" /",
            "                    \"unittest_fixtures.yaml\")",
            "        with open(file_) as f:",
            "            cls.entities = yaml.safe_load(f.read())",
            "        load(cls.entities)",
            "",
            "        server.app.testing = True",
            "        cls.app = server.app.test_client()",
            "",
            "        cls.credentials = {",
            "            'root': {",
            "                'username': 'root',",
            "                'password': 'root'",
            "            },",
            "            'admin': {",
            "                'username': 'frank@iknl.nl',",
            "                'password': 'password'",
            "            },",
            "            'user': {",
            "                'username': 'melle@iknl.nl',",
            "                'password': 'password'",
            "            },",
            "            'user-to-delete': {",
            "                'username': 'dont-use-me',",
            "                'password': 'password'",
            "            }",
            "        }",
            "",
            "    @classmethod",
            "    def tearDownClass(cls):",
            "        Database().clear_data()",
            "",
            "    @classmethod",
            "    def setUp(cls):",
            "        # set session.session",
            "        DatabaseSessionManager.get_session()",
            "",
            "    @classmethod",
            "    def tearDown(cls):",
            "        # unset session.session",
            "        DatabaseSessionManager.clear_session()",
            "",
            "    def login(self, type_='root'):",
            "        with self.server.app.test_client() as client:",
            "            tokens = client.post(",
            "                '/api/token/user',",
            "                json=self.credentials[type_]",
            "            ).json",
            "        if 'access_token' in tokens:",
            "            headers = {",
            "                'Authorization': 'Bearer {}'.format(tokens['access_token'])",
            "            }",
            "            return headers",
            "        else:",
            "            print('something wrong, during login:')",
            "            print(tokens)",
            "            return None",
            "",
            "    def create_user(self, organization=None, rules=[], password=\"password\"):",
            "",
            "        if not organization:",
            "            organization = Organization(name=str(uuid.uuid1()))",
            "            organization.save()",
            "",
            "        # user details",
            "        username = str(uuid.uuid1())",
            "",
            "        # create a temporary organization",
            "        user = User(username=username, password=password,",
            "                    organization=organization, email=f\"{username}@test.org\",",
            "                    rules=rules)",
            "        user.save()",
            "",
            "        self.credentials[username] = {",
            "            \"username\": username,",
            "            \"password\": password",
            "        }",
            "",
            "        return user",
            "",
            "    def create_node(self, organization=None, collaboration=None):",
            "        if not organization:",
            "            organization = Organization(name=str(uuid.uuid1()))",
            "",
            "        if not collaboration:",
            "            collaboration = Collaboration(name=str(uuid.uuid1()))",
            "",
            "        api_key = str(uuid1())",
            "        node = Node(",
            "            name=str(uuid1()),",
            "            api_key=api_key,",
            "            organization=organization,",
            "            collaboration=collaboration",
            "        )",
            "        node.save()",
            "",
            "        return node, api_key",
            "",
            "    def login_node(self, api_key):",
            "        tokens = self.app.post(",
            "            '/api/token/node',",
            "            json={\"api_key\": api_key}",
            "        ).json",
            "        if 'access_token' in tokens:",
            "            headers = {",
            "                'Authorization': 'Bearer {}'.format(tokens['access_token'])",
            "            }",
            "        else:",
            "            print(tokens)",
            "",
            "        return headers",
            "",
            "    def login_container(self, collaboration=None, organization=None,",
            "                        node=None, task=None, api_key=None):",
            "        if not node:",
            "            if not collaboration:",
            "                collaboration = Collaboration(name=str(uuid.uuid1()))",
            "            if not organization:",
            "                organization = Organization(name=str(uuid.uuid1()))",
            "            api_key = str(uuid1())",
            "            node = Node(organization=organization, collaboration=collaboration,",
            "                        api_key=api_key)",
            "            node.save()",
            "        else:",
            "            collaboration = node.collaboration",
            "            organization = node.organization",
            "",
            "        if not task:",
            "            task = Task(image=\"some-image\", collaboration=collaboration,",
            "                        runs=[Run(status=TaskStatus.PENDING)])",
            "            task.save()",
            "",
            "        headers = self.login_node(api_key)",
            "        tokens = self.app.post('/api/token/container', headers=headers, json={",
            "            \"image\": \"some-image\",",
            "            \"task_id\": task.id",
            "        }",
            "        ).json",
            "",
            "        if 'msg' in tokens:",
            "            print(tokens['msg'])",
            "",
            "        headers = {",
            "            'Authorization': 'Bearer {}'.format(tokens['container_token'])",
            "        }",
            "        return headers",
            "",
            "    def paginated_list(",
            "        self, url: str, headers: dict = None",
            "    ) -> tuple[Response, list]:",
            "        \"\"\"",
            "        Get all resources of a list endpoint by browsing through all pages",
            "",
            "        Parameters",
            "        ----------",
            "        url: str",
            "            The url of the list endpoint",
            "        headers: dict",
            "            The headers to use for the request",
            "        kwargs: dict",
            "            Additional arguments to pass to the request",
            "",
            "        Returns",
            "        -------",
            "        tuple[flask.Response, list]",
            "            The response and the list of all resources",
            "        \"\"\"",
            "        result = self.app.get(url, headers=headers)",
            "        links = result.json.get('links')",
            "        page = 1",
            "        json_data = result.json.get('data')",
            "        if json_data is None:",
            "            json_data = []",
            "        while links and links.get('next'):",
            "            page += 1",
            "            new_response = self.app.get(",
            "                links.get('next'), headers=headers",
            "            )",
            "            json_data += new_response.json.get('data') \\",
            "                if new_response.json.get('data') else []",
            "            links = new_response.json.get('links')",
            "        return result, json_data",
            "",
            "    def create_node_and_login(self, *args, **kwargs):",
            "        node, api_key = self.create_node(*args, **kwargs)",
            "        return self.login_node(api_key)",
            "",
            "    def create_user_and_login(self, organization=None, rules=[]):",
            "        user = self.create_user(organization, rules)",
            "        return self.login(user.username)",
            "",
            "    def test_version(self):",
            "        rv = self.app.get('/api/version')",
            "        r = json.loads(rv.data)",
            "        self.assertIn('version', r)",
            "        self.assertEqual(r['version'], __version__)",
            "",
            "    def test_token_different_users(self):",
            "        for type_ in [\"root\", \"admin\", \"user\"]:",
            "            tokens = self.app.post(",
            "                '/api/token/user',",
            "                json=self.credentials[type_]",
            "            ).json",
            "            self.assertIn('access_token', tokens)",
            "            self.assertIn('refresh_token', tokens)",
            "",
            "    def test_organization(self):",
            "",
            "        rule = Rule.get_by_(\"organization\", Scope.GLOBAL,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "",
            "        # First retrieve a list of all organizations",
            "        _response, orgs = self.paginated_list('/api/organization', headers)",
            "        self.assertEqual(len(orgs), len(Organization.get()))",
            "",
            "        attrs = [",
            "            'id',",
            "            'name',",
            "            'domain',",
            "            'name',",
            "            'address1',",
            "            'address2',",
            "            'zipcode',",
            "            'country',",
            "        ]",
            "",
            "        org = orgs[0]",
            "        for attr in attrs:",
            "            self.assertIn(attr, org)",
            "",
            "        # Retrieve a single organization",
            "        url = f'/api/organization/{org[\"id\"]}'",
            "        org = self.app.get(url, headers=headers).json",
            "        self.assertEqual(org['id'], orgs[0]['id'])",
            "        self.assertEqual(org['name'], orgs[0]['name'])",
            "",
            "        # Create a new organization",
            "        org_details = {",
            "            'name': 'Umbrella Corporation',",
            "            'address1': 'Resident Evil Pike'",
            "        }",
            "",
            "        org = self.app.post(",
            "            '/api/organization',",
            "            json=org_details,",
            "            headers=headers",
            "        ).json",
            "",
            "        # for attr in attrs:",
            "        #     self.assertIn(attr, org)",
            "",
            "        # self.assertGreater(org['id'], 0)",
            "",
            "        orgs = self.app.get('/api/organization', headers=headers).json",
            "        # self.assertEqual(len(orgs), 4)",
            "",
            "    def test_collaboration(self):",
            "        org = Organization()",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "",
            "        collaborations = self.app.get(",
            "            '/api/collaboration', headers=headers",
            "        )",
            "        self.assertEqual(collaborations.status_code, HTTPStatus.OK)",
            "        db_cols = Collaboration.get()",
            "        self.assertEqual(len(collaborations.json['data']), len(db_cols))",
            "",
            "    def test_node_without_id(self):",
            "",
            "        # GET",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        nodes = self.app.get(\"/api/node\", headers=headers).json['data']",
            "        expected_fields = [",
            "            'name',",
            "            'collaboration',",
            "            'organization',",
            "            'status',",
            "            'id',",
            "            'type',",
            "            'last_seen',",
            "            'ip'",
            "        ]",
            "        for node in nodes:",
            "            for key in expected_fields:",
            "                self.assertIn(key, node)",
            "",
            "        nodes = self.app.get(\"/api/node\", headers=headers).json",
            "        self.assertIsNotNone(nodes)",
            "",
            "        # POST",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        # unknown collaboration id should fail",
            "        response = self.app.post(\"/api/node\", headers=headers, json={",
            "            \"collaboration_id\": 99999",
            "        })",
            "        response_json = response.json",
            "        self.assertIn(\"msg\", response_json)",
            "        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # succesfully create a node",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        response = self.app.post(\"/api/node\", headers=headers, json={",
            "            \"collaboration_id\": col.id",
            "        })",
            "        self.assertEqual(response.status_code, HTTPStatus.CREATED)",
            "",
            "    def test_node_with_id(self):",
            "",
            "        # root user can access all nodes",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        node = self.app.get(\"/api/node/8\", headers=headers).json",
            "        expected_fields = [",
            "            'name',",
            "            'collaboration',",
            "            'organization',",
            "            'status',",
            "            'id',",
            "            'type',",
            "            'last_seen',",
            "            'ip'",
            "        ]",
            "        for key in expected_fields:",
            "            self.assertIn(key, node)",
            "",
            "        # user cannot access all",
            "        headers = self.create_user_and_login()",
            "        node = self.app.get(\"/api/node/8\", headers=headers)",
            "        self.assertEqual(node.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # some nodes just don't exist",
            "        node = self.app.get(\"/api/node/9999\", headers=headers)",
            "        self.assertEqual(node.status_code, 404)",
            "",
            "    def test_result_with_id(self):",
            "        headers = self.login(\"root\")",
            "        run = self.app.get(\"/api/run/1\", headers=headers)",
            "        self.assertEqual(run.status_code, 200)",
            "",
            "        run = self.app.get(\"/api/run/1?include=task\", headers=headers)",
            "        self.assertEqual(run.status_code, 200)",
            "",
            "    def test_run_without_id(self):",
            "        headers = self.login(\"root\")",
            "        result1 = self.app.get(\"/api/run\", headers=headers)",
            "        self.assertEqual(result1.status_code, 200)",
            "",
            "        result2 = self.app.get(\"/api/run?state=open\",",
            "                               headers=headers)",
            "        self.assertEqual(result2.status_code, 200)",
            "",
            "        result3 = self.app.get(\"/api/run?task_id=1\", headers=headers)",
            "        self.assertEqual(result3.status_code, 200)",
            "",
            "    def test_stats(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/run\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_task_with_id(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/task/1\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_task_witout_id(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/task\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_task_including_runs(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/task?include=runs\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_task_unknown(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/task/9999\", headers=headers)",
            "        self.assertEqual(result.status_code, 404)",
            "",
            "    def test_user_with_id(self):",
            "        headers = self.login(\"admin\")",
            "        result = self.app.get(\"/api/user/1\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "        user = result.json",
            "",
            "        expected_fields = [",
            "            \"username\",",
            "            \"firstname\",",
            "            \"lastname\",",
            "            \"roles\"",
            "        ]",
            "        for field in expected_fields:",
            "            self.assertIn(field, user)",
            "",
            "    def test_user_unknown(self):",
            "        headers = self.login(\"admin\")",
            "        result = self.app.get(\"/api/user/9999\", headers=headers)",
            "        self.assertEqual(result.status_code, 404)",
            "",
            "    def test_user_without_id(self):",
            "        for role in [\"user\", \"admin\", \"root\"]:",
            "            headers = self.login(role)",
            "            result = self.app.get(\"/api/user\", headers=headers)",
            "            self.assertEqual(result.status_code, 200)",
            "",
            "    def test_user_post(self):",
            "        headers = self.login(\"root\")",
            "        new_user = {",
            "            \"username\": \"unittest\",",
            "            \"firstname\": \"unit\",",
            "            \"lastname\": \"test\",",
            "            \"email\": \"unit@test.org\",",
            "        }",
            "        # with a bad password, user should not be created",
            "        new_user['password'] = \"1234\"",
            "        result = self.app.post('/api/user', headers=headers, json=new_user)",
            "        self.assertEqual(result.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        new_user['password'] = \"Welkom01!\"",
            "        result = self.app.post(\"/api/user\", headers=headers,",
            "                               json=new_user)",
            "        self.assertEqual(result.status_code, 201)",
            "",
            "        result = self.app.post(\"/api/user\", headers=headers,",
            "                               json=new_user)",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "    def test_user_delete(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.delete(\"/api/user/5\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_user_delete_unknown(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.delete(\"/api/user/99999\", headers=headers)",
            "        self.assertEqual(result.status_code, 404)",
            "",
            "    def test_user_patch(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.patch(\"/api/user/2\", headers=headers, json={",
            "            \"firstname\": \"Henk\",",
            "            \"lastname\": \"Martin\"",
            "        })",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_user_patch_unknown(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.patch(\"/api/user/9999\", headers=headers, json={",
            "            \"username\": \"root2\"",
            "        })",
            "        self.assertEqual(result.status_code, 404)",
            "",
            "    def test_root_role_forbidden(self):",
            "        headers = self.login(\"root\")",
            "        new_user = {",
            "            \"username\": \"some\",",
            "            \"firstname\": \"guy\",",
            "            \"lastname\": \"there\",",
            "            \"roles\":  \"root\",",
            "            \"password\": \"super-secret\"",
            "        }",
            "        result = self.app.post(\"/api/user\", headers=headers,",
            "                               json=new_user)",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "    @patch(\"vantage6.server.mail_service.MailService.send_email\")",
            "    def test_reset_password(self, send_email):",
            "        user_ = {",
            "            \"username\": \"root\"",
            "        }",
            "        result = self.app.post(\"/api/recover/lost\", json=user_)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    @patch(\"vantage6.server.mail_service.MailService.send_email\")",
            "    def test_reset_password_missing_error(self, send_email):",
            "        result = self.app.post(\"/api/recover/lost\", json={})",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "    @patch(\"vantage6.server.resource.recover.decode_token\")",
            "    def test_recover_password(self, decode_token):",
            "        decode_token.return_value = {'sub': {'id': 1}}",
            "        new_password = {",
            "            \"password\": \"$Ecret88!\",",
            "            \"reset_token\": \"token\"",
            "        }",
            "        result = self.app.post(\"/api/recover/reset\", json=new_password)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "        # verify that the new password works",
            "        result = self.app.post(\"/api/token/user\", json={",
            "            \"username\": \"root\",",
            "            \"password\": \"$Ecret88!\"",
            "        })",
            "        self.assertIn(\"access_token\", result.json)",
            "        self.credentials[\"root\"][\"password\"] = \"$Ecret88!\"",
            "",
            "    def test_fail_recover_password(self):",
            "        result = self.app.post(\"/api/recover/reset\", json={})",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "    def test_change_password(self):",
            "        user = self.create_user(password=\"Password1!\")",
            "        headers = self.login(user.username)",
            "",
            "        # test if fails when not providing correct data",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"current_password\": \"Password1!\"",
            "        })",
            "        self.assertEqual(result.status_code, 400)",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"new_password\": \"a_new_password\"",
            "        })",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "        # test if fails when wrong password is provided",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"current_password\": \"Wrong_password1!\",",
            "            \"new_password\": \"A_new_password1!\"",
            "        })",
            "        self.assertEqual(result.status_code, 401)",
            "",
            "        # test if fails when new password is the same",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"current_password\": \"Password1!\",",
            "            \"new_password\": \"Password1!\"",
            "        })",
            "        self.assertEqual(result.status_code, 400)",
            "",
            "        # test if it works when used as intended",
            "        result = self.app.patch(\"/api/password/change\", headers=headers, json={",
            "            \"current_password\": \"Password1!\",",
            "            \"new_password\": \"A_new_password1\"",
            "        })",
            "        self.assertEqual(result.status_code, 200)",
            "        session.session.refresh(user)",
            "        self.assertTrue(user.check_password(\"A_new_password1\"))",
            "",
            "    def test_view_rules(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/rule\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "    def test_view_roles(self):",
            "        headers = self.login(\"root\")",
            "        result = self.app.get(\"/api/role\", headers=headers)",
            "        self.assertEqual(result.status_code, 200)",
            "",
            "        body = result.json['data']",
            "        expected_fields = ['organization', 'name', 'description', 'users']",
            "        for field in expected_fields:",
            "            self.assertIn(field, body[0])",
            "",
            "    def test_view_role_permissions(self):",
            "        org = Organization()",
            "        org.save()",
            "        other_org = Organization()",
            "        other_org.save()",
            "        col = Collaboration(organizations=[org, other_org])",
            "        col.save()",
            "        org_outside_collab = Organization()",
            "        org_outside_collab.save()",
            "",
            "        # non-existing role",
            "        headers = self.login('root')",
            "        result = self.app.get(\"/api/role/9999\", headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # root user can view all roles",
            "        result, json_data = self.paginated_list('/api/role', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(json_data), len(Role.get()))",
            "",
            "        role = Role(organization=org)",
            "        role.save()",
            "",
            "        # without permissions should allow you to view your own roles, which",
            "        # in this case is an empty list",
            "        headers = self.create_user_and_login()",
            "        result, json_data = self.paginated_list('/api/role', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(json_data), 0)",
            "",
            "        # view roles of your organization",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        result, json_data = self.paginated_list('/api/role', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # +3 for the root, container and node roles (other default roles are",
            "        # not generated for unit tests)",
            "        self.assertEqual(len(json_data), len(org.roles) + 3)",
            "",
            "        # view a single role of your organization",
            "        result = self.app.get(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # check that user of other organization cannot view roles with",
            "        # organization scope",
            "        headers = self.create_user_and_login(other_org, rules=[rule])",
            "        result = self.app.get(",
            "            '/api/role', headers=headers,",
            "            query_string={'organization_id': org.id}",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # user can view their own roles. This should always be possible",
            "        user = self.create_user(rules=[])",
            "        headers = self.login(user.username)",
            "        result = self.app.get('/api/role', headers=headers, query_string={",
            "            'user_id': user.id",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # collaboration permission - in same collaboration with id",
            "        rule = Rule.get_by_(\"role\", Scope.COLLABORATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(other_org, rules=[rule])",
            "        result = self.app.get(f\"/api/role/{role.id}\", headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # collaboration permission - in same collaboration without id",
            "        result, json_data = self.paginated_list('/api/role', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        # +3 for the root, container and node roles (other default roles are",
            "        # not generated for unit tests)",
            "        self.assertEqual(len(json_data), len([",
            "            role_ for org in col.organizations for role_ in org.roles",
            "        ]) + 3)",
            "",
            "        # collaboration permission - in different collaboration with id",
            "        headers = self.create_user_and_login(org_outside_collab, rules=[rule])",
            "        result = self.app.get(f\"/api/role/{role.id}\", headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # collaboration permission - in different collaboration without id",
            "        result = self.app.get('/api/role', headers=headers,",
            "                              query_string={'collaboration_id': col.id})",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        other_org.delete()",
            "        org_outside_collab.delete()",
            "        col.delete()",
            "        role.delete()",
            "        user.delete()",
            "",
            "    def test_create_role_as_root(self):",
            "        headers = self.login(\"root\")",
            "",
            "        # obtain available rules",
            "        rules = self.app.get(\"/api/rule\", headers=headers,",
            "                             query_string={'no_pagination': 1}).json['data']",
            "        rule_ids = [rule.get(\"id\") for rule in rules]",
            "",
            "        # assign first two rules to role",
            "        body = {",
            "            \"name\": \"some-role-name\",",
            "            \"description\": \"Testing if we can create a role\",",
            "            \"rules\": rule_ids[:2]",
            "        }",
            "",
            "        # create role",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "",
            "        # check that server responded ok",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # verify the values",
            "        self.assertEqual(result.json.get(\"name\"), body[\"name\"])",
            "        self.assertEqual(result.json.get(\"description\"), body[\"description\"])",
            "        result = self.app.get(",
            "            \"/api/rule\", headers=headers,",
            "            query_string={'role_id': result.json.get(\"id\")}",
            "        )",
            "        self.assertEqual(len(result.json.get('data')), 2)",
            "",
            "    def test_create_role_as_root_for_different_organization(self):",
            "        headers = self.login(\"root\")",
            "",
            "        # obtain available rules",
            "        rules = self.app.get(\"/api/rule\", headers=headers,",
            "                             query_string={'no_pagination': 1}).json['data']",
            "        # create new organization, so we're sure that the current user",
            "        # is not assigned to the same organization",
            "        org = Organization(name=\"Some-random-organization\")",
            "        org.save()",
            "",
            "        body = {",
            "            \"name\": \"some-role-name\",",
            "            \"description\": \"Testing if we can create a rol for another org\",",
            "            \"rules\": [rule.get(\"id\") for rule in rules],",
            "            \"organization_id\": org.id",
            "        }",
            "",
            "        # create role",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "",
            "        # check that server responded ok",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # verify the organization",
            "        self.assertEqual(org.id, result.json[\"organization\"][\"id\"])",
            "",
            "    def test_create_role_permissions(self):",
            "        all_rules = Rule.get()",
            "",
            "        # check user without any permissions",
            "        headers = self.create_user_and_login()",
            "",
            "        body = {",
            "            \"name\": \"some-role-name\",",
            "            \"description\": \"Testing if we can create a role for another org\",",
            "            \"rules\": [rule.id for rule in all_rules],",
            "        }",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        # check that user with a missing rule cannot create a role with that",
            "        # missing rule",
            "        headers = self.create_user_and_login(rules=(all_rules[:-2]))",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # check that user can create role within his organization",
            "        rule = Rule.get_by_(\"role\", scope=Scope.ORGANIZATION,",
            "                            operation=Operation.CREATE)",
            "",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        body[\"rules\"] = [rule.id]",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # check a non-existing organization",
            "        headers = self.login(\"root\")",
            "        body[\"organization_id\"] = 9999",
            "        result = self.app.post('/api/role', headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # check that assigning an unexisting rule is not possible",
            "        headers = self.create_user_and_login()",
            "        body[\"rules\"] = [9999]",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # check creating role inside the collaboration",
            "        org1 = Organization()",
            "        org1.save()",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org1, org2])",
            "        col.save()",
            "        rule = Rule.get_by_(\"role\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.CREATE)",
            "        headers = self.create_user_and_login(organization=org1, rules=[rule])",
            "        body[\"rules\"] = [rule.id]",
            "        body[\"organization_id\"] = org2.id",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # check creating role outside the collaboration fails",
            "        org3 = Organization()",
            "        org3.save()",
            "        body[\"organization_id\"] = org3.id",
            "        result = self.app.post(\"/api/role\", headers=headers, json=body)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "    def test_edit_role(self):",
            "        headers = self.login('root')",
            "",
            "        # create testing entities",
            "        org = Organization(name=\"some-organization-name\")",
            "        org.save()",
            "        role = Role(name=\"some-role-name\", organization=org)",
            "        role.save()",
            "",
            "        # test name, description",
            "        result = self.app.patch(f'/api/role/{role.id}', headers=headers, json={",
            "            \"name\": \"a-different-role-name\",",
            "            \"description\": \"some description of this role...\"",
            "        })",
            "",
            "        session.session.refresh(role)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(role.name, \"a-different-role-name\")",
            "        self.assertEqual(role.description, \"some description of this role...\")",
            "",
            "        # test modifying rules",
            "        all_rule_ids = [rule.id for rule in Rule.get()]",
            "        result = self.app.patch(f'/api/role/{role.id}', headers=headers, json={",
            "            \"rules\": all_rule_ids",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertListEqual(all_rule_ids, [rule.id for rule in role.rules])",
            "",
            "        # test non owning rules",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION,",
            "                            Operation.EDIT)",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.patch(f\"/api/role/{role.id}\", headers=headers, json={",
            "            \"rules\": all_rule_ids",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test modifying role of another organization, without global",
            "        # permission",
            "        org2 = Organization(name=\"another-organization\")",
            "        headers = self.create_user_and_login(org2, [rule])",
            "        result = self.app.patch(f'/api/role/{role.id}', headers=headers, json={",
            "            \"name\": \"this-will-not-be-updated\"",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test modifying role with global permissions",
            "        rule = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(org2, [rule])",
            "        result = self.app.patch(f'/api/role/{role.id}', headers=headers, json={",
            "            \"name\": \"this-will-not-be-updated\"",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test editing role inside the collaboration",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        rule = Rule.get_by_(\"role\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        result = self.app.patch(f\"/api/role/{role.id}\", headers=headers, json={",
            "            \"name\": \"new-role-name\",",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # check editing role outside the collaboration fails",
            "        org3 = Organization()",
            "        org3.save()",
            "        role = Role(name=\"some-role-name\", organization=org3)",
            "        role.save()",
            "        result = self.app.patch(f\"/api/role/{role.id}\", headers=headers, json={",
            "            \"name\": \"this-will-not-be-updated\"",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "    def test_remove_role(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        role = Role(organization=org)",
            "        role.save()",
            "",
            "        # test removal without permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.delete(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test removal with organization permissions",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION,",
            "                            Operation.DELETE)",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.delete(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test failed removal with organization permissions",
            "        role = Role(organization=org)  # because we removed it...",
            "        role.save()",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test removal with global permissions",
            "        rule = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # check removing role outside the collaboration fails",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        role = Role(organization=org)  # because we removed it...",
            "        role.save()",
            "",
            "        org3 = Organization()",
            "        org3.save()",
            "        rule = Rule.get_by_(\"role\", Scope.COLLABORATION, Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        result = self.app.delete(f\"/api/role/{role.id}\", headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test removing role inside the collaboration",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        result = self.app.delete(f\"/api/role/{role.id}\", headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        org3.delete()",
            "        org2.delete()",
            "        org.delete()",
            "        col.delete()",
            "",
            "    def test_rules_from_role(self):",
            "        headers = self.login('root')",
            "        role = Role.get()[0]",
            "",
            "        result, json_data = self.paginated_list(",
            "            f'/api/role/{role.id}/rule', headers=headers",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(role.rules), len(json_data))",
            "",
            "        result = self.app.get('/api/role/9999/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "    def test_add_single_rule_to_role(self):",
            "        headers = self.login('root')",
            "",
            "        role = Role(name=\"empty\", organization=Organization())",
            "        role.save()",
            "",
            "        # role without rules",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(result.json['data']), 0)",
            "",
            "        rule = Rule.get()[0]",
            "",
            "        # try to add rule to non existing role",
            "        result = self.app.post(f'/api/role/9999/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to add non existent rule",
            "        result = self.app.post(f'/api/role/{role.id}/rule/9999',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # add a rule to a role",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # check that the role now has one rule",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(result.json['data']), 1)",
            "",
            "    def test_remove_single_rule_from_role(self):",
            "        headers = self.login('root')",
            "",
            "        rule = Rule.get()[0]",
            "        role = Role(name=\"unit\", organization=Organization(), rules=[rule])",
            "        role.save()",
            "",
            "        # try to add rule to non existing role",
            "        result = self.app.delete(f'/api/role/9999/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to add non existent rule",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/9999',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(result.json['data']), 1)",
            "",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(result.json), 0)",
            "",
            "    def test_view_permission_rules(self):",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION, Operation.VIEW)",
            "",
            "        org = Organization()",
            "        org.save()",
            "        role = Role(name=\"some-role\", organization=org)",
            "        role.save()",
            "",
            "        # user does not belong to organization",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # user does belong to the organization",
            "        headers = self.create_user_and_login(organization=role.organization,",
            "                                             rules=[rule])",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # user has global permissions",
            "        rule = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(f'/api/role/{role.id}/rule', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        role.delete()",
            "        org.delete()",
            "",
            "    def test_add_rule_to_role_permission(self):",
            "        org = Organization()",
            "        org.save()",
            "        role = Role(name=\"new-role\", organization=org)",
            "        role.save()",
            "",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION, Operation.EDIT)",
            "",
            "        # try adding a rule without any permission",
            "        headers = self.create_user_and_login()",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # you cant edit other organizations roles",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # you can edit other organizations with the global permission",
            "        rule = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # however you can only assign rules that you own",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION, Operation.EDIT)",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test inside the collaboration",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        rule = Rule.get_by_(\"role\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        result = self.app.post(f'/api/role/{role.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # check outside the collaboration fails",
            "        org3 = Organization()",
            "        org3.save()",
            "        role2 = Role(name=\"some-role-name\", organization=org3)",
            "        role2.save()",
            "        result = self.app.post(f'/api/role/{role2.id}/rule/{rule.id}',",
            "                               headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        role.delete()",
            "        role2.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_remove_rule_from_role_permissions(self):",
            "        org = Organization()",
            "        org.save()",
            "        role = Role(name=\"new-role\", organization=org)",
            "        role.save()",
            "        rule = Rule.get_by_(\"role\", Scope.ORGANIZATION,",
            "                            Operation.EDIT)",
            "",
            "        # try removing without any permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try removing rule from other organization",
            "        headers = self.create_user_and_login(organization=Organization(),",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try removing rule which is not in the role",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        role.rules.append(rule)",
            "        role.save()",
            "",
            "        # lets try that again",
            "        headers = self.create_user_and_login(organization=role.organization,",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        role.rules.append(rule)",
            "        role.save()",
            "",
            "        # power users can edit other organization rules",
            "        power_rule = Rule.get_by_(\"role\", Scope.GLOBAL,",
            "                                  Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[power_rule, rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test inside the collaboration",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        rule = Rule.get_by_(\"role\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.EDIT)",
            "        role.rules.append(rule)",
            "        role.save()",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        result = self.app.delete(f'/api/role/{role.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # check outside the collaboration fails",
            "        org3 = Organization()",
            "        org3.save()",
            "        role2 = Role(name=\"some-role-name\", organization=org3)",
            "        role2.rules.append(rule)",
            "        role2.save()",
            "        result = self.app.delete(f'/api/role/{role2.id}/rule/{rule.id}',",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        role.delete()",
            "        role2.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_view_permission_user(self):",
            "",
            "        # user not found",
            "        headers = self.create_user_and_login()",
            "        result = self.app.get('/api/user/9999', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to view users without any permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.get('/api/user', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # root user can view all users",
            "        headers = self.login('root')",
            "        result, json_data = self.paginated_list('/api/user', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(json_data), len(User.get()))",
            "",
            "        # view users of your organization",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION, Operation.VIEW)",
            "        org = Organization()",
            "        org.save()",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        result, json_data = self.paginated_list('/api/user', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(json_data), len(org.users))",
            "",
            "        # view a single user of your organization",
            "        user_id = org.users[0].id",
            "        result = self.app.get(f'/api/user/{user_id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # user can view their own data. This should always be possible",
            "        user = self.create_user(rules=[])",
            "        headers = self.login(user.username)",
            "        result = self.app.get(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # collaboration permission - view single user",
            "        org2 = Organization()",
            "        org2.save()",
            "        org3 = Organization()",
            "        org3.save()",
            "        col = Collaboration(organizations=[org2, org3])",
            "        col.save()",
            "        user = self.create_user(organization=org2, rules=[])",
            "        rule = Rule.get_by_(\"user\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        result = self.app.get(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # collaboration permission - view list of users",
            "        result = self.app.get('/api/user', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        # expecting 2 users: 1 in org2 and the 1 in org3 which is logged in now",
            "        self.assertEqual(len(result.json['data']), 2)",
            "",
            "        # collaboration permission - viewing outside collaboration should fail",
            "        org_outside_col = Organization()",
            "        org_outside_col.save()",
            "        headers = self.create_user_and_login(organization=org_outside_col,",
            "                                             rules=[rule])",
            "        result = self.app.get(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # collaboration permission - viewing other collaborations should fail",
            "        result = self.app.get('/api/user', headers=headers, query_string={",
            "            'collaboration_id': col.id",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        org_outside_col.delete()",
            "        col.delete()",
            "        user.delete()",
            "",
            "    def test_bounce_existing_username_and_email(self):",
            "        headers = self.create_user_and_login()",
            "        User(username=\"something\", email=\"mail@me.org\").save()",
            "        userdata = {",
            "            \"username\": \"not-important\",",
            "            \"firstname\": \"name\",",
            "            \"lastname\": \"lastname\",",
            "            \"password\": \"welkom01\",",
            "            \"email\": \"mail@me.org\"",
            "        }",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        userdata['username'] = 'not-important'",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "    def test_new_permission_user(self):",
            "        userdata = {",
            "            \"username\": \"smarty\",",
            "            \"firstname\": \"Smart\",",
            "            \"lastname\": \"Pants\",",
            "            \"password\": \"Welkom01!\",",
            "            \"email\": \"mail-us@me.org\"",
            "        }",
            "",
            "        # Creating users for other organizations can only be by global scope",
            "        org = Organization()",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION,",
            "                            Operation.CREATE)",
            "        userdata['organization_id'] = 1",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # you can do that when you have the global scope",
            "        gl_rule = Rule.get_by_(\"user\", Scope.GLOBAL, Operation.CREATE)",
            "        userdata['rules'] = [gl_rule.id]",
            "        headers = self.create_user_and_login(org, rules=[gl_rule])",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # you need to own all rules in order to assign them",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        userdata['username'] = 'smarty2'",
            "        userdata['email'] = 'mail2@me.org'",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test inside the collaboration",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        rule = Rule.get_by_(\"user\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.CREATE)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        userdata['username'] = 'smarty4'",
            "        userdata['email'] = 'mail4@me.org'",
            "        userdata['organization_id'] = org2.id",
            "        userdata['rules'] = [rule.id]",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # check outside the collaboration fails",
            "        org3 = Organization()",
            "        org3.save()",
            "        userdata['username'] = 'smarty5'",
            "        userdata['email'] = 'mail5@me.org'",
            "        userdata['organization_id'] = org3.id",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # you can only create users for in which you have all rules",
            "        rule_view_roles = Rule.get_by_(",
            "            \"role\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(",
            "            org, rules=[rule, rule_view_roles])",
            "        role = Role(rules=[rule], organization=org)",
            "        role.save()",
            "        userdata['username'] = 'smarty3'",
            "        userdata['email'] = 'mail3@me.org'",
            "        userdata['roles'] = [role.id]",
            "        del userdata['organization_id']",
            "        del userdata['rules']",
            "        result = self.app.post('/api/user', headers=headers, json=userdata)",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "        # verify that user has the role",
            "        result = self.app.get('/api/role', headers=headers,",
            "                              query_string={'user_id': result.json['id']})",
            "        self.assertEqual(len(result.json['data']), 1)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "        role.delete()",
            "",
            "    def test_patch_user_permissions(self):",
            "",
            "        org = Organization()",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=org)",
            "        user.save()",
            "        self.credentials[user.username] = {'username': user.username,",
            "                                           'password': \"Password\"}",
            "",
            "        # check non-existing user",
            "        headers = self.create_user_and_login()",
            "        result = self.app.patch('/api/user/9999', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # patching without permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'this-aint-gonna-fly'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        self.assertEqual(\"Username\", user.username)",
            "",
            "        # patch as a user of other organization",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION, Operation.EDIT)",
            "        self.create_user_and_login(rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'this-aint-gonna-fly'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        self.assertEqual(\"Username\", user.username)",
            "",
            "        # patch as another user from the same organization",
            "        rule = Rule.get_by_(\"user\", Scope.OWN, Operation.EDIT)",
            "        self.create_user_and_login(user.organization, [rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'this-aint-gonna-fly'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        self.assertEqual(\"Username\", user.username)",
            "",
            "        # edit 'simple' fields",
            "        rule = Rule.get_by_(\"user\", Scope.OWN, Operation.EDIT)",
            "        user.rules.append(rule)",
            "        user.save()",
            "        headers = self.login(user.username)",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'yeah'",
            "        })",
            "        session.session.refresh(user)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(\"yeah\", user.firstname)",
            "",
            "        # edit other user within your organization",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION, Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=user.organization,",
            "                                             rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'whatever'",
            "        })",
            "        session.session.refresh(user)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(\"whatever\", user.firstname)",
            "",
            "        # check that password cannot be edited",
            "        rule = Rule.get_by_(\"user\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'password': 'keep-it-safe'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # edit user from different organization, and test other edit fields",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'again',",
            "            'lastname': 'and again',",
            "        })",
            "        session.session.refresh(user)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(\"again\", user.firstname)",
            "        self.assertEqual(\"and again\", user.lastname)",
            "",
            "        # test editing user inside the collaboration",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        rule2 = Rule.get_by_(\"user\", scope=Scope.COLLABORATION,",
            "                             operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule2])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'something',",
            "            'lastname': 'everything',",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # check editing outside the collaboration fails",
            "        org3 = Organization()",
            "        org3.save()",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule2])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'firstname': 'will-not-work',",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you cannot assign rules that you not own",
            "        not_owning_rule = Rule.get_by_(\"user\", Scope.OWN,",
            "                                       Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [not_owning_rule.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you cannot assign role that has rules that you do not own",
            "        role = Role(name=\"somename\", rules=[not_owning_rule],",
            "                    organization=org)",
            "        role.save()",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [role.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you cannot assign rules if you don't have all the rules",
            "        # that the other user has",
            "        headers = self.create_user_and_login(rules=[rule, not_owning_rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [not_owning_rule.id, rule.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you CAN change the rules. To do so, a user is generated",
            "        # that has same rules as current user, but also rule to edit other",
            "        # users and another one current user does not possess",
            "        assigning_user_rules = user.rules",
            "        assigning_user_rules.append(",
            "            Rule.get_by_(\"user\", Scope.GLOBAL, Operation.EDIT),",
            "        )",
            "        assigning_user_rules.append(not_owning_rule)",
            "        headers = self.create_user_and_login(rules=assigning_user_rules)",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [not_owning_rule.id, rule.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        result = self.app.get('/api/rule', headers=headers,",
            "                              query_string={'user_id': user.id})",
            "        user_rule_ids = [",
            "            rule['id'] for rule in result.json.get('data')",
            "        ]",
            "        self.assertIn(not_owning_rule.id, user_rule_ids)",
            "",
            "        # test that you cannot assign roles if you don't have all the",
            "        # permissions for that role yourself (even though you have permission",
            "        # to assign roles)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'roles': [role.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that you CAN assign roles",
            "        rule_global_view = Rule.get_by_(\"role\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(",
            "            rules=[rule, not_owning_rule, rule_global_view]",
            "        )",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'roles': [role.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        result = self.app.get('/api/role', headers=headers,",
            "                              query_string={'user_id': user.id})",
            "        user_role_ids = [",
            "            role['id'] for role in result.json.get('data')",
            "        ]",
            "        self.assertIn(role.id, user_role_ids)",
            "",
            "        # test that you CANNOT assign roles from different organization",
            "        other_org_role = Role(name=\"somename\", rules=[not_owning_rule],",
            "                              organization=Organization())",
            "        headers = self.create_user_and_login(rules=[rule, not_owning_rule])",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'roles': [other_org_role.id]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test missing role",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'roles': [9999]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test missing rule",
            "        result = self.app.patch(f'/api/user/{user.id}', headers=headers, json={",
            "            'rules': [9999]",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        user.delete()",
            "        role.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_delete_user_permissions(self):",
            "        org = Organization()",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=org)",
            "        user.save()",
            "        self.credentials[user.username] = {'username': user.username,",
            "                                           'password': \"Password\"}",
            "",
            "        # check non-exsitsing user",
            "        headers = self.create_user_and_login()",
            "        result = self.app.delete('/api/user/9999', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to delete without any permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # same organization but missing permissions",
            "        rule = Rule.get_by_(\"user\", Scope.OWN, Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=user.organization,",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # other organization with organization scope",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION,",
            "                            Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=Organization(),",
            "                                             rules=[rule])",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # delete yourself",
            "        rule = Rule.get_by_(\"user\", Scope.OWN, Operation.DELETE)",
            "        user.rules.append(rule)",
            "        user.save()",
            "        headers = self.login(user.username)",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        # User is deleted by the endpoint! user.delete()",
            "",
            "        # delete colleague",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=Organization())",
            "        user.save()",
            "        rule = Rule.get_by_(\"user\", Scope.ORGANIZATION,",
            "                            Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule],",
            "                                             organization=user.organization)",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        # User is deleted by the endpoint user.delete()",
            "",
            "        # delete as root",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=Organization())",
            "        user.save()",
            "        rule = Rule.get_by_(\"user\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        # user is deleted by endpoint! user.delete()",
            "",
            "        # check delete outside the collaboration fails",
            "        user = User(firstname=\"Firstname\", lastname=\"Lastname\",",
            "                    username=\"Username\", password=\"Password\", email=\"a@b.c\",",
            "                    organization=org)",
            "        user.save()",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        org3 = Organization()",
            "        org3.save()",
            "        rule = Rule.get_by_(\"user\", Scope.COLLABORATION,",
            "                            Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test delete inside the collaboration",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        result = self.app.delete(f'/api/user/{user.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_view_organization_as_user_permissions(self):",
            "",
            "        # view without any permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.get('/api/organization', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # view your own organization",
            "        rule = Rule.get_by_(\"organization\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        user = self.create_user(rules=[rule])",
            "        headers = self.login(user.username)",
            "        result = self.app.get(f'/api/organization/{user.organization.id}',",
            "                              headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # try to view another organization without permission",
            "        org = Organization()",
            "        org.save()",
            "        result = self.app.get(f'/api/organization/{org.id}',",
            "                              headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # Missing organization with global view",
            "        rule = Rule.get_by_(\"organization\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get('/api/organization/9999',",
            "                              headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test global view",
            "        result = self.app.get(f'/api/organization/{org.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test view inside the collaboration",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        rule = Rule.get_by_(\"organization\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        result = self.app.get(f'/api/organization/{org.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # check view outside the collaboration fails",
            "        org3 = Organization()",
            "        org3.save()",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        result = self.app.get(f'/api/organization/{org.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_view_organization_as_node_permission(self):",
            "        node, api_key = self.create_node()",
            "        headers = self.login_node(api_key)",
            "",
            "        # test list organization with only your organization",
            "        result = self.app.get('/api/organization', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(result.json['data'][0]['id'], node.organization.id)",
            "",
            "        # test list organization",
            "        result = self.app.get(",
            "            f'/api/organization/{node.organization.id}',",
            "            headers=headers",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(result.json['id'], node.organization.id)",
            "        node.delete()",
            "",
            "    def test_view_organization_as_container_permission(self):",
            "        node, api_key = self.create_node()",
            "        headers = self.login_container(node=node, api_key=api_key)",
            "",
            "        # try to get organization where he runs",
            "        result = self.app.get(",
            "            f'/api/organization/{node.organization.id}',",
            "            headers=headers",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertEqual(result.json['id'], node.organization.id)",
            "",
            "        # get all organizations in the collaboration",
            "        result = self.app.get(",
            "            '/api/organization',",
            "            headers=headers",
            "        )",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        self.assertIsInstance(result.json['data'], list)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_create_organization_permissions(self):",
            "",
            "        # try creating an organization without permissions",
            "        headers = self.create_user_and_login()",
            "        result = self.app.post('/api/organization', headers=headers, json={",
            "            'name': 'this-aint-gonna-happen'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # create an organization",
            "        rule = Rule.get_by_(\"organization\", Scope.GLOBAL,",
            "                            Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.post('/api/organization', headers=headers, json={",
            "            'name': 'this-is-gonna-happen'",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "        self.assertIsNotNone(Organization.get_by_name(\"this-is-gonna-happen\"))",
            "",
            "    def test_patch_organization_permissions(self):",
            "",
            "        # unknown organization",
            "        headers = self.create_user_and_login()",
            "        results = self.app.patch('/api/organization/9999', headers=headers,",
            "                                 json={})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to change anything without permissions",
            "        org = Organization(name=\"first-name\")",
            "        org.save()",
            "        results = self.app.patch(f'/api/organization/{org.id}',",
            "                                 headers=headers, json={})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # change as super user",
            "        rule = Rule.get_by_(\"organization\", Scope.GLOBAL,",
            "                            Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f'/api/organization/{org.id}',",
            "                                 headers=headers, json={",
            "                                     \"name\": \"second-name\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], \"second-name\")",
            "",
            "        # change as organization editor",
            "        rule = Rule.get_by_(\"organization\", Scope.ORGANIZATION,",
            "                            Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.patch(",
            "            f'/api/organization/{org.id}', headers=headers,",
            "            json={\"name\": \"third-name\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], \"third-name\")",
            "",
            "        # change other organization as organization editor",
            "        rule = Rule.get_by_(\"organization\", Scope.ORGANIZATION,",
            "                            Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f'/api/organization/{org.id}',",
            "                                 headers=headers, json={",
            "                                     \"name\": \"third-name\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test editing organization inside the collaboration",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        rule2 = Rule.get_by_(\"organization\", scope=Scope.COLLABORATION,",
            "                             operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule2])",
            "        results = self.app.patch(",
            "            f'/api/organization/{org.id}', headers=headers,",
            "            json={\"name\": \"fourth-name\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # check editing outside the collaboration fails",
            "        org3 = Organization()",
            "        org3.save()",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule2])",
            "        results = self.app.patch(",
            "            f'/api/organization/{org.id}', headers=headers,",
            "            json={\"name\": \"not-going-to-happen\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "    def test_organization_view_nodes(self):",
            "",
            "        # create organization, collaboration and node",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        org.save()",
            "        col = Collaboration(name=str(uuid.uuid1()), organizations=[org])",
            "        col.save()",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        # try to view without permissions",
            "        headers = self.create_user_and_login(org)",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view with organization permissions",
            "        rule = Rule.get_by_(\"node\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # try to view other organization",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view with global permissions",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # try to view as node",
            "        headers = self.create_node_and_login(organization=org)",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # try to view as node from another organization",
            "        headers = self.create_node_and_login()",
            "        results = self.app.get(f\"/api/organization/{org.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_organization_view_collaboration_permissions(self):",
            "",
            "        # test unknown organization",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get('/api/organization/9999/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test view without any permission",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test view with organization scope",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test view with organization scope other organiation",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test view with global scope",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test as node",
            "        headers = self.create_node_and_login(organization=org,",
            "                                             collaboration=col)",
            "        results = self.app.get(f'/api/organization/{org.id}/collaboration',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_collaboration_permissions(self):",
            "",
            "        # setup organization and collaboration",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # try view the collaboration without any permissions",
            "        headers = self.create_user_and_login(organization=org)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view it with organization permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # try to view it from an outside organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # view it with global view permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test access as node",
            "        headers = self.create_node_and_login(organization=org,",
            "                                             collaboration=col)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test access as container",
            "        headers = self.login_container(collaboration=col, organization=org)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        org.delete()",
            "        col.delete()",
            "",
            "    def test_edit_collaboration_permissions(self):",
            "",
            "        # test an unknown collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.patch(\"/api/collaboration/9999\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test editing without any permission",
            "        col = Collaboration(name=\"collaboration-1\")",
            "        col.save()",
            "        headers = self.create_user_and_login()",
            "        results = self.app.patch(f\"/api/collaboration/{col.id}\",",
            "                                 headers=headers, json={",
            "                                     \"name\": \"this-aint-gonna-fly\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test editing with global permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f\"/api/collaboration/{col.id}\",",
            "                                 headers=headers, json={",
            "                                     \"name\": \"this-is-gonna-fly\"",
            "                                 })",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json[\"name\"], \"this-is-gonna-fly\")",
            "        col.delete()",
            "",
            "        # test editing collaboration from within the collaboration",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "        rule = Rule.get_by_(\"collaboration\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.patch(",
            "            f'/api/collaboration/{col.id}', headers=headers,",
            "            json={\"name\": \"some-name\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # check editing collaboration outside the collaboration fails without",
            "        # root access",
            "        org2 = Organization()",
            "        org2.save()",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        results = self.app.patch(",
            "            f'/api/collaboration/{col.id}', headers=headers,",
            "            json={\"name\": \"not-going-to-happen\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org2.delete()",
            "        col.delete()",
            "",
            "    def test_delete_collaboration_permissions(self):",
            "",
            "        col = Collaboration()",
            "        col.save()",
            "",
            "        # test deleting unknown collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.delete(\"/api/collaboration/9999\",",
            "                                  headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test deleting without permission",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}\",",
            "                                  headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test deleting with permission",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}\",",
            "                                  headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # check deleting with collaboration permission outside the",
            "        # collaboration fails",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "        org_not_member = Organization()",
            "        org_not_member.save()",
            "        rule = Rule.get_by_(\"collaboration\", Scope.COLLABORATION,",
            "                            Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=org_not_member,",
            "                                             rules=[rule])",
            "        result = self.app.delete(f\"/api/collaboration/{col.id}\",",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # check deleting with collaboration permission inside the collaboration",
            "        # succeeds",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        result = self.app.delete(f\"/api/collaboration/{col.id}\",",
            "                                 headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org_not_member.delete()",
            "",
            "    def test_view_collaboration_organization_permissions_as_user(self):",
            "        headers = self.create_user_and_login()",
            "",
            "        # non-existing collaboration",
            "        results = self.app.get(\"/api/collaboration/9999/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # access without the proper permissions",
            "        headers = self.create_user_and_login(organization=org)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # global permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # organization permissions of another organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # now with the correct organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_collaboration_organization_permissions_as_node(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # node of a different organization",
            "        headers = self.create_node_and_login()",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # node of the correct organization",
            "        headers = self.create_node_and_login(organization=org,",
            "                                             collaboration=col)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_view_collaboration_organization_permissions_as_container(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # node of a different organization",
            "        headers = self.login_container()",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        headers = self.login_container(organization=org, collaboration=col)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/organization\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_edit_collaboration_organization_permissions(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        org2 = Organization()",
            "        org2.save()",
            "",
            "        # try to do it without permission",
            "        headers = self.create_user_and_login()",
            "        results = self.app.post(f\"/api/collaboration/{col.id}/organization\",",
            "                                headers=headers, json={'id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # edit permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post(f\"/api/collaboration/{col.id}/organization\",",
            "                                headers=headers, json={'id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json), 2)",
            "",
            "        # test adding new organization to collaboration from within the",
            "        # collaboration",
            "        org3 = Organization()",
            "        org3.save()",
            "        rule = Rule.get_by_(\"collaboration\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.post(f\"/api/collaboration/{col.id}/organization\",",
            "                                headers=headers, json={'id': org3.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # adding new organization to collaboration from outside the",
            "        # collaboration should fail with collaboration permission",
            "        org4 = Organization()",
            "        org4.save()",
            "        headers = self.create_user_and_login(organization=org4, rules=[rule])",
            "        results = self.app.post(f\"/api/collaboration/{col.id}/organization\",",
            "                                headers=headers, json={'id': org4.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        org4.delete()",
            "        col.delete()",
            "",
            "    def test_delete_collaboration_organization_permissions(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "",
            "        # try to do it without permission",
            "        headers = self.create_user_and_login()",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}/organization\",",
            "                                  headers=headers, json={'id': org.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # delete first organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}/organization\",",
            "                                  headers=headers, json={'id': org.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json), 1)  # one organization left",
            "",
            "        # add back first organization",
            "        col.organizations.append(org)",
            "        col.save()",
            "",
            "        # removing organization from collaboration from outside the",
            "        # collaboration should fail with collaboration permission",
            "        org3 = Organization()",
            "        org3.save()",
            "        rule = Rule.get_by_(\"collaboration\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}/organization\",",
            "                                  headers=headers, json={'id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test removing organization from collaboration from within the",
            "        # collaboration",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}/organization\",",
            "                                  headers=headers, json={'id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_view_collaboration_node_permissions(self):",
            "",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        col = Collaboration(name=str(uuid.uuid1()), organizations=[org])",
            "        node = Node(collaboration=col, organization=org)",
            "        node.save()",
            "",
            "        # try to view an non-existant collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get(\"/api/collaboration/9999/node\", headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to view without any permissions",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view from another organzization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to view from another organization with global permissions",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.nodes))",
            "",
            "        # try to view from your organization",
            "        rule = Rule.get_by_(\"collaboration\", Scope.ORGANIZATION,",
            "                            Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule], organization=org)",
            "        results = self.app.get(f\"/api/collaboration/{col.id}/node\",",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_add_collaboration_node_permissions(self):",
            "",
            "        org = Organization()",
            "        org.save()",
            "        org2 = Organization()",
            "        org2.save()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        node = Node(organization=org)",
            "        node.save()",
            "        node2 = Node(organization=org2)",
            "        node2.save()",
            "",
            "        org3 = Organization()",
            "        org3.save()",
            "        node3 = Node(organization=org3)",
            "        node3.save()",
            "",
            "        # try non-existant collaboration",
            "        headers = self.create_user_and_login()",
            "",
            "        results = self.app.post('/api/collaboration/9999/node',",
            "                                headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try without proper permissions",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to add non-existing node",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': 9999})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # add a node!",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "        self.assertEqual(len(results.json), len(col.nodes))",
            "",
            "        # try to add a node thats already in there",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # adding new node to collaboration from an organization that is not",
            "        # part of the collaboration should fail",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node3.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # test new node to collaboration from within the collaboration",
            "        rule = Rule.get_by_(\"collaboration\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "        # adding new node to collaboration from outside collaboration should",
            "        # fail with collaboration-scope permission",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        results = self.app.post(f'/api/collaboration/{col.id}/node',",
            "                                headers=headers, json={'id': node3.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "        node2.delete()",
            "        node3.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_delete_collaboration_node_permissions(self):",
            "",
            "        org = Organization()",
            "        org2 = Organization()",
            "        col = Collaboration(organizations=[org, org2])",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        # try non-existant collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.delete('/api/collaboration/9999/node',",
            "                                  headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try without proper permissions",
            "        results = self.app.delete(f'/api/collaboration/{col.id}/node',",
            "                                  headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # try to add non-existing node",
            "        rule = Rule.get_by_(\"collaboration\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/collaboration/{col.id}/node',",
            "                                  headers=headers, json={'id': 9999})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # try to add a node thats not in there",
            "        node2 = Node()",
            "        node2.save()",
            "        results = self.app.delete(f'/api/collaboration/{col.id}/node',",
            "                                  headers=headers, json={'id': node2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "        node2.delete()",
            "",
            "        # delete node from collaboration!",
            "        results = self.app.delete(f'/api/collaboration/{col.id}/node',",
            "                                  headers=headers, json={'id': node.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # removing node from collaboration from outside the",
            "        # collaboration should fail with collaboration permission",
            "        node2 = Node(organization=org2, collaboration=col)",
            "        node2.save()",
            "        org3 = Organization()",
            "        org3.save()",
            "        rule = Rule.get_by_(\"collaboration\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}/node\",",
            "                                  headers=headers, json={'id': node2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test removing organization from collaboration from within the",
            "        # collaboration",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.delete(f\"/api/collaboration/{col.id}/node\",",
            "                                  headers=headers, json={'id': node2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        node.delete()",
            "        node2.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_view_collaboration_task_permissions_as_user(self):",
            "",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        task = Task(collaboration=col)",
            "        task.save()",
            "",
            "        # view non existing collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get('/api/collaboration/9999/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # view without any permission",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # view from another organization",
            "        rule = Rule.get_by_(\"task\", Scope.COLLABORATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # view from your own organization",
            "        headers = self.create_user_and_login(rules=[rule], organization=org)",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.tasks))",
            "",
            "        # view with global permissions",
            "        rule = Rule.get_by_(\"task\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.tasks))",
            "",
            "    def test_view_collaboration_task_permissions_as_node(self):",
            "",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        node, api_key = self.create_node(org, col)",
            "        task = Task(collaboration=col)",
            "        task.save()",
            "",
            "        headers = self.login_node(api_key)",
            "        results = self.app.get(f'/api/collaboration/{col.id}/task',",
            "                               headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_view_node_permissions_as_user(self):",
            "",
            "        org = Organization()",
            "        org2 = Organization()",
            "        col = Collaboration(organizations=[org, org2])",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "        node2 = Node(organization=org2, collaboration=col)",
            "        node2.save()",
            "",
            "        # view non existing node",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get('/api/node/9999', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # missing permissions",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # organization permissions",
            "        rule1 = Rule.get_by_(\"node\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule1])",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # organization permissions from another organization",
            "        headers = self.create_user_and_login(rules=[rule1])",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # global permissions",
            "        rule2 = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule2])",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # list organization permissions",
            "        headers = self.create_user_and_login(organization=org, rules=[rule1])",
            "        results = self.app.get('/api/node', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), 1)  # collab has 1 node",
            "",
            "        # list global permissions",
            "        headers = self.create_user_and_login(rules=[rule2])",
            "        results, json_data = self.paginated_list('/api/node', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(json_data), len(Node.get()))",
            "",
            "        # collaboration permission inside the collaboration",
            "        rule = Rule.get_by_(\"node\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.VIEW)",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # list collaboration permissions - in collaboration",
            "        results = self.app.get('/api/node', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.nodes))",
            "",
            "        # collaboration permission outside the collaboration should fail",
            "        org3 = Organization()",
            "        org3.save()",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # list collaboration permissions - other collaboration",
            "        results = self.app.get('/api/node', headers=headers,",
            "                               query_string={'collaboration_id': col.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "        node2.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "",
            "    def test_view_node_permissions_as_node(self):",
            "",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        node, api_key = self.create_node(org, col)",
            "",
            "        headers = self.login_node(api_key)",
            "",
            "        # global permissions",
            "        results = self.app.get(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # list organization permissions",
            "        results = self.app.get('/api/node', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(org.nodes))",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_create_node_permissions(self):",
            "",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "        org2 = Organization(name=str(uuid.uuid1()))",
            "        org2.save()",
            "",
            "        # test non existing collaboration",
            "        headers = self.create_user_and_login()",
            "        results = self.app.post('/api/node', headers=headers,",
            "                                json={'collaboration_id': 9999})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test creating a node without any permissions",
            "        headers = self.create_user_and_login()",
            "        results = self.app.post('/api/node', headers=headers,",
            "                                json={'collaboration_id': col.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # testing creating a node with organization permissions and supplying",
            "        # an organization id",
            "        rule = Rule.get_by_(\"node\", Scope.ORGANIZATION, Operation.CREATE)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id,",
            "            'organization_id': org.id",
            "        })",
            "",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "        node_id = results.json.get('id')",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id,",
            "            'organization_id': org2.id  # <-------",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test adding a node to an collaboration from an organization which",
            "        # does not belong to the collaboration",
            "        rule2 = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.CREATE)",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule2])",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # check an creating an already existing node",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # lets retry that",
            "        node = Node.get(node_id)",
            "        node.delete()",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "        # test global permissions",
            "        col.organizations.append(org2)",
            "        col.save()",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id,",
            "            'organization_id': org2.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "        # test collaboration permissions",
            "        org3 = Organization()",
            "        org3.save()",
            "        col.organizations.append(org3)",
            "        col.save()",
            "        rule = Rule.get_by_(\"node\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.CREATE)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        result = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id,",
            "            'organization_id': org3.id",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.CREATED)",
            "",
            "        # test collaboration permissions - outside of collaboration should fail",
            "        org4 = Organization()",
            "        org4.save()",
            "        col.organizations.append(org4)",
            "        col.save()",
            "        headers = self.create_user_and_login(organization=Organization(),",
            "                                             rules=[rule])",
            "        result = self.app.post('/api/node', headers=headers, json={",
            "            'collaboration_id': col.id,",
            "            'organization_id': org4.id",
            "        })",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        org4.delete()",
            "        col.delete()",
            "",
            "    def test_delete_node_permissions(self):",
            "",
            "        org = Organization(name=str(uuid.uuid1()))",
            "        col = Collaboration(name=str(uuid.uuid1()), organizations=[org])",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        # unexisting node",
            "        headers = self.create_user_and_login()",
            "        results = self.app.delete('/api/node/9999', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # organization permission other organization",
            "        rule = Rule.get_by_('node', Scope.ORGANIZATION, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # organization permission",
            "        rule = Rule.get_by_('node', Scope.ORGANIZATION, Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.delete(f'/api/node/{node.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # global permission",
            "        org2 = Organization(name=str(uuid.uuid1()))",
            "        node2 = Node(organization=org2, collaboration=col)",
            "        node2.save()",
            "        rule = Rule.get_by_('node', Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/node/{node2.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # collaboration permission - removing node from outside collaboration",
            "        # should fail",
            "        org3 = Organization()",
            "        node3 = Node(organization=org3, collaboration=col)",
            "        node3.save()",
            "        col.organizations.append(org3)",
            "        col.save()",
            "        org_not_in_collab = Organization()",
            "        org_not_in_collab.save()",
            "        rule = Rule.get_by_(\"node\", scope=Scope.COLLABORATION,",
            "                            operation=Operation.DELETE)",
            "        headers = self.create_user_and_login(organization=org_not_in_collab,",
            "                                             rules=[rule])",
            "        results = self.app.delete(f'/api/node/{node3.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # collaboration permission - now within collaboration",
            "        headers = self.create_user_and_login(organization=org, rules=[rule])",
            "        results = self.app.delete(f'/api/node/{node3.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        org_not_in_collab.delete()",
            "        col.delete()",
            "",
            "    def test_patch_node_permissions_as_user(self):",
            "        # test patching non-existant node",
            "        headers = self.create_user_and_login()",
            "        results = self.app.patch(\"/api/node/9999\", headers=headers, json={})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test user without any permissions",
            "        org = Organization()",
            "        org2 = Organization()",
            "        col = Collaboration(organizations=[org, org2])",
            "        node = Node(organization=org, collaboration=col)",
            "        node.save()",
            "",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test user with global permissions",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={\"name\": \"A\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], \"A\")",
            "",
            "        # test user with org permissions and own organization",
            "        rule = Rule.get_by_(\"node\", Scope.ORGANIZATION, Operation.EDIT)",
            "        headers = self.create_user_and_login(org, [rule])",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={'name': 'B'})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], \"B\")",
            "",
            "        # test user with org permissions and other organization",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={'name': 'C'})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test updatin the `organization_id` with organization permissions",
            "        org2 = Organization()",
            "        org2.save()",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={'organization_id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test assigning it to a node thats not part of the collaborat",
            "        col2 = Collaboration(organizations=[org2])",
            "        col2.save()",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={'collaboration_id': col2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # collaboration_id and organization_id. Note that the organization",
            "        # is assigned before the collaboration is defined.",
            "        rule = Rule.get_by_(\"node\", Scope.GLOBAL, Operation.EDIT)",
            "        headers = self.create_user_and_login(org2, rules=[rule])",
            "        results = self.app.patch(f'/api/node/{node.id}', headers=headers,",
            "                                 json={'collaboration_id': col2.id,",
            "                                       'organization_id': org2.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['organization']['id'], org2.id)",
            "        self.assertEqual(results.json['collaboration']['id'], col2.id)",
            "",
            "        # try to patch the node's VPN IP address",
            "        results = self.app.patch(f'/api/node/{node.id}', headers=headers,",
            "                                 json={'ip': '0.0.0.0'})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['ip'], '0.0.0.0')",
            "",
            "        # assign unknow organization",
            "        results = self.app.patch(f'/api/node/{node.id}', headers=headers,",
            "                                 json={'organization_id': 9999})",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # collaboration permission - inside the collaboration",
            "        rule = Rule.get_by_(\"node\", Scope.COLLABORATION, Operation.EDIT)",
            "        headers = self.create_user_and_login(organization=org2, rules=[rule])",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={\"name\": \"A\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # collaboration permission - outside the collaboration",
            "        org3 = Organization()",
            "        org3.save()",
            "        headers = self.create_user_and_login(organization=org3, rules=[rule])",
            "        results = self.app.patch(f\"/api/node/{node.id}\", headers=headers,",
            "                                 json={\"name\": \"A\"})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        org3.delete()",
            "        col.delete()",
            "        col2.delete()",
            "",
            "    def test_view_task_permissions_as_user(self):",
            "        # non existing task",
            "        headers = self.create_user_and_login()",
            "        results = self.app.get('/api/task/9999', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test user without any permissions and id",
            "        org = Organization()",
            "        org2 = Organization()",
            "        col = Collaboration(organizations=[org, org2])",
            "        task = Task(name=\"unit\", collaboration=col, init_org=org)",
            "        task.save()",
            "",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test user with col permissions with id",
            "        rule = Rule.get_by_(\"task\", Scope.COLLABORATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(results.json['name'], 'unit')",
            "",
            "        # collaboration permission outside the collaboration should fail",
            "        org_not_in_collab = Organization()",
            "        org_not_in_collab.save()",
            "        headers = self.create_user_and_login(organization=org_not_in_collab,",
            "                                             rules=[rule])",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test user with org permissions with id from another org",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test user with org permissions without id",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test that user is not allowed to view task results without id",
            "        results = self.app.get('/api/task', headers=headers,",
            "                               query_string={'include': 'results'})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that user is allowed to view task results if they have the rule",
            "        # to view results",
            "        rule_view_results = Rule.get_by_(\"run\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(org,",
            "                                             rules=[rule, rule_view_results])",
            "        results = self.app.get('/api/task', headers=headers,",
            "                               query_string={'include': 'results'})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test user with global permissions and id",
            "        rule = Rule.get_by_(\"task\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test that user is not allowed to view task results with id",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers,",
            "                               query_string={'include': 'results'})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test that user is allowed to view task results if they have the rule",
            "        # to view results",
            "        headers = self.create_user_and_login(org,",
            "                                             rules=[rule, rule_view_results])",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers,",
            "                               query_string={'include': 'results'})",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test user with global permissions without id",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # list collaboration permissions - in collaboration",
            "        rule = Rule.get_by_(\"task\", Scope.COLLABORATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.tasks))",
            "",
            "        # list collaboration permissions - other collaboration",
            "        headers = self.create_user_and_login(org_not_in_collab, rules=[rule])",
            "        results = self.app.get('/api/task', headers=headers,",
            "                               query_string={'collaboration_id': col.id})",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # list own organization permissions - same organization",
            "        rule = Rule.get_by_(\"task\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), len(col.tasks))",
            "",
            "        # list own organization permissions - other organization",
            "        headers = self.create_user_and_login(org2, rules=[rule])",
            "        results = self.app.get('/api/task', headers=headers, query_string={",
            "            'init_org_id': org.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # list own user's task permissions - same user without id",
            "        rule = Rule.get_by_(\"task\", Scope.OWN, Operation.VIEW)",
            "        user = self.create_user(rules=[rule], organization=org)",
            "        headers = self.login(user.username)",
            "        task2 = Task(name=\"unit\", collaboration=col, init_org=org,",
            "                     init_user=user)",
            "        task2.save()",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertEqual(len(results.json['data']), 1)",
            "",
            "        # list own user's task permissions - same user with id",
            "        results = self.app.get(f'/api/task/{task2.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # list own user's task permissions - other user without id",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.get('/api/task', headers=headers, query_string={",
            "            'init_user_id': user.id",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # list own user's task permissions - other user with id",
            "        results = self.app.get(f'/api/task/{task2.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        task.delete()",
            "        task2.delete()",
            "        user.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        col.delete()",
            "",
            "    def test_view_task_permissions_as_node_and_container(self):",
            "        # test node with id",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "        task = Task(collaboration=col, image=\"some-image\", init_org=org)",
            "        task.save()",
            "        res = Run(task=task, status=TaskStatus.PENDING)",
            "        res.save()",
            "",
            "        headers = self.create_node_and_login(organization=org)",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test node without id",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test container with id",
            "        headers = self.login_container(collaboration=col, organization=org,",
            "                                       task=task)",
            "        results = self.app.get(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test container without id",
            "        results = self.app.get('/api/task', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "    def test_create_task_permission_as_user(self):",
            "        # non existant collaboration",
            "        headers = self.create_user_and_login()",
            "        input_ = {'method': 'dummy'}",
            "        task_json = {",
            "            \"collaboration_id\": 9999,",
            "            \"organizations\": [{'id': 9999, 'input': input_}],",
            "            \"image\": \"some-image\"",
            "        }",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # organizations outside of collaboration",
            "        org = Organization()",
            "        org.save()",
            "        col = Collaboration(organizations=[org])",
            "        col.save()",
            "",
            "        # task without any node created",
            "        task_json[\"organizations\"] = [{'id': org.id, 'input': input_}]",
            "        task_json[\"collaboration_id\"] = col.id",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # node is used implicitly as in further checks, can only create task",
            "        # if node has been created",
            "        node = Node(organization=org, collaboration=col)",
            "",
            "        org2 = Organization()",
            "        org2.save()",
            "",
            "        task_json[\"organizations\"] = [{'id': org2.id, 'input': input_}]",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.BAD_REQUEST)",
            "",
            "        # user without any permissions",
            "        task_json[\"organizations\"] = [{'id': org.id, 'input': input_}]",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # user with organization permissions for other organization",
            "        rule = Rule.get_by_(\"task\", Scope.COLLABORATION, Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # user with organization permissions",
            "        headers = self.create_user_and_login(org, rules=[rule])",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "        # user with global permissions but outside of the collaboration. They",
            "        # should *not* be allowed to create a task in a collaboration that",
            "        # they're not a part of",
            "        # TODO add test for user with global permission that creates a task for",
            "        # another organization than their own in the same collaboration",
            "        rule = Rule.get_by_(\"task\", Scope.GLOBAL, Operation.CREATE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.post('/api/task', headers=headers, json=task_json)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "",
            "    def test_create_task_permissions_as_container(self):",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        parent_task = Task(collaboration=col, image=\"some-image\")",
            "        parent_task.save()",
            "        parent_res = Run(organization=org, task=parent_task,",
            "                         status=TaskStatus.PENDING)",
            "        parent_res.save()",
            "",
            "        # test wrong image name",
            "        input_ = {'method': 'dummy'}",
            "        headers = self.login_container(collaboration=col, organization=org,",
            "                                       task=parent_task)",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col.id,",
            "            'image': 'other-image'",
            "        })",
            "",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test other collaboration_id",
            "        col2 = Collaboration(organizations=[org])",
            "        col2.save()",
            "        node2 = Node(organization=org, collaboration=col2)",
            "        node2.save()",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col2.id,",
            "            'image': 'some-image'",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test with correct parameters",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col.id,",
            "            'image': 'some-image'",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.CREATED)",
            "",
            "        # test already completed task",
            "        parent_res.status = TaskStatus.COMPLETED",
            "        parent_res.save()",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col.id,",
            "            'image': 'some-image'",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test a failed task",
            "        parent_res.status = TaskStatus.FAILED",
            "        parent_res.save()",
            "        results = self.app.post('/api/task', headers=headers, json={",
            "            \"organizations\": [{'id': org.id, 'input': input_}],",
            "            'collaboration_id': col.id,",
            "            'image': 'some-image'",
            "        })",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node2.delete()",
            "",
            "    def test_delete_task_permissions(self):",
            "",
            "        # test non-existing task",
            "        headers = self.create_user_and_login()",
            "        self.app.delete('/api/task/9999', headers=headers)",
            "",
            "        # test with organization permissions from other organization",
            "        org = Organization()",
            "        org2 = Organization()",
            "        col = Collaboration(organizations=[org, org2])",
            "        task = Task(collaboration=col, init_org=org)",
            "        task.save()",
            "",
            "        # test with user who is not member of collaboration",
            "        rule = Rule.get_by_(\"task\", Scope.COLLABORATION, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test with collaboration permissions",
            "        headers = self.create_user_and_login(org, [rule])",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test with global permissions",
            "        task = Task(collaboration=col)",
            "        task.save()",
            "        rule = Rule.get_by_(\"task\", Scope.GLOBAL, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test that all results are also deleted",
            "        task = Task(collaboration=col)",
            "        run = Run(task=task)",
            "        run.save()",
            "        run_id = run.id  # cannot access this after deletion",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "        self.assertIsNone(Task.get(run_id))",
            "",
            "        # test permission to delete tasks of own organization - other",
            "        # organization should fail",
            "        task = Task(collaboration=col, init_org=org)",
            "        task.save()",
            "        rule = Rule.get_by_(\"task\", Scope.ORGANIZATION, Operation.DELETE)",
            "        headers = self.create_user_and_login(rules=[rule], organization=org2)",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test permission to delete tasks of own organization - should work",
            "        headers = self.create_user_and_login(rules=[rule], organization=org)",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # test permission to delete own tasks - other user of organization",
            "        # should fail",
            "        rule = Rule.get_by_(\"task\", Scope.OWN, Operation.DELETE)",
            "        user = self.create_user(rules=[rule], organization=org)",
            "        task = Task(collaboration=col, init_org=org, init_user=user)",
            "        task.save()",
            "        headers = self.create_user_and_login(rules=[rule], organization=org)",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test permission to delete own tasks with same user",
            "        headers = self.login(user.username)",
            "        results = self.app.delete(f'/api/task/{task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)",
            "",
            "        # cleanup",
            "        user.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        col.delete()",
            "",
            "    def test_view_task_result_permissions_as_user(self):",
            "",
            "        # non-existing task",
            "        headers = self.create_user_and_login()",
            "        result = self.app.get('/api/task/9999/run', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.NOT_FOUND)",
            "",
            "        # test with organization permissions from other organization",
            "        org = Organization()",
            "        org2 = Organization()",
            "        col = Collaboration(organizations=[org, org2])",
            "        col.save()",
            "        task = Task(collaboration=col, init_org=org)",
            "        # NB: node is used implicitly in task/{id}/result schema",
            "        node = Node(organization=org, collaboration=col)",
            "        res = Run(task=task, organization=org)",
            "        res.save()",
            "",
            "        # Test with permissions of someone who is not in the collaboration",
            "        rule = Rule.get_by_(\"run\", Scope.COLLABORATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test with collaboration permission",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test with global permission",
            "        rule = Rule.get_by_(\"run\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test also result endpoint",
            "        rule = Rule.get_by_(\"run\", Scope.COLLABORATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(",
            "            f'/api/result?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test result endpoint with organization permission",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.get(",
            "            f'/api/result?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test result endpoint with global permission",
            "        rule = Rule.get_by_(\"run\", Scope.GLOBAL, Operation.VIEW)",
            "        headers = self.create_user_and_login(rules=[rule])",
            "        result = self.app.get(",
            "            f'/api/result?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test with organization permission",
            "        rule = Rule.get_by_(\"run\", Scope.ORGANIZATION, Operation.VIEW)",
            "        headers = self.create_user_and_login(org, [rule])",
            "        result = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        result = self.app.get(f'/api/run/{res.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test with organization permission - other organization should fail",
            "        headers = self.create_user_and_login(org2, [rule])",
            "        result = self.app.get(",
            "            f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        result = self.app.get(f'/api/run/{res.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # test with permission to view own runs",
            "        rule = Rule.get_by_(\"run\", Scope.OWN, Operation.VIEW)",
            "        user = self.create_user(rules=[rule], organization=org)",
            "        headers = self.login(user.username)",
            "        task2 = Task(collaboration=col, init_org=org, init_user=user)",
            "        task2.save()",
            "        res2 = Run(task=task2, organization=org)",
            "        res2.save()",
            "        result = self.app.get(f'/api/run?task_id={task2.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "        result = self.app.get(f'/api/run/{res2.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.OK)",
            "",
            "        # test with permission to view own runs - other user should fail",
            "        headers = self.create_user_and_login(rules=[rule], organization=org)",
            "        result = self.app.get(f'/api/run?task_id={task2.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "        result = self.app.get(f'/api/run/{res2.id}', headers=headers)",
            "        self.assertEqual(result.status_code, HTTPStatus.UNAUTHORIZED)",
            "",
            "        # cleanup",
            "        node.delete()",
            "        task.delete()",
            "        task2.delete()",
            "        res.delete()",
            "        res2.delete()",
            "        org.delete()",
            "        org2.delete()",
            "        col.delete()",
            "",
            "    def test_view_task_run_permissions_as_container(self):",
            "        # test if container can",
            "        org = Organization()",
            "        col = Collaboration(organizations=[org])",
            "        task = Task(collaboration=col, image=\"some-image\", init_org=org)",
            "        task.save()",
            "        res = Run(task=task, organization=org, status=TaskStatus.PENDING)",
            "        res.save()",
            "",
            "        headers = self.login_container(collaboration=col, organization=org,",
            "                                       task=task)",
            "        results = self.app.get(f'/api/run?task_id={task.id}', headers=headers)",
            "        self.assertEqual(results.status_code, HTTPStatus.OK)"
        ],
        "action": [],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "vantage6-server/vantage6/server/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import importlib"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import logging"
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import os"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import uuid"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import json"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import time"
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import datetime as dt"
            },
            "8": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import traceback"
            },
            "9": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Any"
            },
            "11": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from http import HTTPStatus"
            },
            "12": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from werkzeug.exceptions import HTTPException"
            },
            "13": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from flasgger import Swagger"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "The server has a central function in the vantage6 architecture. It stores",
            "in the database which organizations, collaborations, users, etc.",
            "exist. It allows the users and nodes to authenticate and subsequently interact",
            "through the API the server hosts. Finally, it also communicates with",
            "authenticated nodes and users via the socketIO server that is run here.",
            "\"\"\"",
            "# -*- coding: utf-8 -*-",
            "from gevent import monkey",
            "",
            "# flake8: noqa: E402 (ignore import error)",
            "monkey.patch_all()",
            "",
            "import importlib",
            "import logging",
            "import os",
            "import uuid",
            "import json",
            "import time",
            "import datetime as dt",
            "import traceback",
            "",
            "from typing import Any",
            "from http import HTTPStatus",
            "from werkzeug.exceptions import HTTPException",
            "from flasgger import Swagger",
            "from flask import (",
            "    Flask, make_response, current_app, request, send_from_directory, Request,",
            "    Response",
            ")",
            "from flask_cors import CORS",
            "from flask_jwt_extended import JWTManager",
            "from flask_marshmallow import Marshmallow",
            "from flask_restful import Api",
            "from flask_mail import Mail",
            "from flask_principal import Principal, Identity, identity_changed",
            "from flask_socketio import SocketIO",
            "from threading import Thread",
            "from pathlib import Path",
            "",
            "from vantage6.common import logger_name",
            "from vantage6.common.globals import PING_INTERVAL_SECONDS",
            "from vantage6.server import db",
            "from vantage6.cli.context import ServerContext",
            "from vantage6.server.model.base import DatabaseSessionManager, Database",
            "from vantage6.server.resource.common.output_schema import HATEOASModelSchema",
            "from vantage6.server.permission import RuleNeed, PermissionManager",
            "from vantage6.server.globals import (",
            "    APPNAME,",
            "    ACCESS_TOKEN_EXPIRES_HOURS,",
            "    RESOURCES,",
            "    SUPER_USER_INFO,",
            "    REFRESH_TOKENS_EXPIRE_HOURS,",
            "    DEFAULT_SUPPORT_EMAIL_ADDRESS,",
            "    MIN_TOKEN_VALIDITY_SECONDS,",
            "    MIN_REFRESH_TOKEN_EXPIRY_DELTA,",
            "    SERVER_MODULE_NAME",
            ")",
            "from vantage6.server.resource.common.swagger_templates import swagger_template",
            "from vantage6.server._version import __version__",
            "from vantage6.server.mail_service import MailService",
            "from vantage6.server.websockets import DefaultSocketNamespace",
            "from vantage6.server.default_roles import get_default_roles, DefaultRole",
            "",
            "",
            "module_name = logger_name(__name__)",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "class ServerApp:",
            "    \"\"\"",
            "    Vantage6 server instance.",
            "",
            "    Attributes",
            "    ----------",
            "    ctx : ServerContext",
            "        Context object that contains the configuration of the server.",
            "    \"\"\"",
            "",
            "    def __init__(self, ctx: ServerContext) -> None:",
            "        \"\"\"Create a vantage6-server application.\"\"\"",
            "",
            "        self.ctx = ctx",
            "",
            "        # initialize, configure Flask",
            "        self.app = Flask(",
            "            SERVER_MODULE_NAME, root_path=Path(__file__),",
            "            template_folder=Path(__file__).parent / 'templates',",
            "            static_folder=Path(__file__).parent / 'static'",
            "        )",
            "        self.debug: dict = self.ctx.config.get('debug', {})",
            "        self.configure_flask()",
            "",
            "        # Setup SQLAlchemy and Marshmallow for marshalling/serializing",
            "        self.ma = Marshmallow(self.app)",
            "",
            "        # Setup the Flask-JWT-Extended extension (JWT: JSON Web Token)",
            "        self.jwt = JWTManager(self.app)",
            "        self.configure_jwt()",
            "",
            "        # Setup Principal, granular API access manegement",
            "        self.principal = Principal(self.app, use_sessions=False)",
            "",
            "        # Enable cross-origin resource sharing",
            "        self.cors = CORS(self.app)",
            "",
            "        # SWAGGER documentation",
            "        self.swagger = Swagger(self.app, template=swagger_template)",
            "",
            "        # Setup the Flask-Mail client",
            "        self.mail = MailService(self.app, Mail(self.app))",
            "",
            "        # Setup websocket channel",
            "        self.socketio = self.setup_socket_connection()",
            "",
            "        # setup the permission manager for the API endpoints",
            "        self.permissions = PermissionManager()",
            "",
            "        # Api - REST JSON-rpc",
            "        self.api = Api(self.app)",
            "        self.configure_api()",
            "        self.load_resources()",
            "",
            "        # set the server version",
            "        self.__version__ = __version__",
            "",
            "        # set up socket ping/pong",
            "        log.debug(\"Starting thread to set node status\")",
            "        t = Thread(target=self.__node_status_worker, daemon=True)",
            "        t.start()",
            "",
            "        log.info(\"Initialization done\")",
            "",
            "    def setup_socket_connection(self) -> SocketIO:",
            "        \"\"\"",
            "        Setup a socket connection. If a message queue is defined, connect the",
            "        socket to the message queue. Otherwise, use the default socketio",
            "        settings.",
            "",
            "        Returns",
            "        -------",
            "        SocketIO",
            "            SocketIO object",
            "        \"\"\"",
            "",
            "        msg_queue = self.ctx.config.get('rabbitmq_uri')",
            "        if msg_queue:",
            "            log.debug(f'Connecting to msg queue: {msg_queue}')",
            "",
            "        debug_mode = self.debug.get('socketio', False)",
            "        if debug_mode:",
            "            log.debug(\"SocketIO debug mode enabled\")",
            "        try:",
            "            socketio = SocketIO(",
            "                self.app,",
            "                async_mode='gevent_uwsgi',",
            "                message_queue=msg_queue,",
            "                ping_timeout=60,",
            "                cors_allowed_origins='*',",
            "                logger=debug_mode,",
            "                engineio_logger=debug_mode",
            "            )",
            "        except Exception as e:",
            "            log.warning('Default socketio settings failed, attempt to run '",
            "                        'without gevent_uwsgi packages! This leads to '",
            "                        'performance issues and possible issues concerning '",
            "                        'the websocket channels!')",
            "            log.debug(e)",
            "            socketio = SocketIO(",
            "                self.app,",
            "                message_queue=msg_queue,",
            "                ping_timeout=60,",
            "                cors_allowed_origins='*',",
            "                logger=debug_mode,",
            "                engineio_logger=debug_mode",
            "            )",
            "",
            "        # FIXME: temporary fix to get socket object into the namespace class",
            "        DefaultSocketNamespace.socketio = socketio",
            "        socketio.on_namespace(DefaultSocketNamespace(\"/tasks\"))",
            "",
            "        return socketio",
            "",
            "    def configure_flask(self) -> None:",
            "        \"\"\"Configure the Flask settings of the vantage6 server.\"\"\"",
            "",
            "        # let us handle exceptions",
            "        self.app.config['PROPAGATE_EXCEPTIONS'] = True",
            "",
            "        # patch where to obtain token",
            "        self.app.config['JWT_AUTH_URL_RULE'] = '/api/token'",
            "",
            "        # If no secret is set in the config file, one is generated. This",
            "        # implies that all (even refresh) tokens will be invalidated on restart",
            "        self.app.config['JWT_SECRET_KEY'] = self.ctx.config.get(",
            "            'jwt_secret_key',",
            "            str(uuid.uuid1())",
            "        )",
            "",
            "        # Default expiration time",
            "        token_expiry_seconds = self._get_jwt_expiration_seconds(",
            "            config_key='token_expires_hours',",
            "            default_hours=ACCESS_TOKEN_EXPIRES_HOURS",
            "        )",
            "        self.app.config['JWT_ACCESS_TOKEN_EXPIRES'] = token_expiry_seconds",
            "",
            "        # Set refresh token expiration time",
            "        self.app.config['JWT_REFRESH_TOKEN_EXPIRES'] = \\",
            "                self._get_jwt_expiration_seconds(",
            "            config_key='refresh_token_expires_hours',",
            "            default_hours=REFRESH_TOKENS_EXPIRE_HOURS,",
            "            longer_than=token_expiry_seconds + MIN_REFRESH_TOKEN_EXPIRY_DELTA,",
            "            is_refresh=True",
            "        )",
            "",
            "        # Open Api Specification (f.k.a. swagger)",
            "        self.app.config['SWAGGER'] = {",
            "            'title': APPNAME,",
            "            'uiversion': \"3\",",
            "            'openapi': '3.0.0',",
            "            'version': __version__",
            "        }",
            "",
            "        # Mail settings",
            "        mail_config = self.ctx.config.get(\"smtp\", {})",
            "        self.app.config[\"MAIL_PORT\"] = mail_config.get(\"port\", 1025)",
            "        self.app.config[\"MAIL_SERVER\"] = mail_config.get(\"server\", \"localhost\")",
            "        self.app.config[\"MAIL_USERNAME\"] = mail_config.get(",
            "            \"username\",",
            "            DEFAULT_SUPPORT_EMAIL_ADDRESS",
            "        )",
            "        self.app.config[\"MAIL_PASSWORD\"] = mail_config.get(\"password\", \"\")",
            "        self.app.config[\"MAIL_USE_TLS\"] = mail_config.get(\"MAIL_USE_TLS\",",
            "                                                          True)",
            "        self.app.config[\"MAIL_USE_SSL\"] = mail_config.get(\"MAIL_USE_SSL\",",
            "                                                          False)",
            "        debug_mode = self.debug.get('flask', False)",
            "        if debug_mode:",
            "            log.debug(\"Flask debug mode enabled\")",
            "        self.app.debug = debug_mode",
            "",
            "        def _get_request_path(request: Request) -> str:",
            "            \"\"\"",
            "            Return request extension of request URL, e.g.",
            "            http://localhost:5000/api/task/1 -> api/task/1",
            "",
            "            Parameters",
            "            ----------",
            "            request: Request",
            "                Flask request object",
            "",
            "            Returns",
            "            -------",
            "            string:",
            "                The endpoint path of the request",
            "            \"\"\"",
            "            return request.url.replace(request.url_root, '')",
            "",
            "        # before request",
            "        @self.app.before_request",
            "        def do_before_request():",
            "            \"\"\"Before every flask request method.\"\"\"",
            "            # Add log message before each request",
            "            log.debug(f\"Received request: {request.method} \"",
            "                      f\"{_get_request_path(request)}\")",
            "",
            "            # This will obtain a (scoped) db session from the session factory",
            "            # that is linked to the flask request global `g`. In every endpoint",
            "            # we then can access the database by using this session. We ensure",
            "            # that the session is removed (and uncommited changes are rolled",
            "            # back) at the end of every request.",
            "            DatabaseSessionManager.new_session()",
            "",
            "        @self.app.after_request",
            "        def remove_db_session(response):",
            "            \"\"\"After every flask request.",
            "",
            "            This will close the database session created by the",
            "            `before_request`.",
            "            \"\"\"",
            "            DatabaseSessionManager.clear_session()",
            "            return response",
            "",
            "        @self.app.errorhandler(HTTPException)",
            "        def error_remove_db_session(error: HTTPException):",
            "            \"\"\"In case an HTTP-exception occurs during the request.",
            "",
            "            It is important to close the db session to avoid having dangling",
            "            sessions.",
            "            \"\"\"",
            "            if error.code == 404:",
            "                log.debug(",
            "                    f\"404 error for route '{_get_request_path(request)}'\")",
            "            else:",
            "                log.warn('HTTP Exception occured during request')",
            "                log.debug(traceback.format_exc())",
            "            DatabaseSessionManager.clear_session()",
            "            return error.get_response()",
            "",
            "        @self.app.errorhandler(Exception)",
            "        def error2_remove_db_session(error):",
            "            \"\"\"In case an exception occurs during the request.",
            "",
            "            It is important to close the db session to avoid having dangling",
            "            sessions.",
            "            \"\"\"",
            "            log.exception('Exception occured during request')",
            "            DatabaseSessionManager.clear_session()",
            "            return {'msg': f'An unexpected error occurred on the server!'}, \\",
            "                HTTPStatus.INTERNAL_SERVER_ERROR",
            "",
            "        @self.app.route('/robots.txt')",
            "        def static_from_root():",
            "            return send_from_directory(self.app.static_folder,",
            "                                       request.path[1:])",
            "",
            "    def _get_jwt_expiration_seconds(",
            "        self, config_key: str, default_hours: int,",
            "        longer_than: int = MIN_TOKEN_VALIDITY_SECONDS,",
            "        is_refresh: bool = False",
            "    ) -> int:",
            "        \"\"\"",
            "        Return the expiration time for JWT tokens.",
            "",
            "        This time may be specified in the config file. If it is not, the",
            "        default value is returned.",
            "",
            "        Parameters",
            "        ----------",
            "        config_key: str",
            "            The config key to look for that sets the expiration time",
            "        default_hours: int",
            "            The default expiration time in hours",
            "        longer_than: int",
            "            The minimum expiration time in hours.",
            "        is_refresh: bool",
            "            If True, the expiration time is for a refresh token. If False, it",
            "            is for an access token.",
            "",
            "        Returns",
            "        -------",
            "        int:",
            "            The JWT token expiration time in seconds",
            "        \"\"\"",
            "        hours_expire = self.ctx.config.get(config_key)",
            "        if hours_expire is None:",
            "            # No value is present in the config file, use default",
            "            seconds_expire = int(float(default_hours) * 3600)",
            "        elif isinstance(hours_expire, (int, float)) or \\",
            "                hours_expire.replace(\".\", \"\").isnumeric():",
            "            # Numeric value is present in the config file",
            "            seconds_expire = int(float(hours_expire) * 3600)",
            "            if seconds_expire < longer_than:",
            "                log.warning(",
            "                    f\"Invalid value for '{config_key}': {hours_expire}. Tokens\"",
            "                    f\" must be valid for at least {longer_than} seconds. Using\"",
            "                    f\" default value: {default_hours} hours\")",
            "                if is_refresh:",
            "                    log.warning(\"Note that refresh tokens should be valid at \"",
            "                                f\"least {MIN_REFRESH_TOKEN_EXPIRY_DELTA} \"",
            "                                \"seconds longer than access tokens.\")",
            "                seconds_expire = int(float(default_hours) * 3600)",
            "        else:",
            "            # Non-numeric value is present in the config file. Warn and use",
            "            # default",
            "            log.error(f\"Invalid value for '{config_key}': {hours_expire}. \"",
            "                      f\"Using default value: {default_hours} hours\")",
            "            seconds_expire = int(float(default_hours) * 3600)",
            "",
            "        return seconds_expire",
            "",
            "    def configure_api(self) -> None:",
            "        \"\"\"Define global API output and its structure.\"\"\"",
            "",
            "        # helper to create HATEOAS schemas",
            "        HATEOASModelSchema.api = self.api",
            "",
            "        # whatever you get try to json it",
            "        @self.api.representation('application/json')",
            "        # pylint: disable=unused-argument",
            "        def output_json(",
            "            data: db.Base | list[db.Base], code: HTTPStatus,",
            "            headers: dict = None",
            "        ) -> Response:",
            "            \"\"\"",
            "            Return jsonified data for request responses.",
            "",
            "            Parameters",
            "            ----------",
            "            data: db.Base | list[db.Base]",
            "                The data to be jsonified",
            "            code: HTTPStatus",
            "                The HTTP status code of the response",
            "            headers: dict",
            "                Additional headers to be added to the response",
            "            \"\"\"",
            "",
            "            if isinstance(data, db.Base):",
            "                data = db.jsonable(data)",
            "            elif isinstance(data, list) and len(data) and \\",
            "                    isinstance(data[0], db.Base):",
            "                data = db.jsonable(data)",
            "",
            "            resp = make_response(json.dumps(data), code)",
            "            resp.headers.extend(headers or {})",
            "            return resp",
            "",
            "    def configure_jwt(self):",
            "        \"\"\"Configure JWT authentication.\"\"\"",
            "",
            "        @self.jwt.additional_claims_loader",
            "        # pylint: disable=unused-argument",
            "        def additional_claims_loader(",
            "                identity: db.Authenticatable | dict) -> dict:",
            "            \"\"\"",
            "            Create additional claims for JWT tokens: set user type and for",
            "            users, set their roles.",
            "",
            "            Parameters",
            "            ----------",
            "            identity: db.Authenticatable | dict",
            "                The identity for which to create the claims",
            "",
            "            Returns",
            "            -------",
            "            dict:",
            "                The claims to be added to the JWT token",
            "            \"\"\"",
            "            roles = []",
            "            if isinstance(identity, db.User):",
            "                type_ = 'user'",
            "                roles = [role.name for role in identity.roles]",
            "",
            "            elif isinstance(identity, db.Node):",
            "                type_ = 'node'",
            "            elif isinstance(identity, dict):",
            "                type_ = 'container'",
            "            else:",
            "                log.error(f\"could not create claims from {str(identity)}\")",
            "                return",
            "",
            "            claims = {",
            "                'client_type': type_,",
            "                'roles': roles,",
            "            }",
            "",
            "            return claims",
            "",
            "        @self.jwt.user_identity_loader",
            "        # pylint: disable=unused-argument",
            "        def user_identity_loader(",
            "                identity: db.Authenticatable | dict) -> str | dict:",
            "            \"\"\"\"",
            "            JSON serializing identity to be used by ``create_access_token``.",
            "",
            "            Parameters",
            "            ----------",
            "            identity: db.Authenticatable | dict",
            "                The identity to be serialized",
            "",
            "            Returns",
            "            -------",
            "            str | dict:",
            "                The serialized identity. For a node or user, this is the id;",
            "                for a container, it is a dict.",
            "            \"\"\"",
            "            if isinstance(identity, db.Authenticatable):",
            "                return identity.id",
            "            if isinstance(identity, dict):",
            "                return identity",
            "",
            "            log.error(f\"Could not create a JSON serializable identity \\",
            "                        from '{str(identity)}'\")",
            "",
            "        @self.jwt.user_lookup_loader",
            "        # pylint: disable=unused-argument",
            "        def user_lookup_loader(",
            "            jwt_payload: dict, jwt_headers: dict",
            "        ) -> db.Authenticatable | dict:",
            "            \"\"\"",
            "            Load the user, node or container instance from the JWT payload.",
            "",
            "            Parameters",
            "            ----------",
            "            jwt_payload: dict",
            "                The JWT payload",
            "            jwt_headers: dict",
            "                The JWT headers",
            "",
            "            Returns",
            "            -------",
            "            db.Authenticatable | dict:",
            "                The user, node or container identity. If the identity is a",
            "                container, a dict is returned.",
            "            \"\"\"",
            "            identity = jwt_headers['sub']",
            "            auth_identity = Identity(identity)",
            "",
            "            # in case of a user or node an auth id is shared as identity",
            "            if isinstance(identity, int):",
            "",
            "                # auth_identity = Identity(identity)",
            "",
            "                auth = db.Authenticatable.get(identity)",
            "",
            "                if isinstance(auth, db.Node):",
            "",
            "                    for rule in db.Role.get_by_name(DefaultRole.NODE).rules:",
            "                        auth_identity.provides.add(",
            "                                RuleNeed(",
            "                                    name=rule.name,",
            "                                    scope=rule.scope,",
            "                                    operation=rule.operation",
            "                                )",
            "                            )",
            "",
            "                if isinstance(auth, db.User):",
            "",
            "                    # add role permissions",
            "                    for role in auth.roles:",
            "                        for rule in role.rules:",
            "                            auth_identity.provides.add(",
            "                                RuleNeed(",
            "                                    name=rule.name,",
            "                                    scope=rule.scope,",
            "                                    operation=rule.operation",
            "                                )",
            "                            )",
            "",
            "                    # add 'extra' permissions",
            "                    for rule in auth.rules:",
            "                        auth_identity.provides.add(",
            "                            RuleNeed(",
            "                                name=rule.name,",
            "                                scope=rule.scope,",
            "                                operation=rule.operation",
            "                            )",
            "                        )",
            "",
            "                identity_changed.send(current_app._get_current_object(),",
            "                                      identity=auth_identity)",
            "",
            "                return auth",
            "            else:",
            "                # container identity",
            "",
            "                for rule in db.Role.get_by_name(DefaultRole.CONTAINER).rules:",
            "                    auth_identity.provides.add(",
            "                        RuleNeed(",
            "                            name=rule.name,",
            "                            scope=rule.scope,",
            "                            operation=rule.operation",
            "                        )",
            "                    )",
            "                identity_changed.send(current_app._get_current_object(),",
            "                                      identity=auth_identity)",
            "                log.debug(identity)",
            "                return identity",
            "",
            "    def load_resources(self) -> None:",
            "        \"\"\"Import the modules containing API resources.\"\"\"",
            "",
            "        # make services available to the endpoints, this way each endpoint can",
            "        # make use of 'em.",
            "        services = {",
            "            \"socketio\": self.socketio,",
            "            \"mail\": self.mail,",
            "            \"api\": self.api,",
            "            \"permissions\": self.permissions,",
            "            \"config\": self.ctx.config",
            "        }",
            "",
            "        for res in RESOURCES:",
            "            module = importlib.import_module('vantage6.server.resource.' + res)",
            "            module.setup(self.api, self.ctx.config['api_path'], services)",
            "",
            "    # TODO consider moving this method elsewhere. This is not trivial at the",
            "    # moment because of the circular import issue with `db`, see",
            "    # https://github.com/vantage6/vantage6/issues/53",
            "    @staticmethod",
            "    def _add_default_roles() -> None:",
            "        for role in get_default_roles(db):",
            "            if not db.Role.get_by_name(role['name']):",
            "                log.warn(f\"Creating new default role {role['name']}...\")",
            "                new_role = db.Role(",
            "                    name=role['name'],",
            "                    description=role['description'],",
            "                    rules=role['rules']",
            "                )",
            "                new_role.save()",
            "",
            "    def start(self) -> None:",
            "        \"\"\"",
            "        Start the server.",
            "",
            "        Before server is really started, some database settings are checked and",
            "        (re)set where appropriate.",
            "        \"\"\"",
            "        # add default roles (if they don't exist yet)",
            "        self._add_default_roles()",
            "",
            "        # create root user if it is not in the DB yet",
            "        try:",
            "            db.User.get_by_username(SUPER_USER_INFO['username'])",
            "        except Exception:",
            "            log.warn(\"No root user found! Is this the first run?\")",
            "",
            "            log.debug(\"Creating organization for root user\")",
            "            org = db.Organization(name=\"root\")",
            "",
            "            # TODO use constant instead of 'Root' literal",
            "            root = db.Role.get_by_name(\"Root\")",
            "",
            "            log.warn(f\"Creating root user: \"",
            "                     f\"username={SUPER_USER_INFO['username']}, \"",
            "                     f\"password={SUPER_USER_INFO['password']}\")",
            "",
            "            user = db.User(username=SUPER_USER_INFO['username'], roles=[root],",
            "                           organization=org, email=\"root@domain.ext\",",
            "                           password=SUPER_USER_INFO['password'],",
            "                           failed_login_attempts=0,",
            "                           last_login_attempt=None)",
            "            user.save()",
            "        return self",
            "",
            "    def __node_status_worker(self) -> None:",
            "        \"\"\"",
            "        Set node status to offline if they haven't send a ping message in a",
            "        while.",
            "        \"\"\"",
            "        # start periodic check if nodes are responsive",
            "        while True:",
            "            # Send ping event",
            "            try:",
            "                before_wait = dt.datetime.utcnow()",
            "",
            "                # Wait a while to give nodes opportunity to pong. This interval",
            "                # is a bit longer than the interval at which the nodes ping,",
            "                # because we want to make sure that the nodes have had time to",
            "                # respond.",
            "                time.sleep(PING_INTERVAL_SECONDS + 5)",
            "",
            "                # Check for each node that is online if they have responded.",
            "                # Otherwise set them to offline.",
            "                online_status_nodes = db.Node.get_online_nodes()",
            "                for node in online_status_nodes:",
            "                    if node.last_seen < before_wait:",
            "                        node.status = 'offline'",
            "                        node.save()",
            "            except Exception:",
            "                log.exception('Node-status thread had an exception')",
            "                time.sleep(PING_INTERVAL_SECONDS)",
            "",
            "",
            "def run_server(config: str, system_folders: bool = True) -> ServerApp:",
            "    \"\"\"",
            "    Run a vantage6 server.",
            "",
            "    Parameters",
            "    ----------",
            "    config: str",
            "        Configuration file path",
            "    system_folders: bool",
            "        Whether to use system or user folders. Default is True.",
            "",
            "    Returns",
            "    -------",
            "    ServerApp",
            "        A running instance of the vantage6 server",
            "    \"\"\"",
            "    ctx = ServerContext.from_external_config_file(",
            "        config,",
            "        system_folders",
            "    )",
            "    allow_drop_all = ctx.config[\"allow_drop_all\"]",
            "    Database().connect(uri=ctx.get_database_uri(),",
            "                       allow_drop_all=allow_drop_all)",
            "    return ServerApp(ctx).start()",
            "",
            "",
            "def run_dev_server(server_app: ServerApp, *args, **kwargs) -> None:",
            "    \"\"\"",
            "    Run a vantage6 development server (outside of a Docker container).",
            "",
            "    Parameters",
            "    ----------",
            "    server_app: ServerApp",
            "        Instance of a vantage6 server",
            "    \"\"\"",
            "    log.warn('*'*80)",
            "    log.warn(' DEVELOPMENT SERVER '.center(80, '*'))",
            "    log.warn('*'*80)",
            "    kwargs.setdefault('log_output', False)",
            "    server_app.socketio.run(server_app.app, *args, **kwargs)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "The server has a central function in the vantage6 architecture. It stores",
            "in the database which organizations, collaborations, users, etc.",
            "exist. It allows the users and nodes to authenticate and subsequently interact",
            "through the API the server hosts. Finally, it also communicates with",
            "authenticated nodes and users via the socketIO server that is run here.",
            "\"\"\"",
            "# -*- coding: utf-8 -*-",
            "from gevent import monkey",
            "",
            "# flake8: noqa: E402 (ignore import error)",
            "monkey.patch_all()",
            "",
            "import importlib",
            "import logging",
            "import uuid",
            "import json",
            "import time",
            "import datetime as dt",
            "import traceback",
            "",
            "from http import HTTPStatus",
            "from werkzeug.exceptions import HTTPException",
            "from flasgger import Swagger",
            "from flask import (",
            "    Flask, make_response, current_app, request, send_from_directory, Request,",
            "    Response",
            ")",
            "from flask_cors import CORS",
            "from flask_jwt_extended import JWTManager",
            "from flask_marshmallow import Marshmallow",
            "from flask_restful import Api",
            "from flask_mail import Mail",
            "from flask_principal import Principal, Identity, identity_changed",
            "from flask_socketio import SocketIO",
            "from threading import Thread",
            "from pathlib import Path",
            "",
            "from vantage6.common import logger_name",
            "from vantage6.common.globals import PING_INTERVAL_SECONDS",
            "from vantage6.server import db",
            "from vantage6.cli.context import ServerContext",
            "from vantage6.server.model.base import DatabaseSessionManager, Database",
            "from vantage6.server.resource.common.output_schema import HATEOASModelSchema",
            "from vantage6.server.permission import RuleNeed, PermissionManager",
            "from vantage6.server.globals import (",
            "    APPNAME,",
            "    ACCESS_TOKEN_EXPIRES_HOURS,",
            "    RESOURCES,",
            "    SUPER_USER_INFO,",
            "    REFRESH_TOKENS_EXPIRE_HOURS,",
            "    DEFAULT_SUPPORT_EMAIL_ADDRESS,",
            "    MIN_TOKEN_VALIDITY_SECONDS,",
            "    MIN_REFRESH_TOKEN_EXPIRY_DELTA,",
            "    SERVER_MODULE_NAME",
            ")",
            "from vantage6.server.resource.common.swagger_templates import swagger_template",
            "from vantage6.server._version import __version__",
            "from vantage6.server.mail_service import MailService",
            "from vantage6.server.websockets import DefaultSocketNamespace",
            "from vantage6.server.default_roles import get_default_roles, DefaultRole",
            "",
            "",
            "module_name = logger_name(__name__)",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "class ServerApp:",
            "    \"\"\"",
            "    Vantage6 server instance.",
            "",
            "    Attributes",
            "    ----------",
            "    ctx : ServerContext",
            "        Context object that contains the configuration of the server.",
            "    \"\"\"",
            "",
            "    def __init__(self, ctx: ServerContext) -> None:",
            "        \"\"\"Create a vantage6-server application.\"\"\"",
            "",
            "        self.ctx = ctx",
            "",
            "        # initialize, configure Flask",
            "        self.app = Flask(",
            "            SERVER_MODULE_NAME, root_path=Path(__file__),",
            "            template_folder=Path(__file__).parent / 'templates',",
            "            static_folder=Path(__file__).parent / 'static'",
            "        )",
            "        self.debug: dict = self.ctx.config.get('debug', {})",
            "        self.configure_flask()",
            "",
            "        # Setup SQLAlchemy and Marshmallow for marshalling/serializing",
            "        self.ma = Marshmallow(self.app)",
            "",
            "        # Setup the Flask-JWT-Extended extension (JWT: JSON Web Token)",
            "        self.jwt = JWTManager(self.app)",
            "        self.configure_jwt()",
            "",
            "        # Setup Principal, granular API access manegement",
            "        self.principal = Principal(self.app, use_sessions=False)",
            "",
            "        # Enable cross-origin resource sharing",
            "        self.cors = CORS(self.app)",
            "",
            "        # SWAGGER documentation",
            "        self.swagger = Swagger(self.app, template=swagger_template)",
            "",
            "        # Setup the Flask-Mail client",
            "        self.mail = MailService(self.app, Mail(self.app))",
            "",
            "        # Setup websocket channel",
            "        self.socketio = self.setup_socket_connection()",
            "",
            "        # setup the permission manager for the API endpoints",
            "        self.permissions = PermissionManager()",
            "",
            "        # Api - REST JSON-rpc",
            "        self.api = Api(self.app)",
            "        self.configure_api()",
            "        self.load_resources()",
            "",
            "        # set the server version",
            "        self.__version__ = __version__",
            "",
            "        # set up socket ping/pong",
            "        log.debug(\"Starting thread to set node status\")",
            "        t = Thread(target=self.__node_status_worker, daemon=True)",
            "        t.start()",
            "",
            "        log.info(\"Initialization done\")",
            "",
            "    def setup_socket_connection(self) -> SocketIO:",
            "        \"\"\"",
            "        Setup a socket connection. If a message queue is defined, connect the",
            "        socket to the message queue. Otherwise, use the default socketio",
            "        settings.",
            "",
            "        Returns",
            "        -------",
            "        SocketIO",
            "            SocketIO object",
            "        \"\"\"",
            "",
            "        msg_queue = self.ctx.config.get('rabbitmq_uri')",
            "        if msg_queue:",
            "            log.debug(f'Connecting to msg queue: {msg_queue}')",
            "",
            "        debug_mode = self.debug.get('socketio', False)",
            "        if debug_mode:",
            "            log.debug(\"SocketIO debug mode enabled\")",
            "        try:",
            "            socketio = SocketIO(",
            "                self.app,",
            "                async_mode='gevent_uwsgi',",
            "                message_queue=msg_queue,",
            "                ping_timeout=60,",
            "                cors_allowed_origins='*',",
            "                logger=debug_mode,",
            "                engineio_logger=debug_mode",
            "            )",
            "        except Exception as e:",
            "            log.warning('Default socketio settings failed, attempt to run '",
            "                        'without gevent_uwsgi packages! This leads to '",
            "                        'performance issues and possible issues concerning '",
            "                        'the websocket channels!')",
            "            log.debug(e)",
            "            socketio = SocketIO(",
            "                self.app,",
            "                message_queue=msg_queue,",
            "                ping_timeout=60,",
            "                cors_allowed_origins='*',",
            "                logger=debug_mode,",
            "                engineio_logger=debug_mode",
            "            )",
            "",
            "        # FIXME: temporary fix to get socket object into the namespace class",
            "        DefaultSocketNamespace.socketio = socketio",
            "        socketio.on_namespace(DefaultSocketNamespace(\"/tasks\"))",
            "",
            "        return socketio",
            "",
            "    def configure_flask(self) -> None:",
            "        \"\"\"Configure the Flask settings of the vantage6 server.\"\"\"",
            "",
            "        # let us handle exceptions",
            "        self.app.config['PROPAGATE_EXCEPTIONS'] = True",
            "",
            "        # patch where to obtain token",
            "        self.app.config['JWT_AUTH_URL_RULE'] = '/api/token'",
            "",
            "        # If no secret is set in the config file, one is generated. This",
            "        # implies that all (even refresh) tokens will be invalidated on restart",
            "        self.app.config['JWT_SECRET_KEY'] = self.ctx.config.get(",
            "            'jwt_secret_key',",
            "            str(uuid.uuid1())",
            "        )",
            "",
            "        # Default expiration time",
            "        token_expiry_seconds = self._get_jwt_expiration_seconds(",
            "            config_key='token_expires_hours',",
            "            default_hours=ACCESS_TOKEN_EXPIRES_HOURS",
            "        )",
            "        self.app.config['JWT_ACCESS_TOKEN_EXPIRES'] = token_expiry_seconds",
            "",
            "        # Set refresh token expiration time",
            "        self.app.config['JWT_REFRESH_TOKEN_EXPIRES'] = \\",
            "                self._get_jwt_expiration_seconds(",
            "            config_key='refresh_token_expires_hours',",
            "            default_hours=REFRESH_TOKENS_EXPIRE_HOURS,",
            "            longer_than=token_expiry_seconds + MIN_REFRESH_TOKEN_EXPIRY_DELTA,",
            "            is_refresh=True",
            "        )",
            "",
            "        # Open Api Specification (f.k.a. swagger)",
            "        self.app.config['SWAGGER'] = {",
            "            'title': APPNAME,",
            "            'uiversion': \"3\",",
            "            'openapi': '3.0.0',",
            "            'version': __version__",
            "        }",
            "",
            "        # Mail settings",
            "        mail_config = self.ctx.config.get(\"smtp\", {})",
            "        self.app.config[\"MAIL_PORT\"] = mail_config.get(\"port\", 1025)",
            "        self.app.config[\"MAIL_SERVER\"] = mail_config.get(\"server\", \"localhost\")",
            "        self.app.config[\"MAIL_USERNAME\"] = mail_config.get(",
            "            \"username\",",
            "            DEFAULT_SUPPORT_EMAIL_ADDRESS",
            "        )",
            "        self.app.config[\"MAIL_PASSWORD\"] = mail_config.get(\"password\", \"\")",
            "        self.app.config[\"MAIL_USE_TLS\"] = mail_config.get(\"MAIL_USE_TLS\",",
            "                                                          True)",
            "        self.app.config[\"MAIL_USE_SSL\"] = mail_config.get(\"MAIL_USE_SSL\",",
            "                                                          False)",
            "        debug_mode = self.debug.get('flask', False)",
            "        if debug_mode:",
            "            log.debug(\"Flask debug mode enabled\")",
            "        self.app.debug = debug_mode",
            "",
            "        def _get_request_path(request: Request) -> str:",
            "            \"\"\"",
            "            Return request extension of request URL, e.g.",
            "            http://localhost:5000/api/task/1 -> api/task/1",
            "",
            "            Parameters",
            "            ----------",
            "            request: Request",
            "                Flask request object",
            "",
            "            Returns",
            "            -------",
            "            string:",
            "                The endpoint path of the request",
            "            \"\"\"",
            "            return request.url.replace(request.url_root, '')",
            "",
            "        # before request",
            "        @self.app.before_request",
            "        def do_before_request():",
            "            \"\"\"Before every flask request method.\"\"\"",
            "            # Add log message before each request",
            "            log.debug(f\"Received request: {request.method} \"",
            "                      f\"{_get_request_path(request)}\")",
            "",
            "            # This will obtain a (scoped) db session from the session factory",
            "            # that is linked to the flask request global `g`. In every endpoint",
            "            # we then can access the database by using this session. We ensure",
            "            # that the session is removed (and uncommited changes are rolled",
            "            # back) at the end of every request.",
            "            DatabaseSessionManager.new_session()",
            "",
            "        @self.app.after_request",
            "        def remove_db_session(response):",
            "            \"\"\"After every flask request.",
            "",
            "            This will close the database session created by the",
            "            `before_request`.",
            "            \"\"\"",
            "            DatabaseSessionManager.clear_session()",
            "            return response",
            "",
            "        @self.app.errorhandler(HTTPException)",
            "        def error_remove_db_session(error: HTTPException):",
            "            \"\"\"In case an HTTP-exception occurs during the request.",
            "",
            "            It is important to close the db session to avoid having dangling",
            "            sessions.",
            "            \"\"\"",
            "            if error.code == 404:",
            "                log.debug(",
            "                    f\"404 error for route '{_get_request_path(request)}'\")",
            "            else:",
            "                log.warn('HTTP Exception occured during request')",
            "                log.debug(traceback.format_exc())",
            "            DatabaseSessionManager.clear_session()",
            "            return error.get_response()",
            "",
            "        @self.app.errorhandler(Exception)",
            "        def error2_remove_db_session(error):",
            "            \"\"\"In case an exception occurs during the request.",
            "",
            "            It is important to close the db session to avoid having dangling",
            "            sessions.",
            "            \"\"\"",
            "            log.exception('Exception occured during request')",
            "            DatabaseSessionManager.clear_session()",
            "            return {'msg': f'An unexpected error occurred on the server!'}, \\",
            "                HTTPStatus.INTERNAL_SERVER_ERROR",
            "",
            "        @self.app.route('/robots.txt')",
            "        def static_from_root():",
            "            return send_from_directory(self.app.static_folder,",
            "                                       request.path[1:])",
            "",
            "    def _get_jwt_expiration_seconds(",
            "        self, config_key: str, default_hours: int,",
            "        longer_than: int = MIN_TOKEN_VALIDITY_SECONDS,",
            "        is_refresh: bool = False",
            "    ) -> int:",
            "        \"\"\"",
            "        Return the expiration time for JWT tokens.",
            "",
            "        This time may be specified in the config file. If it is not, the",
            "        default value is returned.",
            "",
            "        Parameters",
            "        ----------",
            "        config_key: str",
            "            The config key to look for that sets the expiration time",
            "        default_hours: int",
            "            The default expiration time in hours",
            "        longer_than: int",
            "            The minimum expiration time in hours.",
            "        is_refresh: bool",
            "            If True, the expiration time is for a refresh token. If False, it",
            "            is for an access token.",
            "",
            "        Returns",
            "        -------",
            "        int:",
            "            The JWT token expiration time in seconds",
            "        \"\"\"",
            "        hours_expire = self.ctx.config.get(config_key)",
            "        if hours_expire is None:",
            "            # No value is present in the config file, use default",
            "            seconds_expire = int(float(default_hours) * 3600)",
            "        elif isinstance(hours_expire, (int, float)) or \\",
            "                hours_expire.replace(\".\", \"\").isnumeric():",
            "            # Numeric value is present in the config file",
            "            seconds_expire = int(float(hours_expire) * 3600)",
            "            if seconds_expire < longer_than:",
            "                log.warning(",
            "                    f\"Invalid value for '{config_key}': {hours_expire}. Tokens\"",
            "                    f\" must be valid for at least {longer_than} seconds. Using\"",
            "                    f\" default value: {default_hours} hours\")",
            "                if is_refresh:",
            "                    log.warning(\"Note that refresh tokens should be valid at \"",
            "                                f\"least {MIN_REFRESH_TOKEN_EXPIRY_DELTA} \"",
            "                                \"seconds longer than access tokens.\")",
            "                seconds_expire = int(float(default_hours) * 3600)",
            "        else:",
            "            # Non-numeric value is present in the config file. Warn and use",
            "            # default",
            "            log.error(f\"Invalid value for '{config_key}': {hours_expire}. \"",
            "                      f\"Using default value: {default_hours} hours\")",
            "            seconds_expire = int(float(default_hours) * 3600)",
            "",
            "        return seconds_expire",
            "",
            "    def configure_api(self) -> None:",
            "        \"\"\"Define global API output and its structure.\"\"\"",
            "",
            "        # helper to create HATEOAS schemas",
            "        HATEOASModelSchema.api = self.api",
            "",
            "        # whatever you get try to json it",
            "        @self.api.representation('application/json')",
            "        # pylint: disable=unused-argument",
            "        def output_json(",
            "            data: db.Base | list[db.Base], code: HTTPStatus,",
            "            headers: dict = None",
            "        ) -> Response:",
            "            \"\"\"",
            "            Return jsonified data for request responses.",
            "",
            "            Parameters",
            "            ----------",
            "            data: db.Base | list[db.Base]",
            "                The data to be jsonified",
            "            code: HTTPStatus",
            "                The HTTP status code of the response",
            "            headers: dict",
            "                Additional headers to be added to the response",
            "            \"\"\"",
            "",
            "            if isinstance(data, db.Base):",
            "                data = db.jsonable(data)",
            "            elif isinstance(data, list) and len(data) and \\",
            "                    isinstance(data[0], db.Base):",
            "                data = db.jsonable(data)",
            "",
            "            resp = make_response(json.dumps(data), code)",
            "            resp.headers.extend(headers or {})",
            "            return resp",
            "",
            "    def configure_jwt(self):",
            "        \"\"\"Configure JWT authentication.\"\"\"",
            "",
            "        @self.jwt.additional_claims_loader",
            "        # pylint: disable=unused-argument",
            "        def additional_claims_loader(",
            "                identity: db.Authenticatable | dict) -> dict:",
            "            \"\"\"",
            "            Create additional claims for JWT tokens: set user type and for",
            "            users, set their roles.",
            "",
            "            Parameters",
            "            ----------",
            "            identity: db.Authenticatable | dict",
            "                The identity for which to create the claims",
            "",
            "            Returns",
            "            -------",
            "            dict:",
            "                The claims to be added to the JWT token",
            "            \"\"\"",
            "            roles = []",
            "            if isinstance(identity, db.User):",
            "                type_ = 'user'",
            "                roles = [role.name for role in identity.roles]",
            "",
            "            elif isinstance(identity, db.Node):",
            "                type_ = 'node'",
            "            elif isinstance(identity, dict):",
            "                type_ = 'container'",
            "            else:",
            "                log.error(f\"could not create claims from {str(identity)}\")",
            "                return",
            "",
            "            claims = {",
            "                'client_type': type_,",
            "                'roles': roles,",
            "            }",
            "",
            "            return claims",
            "",
            "        @self.jwt.user_identity_loader",
            "        # pylint: disable=unused-argument",
            "        def user_identity_loader(",
            "                identity: db.Authenticatable | dict) -> str | dict:",
            "            \"\"\"\"",
            "            JSON serializing identity to be used by ``create_access_token``.",
            "",
            "            Parameters",
            "            ----------",
            "            identity: db.Authenticatable | dict",
            "                The identity to be serialized",
            "",
            "            Returns",
            "            -------",
            "            str | dict:",
            "                The serialized identity. For a node or user, this is the id;",
            "                for a container, it is a dict.",
            "            \"\"\"",
            "            if isinstance(identity, db.Authenticatable):",
            "                return identity.id",
            "            if isinstance(identity, dict):",
            "                return identity",
            "",
            "            log.error(f\"Could not create a JSON serializable identity \\",
            "                        from '{str(identity)}'\")",
            "",
            "        @self.jwt.user_lookup_loader",
            "        # pylint: disable=unused-argument",
            "        def user_lookup_loader(",
            "            jwt_payload: dict, jwt_headers: dict",
            "        ) -> db.Authenticatable | dict:",
            "            \"\"\"",
            "            Load the user, node or container instance from the JWT payload.",
            "",
            "            Parameters",
            "            ----------",
            "            jwt_payload: dict",
            "                The JWT payload",
            "            jwt_headers: dict",
            "                The JWT headers",
            "",
            "            Returns",
            "            -------",
            "            db.Authenticatable | dict:",
            "                The user, node or container identity. If the identity is a",
            "                container, a dict is returned.",
            "            \"\"\"",
            "            identity = jwt_headers['sub']",
            "            auth_identity = Identity(identity)",
            "",
            "            # in case of a user or node an auth id is shared as identity",
            "            if isinstance(identity, int):",
            "",
            "                # auth_identity = Identity(identity)",
            "",
            "                auth = db.Authenticatable.get(identity)",
            "",
            "                if isinstance(auth, db.Node):",
            "",
            "                    for rule in db.Role.get_by_name(DefaultRole.NODE).rules:",
            "                        auth_identity.provides.add(",
            "                                RuleNeed(",
            "                                    name=rule.name,",
            "                                    scope=rule.scope,",
            "                                    operation=rule.operation",
            "                                )",
            "                            )",
            "",
            "                if isinstance(auth, db.User):",
            "",
            "                    # add role permissions",
            "                    for role in auth.roles:",
            "                        for rule in role.rules:",
            "                            auth_identity.provides.add(",
            "                                RuleNeed(",
            "                                    name=rule.name,",
            "                                    scope=rule.scope,",
            "                                    operation=rule.operation",
            "                                )",
            "                            )",
            "",
            "                    # add 'extra' permissions",
            "                    for rule in auth.rules:",
            "                        auth_identity.provides.add(",
            "                            RuleNeed(",
            "                                name=rule.name,",
            "                                scope=rule.scope,",
            "                                operation=rule.operation",
            "                            )",
            "                        )",
            "",
            "                identity_changed.send(current_app._get_current_object(),",
            "                                      identity=auth_identity)",
            "",
            "                return auth",
            "            else:",
            "                # container identity",
            "",
            "                for rule in db.Role.get_by_name(DefaultRole.CONTAINER).rules:",
            "                    auth_identity.provides.add(",
            "                        RuleNeed(",
            "                            name=rule.name,",
            "                            scope=rule.scope,",
            "                            operation=rule.operation",
            "                        )",
            "                    )",
            "                identity_changed.send(current_app._get_current_object(),",
            "                                      identity=auth_identity)",
            "                log.debug(identity)",
            "                return identity",
            "",
            "    def load_resources(self) -> None:",
            "        \"\"\"Import the modules containing API resources.\"\"\"",
            "",
            "        # make services available to the endpoints, this way each endpoint can",
            "        # make use of 'em.",
            "        services = {",
            "            \"socketio\": self.socketio,",
            "            \"mail\": self.mail,",
            "            \"api\": self.api,",
            "            \"permissions\": self.permissions,",
            "            \"config\": self.ctx.config",
            "        }",
            "",
            "        for res in RESOURCES:",
            "            module = importlib.import_module('vantage6.server.resource.' + res)",
            "            module.setup(self.api, self.ctx.config['api_path'], services)",
            "",
            "    # TODO consider moving this method elsewhere. This is not trivial at the",
            "    # moment because of the circular import issue with `db`, see",
            "    # https://github.com/vantage6/vantage6/issues/53",
            "    @staticmethod",
            "    def _add_default_roles() -> None:",
            "        for role in get_default_roles(db):",
            "            if not db.Role.get_by_name(role['name']):",
            "                log.warn(f\"Creating new default role {role['name']}...\")",
            "                new_role = db.Role(",
            "                    name=role['name'],",
            "                    description=role['description'],",
            "                    rules=role['rules']",
            "                )",
            "                new_role.save()",
            "",
            "    def start(self) -> None:",
            "        \"\"\"",
            "        Start the server.",
            "",
            "        Before server is really started, some database settings are checked and",
            "        (re)set where appropriate.",
            "        \"\"\"",
            "        # add default roles (if they don't exist yet)",
            "        self._add_default_roles()",
            "",
            "        # create root user if it is not in the DB yet",
            "        try:",
            "            db.User.get_by_username(SUPER_USER_INFO['username'])",
            "        except Exception:",
            "            log.warn(\"No root user found! Is this the first run?\")",
            "",
            "            log.debug(\"Creating organization for root user\")",
            "            org = db.Organization(name=\"root\")",
            "",
            "            # TODO use constant instead of 'Root' literal",
            "            root = db.Role.get_by_name(\"Root\")",
            "",
            "            log.warn(f\"Creating root user: \"",
            "                     f\"username={SUPER_USER_INFO['username']}, \"",
            "                     f\"password={SUPER_USER_INFO['password']}\")",
            "",
            "            user = db.User(username=SUPER_USER_INFO['username'], roles=[root],",
            "                           organization=org, email=\"root@domain.ext\",",
            "                           password=SUPER_USER_INFO['password'],",
            "                           failed_login_attempts=0,",
            "                           last_login_attempt=None)",
            "            user.save()",
            "        return self",
            "",
            "    def __node_status_worker(self) -> None:",
            "        \"\"\"",
            "        Set node status to offline if they haven't send a ping message in a",
            "        while.",
            "        \"\"\"",
            "        # start periodic check if nodes are responsive",
            "        while True:",
            "            # Send ping event",
            "            try:",
            "                before_wait = dt.datetime.utcnow()",
            "",
            "                # Wait a while to give nodes opportunity to pong. This interval",
            "                # is a bit longer than the interval at which the nodes ping,",
            "                # because we want to make sure that the nodes have had time to",
            "                # respond.",
            "                time.sleep(PING_INTERVAL_SECONDS + 5)",
            "",
            "                # Check for each node that is online if they have responded.",
            "                # Otherwise set them to offline.",
            "                online_status_nodes = db.Node.get_online_nodes()",
            "                for node in online_status_nodes:",
            "                    if node.last_seen < before_wait:",
            "                        node.status = 'offline'",
            "                        node.save()",
            "            except Exception:",
            "                log.exception('Node-status thread had an exception')",
            "                time.sleep(PING_INTERVAL_SECONDS)",
            "",
            "",
            "def run_server(config: str, system_folders: bool = True) -> ServerApp:",
            "    \"\"\"",
            "    Run a vantage6 server.",
            "",
            "    Parameters",
            "    ----------",
            "    config: str",
            "        Configuration file path",
            "    system_folders: bool",
            "        Whether to use system or user folders. Default is True.",
            "",
            "    Returns",
            "    -------",
            "    ServerApp",
            "        A running instance of the vantage6 server",
            "    \"\"\"",
            "    ctx = ServerContext.from_external_config_file(",
            "        config,",
            "        system_folders",
            "    )",
            "    allow_drop_all = ctx.config[\"allow_drop_all\"]",
            "    Database().connect(uri=ctx.get_database_uri(),",
            "                       allow_drop_all=allow_drop_all)",
            "    return ServerApp(ctx).start()",
            "",
            "",
            "def run_dev_server(server_app: ServerApp, *args, **kwargs) -> None:",
            "    \"\"\"",
            "    Run a vantage6 development server (outside of a Docker container).",
            "",
            "    Parameters",
            "    ----------",
            "    server_app: ServerApp",
            "        Instance of a vantage6 server",
            "    \"\"\"",
            "    log.warn('*'*80)",
            "    log.warn(' DEVELOPMENT SERVER '.center(80, '*'))",
            "    log.warn('*'*80)",
            "    kwargs.setdefault('log_output', False)",
            "    server_app.socketio.run(server_app.app, *args, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": [],
            "23": []
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/default_roles.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         db.Rule.get_by_('collaboration', Scope.ORGANIZATION, Operation.VIEW),"
            },
            "1": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.VIEW),"
            },
            "2": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         db.Rule.get_by_('node', Scope.ORGANIZATION, Operation.VIEW),"
            },
            "3": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('task', Scope.ORGANIZATION, Operation.VIEW),"
            },
            "4": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('run', Scope.ORGANIZATION, Operation.VIEW),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        db.Rule.get_by_('task', Scope.COLLABORATION, Operation.VIEW),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        db.Rule.get_by_('run', Scope.COLLABORATION, Operation.VIEW),"
            },
            "7": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         db.Rule.get_by_('port', Scope.ORGANIZATION, Operation.VIEW),"
            },
            "8": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         db.Rule.get_by_('event', Scope.ORGANIZATION, Operation.RECEIVE),"
            },
            "9": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     ]"
            },
            "10": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     }"
            },
            "11": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     # 3. Researcher role"
            },
            "12": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     RESEARCHER_RULES = VIEWER_RULES + ["
            },
            "13": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('task', Scope.ORGANIZATION, Operation.CREATE),"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        db.Rule.get_by_('task', Scope.COLLABORATION, Operation.CREATE),"
            },
            "15": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         db.Rule.get_by_('task', Scope.ORGANIZATION, Operation.DELETE),"
            },
            "16": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     ]"
            },
            "17": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     RESEARCHER_ROLE = {"
            },
            "18": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     }"
            },
            "19": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     # 4. Collaboration administrator role"
            },
            "20": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "     COLLAB_ADMIN_RULES = ORG_ADMIN_RULES + ["
            },
            "21": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('user', Scope.GLOBAL, Operation.VIEW),"
            },
            "22": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('user', Scope.GLOBAL, Operation.CREATE),"
            },
            "23": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('user', Scope.GLOBAL, Operation.EDIT),"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        db.Rule.get_by_('user', Scope.COLLABORATION, Operation.VIEW),"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        db.Rule.get_by_('user', Scope.COLLABORATION, Operation.CREATE),"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        db.Rule.get_by_('user', Scope.COLLABORATION, Operation.EDIT),"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        # The following rule is given so that a collaboration admin can"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+        # view which organizations they may add to their collaboration"
            },
            "29": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         db.Rule.get_by_('organization', Scope.GLOBAL, Operation.VIEW),"
            },
            "30": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('organization', Scope.GLOBAL, Operation.EDIT),"
            },
            "31": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('collaboration', Scope.GLOBAL, Operation.VIEW),"
            },
            "32": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('collaboration', Scope.GLOBAL, Operation.EDIT),"
            },
            "33": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('role', Scope.GLOBAL, Operation.VIEW),"
            },
            "34": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('node', Scope.GLOBAL, Operation.CREATE),"
            },
            "35": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('node', Scope.GLOBAL, Operation.VIEW),"
            },
            "36": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        db.Rule.get_by_('node', Scope.GLOBAL, Operation.DELETE),"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        db.Rule.get_by_('organization', Scope.COLLABORATION, Operation.EDIT),"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        db.Rule.get_by_('collaboration', Scope.COLLABORATION, Operation.VIEW),"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        db.Rule.get_by_('collaboration', Scope.COLLABORATION, Operation.EDIT),"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        # The following rule is given so that a collaboration admin can"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        # create a new collaboration"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        db.Rule.get_by_('collaboration', Scope.GLOBAL, Operation.CREATE),"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        db.Rule.get_by_('role', Scope.COLLABORATION, Operation.VIEW),"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        db.Rule.get_by_('node', Scope.COLLABORATION, Operation.CREATE),"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        db.Rule.get_by_('node', Scope.COLLABORATION, Operation.VIEW),"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        db.Rule.get_by_('node', Scope.COLLABORATION, Operation.DELETE),"
            },
            "47": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         db.Rule.get_by_('event', Scope.COLLABORATION, Operation.RECEIVE),"
            },
            "48": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         db.Rule.get_by_('event', Scope.COLLABORATION, Operation.SEND),"
            },
            "49": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "     ]"
            }
        },
        "frontPatchFile": [
            "from enum import Enum",
            "",
            "from vantage6.server.model.rule import Operation, Scope",
            "",
            "",
            "class DefaultRole(str, Enum):",
            "    \"\"\" Enum containing the names of the default roles \"\"\"",
            "    ROOT = \"Root\"",
            "    CONTAINER = \"container\"",
            "    NODE = \"node\"",
            "    VIEWER = \"Viewer\"",
            "    RESEARCHER = \"Researcher\"",
            "    ORG_ADMIN = \"Organization Admin\"",
            "    COL_ADMIN = \"Collaboration Admin\"",
            "",
            "",
            "# TODO BvB 22-06-07: we now have to pass this 'db' module as argument to a",
            "# function because that module has a connection to the database. This should",
            "# not be necessary. Fix that after fixing the circular imports described in",
            "# https://github.com/vantage6/vantage6/issues/53",
            "def get_default_roles(db) -> list[dict]:",
            "    \"\"\"",
            "    Get a list containing the default roles and their rules, so that they may",
            "    be created in the database",
            "",
            "    Parameters",
            "    ----------",
            "    db",
            "        The vantage6.server.db module",
            "",
            "    Returns",
            "    -------",
            "    List[Dict]",
            "        A list with dictionaries that each describe one of the roles. Each role",
            "        dictionary contains the following:",
            "",
            "        name: str",
            "            Name of the role",
            "        description: str",
            "            Description of the role",
            "        rules: List[int]",
            "            A list of rule id's that the role contains",
            "    \"\"\"",
            "    # Define default roles",
            "    # 1. Root user",
            "    SUPER_ROLE = {",
            "        'name': DefaultRole.ROOT,",
            "        'description': \"Super role\",",
            "        'rules': db.Rule.get()",
            "    }",
            "    # 2. Role for viewing organization resources",
            "    VIEWER_RULES = [",
            "        db.Rule.get_by_('user', Scope.OWN, Operation.EDIT),",
            "        db.Rule.get_by_('user', Scope.OWN, Operation.DELETE),",
            "        db.Rule.get_by_('user', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('organization', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('organization', Scope.COLLABORATION, Operation.VIEW),",
            "        db.Rule.get_by_('collaboration', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('node', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('task', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('run', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('port', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('event', Scope.ORGANIZATION, Operation.RECEIVE),",
            "    ]",
            "    VIEWER_ROLE = {",
            "        'name': DefaultRole.VIEWER,",
            "        'description': \"Can manage their own account and view resources \"",
            "                       \"related to their organization\",",
            "        'rules': VIEWER_RULES",
            "    }",
            "    # 3. Researcher role",
            "    RESEARCHER_RULES = VIEWER_RULES + [",
            "        db.Rule.get_by_('task', Scope.ORGANIZATION, Operation.CREATE),",
            "        db.Rule.get_by_('task', Scope.ORGANIZATION, Operation.DELETE),",
            "    ]",
            "    RESEARCHER_ROLE = {",
            "        'name': DefaultRole.RESEARCHER,",
            "        'description': \"Can perform tasks, manage their own account, and \"",
            "                       \"view resources related to their organization\",",
            "        'rules': RESEARCHER_RULES",
            "    }",
            "    # 4. Organization administrator role",
            "    ORG_ADMIN_RULES = RESEARCHER_RULES + [",
            "        db.Rule.get_by_('user', Scope.ORGANIZATION, Operation.CREATE),",
            "        db.Rule.get_by_('user', Scope.ORGANIZATION, Operation.EDIT),",
            "        db.Rule.get_by_('user', Scope.ORGANIZATION, Operation.DELETE),",
            "        db.Rule.get_by_('organization', Scope.ORGANIZATION, Operation.EDIT),",
            "        db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.CREATE),",
            "        db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.EDIT),",
            "        db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.DELETE),",
            "        db.Rule.get_by_('node', Scope.ORGANIZATION, Operation.CREATE),",
            "        db.Rule.get_by_('node', Scope.ORGANIZATION, Operation.EDIT),",
            "        db.Rule.get_by_('event', Scope.ORGANIZATION, Operation.SEND),",
            "    ]",
            "    ORG_ADMIN_ROLE = {",
            "        'name': DefaultRole.ORG_ADMIN,",
            "        'description':",
            "            \"Can manage an organization including its users, roles, and nodes.\"",
            "            \" Also has all permissions of a researcher.\",",
            "        'rules': ORG_ADMIN_RULES",
            "    }",
            "    # 4. Collaboration administrator role",
            "    COLLAB_ADMIN_RULES = ORG_ADMIN_RULES + [",
            "        db.Rule.get_by_('user', Scope.GLOBAL, Operation.VIEW),",
            "        db.Rule.get_by_('user', Scope.GLOBAL, Operation.CREATE),",
            "        db.Rule.get_by_('user', Scope.GLOBAL, Operation.EDIT),",
            "        db.Rule.get_by_('organization', Scope.GLOBAL, Operation.VIEW),",
            "        db.Rule.get_by_('organization', Scope.GLOBAL, Operation.EDIT),",
            "        db.Rule.get_by_('collaboration', Scope.GLOBAL, Operation.VIEW),",
            "        db.Rule.get_by_('collaboration', Scope.GLOBAL, Operation.EDIT),",
            "        db.Rule.get_by_('role', Scope.GLOBAL, Operation.VIEW),",
            "        db.Rule.get_by_('node', Scope.GLOBAL, Operation.CREATE),",
            "        db.Rule.get_by_('node', Scope.GLOBAL, Operation.VIEW),",
            "        db.Rule.get_by_('node', Scope.GLOBAL, Operation.DELETE),",
            "        db.Rule.get_by_('event', Scope.COLLABORATION, Operation.RECEIVE),",
            "        db.Rule.get_by_('event', Scope.COLLABORATION, Operation.SEND),",
            "    ]",
            "    COLLAB_ADMIN_ROLE = {",
            "        'name': DefaultRole.COL_ADMIN,",
            "        'description':",
            "            \"Can manage an collaboration including its organization and users.\"",
            "            \" Also has permissions of an organization admin.\",",
            "        'rules': COLLAB_ADMIN_RULES",
            "    }",
            "    # Combine all in array",
            "    return [",
            "        SUPER_ROLE, VIEWER_ROLE, RESEARCHER_ROLE, ORG_ADMIN_ROLE,",
            "        COLLAB_ADMIN_ROLE",
            "    ]"
        ],
        "afterPatchFile": [
            "from enum import Enum",
            "",
            "from vantage6.server.model.rule import Operation, Scope",
            "",
            "",
            "class DefaultRole(str, Enum):",
            "    \"\"\" Enum containing the names of the default roles \"\"\"",
            "    ROOT = \"Root\"",
            "    CONTAINER = \"container\"",
            "    NODE = \"node\"",
            "    VIEWER = \"Viewer\"",
            "    RESEARCHER = \"Researcher\"",
            "    ORG_ADMIN = \"Organization Admin\"",
            "    COL_ADMIN = \"Collaboration Admin\"",
            "",
            "",
            "# TODO BvB 22-06-07: we now have to pass this 'db' module as argument to a",
            "# function because that module has a connection to the database. This should",
            "# not be necessary. Fix that after fixing the circular imports described in",
            "# https://github.com/vantage6/vantage6/issues/53",
            "def get_default_roles(db) -> list[dict]:",
            "    \"\"\"",
            "    Get a list containing the default roles and their rules, so that they may",
            "    be created in the database",
            "",
            "    Parameters",
            "    ----------",
            "    db",
            "        The vantage6.server.db module",
            "",
            "    Returns",
            "    -------",
            "    List[Dict]",
            "        A list with dictionaries that each describe one of the roles. Each role",
            "        dictionary contains the following:",
            "",
            "        name: str",
            "            Name of the role",
            "        description: str",
            "            Description of the role",
            "        rules: List[int]",
            "            A list of rule id's that the role contains",
            "    \"\"\"",
            "    # Define default roles",
            "    # 1. Root user",
            "    SUPER_ROLE = {",
            "        'name': DefaultRole.ROOT,",
            "        'description': \"Super role\",",
            "        'rules': db.Rule.get()",
            "    }",
            "    # 2. Role for viewing organization resources",
            "    VIEWER_RULES = [",
            "        db.Rule.get_by_('user', Scope.OWN, Operation.EDIT),",
            "        db.Rule.get_by_('user', Scope.OWN, Operation.DELETE),",
            "        db.Rule.get_by_('user', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('organization', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('organization', Scope.COLLABORATION, Operation.VIEW),",
            "        db.Rule.get_by_('collaboration', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('node', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('task', Scope.COLLABORATION, Operation.VIEW),",
            "        db.Rule.get_by_('run', Scope.COLLABORATION, Operation.VIEW),",
            "        db.Rule.get_by_('port', Scope.ORGANIZATION, Operation.VIEW),",
            "        db.Rule.get_by_('event', Scope.ORGANIZATION, Operation.RECEIVE),",
            "    ]",
            "    VIEWER_ROLE = {",
            "        'name': DefaultRole.VIEWER,",
            "        'description': \"Can manage their own account and view resources \"",
            "                       \"related to their organization\",",
            "        'rules': VIEWER_RULES",
            "    }",
            "    # 3. Researcher role",
            "    RESEARCHER_RULES = VIEWER_RULES + [",
            "        db.Rule.get_by_('task', Scope.COLLABORATION, Operation.CREATE),",
            "        db.Rule.get_by_('task', Scope.ORGANIZATION, Operation.DELETE),",
            "    ]",
            "    RESEARCHER_ROLE = {",
            "        'name': DefaultRole.RESEARCHER,",
            "        'description': \"Can perform tasks, manage their own account, and \"",
            "                       \"view resources related to their organization\",",
            "        'rules': RESEARCHER_RULES",
            "    }",
            "    # 4. Organization administrator role",
            "    ORG_ADMIN_RULES = RESEARCHER_RULES + [",
            "        db.Rule.get_by_('user', Scope.ORGANIZATION, Operation.CREATE),",
            "        db.Rule.get_by_('user', Scope.ORGANIZATION, Operation.EDIT),",
            "        db.Rule.get_by_('user', Scope.ORGANIZATION, Operation.DELETE),",
            "        db.Rule.get_by_('organization', Scope.ORGANIZATION, Operation.EDIT),",
            "        db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.CREATE),",
            "        db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.EDIT),",
            "        db.Rule.get_by_('role', Scope.ORGANIZATION, Operation.DELETE),",
            "        db.Rule.get_by_('node', Scope.ORGANIZATION, Operation.CREATE),",
            "        db.Rule.get_by_('node', Scope.ORGANIZATION, Operation.EDIT),",
            "        db.Rule.get_by_('event', Scope.ORGANIZATION, Operation.SEND),",
            "    ]",
            "    ORG_ADMIN_ROLE = {",
            "        'name': DefaultRole.ORG_ADMIN,",
            "        'description':",
            "            \"Can manage an organization including its users, roles, and nodes.\"",
            "            \" Also has all permissions of a researcher.\",",
            "        'rules': ORG_ADMIN_RULES",
            "    }",
            "    # 4. Collaboration administrator role",
            "    COLLAB_ADMIN_RULES = ORG_ADMIN_RULES + [",
            "        db.Rule.get_by_('user', Scope.COLLABORATION, Operation.VIEW),",
            "        db.Rule.get_by_('user', Scope.COLLABORATION, Operation.CREATE),",
            "        db.Rule.get_by_('user', Scope.COLLABORATION, Operation.EDIT),",
            "        # The following rule is given so that a collaboration admin can",
            "        # view which organizations they may add to their collaboration",
            "        db.Rule.get_by_('organization', Scope.GLOBAL, Operation.VIEW),",
            "        db.Rule.get_by_('organization', Scope.COLLABORATION, Operation.EDIT),",
            "        db.Rule.get_by_('collaboration', Scope.COLLABORATION, Operation.VIEW),",
            "        db.Rule.get_by_('collaboration', Scope.COLLABORATION, Operation.EDIT),",
            "        # The following rule is given so that a collaboration admin can",
            "        # create a new collaboration",
            "        db.Rule.get_by_('collaboration', Scope.GLOBAL, Operation.CREATE),",
            "        db.Rule.get_by_('role', Scope.COLLABORATION, Operation.VIEW),",
            "        db.Rule.get_by_('node', Scope.COLLABORATION, Operation.CREATE),",
            "        db.Rule.get_by_('node', Scope.COLLABORATION, Operation.VIEW),",
            "        db.Rule.get_by_('node', Scope.COLLABORATION, Operation.DELETE),",
            "        db.Rule.get_by_('event', Scope.COLLABORATION, Operation.RECEIVE),",
            "        db.Rule.get_by_('event', Scope.COLLABORATION, Operation.SEND),",
            "    ]",
            "    COLLAB_ADMIN_ROLE = {",
            "        'name': DefaultRole.COL_ADMIN,",
            "        'description':",
            "            \"Can manage an collaboration including its organization and users.\"",
            "            \" Also has permissions of an organization admin.\",",
            "        'rules': COLLAB_ADMIN_RULES",
            "    }",
            "    # Combine all in array",
            "    return [",
            "        SUPER_ROLE, VIEWER_ROLE, RESEARCHER_ROLE, ORG_ADMIN_ROLE,",
            "        COLLAB_ADMIN_ROLE",
            "    ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "61": [
                "get_default_roles"
            ],
            "62": [
                "get_default_roles"
            ],
            "74": [
                "get_default_roles"
            ],
            "105": [
                "get_default_roles"
            ],
            "106": [
                "get_default_roles"
            ],
            "107": [
                "get_default_roles"
            ],
            "109": [
                "get_default_roles"
            ],
            "110": [
                "get_default_roles"
            ],
            "111": [
                "get_default_roles"
            ],
            "112": [
                "get_default_roles"
            ],
            "113": [
                "get_default_roles"
            ],
            "114": [
                "get_default_roles"
            ],
            "115": [
                "get_default_roles"
            ]
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/model/rule.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from vantage6.server.model.base import Base, DatabaseSessionManager"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class Operation(Enumerate):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+class Operation(str, Enumerate):"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     \"\"\" Enumerator of all available operations \"\"\""
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     VIEW = \"v\""
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     EDIT = \"e\""
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     RECEIVE = \"r\""
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class Scope(Enumerate):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+class Scope(str, Enumerate):"
            },
            "13": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     \"\"\" Enumerator of all available scopes \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     OWN = \"own\""
            },
            "15": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     ORGANIZATION = \"org\""
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "from enum import Enum as Enumerate",
            "",
            "from sqlalchemy import Column, Text, String, Enum",
            "from sqlalchemy.orm import relationship",
            "from sqlalchemy.orm.exc import NoResultFound",
            "from vantage6.server.model.base import Base, DatabaseSessionManager",
            "",
            "",
            "class Operation(Enumerate):",
            "    \"\"\" Enumerator of all available operations \"\"\"",
            "    VIEW = \"v\"",
            "    EDIT = \"e\"",
            "    CREATE = \"c\"",
            "    DELETE = \"d\"",
            "    SEND = \"s\"",
            "    RECEIVE = \"r\"",
            "",
            "",
            "class Scope(Enumerate):",
            "    \"\"\" Enumerator of all available scopes \"\"\"",
            "    OWN = \"own\"",
            "    ORGANIZATION = \"org\"",
            "    COLLABORATION = \"col\"",
            "    GLOBAL = \"glo\"",
            "",
            "",
            "class Rule(Base):",
            "    \"\"\"Rules to determine permissions in an API endpoint.",
            "",
            "    A rule gives access to a single type of action with a given operation,",
            "    scope and resource on which it acts. Note that rules are defined on startup",
            "    of the server, based on permissions defined in the endpoints. You cannot",
            "    edit the rules in the database.",
            "",
            "    Attributes",
            "    ----------",
            "    name : str",
            "        Name of the rule",
            "    operation : Operation",
            "        Operation of the rule",
            "    scope : Scope",
            "        Scope of the rule",
            "    description : str",
            "        Description of the rule",
            "    roles : list[:class:`.~vantage6.server.model.role.Role`]",
            "        Roles that have this rule",
            "    users : list[:class:`.~vantage6.server.model.user.User`]",
            "        Users that have this rule",
            "    \"\"\"",
            "",
            "    # fields",
            "    name = Column(Text)",
            "    operation = Column(Enum(Operation))",
            "    scope = Column(Enum(Scope))",
            "    description = Column(String)",
            "",
            "    # relationships",
            "    roles = relationship(\"Role\", back_populates=\"rules\",",
            "                         secondary=\"role_rule_association\")",
            "    users = relationship(\"User\", back_populates=\"rules\",",
            "                         secondary=\"UserPermission\")",
            "",
            "    @classmethod",
            "    def get_by_(cls, name: str, scope: str, operation: str) -> Rule | None:",
            "        \"\"\"",
            "        Get a rule by its name, scope and operation.",
            "",
            "        Parameters",
            "        ----------",
            "        name : str",
            "            Name of the resource on which the rule acts, e.g. 'node'",
            "        scope : str",
            "            Scope of the rule, e.g. 'organization'",
            "        operation : str",
            "            Operation of the rule, e.g. 'view'",
            "",
            "        Returns",
            "        -------",
            "        Rule | None",
            "            Rule with the given name, scope and operation or None if no rule",
            "            with the given name, scope and operation exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        try:",
            "            result = session.query(cls).filter_by(",
            "                name=name,",
            "                operation=operation,",
            "                scope=scope",
            "            ).first()",
            "            session.commit()",
            "            return result",
            "        except NoResultFound:",
            "            return None",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        String representation of the rule.",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            String representation of the rule",
            "        \"\"\"",
            "        return (",
            "            f\"<Rule \"",
            "            f\"{self.id}: '{self.name}', \"",
            "            f\"operation: {self.operation}, \"",
            "            f\"scope: {self.scope}\"",
            "            \">\"",
            "        )"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "from enum import Enum as Enumerate",
            "",
            "from sqlalchemy import Column, Text, String, Enum",
            "from sqlalchemy.orm import relationship",
            "from sqlalchemy.orm.exc import NoResultFound",
            "from vantage6.server.model.base import Base, DatabaseSessionManager",
            "",
            "",
            "class Operation(str, Enumerate):",
            "    \"\"\" Enumerator of all available operations \"\"\"",
            "    VIEW = \"v\"",
            "    EDIT = \"e\"",
            "    CREATE = \"c\"",
            "    DELETE = \"d\"",
            "    SEND = \"s\"",
            "    RECEIVE = \"r\"",
            "",
            "",
            "class Scope(str, Enumerate):",
            "    \"\"\" Enumerator of all available scopes \"\"\"",
            "    OWN = \"own\"",
            "    ORGANIZATION = \"org\"",
            "    COLLABORATION = \"col\"",
            "    GLOBAL = \"glo\"",
            "",
            "",
            "class Rule(Base):",
            "    \"\"\"Rules to determine permissions in an API endpoint.",
            "",
            "    A rule gives access to a single type of action with a given operation,",
            "    scope and resource on which it acts. Note that rules are defined on startup",
            "    of the server, based on permissions defined in the endpoints. You cannot",
            "    edit the rules in the database.",
            "",
            "    Attributes",
            "    ----------",
            "    name : str",
            "        Name of the rule",
            "    operation : Operation",
            "        Operation of the rule",
            "    scope : Scope",
            "        Scope of the rule",
            "    description : str",
            "        Description of the rule",
            "    roles : list[:class:`.~vantage6.server.model.role.Role`]",
            "        Roles that have this rule",
            "    users : list[:class:`.~vantage6.server.model.user.User`]",
            "        Users that have this rule",
            "    \"\"\"",
            "",
            "    # fields",
            "    name = Column(Text)",
            "    operation = Column(Enum(Operation))",
            "    scope = Column(Enum(Scope))",
            "    description = Column(String)",
            "",
            "    # relationships",
            "    roles = relationship(\"Role\", back_populates=\"rules\",",
            "                         secondary=\"role_rule_association\")",
            "    users = relationship(\"User\", back_populates=\"rules\",",
            "                         secondary=\"UserPermission\")",
            "",
            "    @classmethod",
            "    def get_by_(cls, name: str, scope: str, operation: str) -> Rule | None:",
            "        \"\"\"",
            "        Get a rule by its name, scope and operation.",
            "",
            "        Parameters",
            "        ----------",
            "        name : str",
            "            Name of the resource on which the rule acts, e.g. 'node'",
            "        scope : str",
            "            Scope of the rule, e.g. 'organization'",
            "        operation : str",
            "            Operation of the rule, e.g. 'view'",
            "",
            "        Returns",
            "        -------",
            "        Rule | None",
            "            Rule with the given name, scope and operation or None if no rule",
            "            with the given name, scope and operation exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        try:",
            "            result = session.query(cls).filter_by(",
            "                name=name,",
            "                operation=operation,",
            "                scope=scope",
            "            ).first()",
            "            session.commit()",
            "            return result",
            "        except NoResultFound:",
            "            return None",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        String representation of the rule.",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            String representation of the rule",
            "        \"\"\"",
            "        return (",
            "            f\"<Rule \"",
            "            f\"{self.id}: '{self.name}', \"",
            "            f\"operation: {self.operation}, \"",
            "            f\"scope: {self.scope}\"",
            "            \">\"",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "10": [
                "Operation"
            ],
            "20": [
                "Scope"
            ]
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/model/task.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         Id of the parent task (if any)"
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     database : str"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         Name of the database that needs to be used for this task"
            },
            "3": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    initiator_id : int"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    init_org_id : int"
            },
            "5": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         Id of the organization that created this task"
            },
            "6": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     init_user_id : int"
            },
            "7": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         Id of the user that created this task"
            }
        },
        "frontPatchFile": [
            "from sqlalchemy import Column, String, ForeignKey, Integer, sql",
            "from sqlalchemy.orm import relationship",
            "from sqlalchemy.ext.hybrid import hybrid_property",
            "",
            "from vantage6.common.task_status import TaskStatus, has_task_failed",
            "from vantage6.server.model.base import Base, DatabaseSessionManager",
            "",
            "",
            "class Task(Base):",
            "    \"\"\"",
            "    Table that describes all tasks.",
            "",
            "    A Task can create algorithm Runs for multiple organizations. The input",
            "    of the task is different for each organization (due to the encryption).",
            "    Therefore the input for the task is encrypted for each organization",
            "    separately. The task originates from an organization to which the Runs",
            "    need to be encrypted, therefore the originating organization is also logged",
            "",
            "    Attributes",
            "    ----------",
            "    name : str",
            "        Name of the task",
            "    description : str",
            "        Description of the task",
            "    image : str",
            "        Name of the docker image that needs to be executed",
            "    collaboration_id : int",
            "        Id of the collaboration that this task belongs to",
            "    run_id : int",
            "        Run id of the task",
            "    parent_id : int",
            "        Id of the parent task (if any)",
            "    database : str",
            "        Name of the database that needs to be used for this task",
            "    initiator_id : int",
            "        Id of the organization that created this task",
            "    init_user_id : int",
            "        Id of the user that created this task",
            "",
            "    collaboration : :class:`~.model.collaboration.Collaboration`",
            "        Collaboration that this task belongs to",
            "    parent : :class:`~.model.task.Task`",
            "        Parent task (if any)",
            "    results : list[:class:`~.model.result.Result`]",
            "        List of results that are part of this task",
            "    initiator : :class:`~.model.organization.Organization`",
            "        Organization that created this task",
            "    init_user : :class:`~.model.user.User`",
            "        User that created this task",
            "",
            "    \"\"\"",
            "    # fields",
            "    name = Column(String)",
            "    description = Column(String)",
            "    image = Column(String)",
            "    collaboration_id = Column(Integer, ForeignKey(\"collaboration.id\"))",
            "    job_id = Column(Integer)",
            "    parent_id = Column(Integer, ForeignKey(\"task.id\"))",
            "    init_org_id = Column(Integer, ForeignKey(\"organization.id\"))",
            "    init_user_id = Column(Integer, ForeignKey(\"user.id\"))",
            "",
            "    # relationships",
            "    collaboration = relationship(\"Collaboration\", back_populates=\"tasks\")",
            "    parent = relationship(\"Task\", remote_side=\"Task.id\", backref=\"children\")",
            "    runs = relationship(\"Run\", back_populates=\"task\")",
            "    init_org = relationship(\"Organization\", back_populates=\"tasks\")",
            "    init_user = relationship(\"User\", back_populates=\"created_tasks\")",
            "    databases = relationship(\"TaskDatabase\", back_populates=\"task\")",
            "",
            "    @hybrid_property",
            "    def status(self) -> str:",
            "        \"\"\"",
            "        Returns the status of a task, which is derived from the statuses of",
            "        the underlying algorithm runs.",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            Status of task",
            "        \"\"\"",
            "        # TODO what if there are no result ids? -> currently returns unknown",
            "        run_statuses = [r.status for r in self.runs]",
            "        if any([has_task_failed(status) for status in run_statuses]):",
            "            return TaskStatus.FAILED.value",
            "        elif TaskStatus.ACTIVE in run_statuses:",
            "            return TaskStatus.ACTIVE.value",
            "        elif TaskStatus.INITIALIZING in run_statuses:",
            "            return TaskStatus.INITIALIZING.value",
            "        elif TaskStatus.PENDING in run_statuses:",
            "            return TaskStatus.PENDING.value",
            "        else:",
            "            return TaskStatus.COMPLETED.value",
            "",
            "    @classmethod",
            "    def next_job_id(cls) -> int:",
            "        \"\"\"",
            "        Get the next available run id for a new task.",
            "",
            "        Returns",
            "        -------",
            "        int",
            "            Next available run id",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        max_job_id = session.query(sql.func.max(cls.job_id)).scalar()",
            "        session.commit()",
            "        if max_job_id:",
            "            return max_job_id + 1",
            "        else:",
            "            return 1",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        String representation of the Task object",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            String representation of the Task object",
            "        \"\"\"",
            "        return (",
            "            f\"<Task \"",
            "            f\"{self.id}: '{self.name}', \"",
            "            f\"collaboration:{self.collaboration.name}\"",
            "            \">\"",
            "        )"
        ],
        "afterPatchFile": [
            "from sqlalchemy import Column, String, ForeignKey, Integer, sql",
            "from sqlalchemy.orm import relationship",
            "from sqlalchemy.ext.hybrid import hybrid_property",
            "",
            "from vantage6.common.task_status import TaskStatus, has_task_failed",
            "from vantage6.server.model.base import Base, DatabaseSessionManager",
            "",
            "",
            "class Task(Base):",
            "    \"\"\"",
            "    Table that describes all tasks.",
            "",
            "    A Task can create algorithm Runs for multiple organizations. The input",
            "    of the task is different for each organization (due to the encryption).",
            "    Therefore the input for the task is encrypted for each organization",
            "    separately. The task originates from an organization to which the Runs",
            "    need to be encrypted, therefore the originating organization is also logged",
            "",
            "    Attributes",
            "    ----------",
            "    name : str",
            "        Name of the task",
            "    description : str",
            "        Description of the task",
            "    image : str",
            "        Name of the docker image that needs to be executed",
            "    collaboration_id : int",
            "        Id of the collaboration that this task belongs to",
            "    run_id : int",
            "        Run id of the task",
            "    parent_id : int",
            "        Id of the parent task (if any)",
            "    database : str",
            "        Name of the database that needs to be used for this task",
            "    init_org_id : int",
            "        Id of the organization that created this task",
            "    init_user_id : int",
            "        Id of the user that created this task",
            "",
            "    collaboration : :class:`~.model.collaboration.Collaboration`",
            "        Collaboration that this task belongs to",
            "    parent : :class:`~.model.task.Task`",
            "        Parent task (if any)",
            "    results : list[:class:`~.model.result.Result`]",
            "        List of results that are part of this task",
            "    initiator : :class:`~.model.organization.Organization`",
            "        Organization that created this task",
            "    init_user : :class:`~.model.user.User`",
            "        User that created this task",
            "",
            "    \"\"\"",
            "    # fields",
            "    name = Column(String)",
            "    description = Column(String)",
            "    image = Column(String)",
            "    collaboration_id = Column(Integer, ForeignKey(\"collaboration.id\"))",
            "    job_id = Column(Integer)",
            "    parent_id = Column(Integer, ForeignKey(\"task.id\"))",
            "    init_org_id = Column(Integer, ForeignKey(\"organization.id\"))",
            "    init_user_id = Column(Integer, ForeignKey(\"user.id\"))",
            "",
            "    # relationships",
            "    collaboration = relationship(\"Collaboration\", back_populates=\"tasks\")",
            "    parent = relationship(\"Task\", remote_side=\"Task.id\", backref=\"children\")",
            "    runs = relationship(\"Run\", back_populates=\"task\")",
            "    init_org = relationship(\"Organization\", back_populates=\"tasks\")",
            "    init_user = relationship(\"User\", back_populates=\"created_tasks\")",
            "    databases = relationship(\"TaskDatabase\", back_populates=\"task\")",
            "",
            "    @hybrid_property",
            "    def status(self) -> str:",
            "        \"\"\"",
            "        Returns the status of a task, which is derived from the statuses of",
            "        the underlying algorithm runs.",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            Status of task",
            "        \"\"\"",
            "        # TODO what if there are no result ids? -> currently returns unknown",
            "        run_statuses = [r.status for r in self.runs]",
            "        if any([has_task_failed(status) for status in run_statuses]):",
            "            return TaskStatus.FAILED.value",
            "        elif TaskStatus.ACTIVE in run_statuses:",
            "            return TaskStatus.ACTIVE.value",
            "        elif TaskStatus.INITIALIZING in run_statuses:",
            "            return TaskStatus.INITIALIZING.value",
            "        elif TaskStatus.PENDING in run_statuses:",
            "            return TaskStatus.PENDING.value",
            "        else:",
            "            return TaskStatus.COMPLETED.value",
            "",
            "    @classmethod",
            "    def next_job_id(cls) -> int:",
            "        \"\"\"",
            "        Get the next available run id for a new task.",
            "",
            "        Returns",
            "        -------",
            "        int",
            "            Next available run id",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        max_job_id = session.query(sql.func.max(cls.job_id)).scalar()",
            "        session.commit()",
            "        if max_job_id:",
            "            return max_job_id + 1",
            "        else:",
            "            return 1",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        String representation of the Task object",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            String representation of the Task object",
            "        \"\"\"",
            "        return (",
            "            f\"<Task \"",
            "            f\"{self.id}: '{self.name}', \"",
            "            f\"collaboration:{self.collaboration.name}\"",
            "            \">\"",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "35": [
                "Task"
            ]
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/permission.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from vantage6.server.globals import RESOURCES"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from vantage6.server.default_roles import DefaultRole"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from vantage6.server.model.base import Base"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from vantage6.server.model.role import Role"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from vantage6.server.model.rule import Rule, Operation, Scope"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from vantage6.server.model.base import DatabaseSessionManager"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+from vantage6.server.utils import ("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    obtain_auth_collaborations, obtain_auth_organization"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+)"
            },
            "10": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from vantage6.common import logger_name"
            },
            "11": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " module_name = logger_name(__name__)"
            },
            "13": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " RuleNeed = namedtuple(\"RuleNeed\", [\"name\", \"scope\", \"operation\"])"
            },
            "14": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class RuleCollection:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+class RuleCollection(dict):"
            },
            "18": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     \"\"\""
            },
            "19": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     Class that tracks a set of all rules for a certain resource name"
            },
            "20": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "             What operation the rule applies to"
            },
            "22": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         permission = Permission(RuleNeed(self.name, scope, operation))"
            },
            "24": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.__setattr__(f'{operation.value}_{scope.value}', permission)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        self.__setattr__(f'{operation}_{scope}', permission)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    def can_for_org(self, operation: Operation, subject_org_id: int) -> bool:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        \"\"\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        Check if an operation is allowed on a certain organization"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        Parameters"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        ----------"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        operation: Operation"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+            Operation to check if allowed"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        subject_org_id: int"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            Organization id on which the operation should be allowed"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        Returns"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        -------"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        bool"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            True if the operation is allowed on the organization, False"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            otherwise"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        \"\"\""
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        auth_org = obtain_auth_organization()"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        # check if the entity has global permission"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        global_perm = getattr(self, f'{operation}_{Scope.GLOBAL}')"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        if global_perm and global_perm.can():"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            return True"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        # check if the entity has organization permission and organization is"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        # the same as the subject organization"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        org_perm = getattr(self, f'{operation}_{Scope.ORGANIZATION}')"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        if auth_org.id == subject_org_id and org_perm and org_perm.can():"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+            return True"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        # check if the entity has collaboration permission and the subject"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        # organization is in the collaboration of the own organization"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        col_perm = getattr(self, f'{operation}_{Scope.COLLABORATION}')"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        if col_perm and col_perm.can():"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            for col in auth_org.collaborations:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+                if subject_org_id in [org.id for org in col.organizations]:"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                    return True"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        # no permission found"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        return False"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+    def can_for_col(self, operation: Operation, collaboration_id: int) -> bool:"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        \"\"\""
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        Check if the user or node can perform the operation on a certain"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        collaboration"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        Parameters"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        ----------"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        operation: Operation"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+            Operation to check if allowed"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        collaboration_id: int"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            Collaboration id on which the operation should be allowed"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        \"\"\""
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        auth_collabs = obtain_auth_collaborations()"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        # check if the entity has global permission"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        global_perm = getattr(self, f'{operation}_{Scope.GLOBAL}')"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        if global_perm and global_perm.can():"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            return True"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        # check if the entity has collaboration permission and the subject"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        # collaboration is in the collaborations of the user/node"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        col_perm = getattr(self, f'{operation}_{Scope.COLLABORATION}')"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        if col_perm and col_perm.can() and \\"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+                self._id_in_list(collaboration_id, auth_collabs):"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+            return True"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        # no permission found"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        return False"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    def get_max_scope(self, operation: Operation) -> Scope | None:"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        \"\"\""
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        Get the highest scope that the entity has for a certain operation"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        Parameters"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        ----------"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        operation: Operation"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+            Operation to check"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        Returns"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        -------"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        Scope | None"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+            Highest scope that the entity has for the operation. None if the"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+            entity has no permission for the operation"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        \"\"\""
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        if getattr(self, f'{operation}_{Scope.GLOBAL}'):"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            return Scope.GLOBAL"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        elif getattr(self, f'{operation}_{Scope.COLLABORATION}'):"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            return Scope.COLLABORATION"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        elif getattr(self, f'{operation}_{Scope.ORGANIZATION}'):"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+            return Scope.ORGANIZATION"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        elif getattr(self, f'{operation}_{Scope.OWN}'):"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            return Scope.OWN"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        else:"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            return None"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+    def has_at_least_scope(self, scope: Scope, operation: Operation) -> bool:"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        \"\"\""
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        Check if the entity has at least a certain scope for a certain"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        operation"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        Parameters"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        ----------"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        scope: Scope"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            Scope to check if the entity has at least"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        operation: Operation"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+            Operation to check"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        Returns"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        -------"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        bool"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            True if the entity has at least the scope, False otherwise"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        \"\"\""
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        scopes: list[Scope] = self._get_scopes_from(scope)"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        for s in scopes:"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            perm = getattr(self, f'{operation}_{s}')"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            if perm and perm.can():"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+                return True"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        return False"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+    def _id_in_list(self, id_: int, resource_list: list[Base]) -> bool:"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        \"\"\""
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        Check if resource list contains a resource with a certain ID"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        Parameters"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        ----------"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        id_ : int"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            ID of the resource"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        resource_list : list[db.Base]"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            List of resources"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+        Returns"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        -------"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        bool"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+            True if resource is in list, False otherwise"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        \"\"\""
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        return any(r.id == id_ for r in resource_list)"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+    def _get_scopes_from(self, minimal_scope: Scope) -> list[Scope]:"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        \"\"\""
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        Get scopes that are at least equal to a certain scope"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        Parameters"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        ----------"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        minimal_scope: Scope"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            Minimal scope"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+        Returns"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        -------"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        list[Scope]"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            List of scopes that are at least equal to the minimal scope"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+        Raises"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+        ------"
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+        ValueError"
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+            If the minimal scope is not known"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+        \"\"\""
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        if minimal_scope == Scope.ORGANIZATION:"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+            return [Scope.ORGANIZATION, Scope.COLLABORATION, Scope.GLOBAL]"
            },
            "186": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        elif minimal_scope == Scope.COLLABORATION:"
            },
            "187": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+            return [Scope.COLLABORATION, Scope.GLOBAL]"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+        elif minimal_scope == Scope.GLOBAL:"
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+            return [Scope.GLOBAL]"
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        elif minimal_scope == Scope.OWN:"
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            return [Scope.OWN, Scope.ORGANIZATION, Scope.COLLABORATION,"
            },
            "192": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+                    Scope.GLOBAL]"
            },
            "193": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        else:"
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+            raise ValueError(f\"Unknown scope '{minimal_scope}'\")"
            },
            "195": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 219,
                "PatchRowcode": " "
            },
            "196": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "197": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 221,
                "PatchRowcode": " class PermissionManager:"
            }
        },
        "frontPatchFile": [
            "import logging",
            "import importlib",
            "",
            "from collections import namedtuple",
            "from flask_principal import Permission, PermissionDenied",
            "",
            "from vantage6.server.globals import RESOURCES",
            "from vantage6.server.default_roles import DefaultRole",
            "from vantage6.server.model.role import Role",
            "from vantage6.server.model.rule import Rule, Operation, Scope",
            "from vantage6.server.model.base import DatabaseSessionManager",
            "from vantage6.common import logger_name",
            "",
            "module_name = logger_name(__name__)",
            "log = logging.getLogger(module_name)",
            "",
            "RuleNeed = namedtuple(\"RuleNeed\", [\"name\", \"scope\", \"operation\"])",
            "",
            "",
            "class RuleCollection:",
            "    \"\"\"",
            "    Class that tracks a set of all rules for a certain resource name",
            "",
            "    Parameters",
            "    ----------",
            "    name: str",
            "        Name of the resource endpoint (e.g. node, organization, user)",
            "    \"\"\"",
            "",
            "    def __init__(self, name: str) -> None:",
            "        self.name = name",
            "",
            "    def add(self, scope: Scope, operation: Operation) -> None:",
            "        \"\"\"",
            "        Add a rule to the rule collection",
            "",
            "        Parameters",
            "        ----------",
            "        scope: Scope",
            "            Scope within which to apply the rule",
            "        operation: Operation",
            "            What operation the rule applies to",
            "        \"\"\"",
            "        permission = Permission(RuleNeed(self.name, scope, operation))",
            "        self.__setattr__(f'{operation.value}_{scope.value}', permission)",
            "",
            "",
            "class PermissionManager:",
            "    \"\"\"",
            "    Loads the permissions and syncs rules in database with rules defined in",
            "    the code",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        self.collections = {}",
            "        log.info(\"Loading permission system...\")",
            "        self.load_rules_from_resources()",
            "",
            "    def load_rules_from_resources(self) -> None:",
            "        \"\"\"",
            "        Collect all permission rules from all registered API resources",
            "        \"\"\"",
            "        for res in RESOURCES:",
            "            module = importlib.import_module('vantage6.server.resource.' + res)",
            "            try:",
            "                module.permissions(self)",
            "            except Exception:",
            "                module_name = module.__name__.split(\".\")[-1]",
            "                log.debug(f\"Resource '{module_name}' contains no or invalid \"",
            "                          \"permissions\")",
            "",
            "    def assign_rule_to_root(self, name: str, scope: Scope,",
            "                            operation: Operation) -> None:",
            "        \"\"\"",
            "        Assign a rule to the root role.",
            "",
            "        resource: str",
            "            Resource that the rule applies to",
            "        scope: Scope",
            "            Scope that the rule applies to",
            "        operation: Operation",
            "            Operation that the rule applies to",
            "        \"\"\"",
            "        self.assign_rule_to_fixed_role(DefaultRole.ROOT, name, scope,",
            "                                       operation)",
            "",
            "    def assign_rule_to_node(self, resource: str, scope: Scope,",
            "                            operation: Operation) -> None:",
            "        \"\"\"",
            "        Assign a rule to the Node role.",
            "",
            "        Parameters",
            "        ----------",
            "        resource: str",
            "            Resource that the rule applies to",
            "        scope: Scope",
            "            Scope that the rule applies to",
            "        operation: Operation",
            "            Operation that the rule applies to",
            "        \"\"\"",
            "        self.assign_rule_to_fixed_role(DefaultRole.NODE, resource, scope,",
            "                                       operation)",
            "",
            "    def assign_rule_to_container(self, resource: str, scope: Scope,",
            "                                 operation: Operation) -> None:",
            "        \"\"\"",
            "        Assign a rule to the container role.",
            "",
            "        Parameters",
            "        ----------",
            "        resource: str",
            "            Resource that the rule applies to",
            "        scope: Scope",
            "            Scope that the rule applies to",
            "        operation: Operation",
            "            Operation that the rule applies to",
            "        \"\"\"",
            "        self.assign_rule_to_fixed_role(DefaultRole.CONTAINER, resource, scope,",
            "                                       operation)",
            "",
            "    @staticmethod",
            "    def assign_rule_to_fixed_role(fixedrole: str, resource: str, scope: Scope,",
            "                                  operation: Operation) -> None:",
            "        \"\"\"",
            "        Attach a rule to a fixed role (not adjustable by users).",
            "",
            "        Parameters",
            "        ----------",
            "        fixedrole: str",
            "            Name of the fixed role that the rule should be added to",
            "        resource: str",
            "            Resource that the rule applies to",
            "        scope: Scope",
            "            Scope that the rule applies to",
            "        operation: Operation",
            "            Operation that the rule applies to",
            "        \"\"\"",
            "        role = Role.get_by_name(fixedrole)",
            "        if not role:",
            "            log.warning(f\"{fixedrole} role not found, creating it now!\")",
            "            role = Role(name=fixedrole, description=f\"{fixedrole} role\")",
            "",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        if not rule:",
            "            log.error(f\"Rule ({resource},{scope},{operation}) not found!\")",
            "",
            "        if rule not in role.rules:",
            "            role.rules.append(rule)",
            "            log.info(f\"Rule ({resource},{scope},{operation}) added to \"",
            "                     f\"{fixedrole} role!\")",
            "",
            "    def register_rule(self, resource: str, scope: Scope,",
            "                      operation: Operation, description=None,",
            "                      assign_to_node=False, assign_to_container=False) -> None:",
            "        \"\"\"",
            "        Register a permission rule in the database.",
            "",
            "        If a rule already exists, nothing is done. This rule can be used in API",
            "        endpoints to determine if a user, node or container can do a certain",
            "        operation in a certain scope.",
            "",
            "        Parameters",
            "        ----------",
            "        resource : str",
            "            API resource that the rule applies to",
            "        scope : Scope",
            "            Scope of the rule",
            "        operation : Operation",
            "            Operation of the rule",
            "        description : String, optional",
            "            Human readable description where the rule is used for, by default",
            "            None",
            "        assign_to_node: bool, optional",
            "            Whether rule should be assigned to the node role or not. Default",
            "            False",
            "        assign_to_container: bool, optional",
            "            Whether rule should be assigned to the container role or not.",
            "            Default False",
            "        \"\"\"",
            "        # verify that the rule is in the DB, so that these can be assigned to",
            "        # roles and users",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        if not rule:",
            "            rule = Rule(name=resource, operation=operation, scope=scope,",
            "                        description=description)",
            "            rule.save()",
            "            log.debug(f\"New auth rule '{resource}' with scope={scope}\"",
            "                      f\" and operation={operation} is stored in the DB\")",
            "",
            "        if assign_to_container:",
            "            self.assign_rule_to_container(resource, scope, operation)",
            "",
            "        if assign_to_node:",
            "            self.assign_rule_to_node(resource, scope, operation)",
            "",
            "        # assign all new rules to root user",
            "        self.assign_rule_to_root(resource, scope, operation)",
            "",
            "        self.collection(resource).add(rule.scope, rule.operation)",
            "",
            "    def appender(self, name: str) -> callable:",
            "        \"\"\"",
            "        Add a module's rules to the rule collection",
            "",
            "        Parameters",
            "        ----------",
            "        name: str",
            "            The name of the module whose rules are to be registered",
            "",
            "        Returns",
            "        -------",
            "        Callable",
            "            A callable ``register_rule`` function",
            "        \"\"\"",
            "        # make sure collection exists",
            "        self.collection(name)",
            "        return lambda *args, **kwargs: self.register_rule(name, *args,",
            "                                                          **kwargs)",
            "",
            "    def collection(self, name: str) -> RuleCollection:",
            "        \"\"\"",
            "        Get a RuleCollection object. If it doesn't exist yet, it will be",
            "        created.",
            "",
            "        Parameters",
            "        ----------",
            "        name: str",
            "            Name of the module whose RuleCollection is to be obtained or",
            "            created",
            "",
            "        Returns",
            "        -------",
            "        RuleCollection",
            "            The collection of rules belonging to the module name",
            "        \"\"\"",
            "        if self._collection_exists(name):",
            "            return self.collections[name]",
            "        else:",
            "            self.collections[name] = RuleCollection(name)",
            "            return self.collections[name]",
            "",
            "    def _collection_exists(self, name: str) -> bool:",
            "        \"\"\"",
            "        Check if a module's rule collection is defined",
            "",
            "        Parameters",
            "        ----------",
            "        name: str",
            "            Name of the module to be checked",
            "",
            "        Returns",
            "        -------",
            "        bool:",
            "            True if RuleCollection is defined for module, else False",
            "        \"\"\"",
            "        return name in self.collections",
            "",
            "    def __getattr__(self, name: str) -> RuleCollection:",
            "        # TODO BvB 2023-01-18 I think this function might not be used. It would",
            "        # be triggered when we do something like",
            "        # `permissionManager.resource_name` but we don't ever do that (?!)",
            "        try:",
            "            collection = self.collections[name]",
            "            return collection",
            "        except Exception as e:",
            "            log.critical(f\"Missing permission collection! {name}\")",
            "            raise e",
            "",
            "    @staticmethod",
            "    def rule_exists_in_db(name: str, scope: Scope,",
            "                          operation: Operation) -> bool:",
            "        \"\"\"Check if the rule exists in the DB.",
            "",
            "        Parameters",
            "        ----------",
            "        name: str",
            "            Name of the rule",
            "        scope: Scope",
            "            Scope of the rule",
            "        operation: Operation",
            "            Operation of the rule",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whenever this rule exists in the database or not",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(Rule).filter_by(",
            "            name=name,",
            "            operation=operation,",
            "            scope=scope",
            "        ).scalar()",
            "        session.commit()",
            "        return result",
            "",
            "    @staticmethod",
            "    def check_user_rules(rules: list[Rule]) -> dict | bool:",
            "        \"\"\"",
            "        Check if a user, node or container has all the `rules` in a list",
            "",
            "        Parameters",
            "        ----------",
            "        rules: list[:class:`~vantage6.server.model.rule.Rule`]",
            "            List of rules that user is checked to have",
            "",
            "        Returns",
            "        -------",
            "        dict | bool",
            "            Dict with a message which rule is missing, else None",
            "        \"\"\"",
            "        for rule in rules:",
            "            requires = RuleNeed(rule.name, rule.scope, rule.operation)",
            "            try:",
            "                Permission(requires).test()",
            "            except PermissionDenied:",
            "                return {\"msg\": f\"You don't have the rule ({rule.name}, \"",
            "                        f\"{rule.scope}, {rule.operation})\"}",
            "        return None"
        ],
        "afterPatchFile": [
            "import logging",
            "import importlib",
            "",
            "from collections import namedtuple",
            "from flask_principal import Permission, PermissionDenied",
            "",
            "from vantage6.server.globals import RESOURCES",
            "from vantage6.server.default_roles import DefaultRole",
            "from vantage6.server.model.base import Base",
            "from vantage6.server.model.role import Role",
            "from vantage6.server.model.rule import Rule, Operation, Scope",
            "from vantage6.server.model.base import DatabaseSessionManager",
            "from vantage6.server.utils import (",
            "    obtain_auth_collaborations, obtain_auth_organization",
            ")",
            "from vantage6.common import logger_name",
            "",
            "module_name = logger_name(__name__)",
            "log = logging.getLogger(module_name)",
            "",
            "RuleNeed = namedtuple(\"RuleNeed\", [\"name\", \"scope\", \"operation\"])",
            "",
            "",
            "class RuleCollection(dict):",
            "    \"\"\"",
            "    Class that tracks a set of all rules for a certain resource name",
            "",
            "    Parameters",
            "    ----------",
            "    name: str",
            "        Name of the resource endpoint (e.g. node, organization, user)",
            "    \"\"\"",
            "",
            "    def __init__(self, name: str) -> None:",
            "        self.name = name",
            "",
            "    def add(self, scope: Scope, operation: Operation) -> None:",
            "        \"\"\"",
            "        Add a rule to the rule collection",
            "",
            "        Parameters",
            "        ----------",
            "        scope: Scope",
            "            Scope within which to apply the rule",
            "        operation: Operation",
            "            What operation the rule applies to",
            "        \"\"\"",
            "        permission = Permission(RuleNeed(self.name, scope, operation))",
            "        self.__setattr__(f'{operation}_{scope}', permission)",
            "",
            "    def can_for_org(self, operation: Operation, subject_org_id: int) -> bool:",
            "        \"\"\"",
            "        Check if an operation is allowed on a certain organization",
            "",
            "        Parameters",
            "        ----------",
            "        operation: Operation",
            "            Operation to check if allowed",
            "        subject_org_id: int",
            "            Organization id on which the operation should be allowed",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            True if the operation is allowed on the organization, False",
            "            otherwise",
            "        \"\"\"",
            "        auth_org = obtain_auth_organization()",
            "",
            "        # check if the entity has global permission",
            "        global_perm = getattr(self, f'{operation}_{Scope.GLOBAL}')",
            "        if global_perm and global_perm.can():",
            "            return True",
            "",
            "        # check if the entity has organization permission and organization is",
            "        # the same as the subject organization",
            "        org_perm = getattr(self, f'{operation}_{Scope.ORGANIZATION}')",
            "        if auth_org.id == subject_org_id and org_perm and org_perm.can():",
            "            return True",
            "",
            "        # check if the entity has collaboration permission and the subject",
            "        # organization is in the collaboration of the own organization",
            "        col_perm = getattr(self, f'{operation}_{Scope.COLLABORATION}')",
            "        if col_perm and col_perm.can():",
            "            for col in auth_org.collaborations:",
            "                if subject_org_id in [org.id for org in col.organizations]:",
            "                    return True",
            "",
            "        # no permission found",
            "        return False",
            "",
            "    def can_for_col(self, operation: Operation, collaboration_id: int) -> bool:",
            "        \"\"\"",
            "        Check if the user or node can perform the operation on a certain",
            "        collaboration",
            "",
            "        Parameters",
            "        ----------",
            "        operation: Operation",
            "            Operation to check if allowed",
            "        collaboration_id: int",
            "            Collaboration id on which the operation should be allowed",
            "        \"\"\"",
            "        auth_collabs = obtain_auth_collaborations()",
            "",
            "        # check if the entity has global permission",
            "        global_perm = getattr(self, f'{operation}_{Scope.GLOBAL}')",
            "        if global_perm and global_perm.can():",
            "            return True",
            "",
            "        # check if the entity has collaboration permission and the subject",
            "        # collaboration is in the collaborations of the user/node",
            "        col_perm = getattr(self, f'{operation}_{Scope.COLLABORATION}')",
            "        if col_perm and col_perm.can() and \\",
            "                self._id_in_list(collaboration_id, auth_collabs):",
            "            return True",
            "",
            "        # no permission found",
            "        return False",
            "",
            "    def get_max_scope(self, operation: Operation) -> Scope | None:",
            "        \"\"\"",
            "        Get the highest scope that the entity has for a certain operation",
            "",
            "        Parameters",
            "        ----------",
            "        operation: Operation",
            "            Operation to check",
            "",
            "        Returns",
            "        -------",
            "        Scope | None",
            "            Highest scope that the entity has for the operation. None if the",
            "            entity has no permission for the operation",
            "        \"\"\"",
            "        if getattr(self, f'{operation}_{Scope.GLOBAL}'):",
            "            return Scope.GLOBAL",
            "        elif getattr(self, f'{operation}_{Scope.COLLABORATION}'):",
            "            return Scope.COLLABORATION",
            "        elif getattr(self, f'{operation}_{Scope.ORGANIZATION}'):",
            "            return Scope.ORGANIZATION",
            "        elif getattr(self, f'{operation}_{Scope.OWN}'):",
            "            return Scope.OWN",
            "        else:",
            "            return None",
            "",
            "    def has_at_least_scope(self, scope: Scope, operation: Operation) -> bool:",
            "        \"\"\"",
            "        Check if the entity has at least a certain scope for a certain",
            "        operation",
            "",
            "        Parameters",
            "        ----------",
            "        scope: Scope",
            "            Scope to check if the entity has at least",
            "        operation: Operation",
            "            Operation to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            True if the entity has at least the scope, False otherwise",
            "        \"\"\"",
            "        scopes: list[Scope] = self._get_scopes_from(scope)",
            "        for s in scopes:",
            "            perm = getattr(self, f'{operation}_{s}')",
            "            if perm and perm.can():",
            "                return True",
            "        return False",
            "",
            "    def _id_in_list(self, id_: int, resource_list: list[Base]) -> bool:",
            "        \"\"\"",
            "        Check if resource list contains a resource with a certain ID",
            "",
            "        Parameters",
            "        ----------",
            "        id_ : int",
            "            ID of the resource",
            "        resource_list : list[db.Base]",
            "            List of resources",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            True if resource is in list, False otherwise",
            "        \"\"\"",
            "        return any(r.id == id_ for r in resource_list)",
            "",
            "    def _get_scopes_from(self, minimal_scope: Scope) -> list[Scope]:",
            "        \"\"\"",
            "        Get scopes that are at least equal to a certain scope",
            "",
            "        Parameters",
            "        ----------",
            "        minimal_scope: Scope",
            "            Minimal scope",
            "",
            "        Returns",
            "        -------",
            "        list[Scope]",
            "            List of scopes that are at least equal to the minimal scope",
            "",
            "        Raises",
            "        ------",
            "        ValueError",
            "            If the minimal scope is not known",
            "        \"\"\"",
            "        if minimal_scope == Scope.ORGANIZATION:",
            "            return [Scope.ORGANIZATION, Scope.COLLABORATION, Scope.GLOBAL]",
            "        elif minimal_scope == Scope.COLLABORATION:",
            "            return [Scope.COLLABORATION, Scope.GLOBAL]",
            "        elif minimal_scope == Scope.GLOBAL:",
            "            return [Scope.GLOBAL]",
            "        elif minimal_scope == Scope.OWN:",
            "            return [Scope.OWN, Scope.ORGANIZATION, Scope.COLLABORATION,",
            "                    Scope.GLOBAL]",
            "        else:",
            "            raise ValueError(f\"Unknown scope '{minimal_scope}'\")",
            "",
            "",
            "class PermissionManager:",
            "    \"\"\"",
            "    Loads the permissions and syncs rules in database with rules defined in",
            "    the code",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        self.collections = {}",
            "        log.info(\"Loading permission system...\")",
            "        self.load_rules_from_resources()",
            "",
            "    def load_rules_from_resources(self) -> None:",
            "        \"\"\"",
            "        Collect all permission rules from all registered API resources",
            "        \"\"\"",
            "        for res in RESOURCES:",
            "            module = importlib.import_module('vantage6.server.resource.' + res)",
            "            try:",
            "                module.permissions(self)",
            "            except Exception:",
            "                module_name = module.__name__.split(\".\")[-1]",
            "                log.debug(f\"Resource '{module_name}' contains no or invalid \"",
            "                          \"permissions\")",
            "",
            "    def assign_rule_to_root(self, name: str, scope: Scope,",
            "                            operation: Operation) -> None:",
            "        \"\"\"",
            "        Assign a rule to the root role.",
            "",
            "        resource: str",
            "            Resource that the rule applies to",
            "        scope: Scope",
            "            Scope that the rule applies to",
            "        operation: Operation",
            "            Operation that the rule applies to",
            "        \"\"\"",
            "        self.assign_rule_to_fixed_role(DefaultRole.ROOT, name, scope,",
            "                                       operation)",
            "",
            "    def assign_rule_to_node(self, resource: str, scope: Scope,",
            "                            operation: Operation) -> None:",
            "        \"\"\"",
            "        Assign a rule to the Node role.",
            "",
            "        Parameters",
            "        ----------",
            "        resource: str",
            "            Resource that the rule applies to",
            "        scope: Scope",
            "            Scope that the rule applies to",
            "        operation: Operation",
            "            Operation that the rule applies to",
            "        \"\"\"",
            "        self.assign_rule_to_fixed_role(DefaultRole.NODE, resource, scope,",
            "                                       operation)",
            "",
            "    def assign_rule_to_container(self, resource: str, scope: Scope,",
            "                                 operation: Operation) -> None:",
            "        \"\"\"",
            "        Assign a rule to the container role.",
            "",
            "        Parameters",
            "        ----------",
            "        resource: str",
            "            Resource that the rule applies to",
            "        scope: Scope",
            "            Scope that the rule applies to",
            "        operation: Operation",
            "            Operation that the rule applies to",
            "        \"\"\"",
            "        self.assign_rule_to_fixed_role(DefaultRole.CONTAINER, resource, scope,",
            "                                       operation)",
            "",
            "    @staticmethod",
            "    def assign_rule_to_fixed_role(fixedrole: str, resource: str, scope: Scope,",
            "                                  operation: Operation) -> None:",
            "        \"\"\"",
            "        Attach a rule to a fixed role (not adjustable by users).",
            "",
            "        Parameters",
            "        ----------",
            "        fixedrole: str",
            "            Name of the fixed role that the rule should be added to",
            "        resource: str",
            "            Resource that the rule applies to",
            "        scope: Scope",
            "            Scope that the rule applies to",
            "        operation: Operation",
            "            Operation that the rule applies to",
            "        \"\"\"",
            "        role = Role.get_by_name(fixedrole)",
            "        if not role:",
            "            log.warning(f\"{fixedrole} role not found, creating it now!\")",
            "            role = Role(name=fixedrole, description=f\"{fixedrole} role\")",
            "",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        if not rule:",
            "            log.error(f\"Rule ({resource},{scope},{operation}) not found!\")",
            "",
            "        if rule not in role.rules:",
            "            role.rules.append(rule)",
            "            log.info(f\"Rule ({resource},{scope},{operation}) added to \"",
            "                     f\"{fixedrole} role!\")",
            "",
            "    def register_rule(self, resource: str, scope: Scope,",
            "                      operation: Operation, description=None,",
            "                      assign_to_node=False, assign_to_container=False) -> None:",
            "        \"\"\"",
            "        Register a permission rule in the database.",
            "",
            "        If a rule already exists, nothing is done. This rule can be used in API",
            "        endpoints to determine if a user, node or container can do a certain",
            "        operation in a certain scope.",
            "",
            "        Parameters",
            "        ----------",
            "        resource : str",
            "            API resource that the rule applies to",
            "        scope : Scope",
            "            Scope of the rule",
            "        operation : Operation",
            "            Operation of the rule",
            "        description : String, optional",
            "            Human readable description where the rule is used for, by default",
            "            None",
            "        assign_to_node: bool, optional",
            "            Whether rule should be assigned to the node role or not. Default",
            "            False",
            "        assign_to_container: bool, optional",
            "            Whether rule should be assigned to the container role or not.",
            "            Default False",
            "        \"\"\"",
            "        # verify that the rule is in the DB, so that these can be assigned to",
            "        # roles and users",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        if not rule:",
            "            rule = Rule(name=resource, operation=operation, scope=scope,",
            "                        description=description)",
            "            rule.save()",
            "            log.debug(f\"New auth rule '{resource}' with scope={scope}\"",
            "                      f\" and operation={operation} is stored in the DB\")",
            "",
            "        if assign_to_container:",
            "            self.assign_rule_to_container(resource, scope, operation)",
            "",
            "        if assign_to_node:",
            "            self.assign_rule_to_node(resource, scope, operation)",
            "",
            "        # assign all new rules to root user",
            "        self.assign_rule_to_root(resource, scope, operation)",
            "",
            "        self.collection(resource).add(rule.scope, rule.operation)",
            "",
            "    def appender(self, name: str) -> callable:",
            "        \"\"\"",
            "        Add a module's rules to the rule collection",
            "",
            "        Parameters",
            "        ----------",
            "        name: str",
            "            The name of the module whose rules are to be registered",
            "",
            "        Returns",
            "        -------",
            "        Callable",
            "            A callable ``register_rule`` function",
            "        \"\"\"",
            "        # make sure collection exists",
            "        self.collection(name)",
            "        return lambda *args, **kwargs: self.register_rule(name, *args,",
            "                                                          **kwargs)",
            "",
            "    def collection(self, name: str) -> RuleCollection:",
            "        \"\"\"",
            "        Get a RuleCollection object. If it doesn't exist yet, it will be",
            "        created.",
            "",
            "        Parameters",
            "        ----------",
            "        name: str",
            "            Name of the module whose RuleCollection is to be obtained or",
            "            created",
            "",
            "        Returns",
            "        -------",
            "        RuleCollection",
            "            The collection of rules belonging to the module name",
            "        \"\"\"",
            "        if self._collection_exists(name):",
            "            return self.collections[name]",
            "        else:",
            "            self.collections[name] = RuleCollection(name)",
            "            return self.collections[name]",
            "",
            "    def _collection_exists(self, name: str) -> bool:",
            "        \"\"\"",
            "        Check if a module's rule collection is defined",
            "",
            "        Parameters",
            "        ----------",
            "        name: str",
            "            Name of the module to be checked",
            "",
            "        Returns",
            "        -------",
            "        bool:",
            "            True if RuleCollection is defined for module, else False",
            "        \"\"\"",
            "        return name in self.collections",
            "",
            "    def __getattr__(self, name: str) -> RuleCollection:",
            "        # TODO BvB 2023-01-18 I think this function might not be used. It would",
            "        # be triggered when we do something like",
            "        # `permissionManager.resource_name` but we don't ever do that (?!)",
            "        try:",
            "            collection = self.collections[name]",
            "            return collection",
            "        except Exception as e:",
            "            log.critical(f\"Missing permission collection! {name}\")",
            "            raise e",
            "",
            "    @staticmethod",
            "    def rule_exists_in_db(name: str, scope: Scope,",
            "                          operation: Operation) -> bool:",
            "        \"\"\"Check if the rule exists in the DB.",
            "",
            "        Parameters",
            "        ----------",
            "        name: str",
            "            Name of the rule",
            "        scope: Scope",
            "            Scope of the rule",
            "        operation: Operation",
            "            Operation of the rule",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whenever this rule exists in the database or not",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(Rule).filter_by(",
            "            name=name,",
            "            operation=operation,",
            "            scope=scope",
            "        ).scalar()",
            "        session.commit()",
            "        return result",
            "",
            "    @staticmethod",
            "    def check_user_rules(rules: list[Rule]) -> dict | bool:",
            "        \"\"\"",
            "        Check if a user, node or container has all the `rules` in a list",
            "",
            "        Parameters",
            "        ----------",
            "        rules: list[:class:`~vantage6.server.model.rule.Rule`]",
            "            List of rules that user is checked to have",
            "",
            "        Returns",
            "        -------",
            "        dict | bool",
            "            Dict with a message which rule is missing, else None",
            "        \"\"\"",
            "        for rule in rules:",
            "            requires = RuleNeed(rule.name, rule.scope, rule.operation)",
            "            try:",
            "                Permission(requires).test()",
            "            except PermissionDenied:",
            "                return {\"msg\": f\"You don't have the rule ({rule.name}, \"",
            "                        f\"{rule.scope}, {rule.operation})\"}",
            "        return None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": [
                "RuleCollection"
            ],
            "45": [
                "RuleCollection",
                "add"
            ]
        },
        "addLocation": []
    },
    "vantage6-server/vantage6/server/resource/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from vantage6.common import logger_name"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from vantage6.server import db"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from vantage6.server.utils import ("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    obtain_auth_collaborations, obtain_auth_organization"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from vantage6.server.model.authenticatable import Authenticatable"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from vantage6.server.resource.common.output_schema import HATEOASModelSchema"
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from vantage6.server.permission import PermissionManager"
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from vantage6.server.resource.common.pagination import Page"
            },
            "10": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         db.Organization"
            },
            "11": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "             Organization model"
            },
            "12": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return db.Organization.get(cls.obtain_organization_id())"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        return obtain_auth_organization()"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+    @staticmethod"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    def obtain_auth_collaborations() -> list[db.Collaboration]:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        \"\"\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        Obtain the collaborations that the auth is part of."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        Returns"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        -------"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        list[db.Collaboration]"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            List of collaborations"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        \"\"\""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        return obtain_auth_collaborations()"
            },
            "27": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 171,
                "PatchRowcode": " # ------------------------------------------------------------------------------"
            },
            "30": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "     if dt:"
            },
            "31": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "         return datetime.datetime.strptime(dt, '%Y-%m-%dT%H:%M:%S.%f')"
            },
            "32": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "     return default"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+def get_org_ids_from_collabs(auth: Authenticatable,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+                             collab_id: int = None) -> list[int]:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+    \"\"\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+    Get all organization ids from the collaborations the user or node is in."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+    Parameters"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+    ----------"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+    auth : Authenticatable"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+        User or node"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+    collab_id : int, optional"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+        Collaboration id. If given, only return the organization ids of this"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        collaboration. If not given, return all organization ids of all"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+        collaborations the user or node is in."
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+    Returns"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+    -------"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+    list[int]"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        List of organization ids"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+    \"\"\""
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+    if collab_id:"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+        return ["
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+            org.id"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+            for col in auth.organization.collaborations"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+            for org in col.organizations"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+            if col.id == collab_id"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+        ]"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+    else:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+        return ["
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+            org.id"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+            for col in auth.organization.collaborations"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+            for org in col.organizations"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+        ]"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import datetime",
            "from http import HTTPStatus",
            "import logging",
            "",
            "from functools import wraps",
            "",
            "from flask import g, request",
            "from flask_restful import Resource, Api",
            "from flask_mail import Mail",
            "from flask_jwt_extended import (",
            "    get_jwt, get_jwt_identity, jwt_required",
            ")",
            "from flask_socketio import SocketIO",
            "",
            "",
            "from vantage6.common import logger_name",
            "from vantage6.server import db",
            "from vantage6.server.resource.common.output_schema import HATEOASModelSchema",
            "from vantage6.server.permission import PermissionManager",
            "from vantage6.server.resource.common.pagination import Page",
            "",
            "log = logging.getLogger(logger_name(__name__))",
            "",
            "",
            "class ServicesResources(Resource):",
            "    \"\"\"",
            "    Flask resource base class.",
            "",
            "    Adds functionality like mail, socket, permissions and the api itself.",
            "    Also adds common helper functions.",
            "",
            "    Attributes",
            "    ----------",
            "    socketio : SocketIO",
            "        SocketIO instance",
            "    mail : Mail",
            "        Mail instance",
            "    api : Api",
            "        Api instance",
            "    permissions : PermissionManager",
            "        Instance of class that manages permissions",
            "    config : dict",
            "        Configuration dictionary",
            "    \"\"\"",
            "    def __init__(self, socketio: SocketIO, mail: Mail, api: Api,",
            "                 permissions: PermissionManager, config: dict):",
            "        self.socketio = socketio",
            "        self.mail = mail",
            "        self.api = api",
            "        self.permissions = permissions",
            "        self.config = config",
            "",
            "    @staticmethod",
            "    def is_included(field) -> bool:",
            "        \"\"\"",
            "        Check that a `field` is included in the request argument context.",
            "",
            "        Parameters",
            "        ----------",
            "        field : str",
            "            Name of the field to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            True if the field is included, False otherwise",
            "        \"\"\"",
            "        return field in request.args.getlist('include')",
            "",
            "    def dump(self, page: Page, schema: HATEOASModelSchema) -> dict:",
            "        \"\"\"",
            "        Dump based on the request context (to paginate or not)",
            "",
            "        Parameters",
            "        ----------",
            "        page : Page",
            "            Page object to dump",
            "        schema : HATEOASModelSchema",
            "            Schema to use for dumping",
            "",
            "        Returns",
            "        -------",
            "        dict",
            "            Dumped page",
            "        \"\"\"",
            "        return schema.meta_dump(page)",
            "",
            "    def response(self, page: Page, schema: HATEOASModelSchema):",
            "        \"\"\"",
            "        Prepare a valid HTTP OK response from a page object",
            "",
            "        Parameters",
            "        ----------",
            "        page : Page",
            "            Page object to dump",
            "        schema : HATEOASModelSchema",
            "            Schema to use for dumping",
            "",
            "        Returns",
            "        -------",
            "        tuple",
            "            Tuple of (dumped page, HTTPStatus.OK, headers of the page)",
            "        \"\"\"",
            "        return self.dump(page, schema), HTTPStatus.OK, page.headers",
            "",
            "    @staticmethod",
            "    def obtain_auth() -> db.Authenticatable | dict:",
            "        \"\"\"",
            "        Read authenticatable object or dict from the flask global context.",
            "",
            "        Returns",
            "        -------",
            "        Union[db.Authenticatable, dict]",
            "            Authenticatable object or dict. Authenticatable object is either a",
            "            user or node. Dict is for a container.",
            "        \"\"\"",
            "        if g.user:",
            "            return g.user",
            "        if g.node:",
            "            return g.node",
            "        if g.container:",
            "            return g.container",
            "",
            "    @staticmethod",
            "    def obtain_organization_id() -> int:",
            "        \"\"\"",
            "        Obtain the organization id from the auth that is logged in.",
            "",
            "        Returns",
            "        -------",
            "        int",
            "            Organization id",
            "        \"\"\"",
            "        if g.user:",
            "            return g.user.organization.id",
            "        elif g.node:",
            "            return g.node.organization.id",
            "        else:",
            "            return g.container[\"organization_id\"]",
            "",
            "    @classmethod",
            "    def obtain_auth_organization(cls) -> db.Organization:",
            "        \"\"\"",
            "        Obtain the organization model from the auth that is logged in.",
            "",
            "        Returns",
            "        -------",
            "        db.Organization",
            "            Organization model",
            "        \"\"\"",
            "        return db.Organization.get(cls.obtain_organization_id())",
            "",
            "",
            "# ------------------------------------------------------------------------------",
            "# Helper functions/decoraters ...",
            "# ------------------------------------------------------------------------------",
            "def only_for(types: tuple[str] = ('user', 'node', 'container')) -> callable:",
            "    \"\"\"",
            "    JWT endpoint protection decorator",
            "",
            "    Parameters",
            "    ----------",
            "    types : list[str]",
            "        List of types that are allowed to access the endpoint. Possible types",
            "        are 'user', 'node' and 'container'.",
            "",
            "    Returns",
            "    -------",
            "    function",
            "        Decorator function that can be used to protect endpoints",
            "    \"\"\"",
            "    def protection_decorator(fn):",
            "        @wraps(fn)",
            "        def decorator(*args, **kwargs):",
            "",
            "            # decode JWT-token",
            "            identity = get_jwt_identity()",
            "            claims = get_jwt()",
            "",
            "            # check that identity has access to endpoint",
            "            g.type = claims[\"client_type\"]",
            "            # log.debug(f\"Endpoint accessed as {g.type}\")",
            "",
            "            if g.type not in types:",
            "                # FIXME BvB 23-10-19: user gets a 500 error, would be better to",
            "                # get an error message with 400 code",
            "                msg = f\"{g.type}s are not allowed to access {request.url} \" \\",
            "                      f\"({request.method})\"",
            "                log.warning(msg)",
            "                raise Exception(msg)",
            "",
            "            # do some specific stuff per identity",
            "            g.user = g.container = g.node = None",
            "",
            "            if g.type == 'user':",
            "                user = get_and_update_authenticatable_info(identity)",
            "                g.user = user",
            "                assert g.user.type == g.type",
            "                log.debug(",
            "                    f\"Received request from user {user.username} ({user.id})\")",
            "",
            "            elif g.type == 'node':",
            "                node = get_and_update_authenticatable_info(identity)",
            "                g.node = node",
            "                assert g.node.type == g.type",
            "                log.debug(",
            "                    f\"Received request from node {node.name} ({node.id})\")",
            "",
            "            elif g.type == 'container':",
            "                g.container = identity",
            "                log.debug(",
            "                    \"Received request from container with node id \"",
            "                    f\"{identity['node_id']} and task id {identity['task_id']}\")",
            "",
            "            else:",
            "                raise Exception(f\"Unknown entity: {g.type}\")",
            "",
            "            return fn(*args, **kwargs)",
            "        return jwt_required()(decorator)",
            "    return protection_decorator",
            "",
            "",
            "def get_and_update_authenticatable_info(auth_id: int) -> db.Authenticatable:",
            "    \"\"\"",
            "    Get user or node from ID and update last time seen online.",
            "",
            "    Parameters",
            "    ----------",
            "    auth_id : int",
            "        ID of the user or node",
            "",
            "    Returns",
            "    -------",
            "    db.Authenticatable",
            "        User or node database model",
            "    \"\"\"",
            "    auth = db.Authenticatable.get(auth_id)",
            "    auth.last_seen = datetime.datetime.utcnow()",
            "    auth.save()",
            "    return auth",
            "",
            "",
            "# create alias decorators",
            "with_user_or_node = only_for((\"user\", \"node\",))",
            "with_user = only_for((\"user\",))",
            "with_node = only_for((\"node\",))",
            "with_container = only_for((\"container\",))",
            "",
            "",
            "def parse_datetime(dt: str = None, default: datetime = None) -> datetime:",
            "    \"\"\"",
            "    Utility function to parse a datetime string.",
            "",
            "    Parameters",
            "    ----------",
            "    dt : str",
            "        Datetime string",
            "    default : datetime",
            "        Default datetime to return if `dt` is None",
            "",
            "    Returns",
            "    -------",
            "    datetime",
            "        Datetime object",
            "    \"\"\"",
            "    if dt:",
            "        return datetime.datetime.strptime(dt, '%Y-%m-%dT%H:%M:%S.%f')",
            "    return default"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import datetime",
            "from http import HTTPStatus",
            "import logging",
            "",
            "from functools import wraps",
            "",
            "from flask import g, request",
            "from flask_restful import Resource, Api",
            "from flask_mail import Mail",
            "from flask_jwt_extended import (",
            "    get_jwt, get_jwt_identity, jwt_required",
            ")",
            "from flask_socketio import SocketIO",
            "",
            "",
            "from vantage6.common import logger_name",
            "from vantage6.server import db",
            "from vantage6.server.utils import (",
            "    obtain_auth_collaborations, obtain_auth_organization",
            ")",
            "from vantage6.server.model.authenticatable import Authenticatable",
            "from vantage6.server.resource.common.output_schema import HATEOASModelSchema",
            "from vantage6.server.permission import PermissionManager",
            "from vantage6.server.resource.common.pagination import Page",
            "",
            "log = logging.getLogger(logger_name(__name__))",
            "",
            "",
            "class ServicesResources(Resource):",
            "    \"\"\"",
            "    Flask resource base class.",
            "",
            "    Adds functionality like mail, socket, permissions and the api itself.",
            "    Also adds common helper functions.",
            "",
            "    Attributes",
            "    ----------",
            "    socketio : SocketIO",
            "        SocketIO instance",
            "    mail : Mail",
            "        Mail instance",
            "    api : Api",
            "        Api instance",
            "    permissions : PermissionManager",
            "        Instance of class that manages permissions",
            "    config : dict",
            "        Configuration dictionary",
            "    \"\"\"",
            "    def __init__(self, socketio: SocketIO, mail: Mail, api: Api,",
            "                 permissions: PermissionManager, config: dict):",
            "        self.socketio = socketio",
            "        self.mail = mail",
            "        self.api = api",
            "        self.permissions = permissions",
            "        self.config = config",
            "",
            "    @staticmethod",
            "    def is_included(field) -> bool:",
            "        \"\"\"",
            "        Check that a `field` is included in the request argument context.",
            "",
            "        Parameters",
            "        ----------",
            "        field : str",
            "            Name of the field to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            True if the field is included, False otherwise",
            "        \"\"\"",
            "        return field in request.args.getlist('include')",
            "",
            "    def dump(self, page: Page, schema: HATEOASModelSchema) -> dict:",
            "        \"\"\"",
            "        Dump based on the request context (to paginate or not)",
            "",
            "        Parameters",
            "        ----------",
            "        page : Page",
            "            Page object to dump",
            "        schema : HATEOASModelSchema",
            "            Schema to use for dumping",
            "",
            "        Returns",
            "        -------",
            "        dict",
            "            Dumped page",
            "        \"\"\"",
            "        return schema.meta_dump(page)",
            "",
            "    def response(self, page: Page, schema: HATEOASModelSchema):",
            "        \"\"\"",
            "        Prepare a valid HTTP OK response from a page object",
            "",
            "        Parameters",
            "        ----------",
            "        page : Page",
            "            Page object to dump",
            "        schema : HATEOASModelSchema",
            "            Schema to use for dumping",
            "",
            "        Returns",
            "        -------",
            "        tuple",
            "            Tuple of (dumped page, HTTPStatus.OK, headers of the page)",
            "        \"\"\"",
            "        return self.dump(page, schema), HTTPStatus.OK, page.headers",
            "",
            "    @staticmethod",
            "    def obtain_auth() -> db.Authenticatable | dict:",
            "        \"\"\"",
            "        Read authenticatable object or dict from the flask global context.",
            "",
            "        Returns",
            "        -------",
            "        Union[db.Authenticatable, dict]",
            "            Authenticatable object or dict. Authenticatable object is either a",
            "            user or node. Dict is for a container.",
            "        \"\"\"",
            "        if g.user:",
            "            return g.user",
            "        if g.node:",
            "            return g.node",
            "        if g.container:",
            "            return g.container",
            "",
            "    @staticmethod",
            "    def obtain_organization_id() -> int:",
            "        \"\"\"",
            "        Obtain the organization id from the auth that is logged in.",
            "",
            "        Returns",
            "        -------",
            "        int",
            "            Organization id",
            "        \"\"\"",
            "        if g.user:",
            "            return g.user.organization.id",
            "        elif g.node:",
            "            return g.node.organization.id",
            "        else:",
            "            return g.container[\"organization_id\"]",
            "",
            "    @classmethod",
            "    def obtain_auth_organization(cls) -> db.Organization:",
            "        \"\"\"",
            "        Obtain the organization model from the auth that is logged in.",
            "",
            "        Returns",
            "        -------",
            "        db.Organization",
            "            Organization model",
            "        \"\"\"",
            "        return obtain_auth_organization()",
            "",
            "    @staticmethod",
            "    def obtain_auth_collaborations() -> list[db.Collaboration]:",
            "        \"\"\"",
            "        Obtain the collaborations that the auth is part of.",
            "",
            "        Returns",
            "        -------",
            "        list[db.Collaboration]",
            "            List of collaborations",
            "        \"\"\"",
            "        return obtain_auth_collaborations()",
            "",
            "",
            "# ------------------------------------------------------------------------------",
            "# Helper functions/decoraters ...",
            "# ------------------------------------------------------------------------------",
            "def only_for(types: tuple[str] = ('user', 'node', 'container')) -> callable:",
            "    \"\"\"",
            "    JWT endpoint protection decorator",
            "",
            "    Parameters",
            "    ----------",
            "    types : list[str]",
            "        List of types that are allowed to access the endpoint. Possible types",
            "        are 'user', 'node' and 'container'.",
            "",
            "    Returns",
            "    -------",
            "    function",
            "        Decorator function that can be used to protect endpoints",
            "    \"\"\"",
            "    def protection_decorator(fn):",
            "        @wraps(fn)",
            "        def decorator(*args, **kwargs):",
            "",
            "            # decode JWT-token",
            "            identity = get_jwt_identity()",
            "            claims = get_jwt()",
            "",
            "            # check that identity has access to endpoint",
            "            g.type = claims[\"client_type\"]",
            "            # log.debug(f\"Endpoint accessed as {g.type}\")",
            "",
            "            if g.type not in types:",
            "                # FIXME BvB 23-10-19: user gets a 500 error, would be better to",
            "                # get an error message with 400 code",
            "                msg = f\"{g.type}s are not allowed to access {request.url} \" \\",
            "                      f\"({request.method})\"",
            "                log.warning(msg)",
            "                raise Exception(msg)",
            "",
            "            # do some specific stuff per identity",
            "            g.user = g.container = g.node = None",
            "",
            "            if g.type == 'user':",
            "                user = get_and_update_authenticatable_info(identity)",
            "                g.user = user",
            "                assert g.user.type == g.type",
            "                log.debug(",
            "                    f\"Received request from user {user.username} ({user.id})\")",
            "",
            "            elif g.type == 'node':",
            "                node = get_and_update_authenticatable_info(identity)",
            "                g.node = node",
            "                assert g.node.type == g.type",
            "                log.debug(",
            "                    f\"Received request from node {node.name} ({node.id})\")",
            "",
            "            elif g.type == 'container':",
            "                g.container = identity",
            "                log.debug(",
            "                    \"Received request from container with node id \"",
            "                    f\"{identity['node_id']} and task id {identity['task_id']}\")",
            "",
            "            else:",
            "                raise Exception(f\"Unknown entity: {g.type}\")",
            "",
            "            return fn(*args, **kwargs)",
            "        return jwt_required()(decorator)",
            "    return protection_decorator",
            "",
            "",
            "def get_and_update_authenticatable_info(auth_id: int) -> db.Authenticatable:",
            "    \"\"\"",
            "    Get user or node from ID and update last time seen online.",
            "",
            "    Parameters",
            "    ----------",
            "    auth_id : int",
            "        ID of the user or node",
            "",
            "    Returns",
            "    -------",
            "    db.Authenticatable",
            "        User or node database model",
            "    \"\"\"",
            "    auth = db.Authenticatable.get(auth_id)",
            "    auth.last_seen = datetime.datetime.utcnow()",
            "    auth.save()",
            "    return auth",
            "",
            "",
            "# create alias decorators",
            "with_user_or_node = only_for((\"user\", \"node\",))",
            "with_user = only_for((\"user\",))",
            "with_node = only_for((\"node\",))",
            "with_container = only_for((\"container\",))",
            "",
            "",
            "def parse_datetime(dt: str = None, default: datetime = None) -> datetime:",
            "    \"\"\"",
            "    Utility function to parse a datetime string.",
            "",
            "    Parameters",
            "    ----------",
            "    dt : str",
            "        Datetime string",
            "    default : datetime",
            "        Default datetime to return if `dt` is None",
            "",
            "    Returns",
            "    -------",
            "    datetime",
            "        Datetime object",
            "    \"\"\"",
            "    if dt:",
            "        return datetime.datetime.strptime(dt, '%Y-%m-%dT%H:%M:%S.%f')",
            "    return default",
            "",
            "",
            "def get_org_ids_from_collabs(auth: Authenticatable,",
            "                             collab_id: int = None) -> list[int]:",
            "    \"\"\"",
            "    Get all organization ids from the collaborations the user or node is in.",
            "",
            "    Parameters",
            "    ----------",
            "    auth : Authenticatable",
            "        User or node",
            "    collab_id : int, optional",
            "        Collaboration id. If given, only return the organization ids of this",
            "        collaboration. If not given, return all organization ids of all",
            "        collaborations the user or node is in.",
            "",
            "    Returns",
            "    -------",
            "    list[int]",
            "        List of organization ids",
            "    \"\"\"",
            "    if collab_id:",
            "        return [",
            "            org.id",
            "            for col in auth.organization.collaborations",
            "            for org in col.organizations",
            "            if col.id == collab_id",
            "        ]",
            "    else:",
            "        return [",
            "            org.id",
            "            for col in auth.organization.collaborations",
            "            for org in col.organizations",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "152": [
                "ServicesResources",
                "obtain_auth_organization"
            ]
        },
        "addLocation": []
    }
}