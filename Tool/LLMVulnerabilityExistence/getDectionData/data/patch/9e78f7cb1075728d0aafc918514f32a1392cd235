{
    "cdo_local_uuid/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " _logger = logging.getLogger(pathlib.Path(__file__).name)"
            },
            "1": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+def _is_relative_to(p1: pathlib.Path, p2: pathlib.Path) -> bool:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    This function provides pathlib.is_relative_to to Pythons before 3.9.  After the End of Life of Python 3.8, this function can be removed."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    \"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    if sys.version_info < (3, 9):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        try:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            _ = p1.relative_to(p2)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            return True"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        except ValueError:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            return False"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    else:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        return p1.is_relative_to(p2)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " def configure() -> None:"
            },
            "18": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     \"\"\""
            },
            "19": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     This function is part of setting up _demo_uuid() to generate non-random UUIDs.  See _demo_uuid() documentation for further setup notes."
            },
            "20": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     \"\"\""
            },
            "21": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     global DEMO_UUID_BASE"
            },
            "22": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    # _logger.debug(\"sys.argv = %r.\", sys.argv)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     if os.getenv(\"DEMO_UUID_REQUESTING_NONRANDOM\") == \"NONRANDOM_REQUESTED\":"
            },
            "26": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         warnings.warn("
            },
            "27": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "             \"Environment variable DEMO_UUID_REQUESTING_NONRANDOM is deprecated.  See cdo_local_uuid._demo_uuid for usage notes on its replacement, CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\","
            },
            "28": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         demo_uuid_base_parts.append(sys.argv[0])"
            },
            "29": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "     else:"
            },
            "30": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         command_original_path = pathlib.Path(sys.argv[0])"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        # _logger.debug(\"command_original_path = %r.\", command_original_path)"
            },
            "32": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         command_resolved_path = command_original_path.resolve()"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        # _logger.debug(\"command_resolved_path = %r.\", command_resolved_path)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        # The command could be a command embedded in a virtual"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        # environment, or it could be a script external to any virtual"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        # environment."
            },
            "38": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         venv_original_path = pathlib.Path(env_venv_name)"
            },
            "39": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         venv_resolved_path = venv_original_path.resolve()"
            },
            "40": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        if _is_relative_to(command_resolved_path, venv_resolved_path):"
            },
            "42": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "             command_relative_path = command_resolved_path.relative_to("
            },
            "43": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "                 venv_resolved_path"
            },
            "44": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "             )"
            },
            "45": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "             # _logger.debug(\"command_relative_path = %r.\", command_relative_path)"
            },
            "46": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "             demo_uuid_base_parts.append(str(command_relative_path))"
            },
            "47": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except ValueError:"
            },
            "48": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # _logger.debug(\"Command path is not relative to virtual environment path.\")"
            },
            "49": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            demo_uuid_base_parts.append(str(command_resolved_path))"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        else:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+            demo_uuid_base_parts.append(str(command_original_path))"
            },
            "52": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     if len(sys.argv) > 1:"
            },
            "54": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         # Component: Arguments of argument vector."
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python3",
            "",
            "# Portions of this file contributed by NIST are governed by the",
            "# following statement:",
            "#",
            "# This software was developed at the National Institute of Standards",
            "# and Technology by employees of the Federal Government in the course",
            "# of their official duties. Pursuant to Title 17 Section 105 of the",
            "# United States Code, this software is not subject to copyright",
            "# protection within the United States. NIST assumes no responsibility",
            "# whatsoever for its use by other parties, and makes no guarantees,",
            "# expressed or implied, about its quality, reliability, or any other",
            "# characteristic.",
            "#",
            "# We would appreciate acknowledgement if the software is used.",
            "",
            "\"\"\"",
            "This library is a wrapper for uuid, provided to generate repeatable UUIDs if requested.",
            "",
            "The function local_uuid() should be used in code where a user could be expected to opt in to non-random UUIDs.",
            "\"\"\"",
            "",
            "__version__ = \"0.4.0\"",
            "",
            "__all__ = [\"configure\", \"local_uuid\"]",
            "",
            "import logging",
            "import os",
            "import pathlib",
            "import sys",
            "import typing",
            "import uuid",
            "import warnings",
            "",
            "DEMO_UUID_BASE: typing.Optional[str] = None",
            "",
            "DEMO_UUID_COUNTER: int = 0",
            "",
            "_logger = logging.getLogger(pathlib.Path(__file__).name)",
            "",
            "",
            "def configure() -> None:",
            "    \"\"\"",
            "    This function is part of setting up _demo_uuid() to generate non-random UUIDs.  See _demo_uuid() documentation for further setup notes.",
            "    \"\"\"",
            "    global DEMO_UUID_BASE",
            "",
            "    if os.getenv(\"DEMO_UUID_REQUESTING_NONRANDOM\") == \"NONRANDOM_REQUESTED\":",
            "        warnings.warn(",
            "            \"Environment variable DEMO_UUID_REQUESTING_NONRANDOM is deprecated.  See cdo_local_uuid._demo_uuid for usage notes on its replacement, CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\",",
            "            FutureWarning,",
            "        )",
            "        return",
            "",
            "    if os.getenv(\"CASE_DEMO_NONRANDOM_UUID_BASE\") is not None:",
            "        warnings.warn(",
            "            \"Environment variable CASE_DEMO_NONRANDOM_UUID_BASE is deprecated.  Its replacement variable is CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\",",
            "            FutureWarning,",
            "        )",
            "        return",
            "",
            "    env_base_dir_name = os.getenv(\"CDO_DEMO_NONRANDOM_UUID_BASE\")",
            "    if env_base_dir_name is None:",
            "        return",
            "",
            "    base_dir_original_path = pathlib.Path(env_base_dir_name)",
            "    if not base_dir_original_path.exists():",
            "        warnings.warn(",
            "            \"Environment variable CDO_DEMO_NONRANDOM_UUID_BASE is expected to refer to an existing directory.  Proceeding with random UUIDs.\",",
            "            RuntimeWarning,",
            "        )",
            "        return",
            "    if not base_dir_original_path.is_dir():",
            "        warnings.warn(",
            "            \"Environment variable CDO_DEMO_NONRANDOM_UUID_BASE is expected to refer to a directory.  Proceeding with random UUIDs.\",",
            "            RuntimeWarning,",
            "        )",
            "        return",
            "",
            "    # Component: An emphasis this is an example.",
            "    demo_uuid_base_parts = [\"example.org\"]",
            "",
            "    # Component: Present working directory, relative to CDO_DEMO_NONRANDOM_UUID_BASE if that environment variable is an ancestor of pwd.",
            "    base_dir_resolved_path = base_dir_original_path.resolve()",
            "    srcdir_original_path = pathlib.Path(os.getcwd())",
            "    srcdir_resolved_path = srcdir_original_path.resolve()",
            "    # _logger.debug(\"base_dir_resolved_path = %r.\", base_dir_resolved_path)",
            "    # _logger.debug(\"srcdir_resolved_path = %r.\", srcdir_resolved_path)",
            "    try:",
            "        srcdir_relative_path = srcdir_resolved_path.relative_to(base_dir_resolved_path)",
            "        # _logger.debug(\"srcdir_relative_path = %r.\", srcdir_relative_path)",
            "        demo_uuid_base_parts.append(str(srcdir_relative_path))",
            "    except ValueError:",
            "        # If base_dir is not an ancestor directory of srcdir, default to srcdir.",
            "        # _logger.debug(\"PWD is not relative to base path.\")",
            "        demo_uuid_base_parts.append(str(srcdir_resolved_path))",
            "",
            "    # Component: Command of argument vector.",
            "    env_venv_name = os.getenv(\"VIRTUAL_ENV\")",
            "    if env_venv_name is None:",
            "        demo_uuid_base_parts.append(sys.argv[0])",
            "    else:",
            "        command_original_path = pathlib.Path(sys.argv[0])",
            "        command_resolved_path = command_original_path.resolve()",
            "        venv_original_path = pathlib.Path(env_venv_name)",
            "        venv_resolved_path = venv_original_path.resolve()",
            "        try:",
            "            command_relative_path = command_resolved_path.relative_to(",
            "                venv_resolved_path",
            "            )",
            "            # _logger.debug(\"command_relative_path = %r.\", command_relative_path)",
            "            demo_uuid_base_parts.append(str(command_relative_path))",
            "        except ValueError:",
            "            # _logger.debug(\"Command path is not relative to virtual environment path.\")",
            "            demo_uuid_base_parts.append(str(command_resolved_path))",
            "",
            "    if len(sys.argv) > 1:",
            "        # Component: Arguments of argument vector.",
            "        demo_uuid_base_parts.extend(sys.argv[1:])",
            "",
            "    # _logger.debug(\"demo_uuid_base_parts = %r.\", demo_uuid_base_parts)",
            "",
            "    DEMO_UUID_BASE = \"/\".join(demo_uuid_base_parts)",
            "",
            "",
            "def _demo_uuid() -> str:",
            "    \"\"\"",
            "    This function generates a repeatable UUID, drawing on non-varying elements of the environment and process call for entropy.",
            "",
            "    This function is not intended to be called outside of this module.  Instead, local_uuid() should be called.",
            "",
            "    WARNING: This function was developed for use ONLY for reducing (but not eliminating) version-control edits to identifiers when generating sample data.  It creates UUIDs that are decidedly NOT random, and should remain consistent on repeated calls to the importing script.",
            "",
            "    To prevent accidental non-random UUID usage, two setup steps need to be done before calling this function:",
            "",
            "    * An environment variable, CDO_DEMO_NONRANDOM_UUID_BASE, must be set to a string provided by the caller.  The variable's required value is the path to some directory.  The variable's recommended value is the equivalent of the Make variable \"top_srcdir\" - that is, the root directory of the containing Git repository, some parent of the current process's current working directory.",
            "    * The configure() function in this module must be called.",
            "    \"\"\"",
            "    global DEMO_UUID_BASE",
            "    global DEMO_UUID_COUNTER",
            "",
            "    if os.getenv(\"CDO_DEMO_NONRANDOM_UUID_BASE\") is None:",
            "        raise ValueError(",
            "            \"demo_uuid() called without CDO_DEMO_NONRANDOM_UUID_BASE in environment.\"",
            "        )",
            "",
            "    if DEMO_UUID_BASE is None:",
            "        raise ValueError(\"demo_uuid() called with DEMO_UUID_BASE unset.\")",
            "",
            "    parts = [DEMO_UUID_BASE]",
            "",
            "    # Component: Incrementing counter.",
            "    DEMO_UUID_COUNTER += 1",
            "    parts.append(str(DEMO_UUID_COUNTER))",
            "",
            "    return str(uuid.uuid5(uuid.NAMESPACE_URL, \"/\".join(parts)))",
            "",
            "",
            "def local_uuid() -> str:",
            "    \"\"\"",
            "    Generate either a UUID4, or if requested via environment configuration, a non-random demo UUID.",
            "",
            "    >>> from cdo_local_uuid import local_uuid",
            "    >>> from uuid import UUID",
            "    >>> lu: str = local_uuid()",
            "    >>> # To get a UUID object, e.g. to verify syntax, feed local_uuid's string output into the UUID constructor.",
            "    >>> u = UUID(lu)",
            "    \"\"\"",
            "    global DEMO_UUID_BASE",
            "    if DEMO_UUID_BASE is None:",
            "        return str(uuid.uuid4())",
            "    else:",
            "        return _demo_uuid()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python3",
            "",
            "# Portions of this file contributed by NIST are governed by the",
            "# following statement:",
            "#",
            "# This software was developed at the National Institute of Standards",
            "# and Technology by employees of the Federal Government in the course",
            "# of their official duties. Pursuant to Title 17 Section 105 of the",
            "# United States Code, this software is not subject to copyright",
            "# protection within the United States. NIST assumes no responsibility",
            "# whatsoever for its use by other parties, and makes no guarantees,",
            "# expressed or implied, about its quality, reliability, or any other",
            "# characteristic.",
            "#",
            "# We would appreciate acknowledgement if the software is used.",
            "",
            "\"\"\"",
            "This library is a wrapper for uuid, provided to generate repeatable UUIDs if requested.",
            "",
            "The function local_uuid() should be used in code where a user could be expected to opt in to non-random UUIDs.",
            "\"\"\"",
            "",
            "__version__ = \"0.4.0\"",
            "",
            "__all__ = [\"configure\", \"local_uuid\"]",
            "",
            "import logging",
            "import os",
            "import pathlib",
            "import sys",
            "import typing",
            "import uuid",
            "import warnings",
            "",
            "DEMO_UUID_BASE: typing.Optional[str] = None",
            "",
            "DEMO_UUID_COUNTER: int = 0",
            "",
            "_logger = logging.getLogger(pathlib.Path(__file__).name)",
            "",
            "",
            "def _is_relative_to(p1: pathlib.Path, p2: pathlib.Path) -> bool:",
            "    \"\"\"",
            "    This function provides pathlib.is_relative_to to Pythons before 3.9.  After the End of Life of Python 3.8, this function can be removed.",
            "    \"\"\"",
            "    if sys.version_info < (3, 9):",
            "        try:",
            "            _ = p1.relative_to(p2)",
            "            return True",
            "        except ValueError:",
            "            return False",
            "    else:",
            "        return p1.is_relative_to(p2)",
            "",
            "",
            "def configure() -> None:",
            "    \"\"\"",
            "    This function is part of setting up _demo_uuid() to generate non-random UUIDs.  See _demo_uuid() documentation for further setup notes.",
            "    \"\"\"",
            "    global DEMO_UUID_BASE",
            "",
            "    # _logger.debug(\"sys.argv = %r.\", sys.argv)",
            "",
            "    if os.getenv(\"DEMO_UUID_REQUESTING_NONRANDOM\") == \"NONRANDOM_REQUESTED\":",
            "        warnings.warn(",
            "            \"Environment variable DEMO_UUID_REQUESTING_NONRANDOM is deprecated.  See cdo_local_uuid._demo_uuid for usage notes on its replacement, CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\",",
            "            FutureWarning,",
            "        )",
            "        return",
            "",
            "    if os.getenv(\"CASE_DEMO_NONRANDOM_UUID_BASE\") is not None:",
            "        warnings.warn(",
            "            \"Environment variable CASE_DEMO_NONRANDOM_UUID_BASE is deprecated.  Its replacement variable is CDO_DEMO_NONRANDOM_UUID_BASE.  Proceeding with random UUIDs.\",",
            "            FutureWarning,",
            "        )",
            "        return",
            "",
            "    env_base_dir_name = os.getenv(\"CDO_DEMO_NONRANDOM_UUID_BASE\")",
            "    if env_base_dir_name is None:",
            "        return",
            "",
            "    base_dir_original_path = pathlib.Path(env_base_dir_name)",
            "    if not base_dir_original_path.exists():",
            "        warnings.warn(",
            "            \"Environment variable CDO_DEMO_NONRANDOM_UUID_BASE is expected to refer to an existing directory.  Proceeding with random UUIDs.\",",
            "            RuntimeWarning,",
            "        )",
            "        return",
            "    if not base_dir_original_path.is_dir():",
            "        warnings.warn(",
            "            \"Environment variable CDO_DEMO_NONRANDOM_UUID_BASE is expected to refer to a directory.  Proceeding with random UUIDs.\",",
            "            RuntimeWarning,",
            "        )",
            "        return",
            "",
            "    # Component: An emphasis this is an example.",
            "    demo_uuid_base_parts = [\"example.org\"]",
            "",
            "    # Component: Present working directory, relative to CDO_DEMO_NONRANDOM_UUID_BASE if that environment variable is an ancestor of pwd.",
            "    base_dir_resolved_path = base_dir_original_path.resolve()",
            "    srcdir_original_path = pathlib.Path(os.getcwd())",
            "    srcdir_resolved_path = srcdir_original_path.resolve()",
            "    # _logger.debug(\"base_dir_resolved_path = %r.\", base_dir_resolved_path)",
            "    # _logger.debug(\"srcdir_resolved_path = %r.\", srcdir_resolved_path)",
            "    try:",
            "        srcdir_relative_path = srcdir_resolved_path.relative_to(base_dir_resolved_path)",
            "        # _logger.debug(\"srcdir_relative_path = %r.\", srcdir_relative_path)",
            "        demo_uuid_base_parts.append(str(srcdir_relative_path))",
            "    except ValueError:",
            "        # If base_dir is not an ancestor directory of srcdir, default to srcdir.",
            "        # _logger.debug(\"PWD is not relative to base path.\")",
            "        demo_uuid_base_parts.append(str(srcdir_resolved_path))",
            "",
            "    # Component: Command of argument vector.",
            "    env_venv_name = os.getenv(\"VIRTUAL_ENV\")",
            "    if env_venv_name is None:",
            "        demo_uuid_base_parts.append(sys.argv[0])",
            "    else:",
            "        command_original_path = pathlib.Path(sys.argv[0])",
            "        # _logger.debug(\"command_original_path = %r.\", command_original_path)",
            "        command_resolved_path = command_original_path.resolve()",
            "        # _logger.debug(\"command_resolved_path = %r.\", command_resolved_path)",
            "",
            "        # The command could be a command embedded in a virtual",
            "        # environment, or it could be a script external to any virtual",
            "        # environment.",
            "        venv_original_path = pathlib.Path(env_venv_name)",
            "        venv_resolved_path = venv_original_path.resolve()",
            "        if _is_relative_to(command_resolved_path, venv_resolved_path):",
            "            command_relative_path = command_resolved_path.relative_to(",
            "                venv_resolved_path",
            "            )",
            "            # _logger.debug(\"command_relative_path = %r.\", command_relative_path)",
            "            demo_uuid_base_parts.append(str(command_relative_path))",
            "        else:",
            "            demo_uuid_base_parts.append(str(command_original_path))",
            "",
            "    if len(sys.argv) > 1:",
            "        # Component: Arguments of argument vector.",
            "        demo_uuid_base_parts.extend(sys.argv[1:])",
            "",
            "    # _logger.debug(\"demo_uuid_base_parts = %r.\", demo_uuid_base_parts)",
            "",
            "    DEMO_UUID_BASE = \"/\".join(demo_uuid_base_parts)",
            "",
            "",
            "def _demo_uuid() -> str:",
            "    \"\"\"",
            "    This function generates a repeatable UUID, drawing on non-varying elements of the environment and process call for entropy.",
            "",
            "    This function is not intended to be called outside of this module.  Instead, local_uuid() should be called.",
            "",
            "    WARNING: This function was developed for use ONLY for reducing (but not eliminating) version-control edits to identifiers when generating sample data.  It creates UUIDs that are decidedly NOT random, and should remain consistent on repeated calls to the importing script.",
            "",
            "    To prevent accidental non-random UUID usage, two setup steps need to be done before calling this function:",
            "",
            "    * An environment variable, CDO_DEMO_NONRANDOM_UUID_BASE, must be set to a string provided by the caller.  The variable's required value is the path to some directory.  The variable's recommended value is the equivalent of the Make variable \"top_srcdir\" - that is, the root directory of the containing Git repository, some parent of the current process's current working directory.",
            "    * The configure() function in this module must be called.",
            "    \"\"\"",
            "    global DEMO_UUID_BASE",
            "    global DEMO_UUID_COUNTER",
            "",
            "    if os.getenv(\"CDO_DEMO_NONRANDOM_UUID_BASE\") is None:",
            "        raise ValueError(",
            "            \"demo_uuid() called without CDO_DEMO_NONRANDOM_UUID_BASE in environment.\"",
            "        )",
            "",
            "    if DEMO_UUID_BASE is None:",
            "        raise ValueError(\"demo_uuid() called with DEMO_UUID_BASE unset.\")",
            "",
            "    parts = [DEMO_UUID_BASE]",
            "",
            "    # Component: Incrementing counter.",
            "    DEMO_UUID_COUNTER += 1",
            "    parts.append(str(DEMO_UUID_COUNTER))",
            "",
            "    return str(uuid.uuid5(uuid.NAMESPACE_URL, \"/\".join(parts)))",
            "",
            "",
            "def local_uuid() -> str:",
            "    \"\"\"",
            "    Generate either a UUID4, or if requested via environment configuration, a non-random demo UUID.",
            "",
            "    >>> from cdo_local_uuid import local_uuid",
            "    >>> from uuid import UUID",
            "    >>> lu: str = local_uuid()",
            "    >>> # To get a UUID object, e.g. to verify syntax, feed local_uuid's string output into the UUID constructor.",
            "    >>> u = UUID(lu)",
            "    \"\"\"",
            "    global DEMO_UUID_BASE",
            "    if DEMO_UUID_BASE is None:",
            "        return str(uuid.uuid4())",
            "    else:",
            "        return _demo_uuid()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "107": [
                "configure"
            ],
            "113": [
                "configure"
            ],
            "114": [
                "configure"
            ],
            "115": [
                "configure"
            ]
        },
        "addLocation": [
            "cdo_local_uuid.configure.demo_uuid_base_parts",
            "cdo_local_uuid.configure",
            "saleor.graphql.checkout.mutations"
        ]
    }
}