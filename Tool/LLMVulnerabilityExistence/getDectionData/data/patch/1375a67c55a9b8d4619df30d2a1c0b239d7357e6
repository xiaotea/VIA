{
    "pypiserver/_app.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 250,
                "PatchRowcode": " @auth(\"list\")"
            },
            "1": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " def simple(prefix=\"\"):"
            },
            "2": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "     # PEP 503: require normalized prefix"
            },
            "3": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    normalized = core.normalize_pkgname(prefix)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+    normalized = core.normalize_pkgname_for_url(prefix)"
            },
            "5": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "     if prefix != normalized:"
            },
            "6": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         return redirect('/simple/{0}/'.format(normalized), 301)"
            },
            "7": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 256,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 327,
                "PatchRowcode": " @app.route('/:prefix')"
            },
            "9": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 328,
                "PatchRowcode": " @app.route('/:prefix/')"
            },
            "10": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 329,
                "PatchRowcode": " def bad_url(prefix):"
            },
            "11": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    p = request.fullpath"
            },
            "12": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if p.endswith(\"/\"):"
            },
            "13": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        p = p[:-1]"
            },
            "14": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    p = p.rsplit('/', 1)[0]"
            },
            "15": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    p += \"/simple/%s/\" % prefix"
            },
            "16": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "17": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return redirect(p)"
            },
            "18": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+    \"\"\"Redirect unknown root URLs to /simple/.\"\"\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+    return redirect(core.get_bad_url_redirect_path(request, prefix))"
            }
        },
        "frontPatchFile": [
            "from collections import namedtuple",
            "import logging",
            "import mimetypes",
            "import os",
            "import re",
            "import zipfile",
            "import xml.dom.minidom",
            "",
            "from . import __version__",
            "from . import core",
            "from .bottle import static_file, redirect, request, response, HTTPError, Bottle, template",
            "",
            "try:",
            "    import xmlrpc.client as xmlrpclib # py3",
            "except ImportError:",
            "    import xmlrpclib # py2",
            "",
            "try:",
            "    from io import BytesIO",
            "except ImportError:",
            "    from StringIO import StringIO as BytesIO",
            "",
            "try:  # PY3",
            "    from urllib.parse import urljoin",
            "except ImportError:  # PY2",
            "    from urlparse import urljoin",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "packages = None",
            "config = None",
            "",
            "app = Bottle()",
            "",
            "",
            "class auth(object):",
            "    \"\"\"decorator to apply authentication if specified for the decorated method & action\"\"\"",
            "",
            "    def __init__(self, action):",
            "        self.action = action",
            "",
            "    def __call__(self, method):",
            "",
            "        def protector(*args, **kwargs):",
            "            if self.action in config.authenticated:",
            "                if not request.auth or request.auth[1] is None:",
            "                    raise HTTPError(",
            "                        401, headers={\"WWW-Authenticate\": 'Basic realm=\"pypi\"'}",
            "                    )",
            "                if not config.auther(*request.auth):",
            "                    raise HTTPError(403)",
            "            return method(*args, **kwargs)",
            "",
            "        return protector",
            "",
            "",
            "@app.hook('before_request')",
            "def log_request():",
            "    log.info(config.log_req_frmt, request.environ)",
            "",
            "",
            "@app.hook('after_request')",
            "def log_response():",
            "    log.info(config.log_res_frmt, {  # vars(response))  ## DOES NOT WORK!",
            "        'response': response,",
            "        'status': response.status, 'headers': response.headers,",
            "        'body': response.body, 'cookies': response._cookies,",
            "    })",
            "",
            "",
            "@app.error",
            "def log_error(http_error):",
            "    log.info(config.log_err_frmt, vars(http_error))",
            "",
            "",
            "@app.route(\"/favicon.ico\")",
            "def favicon():",
            "    return HTTPError(404)",
            "",
            "",
            "@app.route('/')",
            "def root():",
            "    fp = request.fullpath",
            "",
            "    try:",
            "        numpkgs = len(list(packages()))",
            "    except:",
            "        numpkgs = 0",
            "",
            "    # Ensure template() does not consider `msg` as filename!",
            "    msg = config.welcome_msg + '\\n'",
            "    return template(msg,",
            "                    URL=request.url,",
            "                    VERSION=__version__,",
            "                    NUMPKGS=numpkgs,",
            "                    PACKAGES=urljoin(fp, \"packages/\"),",
            "                    SIMPLE=urljoin(fp, \"simple/\")",
            "                    )",
            "",
            "_bottle_upload_filename_re = re.compile(r'^[a-z0-9_.!+-]+$', re.I)",
            "",
            "",
            "def is_valid_pkg_filename(fname):",
            "    \"\"\"See https://github.com/pypiserver/pypiserver/issues/102\"\"\"",
            "    return _bottle_upload_filename_re.match(fname) is not None",
            "",
            "",
            "def doc_upload():",
            "    try:",
            "        content = request.files['content']",
            "    except KeyError:",
            "        raise HTTPError(400, \"Missing 'content' file-field!\")",
            "    zip_data = content.file.read()",
            "    try:",
            "        zf = zipfile.ZipFile(BytesIO(zip_data))",
            "        zf.getinfo('index.html')",
            "    except Exception:",
            "        raise HTTPError(400, \"not a zip file\")",
            "",
            "",
            "def remove_pkg():",
            "    name = request.forms.get(\"name\")",
            "    version = request.forms.get(\"version\")",
            "    if not name or not version:",
            "        msg = \"Missing 'name'/'version' fields: name=%s, version=%s\"",
            "        raise HTTPError(400, msg % (name, version))",
            "    found = None",
            "    for pkg in core.find_packages(packages()):",
            "        if pkg.pkgname == name and pkg.version == version:",
            "            found = pkg",
            "            break",
            "    if found is None:",
            "        raise HTTPError(404, \"%s (%s) not found\" % (name, version))",
            "    os.unlink(found.fn)",
            "",
            "",
            "Upload = namedtuple('Upload', 'pkg sig')",
            "",
            "",
            "def file_upload():",
            "    ufiles = Upload._make(",
            "        request.files.get(f, None) for f in ('content', 'gpg_signature'))",
            "    if not ufiles.pkg:",
            "        raise HTTPError(400, \"Missing 'content' file-field!\")",
            "    if (ufiles.sig and",
            "            '%s.asc' % ufiles.pkg.raw_filename != ufiles.sig.raw_filename):",
            "        raise HTTPError(400, \"Unrelated signature %r for package %r!\",",
            "                        ufiles.sig, ufiles.pkg)",
            "",
            "    for uf in ufiles:",
            "        if not uf:",
            "            continue",
            "        if (not is_valid_pkg_filename(uf.raw_filename) or",
            "                core.guess_pkgname_and_version(uf.raw_filename) is None):",
            "            raise HTTPError(400, \"Bad filename: %s\" % uf.raw_filename)",
            "",
            "        if not config.overwrite and core.exists(packages.root, uf.raw_filename):",
            "            log.warn(\"Cannot upload %r since it already exists! \\n\"",
            "                     \"  You may start server with `--overwrite` option. \",",
            "                     uf.raw_filename)",
            "            raise HTTPError(409, \"Package %r already exists!\\n\"",
            "                      \"  You may start server with `--overwrite` option.\",",
            "                      uf.raw_filename)",
            "",
            "        core.store(packages.root, uf.raw_filename, uf.save)",
            "        if request.auth:",
            "            user = request.auth[0]",
            "        else:",
            "            user = 'anon'",
            "        log.info('User %r stored %r.', user, uf.raw_filename)",
            "",
            "",
            "@app.post('/')",
            "@auth(\"update\")",
            "def update():",
            "    try:",
            "        action = request.forms[':action']",
            "    except KeyError:",
            "        raise HTTPError(400, \"Missing ':action' field!\")",
            "",
            "    if action in (\"verify\", \"submit\"):",
            "        log.warning(\"Ignored ':action': %s\", action)",
            "    elif action == \"doc_upload\":",
            "        doc_upload()",
            "    elif action == \"remove_pkg\":",
            "        remove_pkg()",
            "    elif action == \"file_upload\":",
            "        file_upload()",
            "    else:",
            "        raise HTTPError(400, \"Unsupported ':action' field: %s\" % action)",
            "",
            "    return \"\"",
            "",
            "",
            "@app.route(\"/simple\")",
            "@app.route(\"/simple/:prefix\")",
            "@app.route('/packages')",
            "@auth(\"list\")",
            "def pep_503_redirects(prefix=None):",
            "    return redirect(request.fullpath + \"/\", 301)",
            "",
            "",
            "@app.post('/RPC2')",
            "@auth(\"list\")",
            "def handle_rpc():",
            "    \"\"\"Handle pip-style RPC2 search requests\"\"\"",
            "    parser = xml.dom.minidom.parse(request.body)",
            "    methodname = parser.getElementsByTagName(",
            "        \"methodName\")[0].childNodes[0].wholeText.strip()",
            "    log.info(\"Processing RPC2 request for '%s'\", methodname)",
            "    if methodname == 'search':",
            "        value = parser.getElementsByTagName(",
            "            \"string\")[0].childNodes[0].wholeText.strip()",
            "        response = []",
            "        ordering = 0",
            "        for p in packages():",
            "            if p.pkgname.count(value) > 0:",
            "                # We do not presently have any description/summary, returning",
            "                # version instead",
            "                d = {'_pypi_ordering': ordering, 'version': p.version,",
            "                     'name': p.pkgname, 'summary': p.version}",
            "                response.append(d)",
            "            ordering += 1",
            "        call_string = xmlrpclib.dumps((response,), 'search',",
            "                                      methodresponse=True)",
            "        return call_string",
            "",
            "",
            "@app.route(\"/simple/\")",
            "@auth(\"list\")",
            "def simpleindex():",
            "    links = sorted(core.get_prefixes(packages()))",
            "    tmpl = \"\"\"\\",
            "    <html>",
            "        <head>",
            "            <title>Simple Index</title>",
            "        </head>",
            "        <body>",
            "            <h1>Simple Index</h1>",
            "            % for p in links:",
            "                 <a href=\"{{p}}/\">{{p}}</a><br>",
            "            % end",
            "        </body>",
            "    </html>",
            "    \"\"\"",
            "    return template(tmpl, links=links)",
            "",
            "",
            "@app.route(\"/simple/:prefix/\")",
            "@auth(\"list\")",
            "def simple(prefix=\"\"):",
            "    # PEP 503: require normalized prefix",
            "    normalized = core.normalize_pkgname(prefix)",
            "    if prefix != normalized:",
            "        return redirect('/simple/{0}/'.format(normalized), 301)",
            "",
            "    files = sorted(core.find_packages(packages(), prefix=prefix),",
            "                   key=lambda x: (x.parsed_version, x.relfn))",
            "    if not files:",
            "        if config.redirect_to_fallback:",
            "            return redirect(\"%s/%s/\" % (config.fallback_url.rstrip(\"/\"), prefix))",
            "        return HTTPError(404, 'Not Found (%s does not exist)\\n\\n' % normalized)",
            "",
            "    fp = request.fullpath",
            "    links = [(os.path.basename(f.relfn),",
            "              urljoin(fp, \"../../packages/%s\" % f.fname_and_hash(config.hash_algo)))",
            "             for f in files]",
            "    tmpl = \"\"\"\\",
            "    <html>",
            "        <head>",
            "            <title>Links for {{prefix}}</title>",
            "        </head>",
            "        <body>",
            "            <h1>Links for {{prefix}}</h1>",
            "            % for file, href in links:",
            "                 <a href=\"{{href}}\">{{file}}</a><br>",
            "            % end",
            "        </body>",
            "    </html>",
            "    \"\"\"",
            "    return template(tmpl, prefix=prefix, links=links)",
            "",
            "",
            "@app.route('/packages/')",
            "@auth(\"list\")",
            "def list_packages():",
            "    fp = request.fullpath",
            "    files = sorted(core.find_packages(packages()),",
            "                   key=lambda x: (os.path.dirname(x.relfn),",
            "                                  x.pkgname,",
            "                                  x.parsed_version))",
            "    links = [(f.relfn_unix, urljoin(fp, f.fname_and_hash(config.hash_algo)))",
            "             for f in files]",
            "    tmpl = \"\"\"\\",
            "    <html>",
            "        <head>",
            "            <title>Index of packages</title>",
            "        </head>",
            "        <body>",
            "            <h1>Index of packages</h1>",
            "            % for file, href in links:",
            "                 <a href=\"{{href}}\">{{file}}</a><br>",
            "            % end",
            "        </body>",
            "    </html>",
            "    \"\"\"",
            "    return template(tmpl, links=links)",
            "",
            "",
            "@app.route('/packages/:filename#.*#')",
            "@auth(\"download\")",
            "def server_static(filename):",
            "    entries = core.find_packages(packages())",
            "    for x in entries:",
            "        f = x.relfn_unix",
            "        if f == filename:",
            "            response = static_file(",
            "                filename, root=x.root, mimetype=mimetypes.guess_type(filename)[0])",
            "            if config.cache_control:",
            "                response.set_header(",
            "                    \"Cache-Control\", \"public, max-age=%s\" % config.cache_control)",
            "            return response",
            "",
            "    return HTTPError(404, 'Not Found (%s does not exist)\\n\\n' % filename)",
            "",
            "",
            "@app.route('/:prefix')",
            "@app.route('/:prefix/')",
            "def bad_url(prefix):",
            "    p = request.fullpath",
            "    if p.endswith(\"/\"):",
            "        p = p[:-1]",
            "    p = p.rsplit('/', 1)[0]",
            "    p += \"/simple/%s/\" % prefix",
            "",
            "    return redirect(p)"
        ],
        "afterPatchFile": [
            "from collections import namedtuple",
            "import logging",
            "import mimetypes",
            "import os",
            "import re",
            "import zipfile",
            "import xml.dom.minidom",
            "",
            "from . import __version__",
            "from . import core",
            "from .bottle import static_file, redirect, request, response, HTTPError, Bottle, template",
            "",
            "try:",
            "    import xmlrpc.client as xmlrpclib # py3",
            "except ImportError:",
            "    import xmlrpclib # py2",
            "",
            "try:",
            "    from io import BytesIO",
            "except ImportError:",
            "    from StringIO import StringIO as BytesIO",
            "",
            "try:  # PY3",
            "    from urllib.parse import urljoin",
            "except ImportError:  # PY2",
            "    from urlparse import urljoin",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "packages = None",
            "config = None",
            "",
            "app = Bottle()",
            "",
            "",
            "class auth(object):",
            "    \"\"\"decorator to apply authentication if specified for the decorated method & action\"\"\"",
            "",
            "    def __init__(self, action):",
            "        self.action = action",
            "",
            "    def __call__(self, method):",
            "",
            "        def protector(*args, **kwargs):",
            "            if self.action in config.authenticated:",
            "                if not request.auth or request.auth[1] is None:",
            "                    raise HTTPError(",
            "                        401, headers={\"WWW-Authenticate\": 'Basic realm=\"pypi\"'}",
            "                    )",
            "                if not config.auther(*request.auth):",
            "                    raise HTTPError(403)",
            "            return method(*args, **kwargs)",
            "",
            "        return protector",
            "",
            "",
            "@app.hook('before_request')",
            "def log_request():",
            "    log.info(config.log_req_frmt, request.environ)",
            "",
            "",
            "@app.hook('after_request')",
            "def log_response():",
            "    log.info(config.log_res_frmt, {  # vars(response))  ## DOES NOT WORK!",
            "        'response': response,",
            "        'status': response.status, 'headers': response.headers,",
            "        'body': response.body, 'cookies': response._cookies,",
            "    })",
            "",
            "",
            "@app.error",
            "def log_error(http_error):",
            "    log.info(config.log_err_frmt, vars(http_error))",
            "",
            "",
            "@app.route(\"/favicon.ico\")",
            "def favicon():",
            "    return HTTPError(404)",
            "",
            "",
            "@app.route('/')",
            "def root():",
            "    fp = request.fullpath",
            "",
            "    try:",
            "        numpkgs = len(list(packages()))",
            "    except:",
            "        numpkgs = 0",
            "",
            "    # Ensure template() does not consider `msg` as filename!",
            "    msg = config.welcome_msg + '\\n'",
            "    return template(msg,",
            "                    URL=request.url,",
            "                    VERSION=__version__,",
            "                    NUMPKGS=numpkgs,",
            "                    PACKAGES=urljoin(fp, \"packages/\"),",
            "                    SIMPLE=urljoin(fp, \"simple/\")",
            "                    )",
            "",
            "_bottle_upload_filename_re = re.compile(r'^[a-z0-9_.!+-]+$', re.I)",
            "",
            "",
            "def is_valid_pkg_filename(fname):",
            "    \"\"\"See https://github.com/pypiserver/pypiserver/issues/102\"\"\"",
            "    return _bottle_upload_filename_re.match(fname) is not None",
            "",
            "",
            "def doc_upload():",
            "    try:",
            "        content = request.files['content']",
            "    except KeyError:",
            "        raise HTTPError(400, \"Missing 'content' file-field!\")",
            "    zip_data = content.file.read()",
            "    try:",
            "        zf = zipfile.ZipFile(BytesIO(zip_data))",
            "        zf.getinfo('index.html')",
            "    except Exception:",
            "        raise HTTPError(400, \"not a zip file\")",
            "",
            "",
            "def remove_pkg():",
            "    name = request.forms.get(\"name\")",
            "    version = request.forms.get(\"version\")",
            "    if not name or not version:",
            "        msg = \"Missing 'name'/'version' fields: name=%s, version=%s\"",
            "        raise HTTPError(400, msg % (name, version))",
            "    found = None",
            "    for pkg in core.find_packages(packages()):",
            "        if pkg.pkgname == name and pkg.version == version:",
            "            found = pkg",
            "            break",
            "    if found is None:",
            "        raise HTTPError(404, \"%s (%s) not found\" % (name, version))",
            "    os.unlink(found.fn)",
            "",
            "",
            "Upload = namedtuple('Upload', 'pkg sig')",
            "",
            "",
            "def file_upload():",
            "    ufiles = Upload._make(",
            "        request.files.get(f, None) for f in ('content', 'gpg_signature'))",
            "    if not ufiles.pkg:",
            "        raise HTTPError(400, \"Missing 'content' file-field!\")",
            "    if (ufiles.sig and",
            "            '%s.asc' % ufiles.pkg.raw_filename != ufiles.sig.raw_filename):",
            "        raise HTTPError(400, \"Unrelated signature %r for package %r!\",",
            "                        ufiles.sig, ufiles.pkg)",
            "",
            "    for uf in ufiles:",
            "        if not uf:",
            "            continue",
            "        if (not is_valid_pkg_filename(uf.raw_filename) or",
            "                core.guess_pkgname_and_version(uf.raw_filename) is None):",
            "            raise HTTPError(400, \"Bad filename: %s\" % uf.raw_filename)",
            "",
            "        if not config.overwrite and core.exists(packages.root, uf.raw_filename):",
            "            log.warn(\"Cannot upload %r since it already exists! \\n\"",
            "                     \"  You may start server with `--overwrite` option. \",",
            "                     uf.raw_filename)",
            "            raise HTTPError(409, \"Package %r already exists!\\n\"",
            "                      \"  You may start server with `--overwrite` option.\",",
            "                      uf.raw_filename)",
            "",
            "        core.store(packages.root, uf.raw_filename, uf.save)",
            "        if request.auth:",
            "            user = request.auth[0]",
            "        else:",
            "            user = 'anon'",
            "        log.info('User %r stored %r.', user, uf.raw_filename)",
            "",
            "",
            "@app.post('/')",
            "@auth(\"update\")",
            "def update():",
            "    try:",
            "        action = request.forms[':action']",
            "    except KeyError:",
            "        raise HTTPError(400, \"Missing ':action' field!\")",
            "",
            "    if action in (\"verify\", \"submit\"):",
            "        log.warning(\"Ignored ':action': %s\", action)",
            "    elif action == \"doc_upload\":",
            "        doc_upload()",
            "    elif action == \"remove_pkg\":",
            "        remove_pkg()",
            "    elif action == \"file_upload\":",
            "        file_upload()",
            "    else:",
            "        raise HTTPError(400, \"Unsupported ':action' field: %s\" % action)",
            "",
            "    return \"\"",
            "",
            "",
            "@app.route(\"/simple\")",
            "@app.route(\"/simple/:prefix\")",
            "@app.route('/packages')",
            "@auth(\"list\")",
            "def pep_503_redirects(prefix=None):",
            "    return redirect(request.fullpath + \"/\", 301)",
            "",
            "",
            "@app.post('/RPC2')",
            "@auth(\"list\")",
            "def handle_rpc():",
            "    \"\"\"Handle pip-style RPC2 search requests\"\"\"",
            "    parser = xml.dom.minidom.parse(request.body)",
            "    methodname = parser.getElementsByTagName(",
            "        \"methodName\")[0].childNodes[0].wholeText.strip()",
            "    log.info(\"Processing RPC2 request for '%s'\", methodname)",
            "    if methodname == 'search':",
            "        value = parser.getElementsByTagName(",
            "            \"string\")[0].childNodes[0].wholeText.strip()",
            "        response = []",
            "        ordering = 0",
            "        for p in packages():",
            "            if p.pkgname.count(value) > 0:",
            "                # We do not presently have any description/summary, returning",
            "                # version instead",
            "                d = {'_pypi_ordering': ordering, 'version': p.version,",
            "                     'name': p.pkgname, 'summary': p.version}",
            "                response.append(d)",
            "            ordering += 1",
            "        call_string = xmlrpclib.dumps((response,), 'search',",
            "                                      methodresponse=True)",
            "        return call_string",
            "",
            "",
            "@app.route(\"/simple/\")",
            "@auth(\"list\")",
            "def simpleindex():",
            "    links = sorted(core.get_prefixes(packages()))",
            "    tmpl = \"\"\"\\",
            "    <html>",
            "        <head>",
            "            <title>Simple Index</title>",
            "        </head>",
            "        <body>",
            "            <h1>Simple Index</h1>",
            "            % for p in links:",
            "                 <a href=\"{{p}}/\">{{p}}</a><br>",
            "            % end",
            "        </body>",
            "    </html>",
            "    \"\"\"",
            "    return template(tmpl, links=links)",
            "",
            "",
            "@app.route(\"/simple/:prefix/\")",
            "@auth(\"list\")",
            "def simple(prefix=\"\"):",
            "    # PEP 503: require normalized prefix",
            "    normalized = core.normalize_pkgname_for_url(prefix)",
            "    if prefix != normalized:",
            "        return redirect('/simple/{0}/'.format(normalized), 301)",
            "",
            "    files = sorted(core.find_packages(packages(), prefix=prefix),",
            "                   key=lambda x: (x.parsed_version, x.relfn))",
            "    if not files:",
            "        if config.redirect_to_fallback:",
            "            return redirect(\"%s/%s/\" % (config.fallback_url.rstrip(\"/\"), prefix))",
            "        return HTTPError(404, 'Not Found (%s does not exist)\\n\\n' % normalized)",
            "",
            "    fp = request.fullpath",
            "    links = [(os.path.basename(f.relfn),",
            "              urljoin(fp, \"../../packages/%s\" % f.fname_and_hash(config.hash_algo)))",
            "             for f in files]",
            "    tmpl = \"\"\"\\",
            "    <html>",
            "        <head>",
            "            <title>Links for {{prefix}}</title>",
            "        </head>",
            "        <body>",
            "            <h1>Links for {{prefix}}</h1>",
            "            % for file, href in links:",
            "                 <a href=\"{{href}}\">{{file}}</a><br>",
            "            % end",
            "        </body>",
            "    </html>",
            "    \"\"\"",
            "    return template(tmpl, prefix=prefix, links=links)",
            "",
            "",
            "@app.route('/packages/')",
            "@auth(\"list\")",
            "def list_packages():",
            "    fp = request.fullpath",
            "    files = sorted(core.find_packages(packages()),",
            "                   key=lambda x: (os.path.dirname(x.relfn),",
            "                                  x.pkgname,",
            "                                  x.parsed_version))",
            "    links = [(f.relfn_unix, urljoin(fp, f.fname_and_hash(config.hash_algo)))",
            "             for f in files]",
            "    tmpl = \"\"\"\\",
            "    <html>",
            "        <head>",
            "            <title>Index of packages</title>",
            "        </head>",
            "        <body>",
            "            <h1>Index of packages</h1>",
            "            % for file, href in links:",
            "                 <a href=\"{{href}}\">{{file}}</a><br>",
            "            % end",
            "        </body>",
            "    </html>",
            "    \"\"\"",
            "    return template(tmpl, links=links)",
            "",
            "",
            "@app.route('/packages/:filename#.*#')",
            "@auth(\"download\")",
            "def server_static(filename):",
            "    entries = core.find_packages(packages())",
            "    for x in entries:",
            "        f = x.relfn_unix",
            "        if f == filename:",
            "            response = static_file(",
            "                filename, root=x.root, mimetype=mimetypes.guess_type(filename)[0])",
            "            if config.cache_control:",
            "                response.set_header(",
            "                    \"Cache-Control\", \"public, max-age=%s\" % config.cache_control)",
            "            return response",
            "",
            "    return HTTPError(404, 'Not Found (%s does not exist)\\n\\n' % filename)",
            "",
            "",
            "@app.route('/:prefix')",
            "@app.route('/:prefix/')",
            "def bad_url(prefix):",
            "    \"\"\"Redirect unknown root URLs to /simple/.\"\"\"",
            "    return redirect(core.get_bad_url_redirect_path(request, prefix))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "253": [
                "simple"
            ],
            "330": [
                "bad_url"
            ],
            "331": [
                "bad_url"
            ],
            "332": [
                "bad_url"
            ],
            "333": [
                "bad_url"
            ],
            "334": [
                "bad_url"
            ],
            "335": [
                "bad_url"
            ],
            "336": [
                "bad_url"
            ],
            "337": []
        },
        "addLocation": []
    },
    "pypiserver/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import re"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import sys"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+try:  # PY3"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    from urllib.parse import quote"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+except ImportError:  # PY2"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+    from urllib import quote"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import pkg_resources"
            },
            "9": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from . import Configuration"
            },
            "11": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "     return re.sub(r\"[-_.]+\", \"-\", name).lower()"
            },
            "12": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 190,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+def normalize_pkgname_for_url(name):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    \"\"\"Perform PEP 503 normalization and ensure the value is safe for URLs.\"\"\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+    return quote(re.sub(r\"[-_.]+\", \"-\", name).lower())"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 196,
                "PatchRowcode": " def is_allowed_path(path_part):"
            },
            "20": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "     p = path_part.replace(\"\\\\\", \"/\")"
            },
            "21": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "     return not (p.startswith(\".\") or \"/.\" in p)"
            },
            "22": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "     save_method(dest_fn, overwrite=True)  # Overwite check earlier."
            },
            "23": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 284,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 285,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+def get_bad_url_redirect_path(request, prefix):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+    \"\"\"Get the path for a bad root url.\"\"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+    p = request.fullpath"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+    if p.endswith(\"/\"):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+        p = p[:-1]"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+    p = p.rsplit('/', 1)[0]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+    prefix = quote(prefix)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+    p += \"/simple/{}/\".format(prefix)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+    return p"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 297,
                "PatchRowcode": " def _digest_file(fpath, hash_algo):"
            },
            "37": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "     \"\"\""
            },
            "38": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "     Reads and digests a file according to specified hashing-algorith."
            }
        },
        "frontPatchFile": [
            "#! /usr/bin/env python",
            "\"\"\"minimal PyPI like server for use with pip/easy_install\"\"\"",
            "",
            "import functools",
            "import hashlib",
            "import io",
            "import itertools",
            "import logging",
            "import mimetypes",
            "import os",
            "import re",
            "import sys",
            "",
            "import pkg_resources",
            "",
            "from . import Configuration",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def configure(**kwds):",
            "    \"\"\"",
            "    :return: a 2-tuple (Configure, package-list)",
            "    \"\"\"",
            "    c = Configuration(**kwds)",
            "    log.info(\"+++Pypiserver invoked with: %s\", c)",
            "",
            "    if c.root is None:",
            "        c. root = os.path.expanduser(\"~/packages\")",
            "    roots = c.root if isinstance(c.root, (list, tuple)) else [c.root]",
            "    roots = [os.path.abspath(r) for r in roots]",
            "    for r in roots:",
            "        try:",
            "            os.listdir(r)",
            "        except OSError:",
            "            err = sys.exc_info()[1]",
            "            msg = \"Error: while trying to list root(%s): %s\"",
            "            sys.exit(msg % (r, err))",
            "",
            "    packages = lambda: itertools.chain(*[listdir(r) for r in roots])",
            "    packages.root = roots[0]",
            "",
            "    if not c.authenticated:",
            "        c.authenticated = []",
            "    if not callable(c.auther):",
            "        if c.password_file and c.password_file != '.':",
            "            from passlib.apache import HtpasswdFile",
            "            htPsswdFile = HtpasswdFile(c.password_file)",
            "        else:",
            "            c.password_file = htPsswdFile = None",
            "        c.auther = functools.partial(auth_by_htpasswd_file, htPsswdFile)",
            "",
            "    # Read welcome-msg from external file,",
            "    #     or failback to the embedded-msg (ie. in standalone mode).",
            "    #",
            "    try:",
            "        if not c.welcome_file:",
            "            c.welcome_file = \"welcome.html\"",
            "            c.welcome_msg = pkg_resources.resource_string(  # @UndefinedVariable",
            "                __name__, \"welcome.html\").decode(\"utf-8\")  # @UndefinedVariable",
            "        else:",
            "            with io.open(c.welcome_file, 'r', encoding='utf-8') as fd:",
            "                c.welcome_msg = fd.read()",
            "    except Exception:",
            "        log.warning(",
            "            \"Could not load welcome-file(%s)!\", c.welcome_file, exc_info=1)",
            "",
            "    if c.fallback_url is None:",
            "        c.fallback_url = \"https://pypi.org/simple\"",
            "",
            "    if c.hash_algo:",
            "        try:",
            "            halgos = hashlib.algorithms_available",
            "        except AttributeError:",
            "            halgos = ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']",
            "",
            "        if c.hash_algo not in halgos:",
            "            sys.exit('Hash-algorithm %s not one of: %s' % (c.hash_algo, halgos))",
            "",
            "    log.info(\"+++Pypiserver started with: %s\", c)",
            "",
            "    return c, packages",
            "",
            "",
            "def auth_by_htpasswd_file(htPsswdFile, username, password):",
            "    \"\"\"The default ``config.auther``.\"\"\"",
            "    if htPsswdFile is not None:",
            "        htPsswdFile.load_if_changed()",
            "        return htPsswdFile.check_password(username, password)",
            "",
            "",
            "mimetypes.add_type(\"application/octet-stream\", \".egg\")",
            "mimetypes.add_type(\"application/octet-stream\", \".whl\")",
            "mimetypes.add_type(\"text/plain\", \".asc\")",
            "",
            "",
            "# ### Next 2 functions adapted from :mod:`distribute.pkg_resources`.",
            "#",
            "component_re = re.compile(r'(\\d+ | [a-z]+ | \\.| -)', re.I | re.VERBOSE)",
            "replace = {'pre': 'c', 'preview': 'c', '-': 'final-', 'rc': 'c', 'dev': '@'}.get",
            "",
            "",
            "def _parse_version_parts(s):",
            "    for part in component_re.split(s):",
            "        part = replace(part, part)",
            "        if part in ['', '.']:",
            "            continue",
            "        if part[:1] in '0123456789':",
            "            yield part.zfill(8)  # pad for numeric comparison",
            "        else:",
            "            yield '*' + part",
            "",
            "    yield '*final'  # ensure that alpha/beta/candidate are before final",
            "",
            "",
            "def parse_version(s):",
            "    parts = []",
            "    for part in _parse_version_parts(s.lower()):",
            "        if part.startswith('*'):",
            "            # remove trailing zeros from each series of numeric parts",
            "            while parts and parts[-1] == '00000000':",
            "                parts.pop()",
            "        parts.append(part)",
            "    return tuple(parts)",
            "#",
            "#### -- End of distribute's code.",
            "",
            "",
            "_archive_suffix_rx = re.compile(",
            "    r\"(\\.zip|\\.tar\\.gz|\\.tgz|\\.tar\\.bz2|-py[23]\\.\\d-.*|\"",
            "    \"\\.win-amd64-py[23]\\.\\d\\..*|\\.win32-py[23]\\.\\d\\..*|\\.egg)$\",",
            "    re.I)",
            "wheel_file_re = re.compile(",
            "    r\"\"\"^(?P<namever>(?P<name>.+?)-(?P<ver>\\d.*?))",
            "    ((-(?P<build>\\d.*?))?-(?P<pyver>.+?)-(?P<abi>.+?)-(?P<plat>.+?)",
            "    \\.whl|\\.dist-info)$\"\"\",",
            "    re.VERBOSE)",
            "_pkgname_re = re.compile(r'-\\d+[a-z_.!+]', re.I)",
            "_pkgname_parts_re = re.compile(",
            "    r\"[\\.\\-](?=cp\\d|py\\d|macosx|linux|sunos|solaris|irix|aix|cygwin|win)\",",
            "    re.I)",
            "",
            "",
            "def _guess_pkgname_and_version_wheel(basename):",
            "    m = wheel_file_re.match(basename)",
            "    if not m:",
            "        return None, None",
            "    name = m.group(\"name\")",
            "    ver = m.group(\"ver\")",
            "    build = m.group(\"build\")",
            "    if build:",
            "        return name, ver + \"-\" + build",
            "    else:",
            "        return name, ver",
            "",
            "",
            "def guess_pkgname_and_version(path):",
            "    path = os.path.basename(path)",
            "    if path.endswith(\".asc\"):",
            "        path = path.rstrip(\".asc\")",
            "    if path.endswith(\".whl\"):",
            "        return _guess_pkgname_and_version_wheel(path)",
            "    if not _archive_suffix_rx.search(path):",
            "        return",
            "    path = _archive_suffix_rx.sub('', path)",
            "    if '-' not in path:",
            "        pkgname, version = path, ''",
            "    elif path.count('-') == 1:",
            "        pkgname, version = path.split('-', 1)",
            "    elif '.' not in path:",
            "        pkgname, version = path.rsplit('-', 1)",
            "    else:",
            "        pkgname = _pkgname_re.split(path)[0]",
            "        ver_spec = path[len(pkgname) + 1:]",
            "        parts = _pkgname_parts_re.split(ver_spec)",
            "        version = parts[0]",
            "    return pkgname, version",
            "",
            "",
            "def normalize_pkgname(name):",
            "    \"\"\"Perform PEP 503 normalization\"\"\"",
            "    return re.sub(r\"[-_.]+\", \"-\", name).lower()",
            "",
            "",
            "def is_allowed_path(path_part):",
            "    p = path_part.replace(\"\\\\\", \"/\")",
            "    return not (p.startswith(\".\") or \"/.\" in p)",
            "",
            "",
            "class PkgFile(object):",
            "",
            "    __slots__ = ['fn', 'root', '_fname_and_hash',",
            "                 'relfn', 'relfn_unix',",
            "                 'pkgname_norm',",
            "                 'pkgname',",
            "                 'version',",
            "                 'parsed_version',",
            "                 'replaces']",
            "",
            "    def __init__(self, pkgname, version, fn=None, root=None, relfn=None, replaces=None):",
            "        self.pkgname = pkgname",
            "        self.pkgname_norm = normalize_pkgname(pkgname)",
            "        self.version = version",
            "        self.parsed_version = parse_version(version)",
            "        self.fn = fn",
            "        self.root = root",
            "        self.relfn = relfn",
            "        self.relfn_unix = None if relfn is None else relfn.replace(\"\\\\\", \"/\")",
            "        self.replaces = replaces",
            "",
            "    def __repr__(self):",
            "        return \"%s(%s)\" % (",
            "            self.__class__.__name__,",
            "            \", \".join([\"%s=%r\" % (k, getattr(self, k))",
            "                                  for k in sorted(self.__slots__)]))",
            "",
            "    def fname_and_hash(self, hash_algo):",
            "        if not hasattr(self, '_fname_and_hash'):",
            "            if hash_algo:",
            "                self._fname_and_hash = '%s#%s=%.32s' % (self.relfn_unix, hash_algo,",
            "                                                        digest_file(self.fn, hash_algo))",
            "            else:",
            "                self._fname_and_hash = self.relfn_unix",
            "        return self._fname_and_hash",
            "",
            "",
            "def _listdir(root):",
            "    root = os.path.abspath(root)",
            "    for dirpath, dirnames, filenames in os.walk(root):",
            "        dirnames[:] = [x for x in dirnames if is_allowed_path(x)]",
            "        for x in filenames:",
            "            fn = os.path.join(root, dirpath, x)",
            "            if not is_allowed_path(x) or not os.path.isfile(fn):",
            "                continue",
            "            res = guess_pkgname_and_version(x)",
            "            if not res:",
            "                # #Seems the current file isn't a proper package",
            "                continue",
            "            pkgname, version = res",
            "            if pkgname:",
            "                yield PkgFile(pkgname=pkgname,",
            "                              version=version,",
            "                              fn=fn, root=root,",
            "                              relfn=fn[len(root) + 1:])",
            "",
            "",
            "def find_packages(pkgs, prefix=\"\"):",
            "    prefix = normalize_pkgname(prefix)",
            "    for x in pkgs:",
            "        if prefix and x.pkgname_norm != prefix:",
            "            continue",
            "        yield x",
            "",
            "",
            "def get_prefixes(pkgs):",
            "    normalized_pkgnames = set()",
            "    for x in pkgs:",
            "        if x.pkgname:",
            "            normalized_pkgnames.add(x.pkgname_norm)",
            "    return normalized_pkgnames",
            "",
            "",
            "def exists(root, filename):",
            "    assert \"/\" not in filename",
            "    dest_fn = os.path.join(root, filename)",
            "    return os.path.exists(dest_fn)",
            "",
            "",
            "def store(root, filename, save_method):",
            "    assert \"/\" not in filename",
            "    dest_fn = os.path.join(root, filename)",
            "    save_method(dest_fn, overwrite=True)  # Overwite check earlier.",
            "",
            "",
            "def _digest_file(fpath, hash_algo):",
            "    \"\"\"",
            "    Reads and digests a file according to specified hashing-algorith.",
            "",
            "    :param str sha256: any algo contained in :mod:`hashlib`",
            "    :return: <hash_algo>=<hex_digest>",
            "",
            "    From http://stackoverflow.com/a/21565932/548792",
            "    \"\"\"",
            "    blocksize = 2**16",
            "    digester = getattr(hashlib, hash_algo)()",
            "    with open(fpath, 'rb') as f:",
            "        for block in iter(lambda: f.read(blocksize), b''):",
            "            digester.update(block)",
            "    return digester.hexdigest()[:32]",
            "",
            "",
            "try:",
            "    from .cache import cache_manager",
            "",
            "    def listdir(root):",
            "        # root must be absolute path",
            "        return cache_manager.listdir(root, _listdir)",
            "",
            "    def digest_file(fpath, hash_algo):",
            "        # fpath must be absolute path",
            "        return cache_manager.digest_file(fpath, hash_algo, _digest_file)",
            "",
            "except ImportError:",
            "    listdir = _listdir",
            "    digest_file = _digest_file"
        ],
        "afterPatchFile": [
            "#! /usr/bin/env python",
            "\"\"\"minimal PyPI like server for use with pip/easy_install\"\"\"",
            "",
            "import functools",
            "import hashlib",
            "import io",
            "import itertools",
            "import logging",
            "import mimetypes",
            "import os",
            "import re",
            "import sys",
            "",
            "try:  # PY3",
            "    from urllib.parse import quote",
            "except ImportError:  # PY2",
            "    from urllib import quote",
            "",
            "import pkg_resources",
            "",
            "from . import Configuration",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def configure(**kwds):",
            "    \"\"\"",
            "    :return: a 2-tuple (Configure, package-list)",
            "    \"\"\"",
            "    c = Configuration(**kwds)",
            "    log.info(\"+++Pypiserver invoked with: %s\", c)",
            "",
            "    if c.root is None:",
            "        c. root = os.path.expanduser(\"~/packages\")",
            "    roots = c.root if isinstance(c.root, (list, tuple)) else [c.root]",
            "    roots = [os.path.abspath(r) for r in roots]",
            "    for r in roots:",
            "        try:",
            "            os.listdir(r)",
            "        except OSError:",
            "            err = sys.exc_info()[1]",
            "            msg = \"Error: while trying to list root(%s): %s\"",
            "            sys.exit(msg % (r, err))",
            "",
            "    packages = lambda: itertools.chain(*[listdir(r) for r in roots])",
            "    packages.root = roots[0]",
            "",
            "    if not c.authenticated:",
            "        c.authenticated = []",
            "    if not callable(c.auther):",
            "        if c.password_file and c.password_file != '.':",
            "            from passlib.apache import HtpasswdFile",
            "            htPsswdFile = HtpasswdFile(c.password_file)",
            "        else:",
            "            c.password_file = htPsswdFile = None",
            "        c.auther = functools.partial(auth_by_htpasswd_file, htPsswdFile)",
            "",
            "    # Read welcome-msg from external file,",
            "    #     or failback to the embedded-msg (ie. in standalone mode).",
            "    #",
            "    try:",
            "        if not c.welcome_file:",
            "            c.welcome_file = \"welcome.html\"",
            "            c.welcome_msg = pkg_resources.resource_string(  # @UndefinedVariable",
            "                __name__, \"welcome.html\").decode(\"utf-8\")  # @UndefinedVariable",
            "        else:",
            "            with io.open(c.welcome_file, 'r', encoding='utf-8') as fd:",
            "                c.welcome_msg = fd.read()",
            "    except Exception:",
            "        log.warning(",
            "            \"Could not load welcome-file(%s)!\", c.welcome_file, exc_info=1)",
            "",
            "    if c.fallback_url is None:",
            "        c.fallback_url = \"https://pypi.org/simple\"",
            "",
            "    if c.hash_algo:",
            "        try:",
            "            halgos = hashlib.algorithms_available",
            "        except AttributeError:",
            "            halgos = ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']",
            "",
            "        if c.hash_algo not in halgos:",
            "            sys.exit('Hash-algorithm %s not one of: %s' % (c.hash_algo, halgos))",
            "",
            "    log.info(\"+++Pypiserver started with: %s\", c)",
            "",
            "    return c, packages",
            "",
            "",
            "def auth_by_htpasswd_file(htPsswdFile, username, password):",
            "    \"\"\"The default ``config.auther``.\"\"\"",
            "    if htPsswdFile is not None:",
            "        htPsswdFile.load_if_changed()",
            "        return htPsswdFile.check_password(username, password)",
            "",
            "",
            "mimetypes.add_type(\"application/octet-stream\", \".egg\")",
            "mimetypes.add_type(\"application/octet-stream\", \".whl\")",
            "mimetypes.add_type(\"text/plain\", \".asc\")",
            "",
            "",
            "# ### Next 2 functions adapted from :mod:`distribute.pkg_resources`.",
            "#",
            "component_re = re.compile(r'(\\d+ | [a-z]+ | \\.| -)', re.I | re.VERBOSE)",
            "replace = {'pre': 'c', 'preview': 'c', '-': 'final-', 'rc': 'c', 'dev': '@'}.get",
            "",
            "",
            "def _parse_version_parts(s):",
            "    for part in component_re.split(s):",
            "        part = replace(part, part)",
            "        if part in ['', '.']:",
            "            continue",
            "        if part[:1] in '0123456789':",
            "            yield part.zfill(8)  # pad for numeric comparison",
            "        else:",
            "            yield '*' + part",
            "",
            "    yield '*final'  # ensure that alpha/beta/candidate are before final",
            "",
            "",
            "def parse_version(s):",
            "    parts = []",
            "    for part in _parse_version_parts(s.lower()):",
            "        if part.startswith('*'):",
            "            # remove trailing zeros from each series of numeric parts",
            "            while parts and parts[-1] == '00000000':",
            "                parts.pop()",
            "        parts.append(part)",
            "    return tuple(parts)",
            "#",
            "#### -- End of distribute's code.",
            "",
            "",
            "_archive_suffix_rx = re.compile(",
            "    r\"(\\.zip|\\.tar\\.gz|\\.tgz|\\.tar\\.bz2|-py[23]\\.\\d-.*|\"",
            "    \"\\.win-amd64-py[23]\\.\\d\\..*|\\.win32-py[23]\\.\\d\\..*|\\.egg)$\",",
            "    re.I)",
            "wheel_file_re = re.compile(",
            "    r\"\"\"^(?P<namever>(?P<name>.+?)-(?P<ver>\\d.*?))",
            "    ((-(?P<build>\\d.*?))?-(?P<pyver>.+?)-(?P<abi>.+?)-(?P<plat>.+?)",
            "    \\.whl|\\.dist-info)$\"\"\",",
            "    re.VERBOSE)",
            "_pkgname_re = re.compile(r'-\\d+[a-z_.!+]', re.I)",
            "_pkgname_parts_re = re.compile(",
            "    r\"[\\.\\-](?=cp\\d|py\\d|macosx|linux|sunos|solaris|irix|aix|cygwin|win)\",",
            "    re.I)",
            "",
            "",
            "def _guess_pkgname_and_version_wheel(basename):",
            "    m = wheel_file_re.match(basename)",
            "    if not m:",
            "        return None, None",
            "    name = m.group(\"name\")",
            "    ver = m.group(\"ver\")",
            "    build = m.group(\"build\")",
            "    if build:",
            "        return name, ver + \"-\" + build",
            "    else:",
            "        return name, ver",
            "",
            "",
            "def guess_pkgname_and_version(path):",
            "    path = os.path.basename(path)",
            "    if path.endswith(\".asc\"):",
            "        path = path.rstrip(\".asc\")",
            "    if path.endswith(\".whl\"):",
            "        return _guess_pkgname_and_version_wheel(path)",
            "    if not _archive_suffix_rx.search(path):",
            "        return",
            "    path = _archive_suffix_rx.sub('', path)",
            "    if '-' not in path:",
            "        pkgname, version = path, ''",
            "    elif path.count('-') == 1:",
            "        pkgname, version = path.split('-', 1)",
            "    elif '.' not in path:",
            "        pkgname, version = path.rsplit('-', 1)",
            "    else:",
            "        pkgname = _pkgname_re.split(path)[0]",
            "        ver_spec = path[len(pkgname) + 1:]",
            "        parts = _pkgname_parts_re.split(ver_spec)",
            "        version = parts[0]",
            "    return pkgname, version",
            "",
            "",
            "def normalize_pkgname(name):",
            "    \"\"\"Perform PEP 503 normalization\"\"\"",
            "    return re.sub(r\"[-_.]+\", \"-\", name).lower()",
            "",
            "",
            "def normalize_pkgname_for_url(name):",
            "    \"\"\"Perform PEP 503 normalization and ensure the value is safe for URLs.\"\"\"",
            "    return quote(re.sub(r\"[-_.]+\", \"-\", name).lower())",
            "",
            "",
            "def is_allowed_path(path_part):",
            "    p = path_part.replace(\"\\\\\", \"/\")",
            "    return not (p.startswith(\".\") or \"/.\" in p)",
            "",
            "",
            "class PkgFile(object):",
            "",
            "    __slots__ = ['fn', 'root', '_fname_and_hash',",
            "                 'relfn', 'relfn_unix',",
            "                 'pkgname_norm',",
            "                 'pkgname',",
            "                 'version',",
            "                 'parsed_version',",
            "                 'replaces']",
            "",
            "    def __init__(self, pkgname, version, fn=None, root=None, relfn=None, replaces=None):",
            "        self.pkgname = pkgname",
            "        self.pkgname_norm = normalize_pkgname(pkgname)",
            "        self.version = version",
            "        self.parsed_version = parse_version(version)",
            "        self.fn = fn",
            "        self.root = root",
            "        self.relfn = relfn",
            "        self.relfn_unix = None if relfn is None else relfn.replace(\"\\\\\", \"/\")",
            "        self.replaces = replaces",
            "",
            "    def __repr__(self):",
            "        return \"%s(%s)\" % (",
            "            self.__class__.__name__,",
            "            \", \".join([\"%s=%r\" % (k, getattr(self, k))",
            "                                  for k in sorted(self.__slots__)]))",
            "",
            "    def fname_and_hash(self, hash_algo):",
            "        if not hasattr(self, '_fname_and_hash'):",
            "            if hash_algo:",
            "                self._fname_and_hash = '%s#%s=%.32s' % (self.relfn_unix, hash_algo,",
            "                                                        digest_file(self.fn, hash_algo))",
            "            else:",
            "                self._fname_and_hash = self.relfn_unix",
            "        return self._fname_and_hash",
            "",
            "",
            "def _listdir(root):",
            "    root = os.path.abspath(root)",
            "    for dirpath, dirnames, filenames in os.walk(root):",
            "        dirnames[:] = [x for x in dirnames if is_allowed_path(x)]",
            "        for x in filenames:",
            "            fn = os.path.join(root, dirpath, x)",
            "            if not is_allowed_path(x) or not os.path.isfile(fn):",
            "                continue",
            "            res = guess_pkgname_and_version(x)",
            "            if not res:",
            "                # #Seems the current file isn't a proper package",
            "                continue",
            "            pkgname, version = res",
            "            if pkgname:",
            "                yield PkgFile(pkgname=pkgname,",
            "                              version=version,",
            "                              fn=fn, root=root,",
            "                              relfn=fn[len(root) + 1:])",
            "",
            "",
            "def find_packages(pkgs, prefix=\"\"):",
            "    prefix = normalize_pkgname(prefix)",
            "    for x in pkgs:",
            "        if prefix and x.pkgname_norm != prefix:",
            "            continue",
            "        yield x",
            "",
            "",
            "def get_prefixes(pkgs):",
            "    normalized_pkgnames = set()",
            "    for x in pkgs:",
            "        if x.pkgname:",
            "            normalized_pkgnames.add(x.pkgname_norm)",
            "    return normalized_pkgnames",
            "",
            "",
            "def exists(root, filename):",
            "    assert \"/\" not in filename",
            "    dest_fn = os.path.join(root, filename)",
            "    return os.path.exists(dest_fn)",
            "",
            "",
            "def store(root, filename, save_method):",
            "    assert \"/\" not in filename",
            "    dest_fn = os.path.join(root, filename)",
            "    save_method(dest_fn, overwrite=True)  # Overwite check earlier.",
            "",
            "",
            "def get_bad_url_redirect_path(request, prefix):",
            "    \"\"\"Get the path for a bad root url.\"\"\"",
            "    p = request.fullpath",
            "    if p.endswith(\"/\"):",
            "        p = p[:-1]",
            "    p = p.rsplit('/', 1)[0]",
            "    prefix = quote(prefix)",
            "    p += \"/simple/{}/\".format(prefix)",
            "    return p",
            "",
            "",
            "def _digest_file(fpath, hash_algo):",
            "    \"\"\"",
            "    Reads and digests a file according to specified hashing-algorith.",
            "",
            "    :param str sha256: any algo contained in :mod:`hashlib`",
            "    :return: <hash_algo>=<hex_digest>",
            "",
            "    From http://stackoverflow.com/a/21565932/548792",
            "    \"\"\"",
            "    blocksize = 2**16",
            "    digester = getattr(hashlib, hash_algo)()",
            "    with open(fpath, 'rb') as f:",
            "        for block in iter(lambda: f.read(blocksize), b''):",
            "            digester.update(block)",
            "    return digester.hexdigest()[:32]",
            "",
            "",
            "try:",
            "    from .cache import cache_manager",
            "",
            "    def listdir(root):",
            "        # root must be absolute path",
            "        return cache_manager.listdir(root, _listdir)",
            "",
            "    def digest_file(fpath, hash_algo):",
            "        # fpath must be absolute path",
            "        return cache_manager.digest_file(fpath, hash_algo, _digest_file)",
            "",
            "except ImportError:",
            "    listdir = _listdir",
            "    digest_file = _digest_file"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    }
}