{
    "litestar/static_files/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+# ruff: noqa: PTH118"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from __future__ import annotations"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from os.path import commonpath"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+import os.path"
            },
            "5": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from pathlib import Path"
            },
            "6": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from typing import TYPE_CHECKING, Literal, Sequence"
            },
            "7": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " __all__ = (\"StaticFiles\",)"
            },
            "10": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "12": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " if TYPE_CHECKING:"
            },
            "13": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     from litestar.types import Receive, Scope, Send"
            },
            "14": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     from litestar.types.composite_types import PathType"
            },
            "15": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             headers: Headers that will be sent with every response."
            },
            "16": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         \"\"\""
            },
            "17": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         self.adapter = FileSystemAdapter(file_system)"
            },
            "18": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.directories = tuple(Path(p).resolve() if resolve_symlinks else Path(p) for p in directories)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        self.directories = tuple("
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            os.path.normpath(Path(p).resolve() if resolve_symlinks else Path(p)) for p in directories"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        )"
            },
            "22": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         self.is_html_mode = is_html_mode"
            },
            "23": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         self.send_as_attachment = send_as_attachment"
            },
            "24": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         self.headers = headers"
            },
            "25": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     ) -> tuple[Path, FileInfo] | tuple[None, None]:"
            },
            "26": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         \"\"\"Return the resolved path and a :class:`stat_result <os.stat_result>`."
            },
            "27": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        .. versionchanged:: 2.8.3"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            Prevent `CVE-2024-32982 <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-32982>`_"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            by ensuring that the resolved path is within the configured directory as part of `advisory"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            GHSA-83pv-qr33-2vcf <https://github.com/advisories/GHSA-83pv-qr33-2vcf>`_."
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         Args:"
            },
            "35": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "             directories: A list of directory paths."
            },
            "36": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "             file_path: A file path to resolve"
            },
            "37": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         for directory in directories:"
            },
            "38": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "             try:"
            },
            "39": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "                 joined_path = Path(directory, file_path)"
            },
            "40": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                file_info = await self.adapter.info(joined_path)"
            },
            "41": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if file_info and commonpath([str(directory), file_info[\"name\"], joined_path]) == str(directory):"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                normalized_file_path = os.path.normpath(joined_path)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                if os.path.commonpath([directory, normalized_file_path]) == str(directory) and ("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                    file_info := await self.adapter.info(joined_path)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                ):"
            },
            "46": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "                     return joined_path, file_info"
            },
            "47": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             except FileNotFoundError:"
            },
            "48": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "                 continue"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from os.path import commonpath",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Literal, Sequence",
            "",
            "from litestar.enums import ScopeType",
            "from litestar.exceptions import MethodNotAllowedException, NotFoundException",
            "from litestar.file_system import FileSystemAdapter",
            "from litestar.response.file import ASGIFileResponse",
            "from litestar.status_codes import HTTP_404_NOT_FOUND",
            "",
            "__all__ = (\"StaticFiles\",)",
            "",
            "",
            "if TYPE_CHECKING:",
            "    from litestar.types import Receive, Scope, Send",
            "    from litestar.types.composite_types import PathType",
            "    from litestar.types.file_types import FileInfo, FileSystemProtocol",
            "",
            "",
            "class StaticFiles:",
            "    \"\"\"ASGI App that handles file sending.\"\"\"",
            "",
            "    __slots__ = (\"is_html_mode\", \"directories\", \"adapter\", \"send_as_attachment\", \"headers\")",
            "",
            "    def __init__(",
            "        self,",
            "        is_html_mode: bool,",
            "        directories: Sequence[PathType],",
            "        file_system: FileSystemProtocol,",
            "        send_as_attachment: bool = False,",
            "        resolve_symlinks: bool = True,",
            "        headers: dict[str, str] | None = None,",
            "    ) -> None:",
            "        \"\"\"Initialize the Application.",
            "",
            "        Args:",
            "            is_html_mode: Flag dictating whether serving html. If true, the default file will be ``index.html``.",
            "            directories: A list of directories to serve files from.",
            "            file_system: The file_system spec to use for serving files.",
            "            send_as_attachment: Whether to send the file with a ``content-disposition`` header of",
            "             ``attachment`` or ``inline``",
            "            resolve_symlinks: Resolve symlinks to the directories",
            "            headers: Headers that will be sent with every response.",
            "        \"\"\"",
            "        self.adapter = FileSystemAdapter(file_system)",
            "        self.directories = tuple(Path(p).resolve() if resolve_symlinks else Path(p) for p in directories)",
            "        self.is_html_mode = is_html_mode",
            "        self.send_as_attachment = send_as_attachment",
            "        self.headers = headers",
            "",
            "    async def get_fs_info(",
            "        self, directories: Sequence[PathType], file_path: PathType",
            "    ) -> tuple[Path, FileInfo] | tuple[None, None]:",
            "        \"\"\"Return the resolved path and a :class:`stat_result <os.stat_result>`.",
            "",
            "        Args:",
            "            directories: A list of directory paths.",
            "            file_path: A file path to resolve",
            "",
            "        Returns:",
            "            A tuple with an optional resolved :class:`Path <anyio.Path>` instance and an optional",
            "            :class:`stat_result <os.stat_result>`.",
            "        \"\"\"",
            "        for directory in directories:",
            "            try:",
            "                joined_path = Path(directory, file_path)",
            "                file_info = await self.adapter.info(joined_path)",
            "                if file_info and commonpath([str(directory), file_info[\"name\"], joined_path]) == str(directory):",
            "                    return joined_path, file_info",
            "            except FileNotFoundError:",
            "                continue",
            "        return None, None",
            "",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        \"\"\"ASGI callable.",
            "",
            "        Args:",
            "            scope: ASGI scope",
            "            receive: ASGI ``receive`` callable",
            "            send: ASGI ``send`` callable",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if scope[\"type\"] != ScopeType.HTTP or scope[\"method\"] not in {\"GET\", \"HEAD\"}:",
            "            raise MethodNotAllowedException()",
            "",
            "        res = await self.handle(path=scope[\"path\"], is_head_response=scope[\"method\"] == \"HEAD\")",
            "        await res(scope=scope, receive=receive, send=send)",
            "",
            "    async def handle(self, path: str, is_head_response: bool) -> ASGIFileResponse:",
            "        split_path = path.split(\"/\")",
            "        filename = split_path[-1]",
            "        joined_path = Path(*split_path)",
            "        resolved_path, fs_info = await self.get_fs_info(directories=self.directories, file_path=joined_path)",
            "        content_disposition_type: Literal[\"inline\", \"attachment\"] = (",
            "            \"attachment\" if self.send_as_attachment else \"inline\"",
            "        )",
            "",
            "        if self.is_html_mode and fs_info and fs_info[\"type\"] == \"directory\":",
            "            filename = \"index.html\"",
            "            resolved_path, fs_info = await self.get_fs_info(",
            "                directories=self.directories,",
            "                file_path=Path(resolved_path or joined_path) / filename,",
            "            )",
            "",
            "        if fs_info and fs_info[\"type\"] == \"file\":",
            "            return ASGIFileResponse(",
            "                file_path=resolved_path or joined_path,",
            "                file_info=fs_info,",
            "                file_system=self.adapter.file_system,",
            "                filename=filename,",
            "                content_disposition_type=content_disposition_type,",
            "                is_head_response=is_head_response,",
            "                headers=self.headers,",
            "            )",
            "",
            "        if self.is_html_mode:",
            "            # for some reason coverage doesn't catch these two lines",
            "            filename = \"404.html\"  # pragma: no cover",
            "            resolved_path, fs_info = await self.get_fs_info(  # pragma: no cover",
            "                directories=self.directories, file_path=filename",
            "            )",
            "",
            "            if fs_info and fs_info[\"type\"] == \"file\":",
            "                return ASGIFileResponse(",
            "                    file_path=resolved_path or joined_path,",
            "                    file_info=fs_info,",
            "                    file_system=self.adapter.file_system,",
            "                    filename=filename,",
            "                    status_code=HTTP_404_NOT_FOUND,",
            "                    content_disposition_type=content_disposition_type,",
            "                    is_head_response=is_head_response,",
            "                    headers=self.headers,",
            "                )",
            "",
            "        raise NotFoundException(",
            "            f\"no file or directory match the path {resolved_path or joined_path} was found\"",
            "        )  # pragma: no cover"
        ],
        "afterPatchFile": [
            "# ruff: noqa: PTH118",
            "from __future__ import annotations",
            "",
            "import os.path",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Literal, Sequence",
            "",
            "from litestar.enums import ScopeType",
            "from litestar.exceptions import MethodNotAllowedException, NotFoundException",
            "from litestar.file_system import FileSystemAdapter",
            "from litestar.response.file import ASGIFileResponse",
            "from litestar.status_codes import HTTP_404_NOT_FOUND",
            "",
            "__all__ = (\"StaticFiles\",)",
            "",
            "if TYPE_CHECKING:",
            "    from litestar.types import Receive, Scope, Send",
            "    from litestar.types.composite_types import PathType",
            "    from litestar.types.file_types import FileInfo, FileSystemProtocol",
            "",
            "",
            "class StaticFiles:",
            "    \"\"\"ASGI App that handles file sending.\"\"\"",
            "",
            "    __slots__ = (\"is_html_mode\", \"directories\", \"adapter\", \"send_as_attachment\", \"headers\")",
            "",
            "    def __init__(",
            "        self,",
            "        is_html_mode: bool,",
            "        directories: Sequence[PathType],",
            "        file_system: FileSystemProtocol,",
            "        send_as_attachment: bool = False,",
            "        resolve_symlinks: bool = True,",
            "        headers: dict[str, str] | None = None,",
            "    ) -> None:",
            "        \"\"\"Initialize the Application.",
            "",
            "        Args:",
            "            is_html_mode: Flag dictating whether serving html. If true, the default file will be ``index.html``.",
            "            directories: A list of directories to serve files from.",
            "            file_system: The file_system spec to use for serving files.",
            "            send_as_attachment: Whether to send the file with a ``content-disposition`` header of",
            "             ``attachment`` or ``inline``",
            "            resolve_symlinks: Resolve symlinks to the directories",
            "            headers: Headers that will be sent with every response.",
            "        \"\"\"",
            "        self.adapter = FileSystemAdapter(file_system)",
            "        self.directories = tuple(",
            "            os.path.normpath(Path(p).resolve() if resolve_symlinks else Path(p)) for p in directories",
            "        )",
            "        self.is_html_mode = is_html_mode",
            "        self.send_as_attachment = send_as_attachment",
            "        self.headers = headers",
            "",
            "    async def get_fs_info(",
            "        self, directories: Sequence[PathType], file_path: PathType",
            "    ) -> tuple[Path, FileInfo] | tuple[None, None]:",
            "        \"\"\"Return the resolved path and a :class:`stat_result <os.stat_result>`.",
            "",
            "        .. versionchanged:: 2.8.3",
            "",
            "            Prevent `CVE-2024-32982 <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-32982>`_",
            "            by ensuring that the resolved path is within the configured directory as part of `advisory",
            "            GHSA-83pv-qr33-2vcf <https://github.com/advisories/GHSA-83pv-qr33-2vcf>`_.",
            "",
            "        Args:",
            "            directories: A list of directory paths.",
            "            file_path: A file path to resolve",
            "",
            "        Returns:",
            "            A tuple with an optional resolved :class:`Path <anyio.Path>` instance and an optional",
            "            :class:`stat_result <os.stat_result>`.",
            "        \"\"\"",
            "        for directory in directories:",
            "            try:",
            "                joined_path = Path(directory, file_path)",
            "                normalized_file_path = os.path.normpath(joined_path)",
            "                if os.path.commonpath([directory, normalized_file_path]) == str(directory) and (",
            "                    file_info := await self.adapter.info(joined_path)",
            "                ):",
            "                    return joined_path, file_info",
            "            except FileNotFoundError:",
            "                continue",
            "        return None, None",
            "",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        \"\"\"ASGI callable.",
            "",
            "        Args:",
            "            scope: ASGI scope",
            "            receive: ASGI ``receive`` callable",
            "            send: ASGI ``send`` callable",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if scope[\"type\"] != ScopeType.HTTP or scope[\"method\"] not in {\"GET\", \"HEAD\"}:",
            "            raise MethodNotAllowedException()",
            "",
            "        res = await self.handle(path=scope[\"path\"], is_head_response=scope[\"method\"] == \"HEAD\")",
            "        await res(scope=scope, receive=receive, send=send)",
            "",
            "    async def handle(self, path: str, is_head_response: bool) -> ASGIFileResponse:",
            "        split_path = path.split(\"/\")",
            "        filename = split_path[-1]",
            "        joined_path = Path(*split_path)",
            "        resolved_path, fs_info = await self.get_fs_info(directories=self.directories, file_path=joined_path)",
            "        content_disposition_type: Literal[\"inline\", \"attachment\"] = (",
            "            \"attachment\" if self.send_as_attachment else \"inline\"",
            "        )",
            "",
            "        if self.is_html_mode and fs_info and fs_info[\"type\"] == \"directory\":",
            "            filename = \"index.html\"",
            "            resolved_path, fs_info = await self.get_fs_info(",
            "                directories=self.directories,",
            "                file_path=Path(resolved_path or joined_path) / filename,",
            "            )",
            "",
            "        if fs_info and fs_info[\"type\"] == \"file\":",
            "            return ASGIFileResponse(",
            "                file_path=resolved_path or joined_path,",
            "                file_info=fs_info,",
            "                file_system=self.adapter.file_system,",
            "                filename=filename,",
            "                content_disposition_type=content_disposition_type,",
            "                is_head_response=is_head_response,",
            "                headers=self.headers,",
            "            )",
            "",
            "        if self.is_html_mode:",
            "            # for some reason coverage doesn't catch these two lines",
            "            filename = \"404.html\"  # pragma: no cover",
            "            resolved_path, fs_info = await self.get_fs_info(  # pragma: no cover",
            "                directories=self.directories, file_path=filename",
            "            )",
            "",
            "            if fs_info and fs_info[\"type\"] == \"file\":",
            "                return ASGIFileResponse(",
            "                    file_path=resolved_path or joined_path,",
            "                    file_info=fs_info,",
            "                    file_system=self.adapter.file_system,",
            "                    filename=filename,",
            "                    status_code=HTTP_404_NOT_FOUND,",
            "                    content_disposition_type=content_disposition_type,",
            "                    is_head_response=is_head_response,",
            "                    headers=self.headers,",
            "                )",
            "",
            "        raise NotFoundException(",
            "            f\"no file or directory match the path {resolved_path or joined_path} was found\"",
            "        )  # pragma: no cover"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "3": [],
            "15": [],
            "48": [
                "StaticFiles",
                "__init__"
            ],
            "69": [
                "StaticFiles"
            ],
            "70": [
                "StaticFiles"
            ]
        },
        "addLocation": []
    }
}