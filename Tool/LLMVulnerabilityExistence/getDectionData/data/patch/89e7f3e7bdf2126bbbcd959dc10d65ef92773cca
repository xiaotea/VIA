{
    "airflow/auth/managers/base_auth_manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     from airflow.www.extensions.init_appbuilder import AirflowAppBuilder"
            },
            "1": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     from airflow.www.security_manager import AirflowSecurityManagerV2"
            },
            "2": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-ResourceMethod = Literal[\"GET\", \"POST\", \"PUT\", \"DELETE\"]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+ResourceMethod = Literal[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"MENU\"]"
            },
            "5": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " class BaseAuthManager(LoggingMixin):"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from abc import abstractmethod",
            "from functools import cached_property",
            "from typing import TYPE_CHECKING, Container, Literal, Sequence",
            "",
            "from sqlalchemy import select",
            "",
            "from airflow.auth.managers.models.resource_details import (",
            "    DagDetails,",
            ")",
            "from airflow.exceptions import AirflowException",
            "from airflow.models import DagModel",
            "from airflow.security.permissions import ACTION_CAN_ACCESS_MENU",
            "from airflow.utils.log.logging_mixin import LoggingMixin",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "",
            "if TYPE_CHECKING:",
            "    from flask import Blueprint",
            "    from flask_appbuilder.menu import MenuItem",
            "    from sqlalchemy.orm import Session",
            "",
            "    from airflow.auth.managers.models.base_user import BaseUser",
            "    from airflow.auth.managers.models.batch_apis import (",
            "        IsAuthorizedConnectionRequest,",
            "        IsAuthorizedDagRequest,",
            "        IsAuthorizedPoolRequest,",
            "        IsAuthorizedVariableRequest,",
            "    )",
            "    from airflow.auth.managers.models.resource_details import (",
            "        AccessView,",
            "        ConfigurationDetails,",
            "        ConnectionDetails,",
            "        DagAccessEntity,",
            "        DatasetDetails,",
            "        PoolDetails,",
            "        VariableDetails,",
            "    )",
            "    from airflow.cli.cli_config import CLICommand",
            "    from airflow.www.extensions.init_appbuilder import AirflowAppBuilder",
            "    from airflow.www.security_manager import AirflowSecurityManagerV2",
            "",
            "ResourceMethod = Literal[\"GET\", \"POST\", \"PUT\", \"DELETE\"]",
            "",
            "",
            "class BaseAuthManager(LoggingMixin):",
            "    \"\"\"",
            "    Class to derive in order to implement concrete auth managers.",
            "",
            "    Auth managers are responsible for any user management related operation such as login, logout, authz, ...",
            "",
            "    :param appbuilder: the flask app builder",
            "    \"\"\"",
            "",
            "    def __init__(self, appbuilder: AirflowAppBuilder) -> None:",
            "        super().__init__()",
            "        self.appbuilder = appbuilder",
            "",
            "    @staticmethod",
            "    def get_cli_commands() -> list[CLICommand]:",
            "        \"\"\"Vends CLI commands to be included in Airflow CLI.",
            "",
            "        Override this method to expose commands via Airflow CLI to manage this auth manager.",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_api_endpoints(self) -> None | Blueprint:",
            "        \"\"\"Return API endpoint(s) definition for the auth manager.\"\"\"",
            "        return None",
            "",
            "    def get_user_name(self) -> str:",
            "        \"\"\"Return the username associated to the user in session.\"\"\"",
            "        user = self.get_user()",
            "        if not user:",
            "            self.log.error(\"Calling 'get_user_name()' but the user is not signed in.\")",
            "            raise AirflowException(\"The user must be signed in.\")",
            "        return user.get_name()",
            "",
            "    def get_user_display_name(self) -> str:",
            "        \"\"\"Return the user's display name associated to the user in session.\"\"\"",
            "        return self.get_user_name()",
            "",
            "    @abstractmethod",
            "    def get_user(self) -> BaseUser | None:",
            "        \"\"\"Return the user associated to the user in session.\"\"\"",
            "",
            "    def get_user_id(self) -> str | None:",
            "        \"\"\"Return the user ID associated to the user in session.\"\"\"",
            "        user = self.get_user()",
            "        if not user:",
            "            self.log.error(\"Calling 'get_user_id()' but the user is not signed in.\")",
            "            raise AirflowException(\"The user must be signed in.\")",
            "        if user_id := user.get_id():",
            "            return str(user_id)",
            "        return None",
            "",
            "    def init(self) -> None:",
            "        \"\"\"",
            "        Run operations when Airflow is initializing.",
            "",
            "        By default, do nothing.",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_logged_in(self) -> bool:",
            "        \"\"\"Return whether the user is logged in.\"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_configuration(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: ConfigurationDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on configuration.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the configuration",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_connection(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: ConnectionDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a connection.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the connection",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_dag(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        access_entity: DagAccessEntity | None = None,",
            "        details: DagDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a DAG.",
            "",
            "        :param method: the method to perform",
            "        :param access_entity: the kind of DAG information the authorization request is about.",
            "            If not provided, the authorization request is about the DAG itself",
            "        :param details: optional details about the DAG",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_dataset(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: DatasetDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a dataset.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the dataset",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_pool(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: PoolDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a pool.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the pool",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_variable(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: VariableDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a variable.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the variable",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_view(",
            "        self,",
            "        *,",
            "        access_view: AccessView,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to access a read-only state of the installation.",
            "",
            "        :param access_view: the specific read-only view/state the authorization request is about.",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    def is_authorized_custom_view(",
            "        self, *, fab_action_name: str, fab_resource_name: str, user: BaseUser | None = None",
            "    ):",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a custom view.",
            "",
            "        A custom view is a view defined as part of the auth manager. This view is then only available when",
            "        the auth manager is used as part of the environment.",
            "",
            "        By default, it throws an exception because auth managers do not define custom views by default.",
            "        If an auth manager defines some custom views, it needs to override this method.",
            "",
            "        :param fab_action_name: the name of the FAB action defined in the view in ``base_permissions``",
            "        :param fab_resource_name: the name of the FAB resource defined in the view in",
            "            ``class_permission_name``",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "        raise AirflowException(f\"The resource `{fab_resource_name}` does not exist in the environment.\")",
            "",
            "    def batch_is_authorized_connection(",
            "        self,",
            "        requests: Sequence[IsAuthorizedConnectionRequest],",
            "    ) -> bool:",
            "        \"\"\"",
            "        Batch version of ``is_authorized_connection``.",
            "",
            "        By default, calls individually the ``is_authorized_connection`` API on each item in the list of",
            "        requests, which can lead to some poor performance. It is recommended to override this method in the auth",
            "        manager implementation to provide a more efficient implementation.",
            "",
            "        :param requests: a list of requests containing the parameters for ``is_authorized_connection``",
            "        \"\"\"",
            "        return all(",
            "            self.is_authorized_connection(method=request[\"method\"], details=request.get(\"details\"))",
            "            for request in requests",
            "        )",
            "",
            "    def batch_is_authorized_dag(",
            "        self,",
            "        requests: Sequence[IsAuthorizedDagRequest],",
            "    ) -> bool:",
            "        \"\"\"",
            "        Batch version of ``is_authorized_dag``.",
            "",
            "        By default, calls individually the ``is_authorized_dag`` API on each item in the list of requests.",
            "        Can lead to some poor performance. It is recommended to override this method in the auth manager",
            "        implementation to provide a more efficient implementation.",
            "",
            "        :param requests: a list of requests containing the parameters for ``is_authorized_dag``",
            "        \"\"\"",
            "        return all(",
            "            self.is_authorized_dag(",
            "                method=request[\"method\"],",
            "                access_entity=request.get(\"access_entity\"),",
            "                details=request.get(\"details\"),",
            "            )",
            "            for request in requests",
            "        )",
            "",
            "    def batch_is_authorized_pool(",
            "        self,",
            "        requests: Sequence[IsAuthorizedPoolRequest],",
            "    ) -> bool:",
            "        \"\"\"",
            "        Batch version of ``is_authorized_pool``.",
            "",
            "        By default, calls individually the ``is_authorized_pool`` API on each item in the list of",
            "        requests. Can lead to some poor performance. It is recommended to override this method in the auth",
            "        manager implementation to provide a more efficient implementation.",
            "",
            "        :param requests: a list of requests containing the parameters for ``is_authorized_pool``",
            "        \"\"\"",
            "        return all(",
            "            self.is_authorized_pool(method=request[\"method\"], details=request.get(\"details\"))",
            "            for request in requests",
            "        )",
            "",
            "    def batch_is_authorized_variable(",
            "        self,",
            "        requests: Sequence[IsAuthorizedVariableRequest],",
            "    ) -> bool:",
            "        \"\"\"",
            "        Batch version of ``is_authorized_variable``.",
            "",
            "        By default, calls individually the ``is_authorized_variable`` API on each item in the list of",
            "        requests. Can lead to some poor performance. It is recommended to override this method in the auth",
            "        manager implementation to provide a more efficient implementation.",
            "",
            "        :param requests: a list of requests containing the parameters for ``is_authorized_variable``",
            "        \"\"\"",
            "        return all(",
            "            self.is_authorized_variable(method=request[\"method\"], details=request.get(\"details\"))",
            "            for request in requests",
            "        )",
            "",
            "    @provide_session",
            "    def get_permitted_dag_ids(",
            "        self,",
            "        *,",
            "        methods: Container[ResourceMethod] | None = None,",
            "        user=None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> set[str]:",
            "        \"\"\"",
            "        Get readable or writable DAGs for user.",
            "",
            "        By default, reads all the DAGs and check individually if the user has permissions to access the DAG.",
            "        Can lead to some poor performance. It is recommended to override this method in the auth manager",
            "        implementation to provide a more efficient implementation.",
            "        \"\"\"",
            "        if not methods:",
            "            methods = [\"PUT\", \"GET\"]",
            "",
            "        dag_ids = {dag.dag_id for dag in session.execute(select(DagModel.dag_id))}",
            "",
            "        if (\"GET\" in methods and self.is_authorized_dag(method=\"GET\", user=user)) or (",
            "            \"PUT\" in methods and self.is_authorized_dag(method=\"PUT\", user=user)",
            "        ):",
            "            # If user is authorized to read/edit all DAGs, return all DAGs",
            "            return dag_ids",
            "",
            "        def _is_permitted_dag_id(method: ResourceMethod, methods: Container[ResourceMethod], dag_id: str):",
            "            return method in methods and self.is_authorized_dag(",
            "                method=method, details=DagDetails(id=dag_id), user=user",
            "            )",
            "",
            "        return {",
            "            dag_id",
            "            for dag_id in dag_ids",
            "            if _is_permitted_dag_id(\"GET\", methods, dag_id) or _is_permitted_dag_id(\"PUT\", methods, dag_id)",
            "        }",
            "",
            "    def filter_permitted_menu_items(self, menu_items: list[MenuItem]) -> list[MenuItem]:",
            "        \"\"\"",
            "        Filter menu items based on user permissions.",
            "",
            "        :param menu_items: list of all menu items",
            "        \"\"\"",
            "        items = filter(",
            "            lambda item: self.security_manager.has_access(ACTION_CAN_ACCESS_MENU, item.name), menu_items",
            "        )",
            "        accessible_items = []",
            "        for menu_item in items:",
            "            if menu_item.childs:",
            "                accessible_children = []",
            "                for child in menu_item.childs:",
            "                    if self.security_manager.has_access(ACTION_CAN_ACCESS_MENU, child.name):",
            "                        accessible_children.append(child)",
            "                menu_item.childs = accessible_children",
            "            accessible_items.append(menu_item)",
            "        return accessible_items",
            "",
            "    @abstractmethod",
            "    def get_url_login(self, **kwargs) -> str:",
            "        \"\"\"Return the login page url.\"\"\"",
            "",
            "    @abstractmethod",
            "    def get_url_logout(self) -> str:",
            "        \"\"\"Return the logout page url.\"\"\"",
            "",
            "    def get_url_user_profile(self) -> str | None:",
            "        \"\"\"",
            "        Return the url to a page displaying info about the current user.",
            "",
            "        By default, return None.",
            "        \"\"\"",
            "        return None",
            "",
            "    @cached_property",
            "    def security_manager(self) -> AirflowSecurityManagerV2:",
            "        \"\"\"",
            "        Return the security manager.",
            "",
            "        By default, Airflow comes with the default security manager",
            "        ``airflow.www.security_manager.AirflowSecurityManagerV2``. The auth manager might need to extend this",
            "        default security manager for its own purposes.",
            "",
            "        By default, return the default AirflowSecurityManagerV2.",
            "        \"\"\"",
            "        from airflow.www.security_manager import AirflowSecurityManagerV2",
            "",
            "        return AirflowSecurityManagerV2(self.appbuilder)"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from abc import abstractmethod",
            "from functools import cached_property",
            "from typing import TYPE_CHECKING, Container, Literal, Sequence",
            "",
            "from sqlalchemy import select",
            "",
            "from airflow.auth.managers.models.resource_details import (",
            "    DagDetails,",
            ")",
            "from airflow.exceptions import AirflowException",
            "from airflow.models import DagModel",
            "from airflow.security.permissions import ACTION_CAN_ACCESS_MENU",
            "from airflow.utils.log.logging_mixin import LoggingMixin",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "",
            "if TYPE_CHECKING:",
            "    from flask import Blueprint",
            "    from flask_appbuilder.menu import MenuItem",
            "    from sqlalchemy.orm import Session",
            "",
            "    from airflow.auth.managers.models.base_user import BaseUser",
            "    from airflow.auth.managers.models.batch_apis import (",
            "        IsAuthorizedConnectionRequest,",
            "        IsAuthorizedDagRequest,",
            "        IsAuthorizedPoolRequest,",
            "        IsAuthorizedVariableRequest,",
            "    )",
            "    from airflow.auth.managers.models.resource_details import (",
            "        AccessView,",
            "        ConfigurationDetails,",
            "        ConnectionDetails,",
            "        DagAccessEntity,",
            "        DatasetDetails,",
            "        PoolDetails,",
            "        VariableDetails,",
            "    )",
            "    from airflow.cli.cli_config import CLICommand",
            "    from airflow.www.extensions.init_appbuilder import AirflowAppBuilder",
            "    from airflow.www.security_manager import AirflowSecurityManagerV2",
            "",
            "ResourceMethod = Literal[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"MENU\"]",
            "",
            "",
            "class BaseAuthManager(LoggingMixin):",
            "    \"\"\"",
            "    Class to derive in order to implement concrete auth managers.",
            "",
            "    Auth managers are responsible for any user management related operation such as login, logout, authz, ...",
            "",
            "    :param appbuilder: the flask app builder",
            "    \"\"\"",
            "",
            "    def __init__(self, appbuilder: AirflowAppBuilder) -> None:",
            "        super().__init__()",
            "        self.appbuilder = appbuilder",
            "",
            "    @staticmethod",
            "    def get_cli_commands() -> list[CLICommand]:",
            "        \"\"\"Vends CLI commands to be included in Airflow CLI.",
            "",
            "        Override this method to expose commands via Airflow CLI to manage this auth manager.",
            "        \"\"\"",
            "        return []",
            "",
            "    def get_api_endpoints(self) -> None | Blueprint:",
            "        \"\"\"Return API endpoint(s) definition for the auth manager.\"\"\"",
            "        return None",
            "",
            "    def get_user_name(self) -> str:",
            "        \"\"\"Return the username associated to the user in session.\"\"\"",
            "        user = self.get_user()",
            "        if not user:",
            "            self.log.error(\"Calling 'get_user_name()' but the user is not signed in.\")",
            "            raise AirflowException(\"The user must be signed in.\")",
            "        return user.get_name()",
            "",
            "    def get_user_display_name(self) -> str:",
            "        \"\"\"Return the user's display name associated to the user in session.\"\"\"",
            "        return self.get_user_name()",
            "",
            "    @abstractmethod",
            "    def get_user(self) -> BaseUser | None:",
            "        \"\"\"Return the user associated to the user in session.\"\"\"",
            "",
            "    def get_user_id(self) -> str | None:",
            "        \"\"\"Return the user ID associated to the user in session.\"\"\"",
            "        user = self.get_user()",
            "        if not user:",
            "            self.log.error(\"Calling 'get_user_id()' but the user is not signed in.\")",
            "            raise AirflowException(\"The user must be signed in.\")",
            "        if user_id := user.get_id():",
            "            return str(user_id)",
            "        return None",
            "",
            "    def init(self) -> None:",
            "        \"\"\"",
            "        Run operations when Airflow is initializing.",
            "",
            "        By default, do nothing.",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_logged_in(self) -> bool:",
            "        \"\"\"Return whether the user is logged in.\"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_configuration(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: ConfigurationDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on configuration.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the configuration",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_connection(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: ConnectionDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a connection.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the connection",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_dag(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        access_entity: DagAccessEntity | None = None,",
            "        details: DagDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a DAG.",
            "",
            "        :param method: the method to perform",
            "        :param access_entity: the kind of DAG information the authorization request is about.",
            "            If not provided, the authorization request is about the DAG itself",
            "        :param details: optional details about the DAG",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_dataset(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: DatasetDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a dataset.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the dataset",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_pool(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: PoolDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a pool.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the pool",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_variable(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: VariableDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a variable.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the variable",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    @abstractmethod",
            "    def is_authorized_view(",
            "        self,",
            "        *,",
            "        access_view: AccessView,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to access a read-only state of the installation.",
            "",
            "        :param access_view: the specific read-only view/state the authorization request is about.",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "",
            "    def is_authorized_custom_view(",
            "        self, *, fab_action_name: str, fab_resource_name: str, user: BaseUser | None = None",
            "    ):",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a custom view.",
            "",
            "        A custom view is a view defined as part of the auth manager. This view is then only available when",
            "        the auth manager is used as part of the environment.",
            "",
            "        By default, it throws an exception because auth managers do not define custom views by default.",
            "        If an auth manager defines some custom views, it needs to override this method.",
            "",
            "        :param fab_action_name: the name of the FAB action defined in the view in ``base_permissions``",
            "        :param fab_resource_name: the name of the FAB resource defined in the view in",
            "            ``class_permission_name``",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "        \"\"\"",
            "        raise AirflowException(f\"The resource `{fab_resource_name}` does not exist in the environment.\")",
            "",
            "    def batch_is_authorized_connection(",
            "        self,",
            "        requests: Sequence[IsAuthorizedConnectionRequest],",
            "    ) -> bool:",
            "        \"\"\"",
            "        Batch version of ``is_authorized_connection``.",
            "",
            "        By default, calls individually the ``is_authorized_connection`` API on each item in the list of",
            "        requests, which can lead to some poor performance. It is recommended to override this method in the auth",
            "        manager implementation to provide a more efficient implementation.",
            "",
            "        :param requests: a list of requests containing the parameters for ``is_authorized_connection``",
            "        \"\"\"",
            "        return all(",
            "            self.is_authorized_connection(method=request[\"method\"], details=request.get(\"details\"))",
            "            for request in requests",
            "        )",
            "",
            "    def batch_is_authorized_dag(",
            "        self,",
            "        requests: Sequence[IsAuthorizedDagRequest],",
            "    ) -> bool:",
            "        \"\"\"",
            "        Batch version of ``is_authorized_dag``.",
            "",
            "        By default, calls individually the ``is_authorized_dag`` API on each item in the list of requests.",
            "        Can lead to some poor performance. It is recommended to override this method in the auth manager",
            "        implementation to provide a more efficient implementation.",
            "",
            "        :param requests: a list of requests containing the parameters for ``is_authorized_dag``",
            "        \"\"\"",
            "        return all(",
            "            self.is_authorized_dag(",
            "                method=request[\"method\"],",
            "                access_entity=request.get(\"access_entity\"),",
            "                details=request.get(\"details\"),",
            "            )",
            "            for request in requests",
            "        )",
            "",
            "    def batch_is_authorized_pool(",
            "        self,",
            "        requests: Sequence[IsAuthorizedPoolRequest],",
            "    ) -> bool:",
            "        \"\"\"",
            "        Batch version of ``is_authorized_pool``.",
            "",
            "        By default, calls individually the ``is_authorized_pool`` API on each item in the list of",
            "        requests. Can lead to some poor performance. It is recommended to override this method in the auth",
            "        manager implementation to provide a more efficient implementation.",
            "",
            "        :param requests: a list of requests containing the parameters for ``is_authorized_pool``",
            "        \"\"\"",
            "        return all(",
            "            self.is_authorized_pool(method=request[\"method\"], details=request.get(\"details\"))",
            "            for request in requests",
            "        )",
            "",
            "    def batch_is_authorized_variable(",
            "        self,",
            "        requests: Sequence[IsAuthorizedVariableRequest],",
            "    ) -> bool:",
            "        \"\"\"",
            "        Batch version of ``is_authorized_variable``.",
            "",
            "        By default, calls individually the ``is_authorized_variable`` API on each item in the list of",
            "        requests. Can lead to some poor performance. It is recommended to override this method in the auth",
            "        manager implementation to provide a more efficient implementation.",
            "",
            "        :param requests: a list of requests containing the parameters for ``is_authorized_variable``",
            "        \"\"\"",
            "        return all(",
            "            self.is_authorized_variable(method=request[\"method\"], details=request.get(\"details\"))",
            "            for request in requests",
            "        )",
            "",
            "    @provide_session",
            "    def get_permitted_dag_ids(",
            "        self,",
            "        *,",
            "        methods: Container[ResourceMethod] | None = None,",
            "        user=None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> set[str]:",
            "        \"\"\"",
            "        Get readable or writable DAGs for user.",
            "",
            "        By default, reads all the DAGs and check individually if the user has permissions to access the DAG.",
            "        Can lead to some poor performance. It is recommended to override this method in the auth manager",
            "        implementation to provide a more efficient implementation.",
            "        \"\"\"",
            "        if not methods:",
            "            methods = [\"PUT\", \"GET\"]",
            "",
            "        dag_ids = {dag.dag_id for dag in session.execute(select(DagModel.dag_id))}",
            "",
            "        if (\"GET\" in methods and self.is_authorized_dag(method=\"GET\", user=user)) or (",
            "            \"PUT\" in methods and self.is_authorized_dag(method=\"PUT\", user=user)",
            "        ):",
            "            # If user is authorized to read/edit all DAGs, return all DAGs",
            "            return dag_ids",
            "",
            "        def _is_permitted_dag_id(method: ResourceMethod, methods: Container[ResourceMethod], dag_id: str):",
            "            return method in methods and self.is_authorized_dag(",
            "                method=method, details=DagDetails(id=dag_id), user=user",
            "            )",
            "",
            "        return {",
            "            dag_id",
            "            for dag_id in dag_ids",
            "            if _is_permitted_dag_id(\"GET\", methods, dag_id) or _is_permitted_dag_id(\"PUT\", methods, dag_id)",
            "        }",
            "",
            "    def filter_permitted_menu_items(self, menu_items: list[MenuItem]) -> list[MenuItem]:",
            "        \"\"\"",
            "        Filter menu items based on user permissions.",
            "",
            "        :param menu_items: list of all menu items",
            "        \"\"\"",
            "        items = filter(",
            "            lambda item: self.security_manager.has_access(ACTION_CAN_ACCESS_MENU, item.name), menu_items",
            "        )",
            "        accessible_items = []",
            "        for menu_item in items:",
            "            if menu_item.childs:",
            "                accessible_children = []",
            "                for child in menu_item.childs:",
            "                    if self.security_manager.has_access(ACTION_CAN_ACCESS_MENU, child.name):",
            "                        accessible_children.append(child)",
            "                menu_item.childs = accessible_children",
            "            accessible_items.append(menu_item)",
            "        return accessible_items",
            "",
            "    @abstractmethod",
            "    def get_url_login(self, **kwargs) -> str:",
            "        \"\"\"Return the login page url.\"\"\"",
            "",
            "    @abstractmethod",
            "    def get_url_logout(self) -> str:",
            "        \"\"\"Return the logout page url.\"\"\"",
            "",
            "    def get_url_user_profile(self) -> str | None:",
            "        \"\"\"",
            "        Return the url to a page displaying info about the current user.",
            "",
            "        By default, return None.",
            "        \"\"\"",
            "        return None",
            "",
            "    @cached_property",
            "    def security_manager(self) -> AirflowSecurityManagerV2:",
            "        \"\"\"",
            "        Return the security manager.",
            "",
            "        By default, Airflow comes with the default security manager",
            "        ``airflow.www.security_manager.AirflowSecurityManagerV2``. The auth manager might need to extend this",
            "        default security manager for its own purposes.",
            "",
            "        By default, return the default AirflowSecurityManagerV2.",
            "        \"\"\"",
            "        from airflow.www.security_manager import AirflowSecurityManagerV2",
            "",
            "        return AirflowSecurityManagerV2(self.appbuilder)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "60": [
                "ResourceMethod"
            ]
        },
        "addLocation": []
    },
    "airflow/auth/managers/utils/fab.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     \"GET\": ACTION_CAN_READ,"
            },
            "1": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     \"PUT\": ACTION_CAN_EDIT,"
            },
            "2": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     \"DELETE\": ACTION_CAN_DELETE,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    \"MENU\": ACTION_CAN_ACCESS_MENU,"
            },
            "4": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " }"
            },
            "5": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     \"\"\"Return the map associating a FAB action to a method.\"\"\""
            },
            "8": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     return {"
            },
            "9": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         **{v: k for k, v in _MAP_METHOD_NAME_TO_FAB_ACTION_NAME.items()},"
            },
            "10": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ACTION_CAN_ACCESS_MENU: \"GET\","
            },
            "11": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     }"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from typing import TYPE_CHECKING",
            "",
            "from airflow.security.permissions import (",
            "    ACTION_CAN_ACCESS_MENU,",
            "    ACTION_CAN_CREATE,",
            "    ACTION_CAN_DELETE,",
            "    ACTION_CAN_EDIT,",
            "    ACTION_CAN_READ,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from airflow.auth.managers.base_auth_manager import ResourceMethod",
            "",
            "# Convert methods to FAB action name",
            "_MAP_METHOD_NAME_TO_FAB_ACTION_NAME: dict[ResourceMethod, str] = {",
            "    \"POST\": ACTION_CAN_CREATE,",
            "    \"GET\": ACTION_CAN_READ,",
            "    \"PUT\": ACTION_CAN_EDIT,",
            "    \"DELETE\": ACTION_CAN_DELETE,",
            "}",
            "",
            "",
            "def get_fab_action_from_method_map():",
            "    \"\"\"Return the map associating a method to a FAB action.\"\"\"",
            "    return _MAP_METHOD_NAME_TO_FAB_ACTION_NAME",
            "",
            "",
            "def get_method_from_fab_action_map():",
            "    \"\"\"Return the map associating a FAB action to a method.\"\"\"",
            "    return {",
            "        **{v: k for k, v in _MAP_METHOD_NAME_TO_FAB_ACTION_NAME.items()},",
            "        ACTION_CAN_ACCESS_MENU: \"GET\",",
            "    }"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from typing import TYPE_CHECKING",
            "",
            "from airflow.security.permissions import (",
            "    ACTION_CAN_ACCESS_MENU,",
            "    ACTION_CAN_CREATE,",
            "    ACTION_CAN_DELETE,",
            "    ACTION_CAN_EDIT,",
            "    ACTION_CAN_READ,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from airflow.auth.managers.base_auth_manager import ResourceMethod",
            "",
            "# Convert methods to FAB action name",
            "_MAP_METHOD_NAME_TO_FAB_ACTION_NAME: dict[ResourceMethod, str] = {",
            "    \"POST\": ACTION_CAN_CREATE,",
            "    \"GET\": ACTION_CAN_READ,",
            "    \"PUT\": ACTION_CAN_EDIT,",
            "    \"DELETE\": ACTION_CAN_DELETE,",
            "    \"MENU\": ACTION_CAN_ACCESS_MENU,",
            "}",
            "",
            "",
            "def get_fab_action_from_method_map():",
            "    \"\"\"Return the map associating a method to a FAB action.\"\"\"",
            "    return _MAP_METHOD_NAME_TO_FAB_ACTION_NAME",
            "",
            "",
            "def get_method_from_fab_action_map():",
            "    \"\"\"Return the map associating a FAB action to a method.\"\"\"",
            "    return {",
            "        **{v: k for k, v in _MAP_METHOD_NAME_TO_FAB_ACTION_NAME.items()},",
            "    }"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "51": [
                "get_method_from_fab_action_map"
            ]
        },
        "addLocation": []
    },
    "airflow/providers/fab/auth_manager/fab_auth_manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " from airflow.providers.fab.auth_manager.models import Permission, Role, User"
            },
            "1": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " from airflow.security import permissions"
            },
            "2": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " from airflow.security.permissions import ("
            },
            "3": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ACTION_CAN_ACCESS_MENU,"
            },
            "4": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ACTION_CAN_READ,"
            },
            "5": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     RESOURCE_AUDIT_LOG,"
            },
            "6": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     RESOURCE_CLUSTER_ACTIVITY,"
            },
            "7": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     RESOURCE_CONFIG,"
            },
            "8": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "         return self._is_authorized(method=method, resource_type=RESOURCE_VARIABLE, user=user)"
            },
            "9": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 262,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "     def is_authorized_view(self, *, access_view: AccessView, user: BaseUser | None = None) -> bool:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+        # \"Docs\" are only links in the menu, there is no page associated"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        method: ResourceMethod = \"MENU\" if access_view == AccessView.DOCS else \"GET\""
            },
            "13": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "         return self._is_authorized("
            },
            "14": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            method=\"GET\", resource_type=_MAP_ACCESS_VIEW_TO_FAB_RESOURCE_TYPE[access_view], user=user"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+            method=method, resource_type=_MAP_ACCESS_VIEW_TO_FAB_RESOURCE_TYPE[access_view], user=user"
            },
            "16": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "         )"
            },
            "17": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 269,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "     def is_authorized_custom_view("
            },
            "19": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "         \"\"\""
            },
            "20": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": 464,
                "PatchRowcode": "         Return the user permissions."
            },
            "21": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": 465,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ACTION_CAN_READ and ACTION_CAN_ACCESS_MENU are merged into because they are very similar."
            },
            "23": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        We can assume that if a user has permissions to read variables, they also have permissions to access"
            },
            "24": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        the menu \"Variables\"."
            },
            "25": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "         :param user: the user to get permissions for"
            },
            "27": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 467,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "         :meta private:"
            },
            "29": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "         \"\"\""
            },
            "30": {
                "beforePatchRowNumber": 474,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        perms = getattr(user, \"perms\") or []"
            },
            "31": {
                "beforePatchRowNumber": 475,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return ["
            },
            "32": {
                "beforePatchRowNumber": 476,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            (ACTION_CAN_READ if perm[0] == ACTION_CAN_ACCESS_MENU else perm[0], perm[1]) for perm in perms"
            },
            "33": {
                "beforePatchRowNumber": 477,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ]"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+        return getattr(user, \"perms\") or []"
            },
            "35": {
                "beforePatchRowNumber": 478,
                "afterPatchRowNumber": 471,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 479,
                "afterPatchRowNumber": 472,
                "PatchRowcode": "     def _get_root_dag_id(self, dag_id: str) -> str:"
            },
            "37": {
                "beforePatchRowNumber": 480,
                "afterPatchRowNumber": 473,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import argparse",
            "from functools import cached_property",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Container",
            "",
            "from connexion import FlaskApi",
            "from flask import Blueprint, url_for",
            "from sqlalchemy import select",
            "from sqlalchemy.orm import Session, joinedload",
            "",
            "from airflow.auth.managers.base_auth_manager import BaseAuthManager, ResourceMethod",
            "from airflow.auth.managers.models.resource_details import (",
            "    AccessView,",
            "    ConfigurationDetails,",
            "    ConnectionDetails,",
            "    DagAccessEntity,",
            "    DagDetails,",
            "    DatasetDetails,",
            "    PoolDetails,",
            "    VariableDetails,",
            ")",
            "from airflow.auth.managers.utils.fab import get_fab_action_from_method_map, get_method_from_fab_action_map",
            "from airflow.cli.cli_config import (",
            "    DefaultHelpParser,",
            "    GroupCommand,",
            ")",
            "from airflow.configuration import conf",
            "from airflow.exceptions import AirflowException",
            "from airflow.models import DagModel",
            "from airflow.providers.fab.auth_manager.cli_commands.definition import (",
            "    ROLES_COMMANDS,",
            "    SYNC_PERM_COMMAND,",
            "    USERS_COMMANDS,",
            ")",
            "from airflow.providers.fab.auth_manager.models import Permission, Role, User",
            "from airflow.security import permissions",
            "from airflow.security.permissions import (",
            "    ACTION_CAN_ACCESS_MENU,",
            "    ACTION_CAN_READ,",
            "    RESOURCE_AUDIT_LOG,",
            "    RESOURCE_CLUSTER_ACTIVITY,",
            "    RESOURCE_CONFIG,",
            "    RESOURCE_CONNECTION,",
            "    RESOURCE_DAG,",
            "    RESOURCE_DAG_CODE,",
            "    RESOURCE_DAG_DEPENDENCIES,",
            "    RESOURCE_DAG_PREFIX,",
            "    RESOURCE_DAG_RUN,",
            "    RESOURCE_DAG_WARNING,",
            "    RESOURCE_DATASET,",
            "    RESOURCE_DOCS,",
            "    RESOURCE_IMPORT_ERROR,",
            "    RESOURCE_JOB,",
            "    RESOURCE_PLUGIN,",
            "    RESOURCE_POOL,",
            "    RESOURCE_PROVIDER,",
            "    RESOURCE_SLA_MISS,",
            "    RESOURCE_TASK_INSTANCE,",
            "    RESOURCE_TASK_LOG,",
            "    RESOURCE_TASK_RESCHEDULE,",
            "    RESOURCE_TRIGGER,",
            "    RESOURCE_VARIABLE,",
            "    RESOURCE_WEBSITE,",
            "    RESOURCE_XCOM,",
            ")",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.utils.yaml import safe_load",
            "from airflow.www.constants import SWAGGER_BUNDLE, SWAGGER_ENABLED",
            "from airflow.www.extensions.init_views import _CustomErrorRequestBodyValidator, _LazyResolver",
            "",
            "if TYPE_CHECKING:",
            "    from airflow.auth.managers.models.base_user import BaseUser",
            "    from airflow.cli.cli_config import (",
            "        CLICommand,",
            "    )",
            "    from airflow.providers.fab.auth_manager.security_manager.override import FabAirflowSecurityManagerOverride",
            "",
            "_MAP_DAG_ACCESS_ENTITY_TO_FAB_RESOURCE_TYPE: dict[DagAccessEntity, tuple[str, ...]] = {",
            "    DagAccessEntity.AUDIT_LOG: (RESOURCE_AUDIT_LOG,),",
            "    DagAccessEntity.CODE: (RESOURCE_DAG_CODE,),",
            "    DagAccessEntity.DEPENDENCIES: (RESOURCE_DAG_DEPENDENCIES,),",
            "    DagAccessEntity.RUN: (RESOURCE_DAG_RUN,),",
            "    DagAccessEntity.SLA_MISS: (RESOURCE_SLA_MISS,),",
            "    # RESOURCE_TASK_INSTANCE has been originally misused. RESOURCE_TASK_INSTANCE referred to task definition",
            "    # AND task instances without making the difference",
            "    # To be backward compatible, we translate DagAccessEntity.TASK_INSTANCE to RESOURCE_TASK_INSTANCE AND",
            "    # RESOURCE_DAG_RUN",
            "    # See https://github.com/apache/airflow/pull/34317#discussion_r1355917769",
            "    DagAccessEntity.TASK: (RESOURCE_TASK_INSTANCE,),",
            "    DagAccessEntity.TASK_INSTANCE: (RESOURCE_DAG_RUN, RESOURCE_TASK_INSTANCE),",
            "    DagAccessEntity.TASK_LOGS: (RESOURCE_TASK_LOG,),",
            "    DagAccessEntity.TASK_RESCHEDULE: (RESOURCE_TASK_RESCHEDULE,),",
            "    DagAccessEntity.WARNING: (RESOURCE_DAG_WARNING,),",
            "    DagAccessEntity.XCOM: (RESOURCE_XCOM,),",
            "}",
            "",
            "_MAP_ACCESS_VIEW_TO_FAB_RESOURCE_TYPE = {",
            "    AccessView.CLUSTER_ACTIVITY: RESOURCE_CLUSTER_ACTIVITY,",
            "    AccessView.DOCS: RESOURCE_DOCS,",
            "    AccessView.IMPORT_ERRORS: RESOURCE_IMPORT_ERROR,",
            "    AccessView.JOBS: RESOURCE_JOB,",
            "    AccessView.PLUGINS: RESOURCE_PLUGIN,",
            "    AccessView.PROVIDERS: RESOURCE_PROVIDER,",
            "    AccessView.TRIGGERS: RESOURCE_TRIGGER,",
            "    AccessView.WEBSITE: RESOURCE_WEBSITE,",
            "}",
            "",
            "",
            "class FabAuthManager(BaseAuthManager):",
            "    \"\"\"",
            "    Flask-AppBuilder auth manager.",
            "",
            "    This auth manager is responsible for providing a backward compatible user management experience to users.",
            "    \"\"\"",
            "",
            "    @staticmethod",
            "    def get_cli_commands() -> list[CLICommand]:",
            "        \"\"\"Vends CLI commands to be included in Airflow CLI.\"\"\"",
            "        return [",
            "            GroupCommand(",
            "                name=\"users\",",
            "                help=\"Manage users\",",
            "                subcommands=USERS_COMMANDS,",
            "            ),",
            "            GroupCommand(",
            "                name=\"roles\",",
            "                help=\"Manage roles\",",
            "                subcommands=ROLES_COMMANDS,",
            "            ),",
            "            SYNC_PERM_COMMAND,  # not in a command group",
            "        ]",
            "",
            "    def get_api_endpoints(self) -> None | Blueprint:",
            "        folder = Path(__file__).parents[0].resolve()  # this is airflow/auth/managers/fab/",
            "        with folder.joinpath(\"openapi\", \"v1.yaml\").open() as f:",
            "            specification = safe_load(f)",
            "        return FlaskApi(",
            "            specification=specification,",
            "            resolver=_LazyResolver(),",
            "            base_path=\"/auth/fab/v1\",",
            "            options={\"swagger_ui\": SWAGGER_ENABLED, \"swagger_path\": SWAGGER_BUNDLE.__fspath__()},",
            "            strict_validation=True,",
            "            validate_responses=True,",
            "            validator_map={\"body\": _CustomErrorRequestBodyValidator},",
            "        ).blueprint",
            "",
            "    def get_user_display_name(self) -> str:",
            "        \"\"\"Return the user's display name associated to the user in session.\"\"\"",
            "        user = self.get_user()",
            "        first_name = user.first_name.strip() if isinstance(user.first_name, str) else \"\"",
            "        last_name = user.last_name.strip() if isinstance(user.last_name, str) else \"\"",
            "        return f\"{first_name} {last_name}\".strip()",
            "",
            "    def get_user(self) -> User:",
            "        \"\"\"Return the user associated to the user in session.\"\"\"",
            "        from flask_login import current_user",
            "",
            "        return current_user",
            "",
            "    def init(self) -> None:",
            "        \"\"\"Run operations when Airflow is initializing.\"\"\"",
            "        self._sync_appbuilder_roles()",
            "",
            "    def is_logged_in(self) -> bool:",
            "        \"\"\"Return whether the user is logged in.\"\"\"",
            "        return not self.get_user().is_anonymous",
            "",
            "    def is_authorized_configuration(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: ConfigurationDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_CONFIG, user=user)",
            "",
            "    def is_authorized_connection(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: ConnectionDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_CONNECTION, user=user)",
            "",
            "    def is_authorized_dag(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        access_entity: DagAccessEntity | None = None,",
            "        details: DagDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to access the dag.",
            "",
            "        There are multiple scenarios:",
            "",
            "        1. ``dag_access`` is not provided which means the user wants to access the DAG itself and not a sub",
            "        entity (e.g. DAG runs).",
            "        2. ``dag_access`` is provided which means the user wants to access a sub entity of the DAG",
            "        (e.g. DAG runs).",
            "",
            "            a. If ``method`` is GET, then check the user has READ permissions on the DAG and the sub entity.",
            "            b. Else, check the user has EDIT permissions on the DAG and ``method`` on the sub entity. However,",
            "                if no specific DAG is targeted, just check the sub entity.",
            "",
            "        :param method: The method to authorize.",
            "        :param access_entity: The dag access entity.",
            "        :param details: The dag details.",
            "        :param user: The user.",
            "        \"\"\"",
            "        if not access_entity:",
            "            # Scenario 1",
            "            return self._is_authorized_dag(method=method, details=details, user=user)",
            "        else:",
            "            # Scenario 2",
            "            resource_types = self._get_fab_resource_types(access_entity)",
            "            dag_method: ResourceMethod = \"GET\" if method == \"GET\" else \"PUT\"",
            "",
            "            if (details and details.id) and not self._is_authorized_dag(",
            "                method=dag_method, details=details, user=user",
            "            ):",
            "                return False",
            "",
            "            return all(",
            "                self._is_authorized(method=method, resource_type=resource_type, user=user)",
            "                for resource_type in resource_types",
            "            )",
            "",
            "    def is_authorized_dataset(",
            "        self, *, method: ResourceMethod, details: DatasetDetails | None = None, user: BaseUser | None = None",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_DATASET, user=user)",
            "",
            "    def is_authorized_pool(",
            "        self, *, method: ResourceMethod, details: PoolDetails | None = None, user: BaseUser | None = None",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_POOL, user=user)",
            "",
            "    def is_authorized_variable(",
            "        self, *, method: ResourceMethod, details: VariableDetails | None = None, user: BaseUser | None = None",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_VARIABLE, user=user)",
            "",
            "    def is_authorized_view(self, *, access_view: AccessView, user: BaseUser | None = None) -> bool:",
            "        return self._is_authorized(",
            "            method=\"GET\", resource_type=_MAP_ACCESS_VIEW_TO_FAB_RESOURCE_TYPE[access_view], user=user",
            "        )",
            "",
            "    def is_authorized_custom_view(",
            "        self, *, fab_action_name: str, fab_resource_name: str, user: BaseUser | None = None",
            "    ):",
            "        if not user:",
            "            user = self.get_user()",
            "        return (fab_action_name, fab_resource_name) in self._get_user_permissions(user)",
            "",
            "    @provide_session",
            "    def get_permitted_dag_ids(",
            "        self,",
            "        *,",
            "        methods: Container[ResourceMethod] | None = None,",
            "        user=None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> set[str]:",
            "        if not methods:",
            "            methods = [\"PUT\", \"GET\"]",
            "",
            "        if not user:",
            "            user = self.get_user()",
            "",
            "        if not self.is_logged_in():",
            "            roles = user.roles",
            "        else:",
            "            if (\"GET\" in methods and self.is_authorized_dag(method=\"GET\", user=user)) or (",
            "                \"PUT\" in methods and self.is_authorized_dag(method=\"PUT\", user=user)",
            "            ):",
            "                # If user is authorized to read/edit all DAGs, return all DAGs",
            "                return {dag.dag_id for dag in session.execute(select(DagModel.dag_id))}",
            "            user_query = session.scalar(",
            "                select(User)",
            "                .options(",
            "                    joinedload(User.roles)",
            "                    .subqueryload(Role.permissions)",
            "                    .options(joinedload(Permission.action), joinedload(Permission.resource))",
            "                )",
            "                .where(User.id == user.id)",
            "            )",
            "            roles = user_query.roles",
            "",
            "        map_fab_action_name_to_method_name = get_method_from_fab_action_map()",
            "        resources = set()",
            "        for role in roles:",
            "            for permission in role.permissions:",
            "                action = permission.action.name",
            "                if (",
            "                    action in map_fab_action_name_to_method_name",
            "                    and map_fab_action_name_to_method_name[action] in methods",
            "                ):",
            "                    resource = permission.resource.name",
            "                    if resource == permissions.RESOURCE_DAG:",
            "                        return {dag.dag_id for dag in session.execute(select(DagModel.dag_id))}",
            "                    if resource.startswith(permissions.RESOURCE_DAG_PREFIX):",
            "                        resources.add(resource[len(permissions.RESOURCE_DAG_PREFIX) :])",
            "                    else:",
            "                        resources.add(resource)",
            "        return {",
            "            dag.dag_id",
            "            for dag in session.execute(select(DagModel.dag_id).where(DagModel.dag_id.in_(resources)))",
            "        }",
            "",
            "    @cached_property",
            "    def security_manager(self) -> FabAirflowSecurityManagerOverride:",
            "        \"\"\"Return the security manager specific to FAB.\"\"\"",
            "        from airflow.providers.fab.auth_manager.security_manager.override import (",
            "            FabAirflowSecurityManagerOverride,",
            "        )",
            "",
            "        sm_from_config = self.appbuilder.get_app.config.get(\"SECURITY_MANAGER_CLASS\")",
            "        if sm_from_config:",
            "            if not issubclass(sm_from_config, FabAirflowSecurityManagerOverride):",
            "                raise Exception(",
            "                    \"\"\"Your CUSTOM_SECURITY_MANAGER must extend FabAirflowSecurityManagerOverride.\"\"\"",
            "                )",
            "            return sm_from_config(self.appbuilder)",
            "",
            "        return FabAirflowSecurityManagerOverride(self.appbuilder)",
            "",
            "    def get_url_login(self, **kwargs) -> str:",
            "        \"\"\"Return the login page url.\"\"\"",
            "        if not self.security_manager.auth_view:",
            "            raise AirflowException(\"`auth_view` not defined in the security manager.\")",
            "        if \"next_url\" in kwargs and kwargs[\"next_url\"]:",
            "            return url_for(f\"{self.security_manager.auth_view.endpoint}.login\", next_url=kwargs[\"next_url\"])",
            "        else:",
            "            return url_for(f\"{self.security_manager.auth_view.endpoint}.login\")",
            "",
            "    def get_url_logout(self):",
            "        \"\"\"Return the logout page url.\"\"\"",
            "        if not self.security_manager.auth_view:",
            "            raise AirflowException(\"`auth_view` not defined in the security manager.\")",
            "        return url_for(f\"{self.security_manager.auth_view.endpoint}.logout\")",
            "",
            "    def get_url_user_profile(self) -> str | None:",
            "        \"\"\"Return the url to a page displaying info about the current user.\"\"\"",
            "        if not self.security_manager.user_view:",
            "            return None",
            "        return url_for(f\"{self.security_manager.user_view.endpoint}.userinfo\")",
            "",
            "    def _is_authorized(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        resource_type: str,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action.",
            "",
            "        :param method: the method to perform",
            "        :param resource_type: the type of resource the user attempts to perform the action on",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not user:",
            "            user = self.get_user()",
            "",
            "        fab_action = self._get_fab_action(method)",
            "        user_permissions = self._get_user_permissions(user)",
            "",
            "        return (fab_action, resource_type) in user_permissions",
            "",
            "    def _is_authorized_dag(",
            "        self,",
            "        method: ResourceMethod,",
            "        details: DagDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a DAG.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the DAG",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        is_global_authorized = self._is_authorized(method=method, resource_type=RESOURCE_DAG, user=user)",
            "        if is_global_authorized:",
            "            return True",
            "",
            "        if details and details.id:",
            "            # Check whether the user has permissions to access a specific DAG",
            "            resource_dag_name = self._resource_name_for_dag(details.id)",
            "            return self._is_authorized(method=method, resource_type=resource_dag_name, user=user)",
            "",
            "        return False",
            "",
            "    @staticmethod",
            "    def _get_fab_action(method: ResourceMethod) -> str:",
            "        \"\"\"",
            "        Convert the method to a FAB action.",
            "",
            "        :param method: the method to convert",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        fab_action_from_method_map = get_fab_action_from_method_map()",
            "        if method not in fab_action_from_method_map:",
            "            raise AirflowException(f\"Unknown method: {method}\")",
            "        return fab_action_from_method_map[method]",
            "",
            "    @staticmethod",
            "    def _get_fab_resource_types(dag_access_entity: DagAccessEntity) -> tuple[str, ...]:",
            "        \"\"\"",
            "        Convert a DAG access entity to a tuple of FAB resource type.",
            "",
            "        :param dag_access_entity: the DAG access entity",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if dag_access_entity not in _MAP_DAG_ACCESS_ENTITY_TO_FAB_RESOURCE_TYPE:",
            "            raise AirflowException(f\"Unknown DAG access entity: {dag_access_entity}\")",
            "        return _MAP_DAG_ACCESS_ENTITY_TO_FAB_RESOURCE_TYPE[dag_access_entity]",
            "",
            "    def _resource_name_for_dag(self, dag_id: str) -> str:",
            "        \"\"\"",
            "        Return the FAB resource name for a DAG id.",
            "",
            "        :param dag_id: the DAG id",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        root_dag_id = self._get_root_dag_id(dag_id)",
            "        if root_dag_id == RESOURCE_DAG:",
            "            return root_dag_id",
            "        if root_dag_id.startswith(RESOURCE_DAG_PREFIX):",
            "            return root_dag_id",
            "        return f\"{RESOURCE_DAG_PREFIX}{root_dag_id}\"",
            "",
            "    @staticmethod",
            "    def _get_user_permissions(user: BaseUser):",
            "        \"\"\"",
            "        Return the user permissions.",
            "",
            "        ACTION_CAN_READ and ACTION_CAN_ACCESS_MENU are merged into because they are very similar.",
            "        We can assume that if a user has permissions to read variables, they also have permissions to access",
            "        the menu \"Variables\".",
            "",
            "        :param user: the user to get permissions for",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        perms = getattr(user, \"perms\") or []",
            "        return [",
            "            (ACTION_CAN_READ if perm[0] == ACTION_CAN_ACCESS_MENU else perm[0], perm[1]) for perm in perms",
            "        ]",
            "",
            "    def _get_root_dag_id(self, dag_id: str) -> str:",
            "        \"\"\"",
            "        Return the root DAG id in case of sub DAG, return the DAG id otherwise.",
            "",
            "        :param dag_id: the DAG id",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if \".\" in dag_id:",
            "            return self.appbuilder.get_session.scalar(",
            "                select(DagModel.dag_id, DagModel.root_dag_id).where(DagModel.dag_id == dag_id).limit(1)",
            "            )",
            "        return dag_id",
            "",
            "    def _sync_appbuilder_roles(self):",
            "        \"\"\"",
            "        Sync appbuilder roles to DB.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        # Garbage collect old permissions/views after they have been modified.",
            "        # Otherwise, when the name of a view or menu is changed, the framework",
            "        # will add the new Views and Menus names to the backend, but will not",
            "        # delete the old ones.",
            "        if conf.getboolean(",
            "            \"fab\", \"UPDATE_FAB_PERMS\", fallback=conf.getboolean(\"webserver\", \"UPDATE_FAB_PERMS\")",
            "        ):",
            "            self.security_manager.sync_roles()",
            "",
            "",
            "def get_parser() -> argparse.ArgumentParser:",
            "    \"\"\"Generate documentation; used by Sphinx argparse.\"\"\"",
            "    from airflow.cli.cli_parser import AirflowHelpFormatter, _add_command",
            "",
            "    parser = DefaultHelpParser(prog=\"airflow\", formatter_class=AirflowHelpFormatter)",
            "    subparsers = parser.add_subparsers(dest=\"subcommand\", metavar=\"GROUP_OR_COMMAND\")",
            "    for group_command in FabAuthManager.get_cli_commands():",
            "        _add_command(subparsers, group_command)",
            "    return parser"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import argparse",
            "from functools import cached_property",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Container",
            "",
            "from connexion import FlaskApi",
            "from flask import Blueprint, url_for",
            "from sqlalchemy import select",
            "from sqlalchemy.orm import Session, joinedload",
            "",
            "from airflow.auth.managers.base_auth_manager import BaseAuthManager, ResourceMethod",
            "from airflow.auth.managers.models.resource_details import (",
            "    AccessView,",
            "    ConfigurationDetails,",
            "    ConnectionDetails,",
            "    DagAccessEntity,",
            "    DagDetails,",
            "    DatasetDetails,",
            "    PoolDetails,",
            "    VariableDetails,",
            ")",
            "from airflow.auth.managers.utils.fab import get_fab_action_from_method_map, get_method_from_fab_action_map",
            "from airflow.cli.cli_config import (",
            "    DefaultHelpParser,",
            "    GroupCommand,",
            ")",
            "from airflow.configuration import conf",
            "from airflow.exceptions import AirflowException",
            "from airflow.models import DagModel",
            "from airflow.providers.fab.auth_manager.cli_commands.definition import (",
            "    ROLES_COMMANDS,",
            "    SYNC_PERM_COMMAND,",
            "    USERS_COMMANDS,",
            ")",
            "from airflow.providers.fab.auth_manager.models import Permission, Role, User",
            "from airflow.security import permissions",
            "from airflow.security.permissions import (",
            "    RESOURCE_AUDIT_LOG,",
            "    RESOURCE_CLUSTER_ACTIVITY,",
            "    RESOURCE_CONFIG,",
            "    RESOURCE_CONNECTION,",
            "    RESOURCE_DAG,",
            "    RESOURCE_DAG_CODE,",
            "    RESOURCE_DAG_DEPENDENCIES,",
            "    RESOURCE_DAG_PREFIX,",
            "    RESOURCE_DAG_RUN,",
            "    RESOURCE_DAG_WARNING,",
            "    RESOURCE_DATASET,",
            "    RESOURCE_DOCS,",
            "    RESOURCE_IMPORT_ERROR,",
            "    RESOURCE_JOB,",
            "    RESOURCE_PLUGIN,",
            "    RESOURCE_POOL,",
            "    RESOURCE_PROVIDER,",
            "    RESOURCE_SLA_MISS,",
            "    RESOURCE_TASK_INSTANCE,",
            "    RESOURCE_TASK_LOG,",
            "    RESOURCE_TASK_RESCHEDULE,",
            "    RESOURCE_TRIGGER,",
            "    RESOURCE_VARIABLE,",
            "    RESOURCE_WEBSITE,",
            "    RESOURCE_XCOM,",
            ")",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.utils.yaml import safe_load",
            "from airflow.www.constants import SWAGGER_BUNDLE, SWAGGER_ENABLED",
            "from airflow.www.extensions.init_views import _CustomErrorRequestBodyValidator, _LazyResolver",
            "",
            "if TYPE_CHECKING:",
            "    from airflow.auth.managers.models.base_user import BaseUser",
            "    from airflow.cli.cli_config import (",
            "        CLICommand,",
            "    )",
            "    from airflow.providers.fab.auth_manager.security_manager.override import FabAirflowSecurityManagerOverride",
            "",
            "_MAP_DAG_ACCESS_ENTITY_TO_FAB_RESOURCE_TYPE: dict[DagAccessEntity, tuple[str, ...]] = {",
            "    DagAccessEntity.AUDIT_LOG: (RESOURCE_AUDIT_LOG,),",
            "    DagAccessEntity.CODE: (RESOURCE_DAG_CODE,),",
            "    DagAccessEntity.DEPENDENCIES: (RESOURCE_DAG_DEPENDENCIES,),",
            "    DagAccessEntity.RUN: (RESOURCE_DAG_RUN,),",
            "    DagAccessEntity.SLA_MISS: (RESOURCE_SLA_MISS,),",
            "    # RESOURCE_TASK_INSTANCE has been originally misused. RESOURCE_TASK_INSTANCE referred to task definition",
            "    # AND task instances without making the difference",
            "    # To be backward compatible, we translate DagAccessEntity.TASK_INSTANCE to RESOURCE_TASK_INSTANCE AND",
            "    # RESOURCE_DAG_RUN",
            "    # See https://github.com/apache/airflow/pull/34317#discussion_r1355917769",
            "    DagAccessEntity.TASK: (RESOURCE_TASK_INSTANCE,),",
            "    DagAccessEntity.TASK_INSTANCE: (RESOURCE_DAG_RUN, RESOURCE_TASK_INSTANCE),",
            "    DagAccessEntity.TASK_LOGS: (RESOURCE_TASK_LOG,),",
            "    DagAccessEntity.TASK_RESCHEDULE: (RESOURCE_TASK_RESCHEDULE,),",
            "    DagAccessEntity.WARNING: (RESOURCE_DAG_WARNING,),",
            "    DagAccessEntity.XCOM: (RESOURCE_XCOM,),",
            "}",
            "",
            "_MAP_ACCESS_VIEW_TO_FAB_RESOURCE_TYPE = {",
            "    AccessView.CLUSTER_ACTIVITY: RESOURCE_CLUSTER_ACTIVITY,",
            "    AccessView.DOCS: RESOURCE_DOCS,",
            "    AccessView.IMPORT_ERRORS: RESOURCE_IMPORT_ERROR,",
            "    AccessView.JOBS: RESOURCE_JOB,",
            "    AccessView.PLUGINS: RESOURCE_PLUGIN,",
            "    AccessView.PROVIDERS: RESOURCE_PROVIDER,",
            "    AccessView.TRIGGERS: RESOURCE_TRIGGER,",
            "    AccessView.WEBSITE: RESOURCE_WEBSITE,",
            "}",
            "",
            "",
            "class FabAuthManager(BaseAuthManager):",
            "    \"\"\"",
            "    Flask-AppBuilder auth manager.",
            "",
            "    This auth manager is responsible for providing a backward compatible user management experience to users.",
            "    \"\"\"",
            "",
            "    @staticmethod",
            "    def get_cli_commands() -> list[CLICommand]:",
            "        \"\"\"Vends CLI commands to be included in Airflow CLI.\"\"\"",
            "        return [",
            "            GroupCommand(",
            "                name=\"users\",",
            "                help=\"Manage users\",",
            "                subcommands=USERS_COMMANDS,",
            "            ),",
            "            GroupCommand(",
            "                name=\"roles\",",
            "                help=\"Manage roles\",",
            "                subcommands=ROLES_COMMANDS,",
            "            ),",
            "            SYNC_PERM_COMMAND,  # not in a command group",
            "        ]",
            "",
            "    def get_api_endpoints(self) -> None | Blueprint:",
            "        folder = Path(__file__).parents[0].resolve()  # this is airflow/auth/managers/fab/",
            "        with folder.joinpath(\"openapi\", \"v1.yaml\").open() as f:",
            "            specification = safe_load(f)",
            "        return FlaskApi(",
            "            specification=specification,",
            "            resolver=_LazyResolver(),",
            "            base_path=\"/auth/fab/v1\",",
            "            options={\"swagger_ui\": SWAGGER_ENABLED, \"swagger_path\": SWAGGER_BUNDLE.__fspath__()},",
            "            strict_validation=True,",
            "            validate_responses=True,",
            "            validator_map={\"body\": _CustomErrorRequestBodyValidator},",
            "        ).blueprint",
            "",
            "    def get_user_display_name(self) -> str:",
            "        \"\"\"Return the user's display name associated to the user in session.\"\"\"",
            "        user = self.get_user()",
            "        first_name = user.first_name.strip() if isinstance(user.first_name, str) else \"\"",
            "        last_name = user.last_name.strip() if isinstance(user.last_name, str) else \"\"",
            "        return f\"{first_name} {last_name}\".strip()",
            "",
            "    def get_user(self) -> User:",
            "        \"\"\"Return the user associated to the user in session.\"\"\"",
            "        from flask_login import current_user",
            "",
            "        return current_user",
            "",
            "    def init(self) -> None:",
            "        \"\"\"Run operations when Airflow is initializing.\"\"\"",
            "        self._sync_appbuilder_roles()",
            "",
            "    def is_logged_in(self) -> bool:",
            "        \"\"\"Return whether the user is logged in.\"\"\"",
            "        return not self.get_user().is_anonymous",
            "",
            "    def is_authorized_configuration(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: ConfigurationDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_CONFIG, user=user)",
            "",
            "    def is_authorized_connection(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        details: ConnectionDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_CONNECTION, user=user)",
            "",
            "    def is_authorized_dag(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        access_entity: DagAccessEntity | None = None,",
            "        details: DagDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to access the dag.",
            "",
            "        There are multiple scenarios:",
            "",
            "        1. ``dag_access`` is not provided which means the user wants to access the DAG itself and not a sub",
            "        entity (e.g. DAG runs).",
            "        2. ``dag_access`` is provided which means the user wants to access a sub entity of the DAG",
            "        (e.g. DAG runs).",
            "",
            "            a. If ``method`` is GET, then check the user has READ permissions on the DAG and the sub entity.",
            "            b. Else, check the user has EDIT permissions on the DAG and ``method`` on the sub entity. However,",
            "                if no specific DAG is targeted, just check the sub entity.",
            "",
            "        :param method: The method to authorize.",
            "        :param access_entity: The dag access entity.",
            "        :param details: The dag details.",
            "        :param user: The user.",
            "        \"\"\"",
            "        if not access_entity:",
            "            # Scenario 1",
            "            return self._is_authorized_dag(method=method, details=details, user=user)",
            "        else:",
            "            # Scenario 2",
            "            resource_types = self._get_fab_resource_types(access_entity)",
            "            dag_method: ResourceMethod = \"GET\" if method == \"GET\" else \"PUT\"",
            "",
            "            if (details and details.id) and not self._is_authorized_dag(",
            "                method=dag_method, details=details, user=user",
            "            ):",
            "                return False",
            "",
            "            return all(",
            "                self._is_authorized(method=method, resource_type=resource_type, user=user)",
            "                for resource_type in resource_types",
            "            )",
            "",
            "    def is_authorized_dataset(",
            "        self, *, method: ResourceMethod, details: DatasetDetails | None = None, user: BaseUser | None = None",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_DATASET, user=user)",
            "",
            "    def is_authorized_pool(",
            "        self, *, method: ResourceMethod, details: PoolDetails | None = None, user: BaseUser | None = None",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_POOL, user=user)",
            "",
            "    def is_authorized_variable(",
            "        self, *, method: ResourceMethod, details: VariableDetails | None = None, user: BaseUser | None = None",
            "    ) -> bool:",
            "        return self._is_authorized(method=method, resource_type=RESOURCE_VARIABLE, user=user)",
            "",
            "    def is_authorized_view(self, *, access_view: AccessView, user: BaseUser | None = None) -> bool:",
            "        # \"Docs\" are only links in the menu, there is no page associated",
            "        method: ResourceMethod = \"MENU\" if access_view == AccessView.DOCS else \"GET\"",
            "        return self._is_authorized(",
            "            method=method, resource_type=_MAP_ACCESS_VIEW_TO_FAB_RESOURCE_TYPE[access_view], user=user",
            "        )",
            "",
            "    def is_authorized_custom_view(",
            "        self, *, fab_action_name: str, fab_resource_name: str, user: BaseUser | None = None",
            "    ):",
            "        if not user:",
            "            user = self.get_user()",
            "        return (fab_action_name, fab_resource_name) in self._get_user_permissions(user)",
            "",
            "    @provide_session",
            "    def get_permitted_dag_ids(",
            "        self,",
            "        *,",
            "        methods: Container[ResourceMethod] | None = None,",
            "        user=None,",
            "        session: Session = NEW_SESSION,",
            "    ) -> set[str]:",
            "        if not methods:",
            "            methods = [\"PUT\", \"GET\"]",
            "",
            "        if not user:",
            "            user = self.get_user()",
            "",
            "        if not self.is_logged_in():",
            "            roles = user.roles",
            "        else:",
            "            if (\"GET\" in methods and self.is_authorized_dag(method=\"GET\", user=user)) or (",
            "                \"PUT\" in methods and self.is_authorized_dag(method=\"PUT\", user=user)",
            "            ):",
            "                # If user is authorized to read/edit all DAGs, return all DAGs",
            "                return {dag.dag_id for dag in session.execute(select(DagModel.dag_id))}",
            "            user_query = session.scalar(",
            "                select(User)",
            "                .options(",
            "                    joinedload(User.roles)",
            "                    .subqueryload(Role.permissions)",
            "                    .options(joinedload(Permission.action), joinedload(Permission.resource))",
            "                )",
            "                .where(User.id == user.id)",
            "            )",
            "            roles = user_query.roles",
            "",
            "        map_fab_action_name_to_method_name = get_method_from_fab_action_map()",
            "        resources = set()",
            "        for role in roles:",
            "            for permission in role.permissions:",
            "                action = permission.action.name",
            "                if (",
            "                    action in map_fab_action_name_to_method_name",
            "                    and map_fab_action_name_to_method_name[action] in methods",
            "                ):",
            "                    resource = permission.resource.name",
            "                    if resource == permissions.RESOURCE_DAG:",
            "                        return {dag.dag_id for dag in session.execute(select(DagModel.dag_id))}",
            "                    if resource.startswith(permissions.RESOURCE_DAG_PREFIX):",
            "                        resources.add(resource[len(permissions.RESOURCE_DAG_PREFIX) :])",
            "                    else:",
            "                        resources.add(resource)",
            "        return {",
            "            dag.dag_id",
            "            for dag in session.execute(select(DagModel.dag_id).where(DagModel.dag_id.in_(resources)))",
            "        }",
            "",
            "    @cached_property",
            "    def security_manager(self) -> FabAirflowSecurityManagerOverride:",
            "        \"\"\"Return the security manager specific to FAB.\"\"\"",
            "        from airflow.providers.fab.auth_manager.security_manager.override import (",
            "            FabAirflowSecurityManagerOverride,",
            "        )",
            "",
            "        sm_from_config = self.appbuilder.get_app.config.get(\"SECURITY_MANAGER_CLASS\")",
            "        if sm_from_config:",
            "            if not issubclass(sm_from_config, FabAirflowSecurityManagerOverride):",
            "                raise Exception(",
            "                    \"\"\"Your CUSTOM_SECURITY_MANAGER must extend FabAirflowSecurityManagerOverride.\"\"\"",
            "                )",
            "            return sm_from_config(self.appbuilder)",
            "",
            "        return FabAirflowSecurityManagerOverride(self.appbuilder)",
            "",
            "    def get_url_login(self, **kwargs) -> str:",
            "        \"\"\"Return the login page url.\"\"\"",
            "        if not self.security_manager.auth_view:",
            "            raise AirflowException(\"`auth_view` not defined in the security manager.\")",
            "        if \"next_url\" in kwargs and kwargs[\"next_url\"]:",
            "            return url_for(f\"{self.security_manager.auth_view.endpoint}.login\", next_url=kwargs[\"next_url\"])",
            "        else:",
            "            return url_for(f\"{self.security_manager.auth_view.endpoint}.login\")",
            "",
            "    def get_url_logout(self):",
            "        \"\"\"Return the logout page url.\"\"\"",
            "        if not self.security_manager.auth_view:",
            "            raise AirflowException(\"`auth_view` not defined in the security manager.\")",
            "        return url_for(f\"{self.security_manager.auth_view.endpoint}.logout\")",
            "",
            "    def get_url_user_profile(self) -> str | None:",
            "        \"\"\"Return the url to a page displaying info about the current user.\"\"\"",
            "        if not self.security_manager.user_view:",
            "            return None",
            "        return url_for(f\"{self.security_manager.user_view.endpoint}.userinfo\")",
            "",
            "    def _is_authorized(",
            "        self,",
            "        *,",
            "        method: ResourceMethod,",
            "        resource_type: str,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action.",
            "",
            "        :param method: the method to perform",
            "        :param resource_type: the type of resource the user attempts to perform the action on",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not user:",
            "            user = self.get_user()",
            "",
            "        fab_action = self._get_fab_action(method)",
            "        user_permissions = self._get_user_permissions(user)",
            "",
            "        return (fab_action, resource_type) in user_permissions",
            "",
            "    def _is_authorized_dag(",
            "        self,",
            "        method: ResourceMethod,",
            "        details: DagDetails | None = None,",
            "        user: BaseUser | None = None,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Return whether the user is authorized to perform a given action on a DAG.",
            "",
            "        :param method: the method to perform",
            "        :param details: optional details about the DAG",
            "        :param user: the user to perform the action on. If not provided (or None), it uses the current user",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        is_global_authorized = self._is_authorized(method=method, resource_type=RESOURCE_DAG, user=user)",
            "        if is_global_authorized:",
            "            return True",
            "",
            "        if details and details.id:",
            "            # Check whether the user has permissions to access a specific DAG",
            "            resource_dag_name = self._resource_name_for_dag(details.id)",
            "            return self._is_authorized(method=method, resource_type=resource_dag_name, user=user)",
            "",
            "        return False",
            "",
            "    @staticmethod",
            "    def _get_fab_action(method: ResourceMethod) -> str:",
            "        \"\"\"",
            "        Convert the method to a FAB action.",
            "",
            "        :param method: the method to convert",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        fab_action_from_method_map = get_fab_action_from_method_map()",
            "        if method not in fab_action_from_method_map:",
            "            raise AirflowException(f\"Unknown method: {method}\")",
            "        return fab_action_from_method_map[method]",
            "",
            "    @staticmethod",
            "    def _get_fab_resource_types(dag_access_entity: DagAccessEntity) -> tuple[str, ...]:",
            "        \"\"\"",
            "        Convert a DAG access entity to a tuple of FAB resource type.",
            "",
            "        :param dag_access_entity: the DAG access entity",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if dag_access_entity not in _MAP_DAG_ACCESS_ENTITY_TO_FAB_RESOURCE_TYPE:",
            "            raise AirflowException(f\"Unknown DAG access entity: {dag_access_entity}\")",
            "        return _MAP_DAG_ACCESS_ENTITY_TO_FAB_RESOURCE_TYPE[dag_access_entity]",
            "",
            "    def _resource_name_for_dag(self, dag_id: str) -> str:",
            "        \"\"\"",
            "        Return the FAB resource name for a DAG id.",
            "",
            "        :param dag_id: the DAG id",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        root_dag_id = self._get_root_dag_id(dag_id)",
            "        if root_dag_id == RESOURCE_DAG:",
            "            return root_dag_id",
            "        if root_dag_id.startswith(RESOURCE_DAG_PREFIX):",
            "            return root_dag_id",
            "        return f\"{RESOURCE_DAG_PREFIX}{root_dag_id}\"",
            "",
            "    @staticmethod",
            "    def _get_user_permissions(user: BaseUser):",
            "        \"\"\"",
            "        Return the user permissions.",
            "",
            "        :param user: the user to get permissions for",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return getattr(user, \"perms\") or []",
            "",
            "    def _get_root_dag_id(self, dag_id: str) -> str:",
            "        \"\"\"",
            "        Return the root DAG id in case of sub DAG, return the DAG id otherwise.",
            "",
            "        :param dag_id: the DAG id",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if \".\" in dag_id:",
            "            return self.appbuilder.get_session.scalar(",
            "                select(DagModel.dag_id, DagModel.root_dag_id).where(DagModel.dag_id == dag_id).limit(1)",
            "            )",
            "        return dag_id",
            "",
            "    def _sync_appbuilder_roles(self):",
            "        \"\"\"",
            "        Sync appbuilder roles to DB.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        # Garbage collect old permissions/views after they have been modified.",
            "        # Otherwise, when the name of a view or menu is changed, the framework",
            "        # will add the new Views and Menus names to the backend, but will not",
            "        # delete the old ones.",
            "        if conf.getboolean(",
            "            \"fab\", \"UPDATE_FAB_PERMS\", fallback=conf.getboolean(\"webserver\", \"UPDATE_FAB_PERMS\")",
            "        ):",
            "            self.security_manager.sync_roles()",
            "",
            "",
            "def get_parser() -> argparse.ArgumentParser:",
            "    \"\"\"Generate documentation; used by Sphinx argparse.\"\"\"",
            "    from airflow.cli.cli_parser import AirflowHelpFormatter, _add_command",
            "",
            "    parser = DefaultHelpParser(prog=\"airflow\", formatter_class=AirflowHelpFormatter)",
            "    subparsers = parser.add_subparsers(dest=\"subcommand\", metavar=\"GROUP_OR_COMMAND\")",
            "    for group_command in FabAuthManager.get_cli_commands():",
            "        _add_command(subparsers, group_command)",
            "    return parser"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "57": [],
            "58": [],
            "267": [
                "FabAuthManager",
                "is_authorized_view"
            ],
            "466": [
                "FabAuthManager",
                "_get_user_permissions"
            ],
            "467": [
                "FabAuthManager",
                "_get_user_permissions"
            ],
            "468": [
                "FabAuthManager",
                "_get_user_permissions"
            ],
            "469": [
                "FabAuthManager",
                "_get_user_permissions"
            ],
            "474": [
                "FabAuthManager",
                "_get_user_permissions"
            ],
            "475": [
                "FabAuthManager",
                "_get_user_permissions"
            ],
            "476": [
                "FabAuthManager",
                "_get_user_permissions"
            ],
            "477": [
                "FabAuthManager",
                "_get_user_permissions"
            ]
        },
        "addLocation": []
    },
    "airflow/www/security_manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " from airflow.exceptions import AirflowException"
            },
            "1": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " from airflow.models import Connection, DagRun, Pool, TaskInstance, Variable"
            },
            "2": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " from airflow.security.permissions import ("
            },
            "3": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ACTION_CAN_ACCESS_MENU,"
            },
            "4": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ACTION_CAN_READ,"
            },
            "5": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     RESOURCE_ADMIN_MENU,"
            },
            "6": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     RESOURCE_AUDIT_LOG,"
            },
            "7": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     RESOURCE_BROWSE_MENU,"
            },
            "8": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "             # This means the page the user is trying to access is specific to the auth manager used"
            },
            "9": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "             # Example: the user list view in FabAuthManager"
            },
            "10": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "             return lambda action, resource_pk, user: get_auth_manager().is_authorized_custom_view("
            },
            "11": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                fab_action_name=ACTION_CAN_READ if action == ACTION_CAN_ACCESS_MENU else action,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+                fab_action_name=action,"
            },
            "13": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "                 fab_resource_name=fab_resource_name,"
            },
            "14": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "                 user=user,"
            },
            "15": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "             )"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import json",
            "from functools import cached_property",
            "from typing import TYPE_CHECKING, Callable",
            "",
            "from flask import g",
            "from flask_limiter import Limiter",
            "from flask_limiter.util import get_remote_address",
            "from sqlalchemy import select",
            "",
            "from airflow.auth.managers.models.resource_details import (",
            "    AccessView,",
            "    ConnectionDetails,",
            "    DagAccessEntity,",
            "    DagDetails,",
            "    PoolDetails,",
            "    VariableDetails,",
            ")",
            "from airflow.auth.managers.utils.fab import (",
            "    get_method_from_fab_action_map,",
            ")",
            "from airflow.exceptions import AirflowException",
            "from airflow.models import Connection, DagRun, Pool, TaskInstance, Variable",
            "from airflow.security.permissions import (",
            "    ACTION_CAN_ACCESS_MENU,",
            "    ACTION_CAN_READ,",
            "    RESOURCE_ADMIN_MENU,",
            "    RESOURCE_AUDIT_LOG,",
            "    RESOURCE_BROWSE_MENU,",
            "    RESOURCE_CLUSTER_ACTIVITY,",
            "    RESOURCE_CONFIG,",
            "    RESOURCE_CONNECTION,",
            "    RESOURCE_DAG,",
            "    RESOURCE_DAG_CODE,",
            "    RESOURCE_DAG_DEPENDENCIES,",
            "    RESOURCE_DAG_RUN,",
            "    RESOURCE_DATASET,",
            "    RESOURCE_DOCS,",
            "    RESOURCE_DOCS_MENU,",
            "    RESOURCE_JOB,",
            "    RESOURCE_PLUGIN,",
            "    RESOURCE_POOL,",
            "    RESOURCE_PROVIDER,",
            "    RESOURCE_SLA_MISS,",
            "    RESOURCE_TASK_INSTANCE,",
            "    RESOURCE_TASK_RESCHEDULE,",
            "    RESOURCE_TRIGGER,",
            "    RESOURCE_VARIABLE,",
            "    RESOURCE_XCOM,",
            ")",
            "from airflow.utils.log.logging_mixin import LoggingMixin",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.www.extensions.init_auth_manager import get_auth_manager",
            "from airflow.www.utils import CustomSQLAInterface",
            "",
            "EXISTING_ROLES = {",
            "    \"Admin\",",
            "    \"Viewer\",",
            "    \"User\",",
            "    \"Op\",",
            "    \"Public\",",
            "}",
            "",
            "if TYPE_CHECKING:",
            "    from sqlalchemy.orm import Session",
            "",
            "    from airflow.auth.managers.models.base_user import BaseUser",
            "    from airflow.providers.fab.auth_manager.models import Action, Resource",
            "",
            "",
            "class AirflowSecurityManagerV2(LoggingMixin):",
            "    \"\"\"Custom security manager, which introduces a permission model adapted to Airflow.",
            "",
            "    It's named V2 to differentiate it from the obsolete airflow.www.security.AirflowSecurityManager.",
            "    \"\"\"",
            "",
            "    def __init__(self, appbuilder) -> None:",
            "        super().__init__()",
            "        self.appbuilder = appbuilder",
            "",
            "        # Setup Flask-Limiter",
            "        self.limiter = self.create_limiter()",
            "",
            "        # Go and fix up the SQLAInterface used from the stock one to our subclass.",
            "        # This is needed to support the \"hack\" where we had to edit",
            "        # FieldConverter.conversion_table in place in airflow.www.utils",
            "        for attr in dir(self):",
            "            if attr.endswith(\"view\"):",
            "                view = getattr(self, attr, None)",
            "                if view and getattr(view, \"datamodel\", None):",
            "                    view.datamodel = CustomSQLAInterface(view.datamodel.obj)",
            "",
            "    @staticmethod",
            "    def before_request():",
            "        \"\"\"Run hook before request.\"\"\"",
            "        g.user = get_auth_manager().get_user()",
            "",
            "    def create_limiter(self) -> Limiter:",
            "        limiter = Limiter(key_func=get_remote_address)",
            "        limiter.init_app(self.appbuilder.get_app)",
            "        return limiter",
            "",
            "    def register_views(self):",
            "        \"\"\"Allow auth managers to register their own views. By default, do nothing.\"\"\"",
            "        pass",
            "",
            "    def has_access(",
            "        self, action_name: str, resource_name: str, user=None, resource_pk: str | None = None",
            "    ) -> bool:",
            "        \"\"\"",
            "        Verify whether a given user could perform a certain action on the given resource.",
            "",
            "        Example actions might include can_read, can_write, can_delete, etc.",
            "",
            "        This function is called by FAB when accessing a view. See",
            "        https://github.com/dpgaspar/Flask-AppBuilder/blob/c6fecdc551629e15467fde5d06b4437379d90592/flask_appbuilder/security/decorators.py#L134",
            "",
            "        :param action_name: action_name on resource (e.g can_read, can_edit).",
            "        :param resource_name: name of view-menu or resource.",
            "        :param user: user",
            "        :param resource_pk: the resource primary key (e.g. the connection ID)",
            "        :return: Whether user could perform certain action on the resource.",
            "        \"\"\"",
            "        if not user:",
            "            user = g.user",
            "",
            "        is_authorized_method = self._get_auth_manager_is_authorized_method(resource_name)",
            "        return is_authorized_method(action_name, resource_pk, user)",
            "",
            "    def create_admin_standalone(self) -> tuple[str | None, str | None]:",
            "        \"\"\"Perform the required steps when initializing airflow for standalone mode.",
            "",
            "        If necessary, returns the username and password to be printed in the console for users to log in.",
            "        \"\"\"",
            "        return None, None",
            "",
            "    def add_limit_view(self, baseview):",
            "        if not baseview.limits:",
            "            return",
            "",
            "        for limit in baseview.limits:",
            "            self.limiter.limit(",
            "                limit_value=limit.limit_value,",
            "                key_func=limit.key_func,",
            "                per_method=limit.per_method,",
            "                methods=limit.methods,",
            "                error_message=limit.error_message,",
            "                exempt_when=limit.exempt_when,",
            "                override_defaults=limit.override_defaults,",
            "                deduct_when=limit.deduct_when,",
            "                on_breach=limit.on_breach,",
            "                cost=limit.cost,",
            "            )(baseview.blueprint)",
            "",
            "    @cached_property",
            "    @provide_session",
            "    def _auth_manager_is_authorized_map(",
            "        self, session: Session = NEW_SESSION",
            "    ) -> dict[str, Callable[[str, str | None, BaseUser | None], bool]]:",
            "        \"\"\"",
            "        Return the map associating a FAB resource name to the corresponding auth manager is_authorized_ API.",
            "",
            "        The function returned takes the FAB action name and the user as parameter.",
            "        \"\"\"",
            "        auth_manager = get_auth_manager()",
            "        methods = get_method_from_fab_action_map()",
            "",
            "        def get_connection_id(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            connection = session.scalar(select(Connection).where(Connection.id == resource_pk).limit(1))",
            "            if not connection:",
            "                raise AirflowException(\"Connection not found\")",
            "            return connection.conn_id",
            "",
            "        def get_dag_id_from_dagrun_id(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            dagrun = session.scalar(select(DagRun).where(DagRun.id == resource_pk).limit(1))",
            "            if not dagrun:",
            "                raise AirflowException(\"DagRun not found\")",
            "            return dagrun.dag_id",
            "",
            "        def get_dag_id_from_task_instance(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            composite_pk = json.loads(resource_pk)",
            "            ti = session.scalar(",
            "                select(DagRun)",
            "                .where(",
            "                    TaskInstance.dag_id == composite_pk[0],",
            "                    TaskInstance.task_id == composite_pk[1],",
            "                    TaskInstance.run_id == composite_pk[2],",
            "                    TaskInstance.map_index >= composite_pk[3],",
            "                )",
            "                .limit(1)",
            "            )",
            "            if not ti:",
            "                raise AirflowException(\"Task instance not found\")",
            "            return ti.dag_id",
            "",
            "        def get_pool_name(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            pool = session.scalar(select(Pool).where(Pool.id == resource_pk).limit(1))",
            "            if not pool:",
            "                raise AirflowException(\"Pool not found\")",
            "            return pool.pool",
            "",
            "        def get_variable_key(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            variable = session.scalar(select(Variable).where(Variable.id == resource_pk).limit(1))",
            "            if not variable:",
            "                raise AirflowException(\"Connection not found\")",
            "            return variable.key",
            "",
            "        return {",
            "            RESOURCE_AUDIT_LOG: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.AUDIT_LOG,",
            "                user=user,",
            "            ),",
            "            RESOURCE_CLUSTER_ACTIVITY: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.CLUSTER_ACTIVITY,",
            "                user=user,",
            "            ),",
            "            RESOURCE_CONFIG: lambda action, resource_pk, user: auth_manager.is_authorized_configuration(",
            "                method=methods[action],",
            "                user=user,",
            "            ),",
            "            RESOURCE_CONNECTION: lambda action, resource_pk, user: auth_manager.is_authorized_connection(",
            "                method=methods[action],",
            "                details=ConnectionDetails(conn_id=get_connection_id(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_DAG: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                user=user,",
            "            ),",
            "            RESOURCE_DAG_CODE: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.CODE,",
            "                user=user,",
            "            ),",
            "            RESOURCE_DAG_DEPENDENCIES: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.DEPENDENCIES,",
            "                user=user,",
            "            ),",
            "            RESOURCE_DAG_RUN: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.RUN,",
            "                details=DagDetails(id=get_dag_id_from_dagrun_id(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_DATASET: lambda action, resource_pk, user: auth_manager.is_authorized_dataset(",
            "                method=methods[action],",
            "                user=user,",
            "            ),",
            "            RESOURCE_DOCS: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.DOCS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_PLUGIN: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.PLUGINS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_JOB: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.JOBS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_POOL: lambda action, resource_pk, user: auth_manager.is_authorized_pool(",
            "                method=methods[action],",
            "                details=PoolDetails(name=get_pool_name(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_PROVIDER: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.PROVIDERS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_SLA_MISS: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.SLA_MISS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_TASK_INSTANCE: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.TASK_INSTANCE,",
            "                details=DagDetails(id=get_dag_id_from_task_instance(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_TASK_RESCHEDULE: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.TASK_RESCHEDULE,",
            "                user=user,",
            "            ),",
            "            RESOURCE_TRIGGER: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.TRIGGERS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_VARIABLE: lambda action, resource_pk, user: auth_manager.is_authorized_variable(",
            "                method=methods[action],",
            "                details=VariableDetails(key=get_variable_key(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_XCOM: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.XCOM,",
            "                user=user,",
            "            ),",
            "        }",
            "",
            "    def _get_auth_manager_is_authorized_method(self, fab_resource_name: str) -> Callable:",
            "        is_authorized_method = self._auth_manager_is_authorized_map.get(fab_resource_name)",
            "        if is_authorized_method:",
            "            return is_authorized_method",
            "        elif fab_resource_name in [RESOURCE_DOCS_MENU, RESOURCE_ADMIN_MENU, RESOURCE_BROWSE_MENU]:",
            "            # Display the \"Browse\", \"Admin\" and \"Docs\" dropdowns in the menu if the user has access to at",
            "            # least one dropdown child",
            "            return self._is_authorized_category_menu(fab_resource_name)",
            "        else:",
            "            # This means the page the user is trying to access is specific to the auth manager used",
            "            # Example: the user list view in FabAuthManager",
            "            return lambda action, resource_pk, user: get_auth_manager().is_authorized_custom_view(",
            "                fab_action_name=ACTION_CAN_READ if action == ACTION_CAN_ACCESS_MENU else action,",
            "                fab_resource_name=fab_resource_name,",
            "                user=user,",
            "            )",
            "",
            "    def _is_authorized_category_menu(self, category: str) -> Callable:",
            "        items = {item.name for item in self.appbuilder.menu.find(category).childs}",
            "        return lambda action, resource_pk, user: any(",
            "            self._get_auth_manager_is_authorized_method(fab_resource_name=item)(action, resource_pk, user)",
            "            for item in items",
            "        )",
            "",
            "    \"\"\"",
            "    The following methods are specific to FAB auth manager. They still need to be \"present\" in the main",
            "    security manager class, but they do nothing.",
            "    \"\"\"",
            "",
            "    def get_action(self, name: str) -> Action:",
            "        raise NotImplementedError(\"Only available if FAB auth manager is used\")",
            "",
            "    def get_resource(self, name: str) -> Resource:",
            "        raise NotImplementedError(\"Only available if FAB auth manager is used\")",
            "",
            "    def add_permissions_view(self, base_action_names, resource_name):",
            "        pass",
            "",
            "    def add_permissions_menu(self, resource_name):",
            "        pass"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import json",
            "from functools import cached_property",
            "from typing import TYPE_CHECKING, Callable",
            "",
            "from flask import g",
            "from flask_limiter import Limiter",
            "from flask_limiter.util import get_remote_address",
            "from sqlalchemy import select",
            "",
            "from airflow.auth.managers.models.resource_details import (",
            "    AccessView,",
            "    ConnectionDetails,",
            "    DagAccessEntity,",
            "    DagDetails,",
            "    PoolDetails,",
            "    VariableDetails,",
            ")",
            "from airflow.auth.managers.utils.fab import (",
            "    get_method_from_fab_action_map,",
            ")",
            "from airflow.exceptions import AirflowException",
            "from airflow.models import Connection, DagRun, Pool, TaskInstance, Variable",
            "from airflow.security.permissions import (",
            "    RESOURCE_ADMIN_MENU,",
            "    RESOURCE_AUDIT_LOG,",
            "    RESOURCE_BROWSE_MENU,",
            "    RESOURCE_CLUSTER_ACTIVITY,",
            "    RESOURCE_CONFIG,",
            "    RESOURCE_CONNECTION,",
            "    RESOURCE_DAG,",
            "    RESOURCE_DAG_CODE,",
            "    RESOURCE_DAG_DEPENDENCIES,",
            "    RESOURCE_DAG_RUN,",
            "    RESOURCE_DATASET,",
            "    RESOURCE_DOCS,",
            "    RESOURCE_DOCS_MENU,",
            "    RESOURCE_JOB,",
            "    RESOURCE_PLUGIN,",
            "    RESOURCE_POOL,",
            "    RESOURCE_PROVIDER,",
            "    RESOURCE_SLA_MISS,",
            "    RESOURCE_TASK_INSTANCE,",
            "    RESOURCE_TASK_RESCHEDULE,",
            "    RESOURCE_TRIGGER,",
            "    RESOURCE_VARIABLE,",
            "    RESOURCE_XCOM,",
            ")",
            "from airflow.utils.log.logging_mixin import LoggingMixin",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.www.extensions.init_auth_manager import get_auth_manager",
            "from airflow.www.utils import CustomSQLAInterface",
            "",
            "EXISTING_ROLES = {",
            "    \"Admin\",",
            "    \"Viewer\",",
            "    \"User\",",
            "    \"Op\",",
            "    \"Public\",",
            "}",
            "",
            "if TYPE_CHECKING:",
            "    from sqlalchemy.orm import Session",
            "",
            "    from airflow.auth.managers.models.base_user import BaseUser",
            "    from airflow.providers.fab.auth_manager.models import Action, Resource",
            "",
            "",
            "class AirflowSecurityManagerV2(LoggingMixin):",
            "    \"\"\"Custom security manager, which introduces a permission model adapted to Airflow.",
            "",
            "    It's named V2 to differentiate it from the obsolete airflow.www.security.AirflowSecurityManager.",
            "    \"\"\"",
            "",
            "    def __init__(self, appbuilder) -> None:",
            "        super().__init__()",
            "        self.appbuilder = appbuilder",
            "",
            "        # Setup Flask-Limiter",
            "        self.limiter = self.create_limiter()",
            "",
            "        # Go and fix up the SQLAInterface used from the stock one to our subclass.",
            "        # This is needed to support the \"hack\" where we had to edit",
            "        # FieldConverter.conversion_table in place in airflow.www.utils",
            "        for attr in dir(self):",
            "            if attr.endswith(\"view\"):",
            "                view = getattr(self, attr, None)",
            "                if view and getattr(view, \"datamodel\", None):",
            "                    view.datamodel = CustomSQLAInterface(view.datamodel.obj)",
            "",
            "    @staticmethod",
            "    def before_request():",
            "        \"\"\"Run hook before request.\"\"\"",
            "        g.user = get_auth_manager().get_user()",
            "",
            "    def create_limiter(self) -> Limiter:",
            "        limiter = Limiter(key_func=get_remote_address)",
            "        limiter.init_app(self.appbuilder.get_app)",
            "        return limiter",
            "",
            "    def register_views(self):",
            "        \"\"\"Allow auth managers to register their own views. By default, do nothing.\"\"\"",
            "        pass",
            "",
            "    def has_access(",
            "        self, action_name: str, resource_name: str, user=None, resource_pk: str | None = None",
            "    ) -> bool:",
            "        \"\"\"",
            "        Verify whether a given user could perform a certain action on the given resource.",
            "",
            "        Example actions might include can_read, can_write, can_delete, etc.",
            "",
            "        This function is called by FAB when accessing a view. See",
            "        https://github.com/dpgaspar/Flask-AppBuilder/blob/c6fecdc551629e15467fde5d06b4437379d90592/flask_appbuilder/security/decorators.py#L134",
            "",
            "        :param action_name: action_name on resource (e.g can_read, can_edit).",
            "        :param resource_name: name of view-menu or resource.",
            "        :param user: user",
            "        :param resource_pk: the resource primary key (e.g. the connection ID)",
            "        :return: Whether user could perform certain action on the resource.",
            "        \"\"\"",
            "        if not user:",
            "            user = g.user",
            "",
            "        is_authorized_method = self._get_auth_manager_is_authorized_method(resource_name)",
            "        return is_authorized_method(action_name, resource_pk, user)",
            "",
            "    def create_admin_standalone(self) -> tuple[str | None, str | None]:",
            "        \"\"\"Perform the required steps when initializing airflow for standalone mode.",
            "",
            "        If necessary, returns the username and password to be printed in the console for users to log in.",
            "        \"\"\"",
            "        return None, None",
            "",
            "    def add_limit_view(self, baseview):",
            "        if not baseview.limits:",
            "            return",
            "",
            "        for limit in baseview.limits:",
            "            self.limiter.limit(",
            "                limit_value=limit.limit_value,",
            "                key_func=limit.key_func,",
            "                per_method=limit.per_method,",
            "                methods=limit.methods,",
            "                error_message=limit.error_message,",
            "                exempt_when=limit.exempt_when,",
            "                override_defaults=limit.override_defaults,",
            "                deduct_when=limit.deduct_when,",
            "                on_breach=limit.on_breach,",
            "                cost=limit.cost,",
            "            )(baseview.blueprint)",
            "",
            "    @cached_property",
            "    @provide_session",
            "    def _auth_manager_is_authorized_map(",
            "        self, session: Session = NEW_SESSION",
            "    ) -> dict[str, Callable[[str, str | None, BaseUser | None], bool]]:",
            "        \"\"\"",
            "        Return the map associating a FAB resource name to the corresponding auth manager is_authorized_ API.",
            "",
            "        The function returned takes the FAB action name and the user as parameter.",
            "        \"\"\"",
            "        auth_manager = get_auth_manager()",
            "        methods = get_method_from_fab_action_map()",
            "",
            "        def get_connection_id(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            connection = session.scalar(select(Connection).where(Connection.id == resource_pk).limit(1))",
            "            if not connection:",
            "                raise AirflowException(\"Connection not found\")",
            "            return connection.conn_id",
            "",
            "        def get_dag_id_from_dagrun_id(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            dagrun = session.scalar(select(DagRun).where(DagRun.id == resource_pk).limit(1))",
            "            if not dagrun:",
            "                raise AirflowException(\"DagRun not found\")",
            "            return dagrun.dag_id",
            "",
            "        def get_dag_id_from_task_instance(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            composite_pk = json.loads(resource_pk)",
            "            ti = session.scalar(",
            "                select(DagRun)",
            "                .where(",
            "                    TaskInstance.dag_id == composite_pk[0],",
            "                    TaskInstance.task_id == composite_pk[1],",
            "                    TaskInstance.run_id == composite_pk[2],",
            "                    TaskInstance.map_index >= composite_pk[3],",
            "                )",
            "                .limit(1)",
            "            )",
            "            if not ti:",
            "                raise AirflowException(\"Task instance not found\")",
            "            return ti.dag_id",
            "",
            "        def get_pool_name(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            pool = session.scalar(select(Pool).where(Pool.id == resource_pk).limit(1))",
            "            if not pool:",
            "                raise AirflowException(\"Pool not found\")",
            "            return pool.pool",
            "",
            "        def get_variable_key(resource_pk):",
            "            if not resource_pk:",
            "                return None",
            "            variable = session.scalar(select(Variable).where(Variable.id == resource_pk).limit(1))",
            "            if not variable:",
            "                raise AirflowException(\"Connection not found\")",
            "            return variable.key",
            "",
            "        return {",
            "            RESOURCE_AUDIT_LOG: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.AUDIT_LOG,",
            "                user=user,",
            "            ),",
            "            RESOURCE_CLUSTER_ACTIVITY: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.CLUSTER_ACTIVITY,",
            "                user=user,",
            "            ),",
            "            RESOURCE_CONFIG: lambda action, resource_pk, user: auth_manager.is_authorized_configuration(",
            "                method=methods[action],",
            "                user=user,",
            "            ),",
            "            RESOURCE_CONNECTION: lambda action, resource_pk, user: auth_manager.is_authorized_connection(",
            "                method=methods[action],",
            "                details=ConnectionDetails(conn_id=get_connection_id(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_DAG: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                user=user,",
            "            ),",
            "            RESOURCE_DAG_CODE: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.CODE,",
            "                user=user,",
            "            ),",
            "            RESOURCE_DAG_DEPENDENCIES: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.DEPENDENCIES,",
            "                user=user,",
            "            ),",
            "            RESOURCE_DAG_RUN: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.RUN,",
            "                details=DagDetails(id=get_dag_id_from_dagrun_id(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_DATASET: lambda action, resource_pk, user: auth_manager.is_authorized_dataset(",
            "                method=methods[action],",
            "                user=user,",
            "            ),",
            "            RESOURCE_DOCS: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.DOCS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_PLUGIN: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.PLUGINS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_JOB: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.JOBS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_POOL: lambda action, resource_pk, user: auth_manager.is_authorized_pool(",
            "                method=methods[action],",
            "                details=PoolDetails(name=get_pool_name(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_PROVIDER: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.PROVIDERS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_SLA_MISS: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.SLA_MISS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_TASK_INSTANCE: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.TASK_INSTANCE,",
            "                details=DagDetails(id=get_dag_id_from_task_instance(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_TASK_RESCHEDULE: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.TASK_RESCHEDULE,",
            "                user=user,",
            "            ),",
            "            RESOURCE_TRIGGER: lambda action, resource_pk, user: auth_manager.is_authorized_view(",
            "                access_view=AccessView.TRIGGERS,",
            "                user=user,",
            "            ),",
            "            RESOURCE_VARIABLE: lambda action, resource_pk, user: auth_manager.is_authorized_variable(",
            "                method=methods[action],",
            "                details=VariableDetails(key=get_variable_key(resource_pk)),",
            "                user=user,",
            "            ),",
            "            RESOURCE_XCOM: lambda action, resource_pk, user: auth_manager.is_authorized_dag(",
            "                method=methods[action],",
            "                access_entity=DagAccessEntity.XCOM,",
            "                user=user,",
            "            ),",
            "        }",
            "",
            "    def _get_auth_manager_is_authorized_method(self, fab_resource_name: str) -> Callable:",
            "        is_authorized_method = self._auth_manager_is_authorized_map.get(fab_resource_name)",
            "        if is_authorized_method:",
            "            return is_authorized_method",
            "        elif fab_resource_name in [RESOURCE_DOCS_MENU, RESOURCE_ADMIN_MENU, RESOURCE_BROWSE_MENU]:",
            "            # Display the \"Browse\", \"Admin\" and \"Docs\" dropdowns in the menu if the user has access to at",
            "            # least one dropdown child",
            "            return self._is_authorized_category_menu(fab_resource_name)",
            "        else:",
            "            # This means the page the user is trying to access is specific to the auth manager used",
            "            # Example: the user list view in FabAuthManager",
            "            return lambda action, resource_pk, user: get_auth_manager().is_authorized_custom_view(",
            "                fab_action_name=action,",
            "                fab_resource_name=fab_resource_name,",
            "                user=user,",
            "            )",
            "",
            "    def _is_authorized_category_menu(self, category: str) -> Callable:",
            "        items = {item.name for item in self.appbuilder.menu.find(category).childs}",
            "        return lambda action, resource_pk, user: any(",
            "            self._get_auth_manager_is_authorized_method(fab_resource_name=item)(action, resource_pk, user)",
            "            for item in items",
            "        )",
            "",
            "    \"\"\"",
            "    The following methods are specific to FAB auth manager. They still need to be \"present\" in the main",
            "    security manager class, but they do nothing.",
            "    \"\"\"",
            "",
            "    def get_action(self, name: str) -> Action:",
            "        raise NotImplementedError(\"Only available if FAB auth manager is used\")",
            "",
            "    def get_resource(self, name: str) -> Resource:",
            "        raise NotImplementedError(\"Only available if FAB auth manager is used\")",
            "",
            "    def add_permissions_view(self, base_action_names, resource_name):",
            "        pass",
            "",
            "    def add_permissions_menu(self, resource_name):",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "42": [],
            "43": [],
            "343": [
                "AirflowSecurityManagerV2",
                "_get_auth_manager_is_authorized_method"
            ]
        },
        "addLocation": []
    }
}