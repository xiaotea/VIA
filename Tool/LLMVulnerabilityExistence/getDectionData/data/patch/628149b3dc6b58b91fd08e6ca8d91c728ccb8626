{
    "keystone/identity/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "             raise exception.UserNotFound(user_id=user_id)"
            },
            "1": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 409,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "         user_ref = self.identity_api.update_user(context, user_id, user)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+        # If the password was changed or the user was disabled we clear tokens"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+        if user.get('password') or user.get('enabled', True) == False:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+            try:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+                for token_id in self.token_api.list_tokens(context, user_id):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+                    self.token_api.delete_token(context, token_id)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+            except exception.NotImplemented:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+                # The users status has been changed but tokens remain valid for"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+                # backends that can't list tokens for users"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+                LOG.warning('User %s status has changed, but existing tokens '"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+                            'remain valid' % user_id)"
            },
            "14": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 422,
                "PatchRowcode": "         return {'user': user_ref}"
            },
            "15": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 423,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 424,
                "PatchRowcode": "     def delete_user(self, context, user_id):"
            },
            "17": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "         return self.update_user(context, user_id, user)"
            },
            "18": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 433,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "     def set_user_password(self, context, user_id, user):"
            },
            "20": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_ref = self.update_user(context, user_id, user)"
            },
            "21": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "22": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for token_id in self.token_api.list_tokens(context, user_id):"
            },
            "23": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.token_api.delete_token(context, token_id)"
            },
            "24": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except exception.NotImplemented:"
            },
            "25": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # The password has been changed but tokens remain valid for"
            },
            "26": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # backends that can't list tokens for users"
            },
            "27": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            LOG.warning('Password changed for %s, but existing tokens remain '"
            },
            "28": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        'valid' % user_id)"
            },
            "29": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return user_ref"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 435,
                "PatchRowcode": "+        return self.update_user(context, user_id, user)"
            },
            "31": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 436,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "     def update_user_tenant(self, context, user_id, user):"
            },
            "33": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "         \"\"\"Update the default tenant.\"\"\""
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "\"\"\"Main entry point into the Identity service.\"\"\"",
            "",
            "import uuid",
            "import urllib",
            "import urlparse",
            "",
            "from keystone import config",
            "from keystone import exception",
            "from keystone import policy",
            "from keystone import token",
            "from keystone.common import logging",
            "from keystone.common import manager",
            "from keystone.common import wsgi",
            "",
            "",
            "CONF = config.CONF",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class Manager(manager.Manager):",
            "    \"\"\"Default pivot point for the Identity backend.",
            "",
            "    See :mod:`keystone.common.manager.Manager` for more details on how this",
            "    dynamically calls the backend.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super(Manager, self).__init__(CONF.identity.driver)",
            "",
            "",
            "class Driver(object):",
            "    \"\"\"Interface description for an Identity driver.\"\"\"",
            "",
            "    def authenticate(self, user_id=None, tenant_id=None, password=None):",
            "        \"\"\"Authenticate a given user, tenant and password.",
            "",
            "        Returns: (user, tenant, metadata).",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_tenant(self, tenant_id):",
            "        \"\"\"Get a tenant by id.",
            "",
            "        Returns: tenant_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_tenant_by_name(self, tenant_name):",
            "        \"\"\"Get a tenant by name.",
            "",
            "        Returns: tenant_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_user(self, user_id):",
            "        \"\"\"Get a user by id.",
            "",
            "        Returns: user_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_user_by_name(self, user_name):",
            "        \"\"\"Get a user by name.",
            "",
            "        Returns: user_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_role(self, role_id):",
            "        \"\"\"Get a role by id.",
            "",
            "        Returns: role_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def list_users(self):",
            "        \"\"\"List all users in the system.",
            "",
            "        NOTE(termie): I'd prefer if this listed only the users for a given",
            "                      tenant.",
            "",
            "        Returns: a list of user_refs or an empty list.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def list_roles(self):",
            "        \"\"\"List all roles in the system.",
            "",
            "        Returns: a list of role_refs or an empty list.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    # NOTE(termie): seven calls below should probably be exposed by the api",
            "    #               more clearly when the api redesign happens",
            "    def add_user_to_tenant(self, tenant_id, user_id):",
            "        raise exception.NotImplemented()",
            "",
            "    def remove_user_from_tenant(self, tenant_id, user_id):",
            "        raise exception.NotImplemented()",
            "",
            "    def get_all_tenants(self):",
            "        raise exception.NotImplemented()",
            "",
            "    def get_tenants_for_user(self, user_id):",
            "        \"\"\"Get the tenants associated with a given user.",
            "",
            "        Returns: a list of tenant ids.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_roles_for_user_and_tenant(self, user_id, tenant_id):",
            "        \"\"\"Get the roles associated with a user within given tenant.",
            "",
            "        Returns: a list of role ids.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def add_role_to_user_and_tenant(self, user_id, tenant_id, role_id):",
            "        \"\"\"Add a role to a user within given tenant.\"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def remove_role_from_user_and_tenant(self, user_id, tenant_id, role_id):",
            "        \"\"\"Remove a role from a user within given tenant.\"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    # user crud",
            "    def create_user(self, user_id, user):",
            "        raise exception.NotImplemented()",
            "",
            "    def update_user(self, user_id, user):",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_user(self, user_id):",
            "        raise exception.NotImplemented()",
            "",
            "    # tenant crud",
            "    def create_tenant(self, tenant_id, tenant):",
            "        raise exception.NotImplemented()",
            "",
            "    def update_tenant(self, tenant_id, tenant):",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_tenant(self, tenant_id, tenant):",
            "        raise exception.NotImplemented()",
            "",
            "    # metadata crud",
            "",
            "    def get_metadata(self, user_id, tenant_id):",
            "        raise exception.NotImplemented()",
            "",
            "    def create_metadata(self, user_id, tenant_id, metadata):",
            "        raise exception.NotImplemented()",
            "",
            "    def update_metadata(self, user_id, tenant_id, metadata):",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_metadata(self, user_id, tenant_id, metadata):",
            "        raise exception.NotImplemented()",
            "",
            "    # role crud",
            "    def create_role(self, role_id, role):",
            "        raise exception.NotImplemented()",
            "",
            "    def update_role(self, role_id, role):",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_role(self, role_id):",
            "        raise exception.NotImplemented()",
            "",
            "",
            "class PublicRouter(wsgi.ComposableRouter):",
            "    def add_routes(self, mapper):",
            "        tenant_controller = TenantController()",
            "        mapper.connect('/tenants',",
            "                       controller=tenant_controller,",
            "                       action='get_tenants_for_token',",
            "                       conditions=dict(methods=['GET']))",
            "",
            "",
            "class AdminRouter(wsgi.ComposableRouter):",
            "    def add_routes(self, mapper):",
            "        # Tenant Operations",
            "        tenant_controller = TenantController()",
            "        mapper.connect('/tenants',",
            "                       controller=tenant_controller,",
            "                       action='get_all_tenants',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/tenants/{tenant_id}',",
            "                       controller=tenant_controller,",
            "                       action='get_tenant',",
            "                       conditions=dict(method=['GET']))",
            "",
            "        # User Operations",
            "        user_controller = UserController()",
            "        mapper.connect('/users/{user_id}',",
            "                       controller=user_controller,",
            "                       action='get_user',",
            "                       conditions=dict(method=['GET']))",
            "",
            "        # Role Operations",
            "        roles_controller = RoleController()",
            "        mapper.connect('/tenants/{tenant_id}/users/{user_id}/roles',",
            "                       controller=roles_controller,",
            "                       action='get_user_roles',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/users/{user_id}/roles',",
            "                       controller=user_controller,",
            "                       action='get_user_roles',",
            "                       conditions=dict(method=['GET']))",
            "",
            "",
            "class TenantController(wsgi.Application):",
            "    def __init__(self):",
            "        self.identity_api = Manager()",
            "        self.policy_api = policy.Manager()",
            "        self.token_api = token.Manager()",
            "        super(TenantController, self).__init__()",
            "",
            "    def get_all_tenants(self, context, **kw):",
            "        \"\"\"Gets a list of all tenants for an admin user.\"\"\"",
            "        self.assert_admin(context)",
            "        tenant_refs = self.identity_api.get_tenants(context)",
            "        params = {",
            "            'limit': context['query_string'].get('limit'),",
            "            'marker': context['query_string'].get('marker'),",
            "        }",
            "        return self._format_tenant_list(tenant_refs, **params)",
            "",
            "    def get_tenants_for_token(self, context, **kw):",
            "        \"\"\"Get valid tenants for token based on token used to authenticate.",
            "",
            "        Pulls the token from the context, validates it and gets the valid",
            "        tenants for the user in the token.",
            "",
            "        Doesn't care about token scopedness.",
            "",
            "        \"\"\"",
            "        try:",
            "            token_ref = self.token_api.get_token(context=context,",
            "                                                 token_id=context['token_id'])",
            "        except exception.NotFound:",
            "            raise exception.Unauthorized()",
            "",
            "        user_ref = token_ref['user']",
            "        tenant_ids = self.identity_api.get_tenants_for_user(",
            "                context, user_ref['id'])",
            "        tenant_refs = []",
            "        for tenant_id in tenant_ids:",
            "            tenant_refs.append(self.identity_api.get_tenant(",
            "                    context=context,",
            "                    tenant_id=tenant_id))",
            "        params = {",
            "            'limit': context['query_string'].get('limit'),",
            "            'marker': context['query_string'].get('marker'),",
            "        }",
            "        return self._format_tenant_list(tenant_refs, **params)",
            "",
            "    def get_tenant(self, context, tenant_id):",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "        tenant = self.identity_api.get_tenant(context, tenant_id)",
            "        if tenant is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        return {'tenant': tenant}",
            "",
            "    # CRUD Extension",
            "    def create_tenant(self, context, tenant):",
            "        tenant_ref = self._normalize_dict(tenant)",
            "        self.assert_admin(context)",
            "        tenant_id = (tenant_ref.get('id')",
            "                     and tenant_ref.get('id')",
            "                     or uuid.uuid4().hex)",
            "        tenant_ref['id'] = tenant_id",
            "",
            "        tenant = self.identity_api.create_tenant(",
            "                context, tenant_id, tenant_ref)",
            "        return {'tenant': tenant}",
            "",
            "    def update_tenant(self, context, tenant_id, tenant):",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        tenant_ref = self.identity_api.update_tenant(",
            "                context, tenant_id, tenant)",
            "        return {'tenant': tenant_ref}",
            "",
            "    def delete_tenant(self, context, tenant_id, **kw):",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        self.identity_api.delete_tenant(context, tenant_id)",
            "",
            "    def get_tenant_users(self, context, tenant_id, **kw):",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        user_refs = self.identity_api.get_tenant_users(context, tenant_id)",
            "        return {'users': user_refs}",
            "",
            "    def _format_tenant_list(self, tenant_refs, **kwargs):",
            "        marker = kwargs.get('marker')",
            "        page_idx = 0",
            "        if marker is not None:",
            "            for (marker_idx, tenant) in enumerate(tenant_refs):",
            "                if tenant['id'] == marker:",
            "                    # we start pagination after the marker",
            "                    page_idx = marker_idx + 1",
            "                    break",
            "            else:",
            "                msg = 'Marker could not be found'",
            "                raise exception.ValidationError(message=msg)",
            "",
            "        limit = kwargs.get('limit')",
            "        if limit is not None:",
            "            try:",
            "                limit = int(limit)",
            "                if limit < 0:",
            "                    raise AssertionError()",
            "            except (ValueError, AssertionError):",
            "                msg = 'Invalid limit value'",
            "                raise exception.ValidationError(message=msg)",
            "",
            "        tenant_refs = tenant_refs[page_idx:limit]",
            "",
            "        for x in tenant_refs:",
            "            if 'enabled' not in x:",
            "                x['enabled'] = True",
            "        o = {'tenants': tenant_refs,",
            "             'tenants_links': []}",
            "        return o",
            "",
            "",
            "class UserController(wsgi.Application):",
            "    def __init__(self):",
            "        self.identity_api = Manager()",
            "        self.policy_api = policy.Manager()",
            "        self.token_api = token.Manager()",
            "        super(UserController, self).__init__()",
            "",
            "    def get_user(self, context, user_id):",
            "        self.assert_admin(context)",
            "        user_ref = self.identity_api.get_user(context, user_id)",
            "        if not user_ref:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "",
            "        return {'user': user_ref}",
            "",
            "    def get_users(self, context):",
            "        # NOTE(termie): i can't imagine that this really wants all the data",
            "        #               about every single user in the system...",
            "        self.assert_admin(context)",
            "        user_refs = self.identity_api.list_users(context)",
            "        return {'users': user_refs}",
            "",
            "    # CRUD extension",
            "    def create_user(self, context, user):",
            "        user = self._normalize_dict(user)",
            "        self.assert_admin(context)",
            "        tenant_id = user.get('tenantId', None)",
            "        if (tenant_id is not None",
            "                and self.identity_api.get_tenant(context, tenant_id) is None):",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "        user_id = uuid.uuid4().hex",
            "        user_ref = user.copy()",
            "        user_ref['id'] = user_id",
            "        new_user_ref = self.identity_api.create_user(",
            "                context, user_id, user_ref)",
            "        if tenant_id:",
            "            self.identity_api.add_user_to_tenant(context, tenant_id, user_id)",
            "        return {'user': new_user_ref}",
            "",
            "    def update_user(self, context, user_id, user):",
            "        # NOTE(termie): this is really more of a patch than a put",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_user(context, user_id) is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "",
            "        user_ref = self.identity_api.update_user(context, user_id, user)",
            "        return {'user': user_ref}",
            "",
            "    def delete_user(self, context, user_id):",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_user(context, user_id) is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "",
            "        self.identity_api.delete_user(context, user_id)",
            "",
            "    def set_user_enabled(self, context, user_id, user):",
            "        return self.update_user(context, user_id, user)",
            "",
            "    def set_user_password(self, context, user_id, user):",
            "        user_ref = self.update_user(context, user_id, user)",
            "        try:",
            "            for token_id in self.token_api.list_tokens(context, user_id):",
            "                self.token_api.delete_token(context, token_id)",
            "        except exception.NotImplemented:",
            "            # The password has been changed but tokens remain valid for",
            "            # backends that can't list tokens for users",
            "            LOG.warning('Password changed for %s, but existing tokens remain '",
            "                        'valid' % user_id)",
            "        return user_ref",
            "",
            "    def update_user_tenant(self, context, user_id, user):",
            "        \"\"\"Update the default tenant.\"\"\"",
            "        # ensure that we're a member of that tenant",
            "        tenant_id = user.get('tenantId')",
            "        self.identity_api.add_user_to_tenant(context, tenant_id, user_id)",
            "        return self.update_user(context, user_id, user)",
            "",
            "",
            "class RoleController(wsgi.Application):",
            "    def __init__(self):",
            "        self.identity_api = Manager()",
            "        self.token_api = token.Manager()",
            "        self.policy_api = policy.Manager()",
            "        super(RoleController, self).__init__()",
            "",
            "    # COMPAT(essex-3)",
            "    def get_user_roles(self, context, user_id, tenant_id=None):",
            "        \"\"\"Get the roles for a user and tenant pair.",
            "",
            "        Since we're trying to ignore the idea of user-only roles we're",
            "        not implementing them in hopes that the idea will die off.",
            "",
            "        \"\"\"",
            "        if tenant_id is None:",
            "            raise exception.NotImplemented(message='User roles not supported: '",
            "                                                   'tenant ID required')",
            "",
            "        user = self.identity_api.get_user(context, user_id)",
            "        if user is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "        tenant = self.identity_api.get_tenant(context, tenant_id)",
            "        if tenant is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        roles = self.identity_api.get_roles_for_user_and_tenant(",
            "                context, user_id, tenant_id)",
            "        return {'roles': [self.identity_api.get_role(context, x)",
            "                          for x in roles]}",
            "",
            "    # CRUD extension",
            "    def get_role(self, context, role_id):",
            "        self.assert_admin(context)",
            "        role_ref = self.identity_api.get_role(context, role_id)",
            "        if not role_ref:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "        return {'role': role_ref}",
            "",
            "    def create_role(self, context, role):",
            "        role = self._normalize_dict(role)",
            "        self.assert_admin(context)",
            "        role_id = uuid.uuid4().hex",
            "        role['id'] = role_id",
            "        role_ref = self.identity_api.create_role(context, role_id, role)",
            "        return {'role': role_ref}",
            "",
            "    def delete_role(self, context, role_id):",
            "        self.assert_admin(context)",
            "        self.get_role(context, role_id)",
            "        self.identity_api.delete_role(context, role_id)",
            "",
            "    def get_roles(self, context):",
            "        self.assert_admin(context)",
            "        roles = self.identity_api.list_roles(context)",
            "        # TODO(termie): probably inefficient at some point",
            "        return {'roles': roles}",
            "",
            "    def add_role_to_user(self, context, user_id, role_id, tenant_id=None):",
            "        \"\"\"Add a role to a user and tenant pair.",
            "",
            "        Since we're trying to ignore the idea of user-only roles we're",
            "        not implementing them in hopes that the idea will die off.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        if tenant_id is None:",
            "            raise exception.NotImplemented(message='User roles not supported: '",
            "                                                   'tenant_id required')",
            "        if self.identity_api.get_user(context, user_id) is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "        if self.identity_api.get_role(context, role_id) is None:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "",
            "        # This still has the weird legacy semantics that adding a role to",
            "        # a user also adds them to a tenant",
            "        self.identity_api.add_user_to_tenant(context, tenant_id, user_id)",
            "        self.identity_api.add_role_to_user_and_tenant(",
            "                context, user_id, tenant_id, role_id)",
            "        role_ref = self.identity_api.get_role(context, role_id)",
            "        return {'role': role_ref}",
            "",
            "    def remove_role_from_user(self, context, user_id, role_id, tenant_id=None):",
            "        \"\"\"Remove a role from a user and tenant pair.",
            "",
            "        Since we're trying to ignore the idea of user-only roles we're",
            "        not implementing them in hopes that the idea will die off.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        if tenant_id is None:",
            "            raise exception.NotImplemented(message='User roles not supported: '",
            "                                                   'tenant_id required')",
            "        if self.identity_api.get_user(context, user_id) is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "        if self.identity_api.get_role(context, role_id) is None:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "",
            "        # This still has the weird legacy semantics that adding a role to",
            "        # a user also adds them to a tenant, so we must follow up on that",
            "        self.identity_api.remove_role_from_user_and_tenant(",
            "                context, user_id, tenant_id, role_id)",
            "        roles = self.identity_api.get_roles_for_user_and_tenant(",
            "                context, user_id, tenant_id)",
            "        if not roles:",
            "            self.identity_api.remove_user_from_tenant(",
            "                    context, tenant_id, user_id)",
            "        return",
            "",
            "    # COMPAT(diablo): CRUD extension",
            "    def get_role_refs(self, context, user_id):",
            "        \"\"\"Ultimate hack to get around having to make role_refs first-class.",
            "",
            "        This will basically iterate over the various roles the user has in",
            "        all tenants the user is a member of and create fake role_refs where",
            "        the id encodes the user-tenant-role information so we can look",
            "        up the appropriate data when we need to delete them.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        user_ref = self.identity_api.get_user(context, user_id)",
            "        tenant_ids = self.identity_api.get_tenants_for_user(context, user_id)",
            "        o = []",
            "        for tenant_id in tenant_ids:",
            "            role_ids = self.identity_api.get_roles_for_user_and_tenant(",
            "                    context, user_id, tenant_id)",
            "            for role_id in role_ids:",
            "                ref = {'roleId': role_id,",
            "                       'tenantId': tenant_id,",
            "                       'userId': user_id}",
            "                ref['id'] = urllib.urlencode(ref)",
            "                o.append(ref)",
            "        return {'roles': o}",
            "",
            "    # COMPAT(diablo): CRUD extension",
            "    def create_role_ref(self, context, user_id, role):",
            "        \"\"\"This is actually used for adding a user to a tenant.",
            "",
            "        In the legacy data model adding a user to a tenant required setting",
            "        a role.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        # TODO(termie): for now we're ignoring the actual role",
            "        tenant_id = role.get('tenantId')",
            "        role_id = role.get('roleId')",
            "        self.identity_api.add_user_to_tenant(context, tenant_id, user_id)",
            "        self.identity_api.add_role_to_user_and_tenant(",
            "                context, user_id, tenant_id, role_id)",
            "        role_ref = self.identity_api.get_role(context, role_id)",
            "        return {'role': role_ref}",
            "",
            "    # COMPAT(diablo): CRUD extension",
            "    def delete_role_ref(self, context, user_id, role_ref_id):",
            "        \"\"\"This is actually used for deleting a user from a tenant.",
            "",
            "        In the legacy data model removing a user from a tenant required",
            "        deleting a role.",
            "",
            "        To emulate this, we encode the tenant and role in the role_ref_id,",
            "        and if this happens to be the last role for the user-tenant pair,",
            "        we remove the user from the tenant.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        # TODO(termie): for now we're ignoring the actual role",
            "        role_ref_ref = urlparse.parse_qs(role_ref_id)",
            "        tenant_id = role_ref_ref.get('tenantId')[0]",
            "        role_id = role_ref_ref.get('roleId')[0]",
            "        self.identity_api.remove_role_from_user_and_tenant(",
            "                context, user_id, tenant_id, role_id)",
            "        roles = self.identity_api.get_roles_for_user_and_tenant(",
            "                context, user_id, tenant_id)",
            "        if not roles:",
            "            self.identity_api.remove_user_from_tenant(",
            "                    context, tenant_id, user_id)"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "\"\"\"Main entry point into the Identity service.\"\"\"",
            "",
            "import uuid",
            "import urllib",
            "import urlparse",
            "",
            "from keystone import config",
            "from keystone import exception",
            "from keystone import policy",
            "from keystone import token",
            "from keystone.common import logging",
            "from keystone.common import manager",
            "from keystone.common import wsgi",
            "",
            "",
            "CONF = config.CONF",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class Manager(manager.Manager):",
            "    \"\"\"Default pivot point for the Identity backend.",
            "",
            "    See :mod:`keystone.common.manager.Manager` for more details on how this",
            "    dynamically calls the backend.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super(Manager, self).__init__(CONF.identity.driver)",
            "",
            "",
            "class Driver(object):",
            "    \"\"\"Interface description for an Identity driver.\"\"\"",
            "",
            "    def authenticate(self, user_id=None, tenant_id=None, password=None):",
            "        \"\"\"Authenticate a given user, tenant and password.",
            "",
            "        Returns: (user, tenant, metadata).",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_tenant(self, tenant_id):",
            "        \"\"\"Get a tenant by id.",
            "",
            "        Returns: tenant_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_tenant_by_name(self, tenant_name):",
            "        \"\"\"Get a tenant by name.",
            "",
            "        Returns: tenant_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_user(self, user_id):",
            "        \"\"\"Get a user by id.",
            "",
            "        Returns: user_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_user_by_name(self, user_name):",
            "        \"\"\"Get a user by name.",
            "",
            "        Returns: user_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_role(self, role_id):",
            "        \"\"\"Get a role by id.",
            "",
            "        Returns: role_ref or None.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def list_users(self):",
            "        \"\"\"List all users in the system.",
            "",
            "        NOTE(termie): I'd prefer if this listed only the users for a given",
            "                      tenant.",
            "",
            "        Returns: a list of user_refs or an empty list.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def list_roles(self):",
            "        \"\"\"List all roles in the system.",
            "",
            "        Returns: a list of role_refs or an empty list.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    # NOTE(termie): seven calls below should probably be exposed by the api",
            "    #               more clearly when the api redesign happens",
            "    def add_user_to_tenant(self, tenant_id, user_id):",
            "        raise exception.NotImplemented()",
            "",
            "    def remove_user_from_tenant(self, tenant_id, user_id):",
            "        raise exception.NotImplemented()",
            "",
            "    def get_all_tenants(self):",
            "        raise exception.NotImplemented()",
            "",
            "    def get_tenants_for_user(self, user_id):",
            "        \"\"\"Get the tenants associated with a given user.",
            "",
            "        Returns: a list of tenant ids.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def get_roles_for_user_and_tenant(self, user_id, tenant_id):",
            "        \"\"\"Get the roles associated with a user within given tenant.",
            "",
            "        Returns: a list of role ids.",
            "",
            "        \"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def add_role_to_user_and_tenant(self, user_id, tenant_id, role_id):",
            "        \"\"\"Add a role to a user within given tenant.\"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def remove_role_from_user_and_tenant(self, user_id, tenant_id, role_id):",
            "        \"\"\"Remove a role from a user within given tenant.\"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    # user crud",
            "    def create_user(self, user_id, user):",
            "        raise exception.NotImplemented()",
            "",
            "    def update_user(self, user_id, user):",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_user(self, user_id):",
            "        raise exception.NotImplemented()",
            "",
            "    # tenant crud",
            "    def create_tenant(self, tenant_id, tenant):",
            "        raise exception.NotImplemented()",
            "",
            "    def update_tenant(self, tenant_id, tenant):",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_tenant(self, tenant_id, tenant):",
            "        raise exception.NotImplemented()",
            "",
            "    # metadata crud",
            "",
            "    def get_metadata(self, user_id, tenant_id):",
            "        raise exception.NotImplemented()",
            "",
            "    def create_metadata(self, user_id, tenant_id, metadata):",
            "        raise exception.NotImplemented()",
            "",
            "    def update_metadata(self, user_id, tenant_id, metadata):",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_metadata(self, user_id, tenant_id, metadata):",
            "        raise exception.NotImplemented()",
            "",
            "    # role crud",
            "    def create_role(self, role_id, role):",
            "        raise exception.NotImplemented()",
            "",
            "    def update_role(self, role_id, role):",
            "        raise exception.NotImplemented()",
            "",
            "    def delete_role(self, role_id):",
            "        raise exception.NotImplemented()",
            "",
            "",
            "class PublicRouter(wsgi.ComposableRouter):",
            "    def add_routes(self, mapper):",
            "        tenant_controller = TenantController()",
            "        mapper.connect('/tenants',",
            "                       controller=tenant_controller,",
            "                       action='get_tenants_for_token',",
            "                       conditions=dict(methods=['GET']))",
            "",
            "",
            "class AdminRouter(wsgi.ComposableRouter):",
            "    def add_routes(self, mapper):",
            "        # Tenant Operations",
            "        tenant_controller = TenantController()",
            "        mapper.connect('/tenants',",
            "                       controller=tenant_controller,",
            "                       action='get_all_tenants',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/tenants/{tenant_id}',",
            "                       controller=tenant_controller,",
            "                       action='get_tenant',",
            "                       conditions=dict(method=['GET']))",
            "",
            "        # User Operations",
            "        user_controller = UserController()",
            "        mapper.connect('/users/{user_id}',",
            "                       controller=user_controller,",
            "                       action='get_user',",
            "                       conditions=dict(method=['GET']))",
            "",
            "        # Role Operations",
            "        roles_controller = RoleController()",
            "        mapper.connect('/tenants/{tenant_id}/users/{user_id}/roles',",
            "                       controller=roles_controller,",
            "                       action='get_user_roles',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/users/{user_id}/roles',",
            "                       controller=user_controller,",
            "                       action='get_user_roles',",
            "                       conditions=dict(method=['GET']))",
            "",
            "",
            "class TenantController(wsgi.Application):",
            "    def __init__(self):",
            "        self.identity_api = Manager()",
            "        self.policy_api = policy.Manager()",
            "        self.token_api = token.Manager()",
            "        super(TenantController, self).__init__()",
            "",
            "    def get_all_tenants(self, context, **kw):",
            "        \"\"\"Gets a list of all tenants for an admin user.\"\"\"",
            "        self.assert_admin(context)",
            "        tenant_refs = self.identity_api.get_tenants(context)",
            "        params = {",
            "            'limit': context['query_string'].get('limit'),",
            "            'marker': context['query_string'].get('marker'),",
            "        }",
            "        return self._format_tenant_list(tenant_refs, **params)",
            "",
            "    def get_tenants_for_token(self, context, **kw):",
            "        \"\"\"Get valid tenants for token based on token used to authenticate.",
            "",
            "        Pulls the token from the context, validates it and gets the valid",
            "        tenants for the user in the token.",
            "",
            "        Doesn't care about token scopedness.",
            "",
            "        \"\"\"",
            "        try:",
            "            token_ref = self.token_api.get_token(context=context,",
            "                                                 token_id=context['token_id'])",
            "        except exception.NotFound:",
            "            raise exception.Unauthorized()",
            "",
            "        user_ref = token_ref['user']",
            "        tenant_ids = self.identity_api.get_tenants_for_user(",
            "                context, user_ref['id'])",
            "        tenant_refs = []",
            "        for tenant_id in tenant_ids:",
            "            tenant_refs.append(self.identity_api.get_tenant(",
            "                    context=context,",
            "                    tenant_id=tenant_id))",
            "        params = {",
            "            'limit': context['query_string'].get('limit'),",
            "            'marker': context['query_string'].get('marker'),",
            "        }",
            "        return self._format_tenant_list(tenant_refs, **params)",
            "",
            "    def get_tenant(self, context, tenant_id):",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "        tenant = self.identity_api.get_tenant(context, tenant_id)",
            "        if tenant is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        return {'tenant': tenant}",
            "",
            "    # CRUD Extension",
            "    def create_tenant(self, context, tenant):",
            "        tenant_ref = self._normalize_dict(tenant)",
            "        self.assert_admin(context)",
            "        tenant_id = (tenant_ref.get('id')",
            "                     and tenant_ref.get('id')",
            "                     or uuid.uuid4().hex)",
            "        tenant_ref['id'] = tenant_id",
            "",
            "        tenant = self.identity_api.create_tenant(",
            "                context, tenant_id, tenant_ref)",
            "        return {'tenant': tenant}",
            "",
            "    def update_tenant(self, context, tenant_id, tenant):",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        tenant_ref = self.identity_api.update_tenant(",
            "                context, tenant_id, tenant)",
            "        return {'tenant': tenant_ref}",
            "",
            "    def delete_tenant(self, context, tenant_id, **kw):",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        self.identity_api.delete_tenant(context, tenant_id)",
            "",
            "    def get_tenant_users(self, context, tenant_id, **kw):",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        user_refs = self.identity_api.get_tenant_users(context, tenant_id)",
            "        return {'users': user_refs}",
            "",
            "    def _format_tenant_list(self, tenant_refs, **kwargs):",
            "        marker = kwargs.get('marker')",
            "        page_idx = 0",
            "        if marker is not None:",
            "            for (marker_idx, tenant) in enumerate(tenant_refs):",
            "                if tenant['id'] == marker:",
            "                    # we start pagination after the marker",
            "                    page_idx = marker_idx + 1",
            "                    break",
            "            else:",
            "                msg = 'Marker could not be found'",
            "                raise exception.ValidationError(message=msg)",
            "",
            "        limit = kwargs.get('limit')",
            "        if limit is not None:",
            "            try:",
            "                limit = int(limit)",
            "                if limit < 0:",
            "                    raise AssertionError()",
            "            except (ValueError, AssertionError):",
            "                msg = 'Invalid limit value'",
            "                raise exception.ValidationError(message=msg)",
            "",
            "        tenant_refs = tenant_refs[page_idx:limit]",
            "",
            "        for x in tenant_refs:",
            "            if 'enabled' not in x:",
            "                x['enabled'] = True",
            "        o = {'tenants': tenant_refs,",
            "             'tenants_links': []}",
            "        return o",
            "",
            "",
            "class UserController(wsgi.Application):",
            "    def __init__(self):",
            "        self.identity_api = Manager()",
            "        self.policy_api = policy.Manager()",
            "        self.token_api = token.Manager()",
            "        super(UserController, self).__init__()",
            "",
            "    def get_user(self, context, user_id):",
            "        self.assert_admin(context)",
            "        user_ref = self.identity_api.get_user(context, user_id)",
            "        if not user_ref:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "",
            "        return {'user': user_ref}",
            "",
            "    def get_users(self, context):",
            "        # NOTE(termie): i can't imagine that this really wants all the data",
            "        #               about every single user in the system...",
            "        self.assert_admin(context)",
            "        user_refs = self.identity_api.list_users(context)",
            "        return {'users': user_refs}",
            "",
            "    # CRUD extension",
            "    def create_user(self, context, user):",
            "        user = self._normalize_dict(user)",
            "        self.assert_admin(context)",
            "        tenant_id = user.get('tenantId', None)",
            "        if (tenant_id is not None",
            "                and self.identity_api.get_tenant(context, tenant_id) is None):",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "        user_id = uuid.uuid4().hex",
            "        user_ref = user.copy()",
            "        user_ref['id'] = user_id",
            "        new_user_ref = self.identity_api.create_user(",
            "                context, user_id, user_ref)",
            "        if tenant_id:",
            "            self.identity_api.add_user_to_tenant(context, tenant_id, user_id)",
            "        return {'user': new_user_ref}",
            "",
            "    def update_user(self, context, user_id, user):",
            "        # NOTE(termie): this is really more of a patch than a put",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_user(context, user_id) is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "",
            "        user_ref = self.identity_api.update_user(context, user_id, user)",
            "",
            "        # If the password was changed or the user was disabled we clear tokens",
            "        if user.get('password') or user.get('enabled', True) == False:",
            "            try:",
            "                for token_id in self.token_api.list_tokens(context, user_id):",
            "                    self.token_api.delete_token(context, token_id)",
            "            except exception.NotImplemented:",
            "                # The users status has been changed but tokens remain valid for",
            "                # backends that can't list tokens for users",
            "                LOG.warning('User %s status has changed, but existing tokens '",
            "                            'remain valid' % user_id)",
            "        return {'user': user_ref}",
            "",
            "    def delete_user(self, context, user_id):",
            "        self.assert_admin(context)",
            "        if self.identity_api.get_user(context, user_id) is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "",
            "        self.identity_api.delete_user(context, user_id)",
            "",
            "    def set_user_enabled(self, context, user_id, user):",
            "        return self.update_user(context, user_id, user)",
            "",
            "    def set_user_password(self, context, user_id, user):",
            "        return self.update_user(context, user_id, user)",
            "",
            "    def update_user_tenant(self, context, user_id, user):",
            "        \"\"\"Update the default tenant.\"\"\"",
            "        # ensure that we're a member of that tenant",
            "        tenant_id = user.get('tenantId')",
            "        self.identity_api.add_user_to_tenant(context, tenant_id, user_id)",
            "        return self.update_user(context, user_id, user)",
            "",
            "",
            "class RoleController(wsgi.Application):",
            "    def __init__(self):",
            "        self.identity_api = Manager()",
            "        self.token_api = token.Manager()",
            "        self.policy_api = policy.Manager()",
            "        super(RoleController, self).__init__()",
            "",
            "    # COMPAT(essex-3)",
            "    def get_user_roles(self, context, user_id, tenant_id=None):",
            "        \"\"\"Get the roles for a user and tenant pair.",
            "",
            "        Since we're trying to ignore the idea of user-only roles we're",
            "        not implementing them in hopes that the idea will die off.",
            "",
            "        \"\"\"",
            "        if tenant_id is None:",
            "            raise exception.NotImplemented(message='User roles not supported: '",
            "                                                   'tenant ID required')",
            "",
            "        user = self.identity_api.get_user(context, user_id)",
            "        if user is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "        tenant = self.identity_api.get_tenant(context, tenant_id)",
            "        if tenant is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "",
            "        roles = self.identity_api.get_roles_for_user_and_tenant(",
            "                context, user_id, tenant_id)",
            "        return {'roles': [self.identity_api.get_role(context, x)",
            "                          for x in roles]}",
            "",
            "    # CRUD extension",
            "    def get_role(self, context, role_id):",
            "        self.assert_admin(context)",
            "        role_ref = self.identity_api.get_role(context, role_id)",
            "        if not role_ref:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "        return {'role': role_ref}",
            "",
            "    def create_role(self, context, role):",
            "        role = self._normalize_dict(role)",
            "        self.assert_admin(context)",
            "        role_id = uuid.uuid4().hex",
            "        role['id'] = role_id",
            "        role_ref = self.identity_api.create_role(context, role_id, role)",
            "        return {'role': role_ref}",
            "",
            "    def delete_role(self, context, role_id):",
            "        self.assert_admin(context)",
            "        self.get_role(context, role_id)",
            "        self.identity_api.delete_role(context, role_id)",
            "",
            "    def get_roles(self, context):",
            "        self.assert_admin(context)",
            "        roles = self.identity_api.list_roles(context)",
            "        # TODO(termie): probably inefficient at some point",
            "        return {'roles': roles}",
            "",
            "    def add_role_to_user(self, context, user_id, role_id, tenant_id=None):",
            "        \"\"\"Add a role to a user and tenant pair.",
            "",
            "        Since we're trying to ignore the idea of user-only roles we're",
            "        not implementing them in hopes that the idea will die off.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        if tenant_id is None:",
            "            raise exception.NotImplemented(message='User roles not supported: '",
            "                                                   'tenant_id required')",
            "        if self.identity_api.get_user(context, user_id) is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "        if self.identity_api.get_role(context, role_id) is None:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "",
            "        # This still has the weird legacy semantics that adding a role to",
            "        # a user also adds them to a tenant",
            "        self.identity_api.add_user_to_tenant(context, tenant_id, user_id)",
            "        self.identity_api.add_role_to_user_and_tenant(",
            "                context, user_id, tenant_id, role_id)",
            "        role_ref = self.identity_api.get_role(context, role_id)",
            "        return {'role': role_ref}",
            "",
            "    def remove_role_from_user(self, context, user_id, role_id, tenant_id=None):",
            "        \"\"\"Remove a role from a user and tenant pair.",
            "",
            "        Since we're trying to ignore the idea of user-only roles we're",
            "        not implementing them in hopes that the idea will die off.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        if tenant_id is None:",
            "            raise exception.NotImplemented(message='User roles not supported: '",
            "                                                   'tenant_id required')",
            "        if self.identity_api.get_user(context, user_id) is None:",
            "            raise exception.UserNotFound(user_id=user_id)",
            "        if self.identity_api.get_tenant(context, tenant_id) is None:",
            "            raise exception.TenantNotFound(tenant_id=tenant_id)",
            "        if self.identity_api.get_role(context, role_id) is None:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "",
            "        # This still has the weird legacy semantics that adding a role to",
            "        # a user also adds them to a tenant, so we must follow up on that",
            "        self.identity_api.remove_role_from_user_and_tenant(",
            "                context, user_id, tenant_id, role_id)",
            "        roles = self.identity_api.get_roles_for_user_and_tenant(",
            "                context, user_id, tenant_id)",
            "        if not roles:",
            "            self.identity_api.remove_user_from_tenant(",
            "                    context, tenant_id, user_id)",
            "        return",
            "",
            "    # COMPAT(diablo): CRUD extension",
            "    def get_role_refs(self, context, user_id):",
            "        \"\"\"Ultimate hack to get around having to make role_refs first-class.",
            "",
            "        This will basically iterate over the various roles the user has in",
            "        all tenants the user is a member of and create fake role_refs where",
            "        the id encodes the user-tenant-role information so we can look",
            "        up the appropriate data when we need to delete them.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        user_ref = self.identity_api.get_user(context, user_id)",
            "        tenant_ids = self.identity_api.get_tenants_for_user(context, user_id)",
            "        o = []",
            "        for tenant_id in tenant_ids:",
            "            role_ids = self.identity_api.get_roles_for_user_and_tenant(",
            "                    context, user_id, tenant_id)",
            "            for role_id in role_ids:",
            "                ref = {'roleId': role_id,",
            "                       'tenantId': tenant_id,",
            "                       'userId': user_id}",
            "                ref['id'] = urllib.urlencode(ref)",
            "                o.append(ref)",
            "        return {'roles': o}",
            "",
            "    # COMPAT(diablo): CRUD extension",
            "    def create_role_ref(self, context, user_id, role):",
            "        \"\"\"This is actually used for adding a user to a tenant.",
            "",
            "        In the legacy data model adding a user to a tenant required setting",
            "        a role.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        # TODO(termie): for now we're ignoring the actual role",
            "        tenant_id = role.get('tenantId')",
            "        role_id = role.get('roleId')",
            "        self.identity_api.add_user_to_tenant(context, tenant_id, user_id)",
            "        self.identity_api.add_role_to_user_and_tenant(",
            "                context, user_id, tenant_id, role_id)",
            "        role_ref = self.identity_api.get_role(context, role_id)",
            "        return {'role': role_ref}",
            "",
            "    # COMPAT(diablo): CRUD extension",
            "    def delete_role_ref(self, context, user_id, role_ref_id):",
            "        \"\"\"This is actually used for deleting a user from a tenant.",
            "",
            "        In the legacy data model removing a user from a tenant required",
            "        deleting a role.",
            "",
            "        To emulate this, we encode the tenant and role in the role_ref_id,",
            "        and if this happens to be the last role for the user-tenant pair,",
            "        we remove the user from the tenant.",
            "",
            "        \"\"\"",
            "        self.assert_admin(context)",
            "        # TODO(termie): for now we're ignoring the actual role",
            "        role_ref_ref = urlparse.parse_qs(role_ref_id)",
            "        tenant_id = role_ref_ref.get('tenantId')[0]",
            "        role_id = role_ref_ref.get('roleId')[0]",
            "        self.identity_api.remove_role_from_user_and_tenant(",
            "                context, user_id, tenant_id, role_id)",
            "        roles = self.identity_api.get_roles_for_user_and_tenant(",
            "                context, user_id, tenant_id)",
            "        if not roles:",
            "            self.identity_api.remove_user_from_tenant(",
            "                    context, tenant_id, user_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "424": [
                "UserController",
                "set_user_password"
            ],
            "425": [
                "UserController",
                "set_user_password"
            ],
            "426": [
                "UserController",
                "set_user_password"
            ],
            "427": [
                "UserController",
                "set_user_password"
            ],
            "428": [
                "UserController",
                "set_user_password"
            ],
            "429": [
                "UserController",
                "set_user_password"
            ],
            "430": [
                "UserController",
                "set_user_password"
            ],
            "431": [
                "UserController",
                "set_user_password"
            ],
            "432": [
                "UserController",
                "set_user_password"
            ],
            "433": [
                "UserController",
                "set_user_password"
            ]
        },
        "addLocation": [
            "keystone.identity.core.UserController.set_user_enabled",
            "keystone.identity.core.UserController.set_user_password",
            "keystone.identity.core.UserController.update_user_tenant",
            "knowledge_repo.app.routes.comment"
        ]
    },
    "keystone/service.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from keystone.common import wsgi"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+LOG = logging.getLogger(__name__)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " class AdminRouter(wsgi.ComposingRouter):"
            },
            "7": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     def __init__(self):"
            },
            "8": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         mapper = routes.Mapper()"
            },
            "9": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "                 # If the user is disabled don't allow them to authenticate"
            },
            "11": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "                 if not user_ref.get('enabled', True):"
            },
            "12": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise exception.Forbidden(message='User has been disabled')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+                    LOG.warning('User %s is disabled' % user_id)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+                    raise exception.Unauthorized()"
            },
            "15": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "             except AssertionError as e:"
            },
            "16": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "                 raise exception.Unauthorized(e.message)"
            },
            "17": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 285,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 318,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 319,
                "PatchRowcode": "             user_ref = old_token_ref['user']"
            },
            "20": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 320,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+            # If the user is disabled don't allow them to authenticate"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+            current_user_ref = self.identity_api.get_user("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+                                                    context=context,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+                                                    user_id=user_ref['id'])"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+            if not current_user_ref.get('enabled', True):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+                LOG.warning('User %s is disabled' % user_ref['id'])"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+                raise exception.Unauthorized()"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "             tenants = self.identity_api.get_tenants_for_user(context,"
            },
            "30": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "                                                              user_ref['id'])"
            },
            "31": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "             if tenant_id:"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import uuid",
            "",
            "import routes",
            "",
            "from keystone import catalog",
            "from keystone import exception",
            "from keystone import identity",
            "from keystone import policy",
            "from keystone import token",
            "from keystone.common import logging",
            "from keystone.common import utils",
            "from keystone.common import wsgi",
            "",
            "",
            "class AdminRouter(wsgi.ComposingRouter):",
            "    def __init__(self):",
            "        mapper = routes.Mapper()",
            "",
            "        version_controller = VersionController('admin')",
            "        mapper.connect('/',",
            "                       controller=version_controller,",
            "                       action='get_version')",
            "",
            "        # Token Operations",
            "        auth_controller = TokenController()",
            "        mapper.connect('/tokens',",
            "                       controller=auth_controller,",
            "                       action='authenticate',",
            "                       conditions=dict(method=['POST']))",
            "        mapper.connect('/tokens/{token_id}',",
            "                       controller=auth_controller,",
            "                       action='validate_token',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/tokens/{token_id}',",
            "                       controller=auth_controller,",
            "                       action='validate_token_head',",
            "                       conditions=dict(method=['HEAD']))",
            "        mapper.connect('/tokens/{token_id}',",
            "                       controller=auth_controller,",
            "                       action='delete_token',",
            "                       conditions=dict(method=['DELETE']))",
            "        mapper.connect('/tokens/{token_id}/endpoints',",
            "                       controller=auth_controller,",
            "                       action='endpoints',",
            "                       conditions=dict(method=['GET']))",
            "",
            "        # Miscellaneous Operations",
            "        extensions_controller = AdminExtensionsController()",
            "        mapper.connect('/extensions',",
            "                       controller=extensions_controller,",
            "                       action='get_extensions_info',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/extensions/{extension_alias}',",
            "                       controller=extensions_controller,",
            "                       action='get_extension_info',",
            "                       conditions=dict(method=['GET']))",
            "        identity_router = identity.AdminRouter()",
            "        routers = [identity_router]",
            "        super(AdminRouter, self).__init__(mapper, routers)",
            "",
            "",
            "class PublicRouter(wsgi.ComposingRouter):",
            "    def __init__(self):",
            "        mapper = routes.Mapper()",
            "",
            "        version_controller = VersionController('public')",
            "        mapper.connect('/',",
            "                       controller=version_controller,",
            "                       action='get_version')",
            "",
            "        # Token Operations",
            "        auth_controller = TokenController()",
            "        mapper.connect('/tokens',",
            "                       controller=auth_controller,",
            "                       action='authenticate',",
            "                       conditions=dict(method=['POST']))",
            "",
            "        # Miscellaneous",
            "        extensions_controller = PublicExtensionsController()",
            "        mapper.connect('/extensions',",
            "                       controller=extensions_controller,",
            "                       action='get_extensions_info',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/extensions/{extension_alias}',",
            "                       controller=extensions_controller,",
            "                       action='get_extension_info',",
            "                       conditions=dict(method=['GET']))",
            "",
            "        identity_router = identity.PublicRouter()",
            "        routers = [identity_router]",
            "",
            "        super(PublicRouter, self).__init__(mapper, routers)",
            "",
            "",
            "class PublicVersionRouter(wsgi.ComposingRouter):",
            "    def __init__(self):",
            "        mapper = routes.Mapper()",
            "        version_controller = VersionController('public')",
            "        mapper.connect('/',",
            "                       controller=version_controller,",
            "                       action='get_versions')",
            "        routers = []",
            "        super(PublicVersionRouter, self).__init__(mapper, routers)",
            "",
            "",
            "class AdminVersionRouter(wsgi.ComposingRouter):",
            "    def __init__(self):",
            "        mapper = routes.Mapper()",
            "        version_controller = VersionController('admin')",
            "        mapper.connect('/',",
            "                       controller=version_controller,",
            "                       action='get_versions')",
            "        routers = []",
            "        super(AdminVersionRouter, self).__init__(mapper, routers)",
            "",
            "",
            "class VersionController(wsgi.Application):",
            "    def __init__(self, version_type):",
            "        self.catalog_api = catalog.Manager()",
            "        self.url_key = \"%sURL\" % version_type",
            "",
            "        super(VersionController, self).__init__()",
            "",
            "    def _get_identity_url(self, context):",
            "        catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=None,",
            "                tenant_id=None)",
            "        for region, region_ref in catalog_ref.iteritems():",
            "            for service, service_ref in region_ref.iteritems():",
            "                if service == 'identity':",
            "                    return service_ref[self.url_key]",
            "",
            "        raise exception.NotImplemented()",
            "",
            "    def _get_versions_list(self, context):",
            "        \"\"\"The list of versions is dependent on the context.\"\"\"",
            "        identity_url = self._get_identity_url(context)",
            "        if not identity_url.endswith('/'):",
            "            identity_url = identity_url + '/'",
            "",
            "        versions = {}",
            "        versions['v2.0'] = {",
            "            \"id\": \"v2.0\",",
            "            \"status\": \"beta\",",
            "            \"updated\": \"2011-11-19T00:00:00Z\",",
            "            \"links\": [",
            "                {",
            "                    \"rel\": \"self\",",
            "                    \"href\": identity_url,",
            "                }, {",
            "                    \"rel\": \"describedby\",",
            "                    \"type\": \"text/html\",",
            "                    \"href\": \"http://docs.openstack.org/api/openstack-\"",
            "                                \"identity-service/2.0/content/\"",
            "                }, {",
            "                    \"rel\": \"describedby\",",
            "                    \"type\": \"application/pdf\",",
            "                    \"href\": \"http://docs.openstack.org/api/openstack-\"",
            "                                \"identity-service/2.0/identity-dev-guide-\"",
            "                                \"2.0.pdf\"",
            "                }",
            "            ],",
            "            \"media-types\": [",
            "                {",
            "                    \"base\": \"application/json\",",
            "                    \"type\": \"application/vnd.openstack.identity-v2.0\"",
            "                                \"+json\"",
            "                }, {",
            "                    \"base\": \"application/xml\",",
            "                    \"type\": \"application/vnd.openstack.identity-v2.0\"",
            "                                \"+xml\"",
            "                }",
            "            ]",
            "        }",
            "",
            "        return versions",
            "",
            "    def get_versions(self, context):",
            "        versions = self._get_versions_list(context)",
            "        return wsgi.render_response(status=(300, 'Multiple Choices'), body={",
            "            \"versions\": {",
            "                \"values\": versions.values()",
            "            }",
            "        })",
            "",
            "    def get_version(self, context):",
            "        versions = self._get_versions_list(context)",
            "        return wsgi.render_response(body={",
            "            \"version\": versions['v2.0']",
            "        })",
            "",
            "",
            "class NoopController(wsgi.Application):",
            "    def __init__(self):",
            "        super(NoopController, self).__init__()",
            "",
            "    def noop(self, context):",
            "        return {}",
            "",
            "",
            "class TokenController(wsgi.Application):",
            "    def __init__(self):",
            "        self.catalog_api = catalog.Manager()",
            "        self.identity_api = identity.Manager()",
            "        self.token_api = token.Manager()",
            "        self.policy_api = policy.Manager()",
            "        super(TokenController, self).__init__()",
            "",
            "    def authenticate(self, context, auth=None):",
            "        \"\"\"Authenticate credentials and return a token.",
            "",
            "        Accept auth as a dict that looks like::",
            "",
            "            {",
            "                \"auth\":{",
            "                    \"passwordCredentials\":{",
            "                        \"username\":\"test_user\",",
            "                        \"password\":\"mypass\"",
            "                    },",
            "                    \"tenantName\":\"customer-x\"",
            "                }",
            "            }",
            "",
            "        In this case, tenant is optional, if not provided the token will be",
            "        considered \"unscoped\" and can later be used to get a scoped token.",
            "",
            "        Alternatively, this call accepts auth with only a token and tenant",
            "        that will return a token that is scoped to that tenant.",
            "        \"\"\"",
            "",
            "        token_id = uuid.uuid4().hex",
            "        if 'passwordCredentials' in auth:",
            "            username = auth['passwordCredentials'].get('username', '')",
            "            password = auth['passwordCredentials'].get('password', '')",
            "            tenant_name = auth.get('tenantName', None)",
            "",
            "            user_id = auth['passwordCredentials'].get('userId', None)",
            "            if username:",
            "                user_ref = self.identity_api.get_user_by_name(",
            "                        context=context, user_name=username)",
            "                if user_ref:",
            "                    user_id = user_ref['id']",
            "",
            "            # more compat",
            "            tenant_id = auth.get('tenantId', None)",
            "            if tenant_name:",
            "                tenant_ref = self.identity_api.get_tenant_by_name(",
            "                        context=context, tenant_name=tenant_name)",
            "                if tenant_ref:",
            "                    tenant_id = tenant_ref['id']",
            "",
            "            try:",
            "                auth_info = self.identity_api.authenticate(context=context,",
            "                                                           user_id=user_id,",
            "                                                           password=password,",
            "                                                           tenant_id=tenant_id)",
            "                (user_ref, tenant_ref, metadata_ref) = auth_info",
            "",
            "                # If the user is disabled don't allow them to authenticate",
            "                if not user_ref.get('enabled', True):",
            "                    raise exception.Forbidden(message='User has been disabled')",
            "            except AssertionError as e:",
            "                raise exception.Unauthorized(e.message)",
            "",
            "            token_ref = self.token_api.create_token(",
            "                    context, token_id, dict(id=token_id,",
            "                                            user=user_ref,",
            "                                            tenant=tenant_ref,",
            "                                            metadata=metadata_ref))",
            "            if tenant_ref:",
            "                catalog_ref = self.catalog_api.get_catalog(",
            "                        context=context,",
            "                        user_id=user_ref['id'],",
            "                        tenant_id=tenant_ref['id'],",
            "                        metadata=metadata_ref)",
            "            else:",
            "                catalog_ref = {}",
            "",
            "        elif 'token' in auth:",
            "            token = auth['token'].get('id', None)",
            "",
            "            tenant_name = auth.get('tenantName')",
            "",
            "            # more compat",
            "            if tenant_name:",
            "                tenant_ref = self.identity_api.get_tenant_by_name(",
            "                        context=context, tenant_name=tenant_name)",
            "                tenant_id = tenant_ref['id']",
            "            else:",
            "                tenant_id = auth.get('tenantId', None)",
            "",
            "            try:",
            "                old_token_ref = self.token_api.get_token(context=context,",
            "                                                         token_id=token)",
            "            except exception.NotFound:",
            "                raise exception.Unauthorized()",
            "",
            "            user_ref = old_token_ref['user']",
            "",
            "            tenants = self.identity_api.get_tenants_for_user(context,",
            "                                                             user_ref['id'])",
            "            if tenant_id:",
            "                assert tenant_id in tenants",
            "",
            "            tenant_ref = self.identity_api.get_tenant(context=context,",
            "                                                      tenant_id=tenant_id)",
            "            if tenant_ref:",
            "                metadata_ref = self.identity_api.get_metadata(",
            "                        context=context,",
            "                        user_id=user_ref['id'],",
            "                        tenant_id=tenant_ref['id'])",
            "                catalog_ref = self.catalog_api.get_catalog(",
            "                        context=context,",
            "                        user_id=user_ref['id'],",
            "                        tenant_id=tenant_ref['id'],",
            "                        metadata=metadata_ref)",
            "            else:",
            "                metadata_ref = {}",
            "                catalog_ref = {}",
            "",
            "            token_ref = self.token_api.create_token(",
            "                    context, token_id, dict(id=token_id,",
            "                                            user=user_ref,",
            "                                            tenant=tenant_ref,",
            "                                            metadata=metadata_ref))",
            "",
            "        # TODO(termie): optimize this call at some point and put it into the",
            "        #               the return for metadata",
            "        # fill out the roles in the metadata",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            roles_ref.append(self.identity_api.get_role(context, role_id))",
            "        logging.debug('TOKEN_REF %s', token_ref)",
            "        return self._format_authenticate(token_ref, roles_ref, catalog_ref)",
            "",
            "    def _get_token_ref(self, context, token_id, belongs_to=None):",
            "        \"\"\"Returns a token if a valid one exists.",
            "",
            "        Optionally, limited to a token owned by a specific tenant.",
            "",
            "        \"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "",
            "        token_ref = self.token_api.get_token(context=context,",
            "                                             token_id=token_id)",
            "",
            "        if belongs_to:",
            "            assert token_ref['tenant']['id'] == belongs_to",
            "",
            "        return token_ref",
            "",
            "    # admin only",
            "    def validate_token_head(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Identical to ``validate_token``, except does not return a response.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get(\"belongsTo\")",
            "        assert self._get_token_ref(context, token_id, belongs_to)",
            "",
            "    # admin only",
            "    def validate_token(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Returns metadata about the token along any associated roles.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get(\"belongsTo\")",
            "        token_ref = self._get_token_ref(context, token_id, belongs_to)",
            "",
            "        # TODO(termie): optimize this call at some point and put it into the",
            "        #               the return for metadata",
            "        # fill out the roles in the metadata",
            "        metadata_ref = token_ref['metadata']",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            roles_ref.append(self.identity_api.get_role(context, role_id))",
            "",
            "        # Get a service catalog if belongs_to is not none",
            "        # This is needed for on-behalf-of requests",
            "        catalog_ref = None",
            "        if belongs_to is not None:",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=token_ref['user']['id'],",
            "                tenant_id=token_ref['tenant']['id'],",
            "                metadata=metadata_ref)",
            "        return self._format_token(token_ref, roles_ref, catalog_ref)",
            "",
            "    def delete_token(self, context, token_id):",
            "        \"\"\"Delete a token, effectively invalidating it for authz.\"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "",
            "        self.token_api.delete_token(context=context, token_id=token_id)",
            "",
            "    def endpoints(self, context, token_id):",
            "        \"\"\"Return a list of endpoints available to the token.\"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def _format_authenticate(self, token_ref, roles_ref, catalog_ref):",
            "        o = self._format_token(token_ref, roles_ref)",
            "        o['access']['serviceCatalog'] = self._format_catalog(catalog_ref)",
            "        return o",
            "",
            "    def _format_token(self, token_ref, roles_ref, catalog_ref=None):",
            "        user_ref = token_ref['user']",
            "        metadata_ref = token_ref['metadata']",
            "        expires = token_ref['expires']",
            "        if expires is not None:",
            "            expires = utils.isotime(expires)",
            "        o = {'access': {'token': {'id': token_ref['id'],",
            "                                  'expires': expires,",
            "                                  },",
            "                        'user': {'id': user_ref['id'],",
            "                                 'name': user_ref['name'],",
            "                                 'username': user_ref['name'],",
            "                                 'roles': roles_ref,",
            "                                 'roles_links': metadata_ref.get('roles_links',",
            "                                                               [])",
            "                                 }",
            "                        }",
            "             }",
            "        if 'tenant' in token_ref and token_ref['tenant']:",
            "            token_ref['tenant']['enabled'] = True",
            "            o['access']['token']['tenant'] = token_ref['tenant']",
            "        if catalog_ref is not None:",
            "            o['access']['serviceCatalog'] = self._format_catalog(catalog_ref)",
            "        return o",
            "",
            "    def _format_catalog(self, catalog_ref):",
            "        \"\"\"Munge catalogs from internal to output format",
            "        Internal catalogs look like:",
            "",
            "        {$REGION: {",
            "            {$SERVICE: {",
            "                $key1: $value1,",
            "                ...",
            "                }",
            "            }",
            "        }",
            "",
            "        The legacy api wants them to look like",
            "",
            "        [{'name': $SERVICE[name],",
            "          'type': $SERVICE,",
            "          'endpoints': [{",
            "              'tenantId': $tenant_id,",
            "              ...",
            "              'region': $REGION,",
            "              }],",
            "          'endpoints_links': [],",
            "         }]",
            "",
            "        \"\"\"",
            "        if not catalog_ref:",
            "            return {}",
            "",
            "        services = {}",
            "        for region, region_ref in catalog_ref.iteritems():",
            "            for service, service_ref in region_ref.iteritems():",
            "                new_service_ref = services.get(service, {})",
            "                new_service_ref['name'] = service_ref.pop('name')",
            "                new_service_ref['type'] = service",
            "                new_service_ref['endpoints_links'] = []",
            "                service_ref['region'] = region",
            "",
            "                endpoints_ref = new_service_ref.get('endpoints', [])",
            "                endpoints_ref.append(service_ref)",
            "",
            "                new_service_ref['endpoints'] = endpoints_ref",
            "                services[service] = new_service_ref",
            "",
            "        return services.values()",
            "",
            "",
            "class ExtensionsController(wsgi.Application):",
            "    \"\"\"Base extensions controller to be extended by public and admin API's.\"\"\"",
            "",
            "    def __init__(self, extensions=None):",
            "        super(ExtensionsController, self).__init__()",
            "",
            "        self.extensions = extensions or {}",
            "",
            "    def get_extensions_info(self, context):",
            "        return {'extensions': {'values': self.extensions.values()}}",
            "",
            "    def get_extension_info(self, context, extension_alias):",
            "        try:",
            "            return {'extension': self.extensions[extension_alias]}",
            "        except KeyError:",
            "            raise exception.NotFound(target=extension_alias)",
            "",
            "",
            "class PublicExtensionsController(ExtensionsController):",
            "    pass",
            "",
            "",
            "class AdminExtensionsController(ExtensionsController):",
            "    def __init__(self, *args, **kwargs):",
            "        super(AdminExtensionsController, self).__init__(*args, **kwargs)",
            "",
            "        # TODO(dolph): Extensions should obviously provide this information",
            "        #               themselves, but hardcoding it here allows us to match",
            "        #               the API spec in the short term with minimal complexity.",
            "        self.extensions['OS-KSADM'] = {",
            "            'name': 'Openstack Keystone Admin',",
            "            'namespace': 'http://docs.openstack.org/identity/api/ext/'",
            "                         'OS-KSADM/v1.0',",
            "            'alias': 'OS-KSADM',",
            "            'updated': '2011-08-19T13:25:27-06:00',",
            "            'description': 'Openstack extensions to Keystone v2.0 API '",
            "                           'enabling Admin Operations.',",
            "            'links': [",
            "                {",
            "                    'rel': 'describedby',",
            "                    # TODO(dolph): link needs to be revised after",
            "                    #              bug 928059 merges",
            "                    'type': 'text/html',",
            "                    'href': ('https://github.com/openstack/'",
            "                        'identity-api'),",
            "                }",
            "            ]",
            "        }",
            "",
            "",
            "@logging.fail_gracefully",
            "def public_app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return PublicRouter()",
            "",
            "",
            "@logging.fail_gracefully",
            "def admin_app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return AdminRouter()",
            "",
            "",
            "@logging.fail_gracefully",
            "def public_version_app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return PublicVersionRouter()",
            "",
            "",
            "@logging.fail_gracefully",
            "def admin_version_app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return AdminVersionRouter()"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import uuid",
            "",
            "import routes",
            "",
            "from keystone import catalog",
            "from keystone import exception",
            "from keystone import identity",
            "from keystone import policy",
            "from keystone import token",
            "from keystone.common import logging",
            "from keystone.common import utils",
            "from keystone.common import wsgi",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class AdminRouter(wsgi.ComposingRouter):",
            "    def __init__(self):",
            "        mapper = routes.Mapper()",
            "",
            "        version_controller = VersionController('admin')",
            "        mapper.connect('/',",
            "                       controller=version_controller,",
            "                       action='get_version')",
            "",
            "        # Token Operations",
            "        auth_controller = TokenController()",
            "        mapper.connect('/tokens',",
            "                       controller=auth_controller,",
            "                       action='authenticate',",
            "                       conditions=dict(method=['POST']))",
            "        mapper.connect('/tokens/{token_id}',",
            "                       controller=auth_controller,",
            "                       action='validate_token',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/tokens/{token_id}',",
            "                       controller=auth_controller,",
            "                       action='validate_token_head',",
            "                       conditions=dict(method=['HEAD']))",
            "        mapper.connect('/tokens/{token_id}',",
            "                       controller=auth_controller,",
            "                       action='delete_token',",
            "                       conditions=dict(method=['DELETE']))",
            "        mapper.connect('/tokens/{token_id}/endpoints',",
            "                       controller=auth_controller,",
            "                       action='endpoints',",
            "                       conditions=dict(method=['GET']))",
            "",
            "        # Miscellaneous Operations",
            "        extensions_controller = AdminExtensionsController()",
            "        mapper.connect('/extensions',",
            "                       controller=extensions_controller,",
            "                       action='get_extensions_info',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/extensions/{extension_alias}',",
            "                       controller=extensions_controller,",
            "                       action='get_extension_info',",
            "                       conditions=dict(method=['GET']))",
            "        identity_router = identity.AdminRouter()",
            "        routers = [identity_router]",
            "        super(AdminRouter, self).__init__(mapper, routers)",
            "",
            "",
            "class PublicRouter(wsgi.ComposingRouter):",
            "    def __init__(self):",
            "        mapper = routes.Mapper()",
            "",
            "        version_controller = VersionController('public')",
            "        mapper.connect('/',",
            "                       controller=version_controller,",
            "                       action='get_version')",
            "",
            "        # Token Operations",
            "        auth_controller = TokenController()",
            "        mapper.connect('/tokens',",
            "                       controller=auth_controller,",
            "                       action='authenticate',",
            "                       conditions=dict(method=['POST']))",
            "",
            "        # Miscellaneous",
            "        extensions_controller = PublicExtensionsController()",
            "        mapper.connect('/extensions',",
            "                       controller=extensions_controller,",
            "                       action='get_extensions_info',",
            "                       conditions=dict(method=['GET']))",
            "        mapper.connect('/extensions/{extension_alias}',",
            "                       controller=extensions_controller,",
            "                       action='get_extension_info',",
            "                       conditions=dict(method=['GET']))",
            "",
            "        identity_router = identity.PublicRouter()",
            "        routers = [identity_router]",
            "",
            "        super(PublicRouter, self).__init__(mapper, routers)",
            "",
            "",
            "class PublicVersionRouter(wsgi.ComposingRouter):",
            "    def __init__(self):",
            "        mapper = routes.Mapper()",
            "        version_controller = VersionController('public')",
            "        mapper.connect('/',",
            "                       controller=version_controller,",
            "                       action='get_versions')",
            "        routers = []",
            "        super(PublicVersionRouter, self).__init__(mapper, routers)",
            "",
            "",
            "class AdminVersionRouter(wsgi.ComposingRouter):",
            "    def __init__(self):",
            "        mapper = routes.Mapper()",
            "        version_controller = VersionController('admin')",
            "        mapper.connect('/',",
            "                       controller=version_controller,",
            "                       action='get_versions')",
            "        routers = []",
            "        super(AdminVersionRouter, self).__init__(mapper, routers)",
            "",
            "",
            "class VersionController(wsgi.Application):",
            "    def __init__(self, version_type):",
            "        self.catalog_api = catalog.Manager()",
            "        self.url_key = \"%sURL\" % version_type",
            "",
            "        super(VersionController, self).__init__()",
            "",
            "    def _get_identity_url(self, context):",
            "        catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=None,",
            "                tenant_id=None)",
            "        for region, region_ref in catalog_ref.iteritems():",
            "            for service, service_ref in region_ref.iteritems():",
            "                if service == 'identity':",
            "                    return service_ref[self.url_key]",
            "",
            "        raise exception.NotImplemented()",
            "",
            "    def _get_versions_list(self, context):",
            "        \"\"\"The list of versions is dependent on the context.\"\"\"",
            "        identity_url = self._get_identity_url(context)",
            "        if not identity_url.endswith('/'):",
            "            identity_url = identity_url + '/'",
            "",
            "        versions = {}",
            "        versions['v2.0'] = {",
            "            \"id\": \"v2.0\",",
            "            \"status\": \"beta\",",
            "            \"updated\": \"2011-11-19T00:00:00Z\",",
            "            \"links\": [",
            "                {",
            "                    \"rel\": \"self\",",
            "                    \"href\": identity_url,",
            "                }, {",
            "                    \"rel\": \"describedby\",",
            "                    \"type\": \"text/html\",",
            "                    \"href\": \"http://docs.openstack.org/api/openstack-\"",
            "                                \"identity-service/2.0/content/\"",
            "                }, {",
            "                    \"rel\": \"describedby\",",
            "                    \"type\": \"application/pdf\",",
            "                    \"href\": \"http://docs.openstack.org/api/openstack-\"",
            "                                \"identity-service/2.0/identity-dev-guide-\"",
            "                                \"2.0.pdf\"",
            "                }",
            "            ],",
            "            \"media-types\": [",
            "                {",
            "                    \"base\": \"application/json\",",
            "                    \"type\": \"application/vnd.openstack.identity-v2.0\"",
            "                                \"+json\"",
            "                }, {",
            "                    \"base\": \"application/xml\",",
            "                    \"type\": \"application/vnd.openstack.identity-v2.0\"",
            "                                \"+xml\"",
            "                }",
            "            ]",
            "        }",
            "",
            "        return versions",
            "",
            "    def get_versions(self, context):",
            "        versions = self._get_versions_list(context)",
            "        return wsgi.render_response(status=(300, 'Multiple Choices'), body={",
            "            \"versions\": {",
            "                \"values\": versions.values()",
            "            }",
            "        })",
            "",
            "    def get_version(self, context):",
            "        versions = self._get_versions_list(context)",
            "        return wsgi.render_response(body={",
            "            \"version\": versions['v2.0']",
            "        })",
            "",
            "",
            "class NoopController(wsgi.Application):",
            "    def __init__(self):",
            "        super(NoopController, self).__init__()",
            "",
            "    def noop(self, context):",
            "        return {}",
            "",
            "",
            "class TokenController(wsgi.Application):",
            "    def __init__(self):",
            "        self.catalog_api = catalog.Manager()",
            "        self.identity_api = identity.Manager()",
            "        self.token_api = token.Manager()",
            "        self.policy_api = policy.Manager()",
            "        super(TokenController, self).__init__()",
            "",
            "    def authenticate(self, context, auth=None):",
            "        \"\"\"Authenticate credentials and return a token.",
            "",
            "        Accept auth as a dict that looks like::",
            "",
            "            {",
            "                \"auth\":{",
            "                    \"passwordCredentials\":{",
            "                        \"username\":\"test_user\",",
            "                        \"password\":\"mypass\"",
            "                    },",
            "                    \"tenantName\":\"customer-x\"",
            "                }",
            "            }",
            "",
            "        In this case, tenant is optional, if not provided the token will be",
            "        considered \"unscoped\" and can later be used to get a scoped token.",
            "",
            "        Alternatively, this call accepts auth with only a token and tenant",
            "        that will return a token that is scoped to that tenant.",
            "        \"\"\"",
            "",
            "        token_id = uuid.uuid4().hex",
            "        if 'passwordCredentials' in auth:",
            "            username = auth['passwordCredentials'].get('username', '')",
            "            password = auth['passwordCredentials'].get('password', '')",
            "            tenant_name = auth.get('tenantName', None)",
            "",
            "            user_id = auth['passwordCredentials'].get('userId', None)",
            "            if username:",
            "                user_ref = self.identity_api.get_user_by_name(",
            "                        context=context, user_name=username)",
            "                if user_ref:",
            "                    user_id = user_ref['id']",
            "",
            "            # more compat",
            "            tenant_id = auth.get('tenantId', None)",
            "            if tenant_name:",
            "                tenant_ref = self.identity_api.get_tenant_by_name(",
            "                        context=context, tenant_name=tenant_name)",
            "                if tenant_ref:",
            "                    tenant_id = tenant_ref['id']",
            "",
            "            try:",
            "                auth_info = self.identity_api.authenticate(context=context,",
            "                                                           user_id=user_id,",
            "                                                           password=password,",
            "                                                           tenant_id=tenant_id)",
            "                (user_ref, tenant_ref, metadata_ref) = auth_info",
            "",
            "                # If the user is disabled don't allow them to authenticate",
            "                if not user_ref.get('enabled', True):",
            "                    LOG.warning('User %s is disabled' % user_id)",
            "                    raise exception.Unauthorized()",
            "            except AssertionError as e:",
            "                raise exception.Unauthorized(e.message)",
            "",
            "            token_ref = self.token_api.create_token(",
            "                    context, token_id, dict(id=token_id,",
            "                                            user=user_ref,",
            "                                            tenant=tenant_ref,",
            "                                            metadata=metadata_ref))",
            "            if tenant_ref:",
            "                catalog_ref = self.catalog_api.get_catalog(",
            "                        context=context,",
            "                        user_id=user_ref['id'],",
            "                        tenant_id=tenant_ref['id'],",
            "                        metadata=metadata_ref)",
            "            else:",
            "                catalog_ref = {}",
            "",
            "        elif 'token' in auth:",
            "            token = auth['token'].get('id', None)",
            "",
            "            tenant_name = auth.get('tenantName')",
            "",
            "            # more compat",
            "            if tenant_name:",
            "                tenant_ref = self.identity_api.get_tenant_by_name(",
            "                        context=context, tenant_name=tenant_name)",
            "                tenant_id = tenant_ref['id']",
            "            else:",
            "                tenant_id = auth.get('tenantId', None)",
            "",
            "            try:",
            "                old_token_ref = self.token_api.get_token(context=context,",
            "                                                         token_id=token)",
            "            except exception.NotFound:",
            "                raise exception.Unauthorized()",
            "",
            "            user_ref = old_token_ref['user']",
            "",
            "            # If the user is disabled don't allow them to authenticate",
            "            current_user_ref = self.identity_api.get_user(",
            "                                                    context=context,",
            "                                                    user_id=user_ref['id'])",
            "            if not current_user_ref.get('enabled', True):",
            "                LOG.warning('User %s is disabled' % user_ref['id'])",
            "                raise exception.Unauthorized()",
            "",
            "            tenants = self.identity_api.get_tenants_for_user(context,",
            "                                                             user_ref['id'])",
            "            if tenant_id:",
            "                assert tenant_id in tenants",
            "",
            "            tenant_ref = self.identity_api.get_tenant(context=context,",
            "                                                      tenant_id=tenant_id)",
            "            if tenant_ref:",
            "                metadata_ref = self.identity_api.get_metadata(",
            "                        context=context,",
            "                        user_id=user_ref['id'],",
            "                        tenant_id=tenant_ref['id'])",
            "                catalog_ref = self.catalog_api.get_catalog(",
            "                        context=context,",
            "                        user_id=user_ref['id'],",
            "                        tenant_id=tenant_ref['id'],",
            "                        metadata=metadata_ref)",
            "            else:",
            "                metadata_ref = {}",
            "                catalog_ref = {}",
            "",
            "            token_ref = self.token_api.create_token(",
            "                    context, token_id, dict(id=token_id,",
            "                                            user=user_ref,",
            "                                            tenant=tenant_ref,",
            "                                            metadata=metadata_ref))",
            "",
            "        # TODO(termie): optimize this call at some point and put it into the",
            "        #               the return for metadata",
            "        # fill out the roles in the metadata",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            roles_ref.append(self.identity_api.get_role(context, role_id))",
            "        logging.debug('TOKEN_REF %s', token_ref)",
            "        return self._format_authenticate(token_ref, roles_ref, catalog_ref)",
            "",
            "    def _get_token_ref(self, context, token_id, belongs_to=None):",
            "        \"\"\"Returns a token if a valid one exists.",
            "",
            "        Optionally, limited to a token owned by a specific tenant.",
            "",
            "        \"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "",
            "        token_ref = self.token_api.get_token(context=context,",
            "                                             token_id=token_id)",
            "",
            "        if belongs_to:",
            "            assert token_ref['tenant']['id'] == belongs_to",
            "",
            "        return token_ref",
            "",
            "    # admin only",
            "    def validate_token_head(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Identical to ``validate_token``, except does not return a response.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get(\"belongsTo\")",
            "        assert self._get_token_ref(context, token_id, belongs_to)",
            "",
            "    # admin only",
            "    def validate_token(self, context, token_id):",
            "        \"\"\"Check that a token is valid.",
            "",
            "        Optionally, also ensure that it is owned by a specific tenant.",
            "",
            "        Returns metadata about the token along any associated roles.",
            "",
            "        \"\"\"",
            "        belongs_to = context['query_string'].get(\"belongsTo\")",
            "        token_ref = self._get_token_ref(context, token_id, belongs_to)",
            "",
            "        # TODO(termie): optimize this call at some point and put it into the",
            "        #               the return for metadata",
            "        # fill out the roles in the metadata",
            "        metadata_ref = token_ref['metadata']",
            "        roles_ref = []",
            "        for role_id in metadata_ref.get('roles', []):",
            "            roles_ref.append(self.identity_api.get_role(context, role_id))",
            "",
            "        # Get a service catalog if belongs_to is not none",
            "        # This is needed for on-behalf-of requests",
            "        catalog_ref = None",
            "        if belongs_to is not None:",
            "            catalog_ref = self.catalog_api.get_catalog(",
            "                context=context,",
            "                user_id=token_ref['user']['id'],",
            "                tenant_id=token_ref['tenant']['id'],",
            "                metadata=metadata_ref)",
            "        return self._format_token(token_ref, roles_ref, catalog_ref)",
            "",
            "    def delete_token(self, context, token_id):",
            "        \"\"\"Delete a token, effectively invalidating it for authz.\"\"\"",
            "        # TODO(termie): this stuff should probably be moved to middleware",
            "        self.assert_admin(context)",
            "",
            "        self.token_api.delete_token(context=context, token_id=token_id)",
            "",
            "    def endpoints(self, context, token_id):",
            "        \"\"\"Return a list of endpoints available to the token.\"\"\"",
            "        raise exception.NotImplemented()",
            "",
            "    def _format_authenticate(self, token_ref, roles_ref, catalog_ref):",
            "        o = self._format_token(token_ref, roles_ref)",
            "        o['access']['serviceCatalog'] = self._format_catalog(catalog_ref)",
            "        return o",
            "",
            "    def _format_token(self, token_ref, roles_ref, catalog_ref=None):",
            "        user_ref = token_ref['user']",
            "        metadata_ref = token_ref['metadata']",
            "        expires = token_ref['expires']",
            "        if expires is not None:",
            "            expires = utils.isotime(expires)",
            "        o = {'access': {'token': {'id': token_ref['id'],",
            "                                  'expires': expires,",
            "                                  },",
            "                        'user': {'id': user_ref['id'],",
            "                                 'name': user_ref['name'],",
            "                                 'username': user_ref['name'],",
            "                                 'roles': roles_ref,",
            "                                 'roles_links': metadata_ref.get('roles_links',",
            "                                                               [])",
            "                                 }",
            "                        }",
            "             }",
            "        if 'tenant' in token_ref and token_ref['tenant']:",
            "            token_ref['tenant']['enabled'] = True",
            "            o['access']['token']['tenant'] = token_ref['tenant']",
            "        if catalog_ref is not None:",
            "            o['access']['serviceCatalog'] = self._format_catalog(catalog_ref)",
            "        return o",
            "",
            "    def _format_catalog(self, catalog_ref):",
            "        \"\"\"Munge catalogs from internal to output format",
            "        Internal catalogs look like:",
            "",
            "        {$REGION: {",
            "            {$SERVICE: {",
            "                $key1: $value1,",
            "                ...",
            "                }",
            "            }",
            "        }",
            "",
            "        The legacy api wants them to look like",
            "",
            "        [{'name': $SERVICE[name],",
            "          'type': $SERVICE,",
            "          'endpoints': [{",
            "              'tenantId': $tenant_id,",
            "              ...",
            "              'region': $REGION,",
            "              }],",
            "          'endpoints_links': [],",
            "         }]",
            "",
            "        \"\"\"",
            "        if not catalog_ref:",
            "            return {}",
            "",
            "        services = {}",
            "        for region, region_ref in catalog_ref.iteritems():",
            "            for service, service_ref in region_ref.iteritems():",
            "                new_service_ref = services.get(service, {})",
            "                new_service_ref['name'] = service_ref.pop('name')",
            "                new_service_ref['type'] = service",
            "                new_service_ref['endpoints_links'] = []",
            "                service_ref['region'] = region",
            "",
            "                endpoints_ref = new_service_ref.get('endpoints', [])",
            "                endpoints_ref.append(service_ref)",
            "",
            "                new_service_ref['endpoints'] = endpoints_ref",
            "                services[service] = new_service_ref",
            "",
            "        return services.values()",
            "",
            "",
            "class ExtensionsController(wsgi.Application):",
            "    \"\"\"Base extensions controller to be extended by public and admin API's.\"\"\"",
            "",
            "    def __init__(self, extensions=None):",
            "        super(ExtensionsController, self).__init__()",
            "",
            "        self.extensions = extensions or {}",
            "",
            "    def get_extensions_info(self, context):",
            "        return {'extensions': {'values': self.extensions.values()}}",
            "",
            "    def get_extension_info(self, context, extension_alias):",
            "        try:",
            "            return {'extension': self.extensions[extension_alias]}",
            "        except KeyError:",
            "            raise exception.NotFound(target=extension_alias)",
            "",
            "",
            "class PublicExtensionsController(ExtensionsController):",
            "    pass",
            "",
            "",
            "class AdminExtensionsController(ExtensionsController):",
            "    def __init__(self, *args, **kwargs):",
            "        super(AdminExtensionsController, self).__init__(*args, **kwargs)",
            "",
            "        # TODO(dolph): Extensions should obviously provide this information",
            "        #               themselves, but hardcoding it here allows us to match",
            "        #               the API spec in the short term with minimal complexity.",
            "        self.extensions['OS-KSADM'] = {",
            "            'name': 'Openstack Keystone Admin',",
            "            'namespace': 'http://docs.openstack.org/identity/api/ext/'",
            "                         'OS-KSADM/v1.0',",
            "            'alias': 'OS-KSADM',",
            "            'updated': '2011-08-19T13:25:27-06:00',",
            "            'description': 'Openstack extensions to Keystone v2.0 API '",
            "                           'enabling Admin Operations.',",
            "            'links': [",
            "                {",
            "                    'rel': 'describedby',",
            "                    # TODO(dolph): link needs to be revised after",
            "                    #              bug 928059 merges",
            "                    'type': 'text/html',",
            "                    'href': ('https://github.com/openstack/'",
            "                        'identity-api'),",
            "                }",
            "            ]",
            "        }",
            "",
            "",
            "@logging.fail_gracefully",
            "def public_app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return PublicRouter()",
            "",
            "",
            "@logging.fail_gracefully",
            "def admin_app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return AdminRouter()",
            "",
            "",
            "@logging.fail_gracefully",
            "def public_version_app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return PublicVersionRouter()",
            "",
            "",
            "@logging.fail_gracefully",
            "def admin_version_app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return AdminVersionRouter()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "278": [
                "TokenController",
                "authenticate"
            ]
        },
        "addLocation": []
    }
}