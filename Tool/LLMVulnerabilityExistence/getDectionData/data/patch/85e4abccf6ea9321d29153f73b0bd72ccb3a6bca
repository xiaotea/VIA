{
    "jupyter_server/auth/login.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         if default is None:"
            },
            "2": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "             default = self.base_url"
            },
            "3": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not url.startswith(self.base_url):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        # protect chrome users from mishandling unescaped backslashes."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        # \\ is not valid in urls, but some browsers treat it as /"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        # instead of %5C, causing `\\\\` to behave as `//`"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        url = url.replace(\"\\\\\", \"%5C\")"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        parsed = urlparse(url)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):"
            },
            "10": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             # require that next_url be absolute path within our path"
            },
            "11": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "             allow = False"
            },
            "12": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             # OR pass our cross-origin check"
            },
            "13": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if '://' in url:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            if parsed.netloc:"
            },
            "15": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "                 # if full URL, run our cross-origin check:"
            },
            "16": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                parsed = urlparse(url.lower())"
            },
            "17": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "                 origin = '%s://%s' % (parsed.scheme, parsed.netloc)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+                origin = origin.lower()"
            },
            "19": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 if self.allow_origin:"
            },
            "20": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "                     allow = self.allow_origin == origin"
            },
            "21": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "                 elif self.allow_origin_pat:"
            },
            "22": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "                 self.set_login_cookie(self, uuid.uuid4().hex)"
            },
            "23": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "             elif self.token and self.token == typed_password:"
            },
            "24": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "                 self.set_login_cookie(self, uuid.uuid4().hex)"
            },
            "25": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if new_password and self.settings.get('allow_password_change'):"
            },
            "26": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    config_dir = self.settings.get('config_dir')"
            },
            "27": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    config_file = os.path.join(config_dir, 'jupyter_server_config.json')"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+                if new_password and self.settings.get(\"allow_password_change\"):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+                    config_dir = self.settings.get(\"config_dir\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                    config_file = os.path.join("
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                        config_dir, \"jupyter_notebook_config.json\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+                    )"
            },
            "33": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "                     set_password(new_password, config_file=config_file)"
            },
            "34": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "                     self.log.info(\"Wrote hashed password to %s\" % config_file)"
            },
            "35": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "             else:"
            }
        },
        "frontPatchFile": [
            "\"\"\"Tornado handlers for logging into the Jupyter Server.\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "import re",
            "import os",
            "import uuid",
            "",
            "from urllib.parse import urlparse",
            "",
            "from tornado.escape import url_escape",
            "",
            "from .security import passwd_check, set_password",
            "",
            "from ..base.handlers import JupyterHandler",
            "",
            "",
            "class LoginHandler(JupyterHandler):",
            "    \"\"\"The basic tornado login handler",
            "",
            "    authenticates with a hashed password from the configuration.",
            "    \"\"\"",
            "    def _render(self, message=None):",
            "        self.write(self.render_template('login.html',",
            "                next=url_escape(self.get_argument('next', default=self.base_url)),",
            "                message=message,",
            "        ))",
            "",
            "    def _redirect_safe(self, url, default=None):",
            "        \"\"\"Redirect if url is on our PATH",
            "",
            "        Full-domain redirects are allowed if they pass our CORS origin checks.",
            "",
            "        Otherwise use default (self.base_url if unspecified).",
            "        \"\"\"",
            "        if default is None:",
            "            default = self.base_url",
            "        if not url.startswith(self.base_url):",
            "            # require that next_url be absolute path within our path",
            "            allow = False",
            "            # OR pass our cross-origin check",
            "            if '://' in url:",
            "                # if full URL, run our cross-origin check:",
            "                parsed = urlparse(url.lower())",
            "                origin = '%s://%s' % (parsed.scheme, parsed.netloc)",
            "                if self.allow_origin:",
            "                    allow = self.allow_origin == origin",
            "                elif self.allow_origin_pat:",
            "                    allow = bool(self.allow_origin_pat.match(origin))",
            "            if not allow:",
            "                # not allowed, use default",
            "                self.log.warning(\"Not allowing login redirect to %r\" % url)",
            "                url = default",
            "        self.redirect(url)",
            "",
            "    def get(self):",
            "        if self.current_user:",
            "            next_url = self.get_argument('next', default=self.base_url)",
            "            self._redirect_safe(next_url)",
            "        else:",
            "            self._render()",
            "",
            "    @property",
            "    def hashed_password(self):",
            "        return self.password_from_settings(self.settings)",
            "",
            "    def passwd_check(self, a, b):",
            "        return passwd_check(a, b)",
            "",
            "    def post(self):",
            "        typed_password = self.get_argument('password', default=u'')",
            "        new_password = self.get_argument('new_password', default=u'')",
            "",
            "        if self.get_login_available(self.settings):",
            "            if self.passwd_check(self.hashed_password, typed_password) and not new_password:",
            "                self.set_login_cookie(self, uuid.uuid4().hex)",
            "            elif self.token and self.token == typed_password:",
            "                self.set_login_cookie(self, uuid.uuid4().hex)",
            "                if new_password and self.settings.get('allow_password_change'):",
            "                    config_dir = self.settings.get('config_dir')",
            "                    config_file = os.path.join(config_dir, 'jupyter_server_config.json')",
            "                    set_password(new_password, config_file=config_file)",
            "                    self.log.info(\"Wrote hashed password to %s\" % config_file)",
            "            else:",
            "                self.set_status(401)",
            "                self._render(message={'error': 'Invalid credentials'})",
            "                return",
            "",
            "",
            "        next_url = self.get_argument('next', default=self.base_url)",
            "        self._redirect_safe(next_url)",
            "",
            "    @classmethod",
            "    def set_login_cookie(cls, handler, user_id=None):",
            "        \"\"\"Call this on handlers to set the login cookie for success\"\"\"",
            "        cookie_options = handler.settings.get('cookie_options', {})",
            "        cookie_options.setdefault('httponly', True)",
            "        # tornado <4.2 has a bug that considers secure==True as soon as",
            "        # 'secure' kwarg is passed to set_secure_cookie",
            "        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):",
            "            cookie_options.setdefault('secure', True)",
            "        cookie_options.setdefault('path', handler.base_url)",
            "        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)",
            "        return user_id",
            "",
            "    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)",
            "",
            "    @classmethod",
            "    def get_token(cls, handler):",
            "        \"\"\"Get the user token from a request",
            "",
            "        Default:",
            "",
            "        - in URL parameters: ?token=<token>",
            "        - in header: Authorization: token <token>",
            "        \"\"\"",
            "",
            "        user_token = handler.get_argument('token', '')",
            "        if not user_token:",
            "            # get it from Authorization header",
            "            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))",
            "            if m:",
            "                user_token = m.group(1)",
            "        return user_token",
            "",
            "    @classmethod",
            "    def should_check_origin(cls, handler):",
            "        \"\"\"Should the Handler check for CORS origin validation?",
            "",
            "        Origin check should be skipped for token-authenticated requests.",
            "",
            "        Returns:",
            "        - True, if Handler must check for valid CORS origin.",
            "        - False, if Handler should skip origin check since requests are token-authenticated.",
            "        \"\"\"",
            "        return not cls.is_token_authenticated(handler)",
            "",
            "    @classmethod",
            "    def is_token_authenticated(cls, handler):",
            "        \"\"\"Returns True if handler has been token authenticated. Otherwise, False.",
            "",
            "        Login with a token is used to signal certain things, such as:",
            "",
            "        - permit access to REST API",
            "        - xsrf protection",
            "        - skip origin-checks for scripts",
            "        \"\"\"",
            "        if getattr(handler, '_user_id', None) is None:",
            "            # ensure get_user has been called, so we know if we're token-authenticated",
            "            handler.get_current_user()",
            "        return getattr(handler, '_token_authenticated', False)",
            "",
            "    @classmethod",
            "    def get_user(cls, handler):",
            "        \"\"\"Called by handlers.get_current_user for identifying the current user.",
            "",
            "        See tornado.web.RequestHandler.get_current_user for details.",
            "        \"\"\"",
            "        # Can't call this get_current_user because it will collide when",
            "        # called on LoginHandler itself.",
            "        if getattr(handler, '_user_id', None):",
            "            return handler._user_id",
            "        user_id = cls.get_user_token(handler)",
            "        if user_id is None:",
            "            get_secure_cookie_kwargs  = handler.settings.get('get_secure_cookie_kwargs', {})",
            "            user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs )",
            "        else:",
            "            cls.set_login_cookie(handler, user_id)",
            "            # Record that the current request has been authenticated with a token.",
            "            # Used in is_token_authenticated above.",
            "            handler._token_authenticated = True",
            "        if user_id is None:",
            "            # If an invalid cookie was sent, clear it to prevent unnecessary",
            "            # extra warnings. But don't do this on a request with *no* cookie,",
            "            # because that can erroneously log you out (see gh-3365)",
            "            if handler.get_cookie(handler.cookie_name) is not None:",
            "                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)",
            "                handler.clear_login_cookie()",
            "            if not handler.login_available:",
            "                # Completely insecure! No authentication at all.",
            "                # No need to warn here, though; validate_security will have already done that.",
            "                user_id = 'anonymous'",
            "",
            "        # cache value for future retrievals on the same request",
            "        handler._user_id = user_id",
            "        return user_id",
            "",
            "    @classmethod",
            "    def get_user_token(cls, handler):",
            "        \"\"\"Identify the user based on a token in the URL or Authorization header",
            "        ",
            "        Returns:",
            "        - uuid if authenticated",
            "        - None if not",
            "        \"\"\"",
            "        token = handler.token",
            "        if not token:",
            "            return",
            "        # check login token from URL argument or Authorization header",
            "        user_token = cls.get_token(handler)",
            "        authenticated = False",
            "        if user_token == token:",
            "            # token-authenticated, set the login cookie",
            "            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)",
            "            authenticated = True",
            "",
            "        if authenticated:",
            "            return uuid.uuid4().hex",
            "        else:",
            "            return None",
            "",
            "",
            "    @classmethod",
            "    def validate_security(cls, app, ssl_options=None):",
            "        \"\"\"Check the application's security.",
            "",
            "        Show messages, or abort if necessary, based on the security configuration.",
            "        \"\"\"",
            "        if not app.ip:",
            "            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"",
            "            if ssl_options is None:",
            "                app.log.warning(warning + \" and not using encryption. This \"",
            "                    \"is not recommended.\")",
            "            if not app.password and not app.token:",
            "                app.log.warning(warning + \" and not using authentication. \"",
            "                    \"This is highly insecure and not recommended.\")",
            "        else:",
            "            if not app.password and not app.token:",
            "                app.log.warning(",
            "                    \"All authentication is disabled.\"",
            "                    \"  Anyone who can connect to this server will be able to run code.\")",
            "",
            "    @classmethod",
            "    def password_from_settings(cls, settings):",
            "        \"\"\"Return the hashed password from the tornado settings.",
            "",
            "        If there is no configured password, an empty string will be returned.",
            "        \"\"\"",
            "        return settings.get('password', u'')",
            "",
            "    @classmethod",
            "    def get_login_available(cls, settings):",
            "        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"",
            "        return bool(cls.password_from_settings(settings) or settings.get('token'))"
        ],
        "afterPatchFile": [
            "\"\"\"Tornado handlers for logging into the Jupyter Server.\"\"\"",
            "",
            "# Copyright (c) Jupyter Development Team.",
            "# Distributed under the terms of the Modified BSD License.",
            "",
            "import re",
            "import os",
            "import uuid",
            "",
            "from urllib.parse import urlparse",
            "",
            "from tornado.escape import url_escape",
            "",
            "from .security import passwd_check, set_password",
            "",
            "from ..base.handlers import JupyterHandler",
            "",
            "",
            "class LoginHandler(JupyterHandler):",
            "    \"\"\"The basic tornado login handler",
            "",
            "    authenticates with a hashed password from the configuration.",
            "    \"\"\"",
            "    def _render(self, message=None):",
            "        self.write(self.render_template('login.html',",
            "                next=url_escape(self.get_argument('next', default=self.base_url)),",
            "                message=message,",
            "        ))",
            "",
            "    def _redirect_safe(self, url, default=None):",
            "        \"\"\"Redirect if url is on our PATH",
            "",
            "        Full-domain redirects are allowed if they pass our CORS origin checks.",
            "",
            "        Otherwise use default (self.base_url if unspecified).",
            "        \"\"\"",
            "        if default is None:",
            "            default = self.base_url",
            "        # protect chrome users from mishandling unescaped backslashes.",
            "        # \\ is not valid in urls, but some browsers treat it as /",
            "        # instead of %5C, causing `\\\\` to behave as `//`",
            "        url = url.replace(\"\\\\\", \"%5C\")",
            "        parsed = urlparse(url)",
            "        if parsed.netloc or not (parsed.path + \"/\").startswith(self.base_url):",
            "            # require that next_url be absolute path within our path",
            "            allow = False",
            "            # OR pass our cross-origin check",
            "            if parsed.netloc:",
            "                # if full URL, run our cross-origin check:",
            "                origin = '%s://%s' % (parsed.scheme, parsed.netloc)",
            "                origin = origin.lower()",
            "                if self.allow_origin:",
            "                    allow = self.allow_origin == origin",
            "                elif self.allow_origin_pat:",
            "                    allow = bool(self.allow_origin_pat.match(origin))",
            "            if not allow:",
            "                # not allowed, use default",
            "                self.log.warning(\"Not allowing login redirect to %r\" % url)",
            "                url = default",
            "        self.redirect(url)",
            "",
            "    def get(self):",
            "        if self.current_user:",
            "            next_url = self.get_argument('next', default=self.base_url)",
            "            self._redirect_safe(next_url)",
            "        else:",
            "            self._render()",
            "",
            "    @property",
            "    def hashed_password(self):",
            "        return self.password_from_settings(self.settings)",
            "",
            "    def passwd_check(self, a, b):",
            "        return passwd_check(a, b)",
            "",
            "    def post(self):",
            "        typed_password = self.get_argument('password', default=u'')",
            "        new_password = self.get_argument('new_password', default=u'')",
            "",
            "        if self.get_login_available(self.settings):",
            "            if self.passwd_check(self.hashed_password, typed_password) and not new_password:",
            "                self.set_login_cookie(self, uuid.uuid4().hex)",
            "            elif self.token and self.token == typed_password:",
            "                self.set_login_cookie(self, uuid.uuid4().hex)",
            "                if new_password and self.settings.get(\"allow_password_change\"):",
            "                    config_dir = self.settings.get(\"config_dir\")",
            "                    config_file = os.path.join(",
            "                        config_dir, \"jupyter_notebook_config.json\"",
            "                    )",
            "                    set_password(new_password, config_file=config_file)",
            "                    self.log.info(\"Wrote hashed password to %s\" % config_file)",
            "            else:",
            "                self.set_status(401)",
            "                self._render(message={'error': 'Invalid credentials'})",
            "                return",
            "",
            "",
            "        next_url = self.get_argument('next', default=self.base_url)",
            "        self._redirect_safe(next_url)",
            "",
            "    @classmethod",
            "    def set_login_cookie(cls, handler, user_id=None):",
            "        \"\"\"Call this on handlers to set the login cookie for success\"\"\"",
            "        cookie_options = handler.settings.get('cookie_options', {})",
            "        cookie_options.setdefault('httponly', True)",
            "        # tornado <4.2 has a bug that considers secure==True as soon as",
            "        # 'secure' kwarg is passed to set_secure_cookie",
            "        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):",
            "            cookie_options.setdefault('secure', True)",
            "        cookie_options.setdefault('path', handler.base_url)",
            "        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)",
            "        return user_id",
            "",
            "    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)",
            "",
            "    @classmethod",
            "    def get_token(cls, handler):",
            "        \"\"\"Get the user token from a request",
            "",
            "        Default:",
            "",
            "        - in URL parameters: ?token=<token>",
            "        - in header: Authorization: token <token>",
            "        \"\"\"",
            "",
            "        user_token = handler.get_argument('token', '')",
            "        if not user_token:",
            "            # get it from Authorization header",
            "            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))",
            "            if m:",
            "                user_token = m.group(1)",
            "        return user_token",
            "",
            "    @classmethod",
            "    def should_check_origin(cls, handler):",
            "        \"\"\"Should the Handler check for CORS origin validation?",
            "",
            "        Origin check should be skipped for token-authenticated requests.",
            "",
            "        Returns:",
            "        - True, if Handler must check for valid CORS origin.",
            "        - False, if Handler should skip origin check since requests are token-authenticated.",
            "        \"\"\"",
            "        return not cls.is_token_authenticated(handler)",
            "",
            "    @classmethod",
            "    def is_token_authenticated(cls, handler):",
            "        \"\"\"Returns True if handler has been token authenticated. Otherwise, False.",
            "",
            "        Login with a token is used to signal certain things, such as:",
            "",
            "        - permit access to REST API",
            "        - xsrf protection",
            "        - skip origin-checks for scripts",
            "        \"\"\"",
            "        if getattr(handler, '_user_id', None) is None:",
            "            # ensure get_user has been called, so we know if we're token-authenticated",
            "            handler.get_current_user()",
            "        return getattr(handler, '_token_authenticated', False)",
            "",
            "    @classmethod",
            "    def get_user(cls, handler):",
            "        \"\"\"Called by handlers.get_current_user for identifying the current user.",
            "",
            "        See tornado.web.RequestHandler.get_current_user for details.",
            "        \"\"\"",
            "        # Can't call this get_current_user because it will collide when",
            "        # called on LoginHandler itself.",
            "        if getattr(handler, '_user_id', None):",
            "            return handler._user_id",
            "        user_id = cls.get_user_token(handler)",
            "        if user_id is None:",
            "            get_secure_cookie_kwargs  = handler.settings.get('get_secure_cookie_kwargs', {})",
            "            user_id = handler.get_secure_cookie(handler.cookie_name, **get_secure_cookie_kwargs )",
            "        else:",
            "            cls.set_login_cookie(handler, user_id)",
            "            # Record that the current request has been authenticated with a token.",
            "            # Used in is_token_authenticated above.",
            "            handler._token_authenticated = True",
            "        if user_id is None:",
            "            # If an invalid cookie was sent, clear it to prevent unnecessary",
            "            # extra warnings. But don't do this on a request with *no* cookie,",
            "            # because that can erroneously log you out (see gh-3365)",
            "            if handler.get_cookie(handler.cookie_name) is not None:",
            "                handler.log.warning(\"Clearing invalid/expired login cookie %s\", handler.cookie_name)",
            "                handler.clear_login_cookie()",
            "            if not handler.login_available:",
            "                # Completely insecure! No authentication at all.",
            "                # No need to warn here, though; validate_security will have already done that.",
            "                user_id = 'anonymous'",
            "",
            "        # cache value for future retrievals on the same request",
            "        handler._user_id = user_id",
            "        return user_id",
            "",
            "    @classmethod",
            "    def get_user_token(cls, handler):",
            "        \"\"\"Identify the user based on a token in the URL or Authorization header",
            "        ",
            "        Returns:",
            "        - uuid if authenticated",
            "        - None if not",
            "        \"\"\"",
            "        token = handler.token",
            "        if not token:",
            "            return",
            "        # check login token from URL argument or Authorization header",
            "        user_token = cls.get_token(handler)",
            "        authenticated = False",
            "        if user_token == token:",
            "            # token-authenticated, set the login cookie",
            "            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)",
            "            authenticated = True",
            "",
            "        if authenticated:",
            "            return uuid.uuid4().hex",
            "        else:",
            "            return None",
            "",
            "",
            "    @classmethod",
            "    def validate_security(cls, app, ssl_options=None):",
            "        \"\"\"Check the application's security.",
            "",
            "        Show messages, or abort if necessary, based on the security configuration.",
            "        \"\"\"",
            "        if not app.ip:",
            "            warning = \"WARNING: The Jupyter server is listening on all IP addresses\"",
            "            if ssl_options is None:",
            "                app.log.warning(warning + \" and not using encryption. This \"",
            "                    \"is not recommended.\")",
            "            if not app.password and not app.token:",
            "                app.log.warning(warning + \" and not using authentication. \"",
            "                    \"This is highly insecure and not recommended.\")",
            "        else:",
            "            if not app.password and not app.token:",
            "                app.log.warning(",
            "                    \"All authentication is disabled.\"",
            "                    \"  Anyone who can connect to this server will be able to run code.\")",
            "",
            "    @classmethod",
            "    def password_from_settings(cls, settings):",
            "        \"\"\"Return the hashed password from the tornado settings.",
            "",
            "        If there is no configured password, an empty string will be returned.",
            "        \"\"\"",
            "        return settings.get('password', u'')",
            "",
            "    @classmethod",
            "    def get_login_available(cls, settings):",
            "        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"",
            "        return bool(cls.password_from_settings(settings) or settings.get('token'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "39": [
                "LoginHandler",
                "_redirect_safe"
            ],
            "43": [
                "LoginHandler",
                "_redirect_safe"
            ],
            "45": [
                "LoginHandler",
                "_redirect_safe"
            ],
            "80": [
                "LoginHandler",
                "post"
            ],
            "81": [
                "LoginHandler",
                "post"
            ],
            "82": [
                "LoginHandler",
                "post"
            ]
        },
        "addLocation": []
    }
}