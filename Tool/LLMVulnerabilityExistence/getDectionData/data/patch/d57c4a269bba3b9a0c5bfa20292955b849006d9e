{
    "mechanicalsoup/browser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import io"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import tempfile"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import urllib"
            },
            "4": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from .__version__ import __title__, __version__"
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from .form import Form"
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .utils import LinkNotFoundError"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from .utils import LinkNotFoundError, is_multipart_file_upload"
            },
            "9": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " class Browser:"
            },
            "12": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 229,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "                 # If the enctype is not multipart, the filename is put in"
            },
            "14": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "                 # the form as a text input and the file is not sent."
            },
            "15": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if tag.get(\"type\", \"\").lower() == \"file\" and multipart:"
            },
            "16": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    filepath = value"
            },
            "17": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if filepath != \"\" and isinstance(filepath, str):"
            },
            "18": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        content = open(filepath, \"rb\")"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+                if is_multipart_file_upload(form, tag):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                    if isinstance(value, io.IOBase):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+                        content = value"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+                        filename = os.path.basename(getattr(value, \"name\", \"\"))"
            },
            "23": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "                     else:"
            },
            "24": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "                         content = \"\""
            },
            "25": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    filename = os.path.basename(filepath)"
            },
            "26": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # If value is the empty string, we still pass it"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+                        filename = os.path.basename(value)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+                    # If content is the empty string, we still pass it"
            },
            "29": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "                     # for consistency with browsers (see"
            },
            "30": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "                     # https://github.com/MechanicalSoup/MechanicalSoup/issues/250)."
            },
            "31": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "                     files[name] = (filename, content)"
            },
            "32": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "                 else:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+                    if isinstance(value, io.IOBase):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+                        value = os.path.basename(getattr(value, \"name\", \"\"))"
            },
            "35": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "                     data.append((name, value))"
            },
            "36": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 247,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "             elif tag.name == \"button\":"
            }
        },
        "frontPatchFile": [
            "import os",
            "import tempfile",
            "import urllib",
            "import weakref",
            "import webbrowser",
            "",
            "import bs4",
            "import bs4.dammit",
            "import requests",
            "",
            "from .__version__ import __title__, __version__",
            "from .form import Form",
            "from .utils import LinkNotFoundError",
            "",
            "",
            "class Browser:",
            "    \"\"\"Builds a low-level Browser.",
            "",
            "    It is recommended to use :class:`StatefulBrowser` for most applications,",
            "    since it offers more advanced features and conveniences than Browser.",
            "",
            "    :param session: Attach a pre-existing requests Session instead of",
            "        constructing a new one.",
            "    :param soup_config: Configuration passed to BeautifulSoup to affect",
            "        the way HTML is parsed. Defaults to ``{'features': 'lxml'}``.",
            "        If overridden, it is highly recommended to `specify a parser",
            "        <https://www.crummy.com/software/BeautifulSoup/bs4/doc/#specifying-the-parser-to-use>`__.",
            "        Otherwise, BeautifulSoup will issue a warning and pick one for",
            "        you, but the parser it chooses may be different on different",
            "        machines.",
            "    :param requests_adapters: Configuration passed to requests, to affect",
            "        the way HTTP requests are performed.",
            "    :param raise_on_404: If True, raise :class:`LinkNotFoundError`",
            "        when visiting a page triggers a 404 Not Found error.",
            "    :param user_agent: Set the user agent header to this value.",
            "",
            "    \"\"\"",
            "    def __init__(self, session=None, soup_config={'features': 'lxml'},",
            "                 requests_adapters=None,",
            "                 raise_on_404=False, user_agent=None):",
            "",
            "        self.raise_on_404 = raise_on_404",
            "        self.session = session or requests.Session()",
            "",
            "        if hasattr(weakref, 'finalize'):",
            "            self._finalize = weakref.finalize(self.session, self.close)",
            "        else:   # pragma: no cover",
            "            # Python < 3 does not have weakref.finalize, but these",
            "            # versions accept calling session.close() within __del__",
            "            self._finalize = self.close",
            "",
            "        self.set_user_agent(user_agent)",
            "",
            "        if requests_adapters is not None:",
            "            for adaptee, adapter in requests_adapters.items():",
            "                self.session.mount(adaptee, adapter)",
            "",
            "        self.soup_config = soup_config or dict()",
            "",
            "    @staticmethod",
            "    def __looks_like_html(response):",
            "        \"\"\"Guesses entity type when Content-Type header is missing.",
            "        Since Content-Type is not strictly required, some servers leave it out.",
            "        \"\"\"",
            "        text = response.text.lstrip().lower()",
            "        return text.startswith('<html') or text.startswith('<!doctype')",
            "",
            "    @staticmethod",
            "    def add_soup(response, soup_config):",
            "        \"\"\"Attaches a soup object to a requests response.\"\"\"",
            "        if (\"text/html\" in response.headers.get(\"Content-Type\", \"\") or",
            "                Browser.__looks_like_html(response)):",
            "            # Note: By default (no charset provided in HTTP headers), requests",
            "            # returns 'ISO-8859-1' which is the default for HTML4, even if HTML",
            "            # code specifies a different encoding. In this case, we want to",
            "            # resort to bs4 sniffing, hence the special handling here.",
            "            http_encoding = (",
            "                response.encoding",
            "                if 'charset' in response.headers.get(\"Content-Type\", \"\")",
            "                else None",
            "            )",
            "            html_encoding = bs4.dammit.EncodingDetector.find_declared_encoding(",
            "                response.content,",
            "                is_html=True",
            "            )",
            "            # See https://www.w3.org/International/questions/qa-html-encoding-declarations.en#httphead  # noqa: E501",
            "            # > The HTTP header has a higher precedence than the in-document",
            "            # > meta declarations.",
            "            encoding = http_encoding if http_encoding else html_encoding",
            "            response.soup = bs4.BeautifulSoup(",
            "                response.content,",
            "                from_encoding=encoding,",
            "                **soup_config",
            "            )",
            "        else:",
            "            response.soup = None",
            "",
            "    def set_cookiejar(self, cookiejar):",
            "        \"\"\"Replaces the current cookiejar in the requests session. Since the",
            "        session handles cookies automatically without calling this function,",
            "        only use this when default cookie handling is insufficient.",
            "",
            "        :param cookiejar: Any `http.cookiejar.CookieJar",
            "          <https://docs.python.org/3/library/http.cookiejar.html#http.cookiejar.CookieJar>`__",
            "          compatible object.",
            "        \"\"\"",
            "        self.session.cookies = cookiejar",
            "",
            "    def get_cookiejar(self):",
            "        \"\"\"Gets the cookiejar from the requests session.\"\"\"",
            "        return self.session.cookies",
            "",
            "    def set_user_agent(self, user_agent):",
            "        \"\"\"Replaces the current user agent in the requests session headers.\"\"\"",
            "        # set a default user_agent if not specified",
            "        if user_agent is None:",
            "            requests_ua = requests.utils.default_user_agent()",
            "            user_agent = f'{requests_ua} ({__title__}/{__version__})'",
            "",
            "        # the requests module uses a case-insensitive dict for session headers",
            "        self.session.headers['User-agent'] = user_agent",
            "",
            "    def request(self, *args, **kwargs):",
            "        \"\"\"Straightforward wrapper around `requests.Session.request",
            "        <http://docs.python-requests.org/en/master/api/#requests.Session.request>`__.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "",
            "        This is a low-level function that should not be called for",
            "        basic usage (use :func:`get` or :func:`post` instead). Use it if you",
            "        need an HTTP verb that MechanicalSoup doesn't manage (e.g. MKCOL) for",
            "        example.",
            "        \"\"\"",
            "        response = self.session.request(*args, **kwargs)",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    def get(self, *args, **kwargs):",
            "        \"\"\"Straightforward wrapper around `requests.Session.get",
            "        <http://docs.python-requests.org/en/master/api/#requests.Session.get>`__.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "        \"\"\"",
            "        response = self.session.get(*args, **kwargs)",
            "        if self.raise_on_404 and response.status_code == 404:",
            "            raise LinkNotFoundError()",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    def post(self, *args, **kwargs):",
            "        \"\"\"Straightforward wrapper around `requests.Session.post",
            "        <http://docs.python-requests.org/en/master/api/#requests.Session.post>`__.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "        \"\"\"",
            "        response = self.session.post(*args, **kwargs)",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    def put(self, *args, **kwargs):",
            "        \"\"\"Straightforward wrapper around `requests.Session.put",
            "        <http://docs.python-requests.org/en/master/api/#requests.Session.put>`__.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "        \"\"\"",
            "        response = self.session.put(*args, **kwargs)",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    @staticmethod",
            "    def _get_request_kwargs(method, url, **kwargs):",
            "        \"\"\"This method exists to raise a TypeError when a method or url is",
            "        specified in the kwargs.",
            "        \"\"\"",
            "        request_kwargs = {\"method\": method, \"url\": url}",
            "        request_kwargs.update(kwargs)",
            "        return request_kwargs",
            "",
            "    @classmethod",
            "    def get_request_kwargs(cls, form, url=None, **kwargs):",
            "        \"\"\"Extract input data from the form.\"\"\"",
            "        method = str(form.get(\"method\", \"get\"))",
            "        action = form.get(\"action\")",
            "        url = urllib.parse.urljoin(url, action)",
            "        if url is None:  # This happens when both `action` and `url` are None.",
            "            raise ValueError('no URL to submit to')",
            "",
            "        # read https://www.w3.org/TR/html52/sec-forms.html",
            "        if method.lower() == \"get\":",
            "            data = kwargs.pop(\"params\", dict())",
            "        else:",
            "            data = kwargs.pop(\"data\", dict())",
            "        files = kwargs.pop(\"files\", dict())",
            "",
            "        # Use a list of 2-tuples to better reflect the behavior of browser QSL.",
            "        # Requests also retains order when encoding form data in 2-tuple lists.",
            "        data = [(k, v) for k, v in data.items()]",
            "",
            "        multipart = form.get(\"enctype\", \"\") == \"multipart/form-data\"",
            "",
            "        # Process form tags in the order that they appear on the page,",
            "        # skipping those tags that do not have a name-attribute.",
            "        selector = \",\".join(f\"{tag}[name]\" for tag in",
            "                            (\"input\", \"button\", \"textarea\", \"select\"))",
            "        for tag in form.select(selector):",
            "            name = tag.get(\"name\")  # name-attribute of tag",
            "",
            "            # Skip disabled elements, since they should not be submitted.",
            "            if tag.has_attr('disabled'):",
            "                continue",
            "",
            "            if tag.name == \"input\":",
            "                if tag.get(\"type\", \"\").lower() in (\"radio\", \"checkbox\"):",
            "                    if \"checked\" not in tag.attrs:",
            "                        continue",
            "                    value = tag.get(\"value\", \"on\")",
            "                else:",
            "                    # browsers use empty string for inputs with missing values",
            "                    value = tag.get(\"value\", \"\")",
            "",
            "                # If the enctype is not multipart, the filename is put in",
            "                # the form as a text input and the file is not sent.",
            "                if tag.get(\"type\", \"\").lower() == \"file\" and multipart:",
            "                    filepath = value",
            "                    if filepath != \"\" and isinstance(filepath, str):",
            "                        content = open(filepath, \"rb\")",
            "                    else:",
            "                        content = \"\"",
            "                    filename = os.path.basename(filepath)",
            "                    # If value is the empty string, we still pass it",
            "                    # for consistency with browsers (see",
            "                    # https://github.com/MechanicalSoup/MechanicalSoup/issues/250).",
            "                    files[name] = (filename, content)",
            "                else:",
            "                    data.append((name, value))",
            "",
            "            elif tag.name == \"button\":",
            "                if tag.get(\"type\", \"\").lower() in (\"button\", \"reset\"):",
            "                    continue",
            "                else:",
            "                    data.append((name, tag.get(\"value\", \"\")))",
            "",
            "            elif tag.name == \"textarea\":",
            "                data.append((name, tag.text))",
            "",
            "            elif tag.name == \"select\":",
            "                # If the value attribute is not specified, the content will",
            "                # be passed as a value instead.",
            "                options = tag.select(\"option\")",
            "                selected_values = [i.get(\"value\", i.text) for i in options",
            "                                   if \"selected\" in i.attrs]",
            "                if \"multiple\" in tag.attrs:",
            "                    for value in selected_values:",
            "                        data.append((name, value))",
            "                elif selected_values:",
            "                    # A standard select element only allows one option to be",
            "                    # selected, but browsers pick last if somehow multiple.",
            "                    data.append((name, selected_values[-1]))",
            "                elif options:",
            "                    # Selects the first option if none are selected",
            "                    first_value = options[0].get(\"value\", options[0].text)",
            "                    data.append((name, first_value))",
            "",
            "        if method.lower() == \"get\":",
            "            kwargs[\"params\"] = data",
            "        else:",
            "            kwargs[\"data\"] = data",
            "",
            "        # The following part of the function is here to respect the",
            "        # enctype specified by the form, i.e. force sending multipart",
            "        # content. Since Requests doesn't have yet a feature to choose",
            "        # enctype, we have to use tricks to make it behave as we want",
            "        # This code will be updated if Requests implements it.",
            "        if multipart and not files:",
            "            # Requests will switch to \"multipart/form-data\" only if",
            "            # files pass the `if files:` test, so in this case we use",
            "            # a modified dict that passes the if test even if empty.",
            "            class DictThatReturnsTrue(dict):",
            "                def __bool__(self):",
            "                    return True",
            "                __nonzero__ = __bool__",
            "",
            "            files = DictThatReturnsTrue()",
            "",
            "        return cls._get_request_kwargs(method, url, files=files, **kwargs)",
            "",
            "    def _request(self, form, url=None, **kwargs):",
            "        \"\"\"Extract input data from the form to pass to a Requests session.\"\"\"",
            "        request_kwargs = Browser.get_request_kwargs(form, url, **kwargs)",
            "        return self.session.request(**request_kwargs)",
            "",
            "    def submit(self, form, url=None, **kwargs):",
            "        \"\"\"Prepares and sends a form request.",
            "",
            "        NOTE: To submit a form with a :class:`StatefulBrowser` instance, it is",
            "        recommended to use :func:`StatefulBrowser.submit_selected` instead of",
            "        this method so that the browser state is correctly updated.",
            "",
            "        :param form: The filled-out form.",
            "        :param url: URL of the page the form is on. If the form action is a",
            "            relative path, then this must be specified.",
            "        :param \\\\*\\\\*kwargs: Arguments forwarded to `requests.Session.request",
            "            <http://docs.python-requests.org/en/master/api/#requests.Session.request>`__.",
            "            If `files`, `params` (with GET), or `data` (with POST) are",
            "            specified, they will be appended to by the contents of `form`.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "        \"\"\"",
            "        if isinstance(form, Form):",
            "            form = form.form",
            "        response = self._request(form, url, **kwargs)",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    def launch_browser(self, soup):",
            "        \"\"\"Launch a browser to display a page, for debugging purposes.",
            "",
            "        :param: soup: Page contents to display, supplied as a bs4 soup object.",
            "        \"\"\"",
            "        with tempfile.NamedTemporaryFile(delete=False, suffix='.html') as file:",
            "            file.write(soup.encode())",
            "        webbrowser.open('file://' + file.name)",
            "",
            "    def close(self):",
            "        \"\"\"Close the current session, if still open.\"\"\"",
            "        if self.session is not None:",
            "            self.session.cookies.clear()",
            "            self.session.close()",
            "            self.session = None",
            "",
            "    def __del__(self):",
            "        self._finalize()",
            "",
            "    def __enter__(self):",
            "        return self",
            "",
            "    def __exit__(self, *args):",
            "        self.close()"
        ],
        "afterPatchFile": [
            "import io",
            "import os",
            "import tempfile",
            "import urllib",
            "import weakref",
            "import webbrowser",
            "",
            "import bs4",
            "import bs4.dammit",
            "import requests",
            "",
            "from .__version__ import __title__, __version__",
            "from .form import Form",
            "from .utils import LinkNotFoundError, is_multipart_file_upload",
            "",
            "",
            "class Browser:",
            "    \"\"\"Builds a low-level Browser.",
            "",
            "    It is recommended to use :class:`StatefulBrowser` for most applications,",
            "    since it offers more advanced features and conveniences than Browser.",
            "",
            "    :param session: Attach a pre-existing requests Session instead of",
            "        constructing a new one.",
            "    :param soup_config: Configuration passed to BeautifulSoup to affect",
            "        the way HTML is parsed. Defaults to ``{'features': 'lxml'}``.",
            "        If overridden, it is highly recommended to `specify a parser",
            "        <https://www.crummy.com/software/BeautifulSoup/bs4/doc/#specifying-the-parser-to-use>`__.",
            "        Otherwise, BeautifulSoup will issue a warning and pick one for",
            "        you, but the parser it chooses may be different on different",
            "        machines.",
            "    :param requests_adapters: Configuration passed to requests, to affect",
            "        the way HTTP requests are performed.",
            "    :param raise_on_404: If True, raise :class:`LinkNotFoundError`",
            "        when visiting a page triggers a 404 Not Found error.",
            "    :param user_agent: Set the user agent header to this value.",
            "",
            "    \"\"\"",
            "    def __init__(self, session=None, soup_config={'features': 'lxml'},",
            "                 requests_adapters=None,",
            "                 raise_on_404=False, user_agent=None):",
            "",
            "        self.raise_on_404 = raise_on_404",
            "        self.session = session or requests.Session()",
            "",
            "        if hasattr(weakref, 'finalize'):",
            "            self._finalize = weakref.finalize(self.session, self.close)",
            "        else:   # pragma: no cover",
            "            # Python < 3 does not have weakref.finalize, but these",
            "            # versions accept calling session.close() within __del__",
            "            self._finalize = self.close",
            "",
            "        self.set_user_agent(user_agent)",
            "",
            "        if requests_adapters is not None:",
            "            for adaptee, adapter in requests_adapters.items():",
            "                self.session.mount(adaptee, adapter)",
            "",
            "        self.soup_config = soup_config or dict()",
            "",
            "    @staticmethod",
            "    def __looks_like_html(response):",
            "        \"\"\"Guesses entity type when Content-Type header is missing.",
            "        Since Content-Type is not strictly required, some servers leave it out.",
            "        \"\"\"",
            "        text = response.text.lstrip().lower()",
            "        return text.startswith('<html') or text.startswith('<!doctype')",
            "",
            "    @staticmethod",
            "    def add_soup(response, soup_config):",
            "        \"\"\"Attaches a soup object to a requests response.\"\"\"",
            "        if (\"text/html\" in response.headers.get(\"Content-Type\", \"\") or",
            "                Browser.__looks_like_html(response)):",
            "            # Note: By default (no charset provided in HTTP headers), requests",
            "            # returns 'ISO-8859-1' which is the default for HTML4, even if HTML",
            "            # code specifies a different encoding. In this case, we want to",
            "            # resort to bs4 sniffing, hence the special handling here.",
            "            http_encoding = (",
            "                response.encoding",
            "                if 'charset' in response.headers.get(\"Content-Type\", \"\")",
            "                else None",
            "            )",
            "            html_encoding = bs4.dammit.EncodingDetector.find_declared_encoding(",
            "                response.content,",
            "                is_html=True",
            "            )",
            "            # See https://www.w3.org/International/questions/qa-html-encoding-declarations.en#httphead  # noqa: E501",
            "            # > The HTTP header has a higher precedence than the in-document",
            "            # > meta declarations.",
            "            encoding = http_encoding if http_encoding else html_encoding",
            "            response.soup = bs4.BeautifulSoup(",
            "                response.content,",
            "                from_encoding=encoding,",
            "                **soup_config",
            "            )",
            "        else:",
            "            response.soup = None",
            "",
            "    def set_cookiejar(self, cookiejar):",
            "        \"\"\"Replaces the current cookiejar in the requests session. Since the",
            "        session handles cookies automatically without calling this function,",
            "        only use this when default cookie handling is insufficient.",
            "",
            "        :param cookiejar: Any `http.cookiejar.CookieJar",
            "          <https://docs.python.org/3/library/http.cookiejar.html#http.cookiejar.CookieJar>`__",
            "          compatible object.",
            "        \"\"\"",
            "        self.session.cookies = cookiejar",
            "",
            "    def get_cookiejar(self):",
            "        \"\"\"Gets the cookiejar from the requests session.\"\"\"",
            "        return self.session.cookies",
            "",
            "    def set_user_agent(self, user_agent):",
            "        \"\"\"Replaces the current user agent in the requests session headers.\"\"\"",
            "        # set a default user_agent if not specified",
            "        if user_agent is None:",
            "            requests_ua = requests.utils.default_user_agent()",
            "            user_agent = f'{requests_ua} ({__title__}/{__version__})'",
            "",
            "        # the requests module uses a case-insensitive dict for session headers",
            "        self.session.headers['User-agent'] = user_agent",
            "",
            "    def request(self, *args, **kwargs):",
            "        \"\"\"Straightforward wrapper around `requests.Session.request",
            "        <http://docs.python-requests.org/en/master/api/#requests.Session.request>`__.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "",
            "        This is a low-level function that should not be called for",
            "        basic usage (use :func:`get` or :func:`post` instead). Use it if you",
            "        need an HTTP verb that MechanicalSoup doesn't manage (e.g. MKCOL) for",
            "        example.",
            "        \"\"\"",
            "        response = self.session.request(*args, **kwargs)",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    def get(self, *args, **kwargs):",
            "        \"\"\"Straightforward wrapper around `requests.Session.get",
            "        <http://docs.python-requests.org/en/master/api/#requests.Session.get>`__.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "        \"\"\"",
            "        response = self.session.get(*args, **kwargs)",
            "        if self.raise_on_404 and response.status_code == 404:",
            "            raise LinkNotFoundError()",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    def post(self, *args, **kwargs):",
            "        \"\"\"Straightforward wrapper around `requests.Session.post",
            "        <http://docs.python-requests.org/en/master/api/#requests.Session.post>`__.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "        \"\"\"",
            "        response = self.session.post(*args, **kwargs)",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    def put(self, *args, **kwargs):",
            "        \"\"\"Straightforward wrapper around `requests.Session.put",
            "        <http://docs.python-requests.org/en/master/api/#requests.Session.put>`__.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "        \"\"\"",
            "        response = self.session.put(*args, **kwargs)",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    @staticmethod",
            "    def _get_request_kwargs(method, url, **kwargs):",
            "        \"\"\"This method exists to raise a TypeError when a method or url is",
            "        specified in the kwargs.",
            "        \"\"\"",
            "        request_kwargs = {\"method\": method, \"url\": url}",
            "        request_kwargs.update(kwargs)",
            "        return request_kwargs",
            "",
            "    @classmethod",
            "    def get_request_kwargs(cls, form, url=None, **kwargs):",
            "        \"\"\"Extract input data from the form.\"\"\"",
            "        method = str(form.get(\"method\", \"get\"))",
            "        action = form.get(\"action\")",
            "        url = urllib.parse.urljoin(url, action)",
            "        if url is None:  # This happens when both `action` and `url` are None.",
            "            raise ValueError('no URL to submit to')",
            "",
            "        # read https://www.w3.org/TR/html52/sec-forms.html",
            "        if method.lower() == \"get\":",
            "            data = kwargs.pop(\"params\", dict())",
            "        else:",
            "            data = kwargs.pop(\"data\", dict())",
            "        files = kwargs.pop(\"files\", dict())",
            "",
            "        # Use a list of 2-tuples to better reflect the behavior of browser QSL.",
            "        # Requests also retains order when encoding form data in 2-tuple lists.",
            "        data = [(k, v) for k, v in data.items()]",
            "",
            "        multipart = form.get(\"enctype\", \"\") == \"multipart/form-data\"",
            "",
            "        # Process form tags in the order that they appear on the page,",
            "        # skipping those tags that do not have a name-attribute.",
            "        selector = \",\".join(f\"{tag}[name]\" for tag in",
            "                            (\"input\", \"button\", \"textarea\", \"select\"))",
            "        for tag in form.select(selector):",
            "            name = tag.get(\"name\")  # name-attribute of tag",
            "",
            "            # Skip disabled elements, since they should not be submitted.",
            "            if tag.has_attr('disabled'):",
            "                continue",
            "",
            "            if tag.name == \"input\":",
            "                if tag.get(\"type\", \"\").lower() in (\"radio\", \"checkbox\"):",
            "                    if \"checked\" not in tag.attrs:",
            "                        continue",
            "                    value = tag.get(\"value\", \"on\")",
            "                else:",
            "                    # browsers use empty string for inputs with missing values",
            "                    value = tag.get(\"value\", \"\")",
            "",
            "                # If the enctype is not multipart, the filename is put in",
            "                # the form as a text input and the file is not sent.",
            "                if is_multipart_file_upload(form, tag):",
            "                    if isinstance(value, io.IOBase):",
            "                        content = value",
            "                        filename = os.path.basename(getattr(value, \"name\", \"\"))",
            "                    else:",
            "                        content = \"\"",
            "                        filename = os.path.basename(value)",
            "                    # If content is the empty string, we still pass it",
            "                    # for consistency with browsers (see",
            "                    # https://github.com/MechanicalSoup/MechanicalSoup/issues/250).",
            "                    files[name] = (filename, content)",
            "                else:",
            "                    if isinstance(value, io.IOBase):",
            "                        value = os.path.basename(getattr(value, \"name\", \"\"))",
            "                    data.append((name, value))",
            "",
            "            elif tag.name == \"button\":",
            "                if tag.get(\"type\", \"\").lower() in (\"button\", \"reset\"):",
            "                    continue",
            "                else:",
            "                    data.append((name, tag.get(\"value\", \"\")))",
            "",
            "            elif tag.name == \"textarea\":",
            "                data.append((name, tag.text))",
            "",
            "            elif tag.name == \"select\":",
            "                # If the value attribute is not specified, the content will",
            "                # be passed as a value instead.",
            "                options = tag.select(\"option\")",
            "                selected_values = [i.get(\"value\", i.text) for i in options",
            "                                   if \"selected\" in i.attrs]",
            "                if \"multiple\" in tag.attrs:",
            "                    for value in selected_values:",
            "                        data.append((name, value))",
            "                elif selected_values:",
            "                    # A standard select element only allows one option to be",
            "                    # selected, but browsers pick last if somehow multiple.",
            "                    data.append((name, selected_values[-1]))",
            "                elif options:",
            "                    # Selects the first option if none are selected",
            "                    first_value = options[0].get(\"value\", options[0].text)",
            "                    data.append((name, first_value))",
            "",
            "        if method.lower() == \"get\":",
            "            kwargs[\"params\"] = data",
            "        else:",
            "            kwargs[\"data\"] = data",
            "",
            "        # The following part of the function is here to respect the",
            "        # enctype specified by the form, i.e. force sending multipart",
            "        # content. Since Requests doesn't have yet a feature to choose",
            "        # enctype, we have to use tricks to make it behave as we want",
            "        # This code will be updated if Requests implements it.",
            "        if multipart and not files:",
            "            # Requests will switch to \"multipart/form-data\" only if",
            "            # files pass the `if files:` test, so in this case we use",
            "            # a modified dict that passes the if test even if empty.",
            "            class DictThatReturnsTrue(dict):",
            "                def __bool__(self):",
            "                    return True",
            "                __nonzero__ = __bool__",
            "",
            "            files = DictThatReturnsTrue()",
            "",
            "        return cls._get_request_kwargs(method, url, files=files, **kwargs)",
            "",
            "    def _request(self, form, url=None, **kwargs):",
            "        \"\"\"Extract input data from the form to pass to a Requests session.\"\"\"",
            "        request_kwargs = Browser.get_request_kwargs(form, url, **kwargs)",
            "        return self.session.request(**request_kwargs)",
            "",
            "    def submit(self, form, url=None, **kwargs):",
            "        \"\"\"Prepares and sends a form request.",
            "",
            "        NOTE: To submit a form with a :class:`StatefulBrowser` instance, it is",
            "        recommended to use :func:`StatefulBrowser.submit_selected` instead of",
            "        this method so that the browser state is correctly updated.",
            "",
            "        :param form: The filled-out form.",
            "        :param url: URL of the page the form is on. If the form action is a",
            "            relative path, then this must be specified.",
            "        :param \\\\*\\\\*kwargs: Arguments forwarded to `requests.Session.request",
            "            <http://docs.python-requests.org/en/master/api/#requests.Session.request>`__.",
            "            If `files`, `params` (with GET), or `data` (with POST) are",
            "            specified, they will be appended to by the contents of `form`.",
            "",
            "        :return: `requests.Response",
            "            <http://docs.python-requests.org/en/master/api/#requests.Response>`__",
            "            object with a *soup*-attribute added by :func:`add_soup`.",
            "        \"\"\"",
            "        if isinstance(form, Form):",
            "            form = form.form",
            "        response = self._request(form, url, **kwargs)",
            "        Browser.add_soup(response, self.soup_config)",
            "        return response",
            "",
            "    def launch_browser(self, soup):",
            "        \"\"\"Launch a browser to display a page, for debugging purposes.",
            "",
            "        :param: soup: Page contents to display, supplied as a bs4 soup object.",
            "        \"\"\"",
            "        with tempfile.NamedTemporaryFile(delete=False, suffix='.html') as file:",
            "            file.write(soup.encode())",
            "        webbrowser.open('file://' + file.name)",
            "",
            "    def close(self):",
            "        \"\"\"Close the current session, if still open.\"\"\"",
            "        if self.session is not None:",
            "            self.session.cookies.clear()",
            "            self.session.close()",
            "            self.session = None",
            "",
            "    def __del__(self):",
            "        self._finalize()",
            "",
            "    def __enter__(self):",
            "        return self",
            "",
            "    def __exit__(self, *args):",
            "        self.close()"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [],
            "231": [
                "Browser",
                "get_request_kwargs"
            ],
            "232": [
                "Browser",
                "get_request_kwargs"
            ],
            "233": [
                "Browser",
                "get_request_kwargs"
            ],
            "234": [
                "Browser",
                "get_request_kwargs"
            ],
            "237": [
                "Browser",
                "get_request_kwargs"
            ],
            "238": [
                "Browser",
                "get_request_kwargs"
            ]
        },
        "addLocation": []
    },
    "mechanicalsoup/form.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import copy"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import io"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import warnings"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from bs4 import BeautifulSoup"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .utils import LinkNotFoundError"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from .utils import LinkNotFoundError, is_multipart_file_upload"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " class InvalidFormMethod(LinkNotFoundError):"
            },
            "11": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "             i = self.form.find(\"input\", {\"name\": name})"
            },
            "12": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "             if not i:"
            },
            "13": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "                 raise InvalidFormMethod(\"No input field named \" + name)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+            self._assert_valid_file_upload(i, value)"
            },
            "15": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "             i[\"value\"] = value"
            },
            "16": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     def uncheck_all(self, name):"
            },
            "18": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "             form.set(\"eula-checkbox\", True)"
            },
            "19": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 264,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "         Example: uploading a file through a ``<input type=\"file\""
            },
            "21": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        name=\"tagname\">`` field (provide the path to the local file,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+        name=\"tagname\">`` field (provide an open file object,"
            },
            "23": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "         and its content will be uploaded):"
            },
            "24": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 268,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         .. code-block:: python"
            },
            "26": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 270,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            form.set(\"tagname\", path_to_local_file)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+            form.set(\"tagname\", open(path_to_local_file, \"rb\"))"
            },
            "29": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 272,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "         \"\"\""
            },
            "31": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "         for func in (\"checkbox\", \"radio\", \"input\", \"textarea\", \"select\"):"
            },
            "32": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "         control['value'] = value"
            },
            "33": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "         for k, v in kwargs.items():"
            },
            "34": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "             control[k] = v"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        self._assert_valid_file_upload(control, value)"
            },
            "36": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "         self.form.append(control)"
            },
            "37": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "         return control"
            },
            "38": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 308,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "                 if subtag.string:"
            },
            "40": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "                     subtag.string = subtag.string.strip()"
            },
            "41": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "             print(input_copy)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+    def _assert_valid_file_upload(self, tag, value):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+        \"\"\"Raise an exception if a multipart file input is not an open file.\"\"\""
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+        if ("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+            is_multipart_file_upload(self.form, tag) and"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+            not isinstance(value, io.IOBase)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+        ):"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+            raise ValueError("
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+                \"From v1.3.0 onwards, you must pass an open file object \""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+                'directly, e.g. `form[\"name\"] = open(\"/path/to/file\", \"rb\")`. '"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+                \"This change is to remediate a security vulnerability where \""
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+                \"a malicious web server could read arbitrary files from the \""
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+                \"client (CVE-2023-34457).\""
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+            )"
            }
        },
        "frontPatchFile": [
            "import copy",
            "import warnings",
            "",
            "from bs4 import BeautifulSoup",
            "",
            "from .utils import LinkNotFoundError",
            "",
            "",
            "class InvalidFormMethod(LinkNotFoundError):",
            "    \"\"\"This exception is raised when a method of :class:`Form` is used",
            "    for an HTML element that is of the wrong type (or is malformed).",
            "    It is caught within :func:`Form.set` to perform element type deduction.",
            "",
            "    It is derived from :class:`LinkNotFoundError` so that a single base class",
            "    can be used to catch all exceptions specific to this module.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Form:",
            "    \"\"\"Build a fillable form.",
            "",
            "    :param form: A bs4.element.Tag corresponding to an HTML form element.",
            "",
            "    The Form class is responsible for preparing HTML forms for submission.",
            "    It handles the following types of elements:",
            "    input (text, checkbox, radio), select, and textarea.",
            "",
            "    Each type is set by a method named after the type (e.g.",
            "    :func:`~Form.set_select`), and then there are convenience methods (e.g.",
            "    :func:`~Form.set`) that do type-deduction and set the value using the",
            "    appropriate method.",
            "",
            "    It also handles submit-type elements using :func:`~Form.choose_submit`.",
            "    \"\"\"",
            "",
            "    def __init__(self, form):",
            "        if form.name != 'form':",
            "            warnings.warn(",
            "                f\"Constructed a Form from a '{form.name}' instead of a 'form' \"",
            "                \" element. This may be an error in a future version of \"",
            "                \"MechanicalSoup.\", FutureWarning)",
            "",
            "        self.form = form",
            "        self._submit_chosen = False",
            "",
            "        # Aliases for backwards compatibility",
            "        # (Included specifically in __init__ to suppress them in Sphinx docs)",
            "        self.attach = self.set_input",
            "        self.input = self.set_input",
            "        self.textarea = self.set_textarea",
            "",
            "    def set_input(self, data):",
            "        \"\"\"Fill-in a set of fields in a form.",
            "",
            "        Example: filling-in a login/password form",
            "",
            "        .. code-block:: python",
            "",
            "           form.set_input({\"login\": username, \"password\": password})",
            "",
            "        This will find the input element named \"login\" and give it the",
            "        value ``username``, and the input element named \"password\" and",
            "        give it the value ``password``.",
            "        \"\"\"",
            "",
            "        for (name, value) in data.items():",
            "            i = self.form.find(\"input\", {\"name\": name})",
            "            if not i:",
            "                raise InvalidFormMethod(\"No input field named \" + name)",
            "            i[\"value\"] = value",
            "",
            "    def uncheck_all(self, name):",
            "        \"\"\"Remove the *checked*-attribute of all input elements with",
            "        a *name*-attribute given by ``name``.",
            "        \"\"\"",
            "        for option in self.form.find_all(\"input\", {\"name\": name}):",
            "            if \"checked\" in option.attrs:",
            "                del option.attrs[\"checked\"]",
            "",
            "    def check(self, data):",
            "        \"\"\"For backwards compatibility, this method handles checkboxes",
            "        and radio buttons in a single call. It will not uncheck any",
            "        checkboxes unless explicitly specified by ``data``, in contrast",
            "        with the default behavior of :func:`~Form.set_checkbox`.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            try:",
            "                self.set_checkbox({name: value}, uncheck_other_boxes=False)",
            "                continue",
            "            except InvalidFormMethod:",
            "                pass",
            "            try:",
            "                self.set_radio({name: value})",
            "                continue",
            "            except InvalidFormMethod:",
            "                pass",
            "            raise LinkNotFoundError(\"No input checkbox/radio named \" + name)",
            "",
            "    def set_checkbox(self, data, uncheck_other_boxes=True):",
            "        \"\"\"Set the *checked*-attribute of input elements of type \"checkbox\"",
            "        specified by ``data`` (i.e. check boxes).",
            "",
            "        :param data: Dict of ``{name: value, ...}``.",
            "            In the family of checkboxes whose *name*-attribute is ``name``,",
            "            check the box whose *value*-attribute is ``value``. All boxes in",
            "            the family can be checked (unchecked) if ``value`` is True (False).",
            "            To check multiple specific boxes, let ``value`` be a tuple or list.",
            "        :param uncheck_other_boxes: If True (default), before checking any",
            "            boxes specified by ``data``, uncheck the entire checkbox family.",
            "            Consider setting to False if some boxes are checked by default when",
            "            the HTML is served.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            # Case-insensitive search for type=checkbox",
            "            selector = 'input[type=\"checkbox\" i][name=\"{}\"]'.format(name)",
            "            checkboxes = self.form.select(selector)",
            "            if not checkboxes:",
            "                raise InvalidFormMethod(\"No input checkbox named \" + name)",
            "",
            "            # uncheck if requested",
            "            if uncheck_other_boxes:",
            "                self.uncheck_all(name)",
            "",
            "            # Wrap individual values (e.g. int, str) in a 1-element tuple.",
            "            if not isinstance(value, list) and not isinstance(value, tuple):",
            "                value = (value,)",
            "",
            "            # Check or uncheck one or more boxes",
            "            for choice in value:",
            "                choice_str = str(choice)  # Allow for example literal numbers",
            "                for checkbox in checkboxes:",
            "                    if checkbox.attrs.get(\"value\", \"on\") == choice_str:",
            "                        checkbox[\"checked\"] = \"\"",
            "                        break",
            "                    # Allow specifying True or False to check/uncheck",
            "                    elif choice is True:",
            "                        checkbox[\"checked\"] = \"\"",
            "                        break",
            "                    elif choice is False:",
            "                        if \"checked\" in checkbox.attrs:",
            "                            del checkbox.attrs[\"checked\"]",
            "                        break",
            "                else:",
            "                    raise LinkNotFoundError(",
            "                        \"No input checkbox named %s with choice %s\" %",
            "                        (name, choice)",
            "                    )",
            "",
            "    def set_radio(self, data):",
            "        \"\"\"Set the *checked*-attribute of input elements of type \"radio\"",
            "        specified by ``data`` (i.e. select radio buttons).",
            "",
            "        :param data: Dict of ``{name: value, ...}``.",
            "            In the family of radio buttons whose *name*-attribute is ``name``,",
            "            check the radio button whose *value*-attribute is ``value``.",
            "            Only one radio button in the family can be checked.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            # Case-insensitive search for type=radio",
            "            selector = 'input[type=\"radio\" i][name=\"{}\"]'.format(name)",
            "            radios = self.form.select(selector)",
            "            if not radios:",
            "                raise InvalidFormMethod(\"No input radio named \" + name)",
            "",
            "            # only one radio button can be checked",
            "            self.uncheck_all(name)",
            "",
            "            # Check the appropriate radio button (value cannot be a list/tuple)",
            "            for radio in radios:",
            "                if radio.attrs.get(\"value\", \"on\") == str(value):",
            "                    radio[\"checked\"] = \"\"",
            "                    break",
            "            else:",
            "                raise LinkNotFoundError(",
            "                    f\"No input radio named {name} with choice {value}\"",
            "                )",
            "",
            "    def set_textarea(self, data):",
            "        \"\"\"Set the *string*-attribute of the first textarea element",
            "        specified by ``data`` (i.e. set the text of a textarea).",
            "",
            "        :param data: Dict of ``{name: value, ...}``.",
            "            The textarea whose *name*-attribute is ``name`` will have",
            "            its *string*-attribute set to ``value``.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            t = self.form.find(\"textarea\", {\"name\": name})",
            "            if not t:",
            "                raise InvalidFormMethod(\"No textarea named \" + name)",
            "            t.string = value",
            "",
            "    def set_select(self, data):",
            "        \"\"\"Set the *selected*-attribute of the first option element",
            "        specified by ``data`` (i.e. select an option from a dropdown).",
            "",
            "        :param data: Dict of ``{name: value, ...}``.",
            "            Find the select element whose *name*-attribute is ``name``.",
            "            Then select from among its children the option element whose",
            "            *value*-attribute is ``value``. If no matching *value*-attribute",
            "            is found, this will search for an option whose text matches",
            "            ``value``. If the select element's *multiple*-attribute is set,",
            "            then ``value`` can be a list or tuple to select multiple options.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            select = self.form.find(\"select\", {\"name\": name})",
            "            if not select:",
            "                raise InvalidFormMethod(\"No select named \" + name)",
            "",
            "            # Deselect all options first",
            "            for option in select.find_all(\"option\"):",
            "                if \"selected\" in option.attrs:",
            "                    del option.attrs[\"selected\"]",
            "",
            "            # Wrap individual values in a 1-element tuple.",
            "            # If value is a list/tuple, select must be a <select multiple>.",
            "            if not isinstance(value, list) and not isinstance(value, tuple):",
            "                value = (value,)",
            "            elif \"multiple\" not in select.attrs:",
            "                raise LinkNotFoundError(\"Cannot select multiple options!\")",
            "",
            "            for choice in value:",
            "                option = select.find(\"option\", {\"value\": choice})",
            "",
            "                # try to find with text instead of value",
            "                if not option:",
            "                    option = select.find(\"option\", string=choice)",
            "",
            "                if not option:",
            "                    raise LinkNotFoundError(",
            "                        f'Option {choice} not found for select {name}'",
            "                    )",
            "",
            "                option.attrs[\"selected\"] = \"selected\"",
            "",
            "    def __setitem__(self, name, value):",
            "        \"\"\"Forwards arguments to :func:`~Form.set`. For example,",
            "        :code:`form[\"name\"] = \"value\"` calls :code:`form.set(\"name\", \"value\")`.",
            "        \"\"\"",
            "        return self.set(name, value)",
            "",
            "    def set(self, name, value, force=False):",
            "        \"\"\"Set a form element identified by ``name`` to a specified ``value``.",
            "        The type of element (input, textarea, select, ...) does not",
            "        need to be given; it is inferred by the following methods:",
            "        :func:`~Form.set_checkbox`,",
            "        :func:`~Form.set_radio`,",
            "        :func:`~Form.set_input`,",
            "        :func:`~Form.set_textarea`,",
            "        :func:`~Form.set_select`.",
            "        If none of these methods find a matching element, then if ``force``",
            "        is True, a new element (``<input type=\"text\" ...>``) will be",
            "        added using :func:`~Form.new_control`.",
            "",
            "        Example: filling-in a login/password form with EULA checkbox",
            "",
            "        .. code-block:: python",
            "",
            "            form.set(\"login\", username)",
            "            form.set(\"password\", password)",
            "            form.set(\"eula-checkbox\", True)",
            "",
            "        Example: uploading a file through a ``<input type=\"file\"",
            "        name=\"tagname\">`` field (provide the path to the local file,",
            "        and its content will be uploaded):",
            "",
            "        .. code-block:: python",
            "",
            "            form.set(\"tagname\", path_to_local_file)",
            "",
            "        \"\"\"",
            "        for func in (\"checkbox\", \"radio\", \"input\", \"textarea\", \"select\"):",
            "            try:",
            "                getattr(self, \"set_\" + func)({name: value})",
            "                return",
            "            except InvalidFormMethod:",
            "                pass",
            "        if force:",
            "            self.new_control('text', name, value=value)",
            "            return",
            "        raise LinkNotFoundError(\"No valid element named \" + name)",
            "",
            "    def new_control(self, type, name, value, **kwargs):",
            "        \"\"\"Add a new input element to the form.",
            "",
            "        The arguments set the attributes of the new element.",
            "        \"\"\"",
            "        # Remove existing input-like elements with the same name",
            "        for tag in ('input', 'textarea', 'select'):",
            "            for old in self.form.find_all(tag, {'name': name}):",
            "                old.decompose()",
            "        # We don't have access to the original soup object (just the",
            "        # Tag), so we instantiate a new BeautifulSoup() to call",
            "        # new_tag(). We're only building the soup object, not parsing",
            "        # anything, so the parser doesn't matter. Specify the one",
            "        # included in Python to avoid having dependency issue.",
            "        control = BeautifulSoup(\"\", \"html.parser\").new_tag('input')",
            "        control['type'] = type",
            "        control['name'] = name",
            "        control['value'] = value",
            "        for k, v in kwargs.items():",
            "            control[k] = v",
            "        self.form.append(control)",
            "        return control",
            "",
            "    def choose_submit(self, submit):",
            "        \"\"\"Selects the input (or button) element to use for form submission.",
            "",
            "        :param submit: The :class:`bs4.element.Tag` (or just its",
            "            *name*-attribute) that identifies the submit element to use. If",
            "            ``None``, will choose the first valid submit element in the form,",
            "            if one exists. If ``False``, will not use any submit element;",
            "            this is useful for simulating AJAX requests, for example.",
            "",
            "        To simulate a normal web browser, only one submit element must be",
            "        sent. Therefore, this does not need to be called if there is only",
            "        one submit element in the form.",
            "",
            "        If the element is not found or if multiple elements match, raise a",
            "        :class:`LinkNotFoundError` exception.",
            "",
            "        Example: ::",
            "",
            "            browser = mechanicalsoup.StatefulBrowser()",
            "            browser.open(url)",
            "            form = browser.select_form()",
            "            form.choose_submit('form_name_attr')",
            "            browser.submit_selected()",
            "        \"\"\"",
            "        # Since choose_submit is destructive, it doesn't make sense to call",
            "        # this method twice unless no submit is specified.",
            "        if self._submit_chosen:",
            "            if submit is None:",
            "                return",
            "            else:",
            "                raise Exception('Submit already chosen. Cannot change submit!')",
            "",
            "        # All buttons NOT of type (button,reset) are valid submits",
            "        # Case-insensitive search for type=submit",
            "        inps = [i for i in self.form.select('input[type=\"submit\" i], button')",
            "                if i.get(\"type\", \"\").lower() not in ('button', 'reset')]",
            "",
            "        # If no submit specified, choose the first one",
            "        if submit is None and inps:",
            "            submit = inps[0]",
            "",
            "        found = False",
            "        for inp in inps:",
            "            if (inp.has_attr('name') and inp['name'] == submit):",
            "                if found:",
            "                    raise LinkNotFoundError(",
            "                        f\"Multiple submit elements match: {submit}\"",
            "                    )",
            "                found = True",
            "            elif inp == submit:",
            "                if found:",
            "                    # Ignore submit element since it is an exact",
            "                    # duplicate of the one we're looking at.",
            "                    del inp['name']",
            "                found = True",
            "            else:",
            "                # Delete any non-matching element's name so that it will be",
            "                # omitted from the submitted form data.",
            "                del inp['name']",
            "",
            "        if not found and submit is not None and submit is not False:",
            "            raise LinkNotFoundError(",
            "                f\"Specified submit element not found: {submit}\"",
            "            )",
            "        self._submit_chosen = True",
            "",
            "    def print_summary(self):",
            "        \"\"\"Print a summary of the form.",
            "",
            "        May help finding which fields need to be filled-in.",
            "        \"\"\"",
            "        for input in self.form.find_all(",
            "                (\"input\", \"textarea\", \"select\", \"button\")):",
            "            input_copy = copy.copy(input)",
            "            # Text between the opening tag and the closing tag often",
            "            # contains a lot of spaces that we don't want here.",
            "            for subtag in input_copy.find_all() + [input_copy]:",
            "                if subtag.string:",
            "                    subtag.string = subtag.string.strip()",
            "            print(input_copy)"
        ],
        "afterPatchFile": [
            "import copy",
            "import io",
            "import warnings",
            "",
            "from bs4 import BeautifulSoup",
            "",
            "from .utils import LinkNotFoundError, is_multipart_file_upload",
            "",
            "",
            "class InvalidFormMethod(LinkNotFoundError):",
            "    \"\"\"This exception is raised when a method of :class:`Form` is used",
            "    for an HTML element that is of the wrong type (or is malformed).",
            "    It is caught within :func:`Form.set` to perform element type deduction.",
            "",
            "    It is derived from :class:`LinkNotFoundError` so that a single base class",
            "    can be used to catch all exceptions specific to this module.",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class Form:",
            "    \"\"\"Build a fillable form.",
            "",
            "    :param form: A bs4.element.Tag corresponding to an HTML form element.",
            "",
            "    The Form class is responsible for preparing HTML forms for submission.",
            "    It handles the following types of elements:",
            "    input (text, checkbox, radio), select, and textarea.",
            "",
            "    Each type is set by a method named after the type (e.g.",
            "    :func:`~Form.set_select`), and then there are convenience methods (e.g.",
            "    :func:`~Form.set`) that do type-deduction and set the value using the",
            "    appropriate method.",
            "",
            "    It also handles submit-type elements using :func:`~Form.choose_submit`.",
            "    \"\"\"",
            "",
            "    def __init__(self, form):",
            "        if form.name != 'form':",
            "            warnings.warn(",
            "                f\"Constructed a Form from a '{form.name}' instead of a 'form' \"",
            "                \" element. This may be an error in a future version of \"",
            "                \"MechanicalSoup.\", FutureWarning)",
            "",
            "        self.form = form",
            "        self._submit_chosen = False",
            "",
            "        # Aliases for backwards compatibility",
            "        # (Included specifically in __init__ to suppress them in Sphinx docs)",
            "        self.attach = self.set_input",
            "        self.input = self.set_input",
            "        self.textarea = self.set_textarea",
            "",
            "    def set_input(self, data):",
            "        \"\"\"Fill-in a set of fields in a form.",
            "",
            "        Example: filling-in a login/password form",
            "",
            "        .. code-block:: python",
            "",
            "           form.set_input({\"login\": username, \"password\": password})",
            "",
            "        This will find the input element named \"login\" and give it the",
            "        value ``username``, and the input element named \"password\" and",
            "        give it the value ``password``.",
            "        \"\"\"",
            "",
            "        for (name, value) in data.items():",
            "            i = self.form.find(\"input\", {\"name\": name})",
            "            if not i:",
            "                raise InvalidFormMethod(\"No input field named \" + name)",
            "            self._assert_valid_file_upload(i, value)",
            "            i[\"value\"] = value",
            "",
            "    def uncheck_all(self, name):",
            "        \"\"\"Remove the *checked*-attribute of all input elements with",
            "        a *name*-attribute given by ``name``.",
            "        \"\"\"",
            "        for option in self.form.find_all(\"input\", {\"name\": name}):",
            "            if \"checked\" in option.attrs:",
            "                del option.attrs[\"checked\"]",
            "",
            "    def check(self, data):",
            "        \"\"\"For backwards compatibility, this method handles checkboxes",
            "        and radio buttons in a single call. It will not uncheck any",
            "        checkboxes unless explicitly specified by ``data``, in contrast",
            "        with the default behavior of :func:`~Form.set_checkbox`.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            try:",
            "                self.set_checkbox({name: value}, uncheck_other_boxes=False)",
            "                continue",
            "            except InvalidFormMethod:",
            "                pass",
            "            try:",
            "                self.set_radio({name: value})",
            "                continue",
            "            except InvalidFormMethod:",
            "                pass",
            "            raise LinkNotFoundError(\"No input checkbox/radio named \" + name)",
            "",
            "    def set_checkbox(self, data, uncheck_other_boxes=True):",
            "        \"\"\"Set the *checked*-attribute of input elements of type \"checkbox\"",
            "        specified by ``data`` (i.e. check boxes).",
            "",
            "        :param data: Dict of ``{name: value, ...}``.",
            "            In the family of checkboxes whose *name*-attribute is ``name``,",
            "            check the box whose *value*-attribute is ``value``. All boxes in",
            "            the family can be checked (unchecked) if ``value`` is True (False).",
            "            To check multiple specific boxes, let ``value`` be a tuple or list.",
            "        :param uncheck_other_boxes: If True (default), before checking any",
            "            boxes specified by ``data``, uncheck the entire checkbox family.",
            "            Consider setting to False if some boxes are checked by default when",
            "            the HTML is served.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            # Case-insensitive search for type=checkbox",
            "            selector = 'input[type=\"checkbox\" i][name=\"{}\"]'.format(name)",
            "            checkboxes = self.form.select(selector)",
            "            if not checkboxes:",
            "                raise InvalidFormMethod(\"No input checkbox named \" + name)",
            "",
            "            # uncheck if requested",
            "            if uncheck_other_boxes:",
            "                self.uncheck_all(name)",
            "",
            "            # Wrap individual values (e.g. int, str) in a 1-element tuple.",
            "            if not isinstance(value, list) and not isinstance(value, tuple):",
            "                value = (value,)",
            "",
            "            # Check or uncheck one or more boxes",
            "            for choice in value:",
            "                choice_str = str(choice)  # Allow for example literal numbers",
            "                for checkbox in checkboxes:",
            "                    if checkbox.attrs.get(\"value\", \"on\") == choice_str:",
            "                        checkbox[\"checked\"] = \"\"",
            "                        break",
            "                    # Allow specifying True or False to check/uncheck",
            "                    elif choice is True:",
            "                        checkbox[\"checked\"] = \"\"",
            "                        break",
            "                    elif choice is False:",
            "                        if \"checked\" in checkbox.attrs:",
            "                            del checkbox.attrs[\"checked\"]",
            "                        break",
            "                else:",
            "                    raise LinkNotFoundError(",
            "                        \"No input checkbox named %s with choice %s\" %",
            "                        (name, choice)",
            "                    )",
            "",
            "    def set_radio(self, data):",
            "        \"\"\"Set the *checked*-attribute of input elements of type \"radio\"",
            "        specified by ``data`` (i.e. select radio buttons).",
            "",
            "        :param data: Dict of ``{name: value, ...}``.",
            "            In the family of radio buttons whose *name*-attribute is ``name``,",
            "            check the radio button whose *value*-attribute is ``value``.",
            "            Only one radio button in the family can be checked.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            # Case-insensitive search for type=radio",
            "            selector = 'input[type=\"radio\" i][name=\"{}\"]'.format(name)",
            "            radios = self.form.select(selector)",
            "            if not radios:",
            "                raise InvalidFormMethod(\"No input radio named \" + name)",
            "",
            "            # only one radio button can be checked",
            "            self.uncheck_all(name)",
            "",
            "            # Check the appropriate radio button (value cannot be a list/tuple)",
            "            for radio in radios:",
            "                if radio.attrs.get(\"value\", \"on\") == str(value):",
            "                    radio[\"checked\"] = \"\"",
            "                    break",
            "            else:",
            "                raise LinkNotFoundError(",
            "                    f\"No input radio named {name} with choice {value}\"",
            "                )",
            "",
            "    def set_textarea(self, data):",
            "        \"\"\"Set the *string*-attribute of the first textarea element",
            "        specified by ``data`` (i.e. set the text of a textarea).",
            "",
            "        :param data: Dict of ``{name: value, ...}``.",
            "            The textarea whose *name*-attribute is ``name`` will have",
            "            its *string*-attribute set to ``value``.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            t = self.form.find(\"textarea\", {\"name\": name})",
            "            if not t:",
            "                raise InvalidFormMethod(\"No textarea named \" + name)",
            "            t.string = value",
            "",
            "    def set_select(self, data):",
            "        \"\"\"Set the *selected*-attribute of the first option element",
            "        specified by ``data`` (i.e. select an option from a dropdown).",
            "",
            "        :param data: Dict of ``{name: value, ...}``.",
            "            Find the select element whose *name*-attribute is ``name``.",
            "            Then select from among its children the option element whose",
            "            *value*-attribute is ``value``. If no matching *value*-attribute",
            "            is found, this will search for an option whose text matches",
            "            ``value``. If the select element's *multiple*-attribute is set,",
            "            then ``value`` can be a list or tuple to select multiple options.",
            "        \"\"\"",
            "        for (name, value) in data.items():",
            "            select = self.form.find(\"select\", {\"name\": name})",
            "            if not select:",
            "                raise InvalidFormMethod(\"No select named \" + name)",
            "",
            "            # Deselect all options first",
            "            for option in select.find_all(\"option\"):",
            "                if \"selected\" in option.attrs:",
            "                    del option.attrs[\"selected\"]",
            "",
            "            # Wrap individual values in a 1-element tuple.",
            "            # If value is a list/tuple, select must be a <select multiple>.",
            "            if not isinstance(value, list) and not isinstance(value, tuple):",
            "                value = (value,)",
            "            elif \"multiple\" not in select.attrs:",
            "                raise LinkNotFoundError(\"Cannot select multiple options!\")",
            "",
            "            for choice in value:",
            "                option = select.find(\"option\", {\"value\": choice})",
            "",
            "                # try to find with text instead of value",
            "                if not option:",
            "                    option = select.find(\"option\", string=choice)",
            "",
            "                if not option:",
            "                    raise LinkNotFoundError(",
            "                        f'Option {choice} not found for select {name}'",
            "                    )",
            "",
            "                option.attrs[\"selected\"] = \"selected\"",
            "",
            "    def __setitem__(self, name, value):",
            "        \"\"\"Forwards arguments to :func:`~Form.set`. For example,",
            "        :code:`form[\"name\"] = \"value\"` calls :code:`form.set(\"name\", \"value\")`.",
            "        \"\"\"",
            "        return self.set(name, value)",
            "",
            "    def set(self, name, value, force=False):",
            "        \"\"\"Set a form element identified by ``name`` to a specified ``value``.",
            "        The type of element (input, textarea, select, ...) does not",
            "        need to be given; it is inferred by the following methods:",
            "        :func:`~Form.set_checkbox`,",
            "        :func:`~Form.set_radio`,",
            "        :func:`~Form.set_input`,",
            "        :func:`~Form.set_textarea`,",
            "        :func:`~Form.set_select`.",
            "        If none of these methods find a matching element, then if ``force``",
            "        is True, a new element (``<input type=\"text\" ...>``) will be",
            "        added using :func:`~Form.new_control`.",
            "",
            "        Example: filling-in a login/password form with EULA checkbox",
            "",
            "        .. code-block:: python",
            "",
            "            form.set(\"login\", username)",
            "            form.set(\"password\", password)",
            "            form.set(\"eula-checkbox\", True)",
            "",
            "        Example: uploading a file through a ``<input type=\"file\"",
            "        name=\"tagname\">`` field (provide an open file object,",
            "        and its content will be uploaded):",
            "",
            "        .. code-block:: python",
            "",
            "            form.set(\"tagname\", open(path_to_local_file, \"rb\"))",
            "",
            "        \"\"\"",
            "        for func in (\"checkbox\", \"radio\", \"input\", \"textarea\", \"select\"):",
            "            try:",
            "                getattr(self, \"set_\" + func)({name: value})",
            "                return",
            "            except InvalidFormMethod:",
            "                pass",
            "        if force:",
            "            self.new_control('text', name, value=value)",
            "            return",
            "        raise LinkNotFoundError(\"No valid element named \" + name)",
            "",
            "    def new_control(self, type, name, value, **kwargs):",
            "        \"\"\"Add a new input element to the form.",
            "",
            "        The arguments set the attributes of the new element.",
            "        \"\"\"",
            "        # Remove existing input-like elements with the same name",
            "        for tag in ('input', 'textarea', 'select'):",
            "            for old in self.form.find_all(tag, {'name': name}):",
            "                old.decompose()",
            "        # We don't have access to the original soup object (just the",
            "        # Tag), so we instantiate a new BeautifulSoup() to call",
            "        # new_tag(). We're only building the soup object, not parsing",
            "        # anything, so the parser doesn't matter. Specify the one",
            "        # included in Python to avoid having dependency issue.",
            "        control = BeautifulSoup(\"\", \"html.parser\").new_tag('input')",
            "        control['type'] = type",
            "        control['name'] = name",
            "        control['value'] = value",
            "        for k, v in kwargs.items():",
            "            control[k] = v",
            "        self._assert_valid_file_upload(control, value)",
            "        self.form.append(control)",
            "        return control",
            "",
            "    def choose_submit(self, submit):",
            "        \"\"\"Selects the input (or button) element to use for form submission.",
            "",
            "        :param submit: The :class:`bs4.element.Tag` (or just its",
            "            *name*-attribute) that identifies the submit element to use. If",
            "            ``None``, will choose the first valid submit element in the form,",
            "            if one exists. If ``False``, will not use any submit element;",
            "            this is useful for simulating AJAX requests, for example.",
            "",
            "        To simulate a normal web browser, only one submit element must be",
            "        sent. Therefore, this does not need to be called if there is only",
            "        one submit element in the form.",
            "",
            "        If the element is not found or if multiple elements match, raise a",
            "        :class:`LinkNotFoundError` exception.",
            "",
            "        Example: ::",
            "",
            "            browser = mechanicalsoup.StatefulBrowser()",
            "            browser.open(url)",
            "            form = browser.select_form()",
            "            form.choose_submit('form_name_attr')",
            "            browser.submit_selected()",
            "        \"\"\"",
            "        # Since choose_submit is destructive, it doesn't make sense to call",
            "        # this method twice unless no submit is specified.",
            "        if self._submit_chosen:",
            "            if submit is None:",
            "                return",
            "            else:",
            "                raise Exception('Submit already chosen. Cannot change submit!')",
            "",
            "        # All buttons NOT of type (button,reset) are valid submits",
            "        # Case-insensitive search for type=submit",
            "        inps = [i for i in self.form.select('input[type=\"submit\" i], button')",
            "                if i.get(\"type\", \"\").lower() not in ('button', 'reset')]",
            "",
            "        # If no submit specified, choose the first one",
            "        if submit is None and inps:",
            "            submit = inps[0]",
            "",
            "        found = False",
            "        for inp in inps:",
            "            if (inp.has_attr('name') and inp['name'] == submit):",
            "                if found:",
            "                    raise LinkNotFoundError(",
            "                        f\"Multiple submit elements match: {submit}\"",
            "                    )",
            "                found = True",
            "            elif inp == submit:",
            "                if found:",
            "                    # Ignore submit element since it is an exact",
            "                    # duplicate of the one we're looking at.",
            "                    del inp['name']",
            "                found = True",
            "            else:",
            "                # Delete any non-matching element's name so that it will be",
            "                # omitted from the submitted form data.",
            "                del inp['name']",
            "",
            "        if not found and submit is not None and submit is not False:",
            "            raise LinkNotFoundError(",
            "                f\"Specified submit element not found: {submit}\"",
            "            )",
            "        self._submit_chosen = True",
            "",
            "    def print_summary(self):",
            "        \"\"\"Print a summary of the form.",
            "",
            "        May help finding which fields need to be filled-in.",
            "        \"\"\"",
            "        for input in self.form.find_all(",
            "                (\"input\", \"textarea\", \"select\", \"button\")):",
            "            input_copy = copy.copy(input)",
            "            # Text between the opening tag and the closing tag often",
            "            # contains a lot of spaces that we don't want here.",
            "            for subtag in input_copy.find_all() + [input_copy]:",
            "                if subtag.string:",
            "                    subtag.string = subtag.string.strip()",
            "            print(input_copy)",
            "",
            "    def _assert_valid_file_upload(self, tag, value):",
            "        \"\"\"Raise an exception if a multipart file input is not an open file.\"\"\"",
            "        if (",
            "            is_multipart_file_upload(self.form, tag) and",
            "            not isinstance(value, io.IOBase)",
            "        ):",
            "            raise ValueError(",
            "                \"From v1.3.0 onwards, you must pass an open file object \"",
            "                'directly, e.g. `form[\"name\"] = open(\"/path/to/file\", \"rb\")`. '",
            "                \"This change is to remediate a security vulnerability where \"",
            "                \"a malicious web server could read arbitrary files from the \"",
            "                \"client (CVE-2023-34457).\"",
            "            )"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "6": [],
            "264": [
                "Form",
                "set"
            ],
            "269": [
                "Form",
                "set"
            ]
        },
        "addLocation": []
    },
    "mechanicalsoup/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "       StatefulBrowser)."
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     pass"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+def is_multipart_file_upload(form, tag):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    return ("
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+        form.get(\"enctype\", \"\") == \"multipart/form-data\" and"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+        tag.get(\"type\", \"\").lower() == \"file\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    )"
            }
        },
        "frontPatchFile": [
            "class LinkNotFoundError(Exception):",
            "    \"\"\"Exception raised when mechanicalsoup fails to find something.",
            "",
            "    This happens in situations like (non-exhaustive list):",
            "",
            "    * :func:`~mechanicalsoup.StatefulBrowser.find_link` is called, but",
            "      no link is found.",
            "",
            "    * The browser was configured with raise_on_404=True and a 404",
            "      error is triggered while browsing.",
            "",
            "    * The user tried to fill-in a field which doesn't exist in a form",
            "      (e.g. browser[\"name\"] = \"val\" with browser being a",
            "      StatefulBrowser).",
            "    \"\"\"",
            "    pass"
        ],
        "afterPatchFile": [
            "class LinkNotFoundError(Exception):",
            "    \"\"\"Exception raised when mechanicalsoup fails to find something.",
            "",
            "    This happens in situations like (non-exhaustive list):",
            "",
            "    * :func:`~mechanicalsoup.StatefulBrowser.find_link` is called, but",
            "      no link is found.",
            "",
            "    * The browser was configured with raise_on_404=True and a 404",
            "      error is triggered while browsing.",
            "",
            "    * The user tried to fill-in a field which doesn't exist in a form",
            "      (e.g. browser[\"name\"] = \"val\" with browser being a",
            "      StatefulBrowser).",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "def is_multipart_file_upload(form, tag):",
            "    return (",
            "        form.get(\"enctype\", \"\") == \"multipart/form-data\" and",
            "        tag.get(\"type\", \"\").lower() == \"file\"",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.ansible.template.Templar.template"
        ]
    }
}