{
    "python/paddle/audio/functional/window.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from paddle import Tensor"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+class WindowFunctionRegister(object):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    def __init__(self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+        self._functions_dict = dict()"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    def register(self, func=None):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        def add_subfunction(func):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+            name = func.__name__"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            self._functions_dict[name] = func"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+            return func"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        return add_subfunction"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    def get(self, name):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        return self._functions_dict[name]"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+window_function_register = WindowFunctionRegister()"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "23": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " def _cat(x: List[Tensor], data_type: str) -> Tensor:"
            },
            "24": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     l = [paddle.to_tensor(_, data_type) for _ in x]"
            },
            "25": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     return paddle.concat(l)"
            },
            "26": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "29": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " def _acosh(x: Union[Tensor, float]) -> Tensor:"
            },
            "30": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     if isinstance(x, float):"
            },
            "31": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         return math.log(x + math.sqrt(x**2 - 1))"
            },
            "32": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))"
            },
            "33": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "36": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " def _extend(M: int, sym: bool) -> bool:"
            },
            "37": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\""
            },
            "38": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     if not sym:"
            },
            "39": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         return M, False"
            },
            "40": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "43": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " def _len_guards(M: int) -> bool:"
            },
            "44": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     \"\"\"Handle small or incorrect window lengths.\"\"\""
            },
            "45": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "     if int(M) != M or M < 0:"
            },
            "46": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     return M <= 1"
            },
            "47": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "50": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " def _truncate(w: Tensor, needed: bool) -> Tensor:"
            },
            "51": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\""
            },
            "52": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     if needed:"
            },
            "53": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         return w"
            },
            "54": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "57": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " def _general_gaussian("
            },
            "58": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     M: int, p, sig, sym: bool = True, dtype: str = 'float64'"
            },
            "59": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " ) -> Tensor:"
            },
            "60": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "     return _truncate(w, needs_trunc)"
            },
            "61": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "64": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " def _general_cosine("
            },
            "65": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     M: int, a: float, sym: bool = True, dtype: str = 'float64'"
            },
            "66": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " ) -> Tensor:"
            },
            "67": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "     return _truncate(w, needs_trunc)"
            },
            "68": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "71": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " def _general_hamming("
            },
            "72": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     M: int, alpha: float, sym: bool = True, dtype: str = 'float64'"
            },
            "73": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " ) -> Tensor:"
            },
            "74": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "     return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)"
            },
            "75": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "76": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "78": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " def _taylor("
            },
            "79": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'"
            },
            "80": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " ) -> Tensor:"
            },
            "81": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     return _truncate(w, needs_trunc)"
            },
            "82": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " "
            },
            "83": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "85": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:"
            },
            "86": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "     \"\"\"Compute a Hamming window."
            },
            "87": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     The Hamming window is a taper formed by using a raised cosine with"
            },
            "88": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "     return _general_hamming(M, 0.54, sym, dtype=dtype)"
            },
            "89": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "90": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 190,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "92": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 192,
                "PatchRowcode": " def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:"
            },
            "93": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "     \"\"\"Compute a Hann window."
            },
            "94": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "     The Hann window is a taper formed by using a raised cosine or sine-squared"
            },
            "95": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "     return _general_hamming(M, 0.5, sym, dtype=dtype)"
            },
            "96": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 198,
                "PatchRowcode": " "
            },
            "97": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 199,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "99": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 201,
                "PatchRowcode": " def _tukey("
            },
            "100": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "     M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'"
            },
            "101": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 203,
                "PatchRowcode": " ) -> Tensor:"
            },
            "102": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "     return _truncate(w, needs_trunc)"
            },
            "103": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 232,
                "PatchRowcode": " "
            },
            "104": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "106": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 235,
                "PatchRowcode": " def _kaiser("
            },
            "107": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "     M: int, beta: float, sym: bool = True, dtype: str = 'float64'"
            },
            "108": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " ) -> Tensor:"
            },
            "109": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "     raise NotImplementedError()"
            },
            "110": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 242,
                "PatchRowcode": " "
            },
            "111": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " "
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "113": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 245,
                "PatchRowcode": " def _gaussian("
            },
            "114": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "     M: int, std: float, sym: bool = True, dtype: str = 'float64'"
            },
            "115": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 247,
                "PatchRowcode": " ) -> Tensor:"
            },
            "116": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "     return _truncate(w, needs_trunc)"
            },
            "117": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 260,
                "PatchRowcode": " "
            },
            "118": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 261,
                "PatchRowcode": " "
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "120": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 263,
                "PatchRowcode": " def _exponential("
            },
            "121": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "     M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'"
            },
            "122": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 265,
                "PatchRowcode": " ) -> Tensor:"
            },
            "123": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "     return _truncate(w, needs_trunc)"
            },
            "124": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 280,
                "PatchRowcode": " "
            },
            "125": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 281,
                "PatchRowcode": " "
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "127": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 283,
                "PatchRowcode": " def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:"
            },
            "128": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "     \"\"\"Compute a triangular window.\"\"\""
            },
            "129": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "     if _len_guards(M):"
            },
            "130": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "     return _truncate(w, needs_trunc)"
            },
            "131": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 298,
                "PatchRowcode": " "
            },
            "132": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 299,
                "PatchRowcode": " "
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "134": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 301,
                "PatchRowcode": " def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:"
            },
            "135": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "     \"\"\"Compute a Bohman window."
            },
            "136": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "     The Bohman window is the autocorrelation of a cosine window."
            },
            "137": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "     return _truncate(w, needs_trunc)"
            },
            "138": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 316,
                "PatchRowcode": " "
            },
            "139": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 317,
                "PatchRowcode": " "
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "141": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 319,
                "PatchRowcode": " def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:"
            },
            "142": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "     \"\"\"Compute a Blackman window."
            },
            "143": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "     The Blackman window is a taper formed by using the first three terms of"
            },
            "144": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "     return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)"
            },
            "145": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 327,
                "PatchRowcode": " "
            },
            "146": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 328,
                "PatchRowcode": " "
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+@window_function_register.register()"
            },
            "148": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 330,
                "PatchRowcode": " def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:"
            },
            "149": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "     \"\"\"Compute a window with a simple cosine shape.\"\"\""
            },
            "150": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "     if _len_guards(M):"
            },
            "151": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "     \"\"\"Return a window of a given length and type."
            },
            "152": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 347,
                "PatchRowcode": " "
            },
            "153": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "     Args:"
            },
            "154": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'."
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+        window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'."
            },
            "156": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "         win_length (int): Number of samples."
            },
            "157": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True."
            },
            "158": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 352,
                "PatchRowcode": "         dtype (str, optional): The data type of the return window. Defaults to 'float64'."
            },
            "159": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "         )"
            },
            "160": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 387,
                "PatchRowcode": " "
            },
            "161": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "     try:"
            },
            "162": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        winfunc = eval('_' + winstr)"
            },
            "163": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except NameError as e:"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+        winfunc = window_function_register.get('_' + winstr)"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+    except KeyError as e:"
            },
            "166": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "         raise ValueError(\"Unknown window type.\") from e"
            },
            "167": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 392,
                "PatchRowcode": " "
            },
            "168": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "     params = (win_length,) + args"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "import math",
            "from typing import List",
            "from typing import Tuple",
            "from typing import Union",
            "",
            "import paddle",
            "from paddle import Tensor",
            "",
            "",
            "def _cat(x: List[Tensor], data_type: str) -> Tensor:",
            "    l = [paddle.to_tensor(_, data_type) for _ in x]",
            "    return paddle.concat(l)",
            "",
            "",
            "def _acosh(x: Union[Tensor, float]) -> Tensor:",
            "    if isinstance(x, float):",
            "        return math.log(x + math.sqrt(x**2 - 1))",
            "    return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))",
            "",
            "",
            "def _extend(M: int, sym: bool) -> bool:",
            "    \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"",
            "    if not sym:",
            "        return M + 1, True",
            "    else:",
            "        return M, False",
            "",
            "",
            "def _len_guards(M: int) -> bool:",
            "    \"\"\"Handle small or incorrect window lengths.\"\"\"",
            "    if int(M) != M or M < 0:",
            "        raise ValueError('Window length M must be a non-negative integer')",
            "",
            "    return M <= 1",
            "",
            "",
            "def _truncate(w: Tensor, needed: bool) -> Tensor:",
            "    \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"",
            "    if needed:",
            "        return w[:-1]",
            "    else:",
            "        return w",
            "",
            "",
            "def _general_gaussian(",
            "    M: int, p, sig, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a window with a generalized Gaussian shape.",
            "    This function is consistent with scipy.signal.windows.general_gaussian().",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
            "    w = paddle.exp(-0.5 * paddle.abs(n / sig) ** (2 * p))",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def _general_cosine(",
            "    M: int, a: float, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a generic weighted sum of cosine terms window.",
            "    This function is consistent with scipy.signal.windows.general_cosine().",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "    fac = paddle.linspace(-math.pi, math.pi, M, dtype=dtype)",
            "    w = paddle.zeros((M,), dtype=dtype)",
            "    for k in range(len(a)):",
            "        w += a[k] * paddle.cos(k * fac)",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def _general_hamming(",
            "    M: int, alpha: float, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a generalized Hamming window.",
            "    This function is consistent with scipy.signal.windows.general_hamming()",
            "    \"\"\"",
            "    return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)",
            "",
            "",
            "def _taylor(",
            "    M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a Taylor window.",
            "    The Taylor window taper function approximates the Dolph-Chebyshev window's",
            "    constant sidelobe level for a parameterized number of near-in sidelobes.",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "    # Original text uses a negative sidelobe level parameter and then negates",
            "    # it in the calculation of B. To keep consistent with other methods we",
            "    # assume the sidelobe level parameter to be positive.",
            "    B = 10 ** (sll / 20)",
            "    A = _acosh(B) / math.pi",
            "    s2 = nbar**2 / (A**2 + (nbar - 0.5) ** 2)",
            "    ma = paddle.arange(1, nbar, dtype=dtype)",
            "",
            "    Fm = paddle.empty((nbar - 1,), dtype=dtype)",
            "    signs = paddle.empty_like(ma)",
            "    signs[::2] = 1",
            "    signs[1::2] = -1",
            "    m2 = ma * ma",
            "    for mi in range(len(ma)):",
            "        numer = signs[mi] * paddle.prod(",
            "            1 - m2[mi] / s2 / (A**2 + (ma - 0.5) ** 2)",
            "        )",
            "        if mi == 0:",
            "            denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1 :])",
            "        elif mi == len(ma) - 1:",
            "            denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi])",
            "        else:",
            "            denom = (",
            "                2",
            "                * paddle.prod(1 - m2[mi] / m2[:mi])",
            "                * paddle.prod(1 - m2[mi] / m2[mi + 1 :])",
            "            )",
            "",
            "        Fm[mi] = numer / denom",
            "",
            "    def W(n):",
            "        return 1 + 2 * paddle.matmul(",
            "            Fm.unsqueeze(0),",
            "            paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2.0 + 0.5) / M),",
            "        )",
            "",
            "    w = W(paddle.arange(0, M, dtype=dtype))",
            "",
            "    # normalize (Note that this is not described in the original text [1])",
            "    if norm:",
            "        scale = 1.0 / W((M - 1) / 2)",
            "        w *= scale",
            "    w = w.squeeze()",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a Hamming window.",
            "    The Hamming window is a taper formed by using a raised cosine with",
            "    non-zero endpoints, optimized to minimize the nearest side lobe.",
            "    \"\"\"",
            "    return _general_hamming(M, 0.54, sym, dtype=dtype)",
            "",
            "",
            "def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a Hann window.",
            "    The Hann window is a taper formed by using a raised cosine or sine-squared",
            "    with ends that touch zero.",
            "    \"\"\"",
            "    return _general_hamming(M, 0.5, sym, dtype=dtype)",
            "",
            "",
            "def _tukey(",
            "    M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a Tukey window.",
            "    The Tukey window is also known as a tapered cosine window.",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "",
            "    if alpha <= 0:",
            "        return paddle.ones((M,), dtype=dtype)",
            "    elif alpha >= 1.0:",
            "        return hann(M, sym=sym)",
            "",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    n = paddle.arange(0, M, dtype=dtype)",
            "    width = int(alpha * (M - 1) / 2.0)",
            "    n1 = n[0 : width + 1]",
            "    n2 = n[width + 1 : M - width - 1]",
            "    n3 = n[M - width - 1 :]",
            "",
            "    w1 = 0.5 * (1 + paddle.cos(math.pi * (-1 + 2.0 * n1 / alpha / (M - 1))))",
            "    w2 = paddle.ones(n2.shape, dtype=dtype)",
            "    w3 = 0.5 * (",
            "        1",
            "        + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha / (M - 1)))",
            "    )",
            "    w = paddle.concat([w1, w2, w3])",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def _kaiser(",
            "    M: int, beta: float, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a Kaiser window.",
            "    The Kaiser window is a taper formed by using a Bessel function.",
            "    \"\"\"",
            "    raise NotImplementedError()",
            "",
            "",
            "def _gaussian(",
            "    M: int, std: float, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a Gaussian window.",
            "    The Gaussian widows has a Gaussian shape defined by the standard deviation(std).",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
            "    sig2 = 2 * std * std",
            "    w = paddle.exp(-(n**2) / sig2)",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def _exponential(",
            "    M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute an exponential (or Poisson) window.\"\"\"",
            "    if sym and center is not None:",
            "        raise ValueError(\"If sym==True, center must be None.\")",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    if center is None:",
            "        center = (M - 1) / 2",
            "",
            "    n = paddle.arange(0, M, dtype=dtype)",
            "    w = paddle.exp(-paddle.abs(n - center) / tau)",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a triangular window.\"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    n = paddle.arange(1, (M + 1) // 2 + 1, dtype=dtype)",
            "    if M % 2 == 0:",
            "        w = (2 * n - 1.0) / M",
            "        w = paddle.concat([w, w[::-1]])",
            "    else:",
            "        w = 2 * n / (M + 1.0)",
            "        w = paddle.concat([w, w[-2::-1]])",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a Bohman window.",
            "    The Bohman window is the autocorrelation of a cosine window.",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    fac = paddle.abs(paddle.linspace(-1, 1, M, dtype=dtype)[1:-1])",
            "    w = (1 - fac) * paddle.cos(math.pi * fac) + 1.0 / math.pi * paddle.sin(",
            "        math.pi * fac",
            "    )",
            "    w = _cat([0, w, 0], dtype)",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a Blackman window.",
            "    The Blackman window is a taper formed by using the first three terms of",
            "    a summation of cosines. It was designed to have close to the minimal",
            "    leakage possible.  It is close to optimal, only slightly worse than a",
            "    Kaiser window.",
            "    \"\"\"",
            "    return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)",
            "",
            "",
            "def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a window with a simple cosine shape.\"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "    w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + 0.5))",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def get_window(",
            "    window: Union[str, Tuple[str, float]],",
            "    win_length: int,",
            "    fftbins: bool = True,",
            "    dtype: str = 'float64',",
            ") -> Tensor:",
            "    \"\"\"Return a window of a given length and type.",
            "",
            "    Args:",
            "        window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
            "        win_length (int): Number of samples.",
            "        fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
            "        dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
            "",
            "    Returns:",
            "        Tensor: The window represented as a tensor.",
            "",
            "    Examples:",
            "        .. code-block:: python",
            "",
            "            import paddle",
            "",
            "            n_fft = 512",
            "            cosine_window = paddle.audio.functional.get_window('cosine', n_fft)",
            "",
            "            std = 7",
            "            gussian_window = paddle.audio.functional.get_window(('gaussian',std), n_fft)",
            "    \"\"\"",
            "    sym = not fftbins",
            "",
            "    args = ()",
            "    if isinstance(window, tuple):",
            "        winstr = window[0]",
            "        if len(window) > 1:",
            "            args = window[1:]",
            "    elif isinstance(window, str):",
            "        if window in ['gaussian', 'exponential']:",
            "            raise ValueError(",
            "                \"The '\" + window + \"' window needs one or \"",
            "                \"more parameters -- pass a tuple.\"",
            "            )",
            "        else:",
            "            winstr = window",
            "    else:",
            "        raise ValueError(",
            "            \"%s as window type is not supported.\" % str(type(window))",
            "        )",
            "",
            "    try:",
            "        winfunc = eval('_' + winstr)",
            "    except NameError as e:",
            "        raise ValueError(\"Unknown window type.\") from e",
            "",
            "    params = (win_length,) + args",
            "    kwargs = {'sym': sym}",
            "    return winfunc(*params, dtype=dtype, **kwargs)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "import math",
            "from typing import List",
            "from typing import Tuple",
            "from typing import Union",
            "",
            "import paddle",
            "from paddle import Tensor",
            "",
            "",
            "class WindowFunctionRegister(object):",
            "    def __init__(self):",
            "        self._functions_dict = dict()",
            "",
            "    def register(self, func=None):",
            "        def add_subfunction(func):",
            "            name = func.__name__",
            "            self._functions_dict[name] = func",
            "            return func",
            "",
            "        return add_subfunction",
            "",
            "    def get(self, name):",
            "        return self._functions_dict[name]",
            "",
            "",
            "window_function_register = WindowFunctionRegister()",
            "",
            "",
            "@window_function_register.register()",
            "def _cat(x: List[Tensor], data_type: str) -> Tensor:",
            "    l = [paddle.to_tensor(_, data_type) for _ in x]",
            "    return paddle.concat(l)",
            "",
            "",
            "@window_function_register.register()",
            "def _acosh(x: Union[Tensor, float]) -> Tensor:",
            "    if isinstance(x, float):",
            "        return math.log(x + math.sqrt(x**2 - 1))",
            "    return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))",
            "",
            "",
            "@window_function_register.register()",
            "def _extend(M: int, sym: bool) -> bool:",
            "    \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"",
            "    if not sym:",
            "        return M + 1, True",
            "    else:",
            "        return M, False",
            "",
            "",
            "@window_function_register.register()",
            "def _len_guards(M: int) -> bool:",
            "    \"\"\"Handle small or incorrect window lengths.\"\"\"",
            "    if int(M) != M or M < 0:",
            "        raise ValueError('Window length M must be a non-negative integer')",
            "",
            "    return M <= 1",
            "",
            "",
            "@window_function_register.register()",
            "def _truncate(w: Tensor, needed: bool) -> Tensor:",
            "    \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"",
            "    if needed:",
            "        return w[:-1]",
            "    else:",
            "        return w",
            "",
            "",
            "@window_function_register.register()",
            "def _general_gaussian(",
            "    M: int, p, sig, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a window with a generalized Gaussian shape.",
            "    This function is consistent with scipy.signal.windows.general_gaussian().",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
            "    w = paddle.exp(-0.5 * paddle.abs(n / sig) ** (2 * p))",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "@window_function_register.register()",
            "def _general_cosine(",
            "    M: int, a: float, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a generic weighted sum of cosine terms window.",
            "    This function is consistent with scipy.signal.windows.general_cosine().",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "    fac = paddle.linspace(-math.pi, math.pi, M, dtype=dtype)",
            "    w = paddle.zeros((M,), dtype=dtype)",
            "    for k in range(len(a)):",
            "        w += a[k] * paddle.cos(k * fac)",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "@window_function_register.register()",
            "def _general_hamming(",
            "    M: int, alpha: float, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a generalized Hamming window.",
            "    This function is consistent with scipy.signal.windows.general_hamming()",
            "    \"\"\"",
            "    return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)",
            "",
            "",
            "@window_function_register.register()",
            "def _taylor(",
            "    M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a Taylor window.",
            "    The Taylor window taper function approximates the Dolph-Chebyshev window's",
            "    constant sidelobe level for a parameterized number of near-in sidelobes.",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "    # Original text uses a negative sidelobe level parameter and then negates",
            "    # it in the calculation of B. To keep consistent with other methods we",
            "    # assume the sidelobe level parameter to be positive.",
            "    B = 10 ** (sll / 20)",
            "    A = _acosh(B) / math.pi",
            "    s2 = nbar**2 / (A**2 + (nbar - 0.5) ** 2)",
            "    ma = paddle.arange(1, nbar, dtype=dtype)",
            "",
            "    Fm = paddle.empty((nbar - 1,), dtype=dtype)",
            "    signs = paddle.empty_like(ma)",
            "    signs[::2] = 1",
            "    signs[1::2] = -1",
            "    m2 = ma * ma",
            "    for mi in range(len(ma)):",
            "        numer = signs[mi] * paddle.prod(",
            "            1 - m2[mi] / s2 / (A**2 + (ma - 0.5) ** 2)",
            "        )",
            "        if mi == 0:",
            "            denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1 :])",
            "        elif mi == len(ma) - 1:",
            "            denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi])",
            "        else:",
            "            denom = (",
            "                2",
            "                * paddle.prod(1 - m2[mi] / m2[:mi])",
            "                * paddle.prod(1 - m2[mi] / m2[mi + 1 :])",
            "            )",
            "",
            "        Fm[mi] = numer / denom",
            "",
            "    def W(n):",
            "        return 1 + 2 * paddle.matmul(",
            "            Fm.unsqueeze(0),",
            "            paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2.0 + 0.5) / M),",
            "        )",
            "",
            "    w = W(paddle.arange(0, M, dtype=dtype))",
            "",
            "    # normalize (Note that this is not described in the original text [1])",
            "    if norm:",
            "        scale = 1.0 / W((M - 1) / 2)",
            "        w *= scale",
            "    w = w.squeeze()",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "@window_function_register.register()",
            "def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a Hamming window.",
            "    The Hamming window is a taper formed by using a raised cosine with",
            "    non-zero endpoints, optimized to minimize the nearest side lobe.",
            "    \"\"\"",
            "    return _general_hamming(M, 0.54, sym, dtype=dtype)",
            "",
            "",
            "@window_function_register.register()",
            "def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a Hann window.",
            "    The Hann window is a taper formed by using a raised cosine or sine-squared",
            "    with ends that touch zero.",
            "    \"\"\"",
            "    return _general_hamming(M, 0.5, sym, dtype=dtype)",
            "",
            "",
            "@window_function_register.register()",
            "def _tukey(",
            "    M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a Tukey window.",
            "    The Tukey window is also known as a tapered cosine window.",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "",
            "    if alpha <= 0:",
            "        return paddle.ones((M,), dtype=dtype)",
            "    elif alpha >= 1.0:",
            "        return hann(M, sym=sym)",
            "",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    n = paddle.arange(0, M, dtype=dtype)",
            "    width = int(alpha * (M - 1) / 2.0)",
            "    n1 = n[0 : width + 1]",
            "    n2 = n[width + 1 : M - width - 1]",
            "    n3 = n[M - width - 1 :]",
            "",
            "    w1 = 0.5 * (1 + paddle.cos(math.pi * (-1 + 2.0 * n1 / alpha / (M - 1))))",
            "    w2 = paddle.ones(n2.shape, dtype=dtype)",
            "    w3 = 0.5 * (",
            "        1",
            "        + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha / (M - 1)))",
            "    )",
            "    w = paddle.concat([w1, w2, w3])",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "@window_function_register.register()",
            "def _kaiser(",
            "    M: int, beta: float, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a Kaiser window.",
            "    The Kaiser window is a taper formed by using a Bessel function.",
            "    \"\"\"",
            "    raise NotImplementedError()",
            "",
            "",
            "@window_function_register.register()",
            "def _gaussian(",
            "    M: int, std: float, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute a Gaussian window.",
            "    The Gaussian widows has a Gaussian shape defined by the standard deviation(std).",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
            "    sig2 = 2 * std * std",
            "    w = paddle.exp(-(n**2) / sig2)",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "@window_function_register.register()",
            "def _exponential(",
            "    M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'",
            ") -> Tensor:",
            "    \"\"\"Compute an exponential (or Poisson) window.\"\"\"",
            "    if sym and center is not None:",
            "        raise ValueError(\"If sym==True, center must be None.\")",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    if center is None:",
            "        center = (M - 1) / 2",
            "",
            "    n = paddle.arange(0, M, dtype=dtype)",
            "    w = paddle.exp(-paddle.abs(n - center) / tau)",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "@window_function_register.register()",
            "def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a triangular window.\"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    n = paddle.arange(1, (M + 1) // 2 + 1, dtype=dtype)",
            "    if M % 2 == 0:",
            "        w = (2 * n - 1.0) / M",
            "        w = paddle.concat([w, w[::-1]])",
            "    else:",
            "        w = 2 * n / (M + 1.0)",
            "        w = paddle.concat([w, w[-2::-1]])",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "@window_function_register.register()",
            "def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a Bohman window.",
            "    The Bohman window is the autocorrelation of a cosine window.",
            "    \"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "",
            "    fac = paddle.abs(paddle.linspace(-1, 1, M, dtype=dtype)[1:-1])",
            "    w = (1 - fac) * paddle.cos(math.pi * fac) + 1.0 / math.pi * paddle.sin(",
            "        math.pi * fac",
            "    )",
            "    w = _cat([0, w, 0], dtype)",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "@window_function_register.register()",
            "def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a Blackman window.",
            "    The Blackman window is a taper formed by using the first three terms of",
            "    a summation of cosines. It was designed to have close to the minimal",
            "    leakage possible.  It is close to optimal, only slightly worse than a",
            "    Kaiser window.",
            "    \"\"\"",
            "    return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)",
            "",
            "",
            "@window_function_register.register()",
            "def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
            "    \"\"\"Compute a window with a simple cosine shape.\"\"\"",
            "    if _len_guards(M):",
            "        return paddle.ones((M,), dtype=dtype)",
            "    M, needs_trunc = _extend(M, sym)",
            "    w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + 0.5))",
            "",
            "    return _truncate(w, needs_trunc)",
            "",
            "",
            "def get_window(",
            "    window: Union[str, Tuple[str, float]],",
            "    win_length: int,",
            "    fftbins: bool = True,",
            "    dtype: str = 'float64',",
            ") -> Tensor:",
            "    \"\"\"Return a window of a given length and type.",
            "",
            "    Args:",
            "        window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
            "        win_length (int): Number of samples.",
            "        fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
            "        dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
            "",
            "    Returns:",
            "        Tensor: The window represented as a tensor.",
            "",
            "    Examples:",
            "        .. code-block:: python",
            "",
            "            import paddle",
            "",
            "            n_fft = 512",
            "            cosine_window = paddle.audio.functional.get_window('cosine', n_fft)",
            "",
            "            std = 7",
            "            gussian_window = paddle.audio.functional.get_window(('gaussian',std), n_fft)",
            "    \"\"\"",
            "    sym = not fftbins",
            "",
            "    args = ()",
            "    if isinstance(window, tuple):",
            "        winstr = window[0]",
            "        if len(window) > 1:",
            "            args = window[1:]",
            "    elif isinstance(window, str):",
            "        if window in ['gaussian', 'exponential']:",
            "            raise ValueError(",
            "                \"The '\" + window + \"' window needs one or \"",
            "                \"more parameters -- pass a tuple.\"",
            "            )",
            "        else:",
            "            winstr = window",
            "    else:",
            "        raise ValueError(",
            "            \"%s as window type is not supported.\" % str(type(window))",
            "        )",
            "",
            "    try:",
            "        winfunc = window_function_register.get('_' + winstr)",
            "    except KeyError as e:",
            "        raise ValueError(\"Unknown window type.\") from e",
            "",
            "    params = (win_length,) + args",
            "    kwargs = {'sym': sym}",
            "    return winfunc(*params, dtype=dtype, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "311": [
                "get_window"
            ],
            "351": [
                "get_window"
            ],
            "352": [
                "get_window"
            ]
        },
        "addLocation": [
            "python.paddle.audio.functional.window.get_window",
            "litellm.utils.exception_type",
            "python.paddle.audio.functional.window"
        ]
    }
}