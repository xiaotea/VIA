{
    "horizon/test/unit/workflows/test_workflows.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from django import forms"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from django import http"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from django.test.utils import override_settings"
            },
            "4": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from horizon import base"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from horizon import exceptions"
            },
            "7": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 400,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         flow = WorkflowForTesting(req, entry_point=\"action_two\")"
            },
            "9": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "         self.assertEqual(\"action_two\", flow.get_entry_point())"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+    @override_settings(ALLOWED_HOSTS=['localhost'])"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+    def test_redirect_url_safe(self):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+        url = 'http://localhost/test'"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+        view = WorkflowViewForTesting()"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+        request = self.factory.get(\"/\", data={"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+            'next': url,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+        })"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+        request.META['SERVER_NAME'] = \"localhost\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+        view.request = request"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+        context = view.get_context_data()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+        self.assertEqual(url, context['REDIRECT_URL'])"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+    @override_settings(ALLOWED_HOSTS=['localhost'])"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+    def test_redirect_url_unsafe(self):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+        url = 'http://evilcorp/test'"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+        view = WorkflowViewForTesting()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+        request = self.factory.get(\"/\", data={"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+            'next': url,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 422,
                "PatchRowcode": "+        })"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+        request.META['SERVER_NAME'] = \"localhost\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+        view.request = request"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+        context = view.get_context_data()"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+        self.assertIsNone(context['REDIRECT_URL'])"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 Nebula, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from unittest import mock",
            "",
            "from django import forms",
            "from django import http",
            "",
            "from horizon import base",
            "from horizon import exceptions",
            "from horizon.test import helpers as test",
            "from horizon import workflows",
            "",
            "",
            "PROJECT_ID = \"a23lkjre389fwenj\"",
            "INSTANCE_ID = \"sdlkjhf9832roiw\"",
            "",
            "",
            "def local_callback_func(request, context):",
            "    return \"one\"",
            "",
            "",
            "def other_callback_func(request, context):",
            "    return \"two\"",
            "",
            "",
            "def extra_callback_func(request, context):",
            "    return \"extra\"",
            "",
            "",
            "class ActionOne(workflows.Action):",
            "    project_id = forms.ChoiceField(label=\"Project\")",
            "    user_id = forms.ChoiceField(label=\"User\")",
            "",
            "    class Meta(object):",
            "        name = \"Action One\"",
            "        slug = \"action_one\"",
            "",
            "    def populate_project_id_choices(self, request, context):",
            "        return [(PROJECT_ID, \"test_project\")]",
            "",
            "    def populate_user_id_choices(self, request, context):",
            "        return [(request.user.id, request.user.username)]",
            "",
            "    def handle(self, request, context):",
            "        return {\"foo\": \"bar\"}",
            "",
            "",
            "class ActionTwo(workflows.Action):",
            "    instance_id = forms.CharField(label=\"Instance\")",
            "",
            "    class Meta(object):",
            "        name = \"Action Two\"",
            "        slug = \"action_two\"",
            "",
            "",
            "class ActionThree(workflows.Action):",
            "    extra = forms.CharField(widget=forms.widgets.Textarea)",
            "",
            "    class Meta(object):",
            "        name = \"Action Three\"",
            "        slug = \"action_three\"",
            "",
            "",
            "class ActionFour(workflows.Action):",
            "    field_four = forms.CharField(widget=forms.widgets.Textarea)",
            "",
            "    class Meta(object):",
            "        name = \"Action Four\"",
            "        slug = \"action_four\"",
            "",
            "",
            "class AdminAction(workflows.Action):",
            "    admin_id = forms.CharField(label=\"Admin\")",
            "",
            "    class Meta(object):",
            "        name = \"Admin Action\"",
            "        slug = \"admin_action\"",
            "        permissions = (\"horizon.test\",)",
            "",
            "",
            "class DisabledAction(workflows.Action):",
            "    disabled_id = forms.CharField(label=\"Disabled\")",
            "",
            "    class Meta(object):",
            "        name = \"Action Disabled\"",
            "        slug = \"action_disabled\"",
            "",
            "",
            "class AdminForbiddenAction(workflows.Action):",
            "    admin_id = forms.CharField(label=\"Admin forbidden\")",
            "",
            "    class Meta(object):",
            "        name = \"Admin Action\"",
            "        slug = \"admin_action\"",
            "        policy_rules = (('action', 'forbidden'),)",
            "",
            "",
            "class StepOne(workflows.Step):",
            "    action_class = ActionOne",
            "    contributes = (\"project_id\", \"user_id\")",
            "",
            "",
            "class StepTwo(workflows.Step):",
            "    action_class = ActionTwo",
            "    depends_on = (\"project_id\",)",
            "    contributes = (\"instance_id\",)",
            "    connections = {\"project_id\":",
            "                   (local_callback_func,",
            "                    \"horizon.test.unit.workflows.test_workflows.\"",
            "                    \"other_callback_func\")}",
            "",
            "",
            "class StepThree(workflows.Step):",
            "    action_class = ActionThree",
            "    depends_on = (\"project_id\",)",
            "    contributes = (\"extra_data\",)",
            "    connections = {\"project_id\": (extra_callback_func,)}",
            "    after = StepOne",
            "    before = StepTwo",
            "",
            "",
            "class StepFour(workflows.Step):",
            "    action_class = ActionFour",
            "    contributes = (\"field_four\",)",
            "",
            "",
            "class AdminStep(workflows.Step):",
            "    action_class = AdminAction",
            "    contributes = (\"admin_id\",)",
            "    after = StepOne",
            "    before = StepTwo",
            "",
            "",
            "class DisabledStep(workflows.Step):",
            "    action_class = DisabledAction",
            "    contributes = (\"disabled_id\",)",
            "",
            "    def allowed(self, request):",
            "        return False",
            "",
            "",
            "class AdminForbiddenStep(workflows.Step):",
            "    action_class = AdminForbiddenAction",
            "",
            "",
            "class WorkflowForTesting(workflows.Workflow):",
            "    slug = \"test_workflow\"",
            "    default_steps = (StepOne, StepTwo)",
            "",
            "",
            "class WorkflowWithConfig(workflows.Workflow):",
            "    slug = \"test_workflow\"",
            "    default_steps = (StepOne,)",
            "",
            "",
            "class WorkflowViewForTesting(workflows.WorkflowView):",
            "    workflow_class = WorkflowForTesting",
            "    template_name = \"workflow.html\"",
            "",
            "",
            "class FullscreenWorkflow(workflows.Workflow):",
            "    slug = 'test_fullscreen_workflow'",
            "    default_steps = (StepOne, StepTwo)",
            "    fullscreen = True",
            "",
            "",
            "class FullscreenWorkflowView(workflows.WorkflowView):",
            "    workflow_class = FullscreenWorkflow",
            "    template_name = \"workflow.html\"",
            "",
            "",
            "class WorkflowsTests(test.TestCase):",
            "    def setUp(self):",
            "        super(WorkflowsTests, self).setUp()",
            "        self.policy_patcher = mock.patch(",
            "            'openstack_auth.policy.check', lambda action, request: True)",
            "        self.policy_check = self.policy_patcher.start()",
            "        self.addCleanup(mock.patch.stopall)",
            "",
            "    def tearDown(self):",
            "        super(WorkflowsTests, self).tearDown()",
            "        self._reset_workflow()",
            "",
            "    def _reset_workflow(self):",
            "        WorkflowForTesting._cls_registry = []",
            "",
            "    def test_workflow_construction(self):",
            "        WorkflowForTesting.register(StepThree)",
            "        flow = WorkflowForTesting(self.request)",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepThree: action_three>',",
            "                                  '<StepTwo: action_two>'])",
            "        self.assertEqual(set(['project_id']), flow.depends_on)",
            "",
            "    @test.update_settings(HORIZON_CONFIG={'extra_steps': {",
            "        'horizon.test.unit.workflows.test_workflows.WorkflowWithConfig': (",
            "            'horizon.test.unit.workflows.test_workflows.StepTwo',",
            "            'horizon.test.unit.workflows.test_workflows.StepThree',",
            "            'horizon.test.unit.workflows.test_workflows.StepFour',",
            "        ),",
            "    }})",
            "    def test_workflow_construction_with_config(self):",
            "        flow = WorkflowWithConfig(self.request)",
            "        # NOTE: StepThree must be placed between StepOne and",
            "        # StepTwo in honor of before/after of StepThree.",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepThree: action_three>',",
            "                                  '<StepTwo: action_two>',",
            "                                  '<StepFour: action_four>',",
            "                                  ])",
            "",
            "    def test_step_construction(self):",
            "        step_one = StepOne(WorkflowForTesting(self.request))",
            "        # Action slug is moved from Meta by metaclass, and",
            "        # Step inherits slug from action.",
            "        self.assertEqual(ActionOne.name, step_one.name)",
            "        self.assertEqual(ActionOne.slug, step_one.slug)",
            "        # Handlers should be empty since there are no connections.",
            "        self.assertEqual(step_one._handlers, {})",
            "",
            "        step_two = StepTwo(WorkflowForTesting(self.request))",
            "        # Handlers should be populated since we do have connections.",
            "        self.assertEqual([local_callback_func, other_callback_func],",
            "                         step_two._handlers[\"project_id\"])",
            "",
            "    def test_step_invalid_connections_handlers_not_list_or_tuple(self):",
            "        class InvalidStepA(StepTwo):",
            "            connections = {'project_id': {}}",
            "",
            "        class InvalidStepB(StepTwo):",
            "            connections = {'project_id': ''}",
            "",
            "        with self.assertRaises(TypeError):",
            "            InvalidStepA(WorkflowForTesting(self.request))",
            "",
            "        with self.assertRaises(TypeError):",
            "            InvalidStepB(WorkflowForTesting(self.request))",
            "",
            "    def test_step_invalid_connection_handler_not_string_or_callable(self):",
            "        class InvalidStepA(StepTwo):",
            "            connections = {'project_id': (None,)}",
            "",
            "        class InvalidStepB(StepTwo):",
            "            connections = {'project_id': (0,)}",
            "",
            "        with self.assertRaises(TypeError):",
            "            InvalidStepA(WorkflowForTesting(self.request))",
            "",
            "        with self.assertRaises(TypeError):",
            "            InvalidStepB(WorkflowForTesting(self.request))",
            "",
            "    def test_step_invalid_callback(self):",
            "        # This should raise an exception",
            "        class InvalidStep(StepTwo):",
            "            connections = {\"project_id\": ('local_callback_func',)}",
            "",
            "        with self.assertRaises(ValueError):",
            "            InvalidStep(WorkflowForTesting(self.request))",
            "",
            "    def test_connection_handlers_called(self):",
            "        WorkflowForTesting.register(StepThree)",
            "        flow = WorkflowForTesting(self.request)",
            "",
            "        # This should set the value without any errors, but trigger nothing",
            "        flow.context['does_not_exist'] = False",
            "        self.assertFalse(flow.context['does_not_exist'])",
            "",
            "        # The order here is relevant. Note that we inserted \"extra\" between",
            "        # steps one and two, and one has no handlers, so we should see",
            "        # a response from extra, then one from each of step two's handlers.",
            "        val = flow.context.set('project_id', PROJECT_ID)",
            "        self.assertEqual([('action_three', 'extra'),",
            "                          ('action_two', 'one'),",
            "                          ('action_two', 'two')], val)",
            "",
            "    def test_workflow_validation(self):",
            "        flow = WorkflowForTesting(self.request)",
            "",
            "        # Missing items fail validation.",
            "        with self.assertRaises(exceptions.WorkflowValidationError):",
            "            flow.is_valid()",
            "",
            "        # All required items pass validation.",
            "        seed = {\"project_id\": PROJECT_ID,",
            "                \"user_id\": self.user.id,",
            "                \"instance_id\": INSTANCE_ID}",
            "        req = self.factory.post(\"/\", seed)",
            "        req.user = self.user",
            "        flow = WorkflowForTesting(req, context_seed={\"project_id\": PROJECT_ID})",
            "        for step in flow.steps:",
            "            if not step.action.is_valid():",
            "                self.fail(\"Step %s was unexpectedly invalid: %s\"",
            "                          % (step.slug, step.action.errors))",
            "        self.assertTrue(flow.is_valid())",
            "",
            "        # Additional items shouldn't affect validation",
            "        flow.context.set(\"extra_data\", \"foo\")",
            "        self.assertTrue(flow.is_valid())",
            "",
            "    def test_workflow_finalization(self):",
            "        flow = WorkflowForTesting(self.request)",
            "        self.assertTrue(flow.finalize())",
            "",
            "    def test_workflow_view(self):",
            "        view = WorkflowViewForTesting.as_view()",
            "        req = self.factory.get(\"/\")",
            "        res = view(req)",
            "        self.assertEqual(200, res.status_code)",
            "",
            "    def test_workflow_registration(self):",
            "        req = self.factory.get(\"/foo\")",
            "        flow = WorkflowForTesting(req)",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "        WorkflowForTesting.register(StepThree)",
            "        flow = WorkflowForTesting(req)",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepThree: action_three>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "    def test_workflow_unregister_unexisting_workflow(self):",
            "        with self.assertRaises(base.NotRegistered):",
            "            WorkflowForTesting.unregister(DisabledStep)",
            "",
            "    def test_workflow_render(self):",
            "        WorkflowForTesting.register(StepThree)",
            "        req = self.factory.get(\"/foo\")",
            "        flow = WorkflowForTesting(req)",
            "        output = http.HttpResponse(flow.render())",
            "        self.assertContains(output, flow.name)",
            "        self.assertContains(output, ActionOne.name)",
            "        self.assertContains(output, ActionTwo.name)",
            "        self.assertContains(output, ActionThree.name)",
            "",
            "    def test_has_permissions(self):",
            "        self.assertQuerysetEqual(WorkflowForTesting._cls_registry, [])",
            "        WorkflowForTesting.register(AdminStep)",
            "        flow = WorkflowForTesting(self.request)",
            "        step = AdminStep(flow)",
            "",
            "        self.assertCountEqual(step.permissions,",
            "                              (\"horizon.test\",))",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "        self.set_permissions(['test'])",
            "        self.request.user = self.user",
            "        flow = WorkflowForTesting(self.request)",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<AdminStep: admin_action>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "    def test_has_allowed(self):",
            "        WorkflowForTesting.register(DisabledStep)",
            "        flow = WorkflowForTesting(self.request)",
            "        # Check DisabledStep is not included",
            "        # even though DisabledStep is registered.",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "    def test_step_is_hidden_on_policy(self):",
            "        self.policy_patcher.stop()",
            "",
            "        def policy_check(action, request):",
            "            if action == (('action', 'forbidden'),):",
            "                return False",
            "            return True",
            "",
            "        with mock.patch('openstack_auth.policy.check', policy_check):",
            "            WorkflowForTesting.register(AdminForbiddenStep)",
            "            flow = WorkflowForTesting(self.request)",
            "            output = http.HttpResponse(flow.render())",
            "            self.assertNotContains(output, AdminForbiddenAction.name)",
            "",
            "    def test_entry_point(self):",
            "        req = self.factory.get(\"/foo\")",
            "        flow = WorkflowForTesting(req)",
            "        self.assertEqual(\"action_one\", flow.get_entry_point())",
            "",
            "        flow = WorkflowForTesting(req, entry_point=\"action_two\")",
            "        self.assertEqual(\"action_two\", flow.get_entry_point())"
        ],
        "afterPatchFile": [
            "# Copyright 2012 Nebula, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from unittest import mock",
            "",
            "from django import forms",
            "from django import http",
            "from django.test.utils import override_settings",
            "",
            "from horizon import base",
            "from horizon import exceptions",
            "from horizon.test import helpers as test",
            "from horizon import workflows",
            "",
            "",
            "PROJECT_ID = \"a23lkjre389fwenj\"",
            "INSTANCE_ID = \"sdlkjhf9832roiw\"",
            "",
            "",
            "def local_callback_func(request, context):",
            "    return \"one\"",
            "",
            "",
            "def other_callback_func(request, context):",
            "    return \"two\"",
            "",
            "",
            "def extra_callback_func(request, context):",
            "    return \"extra\"",
            "",
            "",
            "class ActionOne(workflows.Action):",
            "    project_id = forms.ChoiceField(label=\"Project\")",
            "    user_id = forms.ChoiceField(label=\"User\")",
            "",
            "    class Meta(object):",
            "        name = \"Action One\"",
            "        slug = \"action_one\"",
            "",
            "    def populate_project_id_choices(self, request, context):",
            "        return [(PROJECT_ID, \"test_project\")]",
            "",
            "    def populate_user_id_choices(self, request, context):",
            "        return [(request.user.id, request.user.username)]",
            "",
            "    def handle(self, request, context):",
            "        return {\"foo\": \"bar\"}",
            "",
            "",
            "class ActionTwo(workflows.Action):",
            "    instance_id = forms.CharField(label=\"Instance\")",
            "",
            "    class Meta(object):",
            "        name = \"Action Two\"",
            "        slug = \"action_two\"",
            "",
            "",
            "class ActionThree(workflows.Action):",
            "    extra = forms.CharField(widget=forms.widgets.Textarea)",
            "",
            "    class Meta(object):",
            "        name = \"Action Three\"",
            "        slug = \"action_three\"",
            "",
            "",
            "class ActionFour(workflows.Action):",
            "    field_four = forms.CharField(widget=forms.widgets.Textarea)",
            "",
            "    class Meta(object):",
            "        name = \"Action Four\"",
            "        slug = \"action_four\"",
            "",
            "",
            "class AdminAction(workflows.Action):",
            "    admin_id = forms.CharField(label=\"Admin\")",
            "",
            "    class Meta(object):",
            "        name = \"Admin Action\"",
            "        slug = \"admin_action\"",
            "        permissions = (\"horizon.test\",)",
            "",
            "",
            "class DisabledAction(workflows.Action):",
            "    disabled_id = forms.CharField(label=\"Disabled\")",
            "",
            "    class Meta(object):",
            "        name = \"Action Disabled\"",
            "        slug = \"action_disabled\"",
            "",
            "",
            "class AdminForbiddenAction(workflows.Action):",
            "    admin_id = forms.CharField(label=\"Admin forbidden\")",
            "",
            "    class Meta(object):",
            "        name = \"Admin Action\"",
            "        slug = \"admin_action\"",
            "        policy_rules = (('action', 'forbidden'),)",
            "",
            "",
            "class StepOne(workflows.Step):",
            "    action_class = ActionOne",
            "    contributes = (\"project_id\", \"user_id\")",
            "",
            "",
            "class StepTwo(workflows.Step):",
            "    action_class = ActionTwo",
            "    depends_on = (\"project_id\",)",
            "    contributes = (\"instance_id\",)",
            "    connections = {\"project_id\":",
            "                   (local_callback_func,",
            "                    \"horizon.test.unit.workflows.test_workflows.\"",
            "                    \"other_callback_func\")}",
            "",
            "",
            "class StepThree(workflows.Step):",
            "    action_class = ActionThree",
            "    depends_on = (\"project_id\",)",
            "    contributes = (\"extra_data\",)",
            "    connections = {\"project_id\": (extra_callback_func,)}",
            "    after = StepOne",
            "    before = StepTwo",
            "",
            "",
            "class StepFour(workflows.Step):",
            "    action_class = ActionFour",
            "    contributes = (\"field_four\",)",
            "",
            "",
            "class AdminStep(workflows.Step):",
            "    action_class = AdminAction",
            "    contributes = (\"admin_id\",)",
            "    after = StepOne",
            "    before = StepTwo",
            "",
            "",
            "class DisabledStep(workflows.Step):",
            "    action_class = DisabledAction",
            "    contributes = (\"disabled_id\",)",
            "",
            "    def allowed(self, request):",
            "        return False",
            "",
            "",
            "class AdminForbiddenStep(workflows.Step):",
            "    action_class = AdminForbiddenAction",
            "",
            "",
            "class WorkflowForTesting(workflows.Workflow):",
            "    slug = \"test_workflow\"",
            "    default_steps = (StepOne, StepTwo)",
            "",
            "",
            "class WorkflowWithConfig(workflows.Workflow):",
            "    slug = \"test_workflow\"",
            "    default_steps = (StepOne,)",
            "",
            "",
            "class WorkflowViewForTesting(workflows.WorkflowView):",
            "    workflow_class = WorkflowForTesting",
            "    template_name = \"workflow.html\"",
            "",
            "",
            "class FullscreenWorkflow(workflows.Workflow):",
            "    slug = 'test_fullscreen_workflow'",
            "    default_steps = (StepOne, StepTwo)",
            "    fullscreen = True",
            "",
            "",
            "class FullscreenWorkflowView(workflows.WorkflowView):",
            "    workflow_class = FullscreenWorkflow",
            "    template_name = \"workflow.html\"",
            "",
            "",
            "class WorkflowsTests(test.TestCase):",
            "    def setUp(self):",
            "        super(WorkflowsTests, self).setUp()",
            "        self.policy_patcher = mock.patch(",
            "            'openstack_auth.policy.check', lambda action, request: True)",
            "        self.policy_check = self.policy_patcher.start()",
            "        self.addCleanup(mock.patch.stopall)",
            "",
            "    def tearDown(self):",
            "        super(WorkflowsTests, self).tearDown()",
            "        self._reset_workflow()",
            "",
            "    def _reset_workflow(self):",
            "        WorkflowForTesting._cls_registry = []",
            "",
            "    def test_workflow_construction(self):",
            "        WorkflowForTesting.register(StepThree)",
            "        flow = WorkflowForTesting(self.request)",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepThree: action_three>',",
            "                                  '<StepTwo: action_two>'])",
            "        self.assertEqual(set(['project_id']), flow.depends_on)",
            "",
            "    @test.update_settings(HORIZON_CONFIG={'extra_steps': {",
            "        'horizon.test.unit.workflows.test_workflows.WorkflowWithConfig': (",
            "            'horizon.test.unit.workflows.test_workflows.StepTwo',",
            "            'horizon.test.unit.workflows.test_workflows.StepThree',",
            "            'horizon.test.unit.workflows.test_workflows.StepFour',",
            "        ),",
            "    }})",
            "    def test_workflow_construction_with_config(self):",
            "        flow = WorkflowWithConfig(self.request)",
            "        # NOTE: StepThree must be placed between StepOne and",
            "        # StepTwo in honor of before/after of StepThree.",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepThree: action_three>',",
            "                                  '<StepTwo: action_two>',",
            "                                  '<StepFour: action_four>',",
            "                                  ])",
            "",
            "    def test_step_construction(self):",
            "        step_one = StepOne(WorkflowForTesting(self.request))",
            "        # Action slug is moved from Meta by metaclass, and",
            "        # Step inherits slug from action.",
            "        self.assertEqual(ActionOne.name, step_one.name)",
            "        self.assertEqual(ActionOne.slug, step_one.slug)",
            "        # Handlers should be empty since there are no connections.",
            "        self.assertEqual(step_one._handlers, {})",
            "",
            "        step_two = StepTwo(WorkflowForTesting(self.request))",
            "        # Handlers should be populated since we do have connections.",
            "        self.assertEqual([local_callback_func, other_callback_func],",
            "                         step_two._handlers[\"project_id\"])",
            "",
            "    def test_step_invalid_connections_handlers_not_list_or_tuple(self):",
            "        class InvalidStepA(StepTwo):",
            "            connections = {'project_id': {}}",
            "",
            "        class InvalidStepB(StepTwo):",
            "            connections = {'project_id': ''}",
            "",
            "        with self.assertRaises(TypeError):",
            "            InvalidStepA(WorkflowForTesting(self.request))",
            "",
            "        with self.assertRaises(TypeError):",
            "            InvalidStepB(WorkflowForTesting(self.request))",
            "",
            "    def test_step_invalid_connection_handler_not_string_or_callable(self):",
            "        class InvalidStepA(StepTwo):",
            "            connections = {'project_id': (None,)}",
            "",
            "        class InvalidStepB(StepTwo):",
            "            connections = {'project_id': (0,)}",
            "",
            "        with self.assertRaises(TypeError):",
            "            InvalidStepA(WorkflowForTesting(self.request))",
            "",
            "        with self.assertRaises(TypeError):",
            "            InvalidStepB(WorkflowForTesting(self.request))",
            "",
            "    def test_step_invalid_callback(self):",
            "        # This should raise an exception",
            "        class InvalidStep(StepTwo):",
            "            connections = {\"project_id\": ('local_callback_func',)}",
            "",
            "        with self.assertRaises(ValueError):",
            "            InvalidStep(WorkflowForTesting(self.request))",
            "",
            "    def test_connection_handlers_called(self):",
            "        WorkflowForTesting.register(StepThree)",
            "        flow = WorkflowForTesting(self.request)",
            "",
            "        # This should set the value without any errors, but trigger nothing",
            "        flow.context['does_not_exist'] = False",
            "        self.assertFalse(flow.context['does_not_exist'])",
            "",
            "        # The order here is relevant. Note that we inserted \"extra\" between",
            "        # steps one and two, and one has no handlers, so we should see",
            "        # a response from extra, then one from each of step two's handlers.",
            "        val = flow.context.set('project_id', PROJECT_ID)",
            "        self.assertEqual([('action_three', 'extra'),",
            "                          ('action_two', 'one'),",
            "                          ('action_two', 'two')], val)",
            "",
            "    def test_workflow_validation(self):",
            "        flow = WorkflowForTesting(self.request)",
            "",
            "        # Missing items fail validation.",
            "        with self.assertRaises(exceptions.WorkflowValidationError):",
            "            flow.is_valid()",
            "",
            "        # All required items pass validation.",
            "        seed = {\"project_id\": PROJECT_ID,",
            "                \"user_id\": self.user.id,",
            "                \"instance_id\": INSTANCE_ID}",
            "        req = self.factory.post(\"/\", seed)",
            "        req.user = self.user",
            "        flow = WorkflowForTesting(req, context_seed={\"project_id\": PROJECT_ID})",
            "        for step in flow.steps:",
            "            if not step.action.is_valid():",
            "                self.fail(\"Step %s was unexpectedly invalid: %s\"",
            "                          % (step.slug, step.action.errors))",
            "        self.assertTrue(flow.is_valid())",
            "",
            "        # Additional items shouldn't affect validation",
            "        flow.context.set(\"extra_data\", \"foo\")",
            "        self.assertTrue(flow.is_valid())",
            "",
            "    def test_workflow_finalization(self):",
            "        flow = WorkflowForTesting(self.request)",
            "        self.assertTrue(flow.finalize())",
            "",
            "    def test_workflow_view(self):",
            "        view = WorkflowViewForTesting.as_view()",
            "        req = self.factory.get(\"/\")",
            "        res = view(req)",
            "        self.assertEqual(200, res.status_code)",
            "",
            "    def test_workflow_registration(self):",
            "        req = self.factory.get(\"/foo\")",
            "        flow = WorkflowForTesting(req)",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "        WorkflowForTesting.register(StepThree)",
            "        flow = WorkflowForTesting(req)",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepThree: action_three>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "    def test_workflow_unregister_unexisting_workflow(self):",
            "        with self.assertRaises(base.NotRegistered):",
            "            WorkflowForTesting.unregister(DisabledStep)",
            "",
            "    def test_workflow_render(self):",
            "        WorkflowForTesting.register(StepThree)",
            "        req = self.factory.get(\"/foo\")",
            "        flow = WorkflowForTesting(req)",
            "        output = http.HttpResponse(flow.render())",
            "        self.assertContains(output, flow.name)",
            "        self.assertContains(output, ActionOne.name)",
            "        self.assertContains(output, ActionTwo.name)",
            "        self.assertContains(output, ActionThree.name)",
            "",
            "    def test_has_permissions(self):",
            "        self.assertQuerysetEqual(WorkflowForTesting._cls_registry, [])",
            "        WorkflowForTesting.register(AdminStep)",
            "        flow = WorkflowForTesting(self.request)",
            "        step = AdminStep(flow)",
            "",
            "        self.assertCountEqual(step.permissions,",
            "                              (\"horizon.test\",))",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "        self.set_permissions(['test'])",
            "        self.request.user = self.user",
            "        flow = WorkflowForTesting(self.request)",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<AdminStep: admin_action>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "    def test_has_allowed(self):",
            "        WorkflowForTesting.register(DisabledStep)",
            "        flow = WorkflowForTesting(self.request)",
            "        # Check DisabledStep is not included",
            "        # even though DisabledStep is registered.",
            "        self.assertQuerysetEqual(flow.steps,",
            "                                 ['<StepOne: action_one>',",
            "                                  '<StepTwo: action_two>'])",
            "",
            "    def test_step_is_hidden_on_policy(self):",
            "        self.policy_patcher.stop()",
            "",
            "        def policy_check(action, request):",
            "            if action == (('action', 'forbidden'),):",
            "                return False",
            "            return True",
            "",
            "        with mock.patch('openstack_auth.policy.check', policy_check):",
            "            WorkflowForTesting.register(AdminForbiddenStep)",
            "            flow = WorkflowForTesting(self.request)",
            "            output = http.HttpResponse(flow.render())",
            "            self.assertNotContains(output, AdminForbiddenAction.name)",
            "",
            "    def test_entry_point(self):",
            "        req = self.factory.get(\"/foo\")",
            "        flow = WorkflowForTesting(req)",
            "        self.assertEqual(\"action_one\", flow.get_entry_point())",
            "",
            "        flow = WorkflowForTesting(req, entry_point=\"action_two\")",
            "        self.assertEqual(\"action_two\", flow.get_entry_point())",
            "",
            "    @override_settings(ALLOWED_HOSTS=['localhost'])",
            "    def test_redirect_url_safe(self):",
            "        url = 'http://localhost/test'",
            "        view = WorkflowViewForTesting()",
            "        request = self.factory.get(\"/\", data={",
            "            'next': url,",
            "        })",
            "        request.META['SERVER_NAME'] = \"localhost\"",
            "        view.request = request",
            "        context = view.get_context_data()",
            "        self.assertEqual(url, context['REDIRECT_URL'])",
            "",
            "    @override_settings(ALLOWED_HOSTS=['localhost'])",
            "    def test_redirect_url_unsafe(self):",
            "        url = 'http://evilcorp/test'",
            "        view = WorkflowViewForTesting()",
            "        request = self.factory.get(\"/\", data={",
            "            'next': url,",
            "        })",
            "        request.META['SERVER_NAME'] = \"localhost\"",
            "        view.request = request",
            "        context = view.get_context_data()",
            "        self.assertIsNone(context['REDIRECT_URL'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "horizon.test.unit.workflows.test_workflows.WorkflowsTests.self",
            "web.server.codechecker_server.server"
        ]
    },
    "horizon/workflows/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from django import forms"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from django import http"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from django import shortcuts"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from django.utils import http as utils_http"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from django.views import generic"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from horizon import exceptions"
            },
            "7": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         workflow = self.get_workflow()"
            },
            "8": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         workflow.verify_integrity()"
            },
            "9": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         context[self.context_object_name] = workflow"
            },
            "10": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        next = self.request.GET.get(workflow.redirect_param_name)"
            },
            "11": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        context['REDIRECT_URL'] = next"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        redirect_to = self.request.GET.get(workflow.redirect_param_name)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        # Make sure the requested redirect is safe"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        if redirect_to and not utils_http.is_safe_url("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                url=redirect_to,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+                allowed_hosts=[self.request.get_host()]):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+            redirect_to = None"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        context['REDIRECT_URL'] = redirect_to"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         context['layout'] = self.get_layout()"
            },
            "22": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         # For consistency with Workflow class"
            },
            "23": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         context['modal'] = 'modal' in context['layout']"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 Nebula, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import json",
            "",
            "from django import forms",
            "from django import http",
            "from django import shortcuts",
            "from django.views import generic",
            "",
            "from horizon import exceptions",
            "from horizon.forms import views as hz_views",
            "from horizon.forms.views import ADD_TO_FIELD_HEADER",
            "from horizon import messages",
            "",
            "",
            "class WorkflowView(hz_views.ModalBackdropMixin, generic.TemplateView):",
            "    \"\"\"A generic view which handles the intricacies of workflow processing.",
            "",
            "    .. attribute:: workflow_class",
            "",
            "        The :class:`~horizon.workflows.Workflow` class which this view handles.",
            "        Required.",
            "",
            "    .. attribute:: template_name",
            "",
            "        The template to use when rendering this view via standard HTTP",
            "        requests. Required.",
            "",
            "    .. attribute:: ajax_template_name",
            "",
            "        The template to use when rendering the workflow for AJAX requests.",
            "        In general the default common template should be used. Defaults to",
            "        ``\"horizon/common/_workflow.html\"``.",
            "",
            "    .. attribute:: context_object_name",
            "",
            "        The key which should be used for the workflow object in the template",
            "        context. Defaults to ``\"workflow\"``.",
            "",
            "    \"\"\"",
            "    workflow_class = None",
            "    template_name = 'horizon/common/_workflow_base.html'",
            "    context_object_name = \"workflow\"",
            "    ajax_template_name = 'horizon/common/_workflow.html'",
            "    step_errors = {}",
            "",
            "    def __init__(self):",
            "        super(WorkflowView, self).__init__()",
            "        if not self.workflow_class:",
            "            raise AttributeError(\"You must set the workflow_class attribute \"",
            "                                 \"on %s.\" % self.__class__.__name__)",
            "",
            "    def get_initial(self):",
            "        \"\"\"Returns initial data for the workflow.",
            "",
            "        Defaults to using the GET parameters",
            "        to allow pre-seeding of the workflow context values.",
            "        \"\"\"",
            "        return copy.copy(self.request.GET)",
            "",
            "    def get_workflow(self):",
            "        \"\"\"Returns the instantiated workflow class.\"\"\"",
            "        extra_context = self.get_initial()",
            "        entry_point = self.request.GET.get(\"step\", None)",
            "        workflow = self.workflow_class(self.request,",
            "                                       context_seed=extra_context,",
            "                                       entry_point=entry_point)",
            "        return workflow",
            "",
            "    def get_context_data(self, **kwargs):",
            "        \"\"\"Returns the template context, including the workflow class.",
            "",
            "        This method should be overridden in subclasses to provide additional",
            "        context data to the template.",
            "        \"\"\"",
            "        context = super(WorkflowView, self).get_context_data(**kwargs)",
            "        workflow = self.get_workflow()",
            "        workflow.verify_integrity()",
            "        context[self.context_object_name] = workflow",
            "        next = self.request.GET.get(workflow.redirect_param_name)",
            "        context['REDIRECT_URL'] = next",
            "        context['layout'] = self.get_layout()",
            "        # For consistency with Workflow class",
            "        context['modal'] = 'modal' in context['layout']",
            "",
            "        if ADD_TO_FIELD_HEADER in self.request.META:",
            "            context['add_to_field'] = self.request.META[ADD_TO_FIELD_HEADER]",
            "        return context",
            "",
            "    def get_layout(self):",
            "        \"\"\"Returns classes for the workflow element in template.",
            "",
            "        The returned classes are determied based on",
            "        the workflow characteristics.",
            "        \"\"\"",
            "        if self.request.is_ajax():",
            "            layout = ['modal', ]",
            "        else:",
            "            layout = ['static_page', ]",
            "",
            "        if self.workflow_class.wizard:",
            "            layout += ['wizard', ]",
            "",
            "        return layout",
            "",
            "    def get_template_names(self):",
            "        \"\"\"Returns the template name to use for this request.\"\"\"",
            "        if self.request.is_ajax():",
            "            template = self.ajax_template_name",
            "        else:",
            "            template = self.template_name",
            "        return template",
            "",
            "    def get_object_id(self, obj):",
            "        return getattr(obj, \"id\", None)",
            "",
            "    def get_object_display(self, obj):",
            "        return getattr(obj, \"name\", None)",
            "",
            "    def add_error_to_step(self, error_msg, step):",
            "        self.step_errors[step] = error_msg",
            "",
            "    def set_workflow_step_errors(self, context):",
            "        workflow = context['workflow']",
            "        for step in self.step_errors:",
            "            error_msg = self.step_errors[step]",
            "            workflow.add_error_to_step(error_msg, step)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"Handler for HTTP GET requests.\"\"\"",
            "        try:",
            "            context = self.get_context_data(**kwargs)",
            "        except exceptions.NotAvailable:",
            "            exceptions.handle(request)",
            "        self.set_workflow_step_errors(context)",
            "        return self.render_to_response(context)",
            "",
            "    def validate_steps(self, request, workflow, start, end):",
            "        \"\"\"Validates the workflow steps from ``start`` to ``end``, inclusive.",
            "",
            "        Returns a dict describing the validation state of the workflow.",
            "        \"\"\"",
            "        errors = {}",
            "        for step in workflow.steps[start:end + 1]:",
            "            if not step.action.is_valid():",
            "                errors[step.slug] = dict(",
            "                    (field, [str(error) for error in errors])",
            "                    for (field, errors) in step.action.errors.items())",
            "        return {",
            "            'has_errors': bool(errors),",
            "            'workflow_slug': workflow.slug,",
            "            'errors': errors,",
            "        }",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        \"\"\"Handler for HTTP POST requests.\"\"\"",
            "        context = self.get_context_data(**kwargs)",
            "        workflow = context[self.context_object_name]",
            "        try:",
            "            # Check for the VALIDATE_STEP* headers, if they are present",
            "            # and valid integers, return validation results as JSON,",
            "            # otherwise proceed normally.",
            "            validate_step_start = int(self.request.META.get(",
            "                'HTTP_X_HORIZON_VALIDATE_STEP_START', ''))",
            "            validate_step_end = int(self.request.META.get(",
            "                'HTTP_X_HORIZON_VALIDATE_STEP_END', ''))",
            "        except ValueError:",
            "            # No VALIDATE_STEP* headers, or invalid values. Just proceed",
            "            # with normal workflow handling for POSTs.",
            "            pass",
            "        else:",
            "            # There are valid VALIDATE_STEP* headers, so only do validation",
            "            # for the specified steps and return results.",
            "            data = self.validate_steps(request, workflow,",
            "                                       validate_step_start,",
            "                                       validate_step_end)",
            "            return http.HttpResponse(json.dumps(data),",
            "                                     content_type=\"application/json\")",
            "        if not workflow.is_valid():",
            "            return self.render_to_response(context)",
            "        try:",
            "            success = workflow.finalize()",
            "        except forms.ValidationError:",
            "            return self.render_to_response(context)",
            "        except Exception:",
            "            success = False",
            "            exceptions.handle(request)",
            "        if success:",
            "            msg = workflow.format_status_message(workflow.success_message)",
            "            messages.success(request, msg)",
            "        else:",
            "            msg = workflow.format_status_message(workflow.failure_message)",
            "            messages.error(request, msg)",
            "        if \"HTTP_X_HORIZON_ADD_TO_FIELD\" in self.request.META:",
            "            field_id = self.request.META[\"HTTP_X_HORIZON_ADD_TO_FIELD\"]",
            "            response = http.HttpResponse(content_type=\"text/plain\")",
            "            if workflow.object:",
            "                data = [self.get_object_id(workflow.object),",
            "                        self.get_object_display(workflow.object)]",
            "                response.content = json.dumps(data)",
            "                response[\"X-Horizon-Add-To-Field\"] = field_id",
            "            return response",
            "        next_url = self.request.POST.get(workflow.redirect_param_name)",
            "        return shortcuts.redirect(next_url or workflow.get_success_url())"
        ],
        "afterPatchFile": [
            "# Copyright 2012 Nebula, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import json",
            "",
            "from django import forms",
            "from django import http",
            "from django import shortcuts",
            "from django.utils import http as utils_http",
            "from django.views import generic",
            "",
            "from horizon import exceptions",
            "from horizon.forms import views as hz_views",
            "from horizon.forms.views import ADD_TO_FIELD_HEADER",
            "from horizon import messages",
            "",
            "",
            "class WorkflowView(hz_views.ModalBackdropMixin, generic.TemplateView):",
            "    \"\"\"A generic view which handles the intricacies of workflow processing.",
            "",
            "    .. attribute:: workflow_class",
            "",
            "        The :class:`~horizon.workflows.Workflow` class which this view handles.",
            "        Required.",
            "",
            "    .. attribute:: template_name",
            "",
            "        The template to use when rendering this view via standard HTTP",
            "        requests. Required.",
            "",
            "    .. attribute:: ajax_template_name",
            "",
            "        The template to use when rendering the workflow for AJAX requests.",
            "        In general the default common template should be used. Defaults to",
            "        ``\"horizon/common/_workflow.html\"``.",
            "",
            "    .. attribute:: context_object_name",
            "",
            "        The key which should be used for the workflow object in the template",
            "        context. Defaults to ``\"workflow\"``.",
            "",
            "    \"\"\"",
            "    workflow_class = None",
            "    template_name = 'horizon/common/_workflow_base.html'",
            "    context_object_name = \"workflow\"",
            "    ajax_template_name = 'horizon/common/_workflow.html'",
            "    step_errors = {}",
            "",
            "    def __init__(self):",
            "        super(WorkflowView, self).__init__()",
            "        if not self.workflow_class:",
            "            raise AttributeError(\"You must set the workflow_class attribute \"",
            "                                 \"on %s.\" % self.__class__.__name__)",
            "",
            "    def get_initial(self):",
            "        \"\"\"Returns initial data for the workflow.",
            "",
            "        Defaults to using the GET parameters",
            "        to allow pre-seeding of the workflow context values.",
            "        \"\"\"",
            "        return copy.copy(self.request.GET)",
            "",
            "    def get_workflow(self):",
            "        \"\"\"Returns the instantiated workflow class.\"\"\"",
            "        extra_context = self.get_initial()",
            "        entry_point = self.request.GET.get(\"step\", None)",
            "        workflow = self.workflow_class(self.request,",
            "                                       context_seed=extra_context,",
            "                                       entry_point=entry_point)",
            "        return workflow",
            "",
            "    def get_context_data(self, **kwargs):",
            "        \"\"\"Returns the template context, including the workflow class.",
            "",
            "        This method should be overridden in subclasses to provide additional",
            "        context data to the template.",
            "        \"\"\"",
            "        context = super(WorkflowView, self).get_context_data(**kwargs)",
            "        workflow = self.get_workflow()",
            "        workflow.verify_integrity()",
            "        context[self.context_object_name] = workflow",
            "",
            "        redirect_to = self.request.GET.get(workflow.redirect_param_name)",
            "        # Make sure the requested redirect is safe",
            "        if redirect_to and not utils_http.is_safe_url(",
            "                url=redirect_to,",
            "                allowed_hosts=[self.request.get_host()]):",
            "            redirect_to = None",
            "        context['REDIRECT_URL'] = redirect_to",
            "",
            "        context['layout'] = self.get_layout()",
            "        # For consistency with Workflow class",
            "        context['modal'] = 'modal' in context['layout']",
            "",
            "        if ADD_TO_FIELD_HEADER in self.request.META:",
            "            context['add_to_field'] = self.request.META[ADD_TO_FIELD_HEADER]",
            "        return context",
            "",
            "    def get_layout(self):",
            "        \"\"\"Returns classes for the workflow element in template.",
            "",
            "        The returned classes are determied based on",
            "        the workflow characteristics.",
            "        \"\"\"",
            "        if self.request.is_ajax():",
            "            layout = ['modal', ]",
            "        else:",
            "            layout = ['static_page', ]",
            "",
            "        if self.workflow_class.wizard:",
            "            layout += ['wizard', ]",
            "",
            "        return layout",
            "",
            "    def get_template_names(self):",
            "        \"\"\"Returns the template name to use for this request.\"\"\"",
            "        if self.request.is_ajax():",
            "            template = self.ajax_template_name",
            "        else:",
            "            template = self.template_name",
            "        return template",
            "",
            "    def get_object_id(self, obj):",
            "        return getattr(obj, \"id\", None)",
            "",
            "    def get_object_display(self, obj):",
            "        return getattr(obj, \"name\", None)",
            "",
            "    def add_error_to_step(self, error_msg, step):",
            "        self.step_errors[step] = error_msg",
            "",
            "    def set_workflow_step_errors(self, context):",
            "        workflow = context['workflow']",
            "        for step in self.step_errors:",
            "            error_msg = self.step_errors[step]",
            "            workflow.add_error_to_step(error_msg, step)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"Handler for HTTP GET requests.\"\"\"",
            "        try:",
            "            context = self.get_context_data(**kwargs)",
            "        except exceptions.NotAvailable:",
            "            exceptions.handle(request)",
            "        self.set_workflow_step_errors(context)",
            "        return self.render_to_response(context)",
            "",
            "    def validate_steps(self, request, workflow, start, end):",
            "        \"\"\"Validates the workflow steps from ``start`` to ``end``, inclusive.",
            "",
            "        Returns a dict describing the validation state of the workflow.",
            "        \"\"\"",
            "        errors = {}",
            "        for step in workflow.steps[start:end + 1]:",
            "            if not step.action.is_valid():",
            "                errors[step.slug] = dict(",
            "                    (field, [str(error) for error in errors])",
            "                    for (field, errors) in step.action.errors.items())",
            "        return {",
            "            'has_errors': bool(errors),",
            "            'workflow_slug': workflow.slug,",
            "            'errors': errors,",
            "        }",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        \"\"\"Handler for HTTP POST requests.\"\"\"",
            "        context = self.get_context_data(**kwargs)",
            "        workflow = context[self.context_object_name]",
            "        try:",
            "            # Check for the VALIDATE_STEP* headers, if they are present",
            "            # and valid integers, return validation results as JSON,",
            "            # otherwise proceed normally.",
            "            validate_step_start = int(self.request.META.get(",
            "                'HTTP_X_HORIZON_VALIDATE_STEP_START', ''))",
            "            validate_step_end = int(self.request.META.get(",
            "                'HTTP_X_HORIZON_VALIDATE_STEP_END', ''))",
            "        except ValueError:",
            "            # No VALIDATE_STEP* headers, or invalid values. Just proceed",
            "            # with normal workflow handling for POSTs.",
            "            pass",
            "        else:",
            "            # There are valid VALIDATE_STEP* headers, so only do validation",
            "            # for the specified steps and return results.",
            "            data = self.validate_steps(request, workflow,",
            "                                       validate_step_start,",
            "                                       validate_step_end)",
            "            return http.HttpResponse(json.dumps(data),",
            "                                     content_type=\"application/json\")",
            "        if not workflow.is_valid():",
            "            return self.render_to_response(context)",
            "        try:",
            "            success = workflow.finalize()",
            "        except forms.ValidationError:",
            "            return self.render_to_response(context)",
            "        except Exception:",
            "            success = False",
            "            exceptions.handle(request)",
            "        if success:",
            "            msg = workflow.format_status_message(workflow.success_message)",
            "            messages.success(request, msg)",
            "        else:",
            "            msg = workflow.format_status_message(workflow.failure_message)",
            "            messages.error(request, msg)",
            "        if \"HTTP_X_HORIZON_ADD_TO_FIELD\" in self.request.META:",
            "            field_id = self.request.META[\"HTTP_X_HORIZON_ADD_TO_FIELD\"]",
            "            response = http.HttpResponse(content_type=\"text/plain\")",
            "            if workflow.object:",
            "                data = [self.get_object_id(workflow.object),",
            "                        self.get_object_display(workflow.object)]",
            "                response.content = json.dumps(data)",
            "                response[\"X-Horizon-Add-To-Field\"] = field_id",
            "            return response",
            "        next_url = self.request.POST.get(workflow.redirect_param_name)",
            "        return shortcuts.redirect(next_url or workflow.get_success_url())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "93": [
                "WorkflowView",
                "get_context_data"
            ],
            "94": [
                "WorkflowView",
                "get_context_data"
            ]
        },
        "addLocation": []
    }
}