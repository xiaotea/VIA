{
    "petl/io/xml.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     or list of paths can be provided, e.g.,"
            },
            "1": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     ``fromxml('example.html', './/tr', ('th', 'td'))``."
            },
            "2": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    Optionally a custom parser can be provided, e.g.,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+    ``etl.fromxml('example1.xml', 'tr', 'td', parser=my_parser)``."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "     source = read_source_from_arg(source)"
            },
            "9": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         else:"
            },
            "10": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "             assert False, 'bad parameters'"
            },
            "11": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         self.missing = kwargs.get('missing', None)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        self.user_parser = kwargs.get('parser', None)"
            },
            "13": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     def __iter__(self):"
            },
            "15": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         vmatch = self.vmatch"
            },
            "16": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         vdict = self.vdict"
            },
            "17": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         with self.source.open('rb') as xmlf:"
            },
            "19": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "20": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            tree = etree.parse(xmlf)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+            parser2 = _create_xml_parser(self.user_parser)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            tree = etree.parse(xmlf, parser=parser2)"
            },
            "23": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "             if not hasattr(tree, 'iterfind'):"
            },
            "24": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "                 # Python 2.6 compatibility"
            },
            "25": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "                 tree.iterfind = tree.findall"
            },
            "26": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "                                 for f in flds)"
            },
            "27": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 224,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 225,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+def _create_xml_parser(user_parser):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+    if user_parser is not None:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        return user_parser"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+    try:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        # Default lxml parser."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        # This will throw an error if parser is not set and lxml could not be imported"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        # because Python's built XML parser doesn't like the `resolve_entities` kwarg."
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        # return etree.XMLParser(resolve_entities=False)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        return etree.XMLParser(resolve_entities=False)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+    except TypeError:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        # lxml not available"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        return None"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " def element_text_getter(missing):"
            },
            "44": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "     def _get(v):"
            },
            "45": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         if len(v) > 1:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, print_function, division",
            "",
            "",
            "# standard library dependencies",
            "try:",
            "    # prefer lxml as it supports XPath",
            "    from lxml import etree",
            "except ImportError:",
            "    import xml.etree.ElementTree as etree",
            "",
            "from operator import attrgetter",
            "import itertools",
            "from petl.compat import string_types, text_type",
            "",
            "",
            "# internal dependencies",
            "from petl.util.base import Table",
            "from petl.io.sources import read_source_from_arg",
            "",
            "",
            "def fromxml(source, *args, **kwargs):",
            "    \"\"\"",
            "    Extract data from an XML file. E.g.::",
            "",
            "        >>> import petl as etl",
            "        >>> # setup a file to demonstrate with",
            "        ... d = '''<table>",
            "        ...     <tr>",
            "        ...         <td>foo</td><td>bar</td>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td>a</td><td>1</td>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td>b</td><td>2</td>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td>c</td><td>2</td>",
            "        ...     </tr>",
            "        ... </table>'''",
            "        >>> with open('example1.xml', 'w') as f:",
            "        ...     f.write(d)",
            "        ...",
            "        212",
            "        >>> table1 = etl.fromxml('example1.xml', 'tr', 'td')",
            "        >>> table1",
            "        +-----+-----+",
            "        | foo | bar |",
            "        +=====+=====+",
            "        | 'a' | '1' |",
            "        +-----+-----+",
            "        | 'b' | '2' |",
            "        +-----+-----+",
            "        | 'c' | '2' |",
            "        +-----+-----+",
            "",
            "",
            "    If the data values are stored in an attribute, provide the attribute",
            "    name as an extra positional argument::",
            "",
            "        >>> d = '''<table>",
            "        ...     <tr>",
            "        ...         <td v='foo'/><td v='bar'/>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td v='a'/><td v='1'/>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td v='b'/><td v='2'/>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td v='c'/><td v='2'/>",
            "        ...     </tr>",
            "        ... </table>'''",
            "        >>> with open('example2.xml', 'w') as f:",
            "        ...     f.write(d)",
            "        ...",
            "        220",
            "        >>> table2 = etl.fromxml('example2.xml', 'tr', 'td', 'v')",
            "        >>> table2",
            "        +-----+-----+",
            "        | foo | bar |",
            "        +=====+=====+",
            "        | 'a' | '1' |",
            "        +-----+-----+",
            "        | 'b' | '2' |",
            "        +-----+-----+",
            "        | 'c' | '2' |",
            "        +-----+-----+",
            "",
            "    Data values can also be extracted by providing a mapping of field",
            "    names to element paths::",
            "",
            "        >>> d = '''<table>",
            "        ...     <row>",
            "        ...         <foo>a</foo><baz><bar v='1'/><bar v='3'/></baz>",
            "        ...     </row>",
            "        ...     <row>",
            "        ...         <foo>b</foo><baz><bar v='2'/></baz>",
            "        ...     </row>",
            "        ...     <row>",
            "        ...         <foo>c</foo><baz><bar v='2'/></baz>",
            "        ...     </row>",
            "        ... </table>'''",
            "        >>> with open('example3.xml', 'w') as f:",
            "        ...     f.write(d)",
            "        ...",
            "        223",
            "        >>> table3 = etl.fromxml('example3.xml', 'row',",
            "        ...                      {'foo': 'foo', 'bar': ('baz/bar', 'v')})",
            "        >>> table3",
            "        +------------+-----+",
            "        | bar        | foo |",
            "        +============+=====+",
            "        | ('1', '3') | 'a' |",
            "        +------------+-----+",
            "        | '2'        | 'b' |",
            "        +------------+-----+",
            "        | '2'        | 'c' |",
            "        +------------+-----+",
            "",
            "    If `lxml <http://lxml.de/>`_ is installed, full XPath expressions can be",
            "    used.",
            "",
            "    Note that the implementation is currently **not** streaming, i.e.,",
            "    the whole document is loaded into memory.",
            "",
            "    If multiple elements match a given field, all values are reported as a",
            "    tuple.",
            "",
            "    If there is more than one element name used for row values, a tuple",
            "    or list of paths can be provided, e.g.,",
            "    ``fromxml('example.html', './/tr', ('th', 'td'))``.",
            "",
            "    \"\"\"",
            "",
            "    source = read_source_from_arg(source)",
            "    return XmlView(source, *args, **kwargs)",
            "",
            "",
            "class XmlView(Table):",
            "",
            "    def __init__(self, source, *args, **kwargs):",
            "        self.source = source",
            "        self.args = args",
            "        if len(args) == 2 and isinstance(args[1], (string_types, tuple, list)):",
            "            self.rmatch = args[0]",
            "            self.vmatch = args[1]",
            "            self.vdict = None",
            "            self.attr = None",
            "        elif len(args) == 2 and isinstance(args[1], dict):",
            "            self.rmatch = args[0]",
            "            self.vmatch = None",
            "            self.vdict = args[1]",
            "            self.attr = None",
            "        elif len(args) == 3:",
            "            self.rmatch = args[0]",
            "            self.vmatch = args[1]",
            "            self.vdict = None",
            "            self.attr = args[2]",
            "        else:",
            "            assert False, 'bad parameters'",
            "        self.missing = kwargs.get('missing', None)",
            "",
            "    def __iter__(self):",
            "        vmatch = self.vmatch",
            "        vdict = self.vdict",
            "",
            "        with self.source.open('rb') as xmlf:",
            "",
            "            tree = etree.parse(xmlf)",
            "            if not hasattr(tree, 'iterfind'):",
            "                # Python 2.6 compatibility",
            "                tree.iterfind = tree.findall",
            "",
            "            if vmatch is not None:",
            "                # simple case, all value paths are the same",
            "                for rowelm in tree.iterfind(self.rmatch):",
            "                    if self.attr is None:",
            "                        getv = attrgetter('text')",
            "                    else:",
            "                        getv = lambda e: e.get(self.attr)",
            "                    if isinstance(vmatch, string_types):",
            "                        # match only one path",
            "                        velms = rowelm.findall(vmatch)",
            "                    else:",
            "                        # match multiple paths",
            "                        velms = itertools.chain(*[rowelm.findall(enm)",
            "                                                  for enm in vmatch])",
            "                    yield tuple(getv(velm)",
            "                                for velm in velms)",
            "",
            "            else:",
            "                # difficult case, deal with different paths for each field",
            "",
            "                # determine output header",
            "                flds = tuple(sorted(map(text_type, vdict.keys())))",
            "                yield flds",
            "",
            "                # setup value getters",
            "                vmatches = dict()",
            "                vgetters = dict()",
            "                for f in flds:",
            "                    vmatch = self.vdict[f]",
            "                    if isinstance(vmatch, string_types):",
            "                        # match element path",
            "                        vmatches[f] = vmatch",
            "                        vgetters[f] = element_text_getter(self.missing)",
            "                    else:",
            "                        # match element path and attribute name",
            "                        vmatches[f] = vmatch[0]",
            "                        attr = vmatch[1]",
            "                        vgetters[f] = attribute_text_getter(attr, self.missing)",
            "",
            "                # determine data rows",
            "                for rowelm in tree.iterfind(self.rmatch):",
            "                    yield tuple(vgetters[f](rowelm.findall(vmatches[f]))",
            "                                for f in flds)",
            "",
            "",
            "def element_text_getter(missing):",
            "    def _get(v):",
            "        if len(v) > 1:",
            "            return tuple(e.text for e in v)",
            "        elif len(v) == 1:",
            "            return v[0].text",
            "        else:",
            "            return missing",
            "    return _get",
            "",
            "",
            "def attribute_text_getter(attr, missing):",
            "    def _get(v):",
            "        if len(v) > 1:",
            "            return tuple(e.get(attr) for e in v)",
            "        elif len(v) == 1:",
            "            return v[0].get(attr)",
            "        else:",
            "            return missing",
            "    return _get"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, print_function, division",
            "",
            "",
            "# standard library dependencies",
            "try:",
            "    # prefer lxml as it supports XPath",
            "    from lxml import etree",
            "except ImportError:",
            "    import xml.etree.ElementTree as etree",
            "",
            "from operator import attrgetter",
            "import itertools",
            "from petl.compat import string_types, text_type",
            "",
            "",
            "# internal dependencies",
            "from petl.util.base import Table",
            "from petl.io.sources import read_source_from_arg",
            "",
            "",
            "def fromxml(source, *args, **kwargs):",
            "    \"\"\"",
            "    Extract data from an XML file. E.g.::",
            "",
            "        >>> import petl as etl",
            "        >>> # setup a file to demonstrate with",
            "        ... d = '''<table>",
            "        ...     <tr>",
            "        ...         <td>foo</td><td>bar</td>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td>a</td><td>1</td>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td>b</td><td>2</td>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td>c</td><td>2</td>",
            "        ...     </tr>",
            "        ... </table>'''",
            "        >>> with open('example1.xml', 'w') as f:",
            "        ...     f.write(d)",
            "        ...",
            "        212",
            "        >>> table1 = etl.fromxml('example1.xml', 'tr', 'td')",
            "        >>> table1",
            "        +-----+-----+",
            "        | foo | bar |",
            "        +=====+=====+",
            "        | 'a' | '1' |",
            "        +-----+-----+",
            "        | 'b' | '2' |",
            "        +-----+-----+",
            "        | 'c' | '2' |",
            "        +-----+-----+",
            "",
            "",
            "    If the data values are stored in an attribute, provide the attribute",
            "    name as an extra positional argument::",
            "",
            "        >>> d = '''<table>",
            "        ...     <tr>",
            "        ...         <td v='foo'/><td v='bar'/>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td v='a'/><td v='1'/>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td v='b'/><td v='2'/>",
            "        ...     </tr>",
            "        ...     <tr>",
            "        ...         <td v='c'/><td v='2'/>",
            "        ...     </tr>",
            "        ... </table>'''",
            "        >>> with open('example2.xml', 'w') as f:",
            "        ...     f.write(d)",
            "        ...",
            "        220",
            "        >>> table2 = etl.fromxml('example2.xml', 'tr', 'td', 'v')",
            "        >>> table2",
            "        +-----+-----+",
            "        | foo | bar |",
            "        +=====+=====+",
            "        | 'a' | '1' |",
            "        +-----+-----+",
            "        | 'b' | '2' |",
            "        +-----+-----+",
            "        | 'c' | '2' |",
            "        +-----+-----+",
            "",
            "    Data values can also be extracted by providing a mapping of field",
            "    names to element paths::",
            "",
            "        >>> d = '''<table>",
            "        ...     <row>",
            "        ...         <foo>a</foo><baz><bar v='1'/><bar v='3'/></baz>",
            "        ...     </row>",
            "        ...     <row>",
            "        ...         <foo>b</foo><baz><bar v='2'/></baz>",
            "        ...     </row>",
            "        ...     <row>",
            "        ...         <foo>c</foo><baz><bar v='2'/></baz>",
            "        ...     </row>",
            "        ... </table>'''",
            "        >>> with open('example3.xml', 'w') as f:",
            "        ...     f.write(d)",
            "        ...",
            "        223",
            "        >>> table3 = etl.fromxml('example3.xml', 'row',",
            "        ...                      {'foo': 'foo', 'bar': ('baz/bar', 'v')})",
            "        >>> table3",
            "        +------------+-----+",
            "        | bar        | foo |",
            "        +============+=====+",
            "        | ('1', '3') | 'a' |",
            "        +------------+-----+",
            "        | '2'        | 'b' |",
            "        +------------+-----+",
            "        | '2'        | 'c' |",
            "        +------------+-----+",
            "",
            "    If `lxml <http://lxml.de/>`_ is installed, full XPath expressions can be",
            "    used.",
            "",
            "    Note that the implementation is currently **not** streaming, i.e.,",
            "    the whole document is loaded into memory.",
            "",
            "    If multiple elements match a given field, all values are reported as a",
            "    tuple.",
            "",
            "    If there is more than one element name used for row values, a tuple",
            "    or list of paths can be provided, e.g.,",
            "    ``fromxml('example.html', './/tr', ('th', 'td'))``.",
            "",
            "    Optionally a custom parser can be provided, e.g.,",
            "    ``etl.fromxml('example1.xml', 'tr', 'td', parser=my_parser)``.",
            "",
            "    \"\"\"",
            "",
            "    source = read_source_from_arg(source)",
            "    return XmlView(source, *args, **kwargs)",
            "",
            "",
            "class XmlView(Table):",
            "",
            "    def __init__(self, source, *args, **kwargs):",
            "        self.source = source",
            "        self.args = args",
            "        if len(args) == 2 and isinstance(args[1], (string_types, tuple, list)):",
            "            self.rmatch = args[0]",
            "            self.vmatch = args[1]",
            "            self.vdict = None",
            "            self.attr = None",
            "        elif len(args) == 2 and isinstance(args[1], dict):",
            "            self.rmatch = args[0]",
            "            self.vmatch = None",
            "            self.vdict = args[1]",
            "            self.attr = None",
            "        elif len(args) == 3:",
            "            self.rmatch = args[0]",
            "            self.vmatch = args[1]",
            "            self.vdict = None",
            "            self.attr = args[2]",
            "        else:",
            "            assert False, 'bad parameters'",
            "        self.missing = kwargs.get('missing', None)",
            "        self.user_parser = kwargs.get('parser', None)",
            "",
            "    def __iter__(self):",
            "        vmatch = self.vmatch",
            "        vdict = self.vdict",
            "",
            "        with self.source.open('rb') as xmlf:",
            "            parser2 = _create_xml_parser(self.user_parser)",
            "            tree = etree.parse(xmlf, parser=parser2)",
            "            if not hasattr(tree, 'iterfind'):",
            "                # Python 2.6 compatibility",
            "                tree.iterfind = tree.findall",
            "",
            "            if vmatch is not None:",
            "                # simple case, all value paths are the same",
            "                for rowelm in tree.iterfind(self.rmatch):",
            "                    if self.attr is None:",
            "                        getv = attrgetter('text')",
            "                    else:",
            "                        getv = lambda e: e.get(self.attr)",
            "                    if isinstance(vmatch, string_types):",
            "                        # match only one path",
            "                        velms = rowelm.findall(vmatch)",
            "                    else:",
            "                        # match multiple paths",
            "                        velms = itertools.chain(*[rowelm.findall(enm)",
            "                                                  for enm in vmatch])",
            "                    yield tuple(getv(velm)",
            "                                for velm in velms)",
            "",
            "            else:",
            "                # difficult case, deal with different paths for each field",
            "",
            "                # determine output header",
            "                flds = tuple(sorted(map(text_type, vdict.keys())))",
            "                yield flds",
            "",
            "                # setup value getters",
            "                vmatches = dict()",
            "                vgetters = dict()",
            "                for f in flds:",
            "                    vmatch = self.vdict[f]",
            "                    if isinstance(vmatch, string_types):",
            "                        # match element path",
            "                        vmatches[f] = vmatch",
            "                        vgetters[f] = element_text_getter(self.missing)",
            "                    else:",
            "                        # match element path and attribute name",
            "                        vmatches[f] = vmatch[0]",
            "                        attr = vmatch[1]",
            "                        vgetters[f] = attribute_text_getter(attr, self.missing)",
            "",
            "                # determine data rows",
            "                for rowelm in tree.iterfind(self.rmatch):",
            "                    yield tuple(vgetters[f](rowelm.findall(vmatches[f]))",
            "                                for f in flds)",
            "",
            "",
            "def _create_xml_parser(user_parser):",
            "    if user_parser is not None:",
            "        return user_parser",
            "    try:",
            "        # Default lxml parser.",
            "        # This will throw an error if parser is not set and lxml could not be imported",
            "        # because Python's built XML parser doesn't like the `resolve_entities` kwarg.",
            "        # return etree.XMLParser(resolve_entities=False)",
            "        return etree.XMLParser(resolve_entities=False)",
            "    except TypeError:",
            "        # lxml not available",
            "        return None",
            "",
            "",
            "def element_text_getter(missing):",
            "    def _get(v):",
            "        if len(v) > 1:",
            "            return tuple(e.text for e in v)",
            "        elif len(v) == 1:",
            "            return v[0].text",
            "        else:",
            "            return missing",
            "    return _get",
            "",
            "",
            "def attribute_text_getter(attr, missing):",
            "    def _get(v):",
            "        if len(v) > 1:",
            "            return tuple(e.get(attr) for e in v)",
            "        elif len(v) == 1:",
            "            return v[0].get(attr)",
            "        else:",
            "            return missing",
            "    return _get"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "171": [
                "XmlView",
                "__iter__"
            ],
            "172": [
                "XmlView",
                "__iter__"
            ]
        },
        "addLocation": [
            "tensorflow.python.kernel_tests.data_structures.list_ops_test.ListOpsTest.testResourceVariableScatterGatherInt64",
            "petl.io.xml.XmlView",
            "petl.io.xml.fromxml"
        ]
    }
}