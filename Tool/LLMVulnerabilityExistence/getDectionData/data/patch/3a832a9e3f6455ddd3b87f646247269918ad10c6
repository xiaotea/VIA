{
    "django_unicorn/components/unicorn_template_response.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from django.template.response import TemplateResponse"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import orjson"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from bs4 import BeautifulSoup"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from bs4.dammit import EntitySubstitution"
            },
            "8": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from bs4.element import Tag"
            },
            "9": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from bs4.formatter import HTMLFormatter"
            },
            "10": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     Prevent beautifulsoup from re-ordering attributes."
            },
            "12": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    def __init__(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+        super().__init__(entity_substitution=EntitySubstitution.substitute_html)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     def attributes(self, tag: Tag):"
            },
            "18": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         for k, v in tag.attrs.items():"
            },
            "19": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "             yield k, v"
            },
            "20": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "                     root_element.insert_after(t)"
            },
            "21": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         rendered_template = UnicornTemplateResponse._desoupify(soup)"
            },
            "23": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        rendered_template = mark_safe(rendered_template)"
            },
            "24": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         self.component.rendered(rendered_template)"
            },
            "25": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         response.content = rendered_template"
            }
        },
        "frontPatchFile": [
            "import logging",
            "",
            "from django.template.response import TemplateResponse",
            "from django.utils.safestring import mark_safe",
            "",
            "import orjson",
            "from bs4 import BeautifulSoup",
            "from bs4.element import Tag",
            "from bs4.formatter import HTMLFormatter",
            "",
            "from django_unicorn.utils import sanitize_html",
            "",
            "from ..decorators import timed",
            "from ..utils import generate_checksum",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class UnsortedAttributes(HTMLFormatter):",
            "    \"\"\"",
            "    Prevent beautifulsoup from re-ordering attributes.",
            "    \"\"\"",
            "",
            "    def attributes(self, tag: Tag):",
            "        for k, v in tag.attrs.items():",
            "            yield k, v",
            "",
            "",
            "class UnicornTemplateResponse(TemplateResponse):",
            "    def __init__(",
            "        self,",
            "        template,",
            "        request,",
            "        context=None,",
            "        content_type=None,",
            "        status=None,",
            "        charset=None,",
            "        using=None,",
            "        component=None,",
            "        init_js=False,",
            "        **kwargs,",
            "    ):",
            "        super().__init__(",
            "            template=template,",
            "            request=request,",
            "            context=context,",
            "            content_type=content_type,",
            "            status=status,",
            "            charset=charset,",
            "            using=using,",
            "        )",
            "",
            "        self.component = component",
            "        self.init_js = init_js",
            "",
            "    @timed",
            "    def render(self):",
            "        response = super().render()",
            "",
            "        if not self.component or not self.component.component_id:",
            "            return response",
            "",
            "        content = response.content.decode(\"utf-8\")",
            "",
            "        frontend_context_variables = self.component.get_frontend_context_variables()",
            "        frontend_context_variables_dict = orjson.loads(frontend_context_variables)",
            "        checksum = generate_checksum(orjson.dumps(frontend_context_variables_dict))",
            "",
            "        soup = BeautifulSoup(content, features=\"html.parser\")",
            "        root_element = get_root_element(soup)",
            "        root_element[\"unicorn:id\"] = self.component.component_id",
            "        root_element[\"unicorn:name\"] = self.component.component_name",
            "        root_element[\"unicorn:key\"] = self.component.component_key",
            "        root_element[\"unicorn:checksum\"] = checksum",
            "",
            "        # Generate the hash based on the rendered content (without script tag)",
            "        hash = generate_checksum(UnicornTemplateResponse._desoupify(soup))",
            "",
            "        if self.init_js:",
            "            init = {",
            "                \"id\": self.component.component_id,",
            "                \"name\": self.component.component_name,",
            "                \"key\": self.component.component_key,",
            "                \"data\": orjson.loads(frontend_context_variables),",
            "                \"calls\": self.component.calls,",
            "                \"hash\": hash,",
            "            }",
            "            init = orjson.dumps(init).decode(\"utf-8\")",
            "            json_element_id = f\"unicorn:data:{self.component.component_id}\"",
            "            init_script = f\"Unicorn.componentInit(JSON.parse(document.getElementById('{json_element_id}').textContent));\"",
            "",
            "            json_tag = soup.new_tag(\"script\")",
            "            json_tag[\"type\"] = \"application/json\"",
            "            json_tag[\"id\"] = json_element_id",
            "            json_tag.string = sanitize_html(init)",
            "",
            "            if self.component.parent:",
            "                self.component._init_script = init_script",
            "                self.component._json_tag = json_tag",
            "            else:",
            "                json_tags = []",
            "                json_tags.append(json_tag)",
            "",
            "                for child in self.component.children:",
            "                    init_script = f\"{init_script} {child._init_script}\"",
            "                    json_tags.append(child._json_tag)",
            "",
            "                script_tag = soup.new_tag(\"script\")",
            "                script_tag[\"type\"] = \"module\"",
            "                script_tag.string = f\"if (typeof Unicorn === 'undefined') {{ console.error('Unicorn is missing. Do you need {{% load unicorn %}} or {{% unicorn_scripts %}}?') }} else {{ {init_script} }}\"",
            "                root_element.insert_after(script_tag)",
            "",
            "                for t in json_tags:",
            "                    root_element.insert_after(t)",
            "",
            "        rendered_template = UnicornTemplateResponse._desoupify(soup)",
            "        rendered_template = mark_safe(rendered_template)",
            "        self.component.rendered(rendered_template)",
            "",
            "        response.content = rendered_template",
            "",
            "        return response",
            "",
            "    @staticmethod",
            "    def _desoupify(soup):",
            "        soup.smooth()",
            "        return soup.encode(formatter=UnsortedAttributes()).decode(\"utf-8\")",
            "",
            "",
            "def get_root_element(soup: BeautifulSoup) -> Tag:",
            "    \"\"\"",
            "    Gets the first tag element.",
            "",
            "    Returns:",
            "        BeautifulSoup tag element.",
            "",
            "        Raises an Exception if an element cannot be found.",
            "    \"\"\"",
            "    for element in soup.contents:",
            "        if isinstance(element, Tag) and element.name:",
            "            return element",
            "",
            "    raise Exception(\"No root element found\")"
        ],
        "afterPatchFile": [
            "import logging",
            "",
            "from django.template.response import TemplateResponse",
            "",
            "import orjson",
            "from bs4 import BeautifulSoup",
            "from bs4.dammit import EntitySubstitution",
            "from bs4.element import Tag",
            "from bs4.formatter import HTMLFormatter",
            "",
            "from django_unicorn.utils import sanitize_html",
            "",
            "from ..decorators import timed",
            "from ..utils import generate_checksum",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class UnsortedAttributes(HTMLFormatter):",
            "    \"\"\"",
            "    Prevent beautifulsoup from re-ordering attributes.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super().__init__(entity_substitution=EntitySubstitution.substitute_html)",
            "",
            "    def attributes(self, tag: Tag):",
            "        for k, v in tag.attrs.items():",
            "            yield k, v",
            "",
            "",
            "class UnicornTemplateResponse(TemplateResponse):",
            "    def __init__(",
            "        self,",
            "        template,",
            "        request,",
            "        context=None,",
            "        content_type=None,",
            "        status=None,",
            "        charset=None,",
            "        using=None,",
            "        component=None,",
            "        init_js=False,",
            "        **kwargs,",
            "    ):",
            "        super().__init__(",
            "            template=template,",
            "            request=request,",
            "            context=context,",
            "            content_type=content_type,",
            "            status=status,",
            "            charset=charset,",
            "            using=using,",
            "        )",
            "",
            "        self.component = component",
            "        self.init_js = init_js",
            "",
            "    @timed",
            "    def render(self):",
            "        response = super().render()",
            "",
            "        if not self.component or not self.component.component_id:",
            "            return response",
            "",
            "        content = response.content.decode(\"utf-8\")",
            "",
            "        frontend_context_variables = self.component.get_frontend_context_variables()",
            "        frontend_context_variables_dict = orjson.loads(frontend_context_variables)",
            "        checksum = generate_checksum(orjson.dumps(frontend_context_variables_dict))",
            "",
            "        soup = BeautifulSoup(content, features=\"html.parser\")",
            "        root_element = get_root_element(soup)",
            "        root_element[\"unicorn:id\"] = self.component.component_id",
            "        root_element[\"unicorn:name\"] = self.component.component_name",
            "        root_element[\"unicorn:key\"] = self.component.component_key",
            "        root_element[\"unicorn:checksum\"] = checksum",
            "",
            "        # Generate the hash based on the rendered content (without script tag)",
            "        hash = generate_checksum(UnicornTemplateResponse._desoupify(soup))",
            "",
            "        if self.init_js:",
            "            init = {",
            "                \"id\": self.component.component_id,",
            "                \"name\": self.component.component_name,",
            "                \"key\": self.component.component_key,",
            "                \"data\": orjson.loads(frontend_context_variables),",
            "                \"calls\": self.component.calls,",
            "                \"hash\": hash,",
            "            }",
            "            init = orjson.dumps(init).decode(\"utf-8\")",
            "            json_element_id = f\"unicorn:data:{self.component.component_id}\"",
            "            init_script = f\"Unicorn.componentInit(JSON.parse(document.getElementById('{json_element_id}').textContent));\"",
            "",
            "            json_tag = soup.new_tag(\"script\")",
            "            json_tag[\"type\"] = \"application/json\"",
            "            json_tag[\"id\"] = json_element_id",
            "            json_tag.string = sanitize_html(init)",
            "",
            "            if self.component.parent:",
            "                self.component._init_script = init_script",
            "                self.component._json_tag = json_tag",
            "            else:",
            "                json_tags = []",
            "                json_tags.append(json_tag)",
            "",
            "                for child in self.component.children:",
            "                    init_script = f\"{init_script} {child._init_script}\"",
            "                    json_tags.append(child._json_tag)",
            "",
            "                script_tag = soup.new_tag(\"script\")",
            "                script_tag[\"type\"] = \"module\"",
            "                script_tag.string = f\"if (typeof Unicorn === 'undefined') {{ console.error('Unicorn is missing. Do you need {{% load unicorn %}} or {{% unicorn_scripts %}}?') }} else {{ {init_script} }}\"",
            "                root_element.insert_after(script_tag)",
            "",
            "                for t in json_tags:",
            "                    root_element.insert_after(t)",
            "",
            "        rendered_template = UnicornTemplateResponse._desoupify(soup)",
            "        self.component.rendered(rendered_template)",
            "",
            "        response.content = rendered_template",
            "",
            "        return response",
            "",
            "    @staticmethod",
            "    def _desoupify(soup):",
            "        soup.smooth()",
            "        return soup.encode(formatter=UnsortedAttributes()).decode(\"utf-8\")",
            "",
            "",
            "def get_root_element(soup: BeautifulSoup) -> Tag:",
            "    \"\"\"",
            "    Gets the first tag element.",
            "",
            "    Returns:",
            "        BeautifulSoup tag element.",
            "",
            "        Raises an Exception if an element cannot be found.",
            "    \"\"\"",
            "    for element in soup.contents:",
            "        if isinstance(element, Tag) and element.name:",
            "            return element",
            "",
            "    raise Exception(\"No root element found\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": [],
            "118": [
                "UnicornTemplateResponse",
                "render"
            ]
        },
        "addLocation": []
    },
    "django_unicorn/components/unicorn_view.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.core.exceptions import ImproperlyConfigured"
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from django.db.models import Model"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from django.http import HttpRequest"
            },
            "3": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import conditional_escape"
            },
            "4": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from django.views.generic.base import TemplateView"
            },
            "5": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from cachetools.lru import LRUCache"
            },
            "7": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "                     if field_name in frontend_context_variables:"
            },
            "8": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "                         del frontend_context_variables[field_name]"
            },
            "9": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 342,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        safe_fields = []"
            },
            "11": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Keep a list of fields that are safe to not sanitize from `frontend_context_variables`"
            },
            "12": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"safe\"):"
            },
            "13": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if isinstance(self.Meta.safe, Sequence):"
            },
            "14": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                for field_name in self.Meta.safe:"
            },
            "15": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if field_name in frontend_context_variables:"
            },
            "16": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        safe_fields.append(field_name)"
            },
            "17": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "18": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "         # Add cleaned values to `frontend_content_variables` based on the widget in form's fields"
            },
            "19": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "         form = self._get_form(attributes)"
            },
            "20": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 345,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "                         ):"
            },
            "22": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "                             frontend_context_variables[key] = value"
            },
            "23": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 365,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for ("
            },
            "25": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            frontend_context_variable_key,"
            },
            "26": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            frontend_context_variable_value,"
            },
            "27": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ) in frontend_context_variables.items():"
            },
            "28": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if ("
            },
            "29": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                isinstance(frontend_context_variable_value, str)"
            },
            "30": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and frontend_context_variable_key not in safe_fields"
            },
            "31": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ):"
            },
            "32": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                frontend_context_variables[frontend_context_variable_key] = escape("
            },
            "33": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    frontend_context_variable_value"
            },
            "34": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "35": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "36": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "         encoded_frontend_context_variables = serializer.dumps("
            },
            "37": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "             frontend_context_variables"
            },
            "38": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "         )"
            }
        },
        "frontPatchFile": [
            "import importlib",
            "import inspect",
            "import logging",
            "import pickle",
            "import sys",
            "from typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union",
            "",
            "from django.conf import settings",
            "from django.core.cache import caches",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.db.models import Model",
            "from django.http import HttpRequest",
            "from django.utils.html import conditional_escape",
            "from django.views.generic.base import TemplateView",
            "",
            "from cachetools.lru import LRUCache",
            "",
            "from django_unicorn.settings import get_cache_alias",
            "",
            "from .. import serializer",
            "from ..decorators import timed",
            "from ..errors import ComponentLoadError, UnicornCacheError",
            "from ..settings import get_setting",
            "from ..utils import get_cacheable_component",
            "from .fields import UnicornField",
            "from .unicorn_template_response import UnicornTemplateResponse",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "# TODO: Make maxsize configurable",
            "location_cache = LRUCache(maxsize=100)",
            "",
            "# Module cache to store the found component class by id",
            "views_cache = LRUCache(maxsize=100)",
            "",
            "# Module cache for constructed component classes",
            "# This can create a subtle race condition so a more long-term solution needs to be found",
            "constructed_views_cache = LRUCache(maxsize=100)",
            "COMPONENTS_MODULE_CACHE_ENABLED = \"pytest\" not in sys.modules",
            "",
            "",
            "def convert_to_snake_case(s: str) -> str:",
            "    # TODO: Better handling of dash->snake",
            "    return s.replace(\"-\", \"_\")",
            "",
            "",
            "def convert_to_pascal_case(s: str) -> str:",
            "    # TODO: Better handling of dash/snake->pascal-case",
            "    s = convert_to_snake_case(s)",
            "    return \"\".join(word.title() for word in s.split(\"_\"))",
            "",
            "",
            "def get_locations(component_name):",
            "    locations = []",
            "",
            "    if \".\" in component_name:",
            "        # Handle component names that specify a folder structure",
            "        component_name = component_name.replace(\"/\", \".\")",
            "",
            "        # Handle fully-qualified component names (e.g. `project.unicorn.HelloWorldView`)",
            "        class_name = component_name.split(\".\")[-1:][0]",
            "        module_name = component_name.replace(\".\" + class_name, \"\")",
            "        locations.append((class_name, module_name))",
            "",
            "        # Assume if it ends with \"View\", then we don't need to add other",
            "        if component_name.endswith(\"View\") or component_name.endswith(\"Component\"):",
            "            return locations",
            "",
            "    # Handle component names that specify a folder structure",
            "    component_name = component_name.replace(\"/\", \".\")",
            "",
            "    # Use conventions to find the component class",
            "    class_name = convert_to_pascal_case(component_name)",
            "",
            "    if \".\" in class_name:",
            "        if class_name.split(\".\")[-1:]:",
            "            class_name = class_name.split(\".\")[-1:][0]",
            "",
            "    class_name = f\"{class_name}View\"",
            "    module_name = convert_to_snake_case(component_name)",
            "",
            "    unicorn_apps = get_setting(\"APPS\", settings.INSTALLED_APPS)",
            "",
            "    assert (",
            "        isinstance(unicorn_apps, list)",
            "        or isinstance(unicorn_apps, tuple)",
            "        or isinstance(unicorn_apps, set)",
            "    ), \"APPS is expected to be a list, tuple or set\"",
            "",
            "    for app in unicorn_apps:",
            "        # Handle an installed app that actually points to an app config",
            "        if \".apps.\" in app:",
            "            app_config_idx = app.rindex(\".apps.\")",
            "            app = app[:app_config_idx]",
            "",
            "        app_module_name = f\"{app}.components.{module_name}\"",
            "        locations.append((class_name, app_module_name))",
            "",
            "    return locations",
            "",
            "",
            "@timed",
            "def construct_component(",
            "    component_class,",
            "    component_id,",
            "    component_name,",
            "    component_key,",
            "    parent,",
            "    request,",
            "    **kwargs,",
            "):",
            "    \"\"\"",
            "    Constructs a class instance.",
            "    \"\"\"",
            "    component = component_class(",
            "        component_id=component_id,",
            "        component_name=component_name,",
            "        component_key=component_key,",
            "        parent=parent,",
            "        request=request,",
            "        **kwargs,",
            "    )",
            "",
            "    component.calls = []",
            "    component.children = []",
            "    component._children_set = False",
            "",
            "    component.mount()",
            "    component.hydrate()",
            "    component.complete()",
            "    component._validate_called = False",
            "",
            "    return component",
            "",
            "",
            "class UnicornView(TemplateView):",
            "    response_class = UnicornTemplateResponse",
            "    component_name: str = \"\"",
            "    component_key: str = \"\"",
            "    request = None",
            "    parent = None",
            "    children = []",
            "",
            "    # Caches to reduce the amount of time introspecting the class",
            "    _methods_cache: Dict[str, Callable] = {}",
            "    _attribute_names_cache: List[str] = []",
            "    _hook_methods_cache: List[str] = []",
            "",
            "    # Dictionary with key: attribute name; value: pickled attribute value",
            "    _resettable_attributes_cache: Dict[str, Any] = {}",
            "",
            "    # JavaScript method calls",
            "    calls = []",
            "",
            "    def __init__(self, **kwargs):",
            "        super().__init__(**kwargs)",
            "",
            "        assert self.component_name, \"Component name is required\"",
            "",
            "        if \"id\" in kwargs and kwargs[\"id\"]:",
            "            # Sometimes the component_id is initially in kwargs[\"id\"]",
            "            self.component_id = kwargs[\"id\"]",
            "",
            "        assert hasattr(self, \"component_id\"), \"Component id is required\"",
            "        assert self.component_id, \"Component id is required\"",
            "        self.component_cache_key = f\"unicorn:component:{self.component_id}\"",
            "",
            "        if \"request\" in kwargs:",
            "            self.setup(kwargs[\"request\"])",
            "",
            "        if \"parent\" in kwargs:",
            "            self.parent = kwargs[\"parent\"]",
            "",
            "        self._init_script: str = \"\"",
            "        self._children_set = False",
            "        self._validate_called = False",
            "        self.errors = {}",
            "        self._set_default_template_name()",
            "        self._set_caches()",
            "",
            "    @timed",
            "    def _set_default_template_name(self) -> None:",
            "        \"\"\"",
            "        Sets a default template name based on component's name if necessary.",
            "        \"\"\"",
            "        get_template_names_is_valid = False",
            "",
            "        try:",
            "            # Check for get_template_names by explicitly calling it since it",
            "            # is defined in TemplateResponseMixin, but can throw ImproperlyConfigured.",
            "            self.get_template_names()",
            "            get_template_names_is_valid = True",
            "        except ImproperlyConfigured:",
            "            pass",
            "",
            "        if not self.template_name and not get_template_names_is_valid:",
            "            # Convert component name with a dot to a folder structure",
            "            template_name = self.component_name.replace(\".\", \"/\")",
            "            self.template_name = f\"unicorn/{template_name}.html\"",
            "",
            "    @timed",
            "    def _set_caches(self) -> None:",
            "        \"\"\"",
            "        Setup some initial \"caches\" to prevent Python from having to introspect",
            "        a component UnicornView for methods and properties multiple times.",
            "        \"\"\"",
            "        self._attribute_names_cache = self._attribute_names()",
            "        self._set_hook_methods_cache()",
            "        self._methods_cache = self._methods()",
            "        self._set_resettable_attributes_cache()",
            "",
            "    @timed",
            "    def reset(self):",
            "        for (",
            "            attribute_name,",
            "            pickled_value,",
            "        ) in self._resettable_attributes_cache.items():",
            "            try:",
            "                attribute_value = pickle.loads(pickled_value)",
            "                self._set_property(attribute_name, attribute_value)",
            "            except TypeError:",
            "                logger.warn(",
            "                    f\"Resetting '{attribute_name}' attribute failed because it could not be constructed.\"",
            "                )",
            "                pass",
            "            except pickle.PickleError:",
            "                logger.warn(",
            "                    f\"Resetting '{attribute_name}' attribute failed because it could not be de-pickled.\"",
            "                )",
            "                pass",
            "",
            "    def call(self, function_name, *args):",
            "        \"\"\"",
            "        Add a JavaScript method name and arguments to be called after the component is rendered.",
            "        \"\"\"",
            "        self.calls.append({\"fn\": function_name, \"args\": args})",
            "",
            "    def mount(self):",
            "        \"\"\"",
            "        Hook that gets called when the component is first created.",
            "        \"\"\"",
            "        pass",
            "",
            "    def hydrate(self):",
            "        \"\"\"",
            "        Hook that gets called when the component's data is hydrated.",
            "        \"\"\"",
            "        pass",
            "",
            "    def complete(self):",
            "        \"\"\"",
            "        Hook that gets called after all component methods are executed.",
            "        \"\"\"",
            "        pass",
            "",
            "    def rendered(self, html):",
            "        \"\"\"",
            "        Hook that gets called after the component has been rendered.",
            "        \"\"\"",
            "        pass",
            "",
            "    def parent_rendered(self, html):",
            "        \"\"\"",
            "        Hook that gets called after the component's parent has been rendered.",
            "        \"\"\"",
            "        pass",
            "",
            "    def updating(self, name, value):",
            "        \"\"\"",
            "        Hook that gets called when a component's data is about to get updated.",
            "        \"\"\"",
            "        pass",
            "",
            "    def updated(self, name, value):",
            "        \"\"\"",
            "        Hook that gets called when a component's data is updated.",
            "        \"\"\"",
            "        pass",
            "",
            "    def calling(self, name, args):",
            "        \"\"\"",
            "        Hook that gets called when a component's method is about to get called.",
            "        \"\"\"",
            "        pass",
            "",
            "    def called(self, name, args):",
            "        \"\"\"",
            "        Hook that gets called when a component's method is called.",
            "        \"\"\"",
            "        pass",
            "",
            "    @timed",
            "    def render(self, init_js=False) -> str:",
            "        \"\"\"",
            "        Renders a UnicornView component with the public properties available. Delegates to a",
            "        UnicornTemplateResponse to actually render a response.",
            " ",
            "        Args:",
            "            param init_js: Whether or not to include the Javascript required to initialize the component.",
            "        \"\"\"",
            "",
            "        response = self.render_to_response(",
            "            context=self.get_context_data(), component=self, init_js=init_js,",
            "        )",
            "",
            "        # render_to_response() could only return a HttpResponse, so check for render()",
            "        if hasattr(response, \"render\"):",
            "            response.render()",
            "",
            "        rendered_component = response.content.decode(\"utf-8\")",
            "",
            "        # Set the current component as a child of the parent if there is a parent",
            "        # If no parent, mark that the component has its children set.",
            "        # This works because the nested (internal) components get rendered first before the parent,",
            "        # so once we hit a component without a parent we know all of the children have been rendered correctly",
            "        # TODO: This might fall apart with a third layer of nesting components",
            "        if self.parent:",
            "            if not self.parent._children_set:",
            "                self.parent.children.append(self)",
            "        else:",
            "            self._children_set = True",
            "",
            "        return rendered_component",
            "",
            "    @timed",
            "    def get_frontend_context_variables(self) -> str:",
            "        \"\"\"",
            "        Get publicly available properties and output them in a string-encoded JSON object.",
            "        \"\"\"",
            "",
            "        frontend_context_variables = {}",
            "        attributes = self._attributes()",
            "        frontend_context_variables.update(attributes)",
            "",
            "        # Remove any field in `javascript_exclude` from `frontend_context_variables`",
            "        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"javascript_exclude\"):",
            "            if isinstance(self.Meta.javascript_exclude, Sequence):",
            "                for field_name in self.Meta.javascript_exclude:",
            "                    if field_name in frontend_context_variables:",
            "                        del frontend_context_variables[field_name]",
            "",
            "        safe_fields = []",
            "        # Keep a list of fields that are safe to not sanitize from `frontend_context_variables`",
            "        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"safe\"):",
            "            if isinstance(self.Meta.safe, Sequence):",
            "                for field_name in self.Meta.safe:",
            "                    if field_name in frontend_context_variables:",
            "                        safe_fields.append(field_name)",
            "",
            "        # Add cleaned values to `frontend_content_variables` based on the widget in form's fields",
            "        form = self._get_form(attributes)",
            "",
            "        if form:",
            "            form.is_valid()",
            "",
            "            for key in attributes.keys():",
            "                if key in form.fields:",
            "                    field = form.fields[key]",
            "",
            "                    if key in form.cleaned_data:",
            "                        cleaned_value = form.cleaned_data[key]",
            "                        value = field.widget.format_value(cleaned_value)",
            "",
            "                        # Don't update the frontend variable if the only change is",
            "                        # stripping off the whitespace from the field value",
            "                        # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip",
            "                        if (",
            "                            not hasattr(frontend_context_variables[key], \"strip\")",
            "                            or frontend_context_variables[key].strip() != value",
            "                        ):",
            "                            frontend_context_variables[key] = value",
            "",
            "        for (",
            "            frontend_context_variable_key,",
            "            frontend_context_variable_value,",
            "        ) in frontend_context_variables.items():",
            "            if (",
            "                isinstance(frontend_context_variable_value, str)",
            "                and frontend_context_variable_key not in safe_fields",
            "            ):",
            "                frontend_context_variables[frontend_context_variable_key] = escape(",
            "                    frontend_context_variable_value",
            "                )",
            "",
            "        encoded_frontend_context_variables = serializer.dumps(",
            "            frontend_context_variables",
            "        )",
            "",
            "        return encoded_frontend_context_variables",
            "",
            "    @timed",
            "    def _get_form(self, data):",
            "        if hasattr(self, \"form_class\"):",
            "            try:",
            "                form = self.form_class(data)",
            "                form.is_valid()",
            "",
            "                return form",
            "            except Exception as e:",
            "                logger.exception(e)",
            "",
            "    @timed",
            "    def get_context_data(self, **kwargs):",
            "        \"\"\"",
            "        Overrides the standard `get_context_data` to add in publicly available",
            "        properties and methods.",
            "        \"\"\"",
            "",
            "        context = super().get_context_data(**kwargs)",
            "",
            "        attributes = self._attributes()",
            "        context.update(attributes)",
            "        context.update(self._methods())",
            "        context.update({\"unicorn\": {\"errors\": self.errors}})",
            "",
            "        return context",
            "",
            "    @timed",
            "    def is_valid(self, model_names: List = None) -> bool:",
            "        return len(self.validate(model_names).keys()) == 0",
            "",
            "    @timed",
            "    def validate(self, model_names: List = None) -> Dict:",
            "        \"\"\"",
            "        Validates the data using the `form_class` set on the component.",
            "",
            "        Args:",
            "            model_names: Only include validation errors for specified fields. If none, validate everything.",
            "        \"\"\"",
            "        # TODO: Handle form.non_field_errors()?",
            "",
            "        if self._validate_called:",
            "            return self.errors",
            "",
            "        self._validate_called = True",
            "",
            "        data = self._attributes()",
            "        form = self._get_form(data)",
            "",
            "        if form:",
            "            form_errors = form.errors.get_json_data(escape_html=True)",
            "",
            "            # This code is confusing, but handles this use-case:",
            "            # the component has two models, one that starts with an error and one",
            "            # that is valid. Validating the valid one should not show an error for",
            "            # the invalid one. Only after the invalid field is updated, should the",
            "            # error show up and persist, even after updating the valid form.",
            "            if self.errors:",
            "                keys_to_remove = []",
            "",
            "                for key, value in self.errors.items():",
            "                    if key in form_errors:",
            "                        self.errors[key] = value",
            "                    else:",
            "                        keys_to_remove.append(key)",
            "",
            "                for key in keys_to_remove:",
            "                    self.errors.pop(key)",
            "",
            "            if model_names is not None:",
            "                for key, value in form_errors.items():",
            "                    if key in model_names:",
            "                        self.errors[key] = value",
            "            else:",
            "                self.errors.update(form_errors)",
            "",
            "        return self.errors",
            "",
            "    @timed",
            "    def _attribute_names(self) -> List[str]:",
            "        \"\"\"",
            "        Gets publicly available attribute names. Cached in `_attribute_names_cache`.",
            "        \"\"\"",
            "        non_callables = [",
            "            member[0] for member in inspect.getmembers(self, lambda x: not callable(x))",
            "        ]",
            "        attribute_names = [name for name in non_callables if self._is_public(name)]",
            "",
            "        return attribute_names",
            "",
            "    @timed",
            "    def _attributes(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Get publicly available attributes and their values from the component.",
            "        \"\"\"",
            "",
            "        attribute_names = self._attribute_names_cache",
            "        attributes = {}",
            "",
            "        for attribute_name in attribute_names:",
            "            attributes[attribute_name] = getattr(self, attribute_name)",
            "",
            "        return attributes",
            "",
            "    @timed",
            "    def _set_property(self, name, value):",
            "        # Get the correct value type by using the form if it is available",
            "        data = self._attributes()",
            "        data[name] = value",
            "        form = self._get_form(data)",
            "",
            "        if form and name in form.fields and name in form.cleaned_data:",
            "            # The Django form CharField validator will remove whitespace",
            "            # from the field value. Ignore that update if it's the",
            "            # only thing different from the validator",
            "            # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip",
            "            if not hasattr(value, \"strip\") or form.cleaned_data[name] != value.strip():",
            "                value = form.cleaned_data[name]",
            "",
            "        updating_function_name = f\"updating_{name}\"",
            "        if hasattr(self, updating_function_name):",
            "            getattr(self, updating_function_name)(value)",
            "",
            "        try:",
            "            setattr(self, name, value)",
            "",
            "            updated_function_name = f\"updated_{name}\"",
            "",
            "            if hasattr(self, updated_function_name):",
            "                getattr(self, updated_function_name)(value)",
            "        except AttributeError as e:",
            "            raise",
            "",
            "    @timed",
            "    def _methods(self) -> Dict[str, Callable]:",
            "        \"\"\"",
            "        Get publicly available method names and their functions from the component.",
            "        Cached in `_methods_cache`.",
            "        \"\"\"",
            "",
            "        if self._methods_cache:",
            "            return self._methods_cache",
            "",
            "        member_methods = inspect.getmembers(self, inspect.ismethod)",
            "        public_methods = [",
            "            method for method in member_methods if self._is_public(method[0])",
            "        ]",
            "        methods = {k: v for (k, v) in public_methods}",
            "        self._methods_cache = methods",
            "",
            "        return methods",
            "",
            "    @timed",
            "    def _set_hook_methods_cache(self) -> None:",
            "        \"\"\"",
            "        Caches the updating/updated attribute function names defined on the component.",
            "        \"\"\"",
            "        self._hook_methods_cache = []",
            "",
            "        for attribute_name in self._attribute_names_cache:",
            "            updating_function_name = f\"updating_{attribute_name}\"",
            "            updated_function_name = f\"updated_{attribute_name}\"",
            "            hook_function_names = [updating_function_name, updated_function_name]",
            "",
            "            for function_name in hook_function_names:",
            "                if hasattr(self, function_name):",
            "                    self._hook_methods_cache.append(function_name)",
            "",
            "    @timed",
            "    def _set_resettable_attributes_cache(self) -> None:",
            "        \"\"\"",
            "        Caches the attributes that are \"resettable\" in `_resettable_attributes_cache`.",
            "        Cache is a dictionary with key: attribute name; value: pickled attribute value",
            "",
            "        Examples:",
            "            - `UnicornField`",
            "            - Django Models without a defined pk",
            "        \"\"\"",
            "        self._resettable_attributes_cache = {}",
            "",
            "        for attribute_name, attribute_value in self._attributes().items():",
            "            if isinstance(attribute_value, UnicornField):",
            "                self._resettable_attributes_cache[attribute_name] = pickle.dumps(",
            "                    attribute_value",
            "                )",
            "            elif isinstance(attribute_value, Model):",
            "                if not attribute_value.pk:",
            "                    if attribute_name not in self._resettable_attributes_cache:",
            "                        try:",
            "                            self._resettable_attributes_cache[",
            "                                attribute_name",
            "                            ] = pickle.dumps(attribute_value)",
            "                        except pickle.PickleError:",
            "                            logger.warn(",
            "                                f\"Caching '{attribute_name}' failed because it could not be pickled.\"",
            "                            )",
            "                            pass",
            "",
            "    def _is_public(self, name: str) -> bool:",
            "        \"\"\"",
            "        Determines if the name should be sent in the context.",
            "        \"\"\"",
            "",
            "        # Ignore some standard attributes from TemplateView",
            "        protected_names = (",
            "            \"render\",",
            "            \"request\",",
            "            \"args\",",
            "            \"kwargs\",",
            "            \"content_type\",",
            "            \"extra_context\",",
            "            \"http_method_names\",",
            "            \"template_engine\",",
            "            \"template_name\",",
            "            \"dispatch\",",
            "            \"id\",",
            "            \"get\",",
            "            \"get_context_data\",",
            "            \"get_template_names\",",
            "            \"render_to_response\",",
            "            \"http_method_not_allowed\",",
            "            \"options\",",
            "            \"setup\",",
            "            \"fill\",",
            "            # Component methods",
            "            \"component_id\",",
            "            \"component_name\",",
            "            \"component_key\",",
            "            \"reset\",",
            "            \"mount\",",
            "            \"hydrate\",",
            "            \"updating\",",
            "            \"update\",",
            "            \"calling\",",
            "            \"called\",",
            "            \"complete\",",
            "            \"rendered\",",
            "            \"parent_rendered\",",
            "            \"validate\",",
            "            \"is_valid\",",
            "            \"get_frontend_context_variables\",",
            "            \"errors\",",
            "            \"updated\",",
            "            \"parent\",",
            "            \"children\",",
            "            \"call\",",
            "            \"calls\",",
            "            \"component_cache_key\",",
            "        )",
            "        excludes = []",
            "",
            "        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"exclude\"):",
            "            if isinstance(self.Meta.exclude, Sequence):",
            "                excludes = self.Meta.exclude",
            "",
            "        return not (",
            "            name.startswith(\"_\")",
            "            or name in protected_names",
            "            or name in self._hook_methods_cache",
            "            or name in excludes",
            "        )",
            "",
            "    @staticmethod",
            "    @timed",
            "    def create(",
            "        component_id: str,",
            "        component_name: str,",
            "        component_key: str = \"\",",
            "        parent: \"UnicornView\" = None,",
            "        request: HttpRequest = None,",
            "        use_cache=True,",
            "        kwargs: Dict[str, Any] = {},",
            "    ) -> \"UnicornView\":",
            "        \"\"\"",
            "        Find and instantiate a component class based on `component_name`.",
            "",
            "        Args:",
            "            param component_id: Id of the component. Required.",
            "            param component_name: Name of the component. Used to locate the correct `UnicornView`",
            "                component class and template if necessary. Required.",
            "            param component_key: Key of the component to allow multiple components of the same name",
            "                to be differentiated. Optional.",
            "            param parent: The parent component of the current component.",
            "            param kwargs: Keyword arguments for the component passed in from the template. Defaults to `{}`.",
            "        ",
            "        Returns:",
            "            Instantiated `UnicornView` component.",
            "            Raises `ComponentLoadError` if the component could not be loaded.",
            "        \"\"\"",
            "        assert component_id, \"Component id is required\"",
            "        assert component_name, \"Component name is required\"",
            "",
            "        @timed",
            "        def _get_component_class(",
            "            module_name: str, class_name: str",
            "        ) -> Type[UnicornView]:",
            "            \"\"\"",
            "            Imports a component based on module and class name.",
            "            \"\"\"",
            "            module = importlib.import_module(module_name)",
            "            component_class = getattr(module, class_name)",
            "",
            "            return component_class",
            "",
            "        cache = caches[get_cache_alias()]",
            "        component_cache_key = f\"unicorn:component:{component_id}\"",
            "        cached_component = cache.get(component_cache_key)",
            "",
            "        if cached_component:",
            "            # Get the newest version of the parent from cache if it is available",
            "            # This needs to happen for Django cache because instances is pickled, so",
            "            # a change in the view won't be reflected automatically (like with the module",
            "            # cache) so it needs to be retrieved manually.",
            "            if cached_component.parent:",
            "                cached_parent_component = cache.get(",
            "                    cached_component.parent.component_cache_key",
            "                )",
            "",
            "                if cached_parent_component:",
            "                    cached_component.parent = cached_parent_component",
            "                    cached_component.parent.setup(request)",
            "        else:",
            "            cached_component = constructed_views_cache.get(component_id)",
            "",
            "        if use_cache and cached_component:",
            "            # Note that `hydrate()` and `complete` don't need to be called here",
            "            # because this path only happens for re-rendering from the view",
            "            cached_component.setup(request)",
            "            cached_component._validate_called = False",
            "            cached_component.calls = []",
            "            logger.debug(f\"Retrieve {component_id} from constructed views cache\")",
            "",
            "            return cached_component",
            "",
            "        if component_id in views_cache:",
            "            (component_class, parent, kwargs) = views_cache[component_id]",
            "",
            "            component = construct_component(",
            "                component_class=component_class,",
            "                component_id=component_id,",
            "                component_name=component_name,",
            "                component_key=component_key,",
            "                parent=parent,",
            "                request=request,",
            "                **kwargs,",
            "            )",
            "            logger.debug(f\"Retrieve {component_id} from views cache\")",
            "",
            "            return component",
            "",
            "        locations = []",
            "",
            "        if component_name in location_cache:",
            "            locations.append(location_cache[component_name])",
            "        else:",
            "            locations = get_locations(component_name)",
            "",
            "        # Store the last exception that got raised while looking for a component in case it is useful context",
            "        last_exception: Union[",
            "            Optional[ModuleNotFoundError], Optional[AttributeError]",
            "        ] = None",
            "",
            "        for (class_name, module_name) in locations:",
            "            try:",
            "                component_class = _get_component_class(module_name, class_name)",
            "                component = construct_component(",
            "                    component_class=component_class,",
            "                    component_id=component_id,",
            "                    component_name=component_name,",
            "                    component_key=component_key,",
            "                    parent=parent,",
            "                    request=request,",
            "                    **kwargs,",
            "                )",
            "",
            "                # Put the location for the component name in a module cache",
            "                location_cache[component_name] = (class_name, module_name)",
            "",
            "                # Put the component's class in a module cache",
            "                views_cache[component_id] = (component_class, parent, kwargs)",
            "",
            "                # Put the instantiated component into a module cache and the Django cache",
            "                cacheable_component = None",
            "",
            "                try:",
            "                    cacheable_component = get_cacheable_component(component)",
            "                except UnicornCacheError as e:",
            "                    logger.warning(e)",
            "",
            "                if cacheable_component:",
            "                    if COMPONENTS_MODULE_CACHE_ENABLED:",
            "                        constructed_views_cache[component_id] = cacheable_component",
            "",
            "                    cache.set(",
            "                        cacheable_component.component_cache_key, cacheable_component",
            "                    )",
            "",
            "                return component",
            "            except ModuleNotFoundError as e:",
            "                last_exception = e",
            "            except AttributeError as e:",
            "                last_exception = e",
            "",
            "        raise ComponentLoadError(",
            "            f\"'{component_name}' component could not be loaded: {last_exception}\"",
            "        ) from last_exception"
        ],
        "afterPatchFile": [
            "import importlib",
            "import inspect",
            "import logging",
            "import pickle",
            "import sys",
            "from typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union",
            "",
            "from django.conf import settings",
            "from django.core.cache import caches",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.db.models import Model",
            "from django.http import HttpRequest",
            "from django.views.generic.base import TemplateView",
            "",
            "from cachetools.lru import LRUCache",
            "",
            "from django_unicorn.settings import get_cache_alias",
            "",
            "from .. import serializer",
            "from ..decorators import timed",
            "from ..errors import ComponentLoadError, UnicornCacheError",
            "from ..settings import get_setting",
            "from ..utils import get_cacheable_component",
            "from .fields import UnicornField",
            "from .unicorn_template_response import UnicornTemplateResponse",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "# TODO: Make maxsize configurable",
            "location_cache = LRUCache(maxsize=100)",
            "",
            "# Module cache to store the found component class by id",
            "views_cache = LRUCache(maxsize=100)",
            "",
            "# Module cache for constructed component classes",
            "# This can create a subtle race condition so a more long-term solution needs to be found",
            "constructed_views_cache = LRUCache(maxsize=100)",
            "COMPONENTS_MODULE_CACHE_ENABLED = \"pytest\" not in sys.modules",
            "",
            "",
            "def convert_to_snake_case(s: str) -> str:",
            "    # TODO: Better handling of dash->snake",
            "    return s.replace(\"-\", \"_\")",
            "",
            "",
            "def convert_to_pascal_case(s: str) -> str:",
            "    # TODO: Better handling of dash/snake->pascal-case",
            "    s = convert_to_snake_case(s)",
            "    return \"\".join(word.title() for word in s.split(\"_\"))",
            "",
            "",
            "def get_locations(component_name):",
            "    locations = []",
            "",
            "    if \".\" in component_name:",
            "        # Handle component names that specify a folder structure",
            "        component_name = component_name.replace(\"/\", \".\")",
            "",
            "        # Handle fully-qualified component names (e.g. `project.unicorn.HelloWorldView`)",
            "        class_name = component_name.split(\".\")[-1:][0]",
            "        module_name = component_name.replace(\".\" + class_name, \"\")",
            "        locations.append((class_name, module_name))",
            "",
            "        # Assume if it ends with \"View\", then we don't need to add other",
            "        if component_name.endswith(\"View\") or component_name.endswith(\"Component\"):",
            "            return locations",
            "",
            "    # Handle component names that specify a folder structure",
            "    component_name = component_name.replace(\"/\", \".\")",
            "",
            "    # Use conventions to find the component class",
            "    class_name = convert_to_pascal_case(component_name)",
            "",
            "    if \".\" in class_name:",
            "        if class_name.split(\".\")[-1:]:",
            "            class_name = class_name.split(\".\")[-1:][0]",
            "",
            "    class_name = f\"{class_name}View\"",
            "    module_name = convert_to_snake_case(component_name)",
            "",
            "    unicorn_apps = get_setting(\"APPS\", settings.INSTALLED_APPS)",
            "",
            "    assert (",
            "        isinstance(unicorn_apps, list)",
            "        or isinstance(unicorn_apps, tuple)",
            "        or isinstance(unicorn_apps, set)",
            "    ), \"APPS is expected to be a list, tuple or set\"",
            "",
            "    for app in unicorn_apps:",
            "        # Handle an installed app that actually points to an app config",
            "        if \".apps.\" in app:",
            "            app_config_idx = app.rindex(\".apps.\")",
            "            app = app[:app_config_idx]",
            "",
            "        app_module_name = f\"{app}.components.{module_name}\"",
            "        locations.append((class_name, app_module_name))",
            "",
            "    return locations",
            "",
            "",
            "@timed",
            "def construct_component(",
            "    component_class,",
            "    component_id,",
            "    component_name,",
            "    component_key,",
            "    parent,",
            "    request,",
            "    **kwargs,",
            "):",
            "    \"\"\"",
            "    Constructs a class instance.",
            "    \"\"\"",
            "    component = component_class(",
            "        component_id=component_id,",
            "        component_name=component_name,",
            "        component_key=component_key,",
            "        parent=parent,",
            "        request=request,",
            "        **kwargs,",
            "    )",
            "",
            "    component.calls = []",
            "    component.children = []",
            "    component._children_set = False",
            "",
            "    component.mount()",
            "    component.hydrate()",
            "    component.complete()",
            "    component._validate_called = False",
            "",
            "    return component",
            "",
            "",
            "class UnicornView(TemplateView):",
            "    response_class = UnicornTemplateResponse",
            "    component_name: str = \"\"",
            "    component_key: str = \"\"",
            "    request = None",
            "    parent = None",
            "    children = []",
            "",
            "    # Caches to reduce the amount of time introspecting the class",
            "    _methods_cache: Dict[str, Callable] = {}",
            "    _attribute_names_cache: List[str] = []",
            "    _hook_methods_cache: List[str] = []",
            "",
            "    # Dictionary with key: attribute name; value: pickled attribute value",
            "    _resettable_attributes_cache: Dict[str, Any] = {}",
            "",
            "    # JavaScript method calls",
            "    calls = []",
            "",
            "    def __init__(self, **kwargs):",
            "        super().__init__(**kwargs)",
            "",
            "        assert self.component_name, \"Component name is required\"",
            "",
            "        if \"id\" in kwargs and kwargs[\"id\"]:",
            "            # Sometimes the component_id is initially in kwargs[\"id\"]",
            "            self.component_id = kwargs[\"id\"]",
            "",
            "        assert hasattr(self, \"component_id\"), \"Component id is required\"",
            "        assert self.component_id, \"Component id is required\"",
            "        self.component_cache_key = f\"unicorn:component:{self.component_id}\"",
            "",
            "        if \"request\" in kwargs:",
            "            self.setup(kwargs[\"request\"])",
            "",
            "        if \"parent\" in kwargs:",
            "            self.parent = kwargs[\"parent\"]",
            "",
            "        self._init_script: str = \"\"",
            "        self._children_set = False",
            "        self._validate_called = False",
            "        self.errors = {}",
            "        self._set_default_template_name()",
            "        self._set_caches()",
            "",
            "    @timed",
            "    def _set_default_template_name(self) -> None:",
            "        \"\"\"",
            "        Sets a default template name based on component's name if necessary.",
            "        \"\"\"",
            "        get_template_names_is_valid = False",
            "",
            "        try:",
            "            # Check for get_template_names by explicitly calling it since it",
            "            # is defined in TemplateResponseMixin, but can throw ImproperlyConfigured.",
            "            self.get_template_names()",
            "            get_template_names_is_valid = True",
            "        except ImproperlyConfigured:",
            "            pass",
            "",
            "        if not self.template_name and not get_template_names_is_valid:",
            "            # Convert component name with a dot to a folder structure",
            "            template_name = self.component_name.replace(\".\", \"/\")",
            "            self.template_name = f\"unicorn/{template_name}.html\"",
            "",
            "    @timed",
            "    def _set_caches(self) -> None:",
            "        \"\"\"",
            "        Setup some initial \"caches\" to prevent Python from having to introspect",
            "        a component UnicornView for methods and properties multiple times.",
            "        \"\"\"",
            "        self._attribute_names_cache = self._attribute_names()",
            "        self._set_hook_methods_cache()",
            "        self._methods_cache = self._methods()",
            "        self._set_resettable_attributes_cache()",
            "",
            "    @timed",
            "    def reset(self):",
            "        for (",
            "            attribute_name,",
            "            pickled_value,",
            "        ) in self._resettable_attributes_cache.items():",
            "            try:",
            "                attribute_value = pickle.loads(pickled_value)",
            "                self._set_property(attribute_name, attribute_value)",
            "            except TypeError:",
            "                logger.warn(",
            "                    f\"Resetting '{attribute_name}' attribute failed because it could not be constructed.\"",
            "                )",
            "                pass",
            "            except pickle.PickleError:",
            "                logger.warn(",
            "                    f\"Resetting '{attribute_name}' attribute failed because it could not be de-pickled.\"",
            "                )",
            "                pass",
            "",
            "    def call(self, function_name, *args):",
            "        \"\"\"",
            "        Add a JavaScript method name and arguments to be called after the component is rendered.",
            "        \"\"\"",
            "        self.calls.append({\"fn\": function_name, \"args\": args})",
            "",
            "    def mount(self):",
            "        \"\"\"",
            "        Hook that gets called when the component is first created.",
            "        \"\"\"",
            "        pass",
            "",
            "    def hydrate(self):",
            "        \"\"\"",
            "        Hook that gets called when the component's data is hydrated.",
            "        \"\"\"",
            "        pass",
            "",
            "    def complete(self):",
            "        \"\"\"",
            "        Hook that gets called after all component methods are executed.",
            "        \"\"\"",
            "        pass",
            "",
            "    def rendered(self, html):",
            "        \"\"\"",
            "        Hook that gets called after the component has been rendered.",
            "        \"\"\"",
            "        pass",
            "",
            "    def parent_rendered(self, html):",
            "        \"\"\"",
            "        Hook that gets called after the component's parent has been rendered.",
            "        \"\"\"",
            "        pass",
            "",
            "    def updating(self, name, value):",
            "        \"\"\"",
            "        Hook that gets called when a component's data is about to get updated.",
            "        \"\"\"",
            "        pass",
            "",
            "    def updated(self, name, value):",
            "        \"\"\"",
            "        Hook that gets called when a component's data is updated.",
            "        \"\"\"",
            "        pass",
            "",
            "    def calling(self, name, args):",
            "        \"\"\"",
            "        Hook that gets called when a component's method is about to get called.",
            "        \"\"\"",
            "        pass",
            "",
            "    def called(self, name, args):",
            "        \"\"\"",
            "        Hook that gets called when a component's method is called.",
            "        \"\"\"",
            "        pass",
            "",
            "    @timed",
            "    def render(self, init_js=False) -> str:",
            "        \"\"\"",
            "        Renders a UnicornView component with the public properties available. Delegates to a",
            "        UnicornTemplateResponse to actually render a response.",
            " ",
            "        Args:",
            "            param init_js: Whether or not to include the Javascript required to initialize the component.",
            "        \"\"\"",
            "",
            "        response = self.render_to_response(",
            "            context=self.get_context_data(), component=self, init_js=init_js,",
            "        )",
            "",
            "        # render_to_response() could only return a HttpResponse, so check for render()",
            "        if hasattr(response, \"render\"):",
            "            response.render()",
            "",
            "        rendered_component = response.content.decode(\"utf-8\")",
            "",
            "        # Set the current component as a child of the parent if there is a parent",
            "        # If no parent, mark that the component has its children set.",
            "        # This works because the nested (internal) components get rendered first before the parent,",
            "        # so once we hit a component without a parent we know all of the children have been rendered correctly",
            "        # TODO: This might fall apart with a third layer of nesting components",
            "        if self.parent:",
            "            if not self.parent._children_set:",
            "                self.parent.children.append(self)",
            "        else:",
            "            self._children_set = True",
            "",
            "        return rendered_component",
            "",
            "    @timed",
            "    def get_frontend_context_variables(self) -> str:",
            "        \"\"\"",
            "        Get publicly available properties and output them in a string-encoded JSON object.",
            "        \"\"\"",
            "",
            "        frontend_context_variables = {}",
            "        attributes = self._attributes()",
            "        frontend_context_variables.update(attributes)",
            "",
            "        # Remove any field in `javascript_exclude` from `frontend_context_variables`",
            "        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"javascript_exclude\"):",
            "            if isinstance(self.Meta.javascript_exclude, Sequence):",
            "                for field_name in self.Meta.javascript_exclude:",
            "                    if field_name in frontend_context_variables:",
            "                        del frontend_context_variables[field_name]",
            "",
            "        # Add cleaned values to `frontend_content_variables` based on the widget in form's fields",
            "        form = self._get_form(attributes)",
            "",
            "        if form:",
            "            form.is_valid()",
            "",
            "            for key in attributes.keys():",
            "                if key in form.fields:",
            "                    field = form.fields[key]",
            "",
            "                    if key in form.cleaned_data:",
            "                        cleaned_value = form.cleaned_data[key]",
            "                        value = field.widget.format_value(cleaned_value)",
            "",
            "                        # Don't update the frontend variable if the only change is",
            "                        # stripping off the whitespace from the field value",
            "                        # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip",
            "                        if (",
            "                            not hasattr(frontend_context_variables[key], \"strip\")",
            "                            or frontend_context_variables[key].strip() != value",
            "                        ):",
            "                            frontend_context_variables[key] = value",
            "",
            "        encoded_frontend_context_variables = serializer.dumps(",
            "            frontend_context_variables",
            "        )",
            "",
            "        return encoded_frontend_context_variables",
            "",
            "    @timed",
            "    def _get_form(self, data):",
            "        if hasattr(self, \"form_class\"):",
            "            try:",
            "                form = self.form_class(data)",
            "                form.is_valid()",
            "",
            "                return form",
            "            except Exception as e:",
            "                logger.exception(e)",
            "",
            "    @timed",
            "    def get_context_data(self, **kwargs):",
            "        \"\"\"",
            "        Overrides the standard `get_context_data` to add in publicly available",
            "        properties and methods.",
            "        \"\"\"",
            "",
            "        context = super().get_context_data(**kwargs)",
            "",
            "        attributes = self._attributes()",
            "        context.update(attributes)",
            "        context.update(self._methods())",
            "        context.update({\"unicorn\": {\"errors\": self.errors}})",
            "",
            "        return context",
            "",
            "    @timed",
            "    def is_valid(self, model_names: List = None) -> bool:",
            "        return len(self.validate(model_names).keys()) == 0",
            "",
            "    @timed",
            "    def validate(self, model_names: List = None) -> Dict:",
            "        \"\"\"",
            "        Validates the data using the `form_class` set on the component.",
            "",
            "        Args:",
            "            model_names: Only include validation errors for specified fields. If none, validate everything.",
            "        \"\"\"",
            "        # TODO: Handle form.non_field_errors()?",
            "",
            "        if self._validate_called:",
            "            return self.errors",
            "",
            "        self._validate_called = True",
            "",
            "        data = self._attributes()",
            "        form = self._get_form(data)",
            "",
            "        if form:",
            "            form_errors = form.errors.get_json_data(escape_html=True)",
            "",
            "            # This code is confusing, but handles this use-case:",
            "            # the component has two models, one that starts with an error and one",
            "            # that is valid. Validating the valid one should not show an error for",
            "            # the invalid one. Only after the invalid field is updated, should the",
            "            # error show up and persist, even after updating the valid form.",
            "            if self.errors:",
            "                keys_to_remove = []",
            "",
            "                for key, value in self.errors.items():",
            "                    if key in form_errors:",
            "                        self.errors[key] = value",
            "                    else:",
            "                        keys_to_remove.append(key)",
            "",
            "                for key in keys_to_remove:",
            "                    self.errors.pop(key)",
            "",
            "            if model_names is not None:",
            "                for key, value in form_errors.items():",
            "                    if key in model_names:",
            "                        self.errors[key] = value",
            "            else:",
            "                self.errors.update(form_errors)",
            "",
            "        return self.errors",
            "",
            "    @timed",
            "    def _attribute_names(self) -> List[str]:",
            "        \"\"\"",
            "        Gets publicly available attribute names. Cached in `_attribute_names_cache`.",
            "        \"\"\"",
            "        non_callables = [",
            "            member[0] for member in inspect.getmembers(self, lambda x: not callable(x))",
            "        ]",
            "        attribute_names = [name for name in non_callables if self._is_public(name)]",
            "",
            "        return attribute_names",
            "",
            "    @timed",
            "    def _attributes(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Get publicly available attributes and their values from the component.",
            "        \"\"\"",
            "",
            "        attribute_names = self._attribute_names_cache",
            "        attributes = {}",
            "",
            "        for attribute_name in attribute_names:",
            "            attributes[attribute_name] = getattr(self, attribute_name)",
            "",
            "        return attributes",
            "",
            "    @timed",
            "    def _set_property(self, name, value):",
            "        # Get the correct value type by using the form if it is available",
            "        data = self._attributes()",
            "        data[name] = value",
            "        form = self._get_form(data)",
            "",
            "        if form and name in form.fields and name in form.cleaned_data:",
            "            # The Django form CharField validator will remove whitespace",
            "            # from the field value. Ignore that update if it's the",
            "            # only thing different from the validator",
            "            # https://docs.djangoproject.com/en/stable/ref/forms/fields/#django.forms.CharField.strip",
            "            if not hasattr(value, \"strip\") or form.cleaned_data[name] != value.strip():",
            "                value = form.cleaned_data[name]",
            "",
            "        updating_function_name = f\"updating_{name}\"",
            "        if hasattr(self, updating_function_name):",
            "            getattr(self, updating_function_name)(value)",
            "",
            "        try:",
            "            setattr(self, name, value)",
            "",
            "            updated_function_name = f\"updated_{name}\"",
            "",
            "            if hasattr(self, updated_function_name):",
            "                getattr(self, updated_function_name)(value)",
            "        except AttributeError as e:",
            "            raise",
            "",
            "    @timed",
            "    def _methods(self) -> Dict[str, Callable]:",
            "        \"\"\"",
            "        Get publicly available method names and their functions from the component.",
            "        Cached in `_methods_cache`.",
            "        \"\"\"",
            "",
            "        if self._methods_cache:",
            "            return self._methods_cache",
            "",
            "        member_methods = inspect.getmembers(self, inspect.ismethod)",
            "        public_methods = [",
            "            method for method in member_methods if self._is_public(method[0])",
            "        ]",
            "        methods = {k: v for (k, v) in public_methods}",
            "        self._methods_cache = methods",
            "",
            "        return methods",
            "",
            "    @timed",
            "    def _set_hook_methods_cache(self) -> None:",
            "        \"\"\"",
            "        Caches the updating/updated attribute function names defined on the component.",
            "        \"\"\"",
            "        self._hook_methods_cache = []",
            "",
            "        for attribute_name in self._attribute_names_cache:",
            "            updating_function_name = f\"updating_{attribute_name}\"",
            "            updated_function_name = f\"updated_{attribute_name}\"",
            "            hook_function_names = [updating_function_name, updated_function_name]",
            "",
            "            for function_name in hook_function_names:",
            "                if hasattr(self, function_name):",
            "                    self._hook_methods_cache.append(function_name)",
            "",
            "    @timed",
            "    def _set_resettable_attributes_cache(self) -> None:",
            "        \"\"\"",
            "        Caches the attributes that are \"resettable\" in `_resettable_attributes_cache`.",
            "        Cache is a dictionary with key: attribute name; value: pickled attribute value",
            "",
            "        Examples:",
            "            - `UnicornField`",
            "            - Django Models without a defined pk",
            "        \"\"\"",
            "        self._resettable_attributes_cache = {}",
            "",
            "        for attribute_name, attribute_value in self._attributes().items():",
            "            if isinstance(attribute_value, UnicornField):",
            "                self._resettable_attributes_cache[attribute_name] = pickle.dumps(",
            "                    attribute_value",
            "                )",
            "            elif isinstance(attribute_value, Model):",
            "                if not attribute_value.pk:",
            "                    if attribute_name not in self._resettable_attributes_cache:",
            "                        try:",
            "                            self._resettable_attributes_cache[",
            "                                attribute_name",
            "                            ] = pickle.dumps(attribute_value)",
            "                        except pickle.PickleError:",
            "                            logger.warn(",
            "                                f\"Caching '{attribute_name}' failed because it could not be pickled.\"",
            "                            )",
            "                            pass",
            "",
            "    def _is_public(self, name: str) -> bool:",
            "        \"\"\"",
            "        Determines if the name should be sent in the context.",
            "        \"\"\"",
            "",
            "        # Ignore some standard attributes from TemplateView",
            "        protected_names = (",
            "            \"render\",",
            "            \"request\",",
            "            \"args\",",
            "            \"kwargs\",",
            "            \"content_type\",",
            "            \"extra_context\",",
            "            \"http_method_names\",",
            "            \"template_engine\",",
            "            \"template_name\",",
            "            \"dispatch\",",
            "            \"id\",",
            "            \"get\",",
            "            \"get_context_data\",",
            "            \"get_template_names\",",
            "            \"render_to_response\",",
            "            \"http_method_not_allowed\",",
            "            \"options\",",
            "            \"setup\",",
            "            \"fill\",",
            "            # Component methods",
            "            \"component_id\",",
            "            \"component_name\",",
            "            \"component_key\",",
            "            \"reset\",",
            "            \"mount\",",
            "            \"hydrate\",",
            "            \"updating\",",
            "            \"update\",",
            "            \"calling\",",
            "            \"called\",",
            "            \"complete\",",
            "            \"rendered\",",
            "            \"parent_rendered\",",
            "            \"validate\",",
            "            \"is_valid\",",
            "            \"get_frontend_context_variables\",",
            "            \"errors\",",
            "            \"updated\",",
            "            \"parent\",",
            "            \"children\",",
            "            \"call\",",
            "            \"calls\",",
            "            \"component_cache_key\",",
            "        )",
            "        excludes = []",
            "",
            "        if hasattr(self, \"Meta\") and hasattr(self.Meta, \"exclude\"):",
            "            if isinstance(self.Meta.exclude, Sequence):",
            "                excludes = self.Meta.exclude",
            "",
            "        return not (",
            "            name.startswith(\"_\")",
            "            or name in protected_names",
            "            or name in self._hook_methods_cache",
            "            or name in excludes",
            "        )",
            "",
            "    @staticmethod",
            "    @timed",
            "    def create(",
            "        component_id: str,",
            "        component_name: str,",
            "        component_key: str = \"\",",
            "        parent: \"UnicornView\" = None,",
            "        request: HttpRequest = None,",
            "        use_cache=True,",
            "        kwargs: Dict[str, Any] = {},",
            "    ) -> \"UnicornView\":",
            "        \"\"\"",
            "        Find and instantiate a component class based on `component_name`.",
            "",
            "        Args:",
            "            param component_id: Id of the component. Required.",
            "            param component_name: Name of the component. Used to locate the correct `UnicornView`",
            "                component class and template if necessary. Required.",
            "            param component_key: Key of the component to allow multiple components of the same name",
            "                to be differentiated. Optional.",
            "            param parent: The parent component of the current component.",
            "            param kwargs: Keyword arguments for the component passed in from the template. Defaults to `{}`.",
            "        ",
            "        Returns:",
            "            Instantiated `UnicornView` component.",
            "            Raises `ComponentLoadError` if the component could not be loaded.",
            "        \"\"\"",
            "        assert component_id, \"Component id is required\"",
            "        assert component_name, \"Component name is required\"",
            "",
            "        @timed",
            "        def _get_component_class(",
            "            module_name: str, class_name: str",
            "        ) -> Type[UnicornView]:",
            "            \"\"\"",
            "            Imports a component based on module and class name.",
            "            \"\"\"",
            "            module = importlib.import_module(module_name)",
            "            component_class = getattr(module, class_name)",
            "",
            "            return component_class",
            "",
            "        cache = caches[get_cache_alias()]",
            "        component_cache_key = f\"unicorn:component:{component_id}\"",
            "        cached_component = cache.get(component_cache_key)",
            "",
            "        if cached_component:",
            "            # Get the newest version of the parent from cache if it is available",
            "            # This needs to happen for Django cache because instances is pickled, so",
            "            # a change in the view won't be reflected automatically (like with the module",
            "            # cache) so it needs to be retrieved manually.",
            "            if cached_component.parent:",
            "                cached_parent_component = cache.get(",
            "                    cached_component.parent.component_cache_key",
            "                )",
            "",
            "                if cached_parent_component:",
            "                    cached_component.parent = cached_parent_component",
            "                    cached_component.parent.setup(request)",
            "        else:",
            "            cached_component = constructed_views_cache.get(component_id)",
            "",
            "        if use_cache and cached_component:",
            "            # Note that `hydrate()` and `complete` don't need to be called here",
            "            # because this path only happens for re-rendering from the view",
            "            cached_component.setup(request)",
            "            cached_component._validate_called = False",
            "            cached_component.calls = []",
            "            logger.debug(f\"Retrieve {component_id} from constructed views cache\")",
            "",
            "            return cached_component",
            "",
            "        if component_id in views_cache:",
            "            (component_class, parent, kwargs) = views_cache[component_id]",
            "",
            "            component = construct_component(",
            "                component_class=component_class,",
            "                component_id=component_id,",
            "                component_name=component_name,",
            "                component_key=component_key,",
            "                parent=parent,",
            "                request=request,",
            "                **kwargs,",
            "            )",
            "            logger.debug(f\"Retrieve {component_id} from views cache\")",
            "",
            "            return component",
            "",
            "        locations = []",
            "",
            "        if component_name in location_cache:",
            "            locations.append(location_cache[component_name])",
            "        else:",
            "            locations = get_locations(component_name)",
            "",
            "        # Store the last exception that got raised while looking for a component in case it is useful context",
            "        last_exception: Union[",
            "            Optional[ModuleNotFoundError], Optional[AttributeError]",
            "        ] = None",
            "",
            "        for (class_name, module_name) in locations:",
            "            try:",
            "                component_class = _get_component_class(module_name, class_name)",
            "                component = construct_component(",
            "                    component_class=component_class,",
            "                    component_id=component_id,",
            "                    component_name=component_name,",
            "                    component_key=component_key,",
            "                    parent=parent,",
            "                    request=request,",
            "                    **kwargs,",
            "                )",
            "",
            "                # Put the location for the component name in a module cache",
            "                location_cache[component_name] = (class_name, module_name)",
            "",
            "                # Put the component's class in a module cache",
            "                views_cache[component_id] = (component_class, parent, kwargs)",
            "",
            "                # Put the instantiated component into a module cache and the Django cache",
            "                cacheable_component = None",
            "",
            "                try:",
            "                    cacheable_component = get_cacheable_component(component)",
            "                except UnicornCacheError as e:",
            "                    logger.warning(e)",
            "",
            "                if cacheable_component:",
            "                    if COMPONENTS_MODULE_CACHE_ENABLED:",
            "                        constructed_views_cache[component_id] = cacheable_component",
            "",
            "                    cache.set(",
            "                        cacheable_component.component_cache_key, cacheable_component",
            "                    )",
            "",
            "                return component",
            "            except ModuleNotFoundError as e:",
            "                last_exception = e",
            "            except AttributeError as e:",
            "                last_exception = e",
            "",
            "        raise ComponentLoadError(",
            "            f\"'{component_name}' component could not be loaded: {last_exception}\"",
            "        ) from last_exception"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [],
            "344": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "345": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "346": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "347": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "348": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "349": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "350": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "351": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "375": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "376": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "377": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "378": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "379": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "380": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "381": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "382": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "383": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "384": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "385": [
                "UnicornView",
                "get_frontend_context_variables"
            ],
            "386": [
                "UnicornView",
                "get_frontend_context_variables"
            ]
        },
        "addLocation": []
    },
    "django_unicorn/views/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import copy"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import logging"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from functools import wraps"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Dict"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from typing import Dict, Sequence"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.core.cache import caches"
            },
            "7": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from django.http import HttpRequest, JsonResponse"
            },
            "8": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.http.response import HttpResponseNotModified"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from django.utils.safestring import mark_safe"
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.views.decorators.csrf import csrf_protect"
            },
            "11": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from django.views.decorators.http import require_POST"
            },
            "12": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     # Re-load frontend context variables to deal with non-serializable properties"
            },
            "14": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     component_request.data = orjson.loads(component.get_frontend_context_variables())"
            },
            "15": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    # Get set of attributes that should be marked as `safe`"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    safe_fields = []"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+    if hasattr(component, \"Meta\") and hasattr(component.Meta, \"safe\"):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        if isinstance(component.Meta.safe, Sequence):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+            for field_name in component.Meta.safe:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+                if field_name in component._attributes().keys():"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+                    safe_fields.append(field_name)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    # Mark safe attributes as such before rendering"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    for field_name in safe_fields:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        value = getattr(component, field_name)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        if isinstance(value, str):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+            setattr(component, field_name, mark_safe(value))"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     # Send back all available data for reset or refresh actions"
            },
            "31": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     updated_data = component_request.data"
            },
            "32": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import copy",
            "import logging",
            "from functools import wraps",
            "from typing import Dict",
            "",
            "from django.core.cache import caches",
            "from django.http import HttpRequest, JsonResponse",
            "from django.http.response import HttpResponseNotModified",
            "from django.views.decorators.csrf import csrf_protect",
            "from django.views.decorators.http import require_POST",
            "",
            "import orjson",
            "from bs4 import BeautifulSoup",
            "",
            "from django_unicorn.components import UnicornView",
            "from django_unicorn.components.unicorn_template_response import get_root_element",
            "from django_unicorn.decorators import timed",
            "from django_unicorn.errors import RenderNotModified, UnicornCacheError, UnicornViewError",
            "from django_unicorn.serializer import dumps, loads",
            "from django_unicorn.settings import (",
            "    get_cache_alias,",
            "    get_serial_enabled,",
            "    get_serial_timeout,",
            ")",
            "from django_unicorn.utils import generate_checksum, get_cacheable_component",
            "from django_unicorn.views.action_parsers import call_method, sync_input",
            "from django_unicorn.views.objects import ComponentRequest",
            "from django_unicorn.views.utils import set_property_from_data",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "logger.setLevel(logging.DEBUG)",
            "",
            "",
            "def handle_error(view_func):",
            "    \"\"\"",
            "    Returns a JSON response with an error if necessary.",
            "    \"\"\"",
            "",
            "    def wrapped_view(*args, **kwargs):",
            "        try:",
            "            return view_func(*args, **kwargs)",
            "        except UnicornViewError as e:",
            "            return JsonResponse({\"error\": str(e)})",
            "        except RenderNotModified:",
            "            return HttpResponseNotModified()",
            "        except AssertionError as e:",
            "            return JsonResponse({\"error\": str(e)})",
            "",
            "    return wraps(view_func)(wrapped_view)",
            "",
            "",
            "def _process_component_request(",
            "    request: HttpRequest, component_request: ComponentRequest",
            ") -> Dict:",
            "    \"\"\"",
            "    Process a `ComponentRequest`:",
            "        1. construct a Component view",
            "        2. set all of the properties on the view from the data",
            "        3. execute the type",
            "            - update the properties based on the payload for \"syncInput\"",
            "            - call the method specified for \"callMethod\"",
            "        4. validate any fields specified in a Django form",
            "        5. construct a `dict` that will get returned in a `JsonResponse` later on",
            "",
            "    Args:",
            "        param request: HttpRequest for the function-based view.",
            "        param: component_request: Component request to process.",
            "",
            "    Returns:",
            "        `dict` with the following structure:",
            "        {",
            "            \"id\": component_id,",
            "            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed",
            "            \"data\": {},  // updated data after actions in the payload are completed",
            "            \"errors\": {},  // form validation errors",
            "            \"return\": {}, // optional return value from an executed action",
            "            \"parent\": {},  // optional representation of the parent component",
            "        }",
            "    \"\"\"",
            "    component = UnicornView.create(",
            "        component_id=component_request.id,",
            "        component_name=component_request.name,",
            "        request=request,",
            "    )",
            "",
            "    # Get a deepcopy of the data passed in to determine what fields are updated later",
            "    original_data = copy.deepcopy(component_request.data)",
            "",
            "    # Set component properties based on request data",
            "    for (property_name, property_value) in component_request.data.items():",
            "        set_property_from_data(component, property_name, property_value)",
            "    component.hydrate()",
            "",
            "    validate_all_fields = False",
            "    is_reset_called = False",
            "    is_refresh_called = False",
            "    return_data = None",
            "    partials = []",
            "",
            "    for action in component_request.action_queue:",
            "        if action.partial:",
            "            partials.append(action.partial)",
            "        else:",
            "            partials = action.partials",
            "",
            "        if action.action_type == \"syncInput\":",
            "            sync_input.handle(component_request, component, action.payload)",
            "        elif action.action_type == \"callMethod\":",
            "            (",
            "                component,",
            "                _is_refresh_called,",
            "                _is_reset_called,",
            "                _validate_all_fields,",
            "                return_data,",
            "            ) = call_method.handle(component_request, component, action.payload)",
            "",
            "            is_refresh_called = is_refresh_called | _is_refresh_called",
            "            is_reset_called = is_reset_called | _is_reset_called",
            "            validate_all_fields = validate_all_fields | _validate_all_fields",
            "        else:",
            "            raise UnicornViewError(f\"Unknown action_type '{action.action_type}'\")",
            "",
            "    component.complete()",
            "",
            "    # Re-load frontend context variables to deal with non-serializable properties",
            "    component_request.data = orjson.loads(component.get_frontend_context_variables())",
            "",
            "    # Send back all available data for reset or refresh actions",
            "    updated_data = component_request.data",
            "",
            "    if not is_reset_called:",
            "        if not is_refresh_called:",
            "            updated_data = {}",
            "",
            "            for key, value in original_data.items():",
            "                if value != component_request.data.get(key):",
            "                    updated_data[key] = component_request.data.get(key)",
            "",
            "        if validate_all_fields:",
            "            component.validate()",
            "        else:",
            "            component.validate(model_names=list(updated_data.keys()))",
            "",
            "    rendered_component = component.render()",
            "    component.rendered(rendered_component)",
            "",
            "    cache = caches[get_cache_alias()]",
            "",
            "    try:",
            "        cache.set(component.component_cache_key, get_cacheable_component(component))",
            "    except UnicornCacheError as e:",
            "        logger.warning(e)",
            "",
            "    partial_doms = []",
            "",
            "    if partials and all(partials):",
            "        soup = BeautifulSoup(rendered_component, features=\"html.parser\")",
            "",
            "        for partial in partials:",
            "            partial_found = False",
            "            only_id = False",
            "            only_key = False",
            "",
            "            target = partial.get(\"target\")",
            "",
            "            if not target:",
            "                target = partial.get(\"key\")",
            "",
            "                if target:",
            "                    only_key = True",
            "",
            "            if not target:",
            "                target = partial.get(\"id\")",
            "",
            "                if target:",
            "                    only_id = True",
            "",
            "            assert target, \"Partial target is required\"",
            "",
            "            if not only_id:",
            "                for element in soup.find_all():",
            "                    if (",
            "                        \"unicorn:key\" in element.attrs",
            "                        and element.attrs[\"unicorn:key\"] == target",
            "                    ):",
            "                        partial_doms.append({\"key\": target, \"dom\": str(element)})",
            "                        partial_found = True",
            "                        break",
            "",
            "            if not partial_found and not only_key:",
            "                for element in soup.find_all():",
            "                    if \"id\" in element.attrs and element.attrs[\"id\"] == target:",
            "                        partial_doms.append({\"id\": target, \"dom\": str(element)})",
            "                        partial_found = True",
            "                        break",
            "",
            "    res = {",
            "        \"id\": component_request.id,",
            "        \"data\": updated_data,",
            "        \"errors\": component.errors,",
            "        \"calls\": component.calls,",
            "        \"checksum\": generate_checksum(orjson.dumps(component_request.data)),",
            "    }",
            "",
            "    if partial_doms:",
            "        res.update({\"partials\": partial_doms})",
            "    else:",
            "        hash = generate_checksum(rendered_component)",
            "",
            "        if (",
            "            component_request.hash == hash",
            "            and (not return_data or not return_data.value)",
            "            and not component.calls",
            "        ):",
            "            raise RenderNotModified()",
            "",
            "        # Make sure that partials with comments or blank lines before the root element only return the root element",
            "        soup = BeautifulSoup(rendered_component, features=\"html.parser\")",
            "        rendered_component = str(get_root_element(soup))",
            "",
            "        res.update(",
            "            {\"dom\": rendered_component, \"hash\": hash,}",
            "        )",
            "",
            "    if return_data:",
            "        res.update(",
            "            {\"return\": return_data.get_data(),}",
            "        )",
            "",
            "        if return_data.redirect:",
            "            res.update(",
            "                {\"redirect\": return_data.redirect,}",
            "            )",
            "",
            "        if return_data.poll:",
            "            res.update(",
            "                {\"poll\": return_data.poll,}",
            "            )",
            "",
            "    parent_component = component.parent",
            "",
            "    if parent_component:",
            "        # TODO: Should parent_component.hydrate() be called?",
            "        parent_frontend_context_variables = loads(",
            "            parent_component.get_frontend_context_variables()",
            "        )",
            "        parent_checksum = generate_checksum(dumps(parent_frontend_context_variables))",
            "",
            "        parent = {",
            "            \"id\": parent_component.component_id,",
            "            \"checksum\": parent_checksum,",
            "        }",
            "",
            "        if not partial_doms:",
            "            parent_dom = parent_component.render()",
            "            component.parent_rendered(parent_dom)",
            "",
            "            try:",
            "                cache.set(",
            "                    parent_component.component_cache_key,",
            "                    get_cacheable_component(parent_component),",
            "                )",
            "            except UnicornCacheError as e:",
            "                logger.warning(e)",
            "",
            "            parent.update(",
            "                {",
            "                    \"dom\": parent_dom,",
            "                    \"data\": parent_frontend_context_variables,",
            "                    \"errors\": parent_component.errors,",
            "                }",
            "            )",
            "",
            "        res.update({\"parent\": parent})",
            "",
            "    return res",
            "",
            "",
            "def _handle_component_request(",
            "    request: HttpRequest, component_request: ComponentRequest",
            ") -> Dict:",
            "    \"\"\"",
            "    Process a `ComponentRequest` by adding it to the cache and then either:",
            "        - processing all of the component requests in the cache and returning the resulting value if",
            "            it is the first component request for that particular component name + component id combination",
            "        - return a `dict` saying that the request has been queued",
            "    ",
            "    Args:",
            "        param request: HttpRequest for the function-based view.",
            "        param: component_request: Component request to process.",
            "    ",
            "    Returns:",
            "        `dict` with the following structure:",
            "        {",
            "            \"id\": component_id,",
            "            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed",
            "            \"data\": {},  // updated data after actions in the payload are completed",
            "            \"errors\": {},  // form validation errors",
            "            \"return\": {}, // optional return value from an executed action",
            "            \"parent\": {},  // optional representation of the parent component",
            "        }",
            "    \"\"\"",
            "    # If serial isn't enabled or the wrong cache, just process the request like normal",
            "    if not get_serial_enabled():",
            "        return _process_component_request(request, component_request)",
            "",
            "    cache = caches[get_cache_alias()]",
            "",
            "    # Add the current request `ComponentRequest` to the cache",
            "    queue_cache_key = f\"unicorn:queue:{component_request.id}\"",
            "    component_requests = cache.get(queue_cache_key) or []",
            "",
            "    # Remove `request` from `ComponentRequest` before caching because it is not pickleable",
            "    component_request.request = None",
            "    component_requests.append(component_request)",
            "",
            "    cache.set(",
            "        queue_cache_key, component_requests, timeout=get_serial_timeout(),",
            "    )",
            "",
            "    if len(component_requests) > 1:",
            "        original_epoch = component_requests[0].epoch",
            "        return {",
            "            \"queued\": True,",
            "            \"epoch\": component_request.epoch,",
            "            \"original_epoch\": original_epoch,",
            "        }",
            "",
            "    return _handle_queued_component_requests(",
            "        request, component_request.name, queue_cache_key",
            "    )",
            "",
            "",
            "def _handle_queued_component_requests(",
            "    request: HttpRequest, component_name: str, queue_cache_key",
            ") -> Dict:",
            "    \"\"\"",
            "    Process the current component requests that are stored in cache.",
            "    Also recursively checks for new requests that might have happened",
            "    while executing the first request, merges them together and returns",
            "    the correct appropriate data.",
            "",
            "    Args:",
            "        param request: HttpRequest for the view.",
            "        param: component_name: Name of the component, e.g. \"hello-world\".",
            "        param: queue_cache_key: Cache key created from component id which should be unique",
            "            for any particular user's request lifecycle.",
            "    ",
            "    Returns:",
            "        JSON with the following structure:",
            "        {",
            "            \"id\": component_id,",
            "            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed",
            "            \"data\": {},  // updated data after actions in the payload are completed",
            "            \"errors\": {},  // form validation errors",
            "            \"return\": {}, // optional return value from an executed action",
            "            \"parent\": {},  // optional representation of the parent component",
            "        }",
            "    \"\"\"",
            "    cache = caches[get_cache_alias()]",
            "",
            "    # Handle current request and any others in the cache by first sorting all of the current requests by ascending order",
            "    component_requests = cache.get(queue_cache_key)",
            "",
            "    if not component_requests or not isinstance(component_requests, list):",
            "        raise UnicornViewError(f\"No request found for {queue_cache_key}\")",
            "",
            "    component_requests = sorted(component_requests, key=lambda r: r.epoch)",
            "    first_component_request = component_requests[0]",
            "",
            "    try:",
            "        # Can't store request on a `ComponentRequest` and cache it because `HttpRequest` isn't pickleable",
            "        first_json_result = _process_component_request(request, first_component_request)",
            "    except RenderNotModified:",
            "        # Catching this and re-raising, but need the finally clause to clear the cache",
            "        raise",
            "    finally:",
            "        # Re-check for requests after the first request is processed",
            "        component_requests = cache.get(queue_cache_key)",
            "",
            "        # Check that the request is in the cache before popping it off",
            "        if component_requests:",
            "            component_requests.pop(0)",
            "            cache.set(",
            "                queue_cache_key, component_requests, timeout=get_serial_timeout(),",
            "            )",
            "",
            "    if component_requests:",
            "        # Create one new `component_request` from all of the queued requests that can be processed",
            "        merged_component_request = None",
            "",
            "        for additional_component_request in copy.deepcopy(component_requests):",
            "            if merged_component_request:",
            "                # Add new component request action queue to the merged component request",
            "                merged_component_request.action_queue.extend(",
            "                    additional_component_request.action_queue",
            "                )",
            "",
            "                # Originally, the thought was to merge the `additional_component_request.data` into",
            "                # the `merged_component_request.data`, but I can't figure out a way to do that in a sane",
            "                # manner. This means that for rapidly fired events that mutate `data`, that new",
            "                # `data` with be \"thrown away\".",
            "                # Relevant test: test_call_method_multiple.py::test_message_call_method_multiple_with_updated_data",
            "            else:",
            "                merged_component_request = additional_component_request",
            "",
            "                # Set new component request data from the first component request's resulting data",
            "                for key, val in first_json_result.get(\"data\", {}).items():",
            "                    merged_component_request.data[key] = val",
            "",
            "            component_requests.pop(0)",
            "            cache.set(",
            "                queue_cache_key, component_requests, timeout=get_serial_timeout(),",
            "            )",
            "",
            "        merged_json_result = _handle_component_request(",
            "            request, merged_component_request",
            "        )",
            "",
            "        return merged_json_result",
            "",
            "    return first_json_result",
            "",
            "",
            "@timed",
            "@handle_error",
            "@csrf_protect",
            "@require_POST",
            "def message(request: HttpRequest, component_name: str = None) -> JsonResponse:",
            "    \"\"\"",
            "    Endpoint that instantiates the component and does the correct action",
            "    (set an attribute or call a method) depending on the JSON payload in the body.",
            "",
            "    Args:",
            "        param request: HttpRequest for the function-based view.",
            "        param: component_name: Name of the component, e.g. \"hello-world\".",
            "    ",
            "    Returns:",
            "        `JsonRequest` with the following structure in the body:",
            "        {",
            "            \"id\": component_id,",
            "            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed",
            "            \"data\": {},  // updated data after actions in the payload are completed",
            "            \"errors\": {},  // form validation errors",
            "            \"return\": {}, // optional return value from an executed action",
            "            \"parent\": {},  // optional representation of the parent component",
            "        }",
            "    \"\"\"",
            "",
            "    assert component_name, \"Missing component name in url\"",
            "",
            "    component_request = ComponentRequest(request, component_name)",
            "    json_result = _handle_component_request(request, component_request)",
            "",
            "    return JsonResponse(json_result)"
        ],
        "afterPatchFile": [
            "import copy",
            "import logging",
            "from functools import wraps",
            "from typing import Dict, Sequence",
            "",
            "from django.core.cache import caches",
            "from django.http import HttpRequest, JsonResponse",
            "from django.http.response import HttpResponseNotModified",
            "from django.utils.safestring import mark_safe",
            "from django.views.decorators.csrf import csrf_protect",
            "from django.views.decorators.http import require_POST",
            "",
            "import orjson",
            "from bs4 import BeautifulSoup",
            "",
            "from django_unicorn.components import UnicornView",
            "from django_unicorn.components.unicorn_template_response import get_root_element",
            "from django_unicorn.decorators import timed",
            "from django_unicorn.errors import RenderNotModified, UnicornCacheError, UnicornViewError",
            "from django_unicorn.serializer import dumps, loads",
            "from django_unicorn.settings import (",
            "    get_cache_alias,",
            "    get_serial_enabled,",
            "    get_serial_timeout,",
            ")",
            "from django_unicorn.utils import generate_checksum, get_cacheable_component",
            "from django_unicorn.views.action_parsers import call_method, sync_input",
            "from django_unicorn.views.objects import ComponentRequest",
            "from django_unicorn.views.utils import set_property_from_data",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "logger.setLevel(logging.DEBUG)",
            "",
            "",
            "def handle_error(view_func):",
            "    \"\"\"",
            "    Returns a JSON response with an error if necessary.",
            "    \"\"\"",
            "",
            "    def wrapped_view(*args, **kwargs):",
            "        try:",
            "            return view_func(*args, **kwargs)",
            "        except UnicornViewError as e:",
            "            return JsonResponse({\"error\": str(e)})",
            "        except RenderNotModified:",
            "            return HttpResponseNotModified()",
            "        except AssertionError as e:",
            "            return JsonResponse({\"error\": str(e)})",
            "",
            "    return wraps(view_func)(wrapped_view)",
            "",
            "",
            "def _process_component_request(",
            "    request: HttpRequest, component_request: ComponentRequest",
            ") -> Dict:",
            "    \"\"\"",
            "    Process a `ComponentRequest`:",
            "        1. construct a Component view",
            "        2. set all of the properties on the view from the data",
            "        3. execute the type",
            "            - update the properties based on the payload for \"syncInput\"",
            "            - call the method specified for \"callMethod\"",
            "        4. validate any fields specified in a Django form",
            "        5. construct a `dict` that will get returned in a `JsonResponse` later on",
            "",
            "    Args:",
            "        param request: HttpRequest for the function-based view.",
            "        param: component_request: Component request to process.",
            "",
            "    Returns:",
            "        `dict` with the following structure:",
            "        {",
            "            \"id\": component_id,",
            "            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed",
            "            \"data\": {},  // updated data after actions in the payload are completed",
            "            \"errors\": {},  // form validation errors",
            "            \"return\": {}, // optional return value from an executed action",
            "            \"parent\": {},  // optional representation of the parent component",
            "        }",
            "    \"\"\"",
            "    component = UnicornView.create(",
            "        component_id=component_request.id,",
            "        component_name=component_request.name,",
            "        request=request,",
            "    )",
            "",
            "    # Get a deepcopy of the data passed in to determine what fields are updated later",
            "    original_data = copy.deepcopy(component_request.data)",
            "",
            "    # Set component properties based on request data",
            "    for (property_name, property_value) in component_request.data.items():",
            "        set_property_from_data(component, property_name, property_value)",
            "    component.hydrate()",
            "",
            "    validate_all_fields = False",
            "    is_reset_called = False",
            "    is_refresh_called = False",
            "    return_data = None",
            "    partials = []",
            "",
            "    for action in component_request.action_queue:",
            "        if action.partial:",
            "            partials.append(action.partial)",
            "        else:",
            "            partials = action.partials",
            "",
            "        if action.action_type == \"syncInput\":",
            "            sync_input.handle(component_request, component, action.payload)",
            "        elif action.action_type == \"callMethod\":",
            "            (",
            "                component,",
            "                _is_refresh_called,",
            "                _is_reset_called,",
            "                _validate_all_fields,",
            "                return_data,",
            "            ) = call_method.handle(component_request, component, action.payload)",
            "",
            "            is_refresh_called = is_refresh_called | _is_refresh_called",
            "            is_reset_called = is_reset_called | _is_reset_called",
            "            validate_all_fields = validate_all_fields | _validate_all_fields",
            "        else:",
            "            raise UnicornViewError(f\"Unknown action_type '{action.action_type}'\")",
            "",
            "    component.complete()",
            "",
            "    # Re-load frontend context variables to deal with non-serializable properties",
            "    component_request.data = orjson.loads(component.get_frontend_context_variables())",
            "",
            "    # Get set of attributes that should be marked as `safe`",
            "    safe_fields = []",
            "    if hasattr(component, \"Meta\") and hasattr(component.Meta, \"safe\"):",
            "        if isinstance(component.Meta.safe, Sequence):",
            "            for field_name in component.Meta.safe:",
            "                if field_name in component._attributes().keys():",
            "                    safe_fields.append(field_name)",
            "",
            "    # Mark safe attributes as such before rendering",
            "    for field_name in safe_fields:",
            "        value = getattr(component, field_name)",
            "        if isinstance(value, str):",
            "            setattr(component, field_name, mark_safe(value))",
            "",
            "    # Send back all available data for reset or refresh actions",
            "    updated_data = component_request.data",
            "",
            "    if not is_reset_called:",
            "        if not is_refresh_called:",
            "            updated_data = {}",
            "",
            "            for key, value in original_data.items():",
            "                if value != component_request.data.get(key):",
            "                    updated_data[key] = component_request.data.get(key)",
            "",
            "        if validate_all_fields:",
            "            component.validate()",
            "        else:",
            "            component.validate(model_names=list(updated_data.keys()))",
            "",
            "    rendered_component = component.render()",
            "    component.rendered(rendered_component)",
            "",
            "    cache = caches[get_cache_alias()]",
            "",
            "    try:",
            "        cache.set(component.component_cache_key, get_cacheable_component(component))",
            "    except UnicornCacheError as e:",
            "        logger.warning(e)",
            "",
            "    partial_doms = []",
            "",
            "    if partials and all(partials):",
            "        soup = BeautifulSoup(rendered_component, features=\"html.parser\")",
            "",
            "        for partial in partials:",
            "            partial_found = False",
            "            only_id = False",
            "            only_key = False",
            "",
            "            target = partial.get(\"target\")",
            "",
            "            if not target:",
            "                target = partial.get(\"key\")",
            "",
            "                if target:",
            "                    only_key = True",
            "",
            "            if not target:",
            "                target = partial.get(\"id\")",
            "",
            "                if target:",
            "                    only_id = True",
            "",
            "            assert target, \"Partial target is required\"",
            "",
            "            if not only_id:",
            "                for element in soup.find_all():",
            "                    if (",
            "                        \"unicorn:key\" in element.attrs",
            "                        and element.attrs[\"unicorn:key\"] == target",
            "                    ):",
            "                        partial_doms.append({\"key\": target, \"dom\": str(element)})",
            "                        partial_found = True",
            "                        break",
            "",
            "            if not partial_found and not only_key:",
            "                for element in soup.find_all():",
            "                    if \"id\" in element.attrs and element.attrs[\"id\"] == target:",
            "                        partial_doms.append({\"id\": target, \"dom\": str(element)})",
            "                        partial_found = True",
            "                        break",
            "",
            "    res = {",
            "        \"id\": component_request.id,",
            "        \"data\": updated_data,",
            "        \"errors\": component.errors,",
            "        \"calls\": component.calls,",
            "        \"checksum\": generate_checksum(orjson.dumps(component_request.data)),",
            "    }",
            "",
            "    if partial_doms:",
            "        res.update({\"partials\": partial_doms})",
            "    else:",
            "        hash = generate_checksum(rendered_component)",
            "",
            "        if (",
            "            component_request.hash == hash",
            "            and (not return_data or not return_data.value)",
            "            and not component.calls",
            "        ):",
            "            raise RenderNotModified()",
            "",
            "        # Make sure that partials with comments or blank lines before the root element only return the root element",
            "        soup = BeautifulSoup(rendered_component, features=\"html.parser\")",
            "        rendered_component = str(get_root_element(soup))",
            "",
            "        res.update(",
            "            {\"dom\": rendered_component, \"hash\": hash,}",
            "        )",
            "",
            "    if return_data:",
            "        res.update(",
            "            {\"return\": return_data.get_data(),}",
            "        )",
            "",
            "        if return_data.redirect:",
            "            res.update(",
            "                {\"redirect\": return_data.redirect,}",
            "            )",
            "",
            "        if return_data.poll:",
            "            res.update(",
            "                {\"poll\": return_data.poll,}",
            "            )",
            "",
            "    parent_component = component.parent",
            "",
            "    if parent_component:",
            "        # TODO: Should parent_component.hydrate() be called?",
            "        parent_frontend_context_variables = loads(",
            "            parent_component.get_frontend_context_variables()",
            "        )",
            "        parent_checksum = generate_checksum(dumps(parent_frontend_context_variables))",
            "",
            "        parent = {",
            "            \"id\": parent_component.component_id,",
            "            \"checksum\": parent_checksum,",
            "        }",
            "",
            "        if not partial_doms:",
            "            parent_dom = parent_component.render()",
            "            component.parent_rendered(parent_dom)",
            "",
            "            try:",
            "                cache.set(",
            "                    parent_component.component_cache_key,",
            "                    get_cacheable_component(parent_component),",
            "                )",
            "            except UnicornCacheError as e:",
            "                logger.warning(e)",
            "",
            "            parent.update(",
            "                {",
            "                    \"dom\": parent_dom,",
            "                    \"data\": parent_frontend_context_variables,",
            "                    \"errors\": parent_component.errors,",
            "                }",
            "            )",
            "",
            "        res.update({\"parent\": parent})",
            "",
            "    return res",
            "",
            "",
            "def _handle_component_request(",
            "    request: HttpRequest, component_request: ComponentRequest",
            ") -> Dict:",
            "    \"\"\"",
            "    Process a `ComponentRequest` by adding it to the cache and then either:",
            "        - processing all of the component requests in the cache and returning the resulting value if",
            "            it is the first component request for that particular component name + component id combination",
            "        - return a `dict` saying that the request has been queued",
            "    ",
            "    Args:",
            "        param request: HttpRequest for the function-based view.",
            "        param: component_request: Component request to process.",
            "    ",
            "    Returns:",
            "        `dict` with the following structure:",
            "        {",
            "            \"id\": component_id,",
            "            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed",
            "            \"data\": {},  // updated data after actions in the payload are completed",
            "            \"errors\": {},  // form validation errors",
            "            \"return\": {}, // optional return value from an executed action",
            "            \"parent\": {},  // optional representation of the parent component",
            "        }",
            "    \"\"\"",
            "    # If serial isn't enabled or the wrong cache, just process the request like normal",
            "    if not get_serial_enabled():",
            "        return _process_component_request(request, component_request)",
            "",
            "    cache = caches[get_cache_alias()]",
            "",
            "    # Add the current request `ComponentRequest` to the cache",
            "    queue_cache_key = f\"unicorn:queue:{component_request.id}\"",
            "    component_requests = cache.get(queue_cache_key) or []",
            "",
            "    # Remove `request` from `ComponentRequest` before caching because it is not pickleable",
            "    component_request.request = None",
            "    component_requests.append(component_request)",
            "",
            "    cache.set(",
            "        queue_cache_key, component_requests, timeout=get_serial_timeout(),",
            "    )",
            "",
            "    if len(component_requests) > 1:",
            "        original_epoch = component_requests[0].epoch",
            "        return {",
            "            \"queued\": True,",
            "            \"epoch\": component_request.epoch,",
            "            \"original_epoch\": original_epoch,",
            "        }",
            "",
            "    return _handle_queued_component_requests(",
            "        request, component_request.name, queue_cache_key",
            "    )",
            "",
            "",
            "def _handle_queued_component_requests(",
            "    request: HttpRequest, component_name: str, queue_cache_key",
            ") -> Dict:",
            "    \"\"\"",
            "    Process the current component requests that are stored in cache.",
            "    Also recursively checks for new requests that might have happened",
            "    while executing the first request, merges them together and returns",
            "    the correct appropriate data.",
            "",
            "    Args:",
            "        param request: HttpRequest for the view.",
            "        param: component_name: Name of the component, e.g. \"hello-world\".",
            "        param: queue_cache_key: Cache key created from component id which should be unique",
            "            for any particular user's request lifecycle.",
            "    ",
            "    Returns:",
            "        JSON with the following structure:",
            "        {",
            "            \"id\": component_id,",
            "            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed",
            "            \"data\": {},  // updated data after actions in the payload are completed",
            "            \"errors\": {},  // form validation errors",
            "            \"return\": {}, // optional return value from an executed action",
            "            \"parent\": {},  // optional representation of the parent component",
            "        }",
            "    \"\"\"",
            "    cache = caches[get_cache_alias()]",
            "",
            "    # Handle current request and any others in the cache by first sorting all of the current requests by ascending order",
            "    component_requests = cache.get(queue_cache_key)",
            "",
            "    if not component_requests or not isinstance(component_requests, list):",
            "        raise UnicornViewError(f\"No request found for {queue_cache_key}\")",
            "",
            "    component_requests = sorted(component_requests, key=lambda r: r.epoch)",
            "    first_component_request = component_requests[0]",
            "",
            "    try:",
            "        # Can't store request on a `ComponentRequest` and cache it because `HttpRequest` isn't pickleable",
            "        first_json_result = _process_component_request(request, first_component_request)",
            "    except RenderNotModified:",
            "        # Catching this and re-raising, but need the finally clause to clear the cache",
            "        raise",
            "    finally:",
            "        # Re-check for requests after the first request is processed",
            "        component_requests = cache.get(queue_cache_key)",
            "",
            "        # Check that the request is in the cache before popping it off",
            "        if component_requests:",
            "            component_requests.pop(0)",
            "            cache.set(",
            "                queue_cache_key, component_requests, timeout=get_serial_timeout(),",
            "            )",
            "",
            "    if component_requests:",
            "        # Create one new `component_request` from all of the queued requests that can be processed",
            "        merged_component_request = None",
            "",
            "        for additional_component_request in copy.deepcopy(component_requests):",
            "            if merged_component_request:",
            "                # Add new component request action queue to the merged component request",
            "                merged_component_request.action_queue.extend(",
            "                    additional_component_request.action_queue",
            "                )",
            "",
            "                # Originally, the thought was to merge the `additional_component_request.data` into",
            "                # the `merged_component_request.data`, but I can't figure out a way to do that in a sane",
            "                # manner. This means that for rapidly fired events that mutate `data`, that new",
            "                # `data` with be \"thrown away\".",
            "                # Relevant test: test_call_method_multiple.py::test_message_call_method_multiple_with_updated_data",
            "            else:",
            "                merged_component_request = additional_component_request",
            "",
            "                # Set new component request data from the first component request's resulting data",
            "                for key, val in first_json_result.get(\"data\", {}).items():",
            "                    merged_component_request.data[key] = val",
            "",
            "            component_requests.pop(0)",
            "            cache.set(",
            "                queue_cache_key, component_requests, timeout=get_serial_timeout(),",
            "            )",
            "",
            "        merged_json_result = _handle_component_request(",
            "            request, merged_component_request",
            "        )",
            "",
            "        return merged_json_result",
            "",
            "    return first_json_result",
            "",
            "",
            "@timed",
            "@handle_error",
            "@csrf_protect",
            "@require_POST",
            "def message(request: HttpRequest, component_name: str = None) -> JsonResponse:",
            "    \"\"\"",
            "    Endpoint that instantiates the component and does the correct action",
            "    (set an attribute or call a method) depending on the JSON payload in the body.",
            "",
            "    Args:",
            "        param request: HttpRequest for the function-based view.",
            "        param: component_name: Name of the component, e.g. \"hello-world\".",
            "    ",
            "    Returns:",
            "        `JsonRequest` with the following structure in the body:",
            "        {",
            "            \"id\": component_id,",
            "            \"dom\": html,  // re-rendered version of the component after actions in the payload are completed",
            "            \"data\": {},  // updated data after actions in the payload are completed",
            "            \"errors\": {},  // form validation errors",
            "            \"return\": {}, // optional return value from an executed action",
            "            \"parent\": {},  // optional representation of the parent component",
            "        }",
            "    \"\"\"",
            "",
            "    assert component_name, \"Missing component name in url\"",
            "",
            "    component_request = ComponentRequest(request, component_name)",
            "    json_result = _handle_component_request(request, component_request)",
            "",
            "    return JsonResponse(json_result)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": []
        },
        "addLocation": []
    }
}