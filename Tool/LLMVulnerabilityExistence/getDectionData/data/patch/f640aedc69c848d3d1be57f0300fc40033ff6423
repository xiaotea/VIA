{
    "nautobot/core/settings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     \"xmpp\","
            },
            "1": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " ]"
            },
            "2": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# Banners to display to users. HTML is allowed."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+# Banners to display to users. Markdown and limited HTML are allowed."
            },
            "5": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " if \"NAUTOBOT_BANNER_BOTTOM\" in os.environ and os.environ[\"NAUTOBOT_BANNER_BOTTOM\"] != \"\":"
            },
            "6": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     BANNER_BOTTOM = os.environ[\"NAUTOBOT_BANNER_BOTTOM\"]"
            },
            "7": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " if \"NAUTOBOT_BANNER_LOGIN\" in os.environ and os.environ[\"NAUTOBOT_BANNER_LOGIN\"] != \"\":"
            },
            "8": {
                "beforePatchRowNumber": 686,
                "afterPatchRowNumber": 686,
                "PatchRowcode": "     ),"
            },
            "9": {
                "beforePatchRowNumber": 687,
                "afterPatchRowNumber": 687,
                "PatchRowcode": "     \"BANNER_BOTTOM\": ConstanceConfigItem("
            },
            "10": {
                "beforePatchRowNumber": 688,
                "afterPatchRowNumber": 688,
                "PatchRowcode": "         default=\"\","
            },
            "11": {
                "beforePatchRowNumber": 689,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=\"Custom HTML to display in a banner at the bottom of all pages.\","
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 689,
                "PatchRowcode": "+        help_text=\"Custom Markdown or limited HTML to display in a banner at the bottom of all pages.\","
            },
            "13": {
                "beforePatchRowNumber": 690,
                "afterPatchRowNumber": 690,
                "PatchRowcode": "     ),"
            },
            "14": {
                "beforePatchRowNumber": 691,
                "afterPatchRowNumber": 691,
                "PatchRowcode": "     \"BANNER_LOGIN\": ConstanceConfigItem("
            },
            "15": {
                "beforePatchRowNumber": 692,
                "afterPatchRowNumber": 692,
                "PatchRowcode": "         default=\"\","
            },
            "16": {
                "beforePatchRowNumber": 693,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=\"Custom HTML to display in a banner at the top of the login page.\","
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 693,
                "PatchRowcode": "+        help_text=\"Custom Markdown or limited HTML to display in a banner at the top of the login page.\","
            },
            "18": {
                "beforePatchRowNumber": 694,
                "afterPatchRowNumber": 694,
                "PatchRowcode": "     ),"
            },
            "19": {
                "beforePatchRowNumber": 695,
                "afterPatchRowNumber": 695,
                "PatchRowcode": "     \"BANNER_TOP\": ConstanceConfigItem("
            },
            "20": {
                "beforePatchRowNumber": 696,
                "afterPatchRowNumber": 696,
                "PatchRowcode": "         default=\"\","
            },
            "21": {
                "beforePatchRowNumber": 697,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=\"Custom HTML to display in a banner at the top of all pages.\","
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 697,
                "PatchRowcode": "+        help_text=\"Custom Markdown or limited HTML to display in a banner at the top of all pages.\","
            },
            "23": {
                "beforePatchRowNumber": 698,
                "afterPatchRowNumber": 698,
                "PatchRowcode": "     ),"
            },
            "24": {
                "beforePatchRowNumber": 699,
                "afterPatchRowNumber": 699,
                "PatchRowcode": "     \"CHANGELOG_RETENTION\": ConstanceConfigItem("
            },
            "25": {
                "beforePatchRowNumber": 700,
                "afterPatchRowNumber": 700,
                "PatchRowcode": "         default=90,"
            },
            "26": {
                "beforePatchRowNumber": 972,
                "afterPatchRowNumber": 972,
                "PatchRowcode": "         \"NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET\", None"
            },
            "27": {
                "beforePatchRowNumber": 973,
                "afterPatchRowNumber": 973,
                "PatchRowcode": "     ),  # bullet image used for various view headers"
            },
            "28": {
                "beforePatchRowNumber": 974,
                "afterPatchRowNumber": 974,
                "PatchRowcode": "     \"nav_bullet\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET\", None),  # bullet image used for nav menu headers"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 975,
                "PatchRowcode": "+    \"css\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_CSS\", None),  # Custom global CSS"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 976,
                "PatchRowcode": "+    \"javascript\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_JAVASCRIPT\", None),  # Custom global JavaScript"
            },
            "31": {
                "beforePatchRowNumber": 975,
                "afterPatchRowNumber": 977,
                "PatchRowcode": " }"
            },
            "32": {
                "beforePatchRowNumber": 976,
                "afterPatchRowNumber": 978,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 977,
                "afterPatchRowNumber": 979,
                "PatchRowcode": " # Title to use in place of \"Nautobot\""
            }
        },
        "frontPatchFile": [
            "import os",
            "import os.path",
            "import platform",
            "import re",
            "import sys",
            "import tempfile",
            "",
            "from django.contrib.messages import constants as messages",
            "import django.forms",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot import __version__",
            "from nautobot.core.constants import CONFIG_SETTING_SEPARATOR as _CONFIG_SETTING_SEPARATOR",
            "from nautobot.core.settings_funcs import ConstanceConfigItem, is_truthy, parse_redis_connection",
            "",
            "#",
            "# Environment setup",
            "#",
            "",
            "# This is used for display in the UI. There are also VERSION_MAJOR and VERSION_MINOR derived from this later.",
            "VERSION = __version__",
            "",
            "# Hostname of the system. This is displayed in the web UI footers along with the",
            "# version.",
            "HOSTNAME = platform.node()",
            "",
            "# Set the base directory two levels up (i.e. the base nautobot/ directory)",
            "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))",
            "",
            "# Set the swapable User model to the Nautobot custom User model",
            "AUTH_USER_MODEL = \"users.User\"",
            "",
            "# Set the default AutoField for 3rd party apps",
            "# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions",
            "#      we can't do that yet",
            "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
            "",
            "",
            "###############################################################",
            "# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #",
            "###############################################################",
            "",
            "#",
            "# Nautobot optional settings/defaults",
            "#",
            "",
            "# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)",
            "NAUTOBOT_ROOT = os.getenv(\"NAUTOBOT_ROOT\", os.path.expanduser(\"~/.nautobot\"))",
            "",
            "# Allow users to enable request profiling via django-silk for admins to inspect.",
            "if \"NAUTOBOT_ALLOW_REQUEST_PROFILING\" in os.environ and os.environ[\"NAUTOBOT_ALLOW_REQUEST_PROFILING\"] != \"\":",
            "    ALLOW_REQUEST_PROFILING = is_truthy(os.environ[\"NAUTOBOT_ALLOW_REQUEST_PROFILING\"])",
            "",
            "# URL schemes that are allowed within links in Nautobot",
            "ALLOWED_URL_SCHEMES = [",
            "    \"file\",",
            "    \"ftp\",",
            "    \"ftps\",",
            "    \"http\",",
            "    \"https\",",
            "    \"irc\",",
            "    \"mailto\",",
            "    \"sftp\",",
            "    \"ssh\",",
            "    \"tel\",",
            "    \"telnet\",",
            "    \"tftp\",",
            "    \"vnc\",",
            "    \"xmpp\",",
            "]",
            "",
            "# Banners to display to users. HTML is allowed.",
            "if \"NAUTOBOT_BANNER_BOTTOM\" in os.environ and os.environ[\"NAUTOBOT_BANNER_BOTTOM\"] != \"\":",
            "    BANNER_BOTTOM = os.environ[\"NAUTOBOT_BANNER_BOTTOM\"]",
            "if \"NAUTOBOT_BANNER_LOGIN\" in os.environ and os.environ[\"NAUTOBOT_BANNER_LOGIN\"] != \"\":",
            "    BANNER_LOGIN = os.environ[\"NAUTOBOT_BANNER_LOGIN\"]",
            "if \"NAUTOBOT_BANNER_TOP\" in os.environ and os.environ[\"NAUTOBOT_BANNER_TOP\"] != \"\":",
            "    BANNER_TOP = os.environ[\"NAUTOBOT_BANNER_TOP\"]",
            "",
            "# Number of days to retain changelog entries. Set to 0 to retain changes indefinitely. Defaults to 90 if not set here.",
            "if \"NAUTOBOT_CHANGELOG_RETENTION\" in os.environ and os.environ[\"NAUTOBOT_CHANGELOG_RETENTION\"] != \"\":",
            "    CHANGELOG_RETENTION = int(os.environ[\"NAUTOBOT_CHANGELOG_RETENTION\"])",
            "",
            "# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts",
            "# when a large number of dynamic groups are present",
            "CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED\", \"False\"))",
            "",
            "# UUID uniquely but anonymously identifying this Nautobot deployment.",
            "if \"NAUTOBOT_DEPLOYMENT_ID\" in os.environ and os.environ[\"NAUTOBOT_DEPLOYMENT_ID\"] != \"\":",
            "    DEPLOYMENT_ID = os.environ[\"NAUTOBOT_DEPLOYMENT_ID\"]",
            "",
            "# Device names are not guaranteed globally-unique by Nautobot but in practice they often are.",
            "# Set this to True to use the device name alone as the natural key for Device objects.",
            "# Set this to False to use the sequence (name, tenant, location) as the natural key instead.",
            "#",
            "if \"NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY\" in os.environ and os.environ[\"NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY\"] != \"\":",
            "    DEVICE_NAME_AS_NATURAL_KEY = is_truthy(os.environ[\"NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY\"])",
            "",
            "# The number of seconds to cache the member list of dynamic groups. Set this to `0` to disable caching.",
            "if (",
            "    \"NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\" in os.environ",
            "    and os.environ[\"NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"] != \"\"",
            "):",
            "    DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT = int(os.environ[\"NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"])",
            "",
            "# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted",
            "# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.",
            "EXEMPT_EXCLUDE_MODELS = (",
            "    (\"auth\", \"group\"),",
            "    (\"users\", \"user\"),",
            "    (\"users\", \"objectpermission\"),",
            ")",
            "",
            "# Models to exempt from the enforcement of view permissions",
            "EXEMPT_VIEW_PERMISSIONS = []",
            "",
            "# The file path to a directory where cloned Git repositories will be located",
            "GIT_ROOT = os.getenv(\"NAUTOBOT_GIT_ROOT\", os.path.join(NAUTOBOT_ROOT, \"git\").rstrip(\"/\"))",
            "",
            "# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)",
            "HTTP_PROXIES = None",
            "",
            "# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run",
            "INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_INSTALLATION_METRICS_ENABLED\", \"True\"))",
            "",
            "# Maximum file size (in bytes) that as running Job can create in a call to `Job.create_file()`. Default is 10 << 20",
            "if \"NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE\" in os.environ and os.environ[\"NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE\"] != \"\":",
            "    JOB_CREATE_FILE_MAX_SIZE = int(os.environ[\"NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE\"])",
            "",
            "# The storage backend to use for Job input files and Job output files",
            "JOB_FILE_IO_STORAGE = os.getenv(\"NAUTOBOT_JOB_FILE_IO_STORAGE\", \"db_file_storage.storage.DatabaseFileStorage\")",
            "",
            "# The file path to a directory where locally installed Jobs can be discovered",
            "JOBS_ROOT = os.getenv(\"NAUTOBOT_JOBS_ROOT\", os.path.join(NAUTOBOT_ROOT, \"jobs\").rstrip(\"/\"))",
            "",
            "# `Location` names are not guaranteed globally-unique by Nautobot but in practice they often are.",
            "# Set this to `True` to use the location `name` alone as the natural key for `Location` objects.",
            "# Set this to `False` to use the sequence `(name, parent__name, parent__parent__name, ...)` as the natural key instead.",
            "if \"NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY\" in os.environ and os.environ[\"NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY\"] != \"\":",
            "    LOCATION_NAME_AS_NATURAL_KEY = is_truthy(os.environ[\"NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY\"])",
            "",
            "",
            "# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True",
            "LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv(\"NAUTOBOT_LOG_DEPRECATION_WARNINGS\", \"False\"))",
            "",
            "# Setting this to True will display a \"maintenance mode\" banner at the top of every page.",
            "MAINTENANCE_MODE = is_truthy(os.getenv(\"NAUTOBOT_MAINTENANCE_MODE\", \"False\"))",
            "",
            "# Maximum number of objects that the UI and API will retrieve in a single request. Default is 1000",
            "if \"NAUTOBOT_MAX_PAGE_SIZE\" in os.environ and os.environ[\"NAUTOBOT_MAX_PAGE_SIZE\"] != \"\":",
            "    MAX_PAGE_SIZE = int(os.environ[\"NAUTOBOT_MAX_PAGE_SIZE\"])",
            "",
            "# Metrics",
            "METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_ENABLED\", \"False\"))",
            "METRICS_AUTHENTICATED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_AUTHENTICATED\", \"False\"))",
            "METRICS_DISABLED_APPS = []",
            "if \"NAUTOBOT_METRICS_DISABLED_APPS\" in os.environ and os.environ[\"NAUTOBOT_METRICS_DISABLED_APPS\"] != \"\":",
            "    METRICS_DISABLED_APPS = os.getenv(\"NAUTOBOT_METRICS_DISABLED_APPS\", \"\").split(_CONFIG_SETTING_SEPARATOR)",
            "",
            "# Napalm",
            "NAPALM_ARGS = {}",
            "NAPALM_PASSWORD = os.getenv(\"NAUTOBOT_NAPALM_PASSWORD\", \"\")",
            "NAPALM_TIMEOUT = int(os.getenv(\"NAUTOBOT_NAPALM_TIMEOUT\", \"30\"))",
            "NAPALM_USERNAME = os.getenv(\"NAUTOBOT_NAPALM_USERNAME\", \"\")",
            "",
            "# Default number of objects to display per page of the UI and REST API. Default is 50",
            "if \"NAUTOBOT_PAGINATE_COUNT\" in os.environ and os.environ[\"NAUTOBOT_PAGINATE_COUNT\"] != \"\":",
            "    PAGINATE_COUNT = int(os.environ[\"NAUTOBOT_PAGINATE_COUNT\"])",
            "",
            "# The options displayed in the web interface dropdown to limit the number of objects per page.",
            "# Default is [25, 50, 100, 250, 500, 1000]",
            "if \"NAUTOBOT_PER_PAGE_DEFAULTS\" in os.environ and os.environ[\"NAUTOBOT_PER_PAGE_DEFAULTS\"] != \"\":",
            "    PER_PAGE_DEFAULTS = [int(val) for val in os.environ[\"NAUTOBOT_PER_PAGE_DEFAULTS\"].split(_CONFIG_SETTING_SEPARATOR)]",
            "",
            "# Plugins",
            "PLUGINS = []",
            "PLUGINS_CONFIG = {}",
            "",
            "# Prefer IPv6 addresses or IPv4 addresses in selecting a device's primary IP address? Default False",
            "if \"NAUTOBOT_PREFER_IPV4\" in os.environ and os.environ[\"NAUTOBOT_PREFER_IPV4\"] != \"\":",
            "    PREFER_IPV4 = is_truthy(os.environ[\"NAUTOBOT_PREFER_IPV4\"])",
            "",
            "# Default height and width in pixels of a single rack unit in rendered rack elevations. Defaults are 22 and 220",
            "if (",
            "    \"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\" in os.environ",
            "    and os.environ[\"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\"] != \"\"",
            "):",
            "    RACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(os.environ[\"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\"])",
            "if (",
            "    \"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH\" in os.environ",
            "    and os.environ[\"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"] != \"\"",
            "):",
            "    RACK_ELEVATION_DEFAULT_UNIT_WIDTH = int(os.environ[\"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"])",
            "",
            "# Enable two-digit format for the rack unit numbering in rack elevations.",
            "if (",
            "    \"NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\" in os.environ",
            "    and os.environ[\"NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\"] != \"\"",
            "):",
            "    RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT = is_truthy(os.environ[\"NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\"])",
            "",
            "# How frequently to check for a new Nautobot release on GitHub, and the URL to check for this information.",
            "# Defaults to disabled (no URL) and check every 24 hours when enabled",
            "if \"NAUTOBOT_RELEASE_CHECK_TIMEOUT\" in os.environ and os.environ[\"NAUTOBOT_RELEASE_CHECK_TIMEOUT\"] != \"\":",
            "    RELEASE_CHECK_TIMEOUT = int(os.environ[\"NAUTOBOT_RELEASE_CHECK_TIMEOUT\"])",
            "if \"NAUTOBOT_RELEASE_CHECK_URL\" in os.environ and os.environ[\"NAUTOBOT_RELEASE_CHECK_URL\"] != \"\":",
            "    RELEASE_CHECK_URL = os.environ[\"NAUTOBOT_RELEASE_CHECK_URL\"]",
            "",
            "# Global 3rd-party authentication settings",
            "EXTERNAL_AUTH_DEFAULT_GROUPS = []",
            "EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}",
            "",
            "# Remote auth backend settings",
            "REMOTE_AUTH_AUTO_CREATE_USER = False",
            "REMOTE_AUTH_HEADER = \"HTTP_REMOTE_USER\"",
            "",
            "# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html",
            "SOCIAL_AUTH_POSTGRES_JSONFIELD = False",
            "# Nautobot related - May be overridden if using custom social auth backend",
            "SOCIAL_AUTH_BACKEND_PREFIX = \"social_core.backends\"",
            "",
            "# Job log entry sanitization and similar",
            "SANITIZER_PATTERNS = [",
            "    # General removal of username-like and password-like tokens",
            "    (re.compile(r\"(https?://)?\\S+\\s*@\", re.IGNORECASE), r\"\\1{replacement}@\"),",
            "    (",
            "        re.compile(r\"(username|password|passwd|pwd|secret|secrets)([\\\"']?(?:\\s+is.?|:)?\\s+)\\S+[\\\"']?\", re.IGNORECASE),",
            "        r\"\\1\\2{replacement}\",",
            "    ),",
            "]",
            "",
            "# Storage",
            "STORAGE_BACKEND = None",
            "STORAGE_CONFIG = {}",
            "",
            "# Custom message to display on 4xx and 5xx error pages. Markdown and HTML are supported.",
            "# Default message directs the user to #nautobot on NTC's Slack community.",
            "if \"NAUTOBOT_SUPPORT_MESSAGE\" in os.environ and os.environ[\"NAUTOBOT_SUPPORT_MESSAGE\"] != \"\":",
            "    SUPPORT_MESSAGE = os.environ[\"NAUTOBOT_SUPPORT_MESSAGE\"]",
            "",
            "# Test runner that is aware of our use of \"integration\" tags and only runs",
            "# integration tests if explicitly passed in with `nautobot-server test --tag integration`.",
            "TEST_RUNNER = \"nautobot.core.tests.runner.NautobotTestRunner\"",
            "# Disable test data factories by default so as not to cause issues for plugins.",
            "# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.",
            "TEST_USE_FACTORIES = is_truthy(os.getenv(\"NAUTOBOT_TEST_USE_FACTORIES\", \"False\"))",
            "# Pseudo-random number generator seed, for reproducibility of test results.",
            "TEST_FACTORY_SEED = os.getenv(\"NAUTOBOT_TEST_FACTORY_SEED\", None)",
            "",
            "#",
            "# django-slowtests",
            "#",
            "",
            "# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.",
            "# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command",
            "# will automatically opt to NautobotPerformanceTestRunner to run the tests.",
            "",
            "# The baseline file that the performance test is running against",
            "# TODO we need to replace the baselines in this file with more consistent results at least for CI",
            "TEST_PERFORMANCE_BASELINE_FILE = os.getenv(",
            "    \"NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE\", \"nautobot/core/tests/performance_baselines.yml\"",
            ")",
            "",
            "#",
            "# Django Prometheus",
            "#",
            "",
            "PROMETHEUS_EXPORT_MIGRATIONS = False",
            "",
            "",
            "#",
            "# Django filters",
            "#",
            "",
            "FILTERS_NULL_CHOICE_LABEL = \"None\"",
            "FILTERS_NULL_CHOICE_VALUE = \"null\"",
            "",
            "STRICT_FILTERING = is_truthy(os.getenv(\"NAUTOBOT_STRICT_FILTERING\", \"True\"))",
            "",
            "#",
            "# Django REST framework (API)",
            "#",
            "",
            "REST_FRAMEWORK_VERSION = VERSION.rsplit(\".\", 1)[0]  # Use major.minor as API version",
            "VERSION_MAJOR, VERSION_MINOR = [int(v) for v in REST_FRAMEWORK_VERSION.split(\".\")]",
            "# We support all major.minor API versions from 2.0 to the present latest version.",
            "# Similar logic exists in tasks.py, please keep them in sync!",
            "if VERSION_MAJOR != 2:",
            "    raise RuntimeError(f\"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {VERSION_MAJOR}\")",
            "REST_FRAMEWORK_ALLOWED_VERSIONS = [f\"{VERSION_MAJOR}.{minor}\" for minor in range(0, VERSION_MINOR + 1)]",
            "",
            "REST_FRAMEWORK = {",
            "    \"ALLOWED_VERSIONS\": REST_FRAMEWORK_ALLOWED_VERSIONS,",
            "    \"DEFAULT_AUTHENTICATION_CLASSES\": (",
            "        \"rest_framework.authentication.SessionAuthentication\",",
            "        \"nautobot.core.api.authentication.TokenAuthentication\",",
            "    ),",
            "    \"DEFAULT_FILTER_BACKENDS\": (",
            "        \"nautobot.core.api.filter_backends.NautobotFilterBackend\",",
            "        \"nautobot.core.api.filter_backends.NautobotOrderingFilter\",",
            "    ),",
            "    \"DEFAULT_METADATA_CLASS\": \"nautobot.core.api.metadata.NautobotMetadata\",",
            "    \"DEFAULT_PAGINATION_CLASS\": \"nautobot.core.api.pagination.OptionalLimitOffsetPagination\",",
            "    \"DEFAULT_PERMISSION_CLASSES\": (\"nautobot.core.api.authentication.TokenPermissions\",),",
            "    \"DEFAULT_RENDERER_CLASSES\": (",
            "        \"nautobot.core.api.renderers.NautobotJSONRenderer\",",
            "        \"nautobot.core.api.renderers.FormlessBrowsableAPIRenderer\",",
            "        \"nautobot.core.api.renderers.NautobotCSVRenderer\",",
            "    ),",
            "    \"DEFAULT_PARSER_CLASSES\": (",
            "        \"rest_framework.parsers.JSONParser\",",
            "        \"nautobot.core.api.parsers.NautobotCSVParser\",",
            "    ),",
            "    \"DEFAULT_SCHEMA_CLASS\": \"nautobot.core.api.schema.NautobotAutoSchema\",",
            "    # Version to use if the client doesn't request otherwise. Default to current (i.e. latest)",
            "    \"DEFAULT_VERSION\": REST_FRAMEWORK_VERSION,",
            "    \"DEFAULT_VERSIONING_CLASS\": \"nautobot.core.api.versioning.NautobotAPIVersioning\",",
            "    \"ORDERING_PARAM\": \"sort\",  # This is not meant to be changed by users, but is used internally by the API",
            "    \"PAGE_SIZE\": None,",
            "    \"SCHEMA_COERCE_METHOD_NAMES\": {",
            "        # Default mappings",
            "        \"retrieve\": \"read\",",
            "        \"destroy\": \"delete\",",
            "        # Custom operations",
            "        \"bulk_destroy\": \"bulk_delete\",",
            "    },",
            "    \"VIEW_NAME_FUNCTION\": \"nautobot.core.api.utils.get_view_name\",",
            "}",
            "",
            "",
            "#",
            "# drf_spectacular (OpenAPI/Swagger)",
            "#",
            "",
            "SPECTACULAR_SETTINGS = {",
            "    \"TITLE\": \"API Documentation\",",
            "    \"DESCRIPTION\": \"Source of truth and network automation platform\",",
            "    \"LICENSE\": {\"name\": \"Apache v2 License\"},",
            "    \"VERSION\": VERSION,",
            "    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where \"/api\" was a common \"basePath\"",
            "    # in the schema.",
            "    # OpenAPI 3.0 removes \"basePath\" in favor of \"servers\", so we now declare \"/api\" as the server relative URL and",
            "    # trim it from all of the individual paths correspondingly.",
            "    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.",
            "    \"SERVERS\": [{\"url\": \"/api\"}],",
            "    \"SERVE_PERMISSIONS\": [\"rest_framework.permissions.IsAuthenticated\"],",
            "    \"SCHEMA_PATH_PREFIX\": \"/api\",",
            "    \"SCHEMA_PATH_PREFIX_TRIM\": True,",
            "    # use sidecar - locally packaged UI files, not CDN",
            "    \"SWAGGER_UI_DIST\": \"SIDECAR\",",
            "    \"SWAGGER_UI_FAVICON_HREF\": \"SIDECAR\",",
            "    \"SWAGGER_UI_SETTINGS\": {",
            "        \"deepLinking\": True,",
            "        \"displayOperationId\": True,",
            "    },",
            "    \"REDOC_DIST\": \"SIDECAR\",",
            "    # Do not list all possible enum values in the description of filter fields and the like",
            "    # In addition to being highly verbose, it's inaccurate for filter fields like *__ic and *__re",
            "    \"ENUM_GENERATE_CHOICE_DESCRIPTION\": False,",
            "    \"ENUM_NAME_OVERRIDES\": {",
            "        # These choice enums need to be overridden because they get assigned to the `type` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"type\".",
            "        \"CableTypeChoices\": \"nautobot.dcim.choices.CableTypeChoices\",",
            "        \"ConsolePortTypeChoices\": \"nautobot.dcim.choices.ConsolePortTypeChoices\",",
            "        \"CustomFieldTypeChoices\": \"nautobot.extras.choices.CustomFieldTypeChoices\",",
            "        \"InterfaceTypeChoices\": \"nautobot.dcim.choices.InterfaceTypeChoices\",",
            "        \"IPAddressTypeChoices\": \"nautobot.ipam.choices.IPAddressTypeChoices\",",
            "        \"PortTypeChoices\": \"nautobot.dcim.choices.PortTypeChoices\",",
            "        \"PowerFeedTypeChoices\": \"nautobot.dcim.choices.PowerFeedTypeChoices\",",
            "        \"PowerOutletTypeChoices\": \"nautobot.dcim.choices.PowerOutletTypeChoices\",",
            "        \"PowerPortTypeChoices\": \"nautobot.dcim.choices.PowerPortTypeChoices\",",
            "        \"PrefixTypeChoices\": \"nautobot.ipam.choices.PrefixTypeChoices\",",
            "        \"RackTypeChoices\": \"nautobot.dcim.choices.RackTypeChoices\",",
            "        \"RelationshipTypeChoices\": \"nautobot.extras.choices.RelationshipTypeChoices\",",
            "        # These choice enums need to be overridden because they get assigned to different names with the same choice set and",
            "        # result in this error:",
            "        #   encountered multiple names for the same choice set",
            "        \"JobExecutionTypeIntervalChoices\": \"nautobot.extras.choices.JobExecutionType\",",
            "        # These choice enums need to be overridden because they get assigned to the `protocol` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"protocol\".",
            "        \"InterfaceRedundancyGroupProtocolChoices\": \"nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices\",",
            "        \"ServiceProtocolChoices\": \"nautobot.ipam.choices.ServiceProtocolChoices\",",
            "    },",
            "    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)",
            "    \"COMPONENT_SPLIT_PATCH\": True,",
            "    # Create separate schema components for request vs response where appropriate",
            "    \"COMPONENT_SPLIT_REQUEST\": True,",
            "}",
            "",
            "",
            "##############################################",
            "# DJANGO - Core settings required for Django #",
            "##############################################",
            "",
            "#",
            "# Databases",
            "#",
            "",
            "DATABASES = {",
            "    \"default\": {",
            "        \"NAME\": os.getenv(\"NAUTOBOT_DB_NAME\", \"nautobot\"),",
            "        \"USER\": os.getenv(\"NAUTOBOT_DB_USER\", \"\"),",
            "        \"PASSWORD\": os.getenv(\"NAUTOBOT_DB_PASSWORD\", \"\"),",
            "        \"HOST\": os.getenv(\"NAUTOBOT_DB_HOST\", \"localhost\"),",
            "        \"PORT\": os.getenv(\"NAUTOBOT_DB_PORT\", \"\"),",
            "        \"CONN_MAX_AGE\": int(os.getenv(\"NAUTOBOT_DB_TIMEOUT\", \"300\")),",
            "        \"ENGINE\": os.getenv(",
            "            \"NAUTOBOT_DB_ENGINE\",",
            "            \"django_prometheus.db.backends.postgresql\" if METRICS_ENABLED else \"django.db.backends.postgresql\",",
            "        ),",
            "    }",
            "}",
            "",
            "# Ensure proper Unicode handling for MySQL",
            "if DATABASES[\"default\"][\"ENGINE\"] == \"django.db.backends.mysql\":",
            "    DATABASES[\"default\"][\"OPTIONS\"] = {\"charset\": \"utf8mb4\"}",
            "",
            "# The secret key is used to encrypt session keys and salt passwords.",
            "SECRET_KEY = os.getenv(\"NAUTOBOT_SECRET_KEY\", \"\")",
            "",
            "# Default overrides",
            "if \"NAUTOBOT_ALLOWED_HOSTS\" in os.environ and os.environ[\"NAUTOBOT_ALLOWED_HOSTS\"] != \"\":",
            "    ALLOWED_HOSTS = os.environ[\"NAUTOBOT_ALLOWED_HOSTS\"].split(\" \")",
            "else:",
            "    ALLOWED_HOSTS = []",
            "CSRF_TRUSTED_ORIGINS = []",
            "CSRF_FAILURE_VIEW = \"nautobot.core.views.csrf_failure\"",
            "DATE_FORMAT = os.getenv(\"NAUTOBOT_DATE_FORMAT\", \"N j, Y\")",
            "DATETIME_FORMAT = os.getenv(\"NAUTOBOT_DATETIME_FORMAT\", \"N j, Y g:i a\")",
            "DEBUG = is_truthy(os.getenv(\"NAUTOBOT_DEBUG\", \"False\"))",
            "INTERNAL_IPS = [\"127.0.0.1\", \"::1\"]",
            "FORCE_SCRIPT_NAME = None",
            "",
            "TESTING = \"test\" in sys.argv",
            "",
            "LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"",
            "",
            "if TESTING:",
            "    # Log to null handler instead of stderr during testing",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"handlers\": {\"console\": {\"level\": \"INFO\", \"class\": \"logging.NullHandler\"}},",
            "        \"loggers\": {\"nautobot\": {\"handlers\": [\"console\"], \"level\": \"INFO\"}},",
            "    }",
            "else:",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"formatters\": {",
            "            \"normal\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "            \"verbose\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "        },",
            "        \"handlers\": {",
            "            \"normal_console\": {",
            "                \"level\": \"INFO\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"normal\",",
            "            },",
            "            \"verbose_console\": {",
            "                \"level\": \"DEBUG\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"verbose\",",
            "            },",
            "        },",
            "        \"loggers\": {",
            "            \"django\": {\"handlers\": [\"normal_console\"], \"level\": \"INFO\"},",
            "            \"nautobot\": {",
            "                \"handlers\": [\"verbose_console\" if DEBUG else \"normal_console\"],",
            "                \"level\": LOG_LEVEL,",
            "            },",
            "        },",
            "    }",
            "",
            "MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, \"media\").rstrip(\"/\")",
            "SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv(\"NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE\", \"False\"))",
            "SESSION_COOKIE_AGE = int(os.getenv(\"NAUTOBOT_SESSION_COOKIE_AGE\", \"1209600\"))  # 2 weeks, in seconds",
            "SESSION_FILE_PATH = os.getenv(\"NAUTOBOT_SESSION_FILE_PATH\", None)",
            "SHORT_DATE_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATE_FORMAT\", \"Y-m-d\")",
            "SHORT_DATETIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")",
            "TIME_FORMAT = os.getenv(\"NAUTOBOT_TIME_FORMAT\", \"g:i a\")",
            "TIME_ZONE = os.getenv(\"NAUTOBOT_TIME_ZONE\", \"UTC\")",
            "",
            "# Disable importing the WSGI module before starting the server application. This is required for",
            "# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.",
            "WEBSERVER_WARMUP = False",
            "",
            "# Installed apps and Django plugins. Nautobot plugins will be appended here later.",
            "INSTALLED_APPS = [",
            "    \"django.contrib.auth\",",
            "    \"django.contrib.contenttypes\",",
            "    \"django.contrib.sessions\",",
            "    \"django.contrib.messages\",",
            "    \"django.contrib.staticfiles\",",
            "    \"django.contrib.humanize\",",
            "    \"corsheaders\",",
            "    \"django_filters\",",
            "    \"django_jinja\",",
            "    \"django_tables2\",",
            "    \"django_prometheus\",",
            "    \"social_django\",",
            "    \"taggit\",",
            "    \"timezone_field\",",
            "    \"nautobot.core.apps.NautobotConstanceConfig\",  # overridden form of \"constance\" AppConfig",
            "    \"nautobot.core\",",
            "    \"django.contrib.admin\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_beat\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_results\",",
            "    \"rest_framework\",  # Must be after `nautobot.core` for template overrides",
            "    \"db_file_storage\",",
            "    \"nautobot.circuits\",",
            "    \"nautobot.dcim\",",
            "    \"nautobot.ipam\",",
            "    \"nautobot.extras\",",
            "    \"nautobot.tenancy\",",
            "    \"nautobot.users\",",
            "    \"nautobot.virtualization\",",
            "    \"drf_spectacular\",",
            "    \"drf_spectacular_sidecar\",",
            "    \"graphene_django\",",
            "    \"health_check\",",
            "    \"health_check.storage\",",
            "    # We have custom implementations of these in nautobot.extras.health_checks:",
            "    # \"health_check.db\",",
            "    # \"health_check.contrib.migrations\",",
            "    # \"health_check.contrib.redis\",",
            "    \"django_extensions\",",
            "    \"constance.backends.database\",",
            "    \"django_ajax_tables\",",
            "    \"silk\",",
            "]",
            "",
            "# Middleware",
            "MIDDLEWARE = [",
            "    \"django_prometheus.middleware.PrometheusBeforeMiddleware\",",
            "    \"corsheaders.middleware.CorsMiddleware\",",
            "    \"django.contrib.sessions.middleware.SessionMiddleware\",",
            "    \"silk.middleware.SilkyMiddleware\",",
            "    \"django.middleware.common.CommonMiddleware\",",
            "    \"django.middleware.csrf.CsrfViewMiddleware\",",
            "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",",
            "    \"django.contrib.messages.middleware.MessageMiddleware\",",
            "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",",
            "    \"django.middleware.security.SecurityMiddleware\",",
            "    \"nautobot.core.middleware.ExceptionHandlingMiddleware\",",
            "    \"nautobot.core.middleware.RemoteUserMiddleware\",",
            "    \"nautobot.core.middleware.ExternalAuthMiddleware\",",
            "    \"nautobot.core.middleware.ObjectChangeMiddleware\",",
            "    \"django_prometheus.middleware.PrometheusAfterMiddleware\",",
            "]",
            "",
            "ROOT_URLCONF = \"nautobot.core.urls\"",
            "",
            "TEMPLATES = [",
            "    {",
            "        \"NAME\": \"django\",",
            "        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": True,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "        },",
            "    },",
            "    {",
            "        \"NAME\": \"jinja\",",
            "        \"BACKEND\": \"django_jinja.backend.Jinja2\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": False,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "            \"environment\": \"jinja2.sandbox.SandboxedEnvironment\",",
            "        },",
            "    },",
            "]",
            "",
            "# Set up authentication backends",
            "AUTHENTICATION_BACKENDS = [",
            "    # Always check object permissions",
            "    \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "]",
            "",
            "# Internationalization",
            "LANGUAGE_CODE = \"en-us\"",
            "USE_I18N = True",
            "USE_TZ = True",
            "",
            "# WSGI",
            "WSGI_APPLICATION = \"nautobot.core.wsgi.application\"",
            "SECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")",
            "USE_X_FORWARDED_HOST = True",
            "X_FRAME_OPTIONS = \"DENY\"",
            "",
            "# Static files (CSS, JavaScript, Images)",
            "STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, \"static\")",
            "STATIC_URL = \"static/\"",
            "STATICFILES_DIRS = (os.path.join(BASE_DIR, \"project-static\"),)",
            "",
            "# Media",
            "MEDIA_URL = \"media/\"",
            "",
            "# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)",
            "DATA_UPLOAD_MAX_NUMBER_FIELDS = None",
            "",
            "# Messages",
            "MESSAGE_TAGS = {",
            "    messages.ERROR: \"danger\",",
            "}",
            "",
            "# Authentication URLs",
            "# This is the URL route name for the login view.",
            "LOGIN_URL = \"login\"",
            "",
            "# This is the URL route name for the home page (index) view.",
            "LOGIN_REDIRECT_URL = \"home\"",
            "",
            "#",
            "# django-constance",
            "#",
            "",
            "CONSTANCE_BACKEND = \"constance.backends.database.DatabaseBackend\"",
            "CONSTANCE_DATABASE_PREFIX = \"constance:nautobot:\"",
            "CONSTANCE_DATABASE_CACHE_BACKEND = \"default\"",
            "CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment",
            "",
            "CONSTANCE_ADDITIONAL_FIELDS = {",
            "    \"per_page_defaults_field\": [",
            "        \"nautobot.core.forms.fields.JSONArrayFormField\",",
            "        {",
            "            \"widget\": \"django.forms.TextInput\",",
            "            \"base_field\": django.forms.IntegerField(min_value=1),",
            "        },",
            "    ],",
            "    \"release_check_timeout_field\": [",
            "        \"django.forms.IntegerField\",",
            "        {",
            "            \"min_value\": 3600,",
            "        },",
            "    ],",
            "    \"release_check_url_field\": [",
            "        \"django.forms.URLField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "    \"optional_json_field\": [",
            "        \"django.forms.fields.JSONField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG = {",
            "    \"ALLOW_REQUEST_PROFILING\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Allow users to enable request profiling on their login session.\",",
            "        field_type=bool,",
            "    ),",
            "    \"BANNER_BOTTOM\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the bottom of all pages.\",",
            "    ),",
            "    \"BANNER_LOGIN\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the top of the login page.\",",
            "    ),",
            "    \"BANNER_TOP\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the top of all pages.\",",
            "    ),",
            "    \"CHANGELOG_RETENTION\": ConstanceConfigItem(",
            "        default=90,",
            "        help_text=\"Number of days to retain object changelog history.\\nSet this to 0 to retain changes indefinitely.\",",
            "        field_type=int,",
            "    ),",
            "    \"DEVICE_NAME_AS_NATURAL_KEY\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Device names are not guaranteed globally-unique by Nautobot but in practice they often are. \"",
            "        \"Set this to True to use the device name alone as the natural key for Device objects. \"",
            "        \"Set this to False to use the sequence (name, tenant, location) as the natural key instead.\",",
            "        field_type=bool,",
            "    ),",
            "    \"DEPLOYMENT_ID\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Randomly generated UUID used to identify this installation.\\n\"",
            "        \"Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.\",",
            "        field_type=str,",
            "    ),",
            "    \"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\": ConstanceConfigItem(",
            "        default=0,",
            "        help_text=\"Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list \"",
            "        \"will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very \"",
            "        \"expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the \"",
            "        \"member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.\",",
            "        field_type=int,",
            "    ),",
            "    \"JOB_CREATE_FILE_MAX_SIZE\": ConstanceConfigItem(",
            "        default=10 << 20,",
            "        help_text=mark_safe(  # noqa: S308  # suspicious-mark-safe-usage, but this is a static string so it's safe",
            "            \"Maximum size (in bytes) of any single file generated by a <code>Job.create_file()</code> call.\"",
            "        ),",
            "        field_type=int,",
            "    ),",
            "    \"LOCATION_NAME_AS_NATURAL_KEY\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Location names are not guaranteed globally-unique by Nautobot but in practice they often are. \"",
            "        \"Set this to True to use the location name alone as the natural key for Location objects. \"",
            "        \"Set this to False to use the sequence (name, parent__name, parent__parent__name, ...) \"",
            "        \"as the natural key instead.\",",
            "        field_type=bool,",
            "    ),",
            "    \"MAX_PAGE_SIZE\": ConstanceConfigItem(",
            "        default=1000,",
            "        help_text=\"Maximum number of objects that a user can list in one UI page or one API call.\\n\"",
            "        \"If set to 0, a user can retrieve an unlimited number of objects.\",",
            "        field_type=int,",
            "    ),",
            "    \"PAGINATE_COUNT\": ConstanceConfigItem(",
            "        default=50,",
            "        help_text=\"Default number of objects to display per page when listing objects in the UI and/or REST API.\",",
            "        field_type=int,",
            "    ),",
            "    \"PER_PAGE_DEFAULTS\": ConstanceConfigItem(",
            "        default=[25, 50, 100, 250, 500, 1000],",
            "        help_text=\"Pagination options to present to the user to choose amongst.\\n\"",
            "        \"For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.\",",
            "        # Use custom field type defined above",
            "        field_type=\"per_page_defaults_field\",",
            "    ),",
            "    \"NETWORK_DRIVERS\": ConstanceConfigItem(",
            "        default={},",
            "        help_text=mark_safe(  # noqa: S308  # suspicious-mark-safe-usage, but this is a static string so it's safe",
            "            \"Extend or override default Platform.network_driver translations provided by \"",
            "            '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '",
            "            \"Enter a dictionary in JSON format, for example:\\n\"",
            "            '<pre><code class=\"language-json\">{\\n'",
            "            '    \"netmiko\": {\"my_network_driver\": \"cisco_ios\"},\\n'",
            "            '    \"pyats\": {\"my_network_driver\": \"iosxe\"} \\n'",
            "            \"}</code></pre>\",",
            "        ),",
            "        # Use custom field type defined above",
            "        field_type=\"optional_json_field\",",
            "    ),",
            "    \"PREFER_IPV4\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.\",",
            "        field_type=bool,",
            "    ),",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\": ConstanceConfigItem(",
            "        default=22, help_text=\"Default height (in pixels) of a rack unit in a rack elevation diagram\", field_type=int",
            "    ),",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\": ConstanceConfigItem(",
            "        default=230, help_text=\"Default width (in pixels) of a rack unit in a rack elevation diagram\", field_type=int",
            "    ),",
            "    \"RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Enables two-digit format for the rack unit numbering in a rack elevation diagram\",",
            "        field_type=bool,",
            "    ),",
            "    \"RELEASE_CHECK_TIMEOUT\": ConstanceConfigItem(",
            "        default=24 * 3600,",
            "        help_text=\"Number of seconds (must be at least 3600, or one hour) to cache the result of a release check \"",
            "        \"before checking again for a new release.\",",
            "        # Use custom field type defined above",
            "        field_type=\"release_check_timeout_field\",",
            "    ),",
            "    \"RELEASE_CHECK_URL\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\\n\"",
            "        'This can be set to the official repository \"https://api.github.com/repos/nautobot/nautobot/releases\" or '",
            "        \"a custom fork.\\nSet this to an empty string to disable automatic update checks.\",",
            "        # Use custom field type defined above",
            "        field_type=\"release_check_url_field\",",
            "    ),",
            "    \"SUPPORT_MESSAGE\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Help message to include on 4xx and 5xx error pages. \"",
            "        \"Markdown is supported, as are some HTML tags and attributes.\\n\"",
            "        \"If unspecified, instructions to join Network to Code's Slack community will be provided.\",",
            "    ),",
            "}",
            "",
            "CONSTANCE_CONFIG_FIELDSETS = {",
            "    \"Banners\": [\"BANNER_LOGIN\", \"BANNER_TOP\", \"BANNER_BOTTOM\"],",
            "    \"Change Logging\": [\"CHANGELOG_RETENTION\"],",
            "    \"Device Connectivity\": [\"NETWORK_DRIVERS\", \"PREFER_IPV4\"],",
            "    \"Installation Metrics\": [\"DEPLOYMENT_ID\"],",
            "    \"Natural Keys\": [\"DEVICE_NAME_AS_NATURAL_KEY\", \"LOCATION_NAME_AS_NATURAL_KEY\"],",
            "    \"Pagination\": [\"PAGINATE_COUNT\", \"MAX_PAGE_SIZE\", \"PER_PAGE_DEFAULTS\"],",
            "    \"Performance\": [\"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\", \"JOB_CREATE_FILE_MAX_SIZE\"],",
            "    \"Rack Elevation Rendering\": [",
            "        \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\",",
            "        \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\",",
            "        \"RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\",",
            "    ],",
            "    \"Release Checking\": [\"RELEASE_CHECK_URL\", \"RELEASE_CHECK_TIMEOUT\"],",
            "    \"User Interface\": [\"SUPPORT_MESSAGE\"],",
            "    \"Debugging\": [\"ALLOW_REQUEST_PROFILING\"],",
            "}",
            "",
            "#",
            "# From django-cors-headers",
            "#",
            "",
            "# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.",
            "# Defaults to False. Setting this to True can be dangerous, as it allows any website to make",
            "# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with",
            "# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.",
            "CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv(\"NAUTOBOT_CORS_ALLOW_ALL_ORIGINS\", \"False\"))",
            "",
            "# A list of strings representing regexes that match Origins that are authorized to make cross-site",
            "# HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGIN_REGEXES = []",
            "",
            "# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGINS = []",
            "",
            "#",
            "# GraphQL",
            "#",
            "",
            "GRAPHENE = {",
            "    \"SCHEMA\": \"nautobot.core.graphql.schema_init.schema\",",
            "    \"DJANGO_CHOICE_FIELD_ENUM_V3_NAMING\": True,  # any field with a name of type will break in Graphene otherwise.",
            "}",
            "GRAPHQL_CUSTOM_FIELD_PREFIX = \"cf\"",
            "GRAPHQL_RELATIONSHIP_PREFIX = \"rel\"",
            "GRAPHQL_COMPUTED_FIELD_PREFIX = \"cpf\"",
            "",
            "",
            "#",
            "# Caching",
            "#",
            "",
            "# The django-redis cache is used to establish concurrent locks using Redis.",
            "CACHES = {",
            "    \"default\": {",
            "        \"BACKEND\": os.getenv(",
            "            \"NAUTOBOT_CACHES_BACKEND\",",
            "            \"django_prometheus.cache.backends.redis.RedisCache\" if METRICS_ENABLED else \"django_redis.cache.RedisCache\",",
            "        ),",
            "        \"LOCATION\": parse_redis_connection(redis_database=1),",
            "        \"TIMEOUT\": 300,",
            "        \"OPTIONS\": {",
            "            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",",
            "            \"PASSWORD\": \"\",",
            "        },",
            "    }",
            "}",
            "",
            "# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.",
            "CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv(\"NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT\", \"0\"))",
            "",
            "#",
            "# Celery (used for background processing)",
            "#",
            "",
            "# Celery Beat heartbeat file path - will be touched by Beat each time it wakes up as a proof-of-health.",
            "CELERY_BEAT_HEARTBEAT_FILE = os.getenv(",
            "    \"NAUTOBOT_CELERY_BEAT_HEARTBEAT_FILE\",",
            "    os.path.join(tempfile.gettempdir(), \"nautobot_celery_beat_heartbeat\"),",
            ")",
            "",
            "# Celery broker URL used to tell workers where queues are located",
            "CELERY_BROKER_URL = os.getenv(\"NAUTOBOT_CELERY_BROKER_URL\", parse_redis_connection(redis_database=0))",
            "",
            "# Celery results backend URL to tell workers where to publish task results - DO NOT CHANGE THIS",
            "CELERY_RESULT_BACKEND = \"nautobot.core.celery.backends.NautobotDatabaseBackend\"",
            "",
            "# Enables extended task result attributes (name, args, kwargs, worker, retries, queue, delivery_info) to be written to backend.",
            "CELERY_RESULT_EXTENDED = True",
            "",
            "# A value of None or 0 means results will never expire (depending on backend specifications).",
            "CELERY_RESULT_EXPIRES = None",
            "",
            "# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`",
            "CELERY_TASK_TRACK_STARTED = True",
            "",
            "# If enabled, a `task-sent` event will be sent for every task so tasks can be tracked before they're consumed by a worker.",
            "CELERY_TASK_SEND_SENT_EVENT = True",
            "",
            "# If enabled stdout and stderr of running jobs will be redirected to the task logger.",
            "CELERY_WORKER_REDIRECT_STDOUTS = is_truthy(os.getenv(\"NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS\", \"True\"))",
            "",
            "# The log level of log messages generated by redirected job stdout and stderr. Can be one of `DEBUG`, `INFO`, `WARNING`, `ERROR`, or `CRITICAL`.",
            "CELERY_WORKER_REDIRECT_STDOUTS_LEVEL = os.getenv(\"NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS_LEVEL\", \"WARNING\")",
            "",
            "# Send task-related events so that tasks can be monitored using tools like flower. Sets the default value for the workers -E argument.",
            "CELERY_WORKER_SEND_TASK_EVENTS = True",
            "",
            "# Default celery queue name that will be used by workers and tasks if no queue is specified",
            "CELERY_TASK_DEFAULT_QUEUE = os.getenv(\"NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE\", \"default\")",
            "",
            "# Global task time limits (seconds)",
            "# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,",
            "# while exceeding the hard limit will result in a SIGKILL.",
            "CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT\", str(5 * 60)))",
            "CELERY_TASK_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_TIME_LIMIT\", str(10 * 60)))",
            "",
            "# Ports for prometheus metric HTTP server running on the celery worker.",
            "# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.",
            "# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the",
            "# highest amount of workers you are running on a single machine (comma-separated, like \"8080,8081,8082\"). You can then",
            "# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in",
            "# that case. Set this to an empty string to disable it.",
            "CELERY_WORKER_PROMETHEUS_PORTS = []",
            "if os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\"):",
            "    CELERY_WORKER_PROMETHEUS_PORTS = [",
            "        int(value) for value in os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\").split(_CONFIG_SETTING_SEPARATOR)",
            "    ]",
            "",
            "# These settings define the custom nautobot serialization encoding as an accepted data encoding format",
            "# and register that format for task input and result serialization",
            "CELERY_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_RESULT_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_TASK_SERIALIZER = \"nautobot_json\"",
            "CELERY_RESULT_SERIALIZER = \"nautobot_json\"",
            "",
            "CELERY_BEAT_SCHEDULER = \"nautobot.core.celery.schedulers:NautobotDatabaseScheduler\"",
            "",
            "# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added",
            "# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`",
            "REDIS_LOCK_TIMEOUT = int(os.getenv(\"NAUTOBOT_REDIS_LOCK_TIMEOUT\", \"600\"))",
            "",
            "#",
            "# Custom branding (logo and title)",
            "#",
            "",
            "# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.",
            "# The filepath should be relative to the `MEDIA_ROOT`.",
            "BRANDING_FILEPATHS = {",
            "    \"logo\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_LOGO\", None),  # Navbar logo",
            "    \"favicon\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_FAVICON\", None),  # Browser favicon",
            "    \"icon_16\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_16\", None),  # 16x16px icon",
            "    \"icon_32\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_32\", None),  # 32x32px icon",
            "    \"icon_180\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_180\", None",
            "    ),  # 180x180px icon - used for the apple-touch-icon header",
            "    \"icon_192\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_192\", None),  # 192x192px icon",
            "    \"icon_mask\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK\", None",
            "    ),  # mono-chrome icon used for the mask-icon header",
            "    \"header_bullet\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET\", None",
            "    ),  # bullet image used for various view headers",
            "    \"nav_bullet\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET\", None),  # bullet image used for nav menu headers",
            "}",
            "",
            "# Title to use in place of \"Nautobot\"",
            "BRANDING_TITLE = os.getenv(\"NAUTOBOT_BRANDING_TITLE\", \"Nautobot\")",
            "",
            "# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)",
            "BRANDING_PREPENDED_FILENAME = os.getenv(\"NAUTOBOT_BRANDING_PREPENDED_FILENAME\", \"nautobot_\")",
            "",
            "# Branding URLs (links in the bottom right of the footer)",
            "BRANDING_URLS = {",
            "    \"code\": os.getenv(\"NAUTOBOT_BRANDING_URLS_CODE\", \"https://github.com/nautobot/nautobot\"),",
            "    \"docs\": os.getenv(\"NAUTOBOT_BRANDING_URLS_DOCS\", None),",
            "    \"help\": os.getenv(\"NAUTOBOT_BRANDING_URLS_HELP\", \"https://github.com/nautobot/nautobot/wiki\"),",
            "}",
            "",
            "# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.",
            "BRANDING_POWERED_BY_URL = \"https://docs.nautobot.com/\"",
            "",
            "#",
            "# Django extensions settings",
            "#",
            "",
            "# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models",
            "SHELL_PLUS_DONT_LOAD = [\"taggit\"]",
            "",
            "#",
            "# UI settings",
            "#",
            "",
            "",
            "# UI_RACK_VIEW_TRUNCATE_FUNCTION",
            "def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):",
            "    \"\"\"Given device display name, truncate to fit the rack elevation view.",
            "",
            "    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.",
            "    :type device_display_name: str",
            "",
            "    :return: Truncated device name",
            "    :type: str",
            "    \"\"\"",
            "    return str(device_display_name).split(\".\")[0]",
            "",
            "",
            "# Custom JSON schema serializer field type mappingss. These will be added to",
            "# `NautobotProcessingMixin.TYPE_MAP`.",
            "# Format: `{serializer_field_class.__name__}` => `{json_schema_type}`",
            "# See: https://github.com/yoyowallet/drf-react-template-framework#settings",
            "DRF_REACT_TEMPLATE_TYPE_MAP = {",
            "    \"ContentTypeField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    \"CustomFieldsDataField\": {\"type\": \"object\", \"widget\": \"textarea\"},",
            "    \"DateTimeField\": {\"type\": \"string\", \"format\": \"date-time\", \"widget\": \"date-time\"},",
            "    \"ImageField\": {\"type\": \"string\", \"format\": \"data-url\"},",
            "    \"IPFieldSerializer\": {\"type\": \"string\"},",
            "    \"JSONField\": {\"type\": \"string\", \"widget\": \"textarea\"},",
            "    \"MultipleChoiceJSONField\": {\"type\": \"array\", \"required\": [], \"enum\": \"choices\"},",
            "    \"ManyRelatedField\": {\"type\": \"array\", \"required\": []},",
            "    #",
            "    # Foreign Key fields",
            "    #",
            "    # enum=choices is the one that works in the UI as a related field but it",
            "    # includes ALL related objects in the schema.",
            "    # \"NautobotHyperlinkedRelatedField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    # readOnly=True disables the fields in the UI; not what we want.",
            "    # \"NautobotHyperlinkedRelatedField\": {\"type\": \"string\", \"readOnly\": True},",
            "    # type=string results in a free text field; also not what we want. For now,",
            "    # however, this will keep things moving so the unit tests pass.",
            "    \"NautobotHyperlinkedRelatedField\": {\"type\": \"object\"},",
            "    \"PrimaryKeyRelatedField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    \"RelationshipsDataField\": {\"type\": \"object\"},",
            "    \"SlugField\": {\"type\": \"string\"},",
            "    \"TimeZoneSerializerField\": {\"type\": \"string\"},",
            "    \"UUIDField\": {\"type\": \"string\", \"format\": \"uuid\"},",
            "}",
            "",
            "",
            "#",
            "# django-silk is used for optional request profiling for debugging purposes",
            "#",
            "",
            "SILKY_PYTHON_PROFILER = True",
            "SILKY_PYTHON_PROFILER_BINARY = True",
            "SILKY_PYTHON_PROFILER_EXTENDED_FILE_NAME = True",
            "SILKY_ANALYZE_QUERIES = False  # See the docs for the implications of turning this on https://github.com/jazzband/django-silk?tab=readme-ov-file#enable-query-analysis",
            "SILKY_AUTHENTICATION = True  # User must login",
            "SILKY_AUTHORISATION = True  # User must have permissions",
            "",
            "",
            "# This makes it so that only superusers can access the silk UI",
            "def silk_user_permissions(user):",
            "    return user.is_superuser",
            "",
            "",
            "SILKY_PERMISSIONS = silk_user_permissions",
            "",
            "",
            "# This ensures profiling only happens when enabled on the sessions. Users are able",
            "# to turn this on or off in their user profile. It also ignores health-check requests.",
            "def silk_request_logging_intercept_logic(request):",
            "    if request.path != \"/health/\":",
            "        if request.session.get(\"silk_record_requests\", False):",
            "            return True",
            "    return False",
            "",
            "",
            "SILKY_INTERCEPT_FUNC = silk_request_logging_intercept_logic"
        ],
        "afterPatchFile": [
            "import os",
            "import os.path",
            "import platform",
            "import re",
            "import sys",
            "import tempfile",
            "",
            "from django.contrib.messages import constants as messages",
            "import django.forms",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot import __version__",
            "from nautobot.core.constants import CONFIG_SETTING_SEPARATOR as _CONFIG_SETTING_SEPARATOR",
            "from nautobot.core.settings_funcs import ConstanceConfigItem, is_truthy, parse_redis_connection",
            "",
            "#",
            "# Environment setup",
            "#",
            "",
            "# This is used for display in the UI. There are also VERSION_MAJOR and VERSION_MINOR derived from this later.",
            "VERSION = __version__",
            "",
            "# Hostname of the system. This is displayed in the web UI footers along with the",
            "# version.",
            "HOSTNAME = platform.node()",
            "",
            "# Set the base directory two levels up (i.e. the base nautobot/ directory)",
            "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))",
            "",
            "# Set the swapable User model to the Nautobot custom User model",
            "AUTH_USER_MODEL = \"users.User\"",
            "",
            "# Set the default AutoField for 3rd party apps",
            "# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions",
            "#      we can't do that yet",
            "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
            "",
            "",
            "###############################################################",
            "# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #",
            "###############################################################",
            "",
            "#",
            "# Nautobot optional settings/defaults",
            "#",
            "",
            "# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)",
            "NAUTOBOT_ROOT = os.getenv(\"NAUTOBOT_ROOT\", os.path.expanduser(\"~/.nautobot\"))",
            "",
            "# Allow users to enable request profiling via django-silk for admins to inspect.",
            "if \"NAUTOBOT_ALLOW_REQUEST_PROFILING\" in os.environ and os.environ[\"NAUTOBOT_ALLOW_REQUEST_PROFILING\"] != \"\":",
            "    ALLOW_REQUEST_PROFILING = is_truthy(os.environ[\"NAUTOBOT_ALLOW_REQUEST_PROFILING\"])",
            "",
            "# URL schemes that are allowed within links in Nautobot",
            "ALLOWED_URL_SCHEMES = [",
            "    \"file\",",
            "    \"ftp\",",
            "    \"ftps\",",
            "    \"http\",",
            "    \"https\",",
            "    \"irc\",",
            "    \"mailto\",",
            "    \"sftp\",",
            "    \"ssh\",",
            "    \"tel\",",
            "    \"telnet\",",
            "    \"tftp\",",
            "    \"vnc\",",
            "    \"xmpp\",",
            "]",
            "",
            "# Banners to display to users. Markdown and limited HTML are allowed.",
            "if \"NAUTOBOT_BANNER_BOTTOM\" in os.environ and os.environ[\"NAUTOBOT_BANNER_BOTTOM\"] != \"\":",
            "    BANNER_BOTTOM = os.environ[\"NAUTOBOT_BANNER_BOTTOM\"]",
            "if \"NAUTOBOT_BANNER_LOGIN\" in os.environ and os.environ[\"NAUTOBOT_BANNER_LOGIN\"] != \"\":",
            "    BANNER_LOGIN = os.environ[\"NAUTOBOT_BANNER_LOGIN\"]",
            "if \"NAUTOBOT_BANNER_TOP\" in os.environ and os.environ[\"NAUTOBOT_BANNER_TOP\"] != \"\":",
            "    BANNER_TOP = os.environ[\"NAUTOBOT_BANNER_TOP\"]",
            "",
            "# Number of days to retain changelog entries. Set to 0 to retain changes indefinitely. Defaults to 90 if not set here.",
            "if \"NAUTOBOT_CHANGELOG_RETENTION\" in os.environ and os.environ[\"NAUTOBOT_CHANGELOG_RETENTION\"] != \"\":",
            "    CHANGELOG_RETENTION = int(os.environ[\"NAUTOBOT_CHANGELOG_RETENTION\"])",
            "",
            "# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts",
            "# when a large number of dynamic groups are present",
            "CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED\", \"False\"))",
            "",
            "# UUID uniquely but anonymously identifying this Nautobot deployment.",
            "if \"NAUTOBOT_DEPLOYMENT_ID\" in os.environ and os.environ[\"NAUTOBOT_DEPLOYMENT_ID\"] != \"\":",
            "    DEPLOYMENT_ID = os.environ[\"NAUTOBOT_DEPLOYMENT_ID\"]",
            "",
            "# Device names are not guaranteed globally-unique by Nautobot but in practice they often are.",
            "# Set this to True to use the device name alone as the natural key for Device objects.",
            "# Set this to False to use the sequence (name, tenant, location) as the natural key instead.",
            "#",
            "if \"NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY\" in os.environ and os.environ[\"NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY\"] != \"\":",
            "    DEVICE_NAME_AS_NATURAL_KEY = is_truthy(os.environ[\"NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY\"])",
            "",
            "# The number of seconds to cache the member list of dynamic groups. Set this to `0` to disable caching.",
            "if (",
            "    \"NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\" in os.environ",
            "    and os.environ[\"NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"] != \"\"",
            "):",
            "    DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT = int(os.environ[\"NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"])",
            "",
            "# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted",
            "# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.",
            "EXEMPT_EXCLUDE_MODELS = (",
            "    (\"auth\", \"group\"),",
            "    (\"users\", \"user\"),",
            "    (\"users\", \"objectpermission\"),",
            ")",
            "",
            "# Models to exempt from the enforcement of view permissions",
            "EXEMPT_VIEW_PERMISSIONS = []",
            "",
            "# The file path to a directory where cloned Git repositories will be located",
            "GIT_ROOT = os.getenv(\"NAUTOBOT_GIT_ROOT\", os.path.join(NAUTOBOT_ROOT, \"git\").rstrip(\"/\"))",
            "",
            "# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)",
            "HTTP_PROXIES = None",
            "",
            "# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run",
            "INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_INSTALLATION_METRICS_ENABLED\", \"True\"))",
            "",
            "# Maximum file size (in bytes) that as running Job can create in a call to `Job.create_file()`. Default is 10 << 20",
            "if \"NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE\" in os.environ and os.environ[\"NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE\"] != \"\":",
            "    JOB_CREATE_FILE_MAX_SIZE = int(os.environ[\"NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE\"])",
            "",
            "# The storage backend to use for Job input files and Job output files",
            "JOB_FILE_IO_STORAGE = os.getenv(\"NAUTOBOT_JOB_FILE_IO_STORAGE\", \"db_file_storage.storage.DatabaseFileStorage\")",
            "",
            "# The file path to a directory where locally installed Jobs can be discovered",
            "JOBS_ROOT = os.getenv(\"NAUTOBOT_JOBS_ROOT\", os.path.join(NAUTOBOT_ROOT, \"jobs\").rstrip(\"/\"))",
            "",
            "# `Location` names are not guaranteed globally-unique by Nautobot but in practice they often are.",
            "# Set this to `True` to use the location `name` alone as the natural key for `Location` objects.",
            "# Set this to `False` to use the sequence `(name, parent__name, parent__parent__name, ...)` as the natural key instead.",
            "if \"NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY\" in os.environ and os.environ[\"NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY\"] != \"\":",
            "    LOCATION_NAME_AS_NATURAL_KEY = is_truthy(os.environ[\"NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY\"])",
            "",
            "",
            "# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True",
            "LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv(\"NAUTOBOT_LOG_DEPRECATION_WARNINGS\", \"False\"))",
            "",
            "# Setting this to True will display a \"maintenance mode\" banner at the top of every page.",
            "MAINTENANCE_MODE = is_truthy(os.getenv(\"NAUTOBOT_MAINTENANCE_MODE\", \"False\"))",
            "",
            "# Maximum number of objects that the UI and API will retrieve in a single request. Default is 1000",
            "if \"NAUTOBOT_MAX_PAGE_SIZE\" in os.environ and os.environ[\"NAUTOBOT_MAX_PAGE_SIZE\"] != \"\":",
            "    MAX_PAGE_SIZE = int(os.environ[\"NAUTOBOT_MAX_PAGE_SIZE\"])",
            "",
            "# Metrics",
            "METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_ENABLED\", \"False\"))",
            "METRICS_AUTHENTICATED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_AUTHENTICATED\", \"False\"))",
            "METRICS_DISABLED_APPS = []",
            "if \"NAUTOBOT_METRICS_DISABLED_APPS\" in os.environ and os.environ[\"NAUTOBOT_METRICS_DISABLED_APPS\"] != \"\":",
            "    METRICS_DISABLED_APPS = os.getenv(\"NAUTOBOT_METRICS_DISABLED_APPS\", \"\").split(_CONFIG_SETTING_SEPARATOR)",
            "",
            "# Napalm",
            "NAPALM_ARGS = {}",
            "NAPALM_PASSWORD = os.getenv(\"NAUTOBOT_NAPALM_PASSWORD\", \"\")",
            "NAPALM_TIMEOUT = int(os.getenv(\"NAUTOBOT_NAPALM_TIMEOUT\", \"30\"))",
            "NAPALM_USERNAME = os.getenv(\"NAUTOBOT_NAPALM_USERNAME\", \"\")",
            "",
            "# Default number of objects to display per page of the UI and REST API. Default is 50",
            "if \"NAUTOBOT_PAGINATE_COUNT\" in os.environ and os.environ[\"NAUTOBOT_PAGINATE_COUNT\"] != \"\":",
            "    PAGINATE_COUNT = int(os.environ[\"NAUTOBOT_PAGINATE_COUNT\"])",
            "",
            "# The options displayed in the web interface dropdown to limit the number of objects per page.",
            "# Default is [25, 50, 100, 250, 500, 1000]",
            "if \"NAUTOBOT_PER_PAGE_DEFAULTS\" in os.environ and os.environ[\"NAUTOBOT_PER_PAGE_DEFAULTS\"] != \"\":",
            "    PER_PAGE_DEFAULTS = [int(val) for val in os.environ[\"NAUTOBOT_PER_PAGE_DEFAULTS\"].split(_CONFIG_SETTING_SEPARATOR)]",
            "",
            "# Plugins",
            "PLUGINS = []",
            "PLUGINS_CONFIG = {}",
            "",
            "# Prefer IPv6 addresses or IPv4 addresses in selecting a device's primary IP address? Default False",
            "if \"NAUTOBOT_PREFER_IPV4\" in os.environ and os.environ[\"NAUTOBOT_PREFER_IPV4\"] != \"\":",
            "    PREFER_IPV4 = is_truthy(os.environ[\"NAUTOBOT_PREFER_IPV4\"])",
            "",
            "# Default height and width in pixels of a single rack unit in rendered rack elevations. Defaults are 22 and 220",
            "if (",
            "    \"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\" in os.environ",
            "    and os.environ[\"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\"] != \"\"",
            "):",
            "    RACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(os.environ[\"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\"])",
            "if (",
            "    \"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH\" in os.environ",
            "    and os.environ[\"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"] != \"\"",
            "):",
            "    RACK_ELEVATION_DEFAULT_UNIT_WIDTH = int(os.environ[\"NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"])",
            "",
            "# Enable two-digit format for the rack unit numbering in rack elevations.",
            "if (",
            "    \"NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\" in os.environ",
            "    and os.environ[\"NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\"] != \"\"",
            "):",
            "    RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT = is_truthy(os.environ[\"NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\"])",
            "",
            "# How frequently to check for a new Nautobot release on GitHub, and the URL to check for this information.",
            "# Defaults to disabled (no URL) and check every 24 hours when enabled",
            "if \"NAUTOBOT_RELEASE_CHECK_TIMEOUT\" in os.environ and os.environ[\"NAUTOBOT_RELEASE_CHECK_TIMEOUT\"] != \"\":",
            "    RELEASE_CHECK_TIMEOUT = int(os.environ[\"NAUTOBOT_RELEASE_CHECK_TIMEOUT\"])",
            "if \"NAUTOBOT_RELEASE_CHECK_URL\" in os.environ and os.environ[\"NAUTOBOT_RELEASE_CHECK_URL\"] != \"\":",
            "    RELEASE_CHECK_URL = os.environ[\"NAUTOBOT_RELEASE_CHECK_URL\"]",
            "",
            "# Global 3rd-party authentication settings",
            "EXTERNAL_AUTH_DEFAULT_GROUPS = []",
            "EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}",
            "",
            "# Remote auth backend settings",
            "REMOTE_AUTH_AUTO_CREATE_USER = False",
            "REMOTE_AUTH_HEADER = \"HTTP_REMOTE_USER\"",
            "",
            "# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html",
            "SOCIAL_AUTH_POSTGRES_JSONFIELD = False",
            "# Nautobot related - May be overridden if using custom social auth backend",
            "SOCIAL_AUTH_BACKEND_PREFIX = \"social_core.backends\"",
            "",
            "# Job log entry sanitization and similar",
            "SANITIZER_PATTERNS = [",
            "    # General removal of username-like and password-like tokens",
            "    (re.compile(r\"(https?://)?\\S+\\s*@\", re.IGNORECASE), r\"\\1{replacement}@\"),",
            "    (",
            "        re.compile(r\"(username|password|passwd|pwd|secret|secrets)([\\\"']?(?:\\s+is.?|:)?\\s+)\\S+[\\\"']?\", re.IGNORECASE),",
            "        r\"\\1\\2{replacement}\",",
            "    ),",
            "]",
            "",
            "# Storage",
            "STORAGE_BACKEND = None",
            "STORAGE_CONFIG = {}",
            "",
            "# Custom message to display on 4xx and 5xx error pages. Markdown and HTML are supported.",
            "# Default message directs the user to #nautobot on NTC's Slack community.",
            "if \"NAUTOBOT_SUPPORT_MESSAGE\" in os.environ and os.environ[\"NAUTOBOT_SUPPORT_MESSAGE\"] != \"\":",
            "    SUPPORT_MESSAGE = os.environ[\"NAUTOBOT_SUPPORT_MESSAGE\"]",
            "",
            "# Test runner that is aware of our use of \"integration\" tags and only runs",
            "# integration tests if explicitly passed in with `nautobot-server test --tag integration`.",
            "TEST_RUNNER = \"nautobot.core.tests.runner.NautobotTestRunner\"",
            "# Disable test data factories by default so as not to cause issues for plugins.",
            "# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.",
            "TEST_USE_FACTORIES = is_truthy(os.getenv(\"NAUTOBOT_TEST_USE_FACTORIES\", \"False\"))",
            "# Pseudo-random number generator seed, for reproducibility of test results.",
            "TEST_FACTORY_SEED = os.getenv(\"NAUTOBOT_TEST_FACTORY_SEED\", None)",
            "",
            "#",
            "# django-slowtests",
            "#",
            "",
            "# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.",
            "# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command",
            "# will automatically opt to NautobotPerformanceTestRunner to run the tests.",
            "",
            "# The baseline file that the performance test is running against",
            "# TODO we need to replace the baselines in this file with more consistent results at least for CI",
            "TEST_PERFORMANCE_BASELINE_FILE = os.getenv(",
            "    \"NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE\", \"nautobot/core/tests/performance_baselines.yml\"",
            ")",
            "",
            "#",
            "# Django Prometheus",
            "#",
            "",
            "PROMETHEUS_EXPORT_MIGRATIONS = False",
            "",
            "",
            "#",
            "# Django filters",
            "#",
            "",
            "FILTERS_NULL_CHOICE_LABEL = \"None\"",
            "FILTERS_NULL_CHOICE_VALUE = \"null\"",
            "",
            "STRICT_FILTERING = is_truthy(os.getenv(\"NAUTOBOT_STRICT_FILTERING\", \"True\"))",
            "",
            "#",
            "# Django REST framework (API)",
            "#",
            "",
            "REST_FRAMEWORK_VERSION = VERSION.rsplit(\".\", 1)[0]  # Use major.minor as API version",
            "VERSION_MAJOR, VERSION_MINOR = [int(v) for v in REST_FRAMEWORK_VERSION.split(\".\")]",
            "# We support all major.minor API versions from 2.0 to the present latest version.",
            "# Similar logic exists in tasks.py, please keep them in sync!",
            "if VERSION_MAJOR != 2:",
            "    raise RuntimeError(f\"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {VERSION_MAJOR}\")",
            "REST_FRAMEWORK_ALLOWED_VERSIONS = [f\"{VERSION_MAJOR}.{minor}\" for minor in range(0, VERSION_MINOR + 1)]",
            "",
            "REST_FRAMEWORK = {",
            "    \"ALLOWED_VERSIONS\": REST_FRAMEWORK_ALLOWED_VERSIONS,",
            "    \"DEFAULT_AUTHENTICATION_CLASSES\": (",
            "        \"rest_framework.authentication.SessionAuthentication\",",
            "        \"nautobot.core.api.authentication.TokenAuthentication\",",
            "    ),",
            "    \"DEFAULT_FILTER_BACKENDS\": (",
            "        \"nautobot.core.api.filter_backends.NautobotFilterBackend\",",
            "        \"nautobot.core.api.filter_backends.NautobotOrderingFilter\",",
            "    ),",
            "    \"DEFAULT_METADATA_CLASS\": \"nautobot.core.api.metadata.NautobotMetadata\",",
            "    \"DEFAULT_PAGINATION_CLASS\": \"nautobot.core.api.pagination.OptionalLimitOffsetPagination\",",
            "    \"DEFAULT_PERMISSION_CLASSES\": (\"nautobot.core.api.authentication.TokenPermissions\",),",
            "    \"DEFAULT_RENDERER_CLASSES\": (",
            "        \"nautobot.core.api.renderers.NautobotJSONRenderer\",",
            "        \"nautobot.core.api.renderers.FormlessBrowsableAPIRenderer\",",
            "        \"nautobot.core.api.renderers.NautobotCSVRenderer\",",
            "    ),",
            "    \"DEFAULT_PARSER_CLASSES\": (",
            "        \"rest_framework.parsers.JSONParser\",",
            "        \"nautobot.core.api.parsers.NautobotCSVParser\",",
            "    ),",
            "    \"DEFAULT_SCHEMA_CLASS\": \"nautobot.core.api.schema.NautobotAutoSchema\",",
            "    # Version to use if the client doesn't request otherwise. Default to current (i.e. latest)",
            "    \"DEFAULT_VERSION\": REST_FRAMEWORK_VERSION,",
            "    \"DEFAULT_VERSIONING_CLASS\": \"nautobot.core.api.versioning.NautobotAPIVersioning\",",
            "    \"ORDERING_PARAM\": \"sort\",  # This is not meant to be changed by users, but is used internally by the API",
            "    \"PAGE_SIZE\": None,",
            "    \"SCHEMA_COERCE_METHOD_NAMES\": {",
            "        # Default mappings",
            "        \"retrieve\": \"read\",",
            "        \"destroy\": \"delete\",",
            "        # Custom operations",
            "        \"bulk_destroy\": \"bulk_delete\",",
            "    },",
            "    \"VIEW_NAME_FUNCTION\": \"nautobot.core.api.utils.get_view_name\",",
            "}",
            "",
            "",
            "#",
            "# drf_spectacular (OpenAPI/Swagger)",
            "#",
            "",
            "SPECTACULAR_SETTINGS = {",
            "    \"TITLE\": \"API Documentation\",",
            "    \"DESCRIPTION\": \"Source of truth and network automation platform\",",
            "    \"LICENSE\": {\"name\": \"Apache v2 License\"},",
            "    \"VERSION\": VERSION,",
            "    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where \"/api\" was a common \"basePath\"",
            "    # in the schema.",
            "    # OpenAPI 3.0 removes \"basePath\" in favor of \"servers\", so we now declare \"/api\" as the server relative URL and",
            "    # trim it from all of the individual paths correspondingly.",
            "    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.",
            "    \"SERVERS\": [{\"url\": \"/api\"}],",
            "    \"SERVE_PERMISSIONS\": [\"rest_framework.permissions.IsAuthenticated\"],",
            "    \"SCHEMA_PATH_PREFIX\": \"/api\",",
            "    \"SCHEMA_PATH_PREFIX_TRIM\": True,",
            "    # use sidecar - locally packaged UI files, not CDN",
            "    \"SWAGGER_UI_DIST\": \"SIDECAR\",",
            "    \"SWAGGER_UI_FAVICON_HREF\": \"SIDECAR\",",
            "    \"SWAGGER_UI_SETTINGS\": {",
            "        \"deepLinking\": True,",
            "        \"displayOperationId\": True,",
            "    },",
            "    \"REDOC_DIST\": \"SIDECAR\",",
            "    # Do not list all possible enum values in the description of filter fields and the like",
            "    # In addition to being highly verbose, it's inaccurate for filter fields like *__ic and *__re",
            "    \"ENUM_GENERATE_CHOICE_DESCRIPTION\": False,",
            "    \"ENUM_NAME_OVERRIDES\": {",
            "        # These choice enums need to be overridden because they get assigned to the `type` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"type\".",
            "        \"CableTypeChoices\": \"nautobot.dcim.choices.CableTypeChoices\",",
            "        \"ConsolePortTypeChoices\": \"nautobot.dcim.choices.ConsolePortTypeChoices\",",
            "        \"CustomFieldTypeChoices\": \"nautobot.extras.choices.CustomFieldTypeChoices\",",
            "        \"InterfaceTypeChoices\": \"nautobot.dcim.choices.InterfaceTypeChoices\",",
            "        \"IPAddressTypeChoices\": \"nautobot.ipam.choices.IPAddressTypeChoices\",",
            "        \"PortTypeChoices\": \"nautobot.dcim.choices.PortTypeChoices\",",
            "        \"PowerFeedTypeChoices\": \"nautobot.dcim.choices.PowerFeedTypeChoices\",",
            "        \"PowerOutletTypeChoices\": \"nautobot.dcim.choices.PowerOutletTypeChoices\",",
            "        \"PowerPortTypeChoices\": \"nautobot.dcim.choices.PowerPortTypeChoices\",",
            "        \"PrefixTypeChoices\": \"nautobot.ipam.choices.PrefixTypeChoices\",",
            "        \"RackTypeChoices\": \"nautobot.dcim.choices.RackTypeChoices\",",
            "        \"RelationshipTypeChoices\": \"nautobot.extras.choices.RelationshipTypeChoices\",",
            "        # These choice enums need to be overridden because they get assigned to different names with the same choice set and",
            "        # result in this error:",
            "        #   encountered multiple names for the same choice set",
            "        \"JobExecutionTypeIntervalChoices\": \"nautobot.extras.choices.JobExecutionType\",",
            "        # These choice enums need to be overridden because they get assigned to the `protocol` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"protocol\".",
            "        \"InterfaceRedundancyGroupProtocolChoices\": \"nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices\",",
            "        \"ServiceProtocolChoices\": \"nautobot.ipam.choices.ServiceProtocolChoices\",",
            "    },",
            "    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)",
            "    \"COMPONENT_SPLIT_PATCH\": True,",
            "    # Create separate schema components for request vs response where appropriate",
            "    \"COMPONENT_SPLIT_REQUEST\": True,",
            "}",
            "",
            "",
            "##############################################",
            "# DJANGO - Core settings required for Django #",
            "##############################################",
            "",
            "#",
            "# Databases",
            "#",
            "",
            "DATABASES = {",
            "    \"default\": {",
            "        \"NAME\": os.getenv(\"NAUTOBOT_DB_NAME\", \"nautobot\"),",
            "        \"USER\": os.getenv(\"NAUTOBOT_DB_USER\", \"\"),",
            "        \"PASSWORD\": os.getenv(\"NAUTOBOT_DB_PASSWORD\", \"\"),",
            "        \"HOST\": os.getenv(\"NAUTOBOT_DB_HOST\", \"localhost\"),",
            "        \"PORT\": os.getenv(\"NAUTOBOT_DB_PORT\", \"\"),",
            "        \"CONN_MAX_AGE\": int(os.getenv(\"NAUTOBOT_DB_TIMEOUT\", \"300\")),",
            "        \"ENGINE\": os.getenv(",
            "            \"NAUTOBOT_DB_ENGINE\",",
            "            \"django_prometheus.db.backends.postgresql\" if METRICS_ENABLED else \"django.db.backends.postgresql\",",
            "        ),",
            "    }",
            "}",
            "",
            "# Ensure proper Unicode handling for MySQL",
            "if DATABASES[\"default\"][\"ENGINE\"] == \"django.db.backends.mysql\":",
            "    DATABASES[\"default\"][\"OPTIONS\"] = {\"charset\": \"utf8mb4\"}",
            "",
            "# The secret key is used to encrypt session keys and salt passwords.",
            "SECRET_KEY = os.getenv(\"NAUTOBOT_SECRET_KEY\", \"\")",
            "",
            "# Default overrides",
            "if \"NAUTOBOT_ALLOWED_HOSTS\" in os.environ and os.environ[\"NAUTOBOT_ALLOWED_HOSTS\"] != \"\":",
            "    ALLOWED_HOSTS = os.environ[\"NAUTOBOT_ALLOWED_HOSTS\"].split(\" \")",
            "else:",
            "    ALLOWED_HOSTS = []",
            "CSRF_TRUSTED_ORIGINS = []",
            "CSRF_FAILURE_VIEW = \"nautobot.core.views.csrf_failure\"",
            "DATE_FORMAT = os.getenv(\"NAUTOBOT_DATE_FORMAT\", \"N j, Y\")",
            "DATETIME_FORMAT = os.getenv(\"NAUTOBOT_DATETIME_FORMAT\", \"N j, Y g:i a\")",
            "DEBUG = is_truthy(os.getenv(\"NAUTOBOT_DEBUG\", \"False\"))",
            "INTERNAL_IPS = [\"127.0.0.1\", \"::1\"]",
            "FORCE_SCRIPT_NAME = None",
            "",
            "TESTING = \"test\" in sys.argv",
            "",
            "LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"",
            "",
            "if TESTING:",
            "    # Log to null handler instead of stderr during testing",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"handlers\": {\"console\": {\"level\": \"INFO\", \"class\": \"logging.NullHandler\"}},",
            "        \"loggers\": {\"nautobot\": {\"handlers\": [\"console\"], \"level\": \"INFO\"}},",
            "    }",
            "else:",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"formatters\": {",
            "            \"normal\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "            \"verbose\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "        },",
            "        \"handlers\": {",
            "            \"normal_console\": {",
            "                \"level\": \"INFO\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"normal\",",
            "            },",
            "            \"verbose_console\": {",
            "                \"level\": \"DEBUG\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"verbose\",",
            "            },",
            "        },",
            "        \"loggers\": {",
            "            \"django\": {\"handlers\": [\"normal_console\"], \"level\": \"INFO\"},",
            "            \"nautobot\": {",
            "                \"handlers\": [\"verbose_console\" if DEBUG else \"normal_console\"],",
            "                \"level\": LOG_LEVEL,",
            "            },",
            "        },",
            "    }",
            "",
            "MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, \"media\").rstrip(\"/\")",
            "SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv(\"NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE\", \"False\"))",
            "SESSION_COOKIE_AGE = int(os.getenv(\"NAUTOBOT_SESSION_COOKIE_AGE\", \"1209600\"))  # 2 weeks, in seconds",
            "SESSION_FILE_PATH = os.getenv(\"NAUTOBOT_SESSION_FILE_PATH\", None)",
            "SHORT_DATE_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATE_FORMAT\", \"Y-m-d\")",
            "SHORT_DATETIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")",
            "TIME_FORMAT = os.getenv(\"NAUTOBOT_TIME_FORMAT\", \"g:i a\")",
            "TIME_ZONE = os.getenv(\"NAUTOBOT_TIME_ZONE\", \"UTC\")",
            "",
            "# Disable importing the WSGI module before starting the server application. This is required for",
            "# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.",
            "WEBSERVER_WARMUP = False",
            "",
            "# Installed apps and Django plugins. Nautobot plugins will be appended here later.",
            "INSTALLED_APPS = [",
            "    \"django.contrib.auth\",",
            "    \"django.contrib.contenttypes\",",
            "    \"django.contrib.sessions\",",
            "    \"django.contrib.messages\",",
            "    \"django.contrib.staticfiles\",",
            "    \"django.contrib.humanize\",",
            "    \"corsheaders\",",
            "    \"django_filters\",",
            "    \"django_jinja\",",
            "    \"django_tables2\",",
            "    \"django_prometheus\",",
            "    \"social_django\",",
            "    \"taggit\",",
            "    \"timezone_field\",",
            "    \"nautobot.core.apps.NautobotConstanceConfig\",  # overridden form of \"constance\" AppConfig",
            "    \"nautobot.core\",",
            "    \"django.contrib.admin\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_beat\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_results\",",
            "    \"rest_framework\",  # Must be after `nautobot.core` for template overrides",
            "    \"db_file_storage\",",
            "    \"nautobot.circuits\",",
            "    \"nautobot.dcim\",",
            "    \"nautobot.ipam\",",
            "    \"nautobot.extras\",",
            "    \"nautobot.tenancy\",",
            "    \"nautobot.users\",",
            "    \"nautobot.virtualization\",",
            "    \"drf_spectacular\",",
            "    \"drf_spectacular_sidecar\",",
            "    \"graphene_django\",",
            "    \"health_check\",",
            "    \"health_check.storage\",",
            "    # We have custom implementations of these in nautobot.extras.health_checks:",
            "    # \"health_check.db\",",
            "    # \"health_check.contrib.migrations\",",
            "    # \"health_check.contrib.redis\",",
            "    \"django_extensions\",",
            "    \"constance.backends.database\",",
            "    \"django_ajax_tables\",",
            "    \"silk\",",
            "]",
            "",
            "# Middleware",
            "MIDDLEWARE = [",
            "    \"django_prometheus.middleware.PrometheusBeforeMiddleware\",",
            "    \"corsheaders.middleware.CorsMiddleware\",",
            "    \"django.contrib.sessions.middleware.SessionMiddleware\",",
            "    \"silk.middleware.SilkyMiddleware\",",
            "    \"django.middleware.common.CommonMiddleware\",",
            "    \"django.middleware.csrf.CsrfViewMiddleware\",",
            "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",",
            "    \"django.contrib.messages.middleware.MessageMiddleware\",",
            "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",",
            "    \"django.middleware.security.SecurityMiddleware\",",
            "    \"nautobot.core.middleware.ExceptionHandlingMiddleware\",",
            "    \"nautobot.core.middleware.RemoteUserMiddleware\",",
            "    \"nautobot.core.middleware.ExternalAuthMiddleware\",",
            "    \"nautobot.core.middleware.ObjectChangeMiddleware\",",
            "    \"django_prometheus.middleware.PrometheusAfterMiddleware\",",
            "]",
            "",
            "ROOT_URLCONF = \"nautobot.core.urls\"",
            "",
            "TEMPLATES = [",
            "    {",
            "        \"NAME\": \"django\",",
            "        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": True,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "        },",
            "    },",
            "    {",
            "        \"NAME\": \"jinja\",",
            "        \"BACKEND\": \"django_jinja.backend.Jinja2\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": False,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "            \"environment\": \"jinja2.sandbox.SandboxedEnvironment\",",
            "        },",
            "    },",
            "]",
            "",
            "# Set up authentication backends",
            "AUTHENTICATION_BACKENDS = [",
            "    # Always check object permissions",
            "    \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "]",
            "",
            "# Internationalization",
            "LANGUAGE_CODE = \"en-us\"",
            "USE_I18N = True",
            "USE_TZ = True",
            "",
            "# WSGI",
            "WSGI_APPLICATION = \"nautobot.core.wsgi.application\"",
            "SECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")",
            "USE_X_FORWARDED_HOST = True",
            "X_FRAME_OPTIONS = \"DENY\"",
            "",
            "# Static files (CSS, JavaScript, Images)",
            "STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, \"static\")",
            "STATIC_URL = \"static/\"",
            "STATICFILES_DIRS = (os.path.join(BASE_DIR, \"project-static\"),)",
            "",
            "# Media",
            "MEDIA_URL = \"media/\"",
            "",
            "# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)",
            "DATA_UPLOAD_MAX_NUMBER_FIELDS = None",
            "",
            "# Messages",
            "MESSAGE_TAGS = {",
            "    messages.ERROR: \"danger\",",
            "}",
            "",
            "# Authentication URLs",
            "# This is the URL route name for the login view.",
            "LOGIN_URL = \"login\"",
            "",
            "# This is the URL route name for the home page (index) view.",
            "LOGIN_REDIRECT_URL = \"home\"",
            "",
            "#",
            "# django-constance",
            "#",
            "",
            "CONSTANCE_BACKEND = \"constance.backends.database.DatabaseBackend\"",
            "CONSTANCE_DATABASE_PREFIX = \"constance:nautobot:\"",
            "CONSTANCE_DATABASE_CACHE_BACKEND = \"default\"",
            "CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment",
            "",
            "CONSTANCE_ADDITIONAL_FIELDS = {",
            "    \"per_page_defaults_field\": [",
            "        \"nautobot.core.forms.fields.JSONArrayFormField\",",
            "        {",
            "            \"widget\": \"django.forms.TextInput\",",
            "            \"base_field\": django.forms.IntegerField(min_value=1),",
            "        },",
            "    ],",
            "    \"release_check_timeout_field\": [",
            "        \"django.forms.IntegerField\",",
            "        {",
            "            \"min_value\": 3600,",
            "        },",
            "    ],",
            "    \"release_check_url_field\": [",
            "        \"django.forms.URLField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "    \"optional_json_field\": [",
            "        \"django.forms.fields.JSONField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG = {",
            "    \"ALLOW_REQUEST_PROFILING\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Allow users to enable request profiling on their login session.\",",
            "        field_type=bool,",
            "    ),",
            "    \"BANNER_BOTTOM\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom Markdown or limited HTML to display in a banner at the bottom of all pages.\",",
            "    ),",
            "    \"BANNER_LOGIN\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom Markdown or limited HTML to display in a banner at the top of the login page.\",",
            "    ),",
            "    \"BANNER_TOP\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom Markdown or limited HTML to display in a banner at the top of all pages.\",",
            "    ),",
            "    \"CHANGELOG_RETENTION\": ConstanceConfigItem(",
            "        default=90,",
            "        help_text=\"Number of days to retain object changelog history.\\nSet this to 0 to retain changes indefinitely.\",",
            "        field_type=int,",
            "    ),",
            "    \"DEVICE_NAME_AS_NATURAL_KEY\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Device names are not guaranteed globally-unique by Nautobot but in practice they often are. \"",
            "        \"Set this to True to use the device name alone as the natural key for Device objects. \"",
            "        \"Set this to False to use the sequence (name, tenant, location) as the natural key instead.\",",
            "        field_type=bool,",
            "    ),",
            "    \"DEPLOYMENT_ID\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Randomly generated UUID used to identify this installation.\\n\"",
            "        \"Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.\",",
            "        field_type=str,",
            "    ),",
            "    \"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\": ConstanceConfigItem(",
            "        default=0,",
            "        help_text=\"Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list \"",
            "        \"will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very \"",
            "        \"expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the \"",
            "        \"member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.\",",
            "        field_type=int,",
            "    ),",
            "    \"JOB_CREATE_FILE_MAX_SIZE\": ConstanceConfigItem(",
            "        default=10 << 20,",
            "        help_text=mark_safe(  # noqa: S308  # suspicious-mark-safe-usage, but this is a static string so it's safe",
            "            \"Maximum size (in bytes) of any single file generated by a <code>Job.create_file()</code> call.\"",
            "        ),",
            "        field_type=int,",
            "    ),",
            "    \"LOCATION_NAME_AS_NATURAL_KEY\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Location names are not guaranteed globally-unique by Nautobot but in practice they often are. \"",
            "        \"Set this to True to use the location name alone as the natural key for Location objects. \"",
            "        \"Set this to False to use the sequence (name, parent__name, parent__parent__name, ...) \"",
            "        \"as the natural key instead.\",",
            "        field_type=bool,",
            "    ),",
            "    \"MAX_PAGE_SIZE\": ConstanceConfigItem(",
            "        default=1000,",
            "        help_text=\"Maximum number of objects that a user can list in one UI page or one API call.\\n\"",
            "        \"If set to 0, a user can retrieve an unlimited number of objects.\",",
            "        field_type=int,",
            "    ),",
            "    \"PAGINATE_COUNT\": ConstanceConfigItem(",
            "        default=50,",
            "        help_text=\"Default number of objects to display per page when listing objects in the UI and/or REST API.\",",
            "        field_type=int,",
            "    ),",
            "    \"PER_PAGE_DEFAULTS\": ConstanceConfigItem(",
            "        default=[25, 50, 100, 250, 500, 1000],",
            "        help_text=\"Pagination options to present to the user to choose amongst.\\n\"",
            "        \"For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.\",",
            "        # Use custom field type defined above",
            "        field_type=\"per_page_defaults_field\",",
            "    ),",
            "    \"NETWORK_DRIVERS\": ConstanceConfigItem(",
            "        default={},",
            "        help_text=mark_safe(  # noqa: S308  # suspicious-mark-safe-usage, but this is a static string so it's safe",
            "            \"Extend or override default Platform.network_driver translations provided by \"",
            "            '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '",
            "            \"Enter a dictionary in JSON format, for example:\\n\"",
            "            '<pre><code class=\"language-json\">{\\n'",
            "            '    \"netmiko\": {\"my_network_driver\": \"cisco_ios\"},\\n'",
            "            '    \"pyats\": {\"my_network_driver\": \"iosxe\"} \\n'",
            "            \"}</code></pre>\",",
            "        ),",
            "        # Use custom field type defined above",
            "        field_type=\"optional_json_field\",",
            "    ),",
            "    \"PREFER_IPV4\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.\",",
            "        field_type=bool,",
            "    ),",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\": ConstanceConfigItem(",
            "        default=22, help_text=\"Default height (in pixels) of a rack unit in a rack elevation diagram\", field_type=int",
            "    ),",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\": ConstanceConfigItem(",
            "        default=230, help_text=\"Default width (in pixels) of a rack unit in a rack elevation diagram\", field_type=int",
            "    ),",
            "    \"RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Enables two-digit format for the rack unit numbering in a rack elevation diagram\",",
            "        field_type=bool,",
            "    ),",
            "    \"RELEASE_CHECK_TIMEOUT\": ConstanceConfigItem(",
            "        default=24 * 3600,",
            "        help_text=\"Number of seconds (must be at least 3600, or one hour) to cache the result of a release check \"",
            "        \"before checking again for a new release.\",",
            "        # Use custom field type defined above",
            "        field_type=\"release_check_timeout_field\",",
            "    ),",
            "    \"RELEASE_CHECK_URL\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\\n\"",
            "        'This can be set to the official repository \"https://api.github.com/repos/nautobot/nautobot/releases\" or '",
            "        \"a custom fork.\\nSet this to an empty string to disable automatic update checks.\",",
            "        # Use custom field type defined above",
            "        field_type=\"release_check_url_field\",",
            "    ),",
            "    \"SUPPORT_MESSAGE\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Help message to include on 4xx and 5xx error pages. \"",
            "        \"Markdown is supported, as are some HTML tags and attributes.\\n\"",
            "        \"If unspecified, instructions to join Network to Code's Slack community will be provided.\",",
            "    ),",
            "}",
            "",
            "CONSTANCE_CONFIG_FIELDSETS = {",
            "    \"Banners\": [\"BANNER_LOGIN\", \"BANNER_TOP\", \"BANNER_BOTTOM\"],",
            "    \"Change Logging\": [\"CHANGELOG_RETENTION\"],",
            "    \"Device Connectivity\": [\"NETWORK_DRIVERS\", \"PREFER_IPV4\"],",
            "    \"Installation Metrics\": [\"DEPLOYMENT_ID\"],",
            "    \"Natural Keys\": [\"DEVICE_NAME_AS_NATURAL_KEY\", \"LOCATION_NAME_AS_NATURAL_KEY\"],",
            "    \"Pagination\": [\"PAGINATE_COUNT\", \"MAX_PAGE_SIZE\", \"PER_PAGE_DEFAULTS\"],",
            "    \"Performance\": [\"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\", \"JOB_CREATE_FILE_MAX_SIZE\"],",
            "    \"Rack Elevation Rendering\": [",
            "        \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\",",
            "        \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\",",
            "        \"RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT\",",
            "    ],",
            "    \"Release Checking\": [\"RELEASE_CHECK_URL\", \"RELEASE_CHECK_TIMEOUT\"],",
            "    \"User Interface\": [\"SUPPORT_MESSAGE\"],",
            "    \"Debugging\": [\"ALLOW_REQUEST_PROFILING\"],",
            "}",
            "",
            "#",
            "# From django-cors-headers",
            "#",
            "",
            "# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.",
            "# Defaults to False. Setting this to True can be dangerous, as it allows any website to make",
            "# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with",
            "# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.",
            "CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv(\"NAUTOBOT_CORS_ALLOW_ALL_ORIGINS\", \"False\"))",
            "",
            "# A list of strings representing regexes that match Origins that are authorized to make cross-site",
            "# HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGIN_REGEXES = []",
            "",
            "# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGINS = []",
            "",
            "#",
            "# GraphQL",
            "#",
            "",
            "GRAPHENE = {",
            "    \"SCHEMA\": \"nautobot.core.graphql.schema_init.schema\",",
            "    \"DJANGO_CHOICE_FIELD_ENUM_V3_NAMING\": True,  # any field with a name of type will break in Graphene otherwise.",
            "}",
            "GRAPHQL_CUSTOM_FIELD_PREFIX = \"cf\"",
            "GRAPHQL_RELATIONSHIP_PREFIX = \"rel\"",
            "GRAPHQL_COMPUTED_FIELD_PREFIX = \"cpf\"",
            "",
            "",
            "#",
            "# Caching",
            "#",
            "",
            "# The django-redis cache is used to establish concurrent locks using Redis.",
            "CACHES = {",
            "    \"default\": {",
            "        \"BACKEND\": os.getenv(",
            "            \"NAUTOBOT_CACHES_BACKEND\",",
            "            \"django_prometheus.cache.backends.redis.RedisCache\" if METRICS_ENABLED else \"django_redis.cache.RedisCache\",",
            "        ),",
            "        \"LOCATION\": parse_redis_connection(redis_database=1),",
            "        \"TIMEOUT\": 300,",
            "        \"OPTIONS\": {",
            "            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",",
            "            \"PASSWORD\": \"\",",
            "        },",
            "    }",
            "}",
            "",
            "# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.",
            "CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv(\"NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT\", \"0\"))",
            "",
            "#",
            "# Celery (used for background processing)",
            "#",
            "",
            "# Celery Beat heartbeat file path - will be touched by Beat each time it wakes up as a proof-of-health.",
            "CELERY_BEAT_HEARTBEAT_FILE = os.getenv(",
            "    \"NAUTOBOT_CELERY_BEAT_HEARTBEAT_FILE\",",
            "    os.path.join(tempfile.gettempdir(), \"nautobot_celery_beat_heartbeat\"),",
            ")",
            "",
            "# Celery broker URL used to tell workers where queues are located",
            "CELERY_BROKER_URL = os.getenv(\"NAUTOBOT_CELERY_BROKER_URL\", parse_redis_connection(redis_database=0))",
            "",
            "# Celery results backend URL to tell workers where to publish task results - DO NOT CHANGE THIS",
            "CELERY_RESULT_BACKEND = \"nautobot.core.celery.backends.NautobotDatabaseBackend\"",
            "",
            "# Enables extended task result attributes (name, args, kwargs, worker, retries, queue, delivery_info) to be written to backend.",
            "CELERY_RESULT_EXTENDED = True",
            "",
            "# A value of None or 0 means results will never expire (depending on backend specifications).",
            "CELERY_RESULT_EXPIRES = None",
            "",
            "# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`",
            "CELERY_TASK_TRACK_STARTED = True",
            "",
            "# If enabled, a `task-sent` event will be sent for every task so tasks can be tracked before they're consumed by a worker.",
            "CELERY_TASK_SEND_SENT_EVENT = True",
            "",
            "# If enabled stdout and stderr of running jobs will be redirected to the task logger.",
            "CELERY_WORKER_REDIRECT_STDOUTS = is_truthy(os.getenv(\"NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS\", \"True\"))",
            "",
            "# The log level of log messages generated by redirected job stdout and stderr. Can be one of `DEBUG`, `INFO`, `WARNING`, `ERROR`, or `CRITICAL`.",
            "CELERY_WORKER_REDIRECT_STDOUTS_LEVEL = os.getenv(\"NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS_LEVEL\", \"WARNING\")",
            "",
            "# Send task-related events so that tasks can be monitored using tools like flower. Sets the default value for the workers -E argument.",
            "CELERY_WORKER_SEND_TASK_EVENTS = True",
            "",
            "# Default celery queue name that will be used by workers and tasks if no queue is specified",
            "CELERY_TASK_DEFAULT_QUEUE = os.getenv(\"NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE\", \"default\")",
            "",
            "# Global task time limits (seconds)",
            "# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,",
            "# while exceeding the hard limit will result in a SIGKILL.",
            "CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT\", str(5 * 60)))",
            "CELERY_TASK_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_TIME_LIMIT\", str(10 * 60)))",
            "",
            "# Ports for prometheus metric HTTP server running on the celery worker.",
            "# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.",
            "# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the",
            "# highest amount of workers you are running on a single machine (comma-separated, like \"8080,8081,8082\"). You can then",
            "# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in",
            "# that case. Set this to an empty string to disable it.",
            "CELERY_WORKER_PROMETHEUS_PORTS = []",
            "if os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\"):",
            "    CELERY_WORKER_PROMETHEUS_PORTS = [",
            "        int(value) for value in os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\").split(_CONFIG_SETTING_SEPARATOR)",
            "    ]",
            "",
            "# These settings define the custom nautobot serialization encoding as an accepted data encoding format",
            "# and register that format for task input and result serialization",
            "CELERY_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_RESULT_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_TASK_SERIALIZER = \"nautobot_json\"",
            "CELERY_RESULT_SERIALIZER = \"nautobot_json\"",
            "",
            "CELERY_BEAT_SCHEDULER = \"nautobot.core.celery.schedulers:NautobotDatabaseScheduler\"",
            "",
            "# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added",
            "# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`",
            "REDIS_LOCK_TIMEOUT = int(os.getenv(\"NAUTOBOT_REDIS_LOCK_TIMEOUT\", \"600\"))",
            "",
            "#",
            "# Custom branding (logo and title)",
            "#",
            "",
            "# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.",
            "# The filepath should be relative to the `MEDIA_ROOT`.",
            "BRANDING_FILEPATHS = {",
            "    \"logo\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_LOGO\", None),  # Navbar logo",
            "    \"favicon\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_FAVICON\", None),  # Browser favicon",
            "    \"icon_16\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_16\", None),  # 16x16px icon",
            "    \"icon_32\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_32\", None),  # 32x32px icon",
            "    \"icon_180\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_180\", None",
            "    ),  # 180x180px icon - used for the apple-touch-icon header",
            "    \"icon_192\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_192\", None),  # 192x192px icon",
            "    \"icon_mask\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK\", None",
            "    ),  # mono-chrome icon used for the mask-icon header",
            "    \"header_bullet\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET\", None",
            "    ),  # bullet image used for various view headers",
            "    \"nav_bullet\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET\", None),  # bullet image used for nav menu headers",
            "    \"css\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_CSS\", None),  # Custom global CSS",
            "    \"javascript\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_JAVASCRIPT\", None),  # Custom global JavaScript",
            "}",
            "",
            "# Title to use in place of \"Nautobot\"",
            "BRANDING_TITLE = os.getenv(\"NAUTOBOT_BRANDING_TITLE\", \"Nautobot\")",
            "",
            "# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)",
            "BRANDING_PREPENDED_FILENAME = os.getenv(\"NAUTOBOT_BRANDING_PREPENDED_FILENAME\", \"nautobot_\")",
            "",
            "# Branding URLs (links in the bottom right of the footer)",
            "BRANDING_URLS = {",
            "    \"code\": os.getenv(\"NAUTOBOT_BRANDING_URLS_CODE\", \"https://github.com/nautobot/nautobot\"),",
            "    \"docs\": os.getenv(\"NAUTOBOT_BRANDING_URLS_DOCS\", None),",
            "    \"help\": os.getenv(\"NAUTOBOT_BRANDING_URLS_HELP\", \"https://github.com/nautobot/nautobot/wiki\"),",
            "}",
            "",
            "# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.",
            "BRANDING_POWERED_BY_URL = \"https://docs.nautobot.com/\"",
            "",
            "#",
            "# Django extensions settings",
            "#",
            "",
            "# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models",
            "SHELL_PLUS_DONT_LOAD = [\"taggit\"]",
            "",
            "#",
            "# UI settings",
            "#",
            "",
            "",
            "# UI_RACK_VIEW_TRUNCATE_FUNCTION",
            "def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):",
            "    \"\"\"Given device display name, truncate to fit the rack elevation view.",
            "",
            "    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.",
            "    :type device_display_name: str",
            "",
            "    :return: Truncated device name",
            "    :type: str",
            "    \"\"\"",
            "    return str(device_display_name).split(\".\")[0]",
            "",
            "",
            "# Custom JSON schema serializer field type mappingss. These will be added to",
            "# `NautobotProcessingMixin.TYPE_MAP`.",
            "# Format: `{serializer_field_class.__name__}` => `{json_schema_type}`",
            "# See: https://github.com/yoyowallet/drf-react-template-framework#settings",
            "DRF_REACT_TEMPLATE_TYPE_MAP = {",
            "    \"ContentTypeField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    \"CustomFieldsDataField\": {\"type\": \"object\", \"widget\": \"textarea\"},",
            "    \"DateTimeField\": {\"type\": \"string\", \"format\": \"date-time\", \"widget\": \"date-time\"},",
            "    \"ImageField\": {\"type\": \"string\", \"format\": \"data-url\"},",
            "    \"IPFieldSerializer\": {\"type\": \"string\"},",
            "    \"JSONField\": {\"type\": \"string\", \"widget\": \"textarea\"},",
            "    \"MultipleChoiceJSONField\": {\"type\": \"array\", \"required\": [], \"enum\": \"choices\"},",
            "    \"ManyRelatedField\": {\"type\": \"array\", \"required\": []},",
            "    #",
            "    # Foreign Key fields",
            "    #",
            "    # enum=choices is the one that works in the UI as a related field but it",
            "    # includes ALL related objects in the schema.",
            "    # \"NautobotHyperlinkedRelatedField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    # readOnly=True disables the fields in the UI; not what we want.",
            "    # \"NautobotHyperlinkedRelatedField\": {\"type\": \"string\", \"readOnly\": True},",
            "    # type=string results in a free text field; also not what we want. For now,",
            "    # however, this will keep things moving so the unit tests pass.",
            "    \"NautobotHyperlinkedRelatedField\": {\"type\": \"object\"},",
            "    \"PrimaryKeyRelatedField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    \"RelationshipsDataField\": {\"type\": \"object\"},",
            "    \"SlugField\": {\"type\": \"string\"},",
            "    \"TimeZoneSerializerField\": {\"type\": \"string\"},",
            "    \"UUIDField\": {\"type\": \"string\", \"format\": \"uuid\"},",
            "}",
            "",
            "",
            "#",
            "# django-silk is used for optional request profiling for debugging purposes",
            "#",
            "",
            "SILKY_PYTHON_PROFILER = True",
            "SILKY_PYTHON_PROFILER_BINARY = True",
            "SILKY_PYTHON_PROFILER_EXTENDED_FILE_NAME = True",
            "SILKY_ANALYZE_QUERIES = False  # See the docs for the implications of turning this on https://github.com/jazzband/django-silk?tab=readme-ov-file#enable-query-analysis",
            "SILKY_AUTHENTICATION = True  # User must login",
            "SILKY_AUTHORISATION = True  # User must have permissions",
            "",
            "",
            "# This makes it so that only superusers can access the silk UI",
            "def silk_user_permissions(user):",
            "    return user.is_superuser",
            "",
            "",
            "SILKY_PERMISSIONS = silk_user_permissions",
            "",
            "",
            "# This ensures profiling only happens when enabled on the sessions. Users are able",
            "# to turn this on or off in their user profile. It also ignores health-check requests.",
            "def silk_request_logging_intercept_logic(request):",
            "    if request.path != \"/health/\":",
            "        if request.session.get(\"silk_record_requests\", False):",
            "            return True",
            "    return False",
            "",
            "",
            "SILKY_INTERCEPT_FUNC = silk_request_logging_intercept_logic"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "72": [],
            "689": [],
            "693": [],
            "697": []
        },
        "addLocation": []
    },
    "nautobot/core/tests/test_views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")"
            },
            "1": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         self.assertNotRegex(response_content, footer_hostname_version_pattern)"
            },
            "2": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+    def test_banners_markdown(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        url = reverse(\"home\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        with override_settings("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            BANNER_TOP=\"# Hello world\","
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            BANNER_BOTTOM=\"[info](https://nautobot.com)\","
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        ):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            response = self.client.get(url)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        self.assertInHTML(\"<h1>Hello world</h1>\", response.content.decode(response.charset))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        self.assertInHTML("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            '<a href=\"https://nautobot.com\" rel=\"noopener noreferrer\">info</a>',"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+            response.content.decode(response.charset),"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        )"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        with override_settings(BANNER_LOGIN=\"_Welcome to Nautobot!_\"):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            self.client.logout()"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            response = self.client.get(reverse(\"login\"))"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        self.assertInHTML(\"<em>Welcome to Nautobot!</em>\", response.content.decode(response.charset))"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+    def test_banners_no_xss(self):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        url = reverse(\"home\")"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        with override_settings("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            BANNER_TOP='<script>alert(\"Hello from above!\");</script>',"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+            BANNER_BOTTOM='<script>alert(\"Hello from below!\");</script>',"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        ):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+            response = self.client.get(url)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        self.assertNotIn(\"Hello from above\", response.content.decode(response.charset))"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        self.assertNotIn(\"Hello from below\", response.content.decode(response.charset))"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        with override_settings(BANNER_LOGIN='<script>alert(\"Welcome to Nautobot!\");</script>'):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            self.client.logout()"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            response = self.client.get(reverse(\"login\"))"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        self.assertNotIn(\"Welcome to Nautobot!\", response.content.decode(response.charset))"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " @override_settings(BRANDING_TITLE=\"Nautobot\")"
            },
            "38": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " class SearchFieldsTestCase(TestCase):"
            }
        },
        "frontPatchFile": [
            "import re",
            "from unittest import mock",
            "import urllib.parse",
            "",
            "from django.apps import apps",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import override_settings, RequestFactory",
            "from django.test.utils import override_script_prefix",
            "from django.urls import get_script_prefix, reverse",
            "from prometheus_client.parser import text_string_to_metric_families",
            "",
            "from nautobot.core.constants import GLOBAL_SEARCH_EXCLUDE_LIST",
            "from nautobot.core.testing import TestCase",
            "from nautobot.core.testing.api import APITestCase",
            "from nautobot.core.utils.permissions import get_permission_for_model",
            "from nautobot.core.views import NautobotMetricsView",
            "from nautobot.core.views.mixins import GetReturnURLMixin",
            "from nautobot.dcim.models.locations import Location",
            "from nautobot.extras.choices import CustomFieldTypeChoices",
            "from nautobot.extras.models import FileProxy",
            "from nautobot.extras.models.customfields import CustomField, CustomFieldChoice",
            "from nautobot.extras.registry import registry",
            "from nautobot.users.models import ObjectPermission",
            "",
            "",
            "class GetReturnURLMixinTestCase(TestCase):",
            "    \"\"\"Tests for the API of GetReturnURLMixin.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.factory = RequestFactory(SERVER_NAME=\"nautobot.example.com\")",
            "        cls.mixin = GetReturnURLMixin()",
            "",
            "    def test_get_return_url_explicit(self):",
            "        request = self.factory.get(\"/\", {\"return_url\": \"/dcim/devices/\"})",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), \"/dcim/devices/\")",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=Location.objects.first()), \"/dcim/devices/\")",
            "",
            "        request = self.factory.get(\"/\", {\"return_url\": \"/dcim/devices/?status=Active\"})",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), \"/dcim/devices/?status=Active\")",
            "",
            "    def test_get_return_url_explicit_unsafe(self):",
            "        request = self.factory.get(\"/\", {\"return_url\": \"http://example.com\"})",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), reverse(\"home\"))",
            "",
            "    def test_get_return_url_explicit_punycode(self):",
            "        \"\"\"",
            "        Replace the 'i' in '/dcim/' with a unicode dotless '\u0131' and make sure we're not fooled by it.",
            "        \"\"\"  # noqa: RUF002  # ambiguous-unicode-character-docstring -- fully intentional here!",
            "        request = self.factory.get(\"/\", {\"return_url\": \"/dc\u0131m/devices/\"})  # noqa: RUF001  # ambiguous-unicode-character-string -- fully intentional here!",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), \"/dc%C4%B1m/devices/\")",
            "",
            "    def test_get_return_url_default_with_obj(self):",
            "        request = self.factory.get(\"/\")",
            "        location = Location.objects.first()",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=location), location.get_absolute_url())",
            "",
            "",
            "class HomeViewTestCase(TestCase):",
            "    def test_home(self):",
            "        url = reverse(\"home\")",
            "",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_search(self):",
            "        url = reverse(\"search\")",
            "        params = {",
            "            \"q\": \"foo\",",
            "        }",
            "",
            "        response = self.client.get(f\"{url}?{urllib.parse.urlencode(params)}\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_appropriate_models_included_in_global_search(self):",
            "        # Gather core app configs",
            "        existing_models = []",
            "        global_searchable_models = []",
            "        for app_name in [\"circuits\", \"dcim\", \"extras\", \"ipam\", \"tenancy\", \"virtualization\"]:",
            "            app_config = apps.get_app_config(app_name)",
            "            existing_models += [model._meta.model_name for model in app_config.get_models()]",
            "            global_searchable_models += app_config.searchable_models",
            "",
            "        # Remove those models that are not searchable",
            "        existing_models = [model for model in existing_models if model not in GLOBAL_SEARCH_EXCLUDE_LIST]",
            "        existing_models.sort()",
            "",
            "        # See if there are any models that are missing from global search",
            "        difference = [model for model in existing_models if model not in global_searchable_models]",
            "        if difference:",
            "            self.fail(",
            "                f'Existing model/models {\",\".join(difference)} are not included in the searchable_models attribute of the app config.\\n'",
            "                'If you do not want the models to be searchable, please include them in the GLOBAL_SEARCH_EXCLUDE_LIST constant in nautobot.core.constants.'",
            "            )",
            "",
            "    def make_request(self):",
            "        url = reverse(\"home\")",
            "        response = self.client.get(url)",
            "",
            "        # Search bar in nav",
            "        nav_search_bar_pattern = re.compile(",
            "            '<nav.*<form action=\"/search/\" method=\"get\" class=\"navbar-form\" id=\"navbar_search\" role=\"search\">.*</form>.*</nav>'",
            "        )",
            "        nav_search_bar_result = nav_search_bar_pattern.search(",
            "            response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        )",
            "",
            "        # Global search bar in body/container-fluid wrapper",
            "        body_search_bar_pattern = re.compile(",
            "            '<div class=\"container-fluid wrapper\" id=\"main-content\">.*<form action=\"/search/\" method=\"get\" class=\"form-inline\">.*</form>.*</div>',",
            "            re.DOTALL,",
            "        )",
            "",
            "        body_search_bar_result = body_search_bar_pattern.search(",
            "            response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        )",
            "",
            "        return nav_search_bar_result, body_search_bar_result",
            "",
            "    def test_search_bar_not_visible_if_user_not_authenticated(self):",
            "        self.client.logout()",
            "",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNone(nav_search_bar_result)",
            "        self.assertIsNone(body_search_bar_result)",
            "",
            "    def test_search_bar_visible_if_user_authenticated(self):",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNotNone(nav_search_bar_result)",
            "        self.assertIsNotNone(body_search_bar_result)",
            "",
            "    @override_settings(VERSION=\"1.2.3\")",
            "    def test_footer_version_visible_authenticated_users_only(self):",
            "        url = reverse(\"home\")",
            "        response = self.client.get(url)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "",
            "        footer_hostname_version_pattern = re.compile(r'<p class=\"text-muted\">\\s+\\S+\\s+\\(v1\\.2\\.3\\)\\s+</p>')",
            "        self.assertRegex(response_content, footer_hostname_version_pattern)",
            "",
            "        self.client.logout()",
            "        response = self.client.get(url)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        self.assertNotRegex(response_content, footer_hostname_version_pattern)",
            "",
            "",
            "@override_settings(BRANDING_TITLE=\"Nautobot\")",
            "class SearchFieldsTestCase(TestCase):",
            "    def test_search_bar_redirect_to_login(self):",
            "        self.client.logout()",
            "        response = self.client.get(reverse(\"search\") + \"?q=prefix\")",
            "        # Assert that if the user is not logged in",
            "        # SearchForm will redirect the user to the login Page",
            "        self.assertEqual(response.status_code, 302)",
            "",
            "    def test_global_and_model_search_bar(self):",
            "        self.add_permissions(\"dcim.view_location\", \"dcim.view_device\")",
            "",
            "        # Assert model search bar present in list UI",
            "        response = self.client.get(reverse(\"dcim:location_list\"))",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" required placeholder=\"Search Locations\" id=\"id_q\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        response = self.client.get(reverse(\"dcim:device_list\"))",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" required placeholder=\"Search Devices\" id=\"id_q\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        # Assert global search bar present in UI",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" placeholder=\"Search Nautobot\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "",
            "class FilterFormsTestCase(TestCase):",
            "    def test_support_for_both_default_and_dynamic_filter_form_in_ui(self):",
            "        self.add_permissions(\"dcim.view_location\", \"circuits.view_circuit\")",
            "",
            "        filter_tabs = \"\"\"",
            "            <ul id=\"tabs\" class=\"nav nav-tabs\">",
            "                <li role=\"presentation\" class=\"active\">",
            "                    <a href=\"#default-filter\" role=\"tab\" data-toggle=\"tab\">",
            "                        Default",
            "                    </a>",
            "                </li>",
            "                <li role=\"presentation\" class=\"\">",
            "                    <a href=\"#advanced-filter\" role=\"tab\" data-toggle=\"tab\">",
            "                        Advanced",
            "                    </a>",
            "                </li>",
            "            </ul>",
            "            \"\"\"",
            "",
            "        response = self.client.get(reverse(\"dcim:location_list\"))",
            "        self.assertInHTML(",
            "            filter_tabs,",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        response = self.client.get(reverse(\"circuits:circuit_list\"))",
            "        self.assertInHTML(",
            "            filter_tabs,",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "    def test_filtering_on_custom_select_filter_field(self):",
            "        \"\"\"Assert CustomField select and multiple select fields can be filtered using multiple entries\"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "",
            "        multi_select_cf = CustomField.objects.create(",
            "            type=CustomFieldTypeChoices.TYPE_MULTISELECT, label=\"Multiple Choice\"",
            "        )",
            "        select_cf = CustomField.objects.create(type=CustomFieldTypeChoices.TYPE_SELECT, label=\"choice\")",
            "        choices = [\"Foo\", \"Bar\", \"FooBar\"]",
            "        for cf in [multi_select_cf, select_cf]:",
            "            cf.content_types.set([ContentType.objects.get_for_model(Location)])",
            "            CustomFieldChoice.objects.create(custom_field=cf, value=choices[0])",
            "            CustomFieldChoice.objects.create(custom_field=cf, value=choices[1])",
            "            CustomFieldChoice.objects.create(custom_field=cf, value=choices[2])",
            "",
            "        locations = Location.objects.all()[:3]",
            "        for idx, location in enumerate(locations):",
            "            location.cf[multi_select_cf.key] = choices[:2]",
            "            location.cf[select_cf.key] = choices[idx]",
            "            location.save()",
            "",
            "        query_param = (",
            "            f\"?cf_{multi_select_cf.key}={choices[0]}&cf_{multi_select_cf.key}={choices[1]}\"",
            "            f\"&cf_{select_cf.key}={choices[0]}&cf_{select_cf.key}={choices[1]}\"",
            "        )",
            "        url = reverse(\"dcim:location_list\") + query_param",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        self.assertInHTML(locations[0].name, response_content)",
            "        self.assertInHTML(locations[1].name, response_content)",
            "",
            "    def test_filtering_crafted_query_params(self):",
            "        \"\"\"Test for reflected-XSS vulnerability GHSA-jxgr-gcj5-cqqg.\"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "        query_param = \"?location_type=1 onmouseover=alert('hi') foo=bar\"",
            "        url = reverse(\"dcim:location_list\") + query_param",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_content = response.content.decode(response.charset)",
            "        # The important thing here is that the data-field-parent and data-field-value are correctly quoted",
            "        self.assertInHTML(",
            "            \"\"\"",
            "<span class=\"filter-selection-choice-remove remove-filter-param\"",
            "      data-field-type=\"child\"",
            "      data-field-parent=\"location_type\"",
            "      data-field-value=\"1 onmouseover=alert(&#x27;hi&#x27;) foo=bar\"",
            ">\u00d7</span>\"\"\",  # noqa: RUF001 - ambiguous-unicode-character-string",
            "            response_content,",
            "        )",
            "",
            "",
            "class ForceScriptNameTestcase(TestCase):",
            "    \"\"\"Basic test to assert that `settings.FORCE_SCRIPT_NAME` works as intended.\"\"\"",
            "",
            "    @override_settings(",
            "        FORCE_SCRIPT_NAME=\"/nautobot/\",",
            "    )",
            "    @override_script_prefix(\"/nautobot/\")",
            "    def test_subdirectory_routes(self):",
            "        # We must call `set_script_prefix()` to set the URL resolver script prefix outside of the",
            "        # request/response cycle (e.g. in scripts/tests) to generate correct URLs when `SCRIPT_NAME`",
            "        # is not `/`.",
            "        #",
            "        # We must then call it again to reset the script pefix after we're done because",
            "        # the state is stored in the thread-local scope and will \"infect\" other tests.",
            "        prefix = get_script_prefix()",
            "        self.assertEqual(prefix, \"/nautobot/\")",
            "",
            "        # And that routes will start w/ the prefix vs. just \"/\" (the default).",
            "        routes = (\"home\", \"login\", \"search\", \"api-root\")",
            "        for route in routes:",
            "            url = reverse(route)",
            "            self.assertTrue(url.startswith(prefix))",
            "",
            "",
            "class NavAppsUITestCase(TestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.url = reverse(\"apps:apps_list\")",
            "        self.item_weight = 100  # TODO: not easy to introspect from the nav menu struct, so hard-code it here for now",
            "",
            "    def make_request(self):",
            "        response = self.client.get(reverse(\"home\"))",
            "        return response.content.decode(response.charset)",
            "",
            "    def test_installed_apps_visible(self):",
            "        \"\"\"The \"Installed Apps\" menu item should be available to an authenticated user regardless of permissions.\"\"\"",
            "        response_content = self.make_request()",
            "        self.assertInHTML(",
            "            f\"\"\"",
            "            <a href=\"{self.url}\"",
            "                data-item-weight=\"{self.item_weight}\">",
            "                Installed Apps",
            "            </a>",
            "            \"\"\",",
            "            response_content,",
            "        )",
            "",
            "",
            "class LoginUITestCase(TestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.footer_elements = [",
            "            '<a href=\"#theme_modal\" data-toggle=\"modal\" data-target=\"#theme_modal\" id=\"btn-theme-modal\"><i class=\"mdi mdi-theme-light-dark text-primary\"></i>Theme</a>',",
            "            '<a href=\"/static/docs/index.html\">Docs</a>',",
            "            '<i class=\"mdi mdi-cloud-braces text-primary\"></i> <a href=\"/api/docs/\">API</a>',",
            "            '<i class=\"mdi mdi-graphql text-primary\"></i> <a href=\"/graphql/\">GraphQL</a>',",
            "            '<i class=\"mdi mdi-xml text-primary\"></i> <a href=\"https://github.com/nautobot/nautobot\">Code</a>',",
            "            '<i class=\"mdi mdi-lifebuoy text-primary\"></i> <a href=\"https://github.com/nautobot/nautobot/wiki\">Help</a>',",
            "        ]",
            "",
            "    def make_request(self):",
            "        response = self.client.get(reverse(\"login\"))",
            "        sso_login_pattern = re.compile('<a href=\".*\">Continue with SSO</a>')",
            "        return sso_login_pattern.search(response.content.decode(response.charset))",
            "",
            "    def test_sso_login_button_not_visible(self):",
            "        \"\"\"Test Continue with SSO button not visible if SSO is enabled\"\"\"",
            "        self.client.logout()",
            "",
            "        sso_login_search_result = self.make_request()",
            "        self.assertIsNone(sso_login_search_result)",
            "",
            "    @override_settings(",
            "        AUTHENTICATION_BACKENDS=[",
            "            \"social_core.backends.google.GoogleOAuth2\",",
            "            \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "        ]",
            "    )",
            "    def test_sso_login_button_visible(self):",
            "        self.client.logout()",
            "        sso_login_search_result = self.make_request()",
            "        self.assertIsNotNone(sso_login_search_result)",
            "",
            "    def test_graphql_redirects_back_to_login_unauthenticated(self):",
            "        \"\"\"Assert that graphql redirects to login page if user is unauthenticated.\"\"\"",
            "        self.client.logout()",
            "        headers = {\"HTTP_ACCEPT\": \"text/html\"}",
            "        url = reverse(\"graphql\")",
            "        response = self.client.get(url, follow=True, **headers)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        for footer_text in self.footer_elements:",
            "            self.assertNotIn(footer_text, response_content)",
            "",
            "    def test_api_docs_403_unauthenticated(self):",
            "        \"\"\"Assert that api docs return a 403 Forbidden if user is unauthenticated.\"\"\"",
            "        self.client.logout()",
            "        urls = [",
            "            reverse(\"api_docs\"),",
            "            reverse(\"api_redocs\"),",
            "            reverse(\"schema\"),",
            "            reverse(\"schema_json\"),",
            "            reverse(\"schema_yaml\"),",
            "        ]",
            "        for url in urls:",
            "            response = self.client.get(url)",
            "            self.assertHttpStatus(response, 403)",
            "",
            "",
            "class MetricsViewTestCase(TestCase):",
            "    def query_and_parse_metrics(self):",
            "        response = self.client.get(reverse(\"metrics\"))",
            "        self.assertHttpStatus(response, 200, msg=\"/metrics should return a 200 HTTP status code.\")",
            "        page_content = response.content.decode(response.charset)",
            "        return text_string_to_metric_families(page_content)",
            "",
            "    def test_metrics_extensibility(self):",
            "        \"\"\"Assert that the example metric from the Example App shows up _exactly_ when the app is enabled.\"\"\"",
            "        test_metric_name = \"nautobot_example_metric_count\"",
            "        metrics_with_app = self.query_and_parse_metrics()",
            "        metric_names_with_app = {metric.name for metric in metrics_with_app}",
            "        self.assertIn(test_metric_name, metric_names_with_app)",
            "        with override_settings(PLUGINS=[]):",
            "            # Clear out the app metric registry because it is not updated when settings are changed but Nautobot is not",
            "            # restarted.",
            "            registry[\"app_metrics\"].clear()",
            "            metrics_without_app = self.query_and_parse_metrics()",
            "            metric_names_without_app = {metric.name for metric in metrics_without_app}",
            "            self.assertNotIn(test_metric_name, metric_names_without_app)",
            "        metric_names_with_app.remove(test_metric_name)",
            "        self.assertSetEqual(metric_names_with_app, metric_names_without_app)",
            "",
            "",
            "class AuthenticateMetricsTestCase(APITestCase):",
            "    def test_metrics_authentication(self):",
            "        \"\"\"Assert that if metrics require authentication, a user not logged in gets a 403.\"\"\"",
            "        self.client.logout()",
            "        headers = {}",
            "        response = self.client.get(reverse(\"metrics\"), **headers)",
            "        self.assertHttpStatus(response, 403, msg=\"/metrics should return a 403 HTTP status code.\")",
            "",
            "    def test_metrics(self):",
            "        \"\"\"Assert that if metrics don't require authentication, a user not logged in gets a 200.\"\"\"",
            "        self.factory = RequestFactory()",
            "        self.client.logout()",
            "",
            "        request = self.factory.get(\"/\")",
            "        response = NautobotMetricsView.as_view()(request)",
            "        self.assertHttpStatus(response, 200, msg=\"/metrics should return a 200 HTTP status code.\")",
            "",
            "",
            "class ErrorPagesTestCase(TestCase):",
            "    \"\"\"Tests for 4xx and 5xx error page rendering.\"\"\"",
            "",
            "    @override_settings(DEBUG=False)",
            "    def test_404_default_support_message(self):",
            "        \"\"\"Nautobot's custom 404 page should be used and should include a default support message.\"\"\"",
            "        with self.assertTemplateUsed(\"404.html\"):",
            "            response = self.client.get(\"/foo/bar\")",
            "        self.assertContains(response, \"Network to Code\", status_code=404)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(",
            "            \"If further assistance is required, please join the <code>#nautobot</code> channel on \"",
            "            '<a href=\"https://slack.networktocode.com/\" rel=\"noopener noreferrer\">Network to Code\\'s '",
            "            \"Slack community</a> and post your question.\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")",
            "    def test_404_custom_support_message(self):",
            "        \"\"\"Nautobot's custom 404 page should be used and should include a custom support message if defined.\"\"\"",
            "        with self.assertTemplateUsed(\"404.html\"):",
            "            response = self.client.get(\"/foo/bar\")",
            "        self.assertNotContains(response, \"Network to Code\", status_code=404)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(\"Hello world!\", response_content)",
            "",
            "    @override_settings(DEBUG=False)",
            "    @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)",
            "    def test_500_default_support_message(self, mock_get):",
            "        \"\"\"Nautobot's custom 500 page should be used and should include a default support message.\"\"\"",
            "        url = reverse(\"home\")",
            "        with self.assertTemplateUsed(\"500.html\"):",
            "            self.client.raise_request_exception = False",
            "            response = self.client.get(url)",
            "        self.assertContains(response, \"Network to Code\", status_code=500)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(",
            "            \"If further assistance is required, please join the <code>#nautobot</code> channel on \"",
            "            '<a href=\"https://slack.networktocode.com/\" rel=\"noopener noreferrer\">Network to Code\\'s '",
            "            \"Slack community</a> and post your question.\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")",
            "    @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)",
            "    def test_500_custom_support_message(self, mock_get):",
            "        \"\"\"Nautobot's custom 500 page should be used and should include a custom support message if defined.\"\"\"",
            "        url = reverse(\"home\")",
            "        with self.assertTemplateUsed(\"500.html\"):",
            "            self.client.raise_request_exception = False",
            "            response = self.client.get(url)",
            "        self.assertNotContains(response, \"Network to Code\", status_code=500)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(\"Hello world!\", response_content)",
            "",
            "",
            "class DBFileStorageViewTestCase(TestCase):",
            "    \"\"\"Test authentication/permission enforcement for django_db_file_storage views.\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.test_file_1 = SimpleUploadedFile(name=\"test_file_1.txt\", content=b\"I am content.\\n\")",
            "        self.file_proxy_1 = FileProxy.objects.create(name=self.test_file_1.name, file=self.test_file_1)",
            "        self.test_file_2 = SimpleUploadedFile(name=\"test_file_2.txt\", content=b\"I am content.\\n\")",
            "        self.file_proxy_2 = FileProxy.objects.create(name=self.test_file_2.name, file=self.test_file_2)",
            "        self.url = f\"{reverse('db_file_storage.download_file')}?name={self.file_proxy_1.file.name}\"",
            "",
            "    def test_get_file_anonymous(self):",
            "        self.client.logout()",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 403)",
            "",
            "    def test_get_file_without_permission(self):",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 403)",
            "",
            "    def test_get_object_with_permission(self):",
            "        self.add_permissions(get_permission_for_model(FileProxy, \"view\"))",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_get_object_with_constrained_permission(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": self.file_proxy_1.pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(FileProxy))",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 200)",
            "        url = f\"{reverse('db_file_storage.download_file')}?name={self.file_proxy_2.file.name}\"",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 404)",
            "",
            "",
            "class SilkUIAccessTestCase(TestCase):",
            "    \"\"\"Test access control related to the django-silk UI\"\"\"",
            "",
            "    def test_access_for_non_superuser(self):",
            "        # Login as non-superuser",
            "        self.user.is_superuser = False",
            "        self.user.save()",
            "        self.client.force_login(self.user)",
            "",
            "        # Attempt to access the view",
            "        response = self.client.get(reverse(\"silk:summary\"))",
            "",
            "        # Check for redirect or forbidden status code (302 or 403)",
            "        self.assertIn(response.status_code, [302, 403])",
            "",
            "    def test_access_for_superuser(self):",
            "        # Login as superuser",
            "        self.user.is_superuser = True",
            "        self.user.save()",
            "        self.client.force_login(self.user)",
            "",
            "        # Attempt to access the view",
            "        response = self.client.get(reverse(\"silk:summary\"))",
            "",
            "        # Check for success status code (e.g., 200)",
            "        self.assertEqual(response.status_code, 200)"
        ],
        "afterPatchFile": [
            "import re",
            "from unittest import mock",
            "import urllib.parse",
            "",
            "from django.apps import apps",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import override_settings, RequestFactory",
            "from django.test.utils import override_script_prefix",
            "from django.urls import get_script_prefix, reverse",
            "from prometheus_client.parser import text_string_to_metric_families",
            "",
            "from nautobot.core.constants import GLOBAL_SEARCH_EXCLUDE_LIST",
            "from nautobot.core.testing import TestCase",
            "from nautobot.core.testing.api import APITestCase",
            "from nautobot.core.utils.permissions import get_permission_for_model",
            "from nautobot.core.views import NautobotMetricsView",
            "from nautobot.core.views.mixins import GetReturnURLMixin",
            "from nautobot.dcim.models.locations import Location",
            "from nautobot.extras.choices import CustomFieldTypeChoices",
            "from nautobot.extras.models import FileProxy",
            "from nautobot.extras.models.customfields import CustomField, CustomFieldChoice",
            "from nautobot.extras.registry import registry",
            "from nautobot.users.models import ObjectPermission",
            "",
            "",
            "class GetReturnURLMixinTestCase(TestCase):",
            "    \"\"\"Tests for the API of GetReturnURLMixin.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.factory = RequestFactory(SERVER_NAME=\"nautobot.example.com\")",
            "        cls.mixin = GetReturnURLMixin()",
            "",
            "    def test_get_return_url_explicit(self):",
            "        request = self.factory.get(\"/\", {\"return_url\": \"/dcim/devices/\"})",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), \"/dcim/devices/\")",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=Location.objects.first()), \"/dcim/devices/\")",
            "",
            "        request = self.factory.get(\"/\", {\"return_url\": \"/dcim/devices/?status=Active\"})",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), \"/dcim/devices/?status=Active\")",
            "",
            "    def test_get_return_url_explicit_unsafe(self):",
            "        request = self.factory.get(\"/\", {\"return_url\": \"http://example.com\"})",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), reverse(\"home\"))",
            "",
            "    def test_get_return_url_explicit_punycode(self):",
            "        \"\"\"",
            "        Replace the 'i' in '/dcim/' with a unicode dotless '\u0131' and make sure we're not fooled by it.",
            "        \"\"\"  # noqa: RUF002  # ambiguous-unicode-character-docstring -- fully intentional here!",
            "        request = self.factory.get(\"/\", {\"return_url\": \"/dc\u0131m/devices/\"})  # noqa: RUF001  # ambiguous-unicode-character-string -- fully intentional here!",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), \"/dc%C4%B1m/devices/\")",
            "",
            "    def test_get_return_url_default_with_obj(self):",
            "        request = self.factory.get(\"/\")",
            "        location = Location.objects.first()",
            "        self.assertEqual(self.mixin.get_return_url(request=request, obj=location), location.get_absolute_url())",
            "",
            "",
            "class HomeViewTestCase(TestCase):",
            "    def test_home(self):",
            "        url = reverse(\"home\")",
            "",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_search(self):",
            "        url = reverse(\"search\")",
            "        params = {",
            "            \"q\": \"foo\",",
            "        }",
            "",
            "        response = self.client.get(f\"{url}?{urllib.parse.urlencode(params)}\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_appropriate_models_included_in_global_search(self):",
            "        # Gather core app configs",
            "        existing_models = []",
            "        global_searchable_models = []",
            "        for app_name in [\"circuits\", \"dcim\", \"extras\", \"ipam\", \"tenancy\", \"virtualization\"]:",
            "            app_config = apps.get_app_config(app_name)",
            "            existing_models += [model._meta.model_name for model in app_config.get_models()]",
            "            global_searchable_models += app_config.searchable_models",
            "",
            "        # Remove those models that are not searchable",
            "        existing_models = [model for model in existing_models if model not in GLOBAL_SEARCH_EXCLUDE_LIST]",
            "        existing_models.sort()",
            "",
            "        # See if there are any models that are missing from global search",
            "        difference = [model for model in existing_models if model not in global_searchable_models]",
            "        if difference:",
            "            self.fail(",
            "                f'Existing model/models {\",\".join(difference)} are not included in the searchable_models attribute of the app config.\\n'",
            "                'If you do not want the models to be searchable, please include them in the GLOBAL_SEARCH_EXCLUDE_LIST constant in nautobot.core.constants.'",
            "            )",
            "",
            "    def make_request(self):",
            "        url = reverse(\"home\")",
            "        response = self.client.get(url)",
            "",
            "        # Search bar in nav",
            "        nav_search_bar_pattern = re.compile(",
            "            '<nav.*<form action=\"/search/\" method=\"get\" class=\"navbar-form\" id=\"navbar_search\" role=\"search\">.*</form>.*</nav>'",
            "        )",
            "        nav_search_bar_result = nav_search_bar_pattern.search(",
            "            response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        )",
            "",
            "        # Global search bar in body/container-fluid wrapper",
            "        body_search_bar_pattern = re.compile(",
            "            '<div class=\"container-fluid wrapper\" id=\"main-content\">.*<form action=\"/search/\" method=\"get\" class=\"form-inline\">.*</form>.*</div>',",
            "            re.DOTALL,",
            "        )",
            "",
            "        body_search_bar_result = body_search_bar_pattern.search(",
            "            response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        )",
            "",
            "        return nav_search_bar_result, body_search_bar_result",
            "",
            "    def test_search_bar_not_visible_if_user_not_authenticated(self):",
            "        self.client.logout()",
            "",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNone(nav_search_bar_result)",
            "        self.assertIsNone(body_search_bar_result)",
            "",
            "    def test_search_bar_visible_if_user_authenticated(self):",
            "        nav_search_bar_result, body_search_bar_result = self.make_request()",
            "",
            "        self.assertIsNotNone(nav_search_bar_result)",
            "        self.assertIsNotNone(body_search_bar_result)",
            "",
            "    @override_settings(VERSION=\"1.2.3\")",
            "    def test_footer_version_visible_authenticated_users_only(self):",
            "        url = reverse(\"home\")",
            "        response = self.client.get(url)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "",
            "        footer_hostname_version_pattern = re.compile(r'<p class=\"text-muted\">\\s+\\S+\\s+\\(v1\\.2\\.3\\)\\s+</p>')",
            "        self.assertRegex(response_content, footer_hostname_version_pattern)",
            "",
            "        self.client.logout()",
            "        response = self.client.get(url)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        self.assertNotRegex(response_content, footer_hostname_version_pattern)",
            "",
            "    def test_banners_markdown(self):",
            "        url = reverse(\"home\")",
            "        with override_settings(",
            "            BANNER_TOP=\"# Hello world\",",
            "            BANNER_BOTTOM=\"[info](https://nautobot.com)\",",
            "        ):",
            "            response = self.client.get(url)",
            "        self.assertInHTML(\"<h1>Hello world</h1>\", response.content.decode(response.charset))",
            "        self.assertInHTML(",
            "            '<a href=\"https://nautobot.com\" rel=\"noopener noreferrer\">info</a>',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        with override_settings(BANNER_LOGIN=\"_Welcome to Nautobot!_\"):",
            "            self.client.logout()",
            "            response = self.client.get(reverse(\"login\"))",
            "        self.assertInHTML(\"<em>Welcome to Nautobot!</em>\", response.content.decode(response.charset))",
            "",
            "    def test_banners_no_xss(self):",
            "        url = reverse(\"home\")",
            "        with override_settings(",
            "            BANNER_TOP='<script>alert(\"Hello from above!\");</script>',",
            "            BANNER_BOTTOM='<script>alert(\"Hello from below!\");</script>',",
            "        ):",
            "            response = self.client.get(url)",
            "        self.assertNotIn(\"Hello from above\", response.content.decode(response.charset))",
            "        self.assertNotIn(\"Hello from below\", response.content.decode(response.charset))",
            "",
            "        with override_settings(BANNER_LOGIN='<script>alert(\"Welcome to Nautobot!\");</script>'):",
            "            self.client.logout()",
            "            response = self.client.get(reverse(\"login\"))",
            "        self.assertNotIn(\"Welcome to Nautobot!\", response.content.decode(response.charset))",
            "",
            "",
            "@override_settings(BRANDING_TITLE=\"Nautobot\")",
            "class SearchFieldsTestCase(TestCase):",
            "    def test_search_bar_redirect_to_login(self):",
            "        self.client.logout()",
            "        response = self.client.get(reverse(\"search\") + \"?q=prefix\")",
            "        # Assert that if the user is not logged in",
            "        # SearchForm will redirect the user to the login Page",
            "        self.assertEqual(response.status_code, 302)",
            "",
            "    def test_global_and_model_search_bar(self):",
            "        self.add_permissions(\"dcim.view_location\", \"dcim.view_device\")",
            "",
            "        # Assert model search bar present in list UI",
            "        response = self.client.get(reverse(\"dcim:location_list\"))",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" required placeholder=\"Search Locations\" id=\"id_q\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        response = self.client.get(reverse(\"dcim:device_list\"))",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" required placeholder=\"Search Devices\" id=\"id_q\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        # Assert global search bar present in UI",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"q\" class=\"form-control\" placeholder=\"Search Nautobot\">',",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "",
            "class FilterFormsTestCase(TestCase):",
            "    def test_support_for_both_default_and_dynamic_filter_form_in_ui(self):",
            "        self.add_permissions(\"dcim.view_location\", \"circuits.view_circuit\")",
            "",
            "        filter_tabs = \"\"\"",
            "            <ul id=\"tabs\" class=\"nav nav-tabs\">",
            "                <li role=\"presentation\" class=\"active\">",
            "                    <a href=\"#default-filter\" role=\"tab\" data-toggle=\"tab\">",
            "                        Default",
            "                    </a>",
            "                </li>",
            "                <li role=\"presentation\" class=\"\">",
            "                    <a href=\"#advanced-filter\" role=\"tab\" data-toggle=\"tab\">",
            "                        Advanced",
            "                    </a>",
            "                </li>",
            "            </ul>",
            "            \"\"\"",
            "",
            "        response = self.client.get(reverse(\"dcim:location_list\"))",
            "        self.assertInHTML(",
            "            filter_tabs,",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "        response = self.client.get(reverse(\"circuits:circuit_list\"))",
            "        self.assertInHTML(",
            "            filter_tabs,",
            "            response.content.decode(response.charset),",
            "        )",
            "",
            "    def test_filtering_on_custom_select_filter_field(self):",
            "        \"\"\"Assert CustomField select and multiple select fields can be filtered using multiple entries\"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "",
            "        multi_select_cf = CustomField.objects.create(",
            "            type=CustomFieldTypeChoices.TYPE_MULTISELECT, label=\"Multiple Choice\"",
            "        )",
            "        select_cf = CustomField.objects.create(type=CustomFieldTypeChoices.TYPE_SELECT, label=\"choice\")",
            "        choices = [\"Foo\", \"Bar\", \"FooBar\"]",
            "        for cf in [multi_select_cf, select_cf]:",
            "            cf.content_types.set([ContentType.objects.get_for_model(Location)])",
            "            CustomFieldChoice.objects.create(custom_field=cf, value=choices[0])",
            "            CustomFieldChoice.objects.create(custom_field=cf, value=choices[1])",
            "            CustomFieldChoice.objects.create(custom_field=cf, value=choices[2])",
            "",
            "        locations = Location.objects.all()[:3]",
            "        for idx, location in enumerate(locations):",
            "            location.cf[multi_select_cf.key] = choices[:2]",
            "            location.cf[select_cf.key] = choices[idx]",
            "            location.save()",
            "",
            "        query_param = (",
            "            f\"?cf_{multi_select_cf.key}={choices[0]}&cf_{multi_select_cf.key}={choices[1]}\"",
            "            f\"&cf_{select_cf.key}={choices[0]}&cf_{select_cf.key}={choices[1]}\"",
            "        )",
            "        url = reverse(\"dcim:location_list\") + query_param",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        self.assertInHTML(locations[0].name, response_content)",
            "        self.assertInHTML(locations[1].name, response_content)",
            "",
            "    def test_filtering_crafted_query_params(self):",
            "        \"\"\"Test for reflected-XSS vulnerability GHSA-jxgr-gcj5-cqqg.\"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "        query_param = \"?location_type=1 onmouseover=alert('hi') foo=bar\"",
            "        url = reverse(\"dcim:location_list\") + query_param",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_content = response.content.decode(response.charset)",
            "        # The important thing here is that the data-field-parent and data-field-value are correctly quoted",
            "        self.assertInHTML(",
            "            \"\"\"",
            "<span class=\"filter-selection-choice-remove remove-filter-param\"",
            "      data-field-type=\"child\"",
            "      data-field-parent=\"location_type\"",
            "      data-field-value=\"1 onmouseover=alert(&#x27;hi&#x27;) foo=bar\"",
            ">\u00d7</span>\"\"\",  # noqa: RUF001 - ambiguous-unicode-character-string",
            "            response_content,",
            "        )",
            "",
            "",
            "class ForceScriptNameTestcase(TestCase):",
            "    \"\"\"Basic test to assert that `settings.FORCE_SCRIPT_NAME` works as intended.\"\"\"",
            "",
            "    @override_settings(",
            "        FORCE_SCRIPT_NAME=\"/nautobot/\",",
            "    )",
            "    @override_script_prefix(\"/nautobot/\")",
            "    def test_subdirectory_routes(self):",
            "        # We must call `set_script_prefix()` to set the URL resolver script prefix outside of the",
            "        # request/response cycle (e.g. in scripts/tests) to generate correct URLs when `SCRIPT_NAME`",
            "        # is not `/`.",
            "        #",
            "        # We must then call it again to reset the script pefix after we're done because",
            "        # the state is stored in the thread-local scope and will \"infect\" other tests.",
            "        prefix = get_script_prefix()",
            "        self.assertEqual(prefix, \"/nautobot/\")",
            "",
            "        # And that routes will start w/ the prefix vs. just \"/\" (the default).",
            "        routes = (\"home\", \"login\", \"search\", \"api-root\")",
            "        for route in routes:",
            "            url = reverse(route)",
            "            self.assertTrue(url.startswith(prefix))",
            "",
            "",
            "class NavAppsUITestCase(TestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.url = reverse(\"apps:apps_list\")",
            "        self.item_weight = 100  # TODO: not easy to introspect from the nav menu struct, so hard-code it here for now",
            "",
            "    def make_request(self):",
            "        response = self.client.get(reverse(\"home\"))",
            "        return response.content.decode(response.charset)",
            "",
            "    def test_installed_apps_visible(self):",
            "        \"\"\"The \"Installed Apps\" menu item should be available to an authenticated user regardless of permissions.\"\"\"",
            "        response_content = self.make_request()",
            "        self.assertInHTML(",
            "            f\"\"\"",
            "            <a href=\"{self.url}\"",
            "                data-item-weight=\"{self.item_weight}\">",
            "                Installed Apps",
            "            </a>",
            "            \"\"\",",
            "            response_content,",
            "        )",
            "",
            "",
            "class LoginUITestCase(TestCase):",
            "    def setUp(self):",
            "        super().setUp()",
            "",
            "        self.footer_elements = [",
            "            '<a href=\"#theme_modal\" data-toggle=\"modal\" data-target=\"#theme_modal\" id=\"btn-theme-modal\"><i class=\"mdi mdi-theme-light-dark text-primary\"></i>Theme</a>',",
            "            '<a href=\"/static/docs/index.html\">Docs</a>',",
            "            '<i class=\"mdi mdi-cloud-braces text-primary\"></i> <a href=\"/api/docs/\">API</a>',",
            "            '<i class=\"mdi mdi-graphql text-primary\"></i> <a href=\"/graphql/\">GraphQL</a>',",
            "            '<i class=\"mdi mdi-xml text-primary\"></i> <a href=\"https://github.com/nautobot/nautobot\">Code</a>',",
            "            '<i class=\"mdi mdi-lifebuoy text-primary\"></i> <a href=\"https://github.com/nautobot/nautobot/wiki\">Help</a>',",
            "        ]",
            "",
            "    def make_request(self):",
            "        response = self.client.get(reverse(\"login\"))",
            "        sso_login_pattern = re.compile('<a href=\".*\">Continue with SSO</a>')",
            "        return sso_login_pattern.search(response.content.decode(response.charset))",
            "",
            "    def test_sso_login_button_not_visible(self):",
            "        \"\"\"Test Continue with SSO button not visible if SSO is enabled\"\"\"",
            "        self.client.logout()",
            "",
            "        sso_login_search_result = self.make_request()",
            "        self.assertIsNone(sso_login_search_result)",
            "",
            "    @override_settings(",
            "        AUTHENTICATION_BACKENDS=[",
            "            \"social_core.backends.google.GoogleOAuth2\",",
            "            \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "        ]",
            "    )",
            "    def test_sso_login_button_visible(self):",
            "        self.client.logout()",
            "        sso_login_search_result = self.make_request()",
            "        self.assertIsNotNone(sso_login_search_result)",
            "",
            "    def test_graphql_redirects_back_to_login_unauthenticated(self):",
            "        \"\"\"Assert that graphql redirects to login page if user is unauthenticated.\"\"\"",
            "        self.client.logout()",
            "        headers = {\"HTTP_ACCEPT\": \"text/html\"}",
            "        url = reverse(\"graphql\")",
            "        response = self.client.get(url, follow=True, **headers)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "        response_content = response.content.decode(response.charset).replace(\"\\n\", \"\")",
            "        for footer_text in self.footer_elements:",
            "            self.assertNotIn(footer_text, response_content)",
            "",
            "    def test_api_docs_403_unauthenticated(self):",
            "        \"\"\"Assert that api docs return a 403 Forbidden if user is unauthenticated.\"\"\"",
            "        self.client.logout()",
            "        urls = [",
            "            reverse(\"api_docs\"),",
            "            reverse(\"api_redocs\"),",
            "            reverse(\"schema\"),",
            "            reverse(\"schema_json\"),",
            "            reverse(\"schema_yaml\"),",
            "        ]",
            "        for url in urls:",
            "            response = self.client.get(url)",
            "            self.assertHttpStatus(response, 403)",
            "",
            "",
            "class MetricsViewTestCase(TestCase):",
            "    def query_and_parse_metrics(self):",
            "        response = self.client.get(reverse(\"metrics\"))",
            "        self.assertHttpStatus(response, 200, msg=\"/metrics should return a 200 HTTP status code.\")",
            "        page_content = response.content.decode(response.charset)",
            "        return text_string_to_metric_families(page_content)",
            "",
            "    def test_metrics_extensibility(self):",
            "        \"\"\"Assert that the example metric from the Example App shows up _exactly_ when the app is enabled.\"\"\"",
            "        test_metric_name = \"nautobot_example_metric_count\"",
            "        metrics_with_app = self.query_and_parse_metrics()",
            "        metric_names_with_app = {metric.name for metric in metrics_with_app}",
            "        self.assertIn(test_metric_name, metric_names_with_app)",
            "        with override_settings(PLUGINS=[]):",
            "            # Clear out the app metric registry because it is not updated when settings are changed but Nautobot is not",
            "            # restarted.",
            "            registry[\"app_metrics\"].clear()",
            "            metrics_without_app = self.query_and_parse_metrics()",
            "            metric_names_without_app = {metric.name for metric in metrics_without_app}",
            "            self.assertNotIn(test_metric_name, metric_names_without_app)",
            "        metric_names_with_app.remove(test_metric_name)",
            "        self.assertSetEqual(metric_names_with_app, metric_names_without_app)",
            "",
            "",
            "class AuthenticateMetricsTestCase(APITestCase):",
            "    def test_metrics_authentication(self):",
            "        \"\"\"Assert that if metrics require authentication, a user not logged in gets a 403.\"\"\"",
            "        self.client.logout()",
            "        headers = {}",
            "        response = self.client.get(reverse(\"metrics\"), **headers)",
            "        self.assertHttpStatus(response, 403, msg=\"/metrics should return a 403 HTTP status code.\")",
            "",
            "    def test_metrics(self):",
            "        \"\"\"Assert that if metrics don't require authentication, a user not logged in gets a 200.\"\"\"",
            "        self.factory = RequestFactory()",
            "        self.client.logout()",
            "",
            "        request = self.factory.get(\"/\")",
            "        response = NautobotMetricsView.as_view()(request)",
            "        self.assertHttpStatus(response, 200, msg=\"/metrics should return a 200 HTTP status code.\")",
            "",
            "",
            "class ErrorPagesTestCase(TestCase):",
            "    \"\"\"Tests for 4xx and 5xx error page rendering.\"\"\"",
            "",
            "    @override_settings(DEBUG=False)",
            "    def test_404_default_support_message(self):",
            "        \"\"\"Nautobot's custom 404 page should be used and should include a default support message.\"\"\"",
            "        with self.assertTemplateUsed(\"404.html\"):",
            "            response = self.client.get(\"/foo/bar\")",
            "        self.assertContains(response, \"Network to Code\", status_code=404)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(",
            "            \"If further assistance is required, please join the <code>#nautobot</code> channel on \"",
            "            '<a href=\"https://slack.networktocode.com/\" rel=\"noopener noreferrer\">Network to Code\\'s '",
            "            \"Slack community</a> and post your question.\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")",
            "    def test_404_custom_support_message(self):",
            "        \"\"\"Nautobot's custom 404 page should be used and should include a custom support message if defined.\"\"\"",
            "        with self.assertTemplateUsed(\"404.html\"):",
            "            response = self.client.get(\"/foo/bar\")",
            "        self.assertNotContains(response, \"Network to Code\", status_code=404)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(\"Hello world!\", response_content)",
            "",
            "    @override_settings(DEBUG=False)",
            "    @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)",
            "    def test_500_default_support_message(self, mock_get):",
            "        \"\"\"Nautobot's custom 500 page should be used and should include a default support message.\"\"\"",
            "        url = reverse(\"home\")",
            "        with self.assertTemplateUsed(\"500.html\"):",
            "            self.client.raise_request_exception = False",
            "            response = self.client.get(url)",
            "        self.assertContains(response, \"Network to Code\", status_code=500)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(",
            "            \"If further assistance is required, please join the <code>#nautobot</code> channel on \"",
            "            '<a href=\"https://slack.networktocode.com/\" rel=\"noopener noreferrer\">Network to Code\\'s '",
            "            \"Slack community</a> and post your question.\",",
            "            response_content,",
            "        )",
            "",
            "    @override_settings(DEBUG=False, SUPPORT_MESSAGE=\"Hello world!\")",
            "    @mock.patch(\"nautobot.core.views.HomeView.get\", side_effect=Exception)",
            "    def test_500_custom_support_message(self, mock_get):",
            "        \"\"\"Nautobot's custom 500 page should be used and should include a custom support message if defined.\"\"\"",
            "        url = reverse(\"home\")",
            "        with self.assertTemplateUsed(\"500.html\"):",
            "            self.client.raise_request_exception = False",
            "            response = self.client.get(url)",
            "        self.assertNotContains(response, \"Network to Code\", status_code=500)",
            "        response_content = response.content.decode(response.charset)",
            "        self.assertInHTML(\"Hello world!\", response_content)",
            "",
            "",
            "class DBFileStorageViewTestCase(TestCase):",
            "    \"\"\"Test authentication/permission enforcement for django_db_file_storage views.\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.test_file_1 = SimpleUploadedFile(name=\"test_file_1.txt\", content=b\"I am content.\\n\")",
            "        self.file_proxy_1 = FileProxy.objects.create(name=self.test_file_1.name, file=self.test_file_1)",
            "        self.test_file_2 = SimpleUploadedFile(name=\"test_file_2.txt\", content=b\"I am content.\\n\")",
            "        self.file_proxy_2 = FileProxy.objects.create(name=self.test_file_2.name, file=self.test_file_2)",
            "        self.url = f\"{reverse('db_file_storage.download_file')}?name={self.file_proxy_1.file.name}\"",
            "",
            "    def test_get_file_anonymous(self):",
            "        self.client.logout()",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 403)",
            "",
            "    def test_get_file_without_permission(self):",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 403)",
            "",
            "    def test_get_object_with_permission(self):",
            "        self.add_permissions(get_permission_for_model(FileProxy, \"view\"))",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_get_object_with_constrained_permission(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": self.file_proxy_1.pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(FileProxy))",
            "        response = self.client.get(self.url)",
            "        self.assertHttpStatus(response, 200)",
            "        url = f\"{reverse('db_file_storage.download_file')}?name={self.file_proxy_2.file.name}\"",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 404)",
            "",
            "",
            "class SilkUIAccessTestCase(TestCase):",
            "    \"\"\"Test access control related to the django-silk UI\"\"\"",
            "",
            "    def test_access_for_non_superuser(self):",
            "        # Login as non-superuser",
            "        self.user.is_superuser = False",
            "        self.user.save()",
            "        self.client.force_login(self.user)",
            "",
            "        # Attempt to access the view",
            "        response = self.client.get(reverse(\"silk:summary\"))",
            "",
            "        # Check for redirect or forbidden status code (302 or 403)",
            "        self.assertIn(response.status_code, [302, 403])",
            "",
            "    def test_access_for_superuser(self):",
            "        # Login as superuser",
            "        self.user.is_superuser = True",
            "        self.user.save()",
            "        self.client.force_login(self.user)",
            "",
            "        # Attempt to access the view",
            "        response = self.client.get(reverse(\"silk:summary\"))",
            "",
            "        # Check for success status code (e.g., 200)",
            "        self.assertEqual(response.status_code, 200)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nautobot.core.tests.test_views.HomeViewTestCase.self",
            "tensorflow.python.kernel_tests.quantization_ops.quantization_ops_test"
        ]
    }
}