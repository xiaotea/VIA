{
    "src/api-service/__app__/info/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     get_instance_id,"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     get_subscription,"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from ..onefuzzlib.endpoint_authorization import call_if_user"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from ..onefuzzlib.request import ok"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from ..onefuzzlib.versions import versions"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def main(req: func.HttpRequest) -> func.HttpResponse:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+def get(req: func.HttpRequest) -> func.HttpResponse:"
            },
            "10": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     response = ok("
            },
            "11": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         Info("
            },
            "12": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "             resource_group=get_base_resource_group(),"
            },
            "13": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     )"
            },
            "14": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     return response"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+def main(req: func.HttpRequest) -> func.HttpResponse:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    methods = {\"GET\": get}"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    method = methods[req.method]"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    result = call_if_user(req, method)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    return result"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import azure.functions as func",
            "from onefuzztypes.responses import Info",
            "",
            "from ..onefuzzlib.azure.creds import (",
            "    get_base_region,",
            "    get_base_resource_group,",
            "    get_insights_appid,",
            "    get_insights_instrumentation_key,",
            "    get_instance_id,",
            "    get_subscription,",
            ")",
            "from ..onefuzzlib.request import ok",
            "from ..onefuzzlib.versions import versions",
            "",
            "",
            "def main(req: func.HttpRequest) -> func.HttpResponse:",
            "    response = ok(",
            "        Info(",
            "            resource_group=get_base_resource_group(),",
            "            region=get_base_region(),",
            "            subscription=get_subscription(),",
            "            versions=versions(),",
            "            instance_id=get_instance_id(),",
            "            insights_appid=get_insights_appid(),",
            "            insights_instrumentation_key=get_insights_instrumentation_key(),",
            "        )",
            "    )",
            "",
            "    return response"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import azure.functions as func",
            "from onefuzztypes.responses import Info",
            "",
            "from ..onefuzzlib.azure.creds import (",
            "    get_base_region,",
            "    get_base_resource_group,",
            "    get_insights_appid,",
            "    get_insights_instrumentation_key,",
            "    get_instance_id,",
            "    get_subscription,",
            ")",
            "from ..onefuzzlib.endpoint_authorization import call_if_user",
            "from ..onefuzzlib.request import ok",
            "from ..onefuzzlib.versions import versions",
            "",
            "",
            "def get(req: func.HttpRequest) -> func.HttpResponse:",
            "    response = ok(",
            "        Info(",
            "            resource_group=get_base_resource_group(),",
            "            region=get_base_region(),",
            "            subscription=get_subscription(),",
            "            versions=versions(),",
            "            instance_id=get_instance_id(),",
            "            insights_appid=get_insights_appid(),",
            "            insights_instrumentation_key=get_insights_instrumentation_key(),",
            "        )",
            "    )",
            "",
            "    return response",
            "",
            "",
            "def main(req: func.HttpRequest) -> func.HttpResponse:",
            "    methods = {\"GET\": get}",
            "    method = methods[req.method]",
            "    result = call_if_user(req, method)",
            "",
            "    return result"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "21": [
                "main"
            ]
        },
        "addLocation": []
    },
    "src/api-service/__app__/negotiate/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import azure.functions as func"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from ..onefuzzlib.endpoint_authorization import call_if_user"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " # This endpoint handles the signalr negotation"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " # As we do not differentiate from clients at this time, we pass the Functions runtime"
            },
            "7": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " # provided connection straight to the client"
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " def main(req: func.HttpRequest, connectionInfoJson: str) -> func.HttpResponse:"
            },
            "11": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return func.HttpResponse("
            },
            "12": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        connectionInfoJson,"
            },
            "13": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        status_code=200,"
            },
            "14": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        headers={\"Content-type\": \"application/json\"},"
            },
            "15": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    )"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+    # NOTE: this is a sub-method because the call_if* do not support callbacks with"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    # additional arguments at this time.  Once call_if* supports additional arguments,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    # this should be made a generic function"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    def post(req: func.HttpRequest) -> func.HttpResponse:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+        return func.HttpResponse("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+            connectionInfoJson,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+            status_code=200,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+            headers={\"Content-type\": \"application/json\"},"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        )"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    methods = {\"POST\": post}"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    method = methods[req.method]"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    result = call_if_user(req, method)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    return result"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import azure.functions as func",
            "",
            "# This endpoint handles the signalr negotation",
            "# As we do not differentiate from clients at this time, we pass the Functions runtime",
            "# provided connection straight to the client",
            "#",
            "# For more info:",
            "# https://docs.microsoft.com/en-us/azure/azure-signalr/signalr-concept-internals",
            "",
            "",
            "def main(req: func.HttpRequest, connectionInfoJson: str) -> func.HttpResponse:",
            "    return func.HttpResponse(",
            "        connectionInfoJson,",
            "        status_code=200,",
            "        headers={\"Content-type\": \"application/json\"},",
            "    )"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import azure.functions as func",
            "",
            "from ..onefuzzlib.endpoint_authorization import call_if_user",
            "",
            "# This endpoint handles the signalr negotation",
            "# As we do not differentiate from clients at this time, we pass the Functions runtime",
            "# provided connection straight to the client",
            "#",
            "# For more info:",
            "# https://docs.microsoft.com/en-us/azure/azure-signalr/signalr-concept-internals",
            "",
            "",
            "def main(req: func.HttpRequest, connectionInfoJson: str) -> func.HttpResponse:",
            "    # NOTE: this is a sub-method because the call_if* do not support callbacks with",
            "    # additional arguments at this time.  Once call_if* supports additional arguments,",
            "    # this should be made a generic function",
            "    def post(req: func.HttpRequest) -> func.HttpResponse:",
            "        return func.HttpResponse(",
            "            connectionInfoJson,",
            "            status_code=200,",
            "            headers={\"Content-type\": \"application/json\"},",
            "        )",
            "",
            "    methods = {\"POST\": post}",
            "    method = methods[req.method]",
            "",
            "    result = call_if_user(req, method)",
            "",
            "    return result"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "17": [
                "main"
            ],
            "18": [
                "main"
            ],
            "19": [
                "main"
            ],
            "20": [
                "main"
            ],
            "21": [
                "main"
            ]
        },
        "addLocation": []
    },
    "src/api-service/__app__/onefuzzlib/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     def fetch(cls) -> \"InstanceConfig\":"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         entry = cls.get(get_instance_name())"
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         if entry is None:"
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            entry = cls()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+            entry = cls(allowed_aad_tenants=[])"
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             entry.save()"
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         return entry"
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "from typing import Optional, Tuple",
            "",
            "from onefuzztypes.events import EventInstanceConfigUpdated",
            "from onefuzztypes.models import InstanceConfig as BASE_CONFIG",
            "from pydantic import Field",
            "",
            "from .azure.creds import get_instance_name",
            "from .events import send_event",
            "from .orm import ORMMixin",
            "",
            "",
            "class InstanceConfig(BASE_CONFIG, ORMMixin):",
            "    instance_name: str = Field(default_factory=get_instance_name)",
            "",
            "    @classmethod",
            "    def key_fields(cls) -> Tuple[str, Optional[str]]:",
            "        return (\"instance_name\", None)",
            "",
            "    @classmethod",
            "    def fetch(cls) -> \"InstanceConfig\":",
            "        entry = cls.get(get_instance_name())",
            "        if entry is None:",
            "            entry = cls()",
            "            entry.save()",
            "        return entry",
            "",
            "    def save(self, new: bool = False, require_etag: bool = False) -> None:",
            "        super().save(new=new, require_etag=require_etag)",
            "        send_event(EventInstanceConfigUpdated(config=self))"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "from typing import Optional, Tuple",
            "",
            "from onefuzztypes.events import EventInstanceConfigUpdated",
            "from onefuzztypes.models import InstanceConfig as BASE_CONFIG",
            "from pydantic import Field",
            "",
            "from .azure.creds import get_instance_name",
            "from .events import send_event",
            "from .orm import ORMMixin",
            "",
            "",
            "class InstanceConfig(BASE_CONFIG, ORMMixin):",
            "    instance_name: str = Field(default_factory=get_instance_name)",
            "",
            "    @classmethod",
            "    def key_fields(cls) -> Tuple[str, Optional[str]]:",
            "        return (\"instance_name\", None)",
            "",
            "    @classmethod",
            "    def fetch(cls) -> \"InstanceConfig\":",
            "        entry = cls.get(get_instance_name())",
            "        if entry is None:",
            "            entry = cls(allowed_aad_tenants=[])",
            "            entry.save()",
            "        return entry",
            "",
            "    def save(self, new: bool = False, require_etag: bool = False) -> None:",
            "        super().save(new=new, require_etag=require_etag)",
            "        send_event(EventInstanceConfigUpdated(config=self))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [
                "InstanceConfig",
                "fetch"
            ]
        },
        "addLocation": []
    },
    "src/api-service/__app__/onefuzzlib/user_credentials.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # Copyright (c) Microsoft Corporation."
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " # Licensed under the MIT License."
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Optional"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+import logging"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from typing import List, Optional"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from uuid import UUID"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import azure.functions as func"
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import jwt"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from memoization import cached"
            },
            "11": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from onefuzztypes.enums import ErrorCode"
            },
            "12": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from onefuzztypes.models import Error, Result, UserInfo"
            },
            "13": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from .config import InstanceConfig"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " def get_bearer_token(request: func.HttpRequest) -> Optional[str]:"
            },
            "18": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     auth: str = request.headers.get(\"Authorization\", None)"
            },
            "19": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     return str(token_header)"
            },
            "20": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+@cached(ttl=60)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+def get_allowed_tenants() -> List[str]:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    config = InstanceConfig.fetch()"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    entries = [f\"https://sts.windows.net/{x}/\" for x in config.allowed_aad_tenants]"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    return entries"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " def parse_jwt_token(request: func.HttpRequest) -> Result[UserInfo]:"
            },
            "30": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     \"\"\"Obtains the Access Token from the Authorization Header\"\"\""
            },
            "31": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     token_str = get_auth_token(request)"
            },
            "32": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             errors=[\"unable to find authorization token\"],"
            },
            "33": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         )"
            },
            "34": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # This token has already been verified by the azure authentication layer"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    # The JWT token has already been verified by the azure authentication layer,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    # but we need to verify the tenant is as we expect."
            },
            "38": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     token = jwt.decode(token_str, options={\"verify_signature\": False})"
            },
            "39": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    if \"iss\" not in token:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        return Error("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            code=ErrorCode.INVALID_REQUEST, errors=[\"missing issuer from token\"]"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        )"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    tenants = get_allowed_tenants()"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    if token[\"iss\"] not in tenants:"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        logging.error(\"issuer not from allowed tenant: %s - %s\", token[\"iss\"], tenants)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        return Error(code=ErrorCode.INVALID_REQUEST, errors=[\"unauthorized AAD issuer\"])"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     application_id = UUID(token[\"appid\"]) if \"appid\" in token else None"
            },
            "51": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     object_id = UUID(token[\"oid\"]) if \"oid\" in token else None"
            },
            "52": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     upn = token.get(\"upn\")"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "from typing import Optional",
            "from uuid import UUID",
            "",
            "import azure.functions as func",
            "import jwt",
            "from onefuzztypes.enums import ErrorCode",
            "from onefuzztypes.models import Error, Result, UserInfo",
            "",
            "",
            "def get_bearer_token(request: func.HttpRequest) -> Optional[str]:",
            "    auth: str = request.headers.get(\"Authorization\", None)",
            "    if not auth:",
            "        return None",
            "",
            "    parts = auth.split()",
            "",
            "    if len(parts) != 2:",
            "        return None",
            "",
            "    if parts[0].lower() != \"bearer\":",
            "        return None",
            "",
            "    return parts[1]",
            "",
            "",
            "def get_auth_token(request: func.HttpRequest) -> Optional[str]:",
            "    token = get_bearer_token(request)",
            "    if token is not None:",
            "        return token",
            "",
            "    token_header = request.headers.get(\"x-ms-token-aad-id-token\", None)",
            "    if token_header is None:",
            "        return None",
            "    return str(token_header)",
            "",
            "",
            "def parse_jwt_token(request: func.HttpRequest) -> Result[UserInfo]:",
            "    \"\"\"Obtains the Access Token from the Authorization Header\"\"\"",
            "    token_str = get_auth_token(request)",
            "    if token_str is None:",
            "        return Error(",
            "            code=ErrorCode.INVALID_REQUEST,",
            "            errors=[\"unable to find authorization token\"],",
            "        )",
            "",
            "    # This token has already been verified by the azure authentication layer",
            "    token = jwt.decode(token_str, options={\"verify_signature\": False})",
            "",
            "    application_id = UUID(token[\"appid\"]) if \"appid\" in token else None",
            "    object_id = UUID(token[\"oid\"]) if \"oid\" in token else None",
            "    upn = token.get(\"upn\")",
            "    return UserInfo(application_id=application_id, object_id=object_id, upn=upn)"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import logging",
            "from typing import List, Optional",
            "from uuid import UUID",
            "",
            "import azure.functions as func",
            "import jwt",
            "from memoization import cached",
            "from onefuzztypes.enums import ErrorCode",
            "from onefuzztypes.models import Error, Result, UserInfo",
            "",
            "from .config import InstanceConfig",
            "",
            "",
            "def get_bearer_token(request: func.HttpRequest) -> Optional[str]:",
            "    auth: str = request.headers.get(\"Authorization\", None)",
            "    if not auth:",
            "        return None",
            "",
            "    parts = auth.split()",
            "",
            "    if len(parts) != 2:",
            "        return None",
            "",
            "    if parts[0].lower() != \"bearer\":",
            "        return None",
            "",
            "    return parts[1]",
            "",
            "",
            "def get_auth_token(request: func.HttpRequest) -> Optional[str]:",
            "    token = get_bearer_token(request)",
            "    if token is not None:",
            "        return token",
            "",
            "    token_header = request.headers.get(\"x-ms-token-aad-id-token\", None)",
            "    if token_header is None:",
            "        return None",
            "    return str(token_header)",
            "",
            "",
            "@cached(ttl=60)",
            "def get_allowed_tenants() -> List[str]:",
            "    config = InstanceConfig.fetch()",
            "    entries = [f\"https://sts.windows.net/{x}/\" for x in config.allowed_aad_tenants]",
            "    return entries",
            "",
            "",
            "def parse_jwt_token(request: func.HttpRequest) -> Result[UserInfo]:",
            "    \"\"\"Obtains the Access Token from the Authorization Header\"\"\"",
            "    token_str = get_auth_token(request)",
            "    if token_str is None:",
            "        return Error(",
            "            code=ErrorCode.INVALID_REQUEST,",
            "            errors=[\"unable to find authorization token\"],",
            "        )",
            "",
            "    # The JWT token has already been verified by the azure authentication layer,",
            "    # but we need to verify the tenant is as we expect.",
            "    token = jwt.decode(token_str, options={\"verify_signature\": False})",
            "",
            "    if \"iss\" not in token:",
            "        return Error(",
            "            code=ErrorCode.INVALID_REQUEST, errors=[\"missing issuer from token\"]",
            "        )",
            "",
            "    tenants = get_allowed_tenants()",
            "    if token[\"iss\"] not in tenants:",
            "        logging.error(\"issuer not from allowed tenant: %s - %s\", token[\"iss\"], tenants)",
            "        return Error(code=ErrorCode.INVALID_REQUEST, errors=[\"unauthorized AAD issuer\"])",
            "",
            "    application_id = UUID(token[\"appid\"]) if \"appid\" in token else None",
            "    object_id = UUID(token[\"oid\"]) if \"oid\" in token else None",
            "    upn = token.get(\"upn\")",
            "    return UserInfo(application_id=application_id, object_id=object_id, upn=upn)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "51": [
                "parse_jwt_token"
            ]
        },
        "addLocation": []
    },
    "src/api-service/tests/test_auth_check.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import unittest"
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from uuid import uuid4"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from uuid import UUID, uuid4"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from onefuzztypes.models import UserInfo"
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         user2 = uuid4()"
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         # no admins set"
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertTrue(can_modify_config_impl(InstanceConfig(), UserInfo()))"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        self.assertTrue("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            can_modify_config_impl("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)]), UserInfo()"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+            )"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        )"
            },
            "17": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         # with oid, but no admin"
            },
            "19": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         self.assertTrue("
            },
            "20": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            can_modify_config_impl(InstanceConfig(), UserInfo(object_id=user1))"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+            can_modify_config_impl("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)]),"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+                UserInfo(object_id=user1),"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            )"
            },
            "25": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         )"
            },
            "26": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         # is admin"
            },
            "28": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         self.assertTrue("
            },
            "29": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "             can_modify_config_impl("
            },
            "30": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                InstanceConfig(admins=[user1]), UserInfo(object_id=user1)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                UserInfo(object_id=user1),"
            },
            "33": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             )"
            },
            "34": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         )"
            },
            "35": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         # no user oid set"
            },
            "37": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         self.assertFalse("
            },
            "38": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            can_modify_config_impl(InstanceConfig(admins=[user1]), UserInfo())"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            can_modify_config_impl("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                UserInfo(),"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            )"
            },
            "43": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         )"
            },
            "44": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         # not an admin"
            },
            "46": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         self.assertFalse("
            },
            "47": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "             can_modify_config_impl("
            },
            "48": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                InstanceConfig(admins=[user1]), UserInfo(object_id=user2)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+                UserInfo(object_id=user2),"
            },
            "51": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "             )"
            },
            "52": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         )"
            },
            "53": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         # by default, any can modify"
            },
            "55": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         self.assertIsNone("
            },
            "56": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "             check_can_manage_pools_impl("
            },
            "57": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                InstanceConfig(allow_pool_management=True), UserInfo()"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                InstanceConfig("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                    allowed_aad_tenants=[UUID(int=0)], allow_pool_management=True"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                ),"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                UserInfo(),"
            },
            "62": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "             )"
            },
            "63": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         )"
            },
            "64": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         # with oid, but no admin"
            },
            "66": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         self.assertIsNone("
            },
            "67": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             check_can_manage_pools_impl("
            },
            "68": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                InstanceConfig(allow_pool_management=True), UserInfo(object_id=user1)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+                InstanceConfig("
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+                    allowed_aad_tenants=[UUID(int=0)], allow_pool_management=True"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+                ),"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+                UserInfo(object_id=user1),"
            },
            "73": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             )"
            },
            "74": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         )"
            },
            "75": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "76": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         # is admin"
            },
            "77": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         self.assertIsNone("
            },
            "78": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "             check_can_manage_pools_impl("
            },
            "79": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                InstanceConfig(allow_pool_management=False, admins=[user1]),"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                InstanceConfig("
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                    allowed_aad_tenants=[UUID(int=0)],"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                    allow_pool_management=False,"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                    admins=[user1],"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                ),"
            },
            "85": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "                 UserInfo(object_id=user1),"
            },
            "86": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "             )"
            },
            "87": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         )"
            },
            "88": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "89": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         # no user oid set"
            },
            "90": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         self.assertIsNotNone("
            },
            "91": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "             check_can_manage_pools_impl("
            },
            "92": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                InstanceConfig(allow_pool_management=False, admins=[user1]), UserInfo()"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+                InstanceConfig("
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+                    allowed_aad_tenants=[UUID(int=0)],"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+                    allow_pool_management=False,"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+                    admins=[user1],"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+                ),"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+                UserInfo(),"
            },
            "99": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "             )"
            },
            "100": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         )"
            },
            "101": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            },
            "102": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         # not an admin"
            },
            "103": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         self.assertIsNotNone("
            },
            "104": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "             check_can_manage_pools_impl("
            },
            "105": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                InstanceConfig(allow_pool_management=False, admins=[user1]),"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+                InstanceConfig("
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+                    allowed_aad_tenants=[UUID(int=0)],"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                    allow_pool_management=False,"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                    admins=[user1],"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+                ),"
            },
            "111": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "                 UserInfo(object_id=user2),"
            },
            "112": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "             )"
            },
            "113": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         )"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import os",
            "import unittest",
            "from uuid import uuid4",
            "",
            "from onefuzztypes.models import UserInfo",
            "",
            "from __app__.onefuzzlib.config import InstanceConfig",
            "from __app__.onefuzzlib.endpoint_authorization import (",
            "    can_modify_config_impl,",
            "    check_can_manage_pools_impl,",
            ")",
            "",
            "if \"ONEFUZZ_INSTANCE_NAME\" not in os.environ:",
            "    os.environ[\"ONEFUZZ_INSTANCE_NAME\"] = \"test\"",
            "",
            "",
            "class TestAdmin(unittest.TestCase):",
            "    def test_modify_config(self) -> None:",
            "        user1 = uuid4()",
            "        user2 = uuid4()",
            "",
            "        # no admins set",
            "        self.assertTrue(can_modify_config_impl(InstanceConfig(), UserInfo()))",
            "",
            "        # with oid, but no admin",
            "        self.assertTrue(",
            "            can_modify_config_impl(InstanceConfig(), UserInfo(object_id=user1))",
            "        )",
            "",
            "        # is admin",
            "        self.assertTrue(",
            "            can_modify_config_impl(",
            "                InstanceConfig(admins=[user1]), UserInfo(object_id=user1)",
            "            )",
            "        )",
            "",
            "        # no user oid set",
            "        self.assertFalse(",
            "            can_modify_config_impl(InstanceConfig(admins=[user1]), UserInfo())",
            "        )",
            "",
            "        # not an admin",
            "        self.assertFalse(",
            "            can_modify_config_impl(",
            "                InstanceConfig(admins=[user1]), UserInfo(object_id=user2)",
            "            )",
            "        )",
            "",
            "    def test_manage_pools(self) -> None:",
            "        user1 = uuid4()",
            "        user2 = uuid4()",
            "",
            "        # by default, any can modify",
            "        self.assertIsNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(allow_pool_management=True), UserInfo()",
            "            )",
            "        )",
            "",
            "        # with oid, but no admin",
            "        self.assertIsNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(allow_pool_management=True), UserInfo(object_id=user1)",
            "            )",
            "        )",
            "",
            "        # is admin",
            "        self.assertIsNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(allow_pool_management=False, admins=[user1]),",
            "                UserInfo(object_id=user1),",
            "            )",
            "        )",
            "",
            "        # no user oid set",
            "        self.assertIsNotNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(allow_pool_management=False, admins=[user1]), UserInfo()",
            "            )",
            "        )",
            "",
            "        # not an admin",
            "        self.assertIsNotNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(allow_pool_management=False, admins=[user1]),",
            "                UserInfo(object_id=user2),",
            "            )",
            "        )",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    unittest.main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import os",
            "import unittest",
            "from uuid import UUID, uuid4",
            "",
            "from onefuzztypes.models import UserInfo",
            "",
            "from __app__.onefuzzlib.config import InstanceConfig",
            "from __app__.onefuzzlib.endpoint_authorization import (",
            "    can_modify_config_impl,",
            "    check_can_manage_pools_impl,",
            ")",
            "",
            "if \"ONEFUZZ_INSTANCE_NAME\" not in os.environ:",
            "    os.environ[\"ONEFUZZ_INSTANCE_NAME\"] = \"test\"",
            "",
            "",
            "class TestAdmin(unittest.TestCase):",
            "    def test_modify_config(self) -> None:",
            "        user1 = uuid4()",
            "        user2 = uuid4()",
            "",
            "        # no admins set",
            "        self.assertTrue(",
            "            can_modify_config_impl(",
            "                InstanceConfig(allowed_aad_tenants=[UUID(int=0)]), UserInfo()",
            "            )",
            "        )",
            "",
            "        # with oid, but no admin",
            "        self.assertTrue(",
            "            can_modify_config_impl(",
            "                InstanceConfig(allowed_aad_tenants=[UUID(int=0)]),",
            "                UserInfo(object_id=user1),",
            "            )",
            "        )",
            "",
            "        # is admin",
            "        self.assertTrue(",
            "            can_modify_config_impl(",
            "                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),",
            "                UserInfo(object_id=user1),",
            "            )",
            "        )",
            "",
            "        # no user oid set",
            "        self.assertFalse(",
            "            can_modify_config_impl(",
            "                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),",
            "                UserInfo(),",
            "            )",
            "        )",
            "",
            "        # not an admin",
            "        self.assertFalse(",
            "            can_modify_config_impl(",
            "                InstanceConfig(allowed_aad_tenants=[UUID(int=0)], admins=[user1]),",
            "                UserInfo(object_id=user2),",
            "            )",
            "        )",
            "",
            "    def test_manage_pools(self) -> None:",
            "        user1 = uuid4()",
            "        user2 = uuid4()",
            "",
            "        # by default, any can modify",
            "        self.assertIsNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(",
            "                    allowed_aad_tenants=[UUID(int=0)], allow_pool_management=True",
            "                ),",
            "                UserInfo(),",
            "            )",
            "        )",
            "",
            "        # with oid, but no admin",
            "        self.assertIsNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(",
            "                    allowed_aad_tenants=[UUID(int=0)], allow_pool_management=True",
            "                ),",
            "                UserInfo(object_id=user1),",
            "            )",
            "        )",
            "",
            "        # is admin",
            "        self.assertIsNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(",
            "                    allowed_aad_tenants=[UUID(int=0)],",
            "                    allow_pool_management=False,",
            "                    admins=[user1],",
            "                ),",
            "                UserInfo(object_id=user1),",
            "            )",
            "        )",
            "",
            "        # no user oid set",
            "        self.assertIsNotNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(",
            "                    allowed_aad_tenants=[UUID(int=0)],",
            "                    allow_pool_management=False,",
            "                    admins=[user1],",
            "                ),",
            "                UserInfo(),",
            "            )",
            "        )",
            "",
            "        # not an admin",
            "        self.assertIsNotNone(",
            "            check_can_manage_pools_impl(",
            "                InstanceConfig(",
            "                    allowed_aad_tenants=[UUID(int=0)],",
            "                    allow_pool_management=False,",
            "                    admins=[user1],",
            "                ),",
            "                UserInfo(object_id=user2),",
            "            )",
            "        )",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    unittest.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": [],
            "28": [
                "TestAdmin",
                "test_modify_config"
            ],
            "32": [
                "TestAdmin",
                "test_modify_config"
            ],
            "38": [
                "TestAdmin",
                "test_modify_config"
            ],
            "44": [
                "TestAdmin",
                "test_modify_config"
            ],
            "50": [
                "TestAdmin",
                "test_modify_config"
            ],
            "61": [
                "TestAdmin",
                "test_manage_pools"
            ],
            "68": [
                "TestAdmin",
                "test_manage_pools"
            ],
            "75": [
                "TestAdmin",
                "test_manage_pools"
            ],
            "83": [
                "TestAdmin",
                "test_manage_pools"
            ],
            "90": [
                "TestAdmin",
                "test_manage_pools"
            ]
        },
        "addLocation": []
    },
    "src/deployment/deploy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     set_app_audience,"
            },
            "1": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     update_pool_registration,"
            },
            "2": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from set_admins import update_admins"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+from set_admins import update_admins, update_allowed_aad_tenants"
            },
            "5": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " # Found by manually assigning the User.Read permission to application"
            },
            "7": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " # registration in the admin portal. The values are in the manifest under"
            },
            "8": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         multi_tenant_domain: str,"
            },
            "9": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         upgrade: bool,"
            },
            "10": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         subscription_id: Optional[str],"
            },
            "11": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        admins: List[UUID]"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        admins: List[UUID],"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        allowed_aad_tenants: List[UUID],"
            },
            "14": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "     ):"
            },
            "15": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         self.subscription_id = subscription_id"
            },
            "16": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         self.resource_group = resource_group"
            },
            "17": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         self.export_appinsights = export_appinsights"
            },
            "18": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         self.log_service_principal = log_service_principal"
            },
            "19": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         self.admins = admins"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        self.allowed_aad_tenants = allowed_aad_tenants"
            },
            "21": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 166,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         machine = platform.machine()"
            },
            "23": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         system = platform.system()"
            },
            "24": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": 562,
                "PatchRowcode": "         table_service = TableService(account_name=name, account_key=key)"
            },
            "25": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": 563,
                "PatchRowcode": "         migrate(table_service, self.migrations)"
            },
            "26": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": 564,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def set_admins(self) -> None:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 565,
                "PatchRowcode": "+    def set_instance_config(self) -> None:"
            },
            "29": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "         name = self.results[\"deploy\"][\"func-name\"][\"value\"]"
            },
            "30": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 567,
                "PatchRowcode": "         key = self.results[\"deploy\"][\"func-key\"][\"value\"]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+        tenant = UUID(self.results[\"deploy\"][\"tenant_id\"][\"value\"])"
            },
            "32": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 569,
                "PatchRowcode": "         table_service = TableService(account_name=name, account_key=key)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 571,
                "PatchRowcode": "         if self.admins:"
            },
            "35": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": 572,
                "PatchRowcode": "             update_admins(table_service, self.application_name, self.admins)"
            },
            "36": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": 573,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 574,
                "PatchRowcode": "+        tenants = self.allowed_aad_tenants"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 575,
                "PatchRowcode": "+        if tenant not in tenants:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 576,
                "PatchRowcode": "+            tenants.append(tenant)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 577,
                "PatchRowcode": "+        update_allowed_aad_tenants(table_service, self.application_name, tenants)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 578,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": 570,
                "afterPatchRowNumber": 579,
                "PatchRowcode": "     def create_queues(self) -> None:"
            },
            "43": {
                "beforePatchRowNumber": 571,
                "afterPatchRowNumber": 580,
                "PatchRowcode": "         logger.info(\"creating eventgrid destination queue\")"
            },
            "44": {
                "beforePatchRowNumber": 572,
                "afterPatchRowNumber": 581,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 926,
                "afterPatchRowNumber": 935,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 927,
                "afterPatchRowNumber": 936,
                "PatchRowcode": "     full_deployment_states = rbac_only_states + ["
            },
            "47": {
                "beforePatchRowNumber": 928,
                "afterPatchRowNumber": 937,
                "PatchRowcode": "         (\"apply_migrations\", Client.apply_migrations),"
            },
            "48": {
                "beforePatchRowNumber": 929,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        (\"set_admins\", Client.set_admins),"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 938,
                "PatchRowcode": "+        (\"set_instance_config\", Client.set_instance_config),"
            },
            "50": {
                "beforePatchRowNumber": 930,
                "afterPatchRowNumber": 939,
                "PatchRowcode": "         (\"queues\", Client.create_queues),"
            },
            "51": {
                "beforePatchRowNumber": 931,
                "afterPatchRowNumber": 940,
                "PatchRowcode": "         (\"eventgrid\", Client.create_eventgrid),"
            },
            "52": {
                "beforePatchRowNumber": 932,
                "afterPatchRowNumber": 941,
                "PatchRowcode": "         (\"tools\", Client.upload_tools),"
            },
            "53": {
                "beforePatchRowNumber": 1038,
                "afterPatchRowNumber": 1047,
                "PatchRowcode": "         nargs=\"*\","
            },
            "54": {
                "beforePatchRowNumber": 1039,
                "afterPatchRowNumber": 1048,
                "PatchRowcode": "         help=\"set the list of administrators (by OID in AAD)\","
            },
            "55": {
                "beforePatchRowNumber": 1040,
                "afterPatchRowNumber": 1049,
                "PatchRowcode": "     )"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1050,
                "PatchRowcode": "+    parser.add_argument("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1051,
                "PatchRowcode": "+        \"--allowed_aad_tenants\","
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1052,
                "PatchRowcode": "+        type=UUID,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1053,
                "PatchRowcode": "+        nargs=\"*\","
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1054,
                "PatchRowcode": "+        help=\"Set additional AAD tenants beyond the tenant the app is deployed in\","
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1055,
                "PatchRowcode": "+    )"
            },
            "62": {
                "beforePatchRowNumber": 1041,
                "afterPatchRowNumber": 1056,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 1042,
                "afterPatchRowNumber": 1057,
                "PatchRowcode": "     args = parser.parse_args()"
            },
            "64": {
                "beforePatchRowNumber": 1043,
                "afterPatchRowNumber": 1058,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 1066,
                "afterPatchRowNumber": 1081,
                "PatchRowcode": "         upgrade=args.upgrade,"
            },
            "66": {
                "beforePatchRowNumber": 1067,
                "afterPatchRowNumber": 1082,
                "PatchRowcode": "         subscription_id=args.subscription_id,"
            },
            "67": {
                "beforePatchRowNumber": 1068,
                "afterPatchRowNumber": 1083,
                "PatchRowcode": "         admins=args.set_admins,"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1084,
                "PatchRowcode": "+        allowed_aad_tenants=args.allowed_aad_tenants or [],"
            },
            "69": {
                "beforePatchRowNumber": 1069,
                "afterPatchRowNumber": 1085,
                "PatchRowcode": "     )"
            },
            "70": {
                "beforePatchRowNumber": 1070,
                "afterPatchRowNumber": 1086,
                "PatchRowcode": "     if args.verbose:"
            },
            "71": {
                "beforePatchRowNumber": 1071,
                "afterPatchRowNumber": 1087,
                "PatchRowcode": "         level = logging.DEBUG"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import argparse",
            "import json",
            "import logging",
            "import os",
            "import platform",
            "import shutil",
            "import subprocess",
            "import sys",
            "import tempfile",
            "import time",
            "import uuid",
            "import zipfile",
            "from datetime import datetime, timedelta",
            "from typing import Dict, List, Optional, Tuple, Union, cast",
            "from uuid import UUID",
            "",
            "from azure.common.client_factory import get_client_from_cli_profile",
            "from azure.common.credentials import get_cli_profile",
            "from azure.core.exceptions import ResourceExistsError",
            "from azure.cosmosdb.table.tableservice import TableService",
            "from azure.graphrbac import GraphRbacManagementClient",
            "from azure.graphrbac.models import (",
            "    Application,",
            "    ApplicationCreateParameters,",
            "    ApplicationUpdateParameters,",
            "    AppRole,",
            "    GraphErrorException,",
            "    OptionalClaims,",
            "    RequiredResourceAccess,",
            "    ResourceAccess,",
            "    ServicePrincipalCreateParameters,",
            ")",
            "from azure.mgmt.applicationinsights import ApplicationInsightsManagementClient",
            "from azure.mgmt.applicationinsights.models import (",
            "    ApplicationInsightsComponentExportRequest,",
            ")",
            "from azure.mgmt.eventgrid import EventGridManagementClient",
            "from azure.mgmt.eventgrid.models import (",
            "    EventSubscription,",
            "    EventSubscriptionFilter,",
            "    RetryPolicy,",
            "    StorageQueueEventSubscriptionDestination,",
            ")",
            "from azure.mgmt.resource import ResourceManagementClient, SubscriptionClient",
            "from azure.mgmt.resource.resources.models import (",
            "    Deployment,",
            "    DeploymentMode,",
            "    DeploymentProperties,",
            ")",
            "from azure.mgmt.storage import StorageManagementClient",
            "from azure.storage.blob import (",
            "    BlobServiceClient,",
            "    ContainerSasPermissions,",
            "    generate_container_sas,",
            ")",
            "from azure.storage.queue import QueueServiceClient",
            "from msrest.serialization import TZ_UTC",
            "",
            "from data_migration import migrate",
            "from registration import (",
            "    OnefuzzAppRole,",
            "    add_application_password,",
            "    assign_app_role,",
            "    authorize_application,",
            "    get_graph_client,",
            "    register_application,",
            "    set_app_audience,",
            "    update_pool_registration,",
            ")",
            "from set_admins import update_admins",
            "",
            "# Found by manually assigning the User.Read permission to application",
            "# registration in the admin portal. The values are in the manifest under",
            "# the section \"requiredResourceAccess\"",
            "USER_READ_PERMISSION = \"e1fe6dd8-ba31-4d61-89e7-88639da4683d\"",
            "MICROSOFT_GRAPH_APP_ID = \"00000003-0000-0000-c000-000000000000\"",
            "",
            "ONEFUZZ_CLI_APP = \"72f1562a-8c0c-41ea-beb9-fa2b71c80134\"",
            "ONEFUZZ_CLI_AUTHORITY = (",
            "    \"https://login.microsoftonline.com/72f988bf-86f1-41af-91ab-2d7cd011db47\"",
            ")",
            "COMMON_AUTHORITY = \"https://login.microsoftonline.com/common\"",
            "TELEMETRY_NOTICE = (",
            "    \"Telemetry collection on stats and OneFuzz failures are sent to Microsoft. \"",
            "    \"To disable, delete the ONEFUZZ_TELEMETRY application setting in the \"",
            "    \"Azure Functions instance\"",
            ")",
            "AZCOPY_MISSING_ERROR = (",
            "    \"azcopy is not installed and unable to use the built-in version. \"",
            "    \"Installation instructions are available at https://aka.ms/azcopy\"",
            ")",
            "FUNC_TOOLS_ERROR = (",
            "    \"azure-functions-core-tools is not installed, \"",
            "    \"install v3 using instructions: \"",
            "    \"https://github.com/Azure/azure-functions-core-tools#installing\"",
            ")",
            "",
            "logger = logging.getLogger(\"deploy\")",
            "",
            "",
            "def gen_guid() -> str:",
            "    return str(uuid.uuid4())",
            "",
            "",
            "class Client:",
            "    def __init__(",
            "        self,",
            "        *,",
            "        resource_group: str,",
            "        location: str,",
            "        application_name: str,",
            "        owner: str,",
            "        client_id: Optional[str],",
            "        client_secret: Optional[str],",
            "        app_zip: str,",
            "        tools: str,",
            "        instance_specific: str,",
            "        third_party: str,",
            "        arm_template: str,",
            "        workbook_data: str,",
            "        create_registration: bool,",
            "        migrations: List[str],",
            "        export_appinsights: bool,",
            "        log_service_principal: bool,",
            "        multi_tenant_domain: str,",
            "        upgrade: bool,",
            "        subscription_id: Optional[str],",
            "        admins: List[UUID]",
            "    ):",
            "        self.subscription_id = subscription_id",
            "        self.resource_group = resource_group",
            "        self.arm_template = arm_template",
            "        self.location = location",
            "        self.application_name = application_name",
            "        self.owner = owner",
            "        self.app_zip = app_zip",
            "        self.tools = tools",
            "        self.instance_specific = instance_specific",
            "        self.third_party = third_party",
            "        self.create_registration = create_registration",
            "        self.multi_tenant_domain = multi_tenant_domain",
            "        self.upgrade = upgrade",
            "        self.results: Dict = {",
            "            \"client_id\": client_id,",
            "            \"client_secret\": client_secret,",
            "        }",
            "        if self.multi_tenant_domain:",
            "            authority = COMMON_AUTHORITY",
            "        else:",
            "            authority = ONEFUZZ_CLI_AUTHORITY",
            "        self.cli_config: Dict[str, Union[str, UUID]] = {",
            "            \"client_id\": ONEFUZZ_CLI_APP,",
            "            \"authority\": authority,",
            "        }",
            "        self.migrations = migrations",
            "        self.export_appinsights = export_appinsights",
            "        self.log_service_principal = log_service_principal",
            "        self.admins = admins",
            "",
            "        machine = platform.machine()",
            "        system = platform.system()",
            "",
            "        if system == \"Linux\" and machine == \"x86_64\":",
            "            self.azcopy = os.path.join(self.tools, \"linux\", \"azcopy\")",
            "            subprocess.check_output([\"chmod\", \"+x\", self.azcopy])",
            "        elif system == \"Windows\" and machine == \"AMD64\":",
            "            self.azcopy = os.path.join(self.tools, \"win64\", \"azcopy.exe\")",
            "        else:",
            "            azcopy = shutil.which(\"azcopy\")",
            "            if not azcopy:",
            "                raise Exception(AZCOPY_MISSING_ERROR)",
            "            else:",
            "                logger.warn(\"unable to use built-in azcopy, using system install\")",
            "                self.azcopy = azcopy",
            "",
            "        with open(workbook_data) as f:",
            "            self.workbook_data = json.load(f)",
            "",
            "    def get_subscription_id(self) -> str:",
            "        if self.subscription_id:",
            "            return self.subscription_id",
            "        profile = get_cli_profile()",
            "        self.subscription_id = cast(str, profile.get_subscription_id())",
            "        return self.subscription_id",
            "",
            "    def get_location_display_name(self) -> str:",
            "        location_client = get_client_from_cli_profile(",
            "            SubscriptionClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        locations = location_client.subscriptions.list_locations(",
            "            self.get_subscription_id()",
            "        )",
            "        for location in locations:",
            "            if location.name == self.location:",
            "                return cast(str, location.display_name)",
            "",
            "        raise Exception(\"unknown location: %s\", self.location)",
            "",
            "    def check_region(self) -> None:",
            "        # At the moment, this only checks are the specified providers available",
            "        # in the selected region",
            "",
            "        location = self.get_location_display_name()",
            "",
            "        with open(self.arm_template, \"r\") as handle:",
            "            arm = json.load(handle)",
            "",
            "        client = get_client_from_cli_profile(",
            "            ResourceManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        providers = {x.namespace: x for x in client.providers.list()}",
            "",
            "        unsupported = []",
            "",
            "        for resource in arm[\"resources\"]:",
            "            namespace, name = resource[\"type\"].split(\"/\", 1)",
            "",
            "            # resource types are in the form of a/b/c....",
            "            # only the top two are listed as resource types within providers",
            "            name = \"/\".join(name.split(\"/\")[:2])",
            "",
            "            if namespace not in providers:",
            "                unsupported.append(\"Unsupported provider: %s\" % namespace)",
            "                continue",
            "",
            "            provider = providers[namespace]",
            "            resource_types = {x.resource_type: x for x in provider.resource_types}",
            "            if name not in resource_types:",
            "                unsupported.append(",
            "                    \"Unsupported resource type: %s/%s\" % (namespace, name)",
            "                )",
            "                continue",
            "",
            "            resource_type = resource_types[name]",
            "            if (",
            "                location not in resource_type.locations",
            "                and len(resource_type.locations) > 0",
            "            ):",
            "                unsupported.append(",
            "                    \"%s/%s is unsupported in %s\" % (namespace, name, self.location)",
            "                )",
            "",
            "        if unsupported:",
            "            print(\"The following resources required by onefuzz are not supported:\")",
            "            print(\"\\n\".join([\"* \" + x for x in unsupported]))",
            "            sys.exit(1)",
            "",
            "    def create_password(self, object_id: UUID) -> Tuple[str, str]:",
            "        return add_application_password(object_id, self.get_subscription_id())",
            "",
            "    def setup_rbac(self) -> None:",
            "        \"\"\"",
            "        Setup the client application for the OneFuzz instance.",
            "        By default, Service Principals do not have access to create",
            "        client applications in AAD.",
            "        \"\"\"",
            "        if self.results[\"client_id\"] and self.results[\"client_secret\"]:",
            "            logger.info(\"using existing client application\")",
            "            return",
            "",
            "        client = get_client_from_cli_profile(",
            "            GraphRbacManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        logger.info(\"checking if RBAC already exists\")",
            "",
            "        try:",
            "            existing = list(",
            "                client.applications.list(",
            "                    filter=\"displayName eq '%s'\" % self.application_name",
            "                )",
            "            )",
            "        except GraphErrorException:",
            "            logger.error(\"unable to query RBAC. Provide client_id and client_secret\")",
            "            sys.exit(1)",
            "",
            "        app_roles = [",
            "            AppRole(",
            "                allowed_member_types=[\"Application\"],",
            "                display_name=OnefuzzAppRole.CliClient.value,",
            "                id=str(uuid.uuid4()),",
            "                is_enabled=True,",
            "                description=\"Allows access from the CLI.\",",
            "                value=OnefuzzAppRole.CliClient.value,",
            "            ),",
            "            AppRole(",
            "                allowed_member_types=[\"Application\"],",
            "                display_name=OnefuzzAppRole.ManagedNode.value,",
            "                id=str(uuid.uuid4()),",
            "                is_enabled=True,",
            "                description=\"Allow access from a lab machine.\",",
            "                value=OnefuzzAppRole.ManagedNode.value,",
            "            ),",
            "        ]",
            "",
            "        app: Optional[Application] = None",
            "",
            "        if not existing:",
            "            logger.info(\"creating Application registration\")",
            "",
            "            if self.multi_tenant_domain:",
            "                url = \"https://%s/%s\" % (",
            "                    self.multi_tenant_domain,",
            "                    self.application_name,",
            "                )",
            "            else:",
            "                url = \"https://%s.azurewebsites.net\" % self.application_name",
            "",
            "            params = ApplicationCreateParameters(",
            "                display_name=self.application_name,",
            "                identifier_uris=[url],",
            "                reply_urls=[url + \"/.auth/login/aad/callback\"],",
            "                optional_claims=OptionalClaims(id_token=[], access_token=[]),",
            "                required_resource_access=[",
            "                    RequiredResourceAccess(",
            "                        resource_access=[",
            "                            ResourceAccess(id=USER_READ_PERMISSION, type=\"Scope\")",
            "                        ],",
            "                        resource_app_id=MICROSOFT_GRAPH_APP_ID,",
            "                    )",
            "                ],",
            "                app_roles=app_roles,",
            "            )",
            "",
            "            app = client.applications.create(params)",
            "",
            "            logger.info(\"creating service principal\")",
            "            service_principal_params = ServicePrincipalCreateParameters(",
            "                account_enabled=True,",
            "                app_role_assignment_required=False,",
            "                service_principal_type=\"Application\",",
            "                app_id=app.app_id,",
            "            )",
            "",
            "            def try_sp_create() -> None:",
            "                error: Optional[Exception] = None",
            "                for _ in range(10):",
            "                    try:",
            "                        client.service_principals.create(service_principal_params)",
            "                        return",
            "                    except GraphErrorException as err:",
            "                        # work around timing issue when creating service principal",
            "                        # https://github.com/Azure/azure-cli/issues/14767",
            "                        if (",
            "                            \"service principal being created must in the local tenant\"",
            "                            not in str(err)",
            "                        ):",
            "                            raise err",
            "                    logger.warning(",
            "                        \"creating service principal failed with an error that occurs \"",
            "                        \"due to AAD race conditions\"",
            "                    )",
            "                    time.sleep(60)",
            "                if error is None:",
            "                    raise Exception(\"service principal creation failed\")",
            "                else:",
            "                    raise error",
            "",
            "            try_sp_create()",
            "",
            "        else:",
            "            app = existing[0]",
            "            existing_role_values = [app_role.value for app_role in app.app_roles]",
            "            has_missing_roles = any(",
            "                [role.value not in existing_role_values for role in app_roles]",
            "            )",
            "",
            "            if has_missing_roles:",
            "                # disabling the existing app role first to allow the update",
            "                # this is a requirement to update the application roles",
            "                for role in app.app_roles:",
            "                    role.is_enabled = False",
            "",
            "                client.applications.patch(",
            "                    app.object_id, ApplicationUpdateParameters(app_roles=app.app_roles)",
            "                )",
            "",
            "                # overriding the list of app roles",
            "                client.applications.patch(",
            "                    app.object_id, ApplicationUpdateParameters(app_roles=app_roles)",
            "                )",
            "",
            "        if self.multi_tenant_domain and app.sign_in_audience == \"AzureADMyOrg\":",
            "            url = \"https://%s/%s\" % (",
            "                self.multi_tenant_domain,",
            "                self.application_name,",
            "            )",
            "            client.applications.patch(",
            "                app.object_id, ApplicationUpdateParameters(identifier_uris=[url])",
            "            )",
            "            set_app_audience(app.object_id, \"AzureADMultipleOrgs\")",
            "        elif (",
            "            not self.multi_tenant_domain",
            "            and app.sign_in_audience == \"AzureADMultipleOrgs\"",
            "        ):",
            "            set_app_audience(app.object_id, \"AzureADMyOrg\")",
            "            url = \"https://%s.azurewebsites.net\" % self.application_name",
            "            client.applications.patch(",
            "                app.object_id, ApplicationUpdateParameters(identifier_uris=[url])",
            "            )",
            "        else:",
            "            logger.debug(\"No change to App Registration signInAudence setting\")",
            "",
            "            creds = list(client.applications.list_password_credentials(app.object_id))",
            "            client.applications.update_password_credentials(app.object_id, creds)",
            "",
            "        (password_id, password) = self.create_password(app.object_id)",
            "",
            "        cli_app = list(",
            "            client.applications.list(filter=\"appId eq '%s'\" % ONEFUZZ_CLI_APP)",
            "        )",
            "",
            "        if len(cli_app) == 0:",
            "            logger.info(",
            "                \"Could not find the default CLI application under the current \"",
            "                \"subscription, creating a new one\"",
            "            )",
            "            app_info = register_application(",
            "                \"onefuzz-cli\",",
            "                self.application_name,",
            "                OnefuzzAppRole.CliClient,",
            "                self.get_subscription_id(),",
            "            )",
            "            if self.multi_tenant_domain:",
            "                authority = COMMON_AUTHORITY",
            "            else:",
            "                authority = app_info.authority",
            "            self.cli_config = {",
            "                \"client_id\": app_info.client_id,",
            "                \"authority\": authority,",
            "            }",
            "",
            "        else:",
            "            onefuzz_cli_app = cli_app[0]",
            "            authorize_application(uuid.UUID(onefuzz_cli_app.app_id), app.app_id)",
            "            if self.multi_tenant_domain:",
            "                authority = COMMON_AUTHORITY",
            "            else:",
            "                onefuzz_client = get_graph_client(self.get_subscription_id())",
            "                authority = (",
            "                    \"https://login.microsoftonline.com/%s\"",
            "                    % onefuzz_client.config.tenant_id",
            "                )",
            "            self.cli_config = {",
            "                \"client_id\": onefuzz_cli_app.app_id,",
            "                \"authority\": authority,",
            "            }",
            "",
            "        self.results[\"client_id\"] = app.app_id",
            "        self.results[\"client_secret\"] = password",
            "",
            "        # Log `client_secret` for consumption by CI.",
            "        if self.log_service_principal:",
            "            logger.info(\"client_id: %s client_secret: %s\", app.app_id, password)",
            "        else:",
            "            logger.debug(\"client_id: %s client_secret: %s\", app.app_id, password)",
            "",
            "    def deploy_template(self) -> None:",
            "        logger.info(\"deploying arm template: %s\", self.arm_template)",
            "",
            "        with open(self.arm_template, \"r\") as template_handle:",
            "            template = json.load(template_handle)",
            "",
            "        client = get_client_from_cli_profile(",
            "            ResourceManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        client.resource_groups.create_or_update(",
            "            self.resource_group, {\"location\": self.location}",
            "        )",
            "",
            "        expiry = (datetime.now(TZ_UTC) + timedelta(days=365)).strftime(",
            "            \"%Y-%m-%dT%H:%M:%SZ\"",
            "        )",
            "",
            "        if self.multi_tenant_domain:",
            "            # clear the value in the Issuer Url field:",
            "            # https://docs.microsoft.com/en-us/sharepoint/dev/spfx/use-aadhttpclient-enterpriseapi-multitenant",
            "            app_func_audience = \"https://%s/%s\" % (",
            "                self.multi_tenant_domain,",
            "                self.application_name,",
            "            )",
            "            app_func_issuer = \"\"",
            "            multi_tenant_domain = {\"value\": self.multi_tenant_domain}",
            "        else:",
            "            app_func_audience = \"https://%s.azurewebsites.net\" % self.application_name",
            "            tenant_oid = str(self.cli_config[\"authority\"]).split(\"/\")[-1]",
            "            app_func_issuer = \"https://sts.windows.net/%s/\" % tenant_oid",
            "            multi_tenant_domain = {\"value\": \"\"}",
            "",
            "        params = {",
            "            \"app_func_audience\": {\"value\": app_func_audience},",
            "            \"name\": {\"value\": self.application_name},",
            "            \"owner\": {\"value\": self.owner},",
            "            \"clientId\": {\"value\": self.results[\"client_id\"]},",
            "            \"clientSecret\": {\"value\": self.results[\"client_secret\"]},",
            "            \"app_func_issuer\": {\"value\": app_func_issuer},",
            "            \"signedExpiry\": {\"value\": expiry},",
            "            \"multi_tenant_domain\": multi_tenant_domain,",
            "            \"workbookData\": {\"value\": self.workbook_data},",
            "        }",
            "        deployment = Deployment(",
            "            properties=DeploymentProperties(",
            "                mode=DeploymentMode.incremental, template=template, parameters=params",
            "            )",
            "        )",
            "        count = 0",
            "        tries = 10",
            "        error: Optional[Exception] = None",
            "        while count < tries:",
            "            count += 1",
            "",
            "            try:",
            "                result = client.deployments.begin_create_or_update(",
            "                    self.resource_group, gen_guid(), deployment",
            "                ).result()",
            "                if result.properties.provisioning_state != \"Succeeded\":",
            "                    logger.error(",
            "                        \"error deploying: %s\",",
            "                        json.dumps(result.as_dict(), indent=4, sort_keys=True),",
            "                    )",
            "                    sys.exit(1)",
            "                self.results[\"deploy\"] = result.properties.outputs",
            "                return",
            "            except Exception as err:",
            "                error = err",
            "                as_repr = repr(err)",
            "                # Modeled after Azure-CLI.  See:",
            "                # https://github.com/Azure/azure-cli/blob/",
            "                #   3a2f6009cff788fde3b0170823c9129f187b2812/src/azure-cli-core/",
            "                #   azure/cli/core/commands/arm.py#L1086",
            "                if (",
            "                    \"PrincipalNotFound\" in as_repr",
            "                    and \"does not exist in the directory\" in as_repr",
            "                ):",
            "                    logger.info(\"application principal not available in AAD yet\")",
            "        if error:",
            "            raise error",
            "        else:",
            "            raise Exception(\"unknown error deploying\")",
            "",
            "    def assign_scaleset_identity_role(self) -> None:",
            "        if self.upgrade:",
            "            logger.info(\"Upgrading: skipping assignment of the managed identity role\")",
            "            return",
            "        logger.info(\"assigning the user managed identity role\")",
            "        assign_app_role(",
            "            self.application_name,",
            "            self.results[\"deploy\"][\"scaleset-identity\"][\"value\"],",
            "            self.get_subscription_id(),",
            "            OnefuzzAppRole.ManagedNode,",
            "        )",
            "",
            "    def apply_migrations(self) -> None:",
            "        name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        table_service = TableService(account_name=name, account_key=key)",
            "        migrate(table_service, self.migrations)",
            "",
            "    def set_admins(self) -> None:",
            "        name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        table_service = TableService(account_name=name, account_key=key)",
            "        if self.admins:",
            "            update_admins(table_service, self.application_name, self.admins)",
            "",
            "    def create_queues(self) -> None:",
            "        logger.info(\"creating eventgrid destination queue\")",
            "",
            "        name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.queue.core.windows.net\" % name",
            "        client = QueueServiceClient(",
            "            account_url=account_url,",
            "            credential={\"account_name\": name, \"account_key\": key},",
            "        )",
            "        for queue in [",
            "            \"file-changes\",",
            "            \"task-heartbeat\",",
            "            \"node-heartbeat\",",
            "            \"proxy\",",
            "            \"update-queue\",",
            "            \"webhooks\",",
            "            \"signalr-events\",",
            "        ]:",
            "            try:",
            "                client.create_queue(queue)",
            "            except ResourceExistsError:",
            "                pass",
            "",
            "    def create_eventgrid(self) -> None:",
            "        logger.info(\"creating eventgrid subscription\")",
            "        src_resource_id = self.results[\"deploy\"][\"fuzz-storage\"][\"value\"]",
            "        dst_resource_id = self.results[\"deploy\"][\"func-storage\"][\"value\"]",
            "        client = get_client_from_cli_profile(",
            "            StorageManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        event_subscription_info = EventSubscription(",
            "            destination=StorageQueueEventSubscriptionDestination(",
            "                resource_id=dst_resource_id, queue_name=\"file-changes\"",
            "            ),",
            "            filter=EventSubscriptionFilter(",
            "                included_event_types=[",
            "                    \"Microsoft.Storage.BlobCreated\",",
            "                    \"Microsoft.Storage.BlobDeleted\",",
            "                ]",
            "            ),",
            "            retry_policy=RetryPolicy(",
            "                max_delivery_attempts=30,",
            "                event_time_to_live_in_minutes=1440,",
            "            ),",
            "        )",
            "",
            "        client = get_client_from_cli_profile(",
            "            EventGridManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        result = client.event_subscriptions.begin_create_or_update(",
            "            src_resource_id, \"onefuzz1\", event_subscription_info",
            "        ).result()",
            "        if result.provisioning_state != \"Succeeded\":",
            "            raise Exception(",
            "                \"eventgrid subscription failed: %s\"",
            "                % json.dumps(result.as_dict(), indent=4, sort_keys=True),",
            "            )",
            "",
            "    def add_instance_id(self) -> None:",
            "        logger.info(\"setting instance_id log export\")",
            "",
            "        container_name = \"base-config\"",
            "        blob_name = \"instance_id\"",
            "        account_name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        if container_name not in [x[\"name\"] for x in client.list_containers()]:",
            "            client.create_container(container_name)",
            "",
            "        blob_client = client.get_blob_client(container_name, blob_name)",
            "        if blob_client.exists():",
            "            logger.debug(\"instance_id already exists\")",
            "            instance_id = uuid.UUID(blob_client.download_blob().readall().decode())",
            "        else:",
            "            logger.debug(\"creating new instance_id\")",
            "            instance_id = uuid.uuid4()",
            "            blob_client.upload_blob(str(instance_id))",
            "",
            "        logger.info(\"instance_id: %s\", instance_id)",
            "",
            "    def add_log_export(self) -> None:",
            "        if not self.export_appinsights:",
            "            logger.info(\"not exporting appinsights\")",
            "            return",
            "",
            "        container_name = \"app-insights\"",
            "",
            "        logger.info(\"adding appinsight log export\")",
            "        account_name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        if container_name not in [x[\"name\"] for x in client.list_containers()]:",
            "            client.create_container(container_name)",
            "",
            "        expiry = datetime.utcnow() + timedelta(days=2 * 365)",
            "",
            "        # NOTE: as this is a long-lived SAS url, it should not be logged and only",
            "        # used in the the later-on export_configurations.create() call",
            "        sas = generate_container_sas(",
            "            account_name,",
            "            container_name,",
            "            account_key=key,",
            "            permission=ContainerSasPermissions(write=True),",
            "            expiry=expiry,",
            "        )",
            "        url = \"%s/%s?%s\" % (account_url, container_name, sas)",
            "",
            "        record_types = (",
            "            \"Requests, Event, Exceptions, Metrics, PageViews, \"",
            "            \"PageViewPerformance, Rdd, PerformanceCounters, Availability\"",
            "        )",
            "",
            "        req = ApplicationInsightsComponentExportRequest(",
            "            record_types=record_types,",
            "            destination_type=\"Blob\",",
            "            is_enabled=\"true\",",
            "            destination_address=url,",
            "        )",
            "",
            "        app_insight_client = get_client_from_cli_profile(",
            "            ApplicationInsightsManagementClient,",
            "            subscription_id=self.get_subscription_id(),",
            "        )",
            "",
            "        to_delete = []",
            "        for entry in app_insight_client.export_configurations.list(",
            "            self.resource_group, self.application_name",
            "        ):",
            "            if (",
            "                entry.storage_name == account_name",
            "                and entry.container_name == container_name",
            "            ):",
            "                to_delete.append(entry.export_id)",
            "",
            "        for export_id in to_delete:",
            "            logger.info(\"replacing existing export: %s\", export_id)",
            "            app_insight_client.export_configurations.delete(",
            "                self.resource_group, self.application_name, export_id",
            "            )",
            "",
            "        app_insight_client.export_configurations.create(",
            "            self.resource_group, self.application_name, req",
            "        )",
            "",
            "    def upload_tools(self) -> None:",
            "        logger.info(\"uploading tools from %s\", self.tools)",
            "        account_name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        if \"tools\" not in [x[\"name\"] for x in client.list_containers()]:",
            "            client.create_container(\"tools\")",
            "",
            "        expiry = datetime.utcnow() + timedelta(minutes=30)",
            "",
            "        sas = generate_container_sas(",
            "            account_name,",
            "            \"tools\",",
            "            account_key=key,",
            "            permission=ContainerSasPermissions(",
            "                read=True, write=True, delete=True, list=True",
            "            ),",
            "            expiry=expiry,",
            "        )",
            "        url = \"%s/%s?%s\" % (account_url, \"tools\", sas)",
            "",
            "        subprocess.check_output(",
            "            [",
            "                self.azcopy,",
            "                \"copy\",",
            "                os.path.join(self.tools, \"*\"),",
            "                url,",
            "                \"--overwrite=true\",",
            "                \"--recursive=true\",",
            "            ]",
            "        )",
            "",
            "        subprocess.check_output(",
            "            [self.azcopy, \"sync\", self.tools, url, \"--delete-destination\", \"true\"]",
            "        )",
            "",
            "    def upload_instance_setup(self) -> None:",
            "        logger.info(\"uploading instance-specific-setup from %s\", self.instance_specific)",
            "        account_name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        if \"instance-specific-setup\" not in [",
            "            x[\"name\"] for x in client.list_containers()",
            "        ]:",
            "            client.create_container(\"instance-specific-setup\")",
            "",
            "        expiry = datetime.utcnow() + timedelta(minutes=30)",
            "",
            "        sas = generate_container_sas(",
            "            account_name,",
            "            \"instance-specific-setup\",",
            "            account_key=key,",
            "            permission=ContainerSasPermissions(",
            "                read=True, write=True, delete=True, list=True",
            "            ),",
            "            expiry=expiry,",
            "        )",
            "        url = \"%s/%s?%s\" % (account_url, \"instance-specific-setup\", sas)",
            "",
            "        subprocess.check_output(",
            "            [",
            "                self.azcopy,",
            "                \"copy\",",
            "                os.path.join(self.instance_specific, \"*\"),",
            "                url,",
            "                \"--overwrite=true\",",
            "                \"--recursive=true\",",
            "            ]",
            "        )",
            "",
            "        subprocess.check_output(",
            "            [",
            "                self.azcopy,",
            "                \"sync\",",
            "                self.instance_specific,",
            "                url,",
            "                \"--delete-destination\",",
            "                \"true\",",
            "            ]",
            "        )",
            "",
            "    def upload_third_party(self) -> None:",
            "        logger.info(\"uploading third-party tools from %s\", self.third_party)",
            "        account_name = self.results[\"deploy\"][\"fuzz-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"fuzz-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        containers = [x[\"name\"] for x in client.list_containers()]",
            "",
            "        for name in os.listdir(self.third_party):",
            "            path = os.path.join(self.third_party, name)",
            "            if not os.path.isdir(path):",
            "                continue",
            "            if name not in containers:",
            "                client.create_container(name)",
            "",
            "            expiry = datetime.utcnow() + timedelta(minutes=30)",
            "            sas = generate_container_sas(",
            "                account_name,",
            "                name,",
            "                account_key=key,",
            "                permission=ContainerSasPermissions(",
            "                    read=True, write=True, delete=True, list=True",
            "                ),",
            "                expiry=expiry,",
            "            )",
            "            url = \"%s/%s?%s\" % (account_url, name, sas)",
            "",
            "            subprocess.check_output(",
            "                [",
            "                    self.azcopy,",
            "                    \"copy\",",
            "                    os.path.join(path, \"*\"),",
            "                    url,",
            "                    \"--overwrite=true\",",
            "                    \"--recursive=true\",",
            "                ]",
            "            )",
            "",
            "            subprocess.check_output(",
            "                [self.azcopy, \"sync\", path, url, \"--delete-destination\", \"true\"]",
            "            )",
            "",
            "    def deploy_app(self) -> None:",
            "        logger.info(\"deploying function app %s\", self.app_zip)",
            "        with tempfile.TemporaryDirectory() as tmpdirname:",
            "            with zipfile.ZipFile(self.app_zip, \"r\") as zip_ref:",
            "                func = shutil.which(\"func\")",
            "                assert func is not None",
            "",
            "                zip_ref.extractall(tmpdirname)",
            "                error: Optional[subprocess.CalledProcessError] = None",
            "                max_tries = 5",
            "                for i in range(max_tries):",
            "                    try:",
            "                        subprocess.check_output(",
            "                            [",
            "                                func,",
            "                                \"azure\",",
            "                                \"functionapp\",",
            "                                \"publish\",",
            "                                self.application_name,",
            "                                \"--python\",",
            "                                \"--no-build\",",
            "                            ],",
            "                            env=dict(os.environ, CLI_DEBUG=\"1\"),",
            "                            cwd=tmpdirname,",
            "                        )",
            "                        return",
            "                    except subprocess.CalledProcessError as err:",
            "                        error = err",
            "                        if i + 1 < max_tries:",
            "                            logger.debug(\"func failure error: %s\", err)",
            "                            logger.warning(",
            "                                \"function failed to deploy, waiting 60 \"",
            "                                \"seconds and trying again\"",
            "                            )",
            "                            time.sleep(60)",
            "                if error is not None:",
            "                    raise error",
            "",
            "    def update_registration(self) -> None:",
            "        if not self.create_registration:",
            "            return",
            "        update_pool_registration(self.application_name, self.get_subscription_id())",
            "",
            "    def done(self) -> None:",
            "        logger.info(TELEMETRY_NOTICE)",
            "        client_secret_arg = (",
            "            (\"--client_secret %s\" % self.cli_config[\"client_secret\"])",
            "            if \"client_secret\" in self.cli_config",
            "            else \"\"",
            "        )",
            "        multi_tenant_domain = \"\"",
            "        if self.multi_tenant_domain:",
            "            multi_tenant_domain = \"--tenant_domain %s\" % self.multi_tenant_domain",
            "        logger.info(",
            "            \"Update your CLI config via: onefuzz config --endpoint \"",
            "            \"https://%s.azurewebsites.net --authority %s --client_id %s %s %s\",",
            "            self.application_name,",
            "            self.cli_config[\"authority\"],",
            "            self.cli_config[\"client_id\"],",
            "            client_secret_arg,",
            "            multi_tenant_domain,",
            "        )",
            "",
            "",
            "def arg_dir(arg: str) -> str:",
            "    if not os.path.isdir(arg):",
            "        raise argparse.ArgumentTypeError(\"not a directory: %s\" % arg)",
            "    return arg",
            "",
            "",
            "def arg_file(arg: str) -> str:",
            "    if not os.path.isfile(arg):",
            "        raise argparse.ArgumentTypeError(\"not a file: %s\" % arg)",
            "    return arg",
            "",
            "",
            "def main() -> None:",
            "    rbac_only_states = [",
            "        (\"check_region\", Client.check_region),",
            "        (\"rbac\", Client.setup_rbac),",
            "        (\"arm\", Client.deploy_template),",
            "        (\"assign_scaleset_identity_role\", Client.assign_scaleset_identity_role),",
            "    ]",
            "",
            "    full_deployment_states = rbac_only_states + [",
            "        (\"apply_migrations\", Client.apply_migrations),",
            "        (\"set_admins\", Client.set_admins),",
            "        (\"queues\", Client.create_queues),",
            "        (\"eventgrid\", Client.create_eventgrid),",
            "        (\"tools\", Client.upload_tools),",
            "        (\"add_instance_id\", Client.add_instance_id),",
            "        (\"instance-specific-setup\", Client.upload_instance_setup),",
            "        (\"third-party\", Client.upload_third_party),",
            "        (\"api\", Client.deploy_app),",
            "        (\"export_appinsights\", Client.add_log_export),",
            "        (\"update_registration\", Client.update_registration),",
            "    ]",
            "",
            "    formatter = argparse.ArgumentDefaultsHelpFormatter",
            "    parser = argparse.ArgumentParser(formatter_class=formatter)",
            "    parser.add_argument(\"location\")",
            "    parser.add_argument(\"resource_group\")",
            "    parser.add_argument(\"application_name\")",
            "    parser.add_argument(\"owner\")",
            "    parser.add_argument(",
            "        \"--arm-template\",",
            "        type=arg_file,",
            "        default=\"azuredeploy.json\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--workbook-data\",",
            "        type=arg_file,",
            "        default=\"workbook-data.json\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--app-zip\",",
            "        type=arg_file,",
            "        default=\"api-service.zip\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--tools\", type=arg_dir, default=\"tools\", help=\"(default: %(default)s)\"",
            "    )",
            "    parser.add_argument(",
            "        \"--instance_specific\",",
            "        type=arg_dir,",
            "        default=\"instance-specific-setup\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--third-party\",",
            "        type=arg_dir,",
            "        default=\"third-party\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(\"--client_id\")",
            "    parser.add_argument(\"--client_secret\")",
            "    parser.add_argument(",
            "        \"--start_at\",",
            "        default=full_deployment_states[0][0],",
            "        choices=[x[0] for x in full_deployment_states],",
            "        help=(",
            "            \"Debug deployments by starting at a specific state.  \"",
            "            \"NOT FOR PRODUCTION USE.  (default: %(default)s)\"",
            "        ),",
            "    )",
            "    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")",
            "    parser.add_argument(",
            "        \"--create_pool_registration\",",
            "        action=\"store_true\",",
            "        help=\"Create an application registration and/or generate a \"",
            "        \"password for the pool agent\",",
            "    )",
            "    parser.add_argument(",
            "        \"--upgrade\",",
            "        action=\"store_true\",",
            "        help=\"Indicates that the instance is being upgraded\",",
            "    )",
            "    parser.add_argument(",
            "        \"--apply_migrations\",",
            "        type=str,",
            "        nargs=\"+\",",
            "        default=[],",
            "        help=\"list of migration to apply to the azure table\",",
            "    )",
            "    parser.add_argument(",
            "        \"--export_appinsights\",",
            "        action=\"store_true\",",
            "        help=\"enable appinsight log export\",",
            "    )",
            "    parser.add_argument(",
            "        \"--log_service_principal\",",
            "        action=\"store_true\",",
            "        help=\"display service prinipal with info log level\",",
            "    )",
            "    parser.add_argument(",
            "        \"--multi_tenant_domain\",",
            "        type=str,",
            "        default=None,",
            "        help=\"enable multi-tenant authentication with this tenant domain\",",
            "    )",
            "    parser.add_argument(",
            "        \"--subscription_id\",",
            "        type=str,",
            "    )",
            "    parser.add_argument(",
            "        \"--rbac_only\",",
            "        action=\"store_true\",",
            "        help=\"execute only the steps required to create the rbac resources\",",
            "    )",
            "    parser.add_argument(",
            "        \"--set_admins\",",
            "        type=UUID,",
            "        nargs=\"*\",",
            "        help=\"set the list of administrators (by OID in AAD)\",",
            "    )",
            "",
            "    args = parser.parse_args()",
            "",
            "    if shutil.which(\"func\") is None:",
            "        logger.error(FUNC_TOOLS_ERROR)",
            "        sys.exit(1)",
            "",
            "    client = Client(",
            "        resource_group=args.resource_group,",
            "        location=args.location,",
            "        application_name=args.application_name,",
            "        owner=args.owner,",
            "        client_id=args.client_id,",
            "        client_secret=args.client_secret,",
            "        app_zip=args.app_zip,",
            "        tools=args.tools,",
            "        instance_specific=args.instance_specific,",
            "        third_party=args.third_party,",
            "        arm_template=args.arm_template,",
            "        workbook_data=args.workbook_data,",
            "        create_registration=args.create_pool_registration,",
            "        migrations=args.apply_migrations,",
            "        export_appinsights=args.export_appinsights,",
            "        log_service_principal=args.log_service_principal,",
            "        multi_tenant_domain=args.multi_tenant_domain,",
            "        upgrade=args.upgrade,",
            "        subscription_id=args.subscription_id,",
            "        admins=args.set_admins,",
            "    )",
            "    if args.verbose:",
            "        level = logging.DEBUG",
            "    else:",
            "        level = logging.WARN",
            "",
            "    logging.basicConfig(level=level)",
            "",
            "    logging.getLogger(\"deploy\").setLevel(logging.INFO)",
            "",
            "    if args.rbac_only:",
            "        logger.warning(",
            "            \"'rbac_only' specified. The deployment will execute \"",
            "            \"only the steps required to create the rbac resources\"",
            "        )",
            "        states = rbac_only_states",
            "    else:",
            "        states = full_deployment_states",
            "",
            "    if args.start_at != states[0][0]:",
            "        logger.warning(",
            "            \"*** Starting at a non-standard deployment state.  \"",
            "            \"This may result in a broken deployment.  ***\"",
            "        )",
            "",
            "    started = False",
            "    for state in states:",
            "        if args.start_at == state[0]:",
            "            started = True",
            "        if started:",
            "            state[1](client)",
            "",
            "    client.done()",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "#",
            "# Copyright (c) Microsoft Corporation.",
            "# Licensed under the MIT License.",
            "",
            "import argparse",
            "import json",
            "import logging",
            "import os",
            "import platform",
            "import shutil",
            "import subprocess",
            "import sys",
            "import tempfile",
            "import time",
            "import uuid",
            "import zipfile",
            "from datetime import datetime, timedelta",
            "from typing import Dict, List, Optional, Tuple, Union, cast",
            "from uuid import UUID",
            "",
            "from azure.common.client_factory import get_client_from_cli_profile",
            "from azure.common.credentials import get_cli_profile",
            "from azure.core.exceptions import ResourceExistsError",
            "from azure.cosmosdb.table.tableservice import TableService",
            "from azure.graphrbac import GraphRbacManagementClient",
            "from azure.graphrbac.models import (",
            "    Application,",
            "    ApplicationCreateParameters,",
            "    ApplicationUpdateParameters,",
            "    AppRole,",
            "    GraphErrorException,",
            "    OptionalClaims,",
            "    RequiredResourceAccess,",
            "    ResourceAccess,",
            "    ServicePrincipalCreateParameters,",
            ")",
            "from azure.mgmt.applicationinsights import ApplicationInsightsManagementClient",
            "from azure.mgmt.applicationinsights.models import (",
            "    ApplicationInsightsComponentExportRequest,",
            ")",
            "from azure.mgmt.eventgrid import EventGridManagementClient",
            "from azure.mgmt.eventgrid.models import (",
            "    EventSubscription,",
            "    EventSubscriptionFilter,",
            "    RetryPolicy,",
            "    StorageQueueEventSubscriptionDestination,",
            ")",
            "from azure.mgmt.resource import ResourceManagementClient, SubscriptionClient",
            "from azure.mgmt.resource.resources.models import (",
            "    Deployment,",
            "    DeploymentMode,",
            "    DeploymentProperties,",
            ")",
            "from azure.mgmt.storage import StorageManagementClient",
            "from azure.storage.blob import (",
            "    BlobServiceClient,",
            "    ContainerSasPermissions,",
            "    generate_container_sas,",
            ")",
            "from azure.storage.queue import QueueServiceClient",
            "from msrest.serialization import TZ_UTC",
            "",
            "from data_migration import migrate",
            "from registration import (",
            "    OnefuzzAppRole,",
            "    add_application_password,",
            "    assign_app_role,",
            "    authorize_application,",
            "    get_graph_client,",
            "    register_application,",
            "    set_app_audience,",
            "    update_pool_registration,",
            ")",
            "from set_admins import update_admins, update_allowed_aad_tenants",
            "",
            "# Found by manually assigning the User.Read permission to application",
            "# registration in the admin portal. The values are in the manifest under",
            "# the section \"requiredResourceAccess\"",
            "USER_READ_PERMISSION = \"e1fe6dd8-ba31-4d61-89e7-88639da4683d\"",
            "MICROSOFT_GRAPH_APP_ID = \"00000003-0000-0000-c000-000000000000\"",
            "",
            "ONEFUZZ_CLI_APP = \"72f1562a-8c0c-41ea-beb9-fa2b71c80134\"",
            "ONEFUZZ_CLI_AUTHORITY = (",
            "    \"https://login.microsoftonline.com/72f988bf-86f1-41af-91ab-2d7cd011db47\"",
            ")",
            "COMMON_AUTHORITY = \"https://login.microsoftonline.com/common\"",
            "TELEMETRY_NOTICE = (",
            "    \"Telemetry collection on stats and OneFuzz failures are sent to Microsoft. \"",
            "    \"To disable, delete the ONEFUZZ_TELEMETRY application setting in the \"",
            "    \"Azure Functions instance\"",
            ")",
            "AZCOPY_MISSING_ERROR = (",
            "    \"azcopy is not installed and unable to use the built-in version. \"",
            "    \"Installation instructions are available at https://aka.ms/azcopy\"",
            ")",
            "FUNC_TOOLS_ERROR = (",
            "    \"azure-functions-core-tools is not installed, \"",
            "    \"install v3 using instructions: \"",
            "    \"https://github.com/Azure/azure-functions-core-tools#installing\"",
            ")",
            "",
            "logger = logging.getLogger(\"deploy\")",
            "",
            "",
            "def gen_guid() -> str:",
            "    return str(uuid.uuid4())",
            "",
            "",
            "class Client:",
            "    def __init__(",
            "        self,",
            "        *,",
            "        resource_group: str,",
            "        location: str,",
            "        application_name: str,",
            "        owner: str,",
            "        client_id: Optional[str],",
            "        client_secret: Optional[str],",
            "        app_zip: str,",
            "        tools: str,",
            "        instance_specific: str,",
            "        third_party: str,",
            "        arm_template: str,",
            "        workbook_data: str,",
            "        create_registration: bool,",
            "        migrations: List[str],",
            "        export_appinsights: bool,",
            "        log_service_principal: bool,",
            "        multi_tenant_domain: str,",
            "        upgrade: bool,",
            "        subscription_id: Optional[str],",
            "        admins: List[UUID],",
            "        allowed_aad_tenants: List[UUID],",
            "    ):",
            "        self.subscription_id = subscription_id",
            "        self.resource_group = resource_group",
            "        self.arm_template = arm_template",
            "        self.location = location",
            "        self.application_name = application_name",
            "        self.owner = owner",
            "        self.app_zip = app_zip",
            "        self.tools = tools",
            "        self.instance_specific = instance_specific",
            "        self.third_party = third_party",
            "        self.create_registration = create_registration",
            "        self.multi_tenant_domain = multi_tenant_domain",
            "        self.upgrade = upgrade",
            "        self.results: Dict = {",
            "            \"client_id\": client_id,",
            "            \"client_secret\": client_secret,",
            "        }",
            "        if self.multi_tenant_domain:",
            "            authority = COMMON_AUTHORITY",
            "        else:",
            "            authority = ONEFUZZ_CLI_AUTHORITY",
            "        self.cli_config: Dict[str, Union[str, UUID]] = {",
            "            \"client_id\": ONEFUZZ_CLI_APP,",
            "            \"authority\": authority,",
            "        }",
            "        self.migrations = migrations",
            "        self.export_appinsights = export_appinsights",
            "        self.log_service_principal = log_service_principal",
            "        self.admins = admins",
            "        self.allowed_aad_tenants = allowed_aad_tenants",
            "",
            "        machine = platform.machine()",
            "        system = platform.system()",
            "",
            "        if system == \"Linux\" and machine == \"x86_64\":",
            "            self.azcopy = os.path.join(self.tools, \"linux\", \"azcopy\")",
            "            subprocess.check_output([\"chmod\", \"+x\", self.azcopy])",
            "        elif system == \"Windows\" and machine == \"AMD64\":",
            "            self.azcopy = os.path.join(self.tools, \"win64\", \"azcopy.exe\")",
            "        else:",
            "            azcopy = shutil.which(\"azcopy\")",
            "            if not azcopy:",
            "                raise Exception(AZCOPY_MISSING_ERROR)",
            "            else:",
            "                logger.warn(\"unable to use built-in azcopy, using system install\")",
            "                self.azcopy = azcopy",
            "",
            "        with open(workbook_data) as f:",
            "            self.workbook_data = json.load(f)",
            "",
            "    def get_subscription_id(self) -> str:",
            "        if self.subscription_id:",
            "            return self.subscription_id",
            "        profile = get_cli_profile()",
            "        self.subscription_id = cast(str, profile.get_subscription_id())",
            "        return self.subscription_id",
            "",
            "    def get_location_display_name(self) -> str:",
            "        location_client = get_client_from_cli_profile(",
            "            SubscriptionClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        locations = location_client.subscriptions.list_locations(",
            "            self.get_subscription_id()",
            "        )",
            "        for location in locations:",
            "            if location.name == self.location:",
            "                return cast(str, location.display_name)",
            "",
            "        raise Exception(\"unknown location: %s\", self.location)",
            "",
            "    def check_region(self) -> None:",
            "        # At the moment, this only checks are the specified providers available",
            "        # in the selected region",
            "",
            "        location = self.get_location_display_name()",
            "",
            "        with open(self.arm_template, \"r\") as handle:",
            "            arm = json.load(handle)",
            "",
            "        client = get_client_from_cli_profile(",
            "            ResourceManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        providers = {x.namespace: x for x in client.providers.list()}",
            "",
            "        unsupported = []",
            "",
            "        for resource in arm[\"resources\"]:",
            "            namespace, name = resource[\"type\"].split(\"/\", 1)",
            "",
            "            # resource types are in the form of a/b/c....",
            "            # only the top two are listed as resource types within providers",
            "            name = \"/\".join(name.split(\"/\")[:2])",
            "",
            "            if namespace not in providers:",
            "                unsupported.append(\"Unsupported provider: %s\" % namespace)",
            "                continue",
            "",
            "            provider = providers[namespace]",
            "            resource_types = {x.resource_type: x for x in provider.resource_types}",
            "            if name not in resource_types:",
            "                unsupported.append(",
            "                    \"Unsupported resource type: %s/%s\" % (namespace, name)",
            "                )",
            "                continue",
            "",
            "            resource_type = resource_types[name]",
            "            if (",
            "                location not in resource_type.locations",
            "                and len(resource_type.locations) > 0",
            "            ):",
            "                unsupported.append(",
            "                    \"%s/%s is unsupported in %s\" % (namespace, name, self.location)",
            "                )",
            "",
            "        if unsupported:",
            "            print(\"The following resources required by onefuzz are not supported:\")",
            "            print(\"\\n\".join([\"* \" + x for x in unsupported]))",
            "            sys.exit(1)",
            "",
            "    def create_password(self, object_id: UUID) -> Tuple[str, str]:",
            "        return add_application_password(object_id, self.get_subscription_id())",
            "",
            "    def setup_rbac(self) -> None:",
            "        \"\"\"",
            "        Setup the client application for the OneFuzz instance.",
            "        By default, Service Principals do not have access to create",
            "        client applications in AAD.",
            "        \"\"\"",
            "        if self.results[\"client_id\"] and self.results[\"client_secret\"]:",
            "            logger.info(\"using existing client application\")",
            "            return",
            "",
            "        client = get_client_from_cli_profile(",
            "            GraphRbacManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        logger.info(\"checking if RBAC already exists\")",
            "",
            "        try:",
            "            existing = list(",
            "                client.applications.list(",
            "                    filter=\"displayName eq '%s'\" % self.application_name",
            "                )",
            "            )",
            "        except GraphErrorException:",
            "            logger.error(\"unable to query RBAC. Provide client_id and client_secret\")",
            "            sys.exit(1)",
            "",
            "        app_roles = [",
            "            AppRole(",
            "                allowed_member_types=[\"Application\"],",
            "                display_name=OnefuzzAppRole.CliClient.value,",
            "                id=str(uuid.uuid4()),",
            "                is_enabled=True,",
            "                description=\"Allows access from the CLI.\",",
            "                value=OnefuzzAppRole.CliClient.value,",
            "            ),",
            "            AppRole(",
            "                allowed_member_types=[\"Application\"],",
            "                display_name=OnefuzzAppRole.ManagedNode.value,",
            "                id=str(uuid.uuid4()),",
            "                is_enabled=True,",
            "                description=\"Allow access from a lab machine.\",",
            "                value=OnefuzzAppRole.ManagedNode.value,",
            "            ),",
            "        ]",
            "",
            "        app: Optional[Application] = None",
            "",
            "        if not existing:",
            "            logger.info(\"creating Application registration\")",
            "",
            "            if self.multi_tenant_domain:",
            "                url = \"https://%s/%s\" % (",
            "                    self.multi_tenant_domain,",
            "                    self.application_name,",
            "                )",
            "            else:",
            "                url = \"https://%s.azurewebsites.net\" % self.application_name",
            "",
            "            params = ApplicationCreateParameters(",
            "                display_name=self.application_name,",
            "                identifier_uris=[url],",
            "                reply_urls=[url + \"/.auth/login/aad/callback\"],",
            "                optional_claims=OptionalClaims(id_token=[], access_token=[]),",
            "                required_resource_access=[",
            "                    RequiredResourceAccess(",
            "                        resource_access=[",
            "                            ResourceAccess(id=USER_READ_PERMISSION, type=\"Scope\")",
            "                        ],",
            "                        resource_app_id=MICROSOFT_GRAPH_APP_ID,",
            "                    )",
            "                ],",
            "                app_roles=app_roles,",
            "            )",
            "",
            "            app = client.applications.create(params)",
            "",
            "            logger.info(\"creating service principal\")",
            "            service_principal_params = ServicePrincipalCreateParameters(",
            "                account_enabled=True,",
            "                app_role_assignment_required=False,",
            "                service_principal_type=\"Application\",",
            "                app_id=app.app_id,",
            "            )",
            "",
            "            def try_sp_create() -> None:",
            "                error: Optional[Exception] = None",
            "                for _ in range(10):",
            "                    try:",
            "                        client.service_principals.create(service_principal_params)",
            "                        return",
            "                    except GraphErrorException as err:",
            "                        # work around timing issue when creating service principal",
            "                        # https://github.com/Azure/azure-cli/issues/14767",
            "                        if (",
            "                            \"service principal being created must in the local tenant\"",
            "                            not in str(err)",
            "                        ):",
            "                            raise err",
            "                    logger.warning(",
            "                        \"creating service principal failed with an error that occurs \"",
            "                        \"due to AAD race conditions\"",
            "                    )",
            "                    time.sleep(60)",
            "                if error is None:",
            "                    raise Exception(\"service principal creation failed\")",
            "                else:",
            "                    raise error",
            "",
            "            try_sp_create()",
            "",
            "        else:",
            "            app = existing[0]",
            "            existing_role_values = [app_role.value for app_role in app.app_roles]",
            "            has_missing_roles = any(",
            "                [role.value not in existing_role_values for role in app_roles]",
            "            )",
            "",
            "            if has_missing_roles:",
            "                # disabling the existing app role first to allow the update",
            "                # this is a requirement to update the application roles",
            "                for role in app.app_roles:",
            "                    role.is_enabled = False",
            "",
            "                client.applications.patch(",
            "                    app.object_id, ApplicationUpdateParameters(app_roles=app.app_roles)",
            "                )",
            "",
            "                # overriding the list of app roles",
            "                client.applications.patch(",
            "                    app.object_id, ApplicationUpdateParameters(app_roles=app_roles)",
            "                )",
            "",
            "        if self.multi_tenant_domain and app.sign_in_audience == \"AzureADMyOrg\":",
            "            url = \"https://%s/%s\" % (",
            "                self.multi_tenant_domain,",
            "                self.application_name,",
            "            )",
            "            client.applications.patch(",
            "                app.object_id, ApplicationUpdateParameters(identifier_uris=[url])",
            "            )",
            "            set_app_audience(app.object_id, \"AzureADMultipleOrgs\")",
            "        elif (",
            "            not self.multi_tenant_domain",
            "            and app.sign_in_audience == \"AzureADMultipleOrgs\"",
            "        ):",
            "            set_app_audience(app.object_id, \"AzureADMyOrg\")",
            "            url = \"https://%s.azurewebsites.net\" % self.application_name",
            "            client.applications.patch(",
            "                app.object_id, ApplicationUpdateParameters(identifier_uris=[url])",
            "            )",
            "        else:",
            "            logger.debug(\"No change to App Registration signInAudence setting\")",
            "",
            "            creds = list(client.applications.list_password_credentials(app.object_id))",
            "            client.applications.update_password_credentials(app.object_id, creds)",
            "",
            "        (password_id, password) = self.create_password(app.object_id)",
            "",
            "        cli_app = list(",
            "            client.applications.list(filter=\"appId eq '%s'\" % ONEFUZZ_CLI_APP)",
            "        )",
            "",
            "        if len(cli_app) == 0:",
            "            logger.info(",
            "                \"Could not find the default CLI application under the current \"",
            "                \"subscription, creating a new one\"",
            "            )",
            "            app_info = register_application(",
            "                \"onefuzz-cli\",",
            "                self.application_name,",
            "                OnefuzzAppRole.CliClient,",
            "                self.get_subscription_id(),",
            "            )",
            "            if self.multi_tenant_domain:",
            "                authority = COMMON_AUTHORITY",
            "            else:",
            "                authority = app_info.authority",
            "            self.cli_config = {",
            "                \"client_id\": app_info.client_id,",
            "                \"authority\": authority,",
            "            }",
            "",
            "        else:",
            "            onefuzz_cli_app = cli_app[0]",
            "            authorize_application(uuid.UUID(onefuzz_cli_app.app_id), app.app_id)",
            "            if self.multi_tenant_domain:",
            "                authority = COMMON_AUTHORITY",
            "            else:",
            "                onefuzz_client = get_graph_client(self.get_subscription_id())",
            "                authority = (",
            "                    \"https://login.microsoftonline.com/%s\"",
            "                    % onefuzz_client.config.tenant_id",
            "                )",
            "            self.cli_config = {",
            "                \"client_id\": onefuzz_cli_app.app_id,",
            "                \"authority\": authority,",
            "            }",
            "",
            "        self.results[\"client_id\"] = app.app_id",
            "        self.results[\"client_secret\"] = password",
            "",
            "        # Log `client_secret` for consumption by CI.",
            "        if self.log_service_principal:",
            "            logger.info(\"client_id: %s client_secret: %s\", app.app_id, password)",
            "        else:",
            "            logger.debug(\"client_id: %s client_secret: %s\", app.app_id, password)",
            "",
            "    def deploy_template(self) -> None:",
            "        logger.info(\"deploying arm template: %s\", self.arm_template)",
            "",
            "        with open(self.arm_template, \"r\") as template_handle:",
            "            template = json.load(template_handle)",
            "",
            "        client = get_client_from_cli_profile(",
            "            ResourceManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        client.resource_groups.create_or_update(",
            "            self.resource_group, {\"location\": self.location}",
            "        )",
            "",
            "        expiry = (datetime.now(TZ_UTC) + timedelta(days=365)).strftime(",
            "            \"%Y-%m-%dT%H:%M:%SZ\"",
            "        )",
            "",
            "        if self.multi_tenant_domain:",
            "            # clear the value in the Issuer Url field:",
            "            # https://docs.microsoft.com/en-us/sharepoint/dev/spfx/use-aadhttpclient-enterpriseapi-multitenant",
            "            app_func_audience = \"https://%s/%s\" % (",
            "                self.multi_tenant_domain,",
            "                self.application_name,",
            "            )",
            "            app_func_issuer = \"\"",
            "            multi_tenant_domain = {\"value\": self.multi_tenant_domain}",
            "        else:",
            "            app_func_audience = \"https://%s.azurewebsites.net\" % self.application_name",
            "            tenant_oid = str(self.cli_config[\"authority\"]).split(\"/\")[-1]",
            "            app_func_issuer = \"https://sts.windows.net/%s/\" % tenant_oid",
            "            multi_tenant_domain = {\"value\": \"\"}",
            "",
            "        params = {",
            "            \"app_func_audience\": {\"value\": app_func_audience},",
            "            \"name\": {\"value\": self.application_name},",
            "            \"owner\": {\"value\": self.owner},",
            "            \"clientId\": {\"value\": self.results[\"client_id\"]},",
            "            \"clientSecret\": {\"value\": self.results[\"client_secret\"]},",
            "            \"app_func_issuer\": {\"value\": app_func_issuer},",
            "            \"signedExpiry\": {\"value\": expiry},",
            "            \"multi_tenant_domain\": multi_tenant_domain,",
            "            \"workbookData\": {\"value\": self.workbook_data},",
            "        }",
            "        deployment = Deployment(",
            "            properties=DeploymentProperties(",
            "                mode=DeploymentMode.incremental, template=template, parameters=params",
            "            )",
            "        )",
            "        count = 0",
            "        tries = 10",
            "        error: Optional[Exception] = None",
            "        while count < tries:",
            "            count += 1",
            "",
            "            try:",
            "                result = client.deployments.begin_create_or_update(",
            "                    self.resource_group, gen_guid(), deployment",
            "                ).result()",
            "                if result.properties.provisioning_state != \"Succeeded\":",
            "                    logger.error(",
            "                        \"error deploying: %s\",",
            "                        json.dumps(result.as_dict(), indent=4, sort_keys=True),",
            "                    )",
            "                    sys.exit(1)",
            "                self.results[\"deploy\"] = result.properties.outputs",
            "                return",
            "            except Exception as err:",
            "                error = err",
            "                as_repr = repr(err)",
            "                # Modeled after Azure-CLI.  See:",
            "                # https://github.com/Azure/azure-cli/blob/",
            "                #   3a2f6009cff788fde3b0170823c9129f187b2812/src/azure-cli-core/",
            "                #   azure/cli/core/commands/arm.py#L1086",
            "                if (",
            "                    \"PrincipalNotFound\" in as_repr",
            "                    and \"does not exist in the directory\" in as_repr",
            "                ):",
            "                    logger.info(\"application principal not available in AAD yet\")",
            "        if error:",
            "            raise error",
            "        else:",
            "            raise Exception(\"unknown error deploying\")",
            "",
            "    def assign_scaleset_identity_role(self) -> None:",
            "        if self.upgrade:",
            "            logger.info(\"Upgrading: skipping assignment of the managed identity role\")",
            "            return",
            "        logger.info(\"assigning the user managed identity role\")",
            "        assign_app_role(",
            "            self.application_name,",
            "            self.results[\"deploy\"][\"scaleset-identity\"][\"value\"],",
            "            self.get_subscription_id(),",
            "            OnefuzzAppRole.ManagedNode,",
            "        )",
            "",
            "    def apply_migrations(self) -> None:",
            "        name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        table_service = TableService(account_name=name, account_key=key)",
            "        migrate(table_service, self.migrations)",
            "",
            "    def set_instance_config(self) -> None:",
            "        name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        tenant = UUID(self.results[\"deploy\"][\"tenant_id\"][\"value\"])",
            "        table_service = TableService(account_name=name, account_key=key)",
            "",
            "        if self.admins:",
            "            update_admins(table_service, self.application_name, self.admins)",
            "",
            "        tenants = self.allowed_aad_tenants",
            "        if tenant not in tenants:",
            "            tenants.append(tenant)",
            "        update_allowed_aad_tenants(table_service, self.application_name, tenants)",
            "",
            "    def create_queues(self) -> None:",
            "        logger.info(\"creating eventgrid destination queue\")",
            "",
            "        name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.queue.core.windows.net\" % name",
            "        client = QueueServiceClient(",
            "            account_url=account_url,",
            "            credential={\"account_name\": name, \"account_key\": key},",
            "        )",
            "        for queue in [",
            "            \"file-changes\",",
            "            \"task-heartbeat\",",
            "            \"node-heartbeat\",",
            "            \"proxy\",",
            "            \"update-queue\",",
            "            \"webhooks\",",
            "            \"signalr-events\",",
            "        ]:",
            "            try:",
            "                client.create_queue(queue)",
            "            except ResourceExistsError:",
            "                pass",
            "",
            "    def create_eventgrid(self) -> None:",
            "        logger.info(\"creating eventgrid subscription\")",
            "        src_resource_id = self.results[\"deploy\"][\"fuzz-storage\"][\"value\"]",
            "        dst_resource_id = self.results[\"deploy\"][\"func-storage\"][\"value\"]",
            "        client = get_client_from_cli_profile(",
            "            StorageManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        event_subscription_info = EventSubscription(",
            "            destination=StorageQueueEventSubscriptionDestination(",
            "                resource_id=dst_resource_id, queue_name=\"file-changes\"",
            "            ),",
            "            filter=EventSubscriptionFilter(",
            "                included_event_types=[",
            "                    \"Microsoft.Storage.BlobCreated\",",
            "                    \"Microsoft.Storage.BlobDeleted\",",
            "                ]",
            "            ),",
            "            retry_policy=RetryPolicy(",
            "                max_delivery_attempts=30,",
            "                event_time_to_live_in_minutes=1440,",
            "            ),",
            "        )",
            "",
            "        client = get_client_from_cli_profile(",
            "            EventGridManagementClient, subscription_id=self.get_subscription_id()",
            "        )",
            "        result = client.event_subscriptions.begin_create_or_update(",
            "            src_resource_id, \"onefuzz1\", event_subscription_info",
            "        ).result()",
            "        if result.provisioning_state != \"Succeeded\":",
            "            raise Exception(",
            "                \"eventgrid subscription failed: %s\"",
            "                % json.dumps(result.as_dict(), indent=4, sort_keys=True),",
            "            )",
            "",
            "    def add_instance_id(self) -> None:",
            "        logger.info(\"setting instance_id log export\")",
            "",
            "        container_name = \"base-config\"",
            "        blob_name = \"instance_id\"",
            "        account_name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        if container_name not in [x[\"name\"] for x in client.list_containers()]:",
            "            client.create_container(container_name)",
            "",
            "        blob_client = client.get_blob_client(container_name, blob_name)",
            "        if blob_client.exists():",
            "            logger.debug(\"instance_id already exists\")",
            "            instance_id = uuid.UUID(blob_client.download_blob().readall().decode())",
            "        else:",
            "            logger.debug(\"creating new instance_id\")",
            "            instance_id = uuid.uuid4()",
            "            blob_client.upload_blob(str(instance_id))",
            "",
            "        logger.info(\"instance_id: %s\", instance_id)",
            "",
            "    def add_log_export(self) -> None:",
            "        if not self.export_appinsights:",
            "            logger.info(\"not exporting appinsights\")",
            "            return",
            "",
            "        container_name = \"app-insights\"",
            "",
            "        logger.info(\"adding appinsight log export\")",
            "        account_name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        if container_name not in [x[\"name\"] for x in client.list_containers()]:",
            "            client.create_container(container_name)",
            "",
            "        expiry = datetime.utcnow() + timedelta(days=2 * 365)",
            "",
            "        # NOTE: as this is a long-lived SAS url, it should not be logged and only",
            "        # used in the the later-on export_configurations.create() call",
            "        sas = generate_container_sas(",
            "            account_name,",
            "            container_name,",
            "            account_key=key,",
            "            permission=ContainerSasPermissions(write=True),",
            "            expiry=expiry,",
            "        )",
            "        url = \"%s/%s?%s\" % (account_url, container_name, sas)",
            "",
            "        record_types = (",
            "            \"Requests, Event, Exceptions, Metrics, PageViews, \"",
            "            \"PageViewPerformance, Rdd, PerformanceCounters, Availability\"",
            "        )",
            "",
            "        req = ApplicationInsightsComponentExportRequest(",
            "            record_types=record_types,",
            "            destination_type=\"Blob\",",
            "            is_enabled=\"true\",",
            "            destination_address=url,",
            "        )",
            "",
            "        app_insight_client = get_client_from_cli_profile(",
            "            ApplicationInsightsManagementClient,",
            "            subscription_id=self.get_subscription_id(),",
            "        )",
            "",
            "        to_delete = []",
            "        for entry in app_insight_client.export_configurations.list(",
            "            self.resource_group, self.application_name",
            "        ):",
            "            if (",
            "                entry.storage_name == account_name",
            "                and entry.container_name == container_name",
            "            ):",
            "                to_delete.append(entry.export_id)",
            "",
            "        for export_id in to_delete:",
            "            logger.info(\"replacing existing export: %s\", export_id)",
            "            app_insight_client.export_configurations.delete(",
            "                self.resource_group, self.application_name, export_id",
            "            )",
            "",
            "        app_insight_client.export_configurations.create(",
            "            self.resource_group, self.application_name, req",
            "        )",
            "",
            "    def upload_tools(self) -> None:",
            "        logger.info(\"uploading tools from %s\", self.tools)",
            "        account_name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        if \"tools\" not in [x[\"name\"] for x in client.list_containers()]:",
            "            client.create_container(\"tools\")",
            "",
            "        expiry = datetime.utcnow() + timedelta(minutes=30)",
            "",
            "        sas = generate_container_sas(",
            "            account_name,",
            "            \"tools\",",
            "            account_key=key,",
            "            permission=ContainerSasPermissions(",
            "                read=True, write=True, delete=True, list=True",
            "            ),",
            "            expiry=expiry,",
            "        )",
            "        url = \"%s/%s?%s\" % (account_url, \"tools\", sas)",
            "",
            "        subprocess.check_output(",
            "            [",
            "                self.azcopy,",
            "                \"copy\",",
            "                os.path.join(self.tools, \"*\"),",
            "                url,",
            "                \"--overwrite=true\",",
            "                \"--recursive=true\",",
            "            ]",
            "        )",
            "",
            "        subprocess.check_output(",
            "            [self.azcopy, \"sync\", self.tools, url, \"--delete-destination\", \"true\"]",
            "        )",
            "",
            "    def upload_instance_setup(self) -> None:",
            "        logger.info(\"uploading instance-specific-setup from %s\", self.instance_specific)",
            "        account_name = self.results[\"deploy\"][\"func-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"func-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        if \"instance-specific-setup\" not in [",
            "            x[\"name\"] for x in client.list_containers()",
            "        ]:",
            "            client.create_container(\"instance-specific-setup\")",
            "",
            "        expiry = datetime.utcnow() + timedelta(minutes=30)",
            "",
            "        sas = generate_container_sas(",
            "            account_name,",
            "            \"instance-specific-setup\",",
            "            account_key=key,",
            "            permission=ContainerSasPermissions(",
            "                read=True, write=True, delete=True, list=True",
            "            ),",
            "            expiry=expiry,",
            "        )",
            "        url = \"%s/%s?%s\" % (account_url, \"instance-specific-setup\", sas)",
            "",
            "        subprocess.check_output(",
            "            [",
            "                self.azcopy,",
            "                \"copy\",",
            "                os.path.join(self.instance_specific, \"*\"),",
            "                url,",
            "                \"--overwrite=true\",",
            "                \"--recursive=true\",",
            "            ]",
            "        )",
            "",
            "        subprocess.check_output(",
            "            [",
            "                self.azcopy,",
            "                \"sync\",",
            "                self.instance_specific,",
            "                url,",
            "                \"--delete-destination\",",
            "                \"true\",",
            "            ]",
            "        )",
            "",
            "    def upload_third_party(self) -> None:",
            "        logger.info(\"uploading third-party tools from %s\", self.third_party)",
            "        account_name = self.results[\"deploy\"][\"fuzz-name\"][\"value\"]",
            "        key = self.results[\"deploy\"][\"fuzz-key\"][\"value\"]",
            "        account_url = \"https://%s.blob.core.windows.net\" % account_name",
            "",
            "        client = BlobServiceClient(account_url, credential=key)",
            "        containers = [x[\"name\"] for x in client.list_containers()]",
            "",
            "        for name in os.listdir(self.third_party):",
            "            path = os.path.join(self.third_party, name)",
            "            if not os.path.isdir(path):",
            "                continue",
            "            if name not in containers:",
            "                client.create_container(name)",
            "",
            "            expiry = datetime.utcnow() + timedelta(minutes=30)",
            "            sas = generate_container_sas(",
            "                account_name,",
            "                name,",
            "                account_key=key,",
            "                permission=ContainerSasPermissions(",
            "                    read=True, write=True, delete=True, list=True",
            "                ),",
            "                expiry=expiry,",
            "            )",
            "            url = \"%s/%s?%s\" % (account_url, name, sas)",
            "",
            "            subprocess.check_output(",
            "                [",
            "                    self.azcopy,",
            "                    \"copy\",",
            "                    os.path.join(path, \"*\"),",
            "                    url,",
            "                    \"--overwrite=true\",",
            "                    \"--recursive=true\",",
            "                ]",
            "            )",
            "",
            "            subprocess.check_output(",
            "                [self.azcopy, \"sync\", path, url, \"--delete-destination\", \"true\"]",
            "            )",
            "",
            "    def deploy_app(self) -> None:",
            "        logger.info(\"deploying function app %s\", self.app_zip)",
            "        with tempfile.TemporaryDirectory() as tmpdirname:",
            "            with zipfile.ZipFile(self.app_zip, \"r\") as zip_ref:",
            "                func = shutil.which(\"func\")",
            "                assert func is not None",
            "",
            "                zip_ref.extractall(tmpdirname)",
            "                error: Optional[subprocess.CalledProcessError] = None",
            "                max_tries = 5",
            "                for i in range(max_tries):",
            "                    try:",
            "                        subprocess.check_output(",
            "                            [",
            "                                func,",
            "                                \"azure\",",
            "                                \"functionapp\",",
            "                                \"publish\",",
            "                                self.application_name,",
            "                                \"--python\",",
            "                                \"--no-build\",",
            "                            ],",
            "                            env=dict(os.environ, CLI_DEBUG=\"1\"),",
            "                            cwd=tmpdirname,",
            "                        )",
            "                        return",
            "                    except subprocess.CalledProcessError as err:",
            "                        error = err",
            "                        if i + 1 < max_tries:",
            "                            logger.debug(\"func failure error: %s\", err)",
            "                            logger.warning(",
            "                                \"function failed to deploy, waiting 60 \"",
            "                                \"seconds and trying again\"",
            "                            )",
            "                            time.sleep(60)",
            "                if error is not None:",
            "                    raise error",
            "",
            "    def update_registration(self) -> None:",
            "        if not self.create_registration:",
            "            return",
            "        update_pool_registration(self.application_name, self.get_subscription_id())",
            "",
            "    def done(self) -> None:",
            "        logger.info(TELEMETRY_NOTICE)",
            "        client_secret_arg = (",
            "            (\"--client_secret %s\" % self.cli_config[\"client_secret\"])",
            "            if \"client_secret\" in self.cli_config",
            "            else \"\"",
            "        )",
            "        multi_tenant_domain = \"\"",
            "        if self.multi_tenant_domain:",
            "            multi_tenant_domain = \"--tenant_domain %s\" % self.multi_tenant_domain",
            "        logger.info(",
            "            \"Update your CLI config via: onefuzz config --endpoint \"",
            "            \"https://%s.azurewebsites.net --authority %s --client_id %s %s %s\",",
            "            self.application_name,",
            "            self.cli_config[\"authority\"],",
            "            self.cli_config[\"client_id\"],",
            "            client_secret_arg,",
            "            multi_tenant_domain,",
            "        )",
            "",
            "",
            "def arg_dir(arg: str) -> str:",
            "    if not os.path.isdir(arg):",
            "        raise argparse.ArgumentTypeError(\"not a directory: %s\" % arg)",
            "    return arg",
            "",
            "",
            "def arg_file(arg: str) -> str:",
            "    if not os.path.isfile(arg):",
            "        raise argparse.ArgumentTypeError(\"not a file: %s\" % arg)",
            "    return arg",
            "",
            "",
            "def main() -> None:",
            "    rbac_only_states = [",
            "        (\"check_region\", Client.check_region),",
            "        (\"rbac\", Client.setup_rbac),",
            "        (\"arm\", Client.deploy_template),",
            "        (\"assign_scaleset_identity_role\", Client.assign_scaleset_identity_role),",
            "    ]",
            "",
            "    full_deployment_states = rbac_only_states + [",
            "        (\"apply_migrations\", Client.apply_migrations),",
            "        (\"set_instance_config\", Client.set_instance_config),",
            "        (\"queues\", Client.create_queues),",
            "        (\"eventgrid\", Client.create_eventgrid),",
            "        (\"tools\", Client.upload_tools),",
            "        (\"add_instance_id\", Client.add_instance_id),",
            "        (\"instance-specific-setup\", Client.upload_instance_setup),",
            "        (\"third-party\", Client.upload_third_party),",
            "        (\"api\", Client.deploy_app),",
            "        (\"export_appinsights\", Client.add_log_export),",
            "        (\"update_registration\", Client.update_registration),",
            "    ]",
            "",
            "    formatter = argparse.ArgumentDefaultsHelpFormatter",
            "    parser = argparse.ArgumentParser(formatter_class=formatter)",
            "    parser.add_argument(\"location\")",
            "    parser.add_argument(\"resource_group\")",
            "    parser.add_argument(\"application_name\")",
            "    parser.add_argument(\"owner\")",
            "    parser.add_argument(",
            "        \"--arm-template\",",
            "        type=arg_file,",
            "        default=\"azuredeploy.json\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--workbook-data\",",
            "        type=arg_file,",
            "        default=\"workbook-data.json\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--app-zip\",",
            "        type=arg_file,",
            "        default=\"api-service.zip\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--tools\", type=arg_dir, default=\"tools\", help=\"(default: %(default)s)\"",
            "    )",
            "    parser.add_argument(",
            "        \"--instance_specific\",",
            "        type=arg_dir,",
            "        default=\"instance-specific-setup\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--third-party\",",
            "        type=arg_dir,",
            "        default=\"third-party\",",
            "        help=\"(default: %(default)s)\",",
            "    )",
            "    parser.add_argument(\"--client_id\")",
            "    parser.add_argument(\"--client_secret\")",
            "    parser.add_argument(",
            "        \"--start_at\",",
            "        default=full_deployment_states[0][0],",
            "        choices=[x[0] for x in full_deployment_states],",
            "        help=(",
            "            \"Debug deployments by starting at a specific state.  \"",
            "            \"NOT FOR PRODUCTION USE.  (default: %(default)s)\"",
            "        ),",
            "    )",
            "    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")",
            "    parser.add_argument(",
            "        \"--create_pool_registration\",",
            "        action=\"store_true\",",
            "        help=\"Create an application registration and/or generate a \"",
            "        \"password for the pool agent\",",
            "    )",
            "    parser.add_argument(",
            "        \"--upgrade\",",
            "        action=\"store_true\",",
            "        help=\"Indicates that the instance is being upgraded\",",
            "    )",
            "    parser.add_argument(",
            "        \"--apply_migrations\",",
            "        type=str,",
            "        nargs=\"+\",",
            "        default=[],",
            "        help=\"list of migration to apply to the azure table\",",
            "    )",
            "    parser.add_argument(",
            "        \"--export_appinsights\",",
            "        action=\"store_true\",",
            "        help=\"enable appinsight log export\",",
            "    )",
            "    parser.add_argument(",
            "        \"--log_service_principal\",",
            "        action=\"store_true\",",
            "        help=\"display service prinipal with info log level\",",
            "    )",
            "    parser.add_argument(",
            "        \"--multi_tenant_domain\",",
            "        type=str,",
            "        default=None,",
            "        help=\"enable multi-tenant authentication with this tenant domain\",",
            "    )",
            "    parser.add_argument(",
            "        \"--subscription_id\",",
            "        type=str,",
            "    )",
            "    parser.add_argument(",
            "        \"--rbac_only\",",
            "        action=\"store_true\",",
            "        help=\"execute only the steps required to create the rbac resources\",",
            "    )",
            "    parser.add_argument(",
            "        \"--set_admins\",",
            "        type=UUID,",
            "        nargs=\"*\",",
            "        help=\"set the list of administrators (by OID in AAD)\",",
            "    )",
            "    parser.add_argument(",
            "        \"--allowed_aad_tenants\",",
            "        type=UUID,",
            "        nargs=\"*\",",
            "        help=\"Set additional AAD tenants beyond the tenant the app is deployed in\",",
            "    )",
            "",
            "    args = parser.parse_args()",
            "",
            "    if shutil.which(\"func\") is None:",
            "        logger.error(FUNC_TOOLS_ERROR)",
            "        sys.exit(1)",
            "",
            "    client = Client(",
            "        resource_group=args.resource_group,",
            "        location=args.location,",
            "        application_name=args.application_name,",
            "        owner=args.owner,",
            "        client_id=args.client_id,",
            "        client_secret=args.client_secret,",
            "        app_zip=args.app_zip,",
            "        tools=args.tools,",
            "        instance_specific=args.instance_specific,",
            "        third_party=args.third_party,",
            "        arm_template=args.arm_template,",
            "        workbook_data=args.workbook_data,",
            "        create_registration=args.create_pool_registration,",
            "        migrations=args.apply_migrations,",
            "        export_appinsights=args.export_appinsights,",
            "        log_service_principal=args.log_service_principal,",
            "        multi_tenant_domain=args.multi_tenant_domain,",
            "        upgrade=args.upgrade,",
            "        subscription_id=args.subscription_id,",
            "        admins=args.set_admins,",
            "        allowed_aad_tenants=args.allowed_aad_tenants or [],",
            "    )",
            "    if args.verbose:",
            "        level = logging.DEBUG",
            "    else:",
            "        level = logging.WARN",
            "",
            "    logging.basicConfig(level=level)",
            "",
            "    logging.getLogger(\"deploy\").setLevel(logging.INFO)",
            "",
            "    if args.rbac_only:",
            "        logger.warning(",
            "            \"'rbac_only' specified. The deployment will execute \"",
            "            \"only the steps required to create the rbac resources\"",
            "        )",
            "        states = rbac_only_states",
            "    else:",
            "        states = full_deployment_states",
            "",
            "    if args.start_at != states[0][0]:",
            "        logger.warning(",
            "            \"*** Starting at a non-standard deployment state.  \"",
            "            \"This may result in a broken deployment.  ***\"",
            "        )",
            "",
            "    started = False",
            "    for state in states:",
            "        if args.start_at == state[0]:",
            "            started = True",
            "        if started:",
            "            state[1](client)",
            "",
            "    client.done()",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "75": [],
            "133": [
                "Client",
                "__init__"
            ],
            "563": [
                "Client",
                "set_admins"
            ],
            "929": [
                "main"
            ]
        },
        "addLocation": []
    }
}