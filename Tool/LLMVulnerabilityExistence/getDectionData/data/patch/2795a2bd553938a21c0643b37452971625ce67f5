{
    "consoleme/lib/scm/git/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         await sync_to_async(git.Git(self.tempdir).clone)(*args, **kwargs)"
            },
            "1": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         self.repo = git.Repo(os.path.join(self.tempdir, self.repo_name))"
            },
            "2": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         self.repo.config_writer().set_value(\"user\", \"name\", \"ConsoleMe\").release()"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        self.repo.config_writer().set_value(\"core\", \"symlinks\", \"false\").release()"
            },
            "4": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         if self.git_email:"
            },
            "5": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "             self.repo.config_writer().set_value("
            },
            "6": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "                 \"user\", \"email\", self.git_email"
            }
        },
        "frontPatchFile": [
            "import os",
            "import shutil",
            "import tempfile",
            "from typing import Optional",
            "",
            "import git",
            "from asgiref.sync import sync_to_async",
            "",
            "",
            "class Repository:",
            "    def __init__(self, repo_url, repo_name, git_email):",
            "        self.tempdir = tempfile.mkdtemp()",
            "        self.repo_url = repo_url",
            "        self.git_email = git_email",
            "        self.repo = None",
            "        self.repo_name = repo_name",
            "        self.git = None",
            "",
            "    async def clone(self, no_checkout=True, depth: Optional[int] = None):",
            "        args = []",
            "        kwargs = {}",
            "        if no_checkout:",
            "            args.append(\"-n\")",
            "        args.append(self.repo_url)",
            "        if depth:",
            "            kwargs[\"depth\"] = depth",
            "        await sync_to_async(git.Git(self.tempdir).clone)(*args, **kwargs)",
            "        self.repo = git.Repo(os.path.join(self.tempdir, self.repo_name))",
            "        self.repo.config_writer().set_value(\"user\", \"name\", \"ConsoleMe\").release()",
            "        if self.git_email:",
            "            self.repo.config_writer().set_value(",
            "                \"user\", \"email\", self.git_email",
            "            ).release()",
            "        self.git = self.repo.git",
            "        return self.repo",
            "",
            "    async def cleanup(self):",
            "        await sync_to_async(shutil.rmtree)(self.tempdir)"
        ],
        "afterPatchFile": [
            "import os",
            "import shutil",
            "import tempfile",
            "from typing import Optional",
            "",
            "import git",
            "from asgiref.sync import sync_to_async",
            "",
            "",
            "class Repository:",
            "    def __init__(self, repo_url, repo_name, git_email):",
            "        self.tempdir = tempfile.mkdtemp()",
            "        self.repo_url = repo_url",
            "        self.git_email = git_email",
            "        self.repo = None",
            "        self.repo_name = repo_name",
            "        self.git = None",
            "",
            "    async def clone(self, no_checkout=True, depth: Optional[int] = None):",
            "        args = []",
            "        kwargs = {}",
            "        if no_checkout:",
            "            args.append(\"-n\")",
            "        args.append(self.repo_url)",
            "        if depth:",
            "            kwargs[\"depth\"] = depth",
            "        await sync_to_async(git.Git(self.tempdir).clone)(*args, **kwargs)",
            "        self.repo = git.Repo(os.path.join(self.tempdir, self.repo_name))",
            "        self.repo.config_writer().set_value(\"user\", \"name\", \"ConsoleMe\").release()",
            "        self.repo.config_writer().set_value(\"core\", \"symlinks\", \"false\").release()",
            "        if self.git_email:",
            "            self.repo.config_writer().set_value(",
            "                \"user\", \"email\", self.git_email",
            "            ).release()",
            "        self.git = self.repo.git",
            "        return self.repo",
            "",
            "    async def cleanup(self):",
            "        await sync_to_async(shutil.rmtree)(self.tempdir)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "consoleme.lib.scm.git.Repository.self"
        ]
    },
    "consoleme/lib/templated_resources/requests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import io"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import json"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+import os"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+import random"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+import string"
            },
            "5": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import time"
            },
            "6": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from ruamel.yaml.comments import CommentedSeq"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     repositories_for_request = {}"
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     primary_principal = None"
            },
            "10": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     t = int(time.time())"
            },
            "11": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    generated_branch_name = f\"{user}-{t}\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    suffix = \"\".join("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        random.choices(string.ascii_lowercase + string.digits, k=10)  # nosec"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    )"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    generated_branch_name = f\"{user}-{t}-{suffix}\""
            },
            "16": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     policy_name = config.get("
            },
            "17": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         \"generate_honeybee_request_from_change_model_array.policy_name\","
            },
            "18": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         \"self_service_generated\","
            },
            "19": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         main_branch_name = repositories_for_request[change.principal.repository_name]["
            },
            "20": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             \"main_branch_name\""
            },
            "21": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         ]"
            },
            "22": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        git_client.checkout("
            },
            "23": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            f\"origin/{main_branch_name}\", change.principal.resource_identifier"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        change_file_path = os.path.abspath("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            f\"{repo.working_dir}/{change.principal.resource_identifier}\""
            },
            "27": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         )"
            },
            "28": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        change_file_path = f\"{repo.working_dir}/{change.principal.resource_identifier}\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        clone_wd_path = os.path.abspath(repo.working_dir)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        if os.path.commonprefix((clone_wd_path, change_file_path)) != clone_wd_path:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+            log.exception("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                f\"User attempted to reference a file outside of the repository: {change_file_path} is not within {clone_wd_path}\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+            )"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            raise ValueError(\"Unable to raise change request for this resource\")"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        try:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            git_client.checkout("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+                f\"origin/{main_branch_name}\", \"--\", change.principal.resource_identifier"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            )"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        except Exception:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            log.exception("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+                f\"Unable to checkout {main_branch_name} for {change.principal.resource_identifier}\""
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            )"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+            raise ValueError(\"Unable to raise change request for this resource\")"
            },
            "45": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         with open(change_file_path, \"r\") as f:"
            },
            "46": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             yaml_content = yaml.load(f)"
            },
            "47": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import io",
            "import json",
            "import time",
            "",
            "from ruamel.yaml.comments import CommentedSeq",
            "",
            "from consoleme.config import config",
            "from consoleme.lib.aws import minimize_iam_policy_statements",
            "from consoleme.lib.plugins import get_plugin_by_name",
            "from consoleme.lib.scm.git import Repository",
            "from consoleme.lib.scm.git.bitbucket import BitBucket",
            "from consoleme.lib.yaml import yaml",
            "from consoleme.models import (",
            "    ChangeModelArray,",
            "    ExtendedRequestModel,",
            "    GenericFileChangeModel,",
            "    PolicyModel,",
            "    RequestCreationModel,",
            "    RequestStatus,",
            "    UserModel,",
            ")",
            "",
            "auth = get_plugin_by_name(config.get(\"plugins.auth\", \"default_auth\"))()",
            "log = config.get_logger()",
            "",
            "",
            "async def generate_honeybee_request_from_change_model_array(",
            "    request_creation: RequestCreationModel, user: str, extended_request_uuid: str",
            ") -> ExtendedRequestModel:",
            "    repositories_for_request = {}",
            "    primary_principal = None",
            "    t = int(time.time())",
            "    generated_branch_name = f\"{user}-{t}\"",
            "    policy_name = config.get(",
            "        \"generate_honeybee_request_from_change_model_array.policy_name\",",
            "        \"self_service_generated\",",
            "    )",
            "    repo_config = None",
            "",
            "    # Checkout Git Repo and generate a branch name for the user's change",
            "    for change in request_creation.changes.changes:",
            "        if primary_principal and change.principal != primary_principal:",
            "            raise Exception(\"Changes must all affect the same principal\")",
            "        primary_principal = change.principal",
            "        discovered_repository_for_change = False",
            "        if repositories_for_request.get(change.principal.repository_name):",
            "            continue",
            "        # Find repo",
            "        for r in config.get(\"cache_resource_templates.repositories\", []):",
            "            if r[\"name\"] == change.principal.repository_name:",
            "                repo_config = r",
            "                repo = Repository(",
            "                    r[\"repo_url\"], r[\"name\"], r[\"authentication_settings\"][\"email\"]",
            "                )",
            "                await repo.clone(depth=1)",
            "                git_client = repo.git",
            "                git_client.reset()",
            "                git_client.checkout(b=generated_branch_name)",
            "                repositories_for_request[change.principal.repository_name] = {",
            "                    \"main_branch_name\": r[\"main_branch_name\"],",
            "                    \"repo\": repo,",
            "                    \"git_client\": git_client,",
            "                    \"config\": r,",
            "                }",
            "                discovered_repository_for_change = True",
            "                break",
            "        if not discovered_repository_for_change:",
            "            raise Exception(",
            "                \"No matching repository found for change in ConsoleMe's configuration\"",
            "            )",
            "    request_changes = ChangeModelArray(changes=[])",
            "    affected_templates = []",
            "    for change in request_creation.changes.changes:",
            "        git_client = repositories_for_request[change.principal.repository_name][",
            "            \"git_client\"",
            "        ]",
            "        repo = repositories_for_request[change.principal.repository_name][\"repo\"].repo",
            "        main_branch_name = repositories_for_request[change.principal.repository_name][",
            "            \"main_branch_name\"",
            "        ]",
            "        git_client.checkout(",
            "            f\"origin/{main_branch_name}\", change.principal.resource_identifier",
            "        )",
            "        change_file_path = f\"{repo.working_dir}/{change.principal.resource_identifier}\"",
            "        with open(change_file_path, \"r\") as f:",
            "            yaml_content = yaml.load(f)",
            "",
            "        # Original",
            "        buf = io.BytesIO()",
            "        yaml.dump(yaml_content, buf)",
            "        original_text = buf.getvalue()",
            "        successfully_merged_statement = False",
            "        if not yaml_content.get(\"Policies\"):",
            "            yaml_content[\"Policies\"] = []",
            "        if isinstance(yaml_content[\"Policies\"], dict):",
            "            yaml_content[\"Policies\"] = [yaml_content[\"Policies\"]]",
            "",
            "        # The PolicyModel is a representation of a single (usually inline) policy that a user has requested be merged",
            "        # into a given template. If the policy is provided as a string, it's the contents of the full file (which",
            "        # should include the user's requested change)",
            "        if isinstance(change.policy, PolicyModel):",
            "            if isinstance(change.policy.policy_document[\"Statement\"], str):",
            "                change.policy.policy_document[\"Statement\"] = [",
            "                    change.policy.policy_document[\"Statement\"]",
            "                ]",
            "            for i in range(len(yaml_content.get(\"Policies\", []))):",
            "                policy = yaml_content[\"Policies\"][i]",
            "                if policy.get(\"PolicyName\") != policy_name:",
            "                    continue",
            "                if policy.get(\"IncludeAccounts\") or policy.get(\"ExcludeAccounts\"):",
            "                    raise ValueError(",
            "                        f\"The {policy_name} policy has IncludeAccounts or ExcludeAccounts set\"",
            "                    )",
            "                successfully_merged_statement = True",
            "",
            "                policy[\"Statement\"].extend(",
            "                    CommentedSeq(change.policy.policy_document[\"Statement\"])",
            "                )",
            "                yaml_content[\"Policies\"][i][",
            "                    \"Statement\"",
            "                ] = await minimize_iam_policy_statements(",
            "                    json.loads(json.dumps(policy[\"Statement\"]))",
            "                )",
            "            if not successfully_merged_statement:",
            "                yaml_content[\"Policies\"].append(",
            "                    {",
            "                        \"PolicyName\": policy_name,",
            "                        \"Statement\": change.policy.policy_document[\"Statement\"],",
            "                    }",
            "                )",
            "            with open(change_file_path, \"w\") as f:",
            "                yaml.dump(yaml_content, f)",
            "            # New",
            "            buf = io.BytesIO()",
            "            yaml.dump(yaml_content, buf)",
            "            updated_text = buf.getvalue()",
            "",
            "        elif isinstance(change.policy, str):",
            "            # If the change is provided as a string, it represents the full change",
            "            updated_text = change.policy",
            "            with open(change_file_path, \"w\") as f:",
            "                f.write(updated_text)",
            "        else:",
            "            raise Exception(",
            "                \"Unable to parse change from Honeybee templated role change request\"",
            "            )",
            "",
            "        request_changes.changes.append(",
            "            GenericFileChangeModel(",
            "                principal=primary_principal,",
            "                action=\"attach\",",
            "                change_type=\"generic_file\",",
            "                policy=updated_text,",
            "                old_policy=original_text,",
            "                encoding=\"yaml\",",
            "            )",
            "        )",
            "        git_client.add(change.principal.resource_identifier)",
            "        affected_templates.append(change.principal.resource_identifier)",
            "",
            "    pull_request_url = \"\"",
            "    if not request_creation.dry_run:",
            "        commit_title = f\"ConsoleMe Generated PR for {', '.join(affected_templates)}\"",
            "        commit_message = (",
            "            f\"This request was made through ConsoleMe Self Service\\n\\nUser: {user}\\n\\n\"",
            "            f\"Justification: {request_creation.justification}\"",
            "        )",
            "",
            "        git_client.commit(m=commit_message)",
            "        git_client.push(u=[\"origin\", generated_branch_name])",
            "        if repo_config[\"code_repository_provider\"] == \"bitbucket\":",
            "            bitbucket = BitBucket(",
            "                repo_config[\"code_repository_config\"][\"url\"],",
            "                config.get(",
            "                    repo_config[\"code_repository_config\"][\"username_config_key\"]",
            "                ),",
            "                config.get(",
            "                    repo_config[\"code_repository_config\"][\"password_config_key\"]",
            "                ),",
            "            )",
            "            pull_request_url = await bitbucket.create_pull_request(",
            "                repo_config[\"project_key\"],",
            "                repo_config[\"name\"],",
            "                repo_config[\"project_key\"],",
            "                repo_config[\"name\"],",
            "                generated_branch_name,",
            "                repo_config[\"main_branch_name\"],",
            "                commit_title,",
            "                commit_message,",
            "            )",
            "        else:",
            "            raise Exception(",
            "                f\"Unsupported `code_repository_provider` specified in configuration: {repo_config}\"",
            "            )",
            "",
            "    for repo_name, repo_details in repositories_for_request.items():",
            "        await repo_details[\"repo\"].cleanup()",
            "",
            "    if not pull_request_url and not request_creation.dry_run:",
            "        raise Exception(\"Unable to generate pull request URL\")",
            "",
            "    return ExtendedRequestModel(",
            "        id=extended_request_uuid,",
            "        request_url=pull_request_url,",
            "        principal=primary_principal,",
            "        timestamp=int(time.time()),",
            "        requester_email=user,",
            "        approvers=[],",
            "        request_status=RequestStatus.pending,",
            "        changes=request_changes,",
            "        requester_info=UserModel(",
            "            email=user,",
            "            extended_info=await auth.get_user_info(user),",
            "            details_url=config.config_plugin().get_employee_info_url(user),",
            "            photo_url=config.config_plugin().get_employee_photo_url(user),",
            "        ),",
            "        comments=[],",
            "        cross_account=False,",
            "    )"
        ],
        "afterPatchFile": [
            "import io",
            "import json",
            "import os",
            "import random",
            "import string",
            "import time",
            "",
            "from ruamel.yaml.comments import CommentedSeq",
            "",
            "from consoleme.config import config",
            "from consoleme.lib.aws import minimize_iam_policy_statements",
            "from consoleme.lib.plugins import get_plugin_by_name",
            "from consoleme.lib.scm.git import Repository",
            "from consoleme.lib.scm.git.bitbucket import BitBucket",
            "from consoleme.lib.yaml import yaml",
            "from consoleme.models import (",
            "    ChangeModelArray,",
            "    ExtendedRequestModel,",
            "    GenericFileChangeModel,",
            "    PolicyModel,",
            "    RequestCreationModel,",
            "    RequestStatus,",
            "    UserModel,",
            ")",
            "",
            "auth = get_plugin_by_name(config.get(\"plugins.auth\", \"default_auth\"))()",
            "log = config.get_logger()",
            "",
            "",
            "async def generate_honeybee_request_from_change_model_array(",
            "    request_creation: RequestCreationModel, user: str, extended_request_uuid: str",
            ") -> ExtendedRequestModel:",
            "    repositories_for_request = {}",
            "    primary_principal = None",
            "    t = int(time.time())",
            "    suffix = \"\".join(",
            "        random.choices(string.ascii_lowercase + string.digits, k=10)  # nosec",
            "    )",
            "    generated_branch_name = f\"{user}-{t}-{suffix}\"",
            "    policy_name = config.get(",
            "        \"generate_honeybee_request_from_change_model_array.policy_name\",",
            "        \"self_service_generated\",",
            "    )",
            "    repo_config = None",
            "",
            "    # Checkout Git Repo and generate a branch name for the user's change",
            "    for change in request_creation.changes.changes:",
            "        if primary_principal and change.principal != primary_principal:",
            "            raise Exception(\"Changes must all affect the same principal\")",
            "        primary_principal = change.principal",
            "        discovered_repository_for_change = False",
            "        if repositories_for_request.get(change.principal.repository_name):",
            "            continue",
            "        # Find repo",
            "        for r in config.get(\"cache_resource_templates.repositories\", []):",
            "            if r[\"name\"] == change.principal.repository_name:",
            "                repo_config = r",
            "                repo = Repository(",
            "                    r[\"repo_url\"], r[\"name\"], r[\"authentication_settings\"][\"email\"]",
            "                )",
            "                await repo.clone(depth=1)",
            "                git_client = repo.git",
            "                git_client.reset()",
            "                git_client.checkout(b=generated_branch_name)",
            "                repositories_for_request[change.principal.repository_name] = {",
            "                    \"main_branch_name\": r[\"main_branch_name\"],",
            "                    \"repo\": repo,",
            "                    \"git_client\": git_client,",
            "                    \"config\": r,",
            "                }",
            "                discovered_repository_for_change = True",
            "                break",
            "        if not discovered_repository_for_change:",
            "            raise Exception(",
            "                \"No matching repository found for change in ConsoleMe's configuration\"",
            "            )",
            "    request_changes = ChangeModelArray(changes=[])",
            "    affected_templates = []",
            "    for change in request_creation.changes.changes:",
            "        git_client = repositories_for_request[change.principal.repository_name][",
            "            \"git_client\"",
            "        ]",
            "        repo = repositories_for_request[change.principal.repository_name][\"repo\"].repo",
            "        main_branch_name = repositories_for_request[change.principal.repository_name][",
            "            \"main_branch_name\"",
            "        ]",
            "",
            "        change_file_path = os.path.abspath(",
            "            f\"{repo.working_dir}/{change.principal.resource_identifier}\"",
            "        )",
            "        clone_wd_path = os.path.abspath(repo.working_dir)",
            "        if os.path.commonprefix((clone_wd_path, change_file_path)) != clone_wd_path:",
            "            log.exception(",
            "                f\"User attempted to reference a file outside of the repository: {change_file_path} is not within {clone_wd_path}\"",
            "            )",
            "            raise ValueError(\"Unable to raise change request for this resource\")",
            "",
            "        try:",
            "            git_client.checkout(",
            "                f\"origin/{main_branch_name}\", \"--\", change.principal.resource_identifier",
            "            )",
            "        except Exception:",
            "            log.exception(",
            "                f\"Unable to checkout {main_branch_name} for {change.principal.resource_identifier}\"",
            "            )",
            "            raise ValueError(\"Unable to raise change request for this resource\")",
            "        with open(change_file_path, \"r\") as f:",
            "            yaml_content = yaml.load(f)",
            "",
            "        # Original",
            "        buf = io.BytesIO()",
            "        yaml.dump(yaml_content, buf)",
            "        original_text = buf.getvalue()",
            "        successfully_merged_statement = False",
            "        if not yaml_content.get(\"Policies\"):",
            "            yaml_content[\"Policies\"] = []",
            "        if isinstance(yaml_content[\"Policies\"], dict):",
            "            yaml_content[\"Policies\"] = [yaml_content[\"Policies\"]]",
            "",
            "        # The PolicyModel is a representation of a single (usually inline) policy that a user has requested be merged",
            "        # into a given template. If the policy is provided as a string, it's the contents of the full file (which",
            "        # should include the user's requested change)",
            "        if isinstance(change.policy, PolicyModel):",
            "            if isinstance(change.policy.policy_document[\"Statement\"], str):",
            "                change.policy.policy_document[\"Statement\"] = [",
            "                    change.policy.policy_document[\"Statement\"]",
            "                ]",
            "            for i in range(len(yaml_content.get(\"Policies\", []))):",
            "                policy = yaml_content[\"Policies\"][i]",
            "                if policy.get(\"PolicyName\") != policy_name:",
            "                    continue",
            "                if policy.get(\"IncludeAccounts\") or policy.get(\"ExcludeAccounts\"):",
            "                    raise ValueError(",
            "                        f\"The {policy_name} policy has IncludeAccounts or ExcludeAccounts set\"",
            "                    )",
            "                successfully_merged_statement = True",
            "",
            "                policy[\"Statement\"].extend(",
            "                    CommentedSeq(change.policy.policy_document[\"Statement\"])",
            "                )",
            "                yaml_content[\"Policies\"][i][",
            "                    \"Statement\"",
            "                ] = await minimize_iam_policy_statements(",
            "                    json.loads(json.dumps(policy[\"Statement\"]))",
            "                )",
            "            if not successfully_merged_statement:",
            "                yaml_content[\"Policies\"].append(",
            "                    {",
            "                        \"PolicyName\": policy_name,",
            "                        \"Statement\": change.policy.policy_document[\"Statement\"],",
            "                    }",
            "                )",
            "            with open(change_file_path, \"w\") as f:",
            "                yaml.dump(yaml_content, f)",
            "            # New",
            "            buf = io.BytesIO()",
            "            yaml.dump(yaml_content, buf)",
            "            updated_text = buf.getvalue()",
            "",
            "        elif isinstance(change.policy, str):",
            "            # If the change is provided as a string, it represents the full change",
            "            updated_text = change.policy",
            "            with open(change_file_path, \"w\") as f:",
            "                f.write(updated_text)",
            "        else:",
            "            raise Exception(",
            "                \"Unable to parse change from Honeybee templated role change request\"",
            "            )",
            "",
            "        request_changes.changes.append(",
            "            GenericFileChangeModel(",
            "                principal=primary_principal,",
            "                action=\"attach\",",
            "                change_type=\"generic_file\",",
            "                policy=updated_text,",
            "                old_policy=original_text,",
            "                encoding=\"yaml\",",
            "            )",
            "        )",
            "        git_client.add(change.principal.resource_identifier)",
            "        affected_templates.append(change.principal.resource_identifier)",
            "",
            "    pull_request_url = \"\"",
            "    if not request_creation.dry_run:",
            "        commit_title = f\"ConsoleMe Generated PR for {', '.join(affected_templates)}\"",
            "        commit_message = (",
            "            f\"This request was made through ConsoleMe Self Service\\n\\nUser: {user}\\n\\n\"",
            "            f\"Justification: {request_creation.justification}\"",
            "        )",
            "",
            "        git_client.commit(m=commit_message)",
            "        git_client.push(u=[\"origin\", generated_branch_name])",
            "        if repo_config[\"code_repository_provider\"] == \"bitbucket\":",
            "            bitbucket = BitBucket(",
            "                repo_config[\"code_repository_config\"][\"url\"],",
            "                config.get(",
            "                    repo_config[\"code_repository_config\"][\"username_config_key\"]",
            "                ),",
            "                config.get(",
            "                    repo_config[\"code_repository_config\"][\"password_config_key\"]",
            "                ),",
            "            )",
            "            pull_request_url = await bitbucket.create_pull_request(",
            "                repo_config[\"project_key\"],",
            "                repo_config[\"name\"],",
            "                repo_config[\"project_key\"],",
            "                repo_config[\"name\"],",
            "                generated_branch_name,",
            "                repo_config[\"main_branch_name\"],",
            "                commit_title,",
            "                commit_message,",
            "            )",
            "        else:",
            "            raise Exception(",
            "                f\"Unsupported `code_repository_provider` specified in configuration: {repo_config}\"",
            "            )",
            "",
            "    for repo_name, repo_details in repositories_for_request.items():",
            "        await repo_details[\"repo\"].cleanup()",
            "",
            "    if not pull_request_url and not request_creation.dry_run:",
            "        raise Exception(\"Unable to generate pull request URL\")",
            "",
            "    return ExtendedRequestModel(",
            "        id=extended_request_uuid,",
            "        request_url=pull_request_url,",
            "        principal=primary_principal,",
            "        timestamp=int(time.time()),",
            "        requester_email=user,",
            "        approvers=[],",
            "        request_status=RequestStatus.pending,",
            "        changes=request_changes,",
            "        requester_info=UserModel(",
            "            email=user,",
            "            extended_info=await auth.get_user_info(user),",
            "            details_url=config.config_plugin().get_employee_info_url(user),",
            "            photo_url=config.config_plugin().get_employee_photo_url(user),",
            "        ),",
            "        comments=[],",
            "        cross_account=False,",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "33": [
                "generated_branch_name"
            ],
            "81": [],
            "82": [],
            "84": [
                "change_file_path"
            ]
        },
        "addLocation": []
    }
}