{
    "examples/check_cpe.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " rep = NmapParser.parse_fromfile(\"libnmap/test/files/full_sudo6.xml\")"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-print(\"Nmap scan discovered {0}/{1} hosts up\".format(rep.hosts_up,"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                     rep.hosts_total))"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+print("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+    \"Nmap scan discovered {0}/{1} hosts up\".format("
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+        rep.hosts_up, rep.hosts_total"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+    )"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+)"
            },
            "10": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " for _host in rep.hosts:"
            },
            "11": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     if _host.is_up():"
            },
            "12": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        print(\"+ Host: {0} {1}\".format(_host.address,"
            },
            "13": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                       \" \".join(_host.hostnames)))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+        print("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+            \"+ Host: {0} {1}\".format(_host.address, \" \".join(_host.hostnames))"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+        )"
            },
            "17": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "         # get CPE from service if available"
            },
            "19": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "         for s in _host.services:"
            },
            "20": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            print(\"    Service: {0}/{1} ({2})\".format(s.port,"
            },
            "21": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                      s.protocol,"
            },
            "22": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                      s.state))"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+            print("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+                \"    Service: {0}/{1} ({2})\".format("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+                    s.port, s.protocol, s.state"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+                )"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+            )"
            },
            "28": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "             # NmapService.cpelist returns an array of CPE objects"
            },
            "29": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "             for _serv_cpe in s.cpelist:"
            },
            "30": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "                 print(\"        CPE: {0}\".format(_serv_cpe.cpestring))"
            },
            "31": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         if _host.os_fingerprinted:"
            },
            "33": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "             print(\"  OS Fingerprints\")"
            },
            "34": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "             for osm in _host.os.osmatches:"
            },
            "35": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                print(\"    Found Match:{0} ({1}%)\".format(osm.name,"
            },
            "36": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                          osm.accuracy))"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+                print("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+                    \"    Found Match:{0} ({1}%)\".format(osm.name, osm.accuracy)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+                )"
            },
            "40": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "                 # NmapOSMatch.get_cpe() method return an array of string"
            },
            "41": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "                 # unlike NmapOSClass.cpelist which returns an array of CPE obj"
            },
            "42": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "                 for cpe in osm.get_cpe():"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.parser import NmapParser",
            "",
            "rep = NmapParser.parse_fromfile(\"libnmap/test/files/full_sudo6.xml\")",
            "",
            "print(\"Nmap scan discovered {0}/{1} hosts up\".format(rep.hosts_up,",
            "                                                     rep.hosts_total))",
            "for _host in rep.hosts:",
            "    if _host.is_up():",
            "        print(\"+ Host: {0} {1}\".format(_host.address,",
            "                                       \" \".join(_host.hostnames)))",
            "",
            "        # get CPE from service if available",
            "        for s in _host.services:",
            "            print(\"    Service: {0}/{1} ({2})\".format(s.port,",
            "                                                      s.protocol,",
            "                                                      s.state))",
            "            # NmapService.cpelist returns an array of CPE objects",
            "            for _serv_cpe in s.cpelist:",
            "                print(\"        CPE: {0}\".format(_serv_cpe.cpestring))",
            "",
            "        if _host.os_fingerprinted:",
            "            print(\"  OS Fingerprints\")",
            "            for osm in _host.os.osmatches:",
            "                print(\"    Found Match:{0} ({1}%)\".format(osm.name,",
            "                                                          osm.accuracy))",
            "                # NmapOSMatch.get_cpe() method return an array of string",
            "                # unlike NmapOSClass.cpelist which returns an array of CPE obj",
            "                for cpe in osm.get_cpe():",
            "                    print(\"\\t    CPE: {0}\".format(cpe))"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.parser import NmapParser",
            "",
            "rep = NmapParser.parse_fromfile(\"libnmap/test/files/full_sudo6.xml\")",
            "",
            "print(",
            "    \"Nmap scan discovered {0}/{1} hosts up\".format(",
            "        rep.hosts_up, rep.hosts_total",
            "    )",
            ")",
            "for _host in rep.hosts:",
            "    if _host.is_up():",
            "        print(",
            "            \"+ Host: {0} {1}\".format(_host.address, \" \".join(_host.hostnames))",
            "        )",
            "",
            "        # get CPE from service if available",
            "        for s in _host.services:",
            "            print(",
            "                \"    Service: {0}/{1} ({2})\".format(",
            "                    s.port, s.protocol, s.state",
            "                )",
            "            )",
            "            # NmapService.cpelist returns an array of CPE objects",
            "            for _serv_cpe in s.cpelist:",
            "                print(\"        CPE: {0}\".format(_serv_cpe.cpestring))",
            "",
            "        if _host.os_fingerprinted:",
            "            print(\"  OS Fingerprints\")",
            "            for osm in _host.os.osmatches:",
            "                print(",
            "                    \"    Found Match:{0} ({1}%)\".format(osm.name, osm.accuracy)",
            "                )",
            "                # NmapOSMatch.get_cpe() method return an array of string",
            "                # unlike NmapOSClass.cpelist which returns an array of CPE obj",
            "                for cpe in osm.get_cpe():",
            "                    print(\"\\t    CPE: {0}\".format(cpe))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": [],
            "9": [],
            "12": [],
            "13": [],
            "17": [],
            "18": [],
            "19": [],
            "27": [],
            "28": []
        },
        "addLocation": []
    },
    "examples/diff_sample2.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " def main():"
            },
            "3": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    newrep = NmapParser.parse_fromfile(\"libnmap/test/files/2_hosts_achange.xml\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+    newrep = NmapParser.parse_fromfile("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        \"libnmap/test/files/2_hosts_achange.xml\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    )"
            },
            "7": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     oldrep = NmapParser.parse_fromfile(\"libnmap/test/files/1_hosts.xml\")"
            },
            "8": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     print_diff(newrep, oldrep)"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.parser import NmapParser",
            "",
            "",
            "def nested_obj(objname):",
            "    rval = None",
            "    splitted = objname.split(\"::\")",
            "    if len(splitted) == 2:",
            "        rval = splitted",
            "    return rval",
            "",
            "",
            "def print_diff_added(obj1, obj2, added):",
            "    for akey in added:",
            "        nested = nested_obj(akey)",
            "        if nested is not None:",
            "            if nested[0] == \"NmapHost\":",
            "                subobj1 = obj1.get_host_byid(nested[1])",
            "            elif nested[0] == \"NmapService\":",
            "                subobj1 = obj1.get_service_byid(nested[1])",
            "            print(\"+ {0}\".format(subobj1))",
            "        else:",
            "            print(\"+ {0} {1}: {2}\".format(obj1, akey, getattr(obj1, akey)))",
            "",
            "",
            "def print_diff_removed(obj1, obj2, removed):",
            "    for rkey in removed:",
            "        nested = nested_obj(rkey)",
            "        if nested is not None:",
            "            if nested[0] == \"NmapHost\":",
            "                subobj2 = obj2.get_host_byid(nested[1])",
            "            elif nested[0] == \"NmapService\":",
            "                subobj2 = obj2.get_service_byid(nested[1])",
            "            print(\"- {0}\".format(subobj2))",
            "        else:",
            "            print(\"- {0} {1}: {2}\".format(obj2, rkey, getattr(obj2, rkey)))",
            "",
            "",
            "def print_diff_changed(obj1, obj2, changes):",
            "    for mkey in changes:",
            "        nested = nested_obj(mkey)",
            "        if nested is not None:",
            "            if nested[0] == \"NmapHost\":",
            "                subobj1 = obj1.get_host_byid(nested[1])",
            "                subobj2 = obj2.get_host_byid(nested[1])",
            "            elif nested[0] == \"NmapService\":",
            "                subobj1 = obj1.get_service_byid(nested[1])",
            "                subobj2 = obj2.get_service_byid(nested[1])",
            "            print_diff(subobj1, subobj2)",
            "        else:",
            "            print(",
            "                \"~ {0} {1}: {2} => {3}\".format(",
            "                    obj1, mkey, getattr(obj2, mkey), getattr(obj1, mkey)",
            "                )",
            "            )",
            "",
            "",
            "def print_diff(obj1, obj2):",
            "    ndiff = obj1.diff(obj2)",
            "",
            "    print_diff_changed(obj1, obj2, ndiff.changed())",
            "    print_diff_added(obj1, obj2, ndiff.added())",
            "    print_diff_removed(obj1, obj2, ndiff.removed())",
            "",
            "",
            "def main():",
            "    newrep = NmapParser.parse_fromfile(\"libnmap/test/files/2_hosts_achange.xml\")",
            "    oldrep = NmapParser.parse_fromfile(\"libnmap/test/files/1_hosts.xml\")",
            "",
            "    print_diff(newrep, oldrep)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.parser import NmapParser",
            "",
            "",
            "def nested_obj(objname):",
            "    rval = None",
            "    splitted = objname.split(\"::\")",
            "    if len(splitted) == 2:",
            "        rval = splitted",
            "    return rval",
            "",
            "",
            "def print_diff_added(obj1, obj2, added):",
            "    for akey in added:",
            "        nested = nested_obj(akey)",
            "        if nested is not None:",
            "            if nested[0] == \"NmapHost\":",
            "                subobj1 = obj1.get_host_byid(nested[1])",
            "            elif nested[0] == \"NmapService\":",
            "                subobj1 = obj1.get_service_byid(nested[1])",
            "            print(\"+ {0}\".format(subobj1))",
            "        else:",
            "            print(\"+ {0} {1}: {2}\".format(obj1, akey, getattr(obj1, akey)))",
            "",
            "",
            "def print_diff_removed(obj1, obj2, removed):",
            "    for rkey in removed:",
            "        nested = nested_obj(rkey)",
            "        if nested is not None:",
            "            if nested[0] == \"NmapHost\":",
            "                subobj2 = obj2.get_host_byid(nested[1])",
            "            elif nested[0] == \"NmapService\":",
            "                subobj2 = obj2.get_service_byid(nested[1])",
            "            print(\"- {0}\".format(subobj2))",
            "        else:",
            "            print(\"- {0} {1}: {2}\".format(obj2, rkey, getattr(obj2, rkey)))",
            "",
            "",
            "def print_diff_changed(obj1, obj2, changes):",
            "    for mkey in changes:",
            "        nested = nested_obj(mkey)",
            "        if nested is not None:",
            "            if nested[0] == \"NmapHost\":",
            "                subobj1 = obj1.get_host_byid(nested[1])",
            "                subobj2 = obj2.get_host_byid(nested[1])",
            "            elif nested[0] == \"NmapService\":",
            "                subobj1 = obj1.get_service_byid(nested[1])",
            "                subobj2 = obj2.get_service_byid(nested[1])",
            "            print_diff(subobj1, subobj2)",
            "        else:",
            "            print(",
            "                \"~ {0} {1}: {2} => {3}\".format(",
            "                    obj1, mkey, getattr(obj2, mkey), getattr(obj1, mkey)",
            "                )",
            "            )",
            "",
            "",
            "def print_diff(obj1, obj2):",
            "    ndiff = obj1.diff(obj2)",
            "",
            "    print_diff_changed(obj1, obj2, ndiff.changed())",
            "    print_diff_added(obj1, obj2, ndiff.added())",
            "    print_diff_removed(obj1, obj2, ndiff.removed())",
            "",
            "",
            "def main():",
            "    newrep = NmapParser.parse_fromfile(",
            "        \"libnmap/test/files/2_hosts_achange.xml\"",
            "    )",
            "    oldrep = NmapParser.parse_fromfile(\"libnmap/test/files/1_hosts.xml\")",
            "",
            "    print_diff(newrep, oldrep)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "69": [
                "main"
            ]
        },
        "addLocation": []
    },
    "examples/elastikibana.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         cpelist = nmap_host.os.os_cpelist()"
            },
            "1": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         if len(cpelist):"
            },
            "2": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             mcpe = cpelist.pop()"
            },
            "3": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            rval.update({"
            },
            "4": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"vendor\": mcpe.get_vendor(),"
            },
            "5": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"product\": mcpe.get_product()"
            },
            "6": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            })"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+            rval.update("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+                {\"vendor\": mcpe.get_vendor(), \"product\": mcpe.get_product()}"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+            )"
            },
            "10": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     return rval"
            },
            "11": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.parser import NmapParser",
            "from elasticsearch import Elasticsearch",
            "from datetime import datetime",
            "import pygeoip",
            "",
            "",
            "def store_report(nmap_report, database, index):",
            "    rval = True",
            "    for nmap_host in nmap_report.hosts:",
            "        rv = store_reportitem(nmap_host, database, index)",
            "        if rv is False:",
            "            print(",
            "                \"Failed to store host {0} in \"",
            "                \"elasticsearch\".format(nmap_host.address)",
            "            )",
            "            rval = False",
            "",
            "    return rval",
            "",
            "",
            "def get_os(nmap_host):",
            "    rval = {\"vendor\": \"unknown\", \"product\": \"unknown\"}",
            "    if nmap_host.is_up() and nmap_host.os_fingerprinted:",
            "        cpelist = nmap_host.os.os_cpelist()",
            "        if len(cpelist):",
            "            mcpe = cpelist.pop()",
            "            rval.update({",
            "                    \"vendor\": mcpe.get_vendor(),",
            "                    \"product\": mcpe.get_product()",
            "            })",
            "    return rval",
            "",
            "",
            "def get_geoip_code(address):",
            "    gi = pygeoip.GeoIP(\"/usr/share/GeoIP/GeoIP.dat\")",
            "    return gi.country_code_by_addr(address)",
            "",
            "",
            "def store_reportitem(nmap_host, database, index):",
            "    host_keys = [",
            "        \"starttime\",",
            "        \"endtime\",",
            "        \"address\",",
            "        \"hostnames\",",
            "        \"ipv4\",",
            "        \"ipv6\",",
            "        \"mac\",",
            "        \"status\",",
            "    ]",
            "    jhost = {}",
            "    for hkey in host_keys:",
            "        if hkey == \"starttime\" or hkey == \"endtime\":",
            "            val = getattr(nmap_host, hkey)",
            "            jhost[hkey] = datetime.fromtimestamp(int(val) if len(val) else 0)",
            "        else:",
            "            jhost[hkey] = getattr(nmap_host, hkey)",
            "",
            "    jhost.update({\"country\": get_geoip_code(nmap_host.address)})",
            "    jhost.update(get_os(nmap_host))",
            "    for nmap_service in nmap_host.services:",
            "        reportitems = get_item(nmap_service)",
            "",
            "        for ritem in reportitems:",
            "            ritem.update(jhost)",
            "            database.index(index=index, doc_type=\"NmapItem\", body=ritem)",
            "    return jhost",
            "",
            "",
            "def get_item(nmap_service):",
            "    service_keys = [\"port\", \"protocol\", \"state\"]",
            "    ritems = []",
            "",
            "    # create report item for basic port scan",
            "    jservice = {}",
            "    for skey in service_keys:",
            "        jservice[skey] = getattr(nmap_service, skey)",
            "    jservice[\"type\"] = \"port-scan\"",
            "    jservice[\"service\"] = nmap_service.service",
            "    jservice[\"service-data\"] = nmap_service.banner",
            "    ritems.append(jservice)",
            "",
            "    # create report items from nse script output",
            "    for nse_item in nmap_service.scripts_results:",
            "        jnse = {}",
            "        for skey in service_keys:",
            "            jnse[skey] = getattr(nmap_service, skey)",
            "        jnse[\"type\"] = \"nse-script\"",
            "        jnse[\"service\"] = nse_item[\"id\"]",
            "        jnse[\"service-data\"] = nse_item[\"output\"]",
            "        ritems.append(jnse)",
            "",
            "    return ritems",
            "",
            "",
            "xmlscans = [",
            "    \"../libnmap/test/files/1_hosts.xml\",",
            "    \"../libnmap/test/files/full_sudo6.xml\",",
            "    \"/vagrant/nmap_switches.xml\",",
            "    \"/vagrant/nmap-5hosts.xml\",",
            "]",
            "",
            "for xmlscan in xmlscans:",
            "    nmap_report = NmapParser.parse_fromfile(xmlscan)",
            "",
            "    if nmap_report:",
            "        rep_date = datetime.fromtimestamp(int(nmap_report.started))",
            "        index = \"nmap-{0}\".format(rep_date.strftime(\"%Y-%m-%d\"))",
            "        db = Elasticsearch()",
            "        j = store_report(nmap_report, db, index)"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.parser import NmapParser",
            "from elasticsearch import Elasticsearch",
            "from datetime import datetime",
            "import pygeoip",
            "",
            "",
            "def store_report(nmap_report, database, index):",
            "    rval = True",
            "    for nmap_host in nmap_report.hosts:",
            "        rv = store_reportitem(nmap_host, database, index)",
            "        if rv is False:",
            "            print(",
            "                \"Failed to store host {0} in \"",
            "                \"elasticsearch\".format(nmap_host.address)",
            "            )",
            "            rval = False",
            "",
            "    return rval",
            "",
            "",
            "def get_os(nmap_host):",
            "    rval = {\"vendor\": \"unknown\", \"product\": \"unknown\"}",
            "    if nmap_host.is_up() and nmap_host.os_fingerprinted:",
            "        cpelist = nmap_host.os.os_cpelist()",
            "        if len(cpelist):",
            "            mcpe = cpelist.pop()",
            "            rval.update(",
            "                {\"vendor\": mcpe.get_vendor(), \"product\": mcpe.get_product()}",
            "            )",
            "    return rval",
            "",
            "",
            "def get_geoip_code(address):",
            "    gi = pygeoip.GeoIP(\"/usr/share/GeoIP/GeoIP.dat\")",
            "    return gi.country_code_by_addr(address)",
            "",
            "",
            "def store_reportitem(nmap_host, database, index):",
            "    host_keys = [",
            "        \"starttime\",",
            "        \"endtime\",",
            "        \"address\",",
            "        \"hostnames\",",
            "        \"ipv4\",",
            "        \"ipv6\",",
            "        \"mac\",",
            "        \"status\",",
            "    ]",
            "    jhost = {}",
            "    for hkey in host_keys:",
            "        if hkey == \"starttime\" or hkey == \"endtime\":",
            "            val = getattr(nmap_host, hkey)",
            "            jhost[hkey] = datetime.fromtimestamp(int(val) if len(val) else 0)",
            "        else:",
            "            jhost[hkey] = getattr(nmap_host, hkey)",
            "",
            "    jhost.update({\"country\": get_geoip_code(nmap_host.address)})",
            "    jhost.update(get_os(nmap_host))",
            "    for nmap_service in nmap_host.services:",
            "        reportitems = get_item(nmap_service)",
            "",
            "        for ritem in reportitems:",
            "            ritem.update(jhost)",
            "            database.index(index=index, doc_type=\"NmapItem\", body=ritem)",
            "    return jhost",
            "",
            "",
            "def get_item(nmap_service):",
            "    service_keys = [\"port\", \"protocol\", \"state\"]",
            "    ritems = []",
            "",
            "    # create report item for basic port scan",
            "    jservice = {}",
            "    for skey in service_keys:",
            "        jservice[skey] = getattr(nmap_service, skey)",
            "    jservice[\"type\"] = \"port-scan\"",
            "    jservice[\"service\"] = nmap_service.service",
            "    jservice[\"service-data\"] = nmap_service.banner",
            "    ritems.append(jservice)",
            "",
            "    # create report items from nse script output",
            "    for nse_item in nmap_service.scripts_results:",
            "        jnse = {}",
            "        for skey in service_keys:",
            "            jnse[skey] = getattr(nmap_service, skey)",
            "        jnse[\"type\"] = \"nse-script\"",
            "        jnse[\"service\"] = nse_item[\"id\"]",
            "        jnse[\"service-data\"] = nse_item[\"output\"]",
            "        ritems.append(jnse)",
            "",
            "    return ritems",
            "",
            "",
            "xmlscans = [",
            "    \"../libnmap/test/files/1_hosts.xml\",",
            "    \"../libnmap/test/files/full_sudo6.xml\",",
            "    \"/vagrant/nmap_switches.xml\",",
            "    \"/vagrant/nmap-5hosts.xml\",",
            "]",
            "",
            "for xmlscan in xmlscans:",
            "    nmap_report = NmapParser.parse_fromfile(xmlscan)",
            "",
            "    if nmap_report:",
            "        rep_date = datetime.fromtimestamp(int(nmap_report.started))",
            "        index = \"nmap-{0}\".format(rep_date.strftime(\"%Y-%m-%d\"))",
            "        db = Elasticsearch()",
            "        j = store_report(nmap_report, db, index)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "30": [
                "get_os"
            ],
            "31": [
                "get_os"
            ],
            "32": [
                "get_os"
            ],
            "33": [
                "get_os"
            ]
        },
        "addLocation": []
    },
    "examples/nmap_task.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "     if nmaptask:"
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "         print("
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "             \"Task {0} ({1}): ETC: {2} DONE: {3}%\".format("
            },
            "3": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nmaptask.name,"
            },
            "4": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nmaptask.status,"
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nmaptask.etc,"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nmaptask.progress"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+                nmaptask.name, nmaptask.status, nmaptask.etc, nmaptask.progress"
            },
            "8": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "             )"
            },
            "9": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "         )"
            },
            "10": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.process import NmapProcess",
            "",
            "",
            "def mycallback(nmaptask):",
            "    nmaptask = nmap_proc.current_task",
            "    if nmaptask:",
            "        print(",
            "            \"Task {0} ({1}): ETC: {2} DONE: {3}%\".format(",
            "                nmaptask.name,",
            "                nmaptask.status,",
            "                nmaptask.etc,",
            "                nmaptask.progress",
            "            )",
            "        )",
            "",
            "",
            "nmap_proc = NmapProcess(",
            "    targets=\"scanme.nmap.org\", options=\"-sV\", event_callback=mycallback",
            ")",
            "nmap_proc.run()",
            "print(nmap_proc.stdout)",
            "print(nmap_proc.stderr)"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.process import NmapProcess",
            "",
            "",
            "def mycallback(nmaptask):",
            "    nmaptask = nmap_proc.current_task",
            "    if nmaptask:",
            "        print(",
            "            \"Task {0} ({1}): ETC: {2} DONE: {3}%\".format(",
            "                nmaptask.name, nmaptask.status, nmaptask.etc, nmaptask.progress",
            "            )",
            "        )",
            "",
            "",
            "nmap_proc = NmapProcess(",
            "    targets=\"scanme.nmap.org\", options=\"-sV\", event_callback=mycallback",
            ")",
            "nmap_proc.run()",
            "print(nmap_proc.stdout)",
            "print(nmap_proc.stderr)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "12": [
                "mycallback"
            ],
            "13": [
                "mycallback"
            ],
            "14": [
                "mycallback"
            ],
            "15": [
                "mycallback"
            ]
        },
        "addLocation": []
    },
    "examples/nmap_task_bg.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     if nmaptask:"
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "         print("
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "             \"Task {0} ({1}): ETC: {2} DONE: {3}%\".format("
            },
            "3": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nmaptask.name,"
            },
            "4": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nmaptask.status,"
            },
            "5": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nmaptask.etc,"
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                nmaptask.progress"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+                nmaptask.name, nmaptask.status, nmaptask.etc, nmaptask.progress"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "             )"
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "         )"
            },
            "10": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " print(\"rc: {0} output: {1}\".format(nmap_proc.rc, nmap_proc.summary))"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.process import NmapProcess",
            "",
            "nmap_proc = NmapProcess(targets=\"scanme.nmap.org\", options=\"-sV\")",
            "nmap_proc.run_background()",
            "while nmap_proc.is_running():",
            "    nmaptask = nmap_proc.current_task",
            "    if nmaptask:",
            "        print(",
            "            \"Task {0} ({1}): ETC: {2} DONE: {3}%\".format(",
            "                nmaptask.name,",
            "                nmaptask.status,",
            "                nmaptask.etc,",
            "                nmaptask.progress",
            "            )",
            "        )",
            "print(\"rc: {0} output: {1}\".format(nmap_proc.rc, nmap_proc.summary))",
            "print(nmap_proc.stdout)",
            "print(nmap_proc.stderr)"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "from libnmap.process import NmapProcess",
            "",
            "nmap_proc = NmapProcess(targets=\"scanme.nmap.org\", options=\"-sV\")",
            "nmap_proc.run_background()",
            "while nmap_proc.is_running():",
            "    nmaptask = nmap_proc.current_task",
            "    if nmaptask:",
            "        print(",
            "            \"Task {0} ({1}): ETC: {2} DONE: {3}%\".format(",
            "                nmaptask.name, nmaptask.status, nmaptask.etc, nmaptask.progress",
            "            )",
            "        )",
            "print(\"rc: {0} output: {1}\".format(nmap_proc.rc, nmap_proc.summary))",
            "print(nmap_proc.stdout)",
            "print(nmap_proc.stderr)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [],
            "14": [],
            "15": [],
            "16": []
        },
        "addLocation": []
    },
    "libnmap/parser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " try:"
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    import xml.etree.cElementTree as ET"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+    import defusedxml.ElementTree as ET"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " except ImportError:"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    import xml.etree.ElementTree as ET"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+    try:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+        import xml.etree.cElementTree as ET"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+    except ImportError:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+        import xml.etree.ElementTree as ET"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from xml.etree.ElementTree import iselement as et_iselement"
            },
            "12": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from libnmap.objects import NmapHost, NmapService, NmapReport"
            },
            "13": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 701,
                "afterPatchRowNumber": 705,
                "PatchRowcode": "                     \"to instanciate XML Element from \""
            },
            "16": {
                "beforePatchRowNumber": 702,
                "afterPatchRowNumber": 706,
                "PatchRowcode": "                     \"string {0} - {1}\".format(elt_data, e)"
            },
            "17": {
                "beforePatchRowNumber": 703,
                "afterPatchRowNumber": 707,
                "PatchRowcode": "                 )"
            },
            "18": {
                "beforePatchRowNumber": 704,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif ET.iselement(elt_data):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 708,
                "PatchRowcode": "+        elif et_iselement(elt_data):"
            },
            "20": {
                "beforePatchRowNumber": 705,
                "afterPatchRowNumber": 709,
                "PatchRowcode": "             xelement = elt_data"
            },
            "21": {
                "beforePatchRowNumber": 706,
                "afterPatchRowNumber": 710,
                "PatchRowcode": "         else:"
            },
            "22": {
                "beforePatchRowNumber": 707,
                "afterPatchRowNumber": 711,
                "PatchRowcode": "             raise NmapParserException("
            },
            "23": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": 728,
                "PatchRowcode": "         \"\"\""
            },
            "24": {
                "beforePatchRowNumber": 725,
                "afterPatchRowNumber": 729,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": 730,
                "PatchRowcode": "         rval = {}"
            },
            "26": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not ET.iselement(elt_data):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 731,
                "PatchRowcode": "+        if not et_iselement(elt_data):"
            },
            "28": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 732,
                "PatchRowcode": "             raise NmapParserException("
            },
            "29": {
                "beforePatchRowNumber": 729,
                "afterPatchRowNumber": 733,
                "PatchRowcode": "                 \"Error while trying to parse supplied \""
            },
            "30": {
                "beforePatchRowNumber": 730,
                "afterPatchRowNumber": 734,
                "PatchRowcode": "                 \"data attributes: format is not XML or \""
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "",
            "try:",
            "    import xml.etree.cElementTree as ET",
            "except ImportError:",
            "    import xml.etree.ElementTree as ET",
            "from libnmap.objects import NmapHost, NmapService, NmapReport",
            "",
            "",
            "class NmapParser(object):",
            "    @classmethod",
            "    def parse(cls, nmap_data=None, data_type=\"XML\", incomplete=False):",
            "        \"\"\"",
            "            Generic class method of NmapParser class.",
            "",
            "            The data to be parsed does not need to be a complete nmap",
            "            scan report. You can possibly give <hosts>...</hosts>",
            "            or <port> XML tags.",
            "",
            "            :param nmap_data: any portion of nmap scan result. \\",
            "            nmap_data should always be a string representing a part \\",
            "            or a complete nmap scan report.",
            "            :type nmap_data: string",
            "",
            "            :param data_type: specifies the type of data to be parsed.",
            "            :type data_type: string (\"XML\"|\"JSON\"|\"YAML\").",
            "",
            "            :param incomplete: enable you to parse interrupted nmap scans \\",
            "            and/or incomplete nmap xml blocks by adding a </nmaprun> at \\",
            "            the end of the scan.",
            "            :type incomplete: boolean",
            "",
            "            As of today, only XML parsing is supported.",
            "",
            "            :return: NmapObject (NmapHost, NmapService or NmapReport)",
            "        \"\"\"",
            "",
            "        nmapobj = None",
            "        if data_type == \"XML\":",
            "            nmapobj = cls._parse_xml(nmap_data, incomplete)",
            "        else:",
            "            raise NmapParserException(",
            "                \"Unknown data type provided. \"",
            "                \"Please check documentation for \"",
            "                \"supported data types.\"",
            "            )",
            "        return nmapobj",
            "",
            "    @classmethod",
            "    def _parse_xml(cls, nmap_data=None, incomplete=False):",
            "        \"\"\"",
            "            Protected class method used to process a specific data type.",
            "            In this case: XML. This method is called by cls.parse class",
            "            method and receives nmap scan results data (in XML).",
            "",
            "            :param nmap_data: any portion of nmap scan result can be given \\",
            "            as argument. nmap_data should always be a string representing \\",
            "            a part or a complete nmap scan report.",
            "            :type nmap_data: string",
            "",
            "            This method checks which portion of a nmap scan is given \\",
            "            as argument.",
            "            It could be:",
            "",
            "                1. a full nmap scan report;",
            "                2. a scanned host: <host> tag in a nmap scan report",
            "                3. a scanned service: <port> tag",
            "                4. a list of hosts: <hosts/> tag (TODO)",
            "                5. a list of ports: <ports/> tag",
            "",
            "            :param incomplete: enable you to parse interrupted nmap scans \\",
            "            and/or incomplete nmap xml blocks by adding a </nmaprun> at \\",
            "            the end of the scan.",
            "            :type incomplete: boolean",
            "",
            "            :return: NmapObject (NmapHost, NmapService or NmapReport) \\",
            "                    or a list of NmapObject",
            "        \"\"\"",
            "",
            "        if not nmap_data:",
            "            raise NmapParserException(",
            "                \"No report data to parse: please \"",
            "                \"provide a valid XML nmap report\"",
            "            )",
            "        elif not isinstance(nmap_data, str):",
            "            raise NmapParserException(",
            "                \"wrong nmap_data type given as \"",
            "                \"argument: cannot parse data\"",
            "            )",
            "",
            "        if incomplete is True:",
            "            nmap_data += \"</nmaprun>\"",
            "",
            "        try:",
            "            root = ET.fromstring(nmap_data)",
            "        except Exception as e:",
            "            emsg = \"Wrong XML structure: cannot parse data: {0}\".format(e)",
            "            raise NmapParserException(emsg)",
            "",
            "        nmapobj = None",
            "        if root.tag == \"nmaprun\":",
            "            nmapobj = cls._parse_xml_report(root)",
            "        elif root.tag == \"host\":",
            "            nmapobj = cls._parse_xml_host(root)",
            "        elif root.tag == \"ports\":",
            "            nmapobj = cls._parse_xml_ports(root)",
            "        elif root.tag == \"port\":",
            "            nmapobj = cls._parse_xml_port(root)",
            "        else:",
            "            raise NmapParserException(\"Unpexpected data structure for XML \"",
            "                                      \"root node\")",
            "        return nmapobj",
            "",
            "    @classmethod",
            "    def _parse_xml_report(cls, root=None):",
            "        \"\"\"",
            "            This method parses out a full nmap scan report from its XML root",
            "            node: <nmaprun>.",
            "",
            "            :param root: Element from xml.ElementTree (top of XML the document)",
            "            :type root: Element",
            "",
            "            :return: NmapReport object",
            "        \"\"\"",
            "",
            "        nmap_scan = {",
            "            \"_nmaprun\": {},",
            "            \"_scaninfo\": {},",
            "            \"_hosts\": [],",
            "            \"_runstats\": {}",
            "        }",
            "",
            "        if root is None:",
            "            raise NmapParserException(\"No root node provided to parse XML \"",
            "                                      \"report\")",
            "",
            "        nmap_scan[\"_nmaprun\"] = cls.__format_attributes(root)",
            "        for el in root:",
            "            if el.tag == \"scaninfo\":",
            "                nmap_scan[\"_scaninfo\"] = cls.__parse_scaninfo(el)",
            "            elif el.tag == \"host\":",
            "                nmap_scan[\"_hosts\"].append(cls._parse_xml_host(el))",
            "            elif el.tag == \"runstats\":",
            "                nmap_scan[\"_runstats\"] = cls.__parse_runstats(el)",
            "            # else:",
            "            #    print \"struct pparse unknown attr: {0} value: {1}\".format(",
            "            #        el.tag,",
            "            #        el.get(el.tag))",
            "        return NmapReport(nmap_scan)",
            "",
            "    @classmethod",
            "    def parse_fromstring(cls, nmap_data, data_type=\"XML\", incomplete=False):",
            "        \"\"\"",
            "            Call generic cls.parse() method and ensure that a string is \\",
            "            passed on as argument. If not, an exception is raised.",
            "",
            "            :param nmap_data: Same as for parse(), any portion of nmap scan. \\",
            "            Reports could be passed as argument. Data type _must_ be a string.",
            "",
            "            :type nmap_data: string",
            "",
            "            :param data_type: Specifies the type of data passed on as argument.",
            "",
            "            :param incomplete: enable you to parse interrupted nmap scans \\",
            "            and/or incomplete nmap xml blocks by adding a </nmaprun> at \\",
            "            the end of the scan.",
            "            :type incomplete: boolean",
            "",
            "            :return: NmapObject",
            "        \"\"\"",
            "",
            "        if not isinstance(nmap_data, str):",
            "            raise NmapParserException(",
            "                \"bad argument type for \"",
            "                \"xarse_fromstring(): should be a string\"",
            "            )",
            "        return cls.parse(nmap_data, data_type, incomplete)",
            "",
            "    @classmethod",
            "    def parse_fromfile(",
            "        cls, nmap_report_path,",
            "        data_type=\"XML\",",
            "        incomplete=False",
            "    ):",
            "        \"\"\"",
            "            Call generic cls.parse() method and ensure that a correct file \\",
            "            path is given as argument. If not, an exception is raised.",
            "",
            "            :param nmap_data: Same as for parse(). \\",
            "            Any portion of nmap scan reports could be passed as argument. \\",
            "            Data type _must be a valid path to a file containing \\",
            "            nmap scan results.",
            "",
            "            :param data_type: Specifies the type of serialization in the file.",
            "",
            "            :param incomplete: enable you to parse interrupted nmap scans \\",
            "            and/or incomplete nmap xml blocks by adding a </nmaprun> at \\",
            "            the end of the scan.",
            "            :type incomplete: boolean",
            "",
            "            :return: NmapObject",
            "        \"\"\"",
            "",
            "        try:",
            "            with open(nmap_report_path, \"r\") as fileobj:",
            "                fdata = fileobj.read()",
            "                rval = cls.parse(fdata, data_type, incomplete)",
            "        except IOError:",
            "            raise",
            "        return rval",
            "",
            "    @classmethod",
            "    def parse_fromdict(cls, rdict):",
            "        \"\"\"",
            "            Strange method which transforms a python dict \\",
            "            representation of a NmapReport and turns it into an \\",
            "            NmapReport object. \\",
            "            Needs to be reviewed and possibly removed.",
            "",
            "            :param rdict: python dict representation of an NmapReport",
            "            :type rdict: dict",
            "",
            "            :return: NmapReport",
            "        \"\"\"",
            "",
            "        nreport = {}",
            "        if list(rdict.keys())[0] == \"__NmapReport__\":",
            "            r = rdict[\"__NmapReport__\"]",
            "            nreport[\"_runstats\"] = r[\"_runstats\"]",
            "            nreport[\"_scaninfo\"] = r[\"_scaninfo\"]",
            "            nreport[\"_nmaprun\"] = r[\"_nmaprun\"]",
            "            hlist = []",
            "            for h in r[\"_hosts\"]:",
            "                slist = []",
            "                for s in h[\"__NmapHost__\"][\"_services\"]:",
            "                    cname = \"__NmapService__\"",
            "                    slist.append(",
            "                        NmapService(",
            "                            portid=s[cname][\"_portid\"],",
            "                            protocol=s[cname][\"_protocol\"],",
            "                            state=s[cname][\"_state\"],",
            "                            owner=s[cname][\"_owner\"],",
            "                            service=s[cname][\"_service\"],",
            "                        )",
            "                    )",
            "",
            "                nh = NmapHost(",
            "                    starttime=h[\"__NmapHost__\"][\"_starttime\"],",
            "                    endtime=h[\"__NmapHost__\"][\"_endtime\"],",
            "                    address=h[\"__NmapHost__\"][\"_address\"],",
            "                    status=h[\"__NmapHost__\"][\"_status\"],",
            "                    hostnames=h[\"__NmapHost__\"][\"_hostnames\"],",
            "                    extras=h[\"__NmapHost__\"][\"_extras\"],",
            "                    services=slist,",
            "                )",
            "                hlist.append(nh)",
            "            nreport[\"_hosts\"] = hlist",
            "            nmapobj = NmapReport(nreport)",
            "        return nmapobj",
            "",
            "    @classmethod",
            "    def __parse_scaninfo(cls, scaninfo_data):",
            "        \"\"\"",
            "            Private method parsing a portion of a nmap scan result.",
            "            Receives a <scaninfo> XML tag.",
            "",
            "            :param scaninfo_data: <scaninfo> XML tag from a nmap scan",
            "            :type scaninfo_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML scaninfo tag",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scaninfo_data)",
            "        return cls.__format_attributes(xelement)",
            "",
            "    @classmethod",
            "    def _parse_xml_host(cls, scanhost_data):",
            "        \"\"\"",
            "            Protected method parsing a portion of a nmap scan result.",
            "            Receives a <host> XML tag representing a scanned host with",
            "            its services.",
            "",
            "            :param scaninfo_data: <host> XML tag from a nmap scan",
            "            :type scaninfo_data: xml.ElementTree.Element or a string",
            "",
            "            :return: NmapHost object",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanhost_data)",
            "        _host_header = cls.__format_attributes(xelement)",
            "        _hostnames = []",
            "        _services = []",
            "        _status = {}",
            "        _addresses = []",
            "        _host_extras = {}",
            "        extra_tags = [",
            "            \"uptime\",",
            "            \"distance\",",
            "            \"tcpsequence\",",
            "            \"ipidsequence\",",
            "            \"tcptssequence\",",
            "            \"times\",",
            "        ]",
            "        for xh in xelement:",
            "            if xh.tag == \"hostnames\":",
            "                for hostname in cls.__parse_hostnames(xh):",
            "                    _hostnames.append(hostname)",
            "            elif xh.tag == \"ports\":",
            "                ports_dict = cls._parse_xml_ports(xh)",
            "                for port in ports_dict[\"ports\"]:",
            "                    _services.append(port)",
            "                _host_extras[\"extraports\"] = ports_dict[\"extraports\"]",
            "            elif xh.tag == \"status\":",
            "                _status = cls.__format_attributes(xh)",
            "            elif xh.tag == \"address\":",
            "                _addresses.append(cls.__format_attributes(xh))",
            "            elif xh.tag == \"os\":",
            "                _os_extra = cls.__parse_os_fingerprint(xh)",
            "                _host_extras.update({\"os\": _os_extra})",
            "            elif xh.tag == \"hostscript\":",
            "                _host_scripts = cls.__parse_host_scripts(xh)",
            "                _host_extras.update({\"hostscript\": _host_scripts})",
            "            elif xh.tag in extra_tags:",
            "                _host_extras[xh.tag] = cls.__format_attributes(xh)",
            "            # else:",
            "            #    print \"struct host unknown attr: %s value: %s\" %",
            "            #           (h.tag, h.get(h.tag))",
            "        _stime = \"\"",
            "        _etime = \"\"",
            "        if \"starttime\" in _host_header:",
            "            _stime = _host_header[\"starttime\"]",
            "        if \"endtime\" in _host_header:",
            "            _etime = _host_header[\"endtime\"]",
            "        nhost = NmapHost(",
            "            _stime,",
            "            _etime,",
            "            _addresses,",
            "            _status,",
            "            _hostnames,",
            "            _services,",
            "            _host_extras",
            "        )",
            "        return nhost",
            "",
            "    @classmethod",
            "    def __parse_hostnames(cls, scanhostnames_data):",
            "        \"\"\"",
            "            Private method parsing the hostnames list within a <host> XML tag.",
            "",
            "            :param scanhostnames_data: <hostnames> XML tag from a nmap scan",
            "            :type scanhostnames_data: xml.ElementTree.Element or a string",
            "",
            "            :return: list of hostnames",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanhostnames_data)",
            "        hostnames = []",
            "        for hname in xelement:",
            "            if hname.tag == \"hostname\":",
            "                hostnames.append(hname.get(\"name\"))",
            "        return hostnames",
            "",
            "    @classmethod",
            "    def _parse_xml_ports(cls, scanports_data):",
            "        \"\"\"",
            "            Protected method parsing the list of scanned services from",
            "            a targeted host. This protected method cannot be called directly",
            "            with a string. A <ports/> tag can be directly passed to parse()",
            "            and the below method will be called and return a list of nmap",
            "            scanned services.",
            "",
            "            :param scanports_data: <ports> XML tag from a nmap scan",
            "            :type scanports_data: xml.ElementTree.Element or a string",
            "",
            "            :return: list of NmapService",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanports_data)",
            "",
            "        rdict = {\"ports\": [], \"extraports\": None}",
            "        for xservice in xelement:",
            "            if xservice.tag == \"port\":",
            "                nport = cls._parse_xml_port(xservice)",
            "                rdict[\"ports\"].append(nport)",
            "            elif xservice.tag == \"extraports\":",
            "                extraports = cls.__parse_extraports(xservice)",
            "                rdict[\"extraports\"] = extraports",
            "            # else:",
            "            #    print \"struct port unknown attr: %s value: %s\" %",
            "            #           (h.tag, h.get(h.tag))",
            "        return rdict",
            "",
            "    @classmethod",
            "    def _parse_xml_port(cls, scanport_data):",
            "        \"\"\"",
            "            Protected method parsing a scanned service from a targeted host.",
            "            This protected method cannot be called directly.",
            "            A <port/> tag can be directly passed to parse() and the below",
            "            method will be called and return a NmapService object",
            "            representing the state of the service.",
            "",
            "            :param scanport_data: <port> XML tag from a nmap scan",
            "            :type scanport_data: xml.ElementTree.Element or a string",
            "",
            "            :return: NmapService",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanport_data)",
            "",
            "        _port = cls.__format_attributes(xelement)",
            "        _portid = _port[\"portid\"] if \"portid\" in _port else None",
            "        _protocol = _port[\"protocol\"] if \"protocol\" in _port else None",
            "",
            "        _state = None",
            "        _service = None",
            "        _owner = None",
            "        _service_scripts = []",
            "        _service_extras = {}",
            "        for xport in xelement:",
            "            if xport.tag == \"state\":",
            "                _state = cls.__format_attributes(xport)",
            "            elif xport.tag == \"service\":",
            "                _service = cls.__parse_service(xport)",
            "            elif xport.tag == \"owner\":",
            "                _owner = cls.__format_attributes(xport)",
            "            elif xport.tag == \"script\":",
            "                _script_dict = cls.__parse_script(xport)",
            "                _service_scripts.append(_script_dict)",
            "        _service_extras[\"scripts\"] = _service_scripts",
            "",
            "        if _portid is None or _protocol is None or _state is None:",
            "            raise NmapParserException(",
            "                \"XML <port> tag is incomplete. One \"",
            "                \"of the following tags is missing: \"",
            "                \"portid, protocol or state or tag.\"",
            "            )",
            "",
            "        nport = NmapService(",
            "            _portid, _protocol, _state, _service, _owner, _service_extras",
            "        )",
            "        return nport",
            "",
            "    @classmethod",
            "    def __parse_service(cls, xserv):",
            "        \"\"\"",
            "            Parse <service> tag to manage CPE object",
            "        \"\"\"",
            "        _service = cls.__format_attributes(xserv)",
            "        _cpelist = []",
            "        for _servnode in xserv:",
            "            if _servnode.tag == \"cpe\":",
            "                _cpe_string = _servnode.text",
            "                _cpelist.append(_cpe_string)",
            "        _service[\"cpelist\"] = _cpelist",
            "        return _service",
            "",
            "    @classmethod",
            "    def __parse_extraports(cls, extraports_data):",
            "        \"\"\"",
            "            Private method parsing the data from extra scanned ports.",
            "            X extraports were in state \"closed\" server returned \"conn-refused\"",
            "            tag: <extraports>",
            "",
            "            :param extraports_data: XML data for extraports",
            "            :type extraports_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict with following keys: state, count, reason",
            "        \"\"\"",
            "        rdict = {\"state\": \"\", \"count\": \"\", \"reasons\": []}",
            "        xelement = cls.__format_element(extraports_data)",
            "        extraports_dict = cls.__format_attributes(xelement)",
            "",
            "        if \"state\" in extraports_dict:",
            "            rdict[\"state\"] = extraports_dict",
            "        if \"count\" in extraports_dict:",
            "            rdict[\"count\"] = extraports_dict",
            "        for xelt in xelement:",
            "            if xelt.tag == \"extrareasons\":",
            "                extrareasons_dict = cls.__format_attributes(xelt)",
            "                rdict[\"reasons\"].append(extrareasons_dict)",
            "        return rdict",
            "",
            "    @classmethod",
            "    def __parse_script_table(cls, script_table):",
            "        \"\"\"",
            "           Private method parsing a table from NSE scripts output",
            "",
            "           :param sccript_table: poertion of XML containing the table",
            "           :type script_table: xml.ElementTree.Element",
            "",
            "           :return: python dict of table structure",
            "        \"\"\"",
            "        tdict = {}",
            "        for telem in script_table:",
            "            tkey = telem.get(\"key\")",
            "            if telem.tag == \"elem\":",
            "                if tkey in tdict:",
            "                    if not isinstance(tdict[tkey], list):",
            "                        tdict[tkey] = [tdict[tkey]]",
            "                    tdict[tkey].append(telem.text)",
            "                else:",
            "                    tdict[tkey] = telem.text",
            "            elif telem.tag == \"table\":",
            "                stdict = cls.__parse_script_table(telem)",
            "",
            "                # Handle duplicate table keys",
            "                if tkey in tdict:",
            "                    if not isinstance(tdict[tkey], list):",
            "                        tdict[tkey] = [tdict[tkey]]",
            "                    tdict[tkey].append(stdict)",
            "                else:",
            "                    tdict[tkey] = stdict",
            "        return tdict",
            "",
            "    @classmethod",
            "    def __parse_script(cls, script_data):",
            "        \"\"\"",
            "            Private method parsing the data from NSE scripts output",
            "",
            "            :param script_data: portion of XML describing the results of the",
            "            script data",
            "            :type script_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict holding scripts output",
            "        \"\"\"",
            "        _script_dict = cls.__format_attributes(script_data)",
            "",
            "        _elt_dict = {}",
            "        for script_elem in script_data:",
            "            if script_elem.tag == \"elem\":",
            "                _elt_dict.update({script_elem.get(\"key\"): script_elem.text})",
            "            elif script_elem.tag == \"table\":",
            "                tdict = cls.__parse_script_table(script_elem)",
            "                # Handle duplicate table keys",
            "                skey = script_elem.get(\"key\")",
            "                if skey in _elt_dict:",
            "                    if not isinstance(_elt_dict[skey], list):",
            "                        _elt_dict[skey] = [_elt_dict[skey]]",
            "                    _elt_dict[skey].append(tdict)",
            "                else:",
            "                    _elt_dict[skey] = tdict",
            "        _script_dict[\"elements\"] = _elt_dict",
            "        return _script_dict",
            "",
            "    @classmethod",
            "    def __parse_host_scripts(cls, scripts_data):",
            "        \"\"\"",
            "            Private method parsing the data from scripts affecting",
            "            the target host.",
            "            Contents of <hostscript> is returned as a list of dict.",
            "",
            "            :param scripts_data: portion of XML describing the results of the",
            "            scripts data",
            "            :type scripts_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python list holding scripts output in a dict",
            "        \"\"\"",
            "        _host_scripts = []",
            "        for xscript in scripts_data:",
            "            if xscript.tag == \"script\":",
            "                _script_dict = cls.__parse_script(xscript)",
            "            _host_scripts.append(_script_dict)",
            "        return _host_scripts",
            "",
            "    @classmethod",
            "    def __parse_os_fingerprint(cls, os_data):",
            "        \"\"\"",
            "            Private method parsing the data from an OS fingerprint (-O).",
            "            Contents of <os> is returned as a dict.",
            "",
            "            :param os_data: portion of XML describing the results of the",
            "            os fingerprinting attempt",
            "            :type os_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML os tag",
            "        \"\"\"",
            "        rdict = {}",
            "        xelement = cls.__format_element(os_data)",
            "",
            "        os_class_probability = []",
            "        os_match_probability = []",
            "        os_ports_used = []",
            "        os_fingerprints = []",
            "        for xos in xelement:",
            "            # for nmap xml version < 1.04, osclass is not",
            "            # embedded in osmatch",
            "            if xos.tag == \"osclass\":",
            "                os_class_proba = cls.__parse_osclass(xos)",
            "                os_class_probability.append(os_class_proba)",
            "            elif xos.tag == \"osmatch\":",
            "                os_match_proba = cls.__parse_osmatch(xos)",
            "                os_match_probability.append(os_match_proba)",
            "            elif xos.tag == \"portused\":",
            "                os_portused = cls.__format_attributes(xos)",
            "                os_ports_used.append(os_portused)",
            "            elif xos.tag == \"osfingerprint\":",
            "                os_fp_dict = cls.__format_attributes(xos)",
            "                os_fingerprints.append(os_fp_dict)",
            "",
            "        rdict[\"osmatches\"] = os_match_probability",
            "        rdict[\"osclasses\"] = os_class_probability",
            "        rdict[\"ports_used\"] = os_ports_used",
            "        rdict[\"osfingerprints\"] = os_fingerprints",
            "",
            "        return rdict",
            "",
            "    @classmethod",
            "    def __parse_osmatch(cls, osmatch_data):",
            "        \"\"\"",
            "            This methods parses osmatch data and returns a dict. Depending",
            "            on the nmap xml version, osmatch could contain an osclass",
            "            dict.",
            "",
            "            :param osmatch_data: <osmatch> XML tag from a nmap scan",
            "            :type osmatch_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML osmatch tag",
            "        \"\"\"",
            "        rdict = {}",
            "        xelement = cls.__format_element(osmatch_data)",
            "        rdict[\"osmatch\"] = cls.__format_attributes(xelement)",
            "        rdict[\"osclasses\"] = []",
            "        for xmltag in xelement:",
            "            if xmltag.tag == \"osclass\":",
            "                _osclass_dict = cls.__parse_osclass(xmltag)",
            "                rdict[\"osclasses\"].append(_osclass_dict)",
            "            else:",
            "                exmsg = \"Unexcepted node in <osmatch>: {0}\".format(xmltag.tag)",
            "                raise NmapParserException(exmsg)",
            "        return rdict",
            "",
            "    @classmethod",
            "    def __parse_osclass(cls, osclass_data):",
            "        \"\"\"",
            "            This methods parses osclass data and returns a dict. Depending",
            "            on the nmap xml version, osclass could contain a cpe",
            "            dict.",
            "",
            "            :param osclass_data: <osclass> XML tag from a nmap scan",
            "            :type osclass_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML osclass tag",
            "        \"\"\"",
            "        rdict = {}",
            "        xelement = cls.__format_element(osclass_data)",
            "        rdict[\"osclass\"] = cls.__format_attributes(xelement)",
            "        rdict[\"cpe\"] = []",
            "        for xmltag in xelement:",
            "            if xmltag.tag == \"cpe\":",
            "                _cpe_string = xmltag.text",
            "                rdict[\"cpe\"].append(_cpe_string)",
            "            else:",
            "                exmsg = \"Unexcepted node in <osclass>: {0}\".format(xmltag.tag)",
            "                raise NmapParserException(exmsg)",
            "        return rdict",
            "",
            "    @classmethod",
            "    def __parse_runstats(cls, scanrunstats_data):",
            "        \"\"\"",
            "            Private method parsing a portion of a nmap scan result.",
            "            Receives a <runstats> XML tag.",
            "",
            "            :param scanrunstats_data: <runstats> XML tag from a nmap scan",
            "            :type scanrunstats_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML runstats tag",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanrunstats_data)",
            "",
            "        rdict = {}",
            "        for xmltag in xelement:",
            "            if xmltag.tag in [\"finished\", \"hosts\"]:",
            "                rdict[xmltag.tag] = cls.__format_attributes(xmltag)",
            "            else:",
            "                exmsg = \"Unexcepted node in <runstats>: {0}\".format(xmltag.tag)",
            "                raise NmapParserException(exmsg)",
            "",
            "        return rdict",
            "",
            "    @staticmethod",
            "    def __format_element(elt_data):",
            "        \"\"\"",
            "            Private method which ensures that a XML portion to be parsed is",
            "            of type xml.etree.ElementTree.Element.",
            "            If elt_data is a string, then it is converted to an",
            "            XML Element type.",
            "",
            "            :param elt_data: XML Element to be parsed or string",
            "            to be converted to a XML Element",
            "",
            "            :return: Element",
            "        \"\"\"",
            "        if isinstance(elt_data, str):",
            "            try:",
            "                xelement = ET.fromstring(elt_data)",
            "            except Exception as e:",
            "                raise NmapParserException(",
            "                    \"Error while trying \"",
            "                    \"to instanciate XML Element from \"",
            "                    \"string {0} - {1}\".format(elt_data, e)",
            "                )",
            "        elif ET.iselement(elt_data):",
            "            xelement = elt_data",
            "        else:",
            "            raise NmapParserException(",
            "                \"Error while trying to parse supplied \"",
            "                \"data: unsupported format\"",
            "            )",
            "        return xelement",
            "",
            "    @staticmethod",
            "    def __format_attributes(elt_data):",
            "        \"\"\"",
            "            Private method which converts a single XML tag to a python dict.",
            "            It also checks that the elt_data given as argument is of type",
            "            xml.etree.ElementTree.Element",
            "",
            "            :param elt_data: XML Element to be parsed or string",
            "            to be converted to a XML Element",
            "",
            "            :return: Element",
            "        \"\"\"",
            "",
            "        rval = {}",
            "        if not ET.iselement(elt_data):",
            "            raise NmapParserException(",
            "                \"Error while trying to parse supplied \"",
            "                \"data attributes: format is not XML or \"",
            "                \"XML tag is empty\"",
            "            )",
            "        try:",
            "            for dkey in elt_data.keys():",
            "                rval[dkey] = elt_data.get(dkey)",
            "                if rval[dkey] is None:",
            "                    raise NmapParserException(",
            "                        \"Error while trying to build-up \"",
            "                        \"element attributes: empty \"",
            "                        \"attribute {0}\".format(dkey)",
            "                    )",
            "        except Exception:",
            "            raise",
            "        return rval",
            "",
            "",
            "class NmapParserException(Exception):",
            "    def __init__(self, msg):",
            "        self.msg = msg",
            "",
            "    def __str__(self):",
            "        return self.msg"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "",
            "try:",
            "    import defusedxml.ElementTree as ET",
            "except ImportError:",
            "    try:",
            "        import xml.etree.cElementTree as ET",
            "    except ImportError:",
            "        import xml.etree.ElementTree as ET",
            "from xml.etree.ElementTree import iselement as et_iselement",
            "from libnmap.objects import NmapHost, NmapService, NmapReport",
            "",
            "",
            "class NmapParser(object):",
            "    @classmethod",
            "    def parse(cls, nmap_data=None, data_type=\"XML\", incomplete=False):",
            "        \"\"\"",
            "            Generic class method of NmapParser class.",
            "",
            "            The data to be parsed does not need to be a complete nmap",
            "            scan report. You can possibly give <hosts>...</hosts>",
            "            or <port> XML tags.",
            "",
            "            :param nmap_data: any portion of nmap scan result. \\",
            "            nmap_data should always be a string representing a part \\",
            "            or a complete nmap scan report.",
            "            :type nmap_data: string",
            "",
            "            :param data_type: specifies the type of data to be parsed.",
            "            :type data_type: string (\"XML\"|\"JSON\"|\"YAML\").",
            "",
            "            :param incomplete: enable you to parse interrupted nmap scans \\",
            "            and/or incomplete nmap xml blocks by adding a </nmaprun> at \\",
            "            the end of the scan.",
            "            :type incomplete: boolean",
            "",
            "            As of today, only XML parsing is supported.",
            "",
            "            :return: NmapObject (NmapHost, NmapService or NmapReport)",
            "        \"\"\"",
            "",
            "        nmapobj = None",
            "        if data_type == \"XML\":",
            "            nmapobj = cls._parse_xml(nmap_data, incomplete)",
            "        else:",
            "            raise NmapParserException(",
            "                \"Unknown data type provided. \"",
            "                \"Please check documentation for \"",
            "                \"supported data types.\"",
            "            )",
            "        return nmapobj",
            "",
            "    @classmethod",
            "    def _parse_xml(cls, nmap_data=None, incomplete=False):",
            "        \"\"\"",
            "            Protected class method used to process a specific data type.",
            "            In this case: XML. This method is called by cls.parse class",
            "            method and receives nmap scan results data (in XML).",
            "",
            "            :param nmap_data: any portion of nmap scan result can be given \\",
            "            as argument. nmap_data should always be a string representing \\",
            "            a part or a complete nmap scan report.",
            "            :type nmap_data: string",
            "",
            "            This method checks which portion of a nmap scan is given \\",
            "            as argument.",
            "            It could be:",
            "",
            "                1. a full nmap scan report;",
            "                2. a scanned host: <host> tag in a nmap scan report",
            "                3. a scanned service: <port> tag",
            "                4. a list of hosts: <hosts/> tag (TODO)",
            "                5. a list of ports: <ports/> tag",
            "",
            "            :param incomplete: enable you to parse interrupted nmap scans \\",
            "            and/or incomplete nmap xml blocks by adding a </nmaprun> at \\",
            "            the end of the scan.",
            "            :type incomplete: boolean",
            "",
            "            :return: NmapObject (NmapHost, NmapService or NmapReport) \\",
            "                    or a list of NmapObject",
            "        \"\"\"",
            "",
            "        if not nmap_data:",
            "            raise NmapParserException(",
            "                \"No report data to parse: please \"",
            "                \"provide a valid XML nmap report\"",
            "            )",
            "        elif not isinstance(nmap_data, str):",
            "            raise NmapParserException(",
            "                \"wrong nmap_data type given as \"",
            "                \"argument: cannot parse data\"",
            "            )",
            "",
            "        if incomplete is True:",
            "            nmap_data += \"</nmaprun>\"",
            "",
            "        try:",
            "            root = ET.fromstring(nmap_data)",
            "        except Exception as e:",
            "            emsg = \"Wrong XML structure: cannot parse data: {0}\".format(e)",
            "            raise NmapParserException(emsg)",
            "",
            "        nmapobj = None",
            "        if root.tag == \"nmaprun\":",
            "            nmapobj = cls._parse_xml_report(root)",
            "        elif root.tag == \"host\":",
            "            nmapobj = cls._parse_xml_host(root)",
            "        elif root.tag == \"ports\":",
            "            nmapobj = cls._parse_xml_ports(root)",
            "        elif root.tag == \"port\":",
            "            nmapobj = cls._parse_xml_port(root)",
            "        else:",
            "            raise NmapParserException(\"Unpexpected data structure for XML \"",
            "                                      \"root node\")",
            "        return nmapobj",
            "",
            "    @classmethod",
            "    def _parse_xml_report(cls, root=None):",
            "        \"\"\"",
            "            This method parses out a full nmap scan report from its XML root",
            "            node: <nmaprun>.",
            "",
            "            :param root: Element from xml.ElementTree (top of XML the document)",
            "            :type root: Element",
            "",
            "            :return: NmapReport object",
            "        \"\"\"",
            "",
            "        nmap_scan = {",
            "            \"_nmaprun\": {},",
            "            \"_scaninfo\": {},",
            "            \"_hosts\": [],",
            "            \"_runstats\": {}",
            "        }",
            "",
            "        if root is None:",
            "            raise NmapParserException(\"No root node provided to parse XML \"",
            "                                      \"report\")",
            "",
            "        nmap_scan[\"_nmaprun\"] = cls.__format_attributes(root)",
            "        for el in root:",
            "            if el.tag == \"scaninfo\":",
            "                nmap_scan[\"_scaninfo\"] = cls.__parse_scaninfo(el)",
            "            elif el.tag == \"host\":",
            "                nmap_scan[\"_hosts\"].append(cls._parse_xml_host(el))",
            "            elif el.tag == \"runstats\":",
            "                nmap_scan[\"_runstats\"] = cls.__parse_runstats(el)",
            "            # else:",
            "            #    print \"struct pparse unknown attr: {0} value: {1}\".format(",
            "            #        el.tag,",
            "            #        el.get(el.tag))",
            "        return NmapReport(nmap_scan)",
            "",
            "    @classmethod",
            "    def parse_fromstring(cls, nmap_data, data_type=\"XML\", incomplete=False):",
            "        \"\"\"",
            "            Call generic cls.parse() method and ensure that a string is \\",
            "            passed on as argument. If not, an exception is raised.",
            "",
            "            :param nmap_data: Same as for parse(), any portion of nmap scan. \\",
            "            Reports could be passed as argument. Data type _must_ be a string.",
            "",
            "            :type nmap_data: string",
            "",
            "            :param data_type: Specifies the type of data passed on as argument.",
            "",
            "            :param incomplete: enable you to parse interrupted nmap scans \\",
            "            and/or incomplete nmap xml blocks by adding a </nmaprun> at \\",
            "            the end of the scan.",
            "            :type incomplete: boolean",
            "",
            "            :return: NmapObject",
            "        \"\"\"",
            "",
            "        if not isinstance(nmap_data, str):",
            "            raise NmapParserException(",
            "                \"bad argument type for \"",
            "                \"xarse_fromstring(): should be a string\"",
            "            )",
            "        return cls.parse(nmap_data, data_type, incomplete)",
            "",
            "    @classmethod",
            "    def parse_fromfile(",
            "        cls, nmap_report_path,",
            "        data_type=\"XML\",",
            "        incomplete=False",
            "    ):",
            "        \"\"\"",
            "            Call generic cls.parse() method and ensure that a correct file \\",
            "            path is given as argument. If not, an exception is raised.",
            "",
            "            :param nmap_data: Same as for parse(). \\",
            "            Any portion of nmap scan reports could be passed as argument. \\",
            "            Data type _must be a valid path to a file containing \\",
            "            nmap scan results.",
            "",
            "            :param data_type: Specifies the type of serialization in the file.",
            "",
            "            :param incomplete: enable you to parse interrupted nmap scans \\",
            "            and/or incomplete nmap xml blocks by adding a </nmaprun> at \\",
            "            the end of the scan.",
            "            :type incomplete: boolean",
            "",
            "            :return: NmapObject",
            "        \"\"\"",
            "",
            "        try:",
            "            with open(nmap_report_path, \"r\") as fileobj:",
            "                fdata = fileobj.read()",
            "                rval = cls.parse(fdata, data_type, incomplete)",
            "        except IOError:",
            "            raise",
            "        return rval",
            "",
            "    @classmethod",
            "    def parse_fromdict(cls, rdict):",
            "        \"\"\"",
            "            Strange method which transforms a python dict \\",
            "            representation of a NmapReport and turns it into an \\",
            "            NmapReport object. \\",
            "            Needs to be reviewed and possibly removed.",
            "",
            "            :param rdict: python dict representation of an NmapReport",
            "            :type rdict: dict",
            "",
            "            :return: NmapReport",
            "        \"\"\"",
            "",
            "        nreport = {}",
            "        if list(rdict.keys())[0] == \"__NmapReport__\":",
            "            r = rdict[\"__NmapReport__\"]",
            "            nreport[\"_runstats\"] = r[\"_runstats\"]",
            "            nreport[\"_scaninfo\"] = r[\"_scaninfo\"]",
            "            nreport[\"_nmaprun\"] = r[\"_nmaprun\"]",
            "            hlist = []",
            "            for h in r[\"_hosts\"]:",
            "                slist = []",
            "                for s in h[\"__NmapHost__\"][\"_services\"]:",
            "                    cname = \"__NmapService__\"",
            "                    slist.append(",
            "                        NmapService(",
            "                            portid=s[cname][\"_portid\"],",
            "                            protocol=s[cname][\"_protocol\"],",
            "                            state=s[cname][\"_state\"],",
            "                            owner=s[cname][\"_owner\"],",
            "                            service=s[cname][\"_service\"],",
            "                        )",
            "                    )",
            "",
            "                nh = NmapHost(",
            "                    starttime=h[\"__NmapHost__\"][\"_starttime\"],",
            "                    endtime=h[\"__NmapHost__\"][\"_endtime\"],",
            "                    address=h[\"__NmapHost__\"][\"_address\"],",
            "                    status=h[\"__NmapHost__\"][\"_status\"],",
            "                    hostnames=h[\"__NmapHost__\"][\"_hostnames\"],",
            "                    extras=h[\"__NmapHost__\"][\"_extras\"],",
            "                    services=slist,",
            "                )",
            "                hlist.append(nh)",
            "            nreport[\"_hosts\"] = hlist",
            "            nmapobj = NmapReport(nreport)",
            "        return nmapobj",
            "",
            "    @classmethod",
            "    def __parse_scaninfo(cls, scaninfo_data):",
            "        \"\"\"",
            "            Private method parsing a portion of a nmap scan result.",
            "            Receives a <scaninfo> XML tag.",
            "",
            "            :param scaninfo_data: <scaninfo> XML tag from a nmap scan",
            "            :type scaninfo_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML scaninfo tag",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scaninfo_data)",
            "        return cls.__format_attributes(xelement)",
            "",
            "    @classmethod",
            "    def _parse_xml_host(cls, scanhost_data):",
            "        \"\"\"",
            "            Protected method parsing a portion of a nmap scan result.",
            "            Receives a <host> XML tag representing a scanned host with",
            "            its services.",
            "",
            "            :param scaninfo_data: <host> XML tag from a nmap scan",
            "            :type scaninfo_data: xml.ElementTree.Element or a string",
            "",
            "            :return: NmapHost object",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanhost_data)",
            "        _host_header = cls.__format_attributes(xelement)",
            "        _hostnames = []",
            "        _services = []",
            "        _status = {}",
            "        _addresses = []",
            "        _host_extras = {}",
            "        extra_tags = [",
            "            \"uptime\",",
            "            \"distance\",",
            "            \"tcpsequence\",",
            "            \"ipidsequence\",",
            "            \"tcptssequence\",",
            "            \"times\",",
            "        ]",
            "        for xh in xelement:",
            "            if xh.tag == \"hostnames\":",
            "                for hostname in cls.__parse_hostnames(xh):",
            "                    _hostnames.append(hostname)",
            "            elif xh.tag == \"ports\":",
            "                ports_dict = cls._parse_xml_ports(xh)",
            "                for port in ports_dict[\"ports\"]:",
            "                    _services.append(port)",
            "                _host_extras[\"extraports\"] = ports_dict[\"extraports\"]",
            "            elif xh.tag == \"status\":",
            "                _status = cls.__format_attributes(xh)",
            "            elif xh.tag == \"address\":",
            "                _addresses.append(cls.__format_attributes(xh))",
            "            elif xh.tag == \"os\":",
            "                _os_extra = cls.__parse_os_fingerprint(xh)",
            "                _host_extras.update({\"os\": _os_extra})",
            "            elif xh.tag == \"hostscript\":",
            "                _host_scripts = cls.__parse_host_scripts(xh)",
            "                _host_extras.update({\"hostscript\": _host_scripts})",
            "            elif xh.tag in extra_tags:",
            "                _host_extras[xh.tag] = cls.__format_attributes(xh)",
            "            # else:",
            "            #    print \"struct host unknown attr: %s value: %s\" %",
            "            #           (h.tag, h.get(h.tag))",
            "        _stime = \"\"",
            "        _etime = \"\"",
            "        if \"starttime\" in _host_header:",
            "            _stime = _host_header[\"starttime\"]",
            "        if \"endtime\" in _host_header:",
            "            _etime = _host_header[\"endtime\"]",
            "        nhost = NmapHost(",
            "            _stime,",
            "            _etime,",
            "            _addresses,",
            "            _status,",
            "            _hostnames,",
            "            _services,",
            "            _host_extras",
            "        )",
            "        return nhost",
            "",
            "    @classmethod",
            "    def __parse_hostnames(cls, scanhostnames_data):",
            "        \"\"\"",
            "            Private method parsing the hostnames list within a <host> XML tag.",
            "",
            "            :param scanhostnames_data: <hostnames> XML tag from a nmap scan",
            "            :type scanhostnames_data: xml.ElementTree.Element or a string",
            "",
            "            :return: list of hostnames",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanhostnames_data)",
            "        hostnames = []",
            "        for hname in xelement:",
            "            if hname.tag == \"hostname\":",
            "                hostnames.append(hname.get(\"name\"))",
            "        return hostnames",
            "",
            "    @classmethod",
            "    def _parse_xml_ports(cls, scanports_data):",
            "        \"\"\"",
            "            Protected method parsing the list of scanned services from",
            "            a targeted host. This protected method cannot be called directly",
            "            with a string. A <ports/> tag can be directly passed to parse()",
            "            and the below method will be called and return a list of nmap",
            "            scanned services.",
            "",
            "            :param scanports_data: <ports> XML tag from a nmap scan",
            "            :type scanports_data: xml.ElementTree.Element or a string",
            "",
            "            :return: list of NmapService",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanports_data)",
            "",
            "        rdict = {\"ports\": [], \"extraports\": None}",
            "        for xservice in xelement:",
            "            if xservice.tag == \"port\":",
            "                nport = cls._parse_xml_port(xservice)",
            "                rdict[\"ports\"].append(nport)",
            "            elif xservice.tag == \"extraports\":",
            "                extraports = cls.__parse_extraports(xservice)",
            "                rdict[\"extraports\"] = extraports",
            "            # else:",
            "            #    print \"struct port unknown attr: %s value: %s\" %",
            "            #           (h.tag, h.get(h.tag))",
            "        return rdict",
            "",
            "    @classmethod",
            "    def _parse_xml_port(cls, scanport_data):",
            "        \"\"\"",
            "            Protected method parsing a scanned service from a targeted host.",
            "            This protected method cannot be called directly.",
            "            A <port/> tag can be directly passed to parse() and the below",
            "            method will be called and return a NmapService object",
            "            representing the state of the service.",
            "",
            "            :param scanport_data: <port> XML tag from a nmap scan",
            "            :type scanport_data: xml.ElementTree.Element or a string",
            "",
            "            :return: NmapService",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanport_data)",
            "",
            "        _port = cls.__format_attributes(xelement)",
            "        _portid = _port[\"portid\"] if \"portid\" in _port else None",
            "        _protocol = _port[\"protocol\"] if \"protocol\" in _port else None",
            "",
            "        _state = None",
            "        _service = None",
            "        _owner = None",
            "        _service_scripts = []",
            "        _service_extras = {}",
            "        for xport in xelement:",
            "            if xport.tag == \"state\":",
            "                _state = cls.__format_attributes(xport)",
            "            elif xport.tag == \"service\":",
            "                _service = cls.__parse_service(xport)",
            "            elif xport.tag == \"owner\":",
            "                _owner = cls.__format_attributes(xport)",
            "            elif xport.tag == \"script\":",
            "                _script_dict = cls.__parse_script(xport)",
            "                _service_scripts.append(_script_dict)",
            "        _service_extras[\"scripts\"] = _service_scripts",
            "",
            "        if _portid is None or _protocol is None or _state is None:",
            "            raise NmapParserException(",
            "                \"XML <port> tag is incomplete. One \"",
            "                \"of the following tags is missing: \"",
            "                \"portid, protocol or state or tag.\"",
            "            )",
            "",
            "        nport = NmapService(",
            "            _portid, _protocol, _state, _service, _owner, _service_extras",
            "        )",
            "        return nport",
            "",
            "    @classmethod",
            "    def __parse_service(cls, xserv):",
            "        \"\"\"",
            "            Parse <service> tag to manage CPE object",
            "        \"\"\"",
            "        _service = cls.__format_attributes(xserv)",
            "        _cpelist = []",
            "        for _servnode in xserv:",
            "            if _servnode.tag == \"cpe\":",
            "                _cpe_string = _servnode.text",
            "                _cpelist.append(_cpe_string)",
            "        _service[\"cpelist\"] = _cpelist",
            "        return _service",
            "",
            "    @classmethod",
            "    def __parse_extraports(cls, extraports_data):",
            "        \"\"\"",
            "            Private method parsing the data from extra scanned ports.",
            "            X extraports were in state \"closed\" server returned \"conn-refused\"",
            "            tag: <extraports>",
            "",
            "            :param extraports_data: XML data for extraports",
            "            :type extraports_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict with following keys: state, count, reason",
            "        \"\"\"",
            "        rdict = {\"state\": \"\", \"count\": \"\", \"reasons\": []}",
            "        xelement = cls.__format_element(extraports_data)",
            "        extraports_dict = cls.__format_attributes(xelement)",
            "",
            "        if \"state\" in extraports_dict:",
            "            rdict[\"state\"] = extraports_dict",
            "        if \"count\" in extraports_dict:",
            "            rdict[\"count\"] = extraports_dict",
            "        for xelt in xelement:",
            "            if xelt.tag == \"extrareasons\":",
            "                extrareasons_dict = cls.__format_attributes(xelt)",
            "                rdict[\"reasons\"].append(extrareasons_dict)",
            "        return rdict",
            "",
            "    @classmethod",
            "    def __parse_script_table(cls, script_table):",
            "        \"\"\"",
            "           Private method parsing a table from NSE scripts output",
            "",
            "           :param sccript_table: poertion of XML containing the table",
            "           :type script_table: xml.ElementTree.Element",
            "",
            "           :return: python dict of table structure",
            "        \"\"\"",
            "        tdict = {}",
            "        for telem in script_table:",
            "            tkey = telem.get(\"key\")",
            "            if telem.tag == \"elem\":",
            "                if tkey in tdict:",
            "                    if not isinstance(tdict[tkey], list):",
            "                        tdict[tkey] = [tdict[tkey]]",
            "                    tdict[tkey].append(telem.text)",
            "                else:",
            "                    tdict[tkey] = telem.text",
            "            elif telem.tag == \"table\":",
            "                stdict = cls.__parse_script_table(telem)",
            "",
            "                # Handle duplicate table keys",
            "                if tkey in tdict:",
            "                    if not isinstance(tdict[tkey], list):",
            "                        tdict[tkey] = [tdict[tkey]]",
            "                    tdict[tkey].append(stdict)",
            "                else:",
            "                    tdict[tkey] = stdict",
            "        return tdict",
            "",
            "    @classmethod",
            "    def __parse_script(cls, script_data):",
            "        \"\"\"",
            "            Private method parsing the data from NSE scripts output",
            "",
            "            :param script_data: portion of XML describing the results of the",
            "            script data",
            "            :type script_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict holding scripts output",
            "        \"\"\"",
            "        _script_dict = cls.__format_attributes(script_data)",
            "",
            "        _elt_dict = {}",
            "        for script_elem in script_data:",
            "            if script_elem.tag == \"elem\":",
            "                _elt_dict.update({script_elem.get(\"key\"): script_elem.text})",
            "            elif script_elem.tag == \"table\":",
            "                tdict = cls.__parse_script_table(script_elem)",
            "                # Handle duplicate table keys",
            "                skey = script_elem.get(\"key\")",
            "                if skey in _elt_dict:",
            "                    if not isinstance(_elt_dict[skey], list):",
            "                        _elt_dict[skey] = [_elt_dict[skey]]",
            "                    _elt_dict[skey].append(tdict)",
            "                else:",
            "                    _elt_dict[skey] = tdict",
            "        _script_dict[\"elements\"] = _elt_dict",
            "        return _script_dict",
            "",
            "    @classmethod",
            "    def __parse_host_scripts(cls, scripts_data):",
            "        \"\"\"",
            "            Private method parsing the data from scripts affecting",
            "            the target host.",
            "            Contents of <hostscript> is returned as a list of dict.",
            "",
            "            :param scripts_data: portion of XML describing the results of the",
            "            scripts data",
            "            :type scripts_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python list holding scripts output in a dict",
            "        \"\"\"",
            "        _host_scripts = []",
            "        for xscript in scripts_data:",
            "            if xscript.tag == \"script\":",
            "                _script_dict = cls.__parse_script(xscript)",
            "            _host_scripts.append(_script_dict)",
            "        return _host_scripts",
            "",
            "    @classmethod",
            "    def __parse_os_fingerprint(cls, os_data):",
            "        \"\"\"",
            "            Private method parsing the data from an OS fingerprint (-O).",
            "            Contents of <os> is returned as a dict.",
            "",
            "            :param os_data: portion of XML describing the results of the",
            "            os fingerprinting attempt",
            "            :type os_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML os tag",
            "        \"\"\"",
            "        rdict = {}",
            "        xelement = cls.__format_element(os_data)",
            "",
            "        os_class_probability = []",
            "        os_match_probability = []",
            "        os_ports_used = []",
            "        os_fingerprints = []",
            "        for xos in xelement:",
            "            # for nmap xml version < 1.04, osclass is not",
            "            # embedded in osmatch",
            "            if xos.tag == \"osclass\":",
            "                os_class_proba = cls.__parse_osclass(xos)",
            "                os_class_probability.append(os_class_proba)",
            "            elif xos.tag == \"osmatch\":",
            "                os_match_proba = cls.__parse_osmatch(xos)",
            "                os_match_probability.append(os_match_proba)",
            "            elif xos.tag == \"portused\":",
            "                os_portused = cls.__format_attributes(xos)",
            "                os_ports_used.append(os_portused)",
            "            elif xos.tag == \"osfingerprint\":",
            "                os_fp_dict = cls.__format_attributes(xos)",
            "                os_fingerprints.append(os_fp_dict)",
            "",
            "        rdict[\"osmatches\"] = os_match_probability",
            "        rdict[\"osclasses\"] = os_class_probability",
            "        rdict[\"ports_used\"] = os_ports_used",
            "        rdict[\"osfingerprints\"] = os_fingerprints",
            "",
            "        return rdict",
            "",
            "    @classmethod",
            "    def __parse_osmatch(cls, osmatch_data):",
            "        \"\"\"",
            "            This methods parses osmatch data and returns a dict. Depending",
            "            on the nmap xml version, osmatch could contain an osclass",
            "            dict.",
            "",
            "            :param osmatch_data: <osmatch> XML tag from a nmap scan",
            "            :type osmatch_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML osmatch tag",
            "        \"\"\"",
            "        rdict = {}",
            "        xelement = cls.__format_element(osmatch_data)",
            "        rdict[\"osmatch\"] = cls.__format_attributes(xelement)",
            "        rdict[\"osclasses\"] = []",
            "        for xmltag in xelement:",
            "            if xmltag.tag == \"osclass\":",
            "                _osclass_dict = cls.__parse_osclass(xmltag)",
            "                rdict[\"osclasses\"].append(_osclass_dict)",
            "            else:",
            "                exmsg = \"Unexcepted node in <osmatch>: {0}\".format(xmltag.tag)",
            "                raise NmapParserException(exmsg)",
            "        return rdict",
            "",
            "    @classmethod",
            "    def __parse_osclass(cls, osclass_data):",
            "        \"\"\"",
            "            This methods parses osclass data and returns a dict. Depending",
            "            on the nmap xml version, osclass could contain a cpe",
            "            dict.",
            "",
            "            :param osclass_data: <osclass> XML tag from a nmap scan",
            "            :type osclass_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML osclass tag",
            "        \"\"\"",
            "        rdict = {}",
            "        xelement = cls.__format_element(osclass_data)",
            "        rdict[\"osclass\"] = cls.__format_attributes(xelement)",
            "        rdict[\"cpe\"] = []",
            "        for xmltag in xelement:",
            "            if xmltag.tag == \"cpe\":",
            "                _cpe_string = xmltag.text",
            "                rdict[\"cpe\"].append(_cpe_string)",
            "            else:",
            "                exmsg = \"Unexcepted node in <osclass>: {0}\".format(xmltag.tag)",
            "                raise NmapParserException(exmsg)",
            "        return rdict",
            "",
            "    @classmethod",
            "    def __parse_runstats(cls, scanrunstats_data):",
            "        \"\"\"",
            "            Private method parsing a portion of a nmap scan result.",
            "            Receives a <runstats> XML tag.",
            "",
            "            :param scanrunstats_data: <runstats> XML tag from a nmap scan",
            "            :type scanrunstats_data: xml.ElementTree.Element or a string",
            "",
            "            :return: python dict representing the XML runstats tag",
            "        \"\"\"",
            "",
            "        xelement = cls.__format_element(scanrunstats_data)",
            "",
            "        rdict = {}",
            "        for xmltag in xelement:",
            "            if xmltag.tag in [\"finished\", \"hosts\"]:",
            "                rdict[xmltag.tag] = cls.__format_attributes(xmltag)",
            "            else:",
            "                exmsg = \"Unexcepted node in <runstats>: {0}\".format(xmltag.tag)",
            "                raise NmapParserException(exmsg)",
            "",
            "        return rdict",
            "",
            "    @staticmethod",
            "    def __format_element(elt_data):",
            "        \"\"\"",
            "            Private method which ensures that a XML portion to be parsed is",
            "            of type xml.etree.ElementTree.Element.",
            "            If elt_data is a string, then it is converted to an",
            "            XML Element type.",
            "",
            "            :param elt_data: XML Element to be parsed or string",
            "            to be converted to a XML Element",
            "",
            "            :return: Element",
            "        \"\"\"",
            "        if isinstance(elt_data, str):",
            "            try:",
            "                xelement = ET.fromstring(elt_data)",
            "            except Exception as e:",
            "                raise NmapParserException(",
            "                    \"Error while trying \"",
            "                    \"to instanciate XML Element from \"",
            "                    \"string {0} - {1}\".format(elt_data, e)",
            "                )",
            "        elif et_iselement(elt_data):",
            "            xelement = elt_data",
            "        else:",
            "            raise NmapParserException(",
            "                \"Error while trying to parse supplied \"",
            "                \"data: unsupported format\"",
            "            )",
            "        return xelement",
            "",
            "    @staticmethod",
            "    def __format_attributes(elt_data):",
            "        \"\"\"",
            "            Private method which converts a single XML tag to a python dict.",
            "            It also checks that the elt_data given as argument is of type",
            "            xml.etree.ElementTree.Element",
            "",
            "            :param elt_data: XML Element to be parsed or string",
            "            to be converted to a XML Element",
            "",
            "            :return: Element",
            "        \"\"\"",
            "",
            "        rval = {}",
            "        if not et_iselement(elt_data):",
            "            raise NmapParserException(",
            "                \"Error while trying to parse supplied \"",
            "                \"data attributes: format is not XML or \"",
            "                \"XML tag is empty\"",
            "            )",
            "        try:",
            "            for dkey in elt_data.keys():",
            "                rval[dkey] = elt_data.get(dkey)",
            "                if rval[dkey] is None:",
            "                    raise NmapParserException(",
            "                        \"Error while trying to build-up \"",
            "                        \"element attributes: empty \"",
            "                        \"attribute {0}\".format(dkey)",
            "                    )",
            "        except Exception:",
            "            raise",
            "        return rval",
            "",
            "",
            "class NmapParserException(Exception):",
            "    def __init__(self, msg):",
            "        self.msg = msg",
            "",
            "    def __str__(self):",
            "        return self.msg"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "7": [],
            "704": [
                "NmapParser",
                "__format_element"
            ],
            "727": [
                "NmapParser",
                "__format_attributes"
            ]
        },
        "addLocation": []
    }
}