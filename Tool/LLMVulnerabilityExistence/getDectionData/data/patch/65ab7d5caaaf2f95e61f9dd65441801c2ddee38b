{
    "httpie/client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     httpie_session_headers = None"
            },
            "1": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     if args.session or args.session_read_only:"
            },
            "2": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         httpie_session = get_httpie_session("
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+            env=env,"
            },
            "4": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             config_dir=env.config.directory,"
            },
            "5": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             session_name=args.session or args.session_read_only,"
            },
            "6": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             host=args.headers.get('Host'),"
            },
            "7": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     if httpie_session:"
            },
            "8": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         if httpie_session.is_new() or not args.session_read_only:"
            },
            "9": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "             httpie_session.cookies = requests_session.cookies"
            },
            "10": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            httpie_session.remove_cookies("
            },
            "11": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # TODO: take path & domain into account?"
            },
            "12": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cookie['name'] for cookie in expired_cookies"
            },
            "13": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+            httpie_session.remove_cookies(expired_cookies)"
            },
            "15": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             httpie_session.save()"
            },
            "16": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import argparse",
            "import http.client",
            "import json",
            "import sys",
            "from contextlib import contextmanager",
            "from time import monotonic",
            "from typing import Any, Dict, Callable, Iterable",
            "from urllib.parse import urlparse, urlunparse",
            "",
            "import requests",
            "# noinspection PyPackageRequirements",
            "import urllib3",
            "from . import __version__",
            "from .adapters import HTTPieHTTPAdapter",
            "from .context import Environment",
            "from .cli.constants import EMPTY_STRING",
            "from .cli.dicts import HTTPHeadersDict, NestedJSONArray",
            "from .encoding import UTF8",
            "from .models import RequestsMessage",
            "from .plugins.registry import plugin_manager",
            "from .sessions import get_httpie_session",
            "from .ssl_ import AVAILABLE_SSL_VERSION_ARG_MAPPING, HTTPieCertificate, HTTPieHTTPSAdapter",
            "from .uploads import (",
            "    compress_request, prepare_request_body,",
            "    get_multipart_data_and_content_type,",
            ")",
            "from .utils import get_expired_cookies, repr_dict",
            "",
            "",
            "urllib3.disable_warnings()",
            "",
            "FORM_CONTENT_TYPE = f'application/x-www-form-urlencoded; charset={UTF8}'",
            "JSON_CONTENT_TYPE = 'application/json'",
            "JSON_ACCEPT = f'{JSON_CONTENT_TYPE}, */*;q=0.5'",
            "DEFAULT_UA = f'HTTPie/{__version__}'",
            "",
            "",
            "def collect_messages(",
            "    env: Environment,",
            "    args: argparse.Namespace,",
            "    request_body_read_callback: Callable[[bytes], None] = None,",
            ") -> Iterable[RequestsMessage]:",
            "    httpie_session = None",
            "    httpie_session_headers = None",
            "    if args.session or args.session_read_only:",
            "        httpie_session = get_httpie_session(",
            "            config_dir=env.config.directory,",
            "            session_name=args.session or args.session_read_only,",
            "            host=args.headers.get('Host'),",
            "            url=args.url,",
            "        )",
            "        httpie_session_headers = httpie_session.headers",
            "",
            "    request_kwargs = make_request_kwargs(",
            "        env,",
            "        args=args,",
            "        base_headers=httpie_session_headers,",
            "        request_body_read_callback=request_body_read_callback",
            "    )",
            "    send_kwargs = make_send_kwargs(args)",
            "    send_kwargs_mergeable_from_env = make_send_kwargs_mergeable_from_env(args)",
            "    requests_session = build_requests_session(",
            "        ssl_version=args.ssl_version,",
            "        ciphers=args.ciphers,",
            "        verify=bool(send_kwargs_mergeable_from_env['verify'])",
            "    )",
            "",
            "    if httpie_session:",
            "        httpie_session.update_headers(request_kwargs['headers'])",
            "        requests_session.cookies = httpie_session.cookies",
            "        if args.auth_plugin:",
            "            # Save auth from CLI to HTTPie session.",
            "            httpie_session.auth = {",
            "                'type': args.auth_plugin.auth_type,",
            "                'raw_auth': args.auth_plugin.raw_auth,",
            "            }",
            "        elif httpie_session.auth:",
            "            # Apply auth from HTTPie session",
            "            request_kwargs['auth'] = httpie_session.auth",
            "",
            "    if args.debug:",
            "        # TODO: reflect the split between request and send kwargs.",
            "        dump_request(request_kwargs)",
            "",
            "    request = requests.Request(**request_kwargs)",
            "    prepared_request = requests_session.prepare_request(request)",
            "    apply_missing_repeated_headers(prepared_request, request.headers)",
            "    if args.path_as_is:",
            "        prepared_request.url = ensure_path_as_is(",
            "            orig_url=args.url,",
            "            prepped_url=prepared_request.url,",
            "        )",
            "    if args.compress and prepared_request.body:",
            "        compress_request(",
            "            request=prepared_request,",
            "            always=args.compress > 1,",
            "        )",
            "    response_count = 0",
            "    expired_cookies = []",
            "    while prepared_request:",
            "        yield prepared_request",
            "        if not args.offline:",
            "            send_kwargs_merged = requests_session.merge_environment_settings(",
            "                url=prepared_request.url,",
            "                **send_kwargs_mergeable_from_env,",
            "            )",
            "            with max_headers(args.max_headers):",
            "                response = requests_session.send(",
            "                    request=prepared_request,",
            "                    **send_kwargs_merged,",
            "                    **send_kwargs,",
            "                )",
            "            response._httpie_headers_parsed_at = monotonic()",
            "            expired_cookies += get_expired_cookies(",
            "                response.headers.get('Set-Cookie', '')",
            "            )",
            "",
            "            response_count += 1",
            "            if response.next:",
            "                if args.max_redirects and response_count == args.max_redirects:",
            "                    raise requests.TooManyRedirects",
            "                if args.follow:",
            "                    prepared_request = response.next",
            "                    if args.all:",
            "                        yield response",
            "                    continue",
            "            yield response",
            "        break",
            "",
            "    if httpie_session:",
            "        if httpie_session.is_new() or not args.session_read_only:",
            "            httpie_session.cookies = requests_session.cookies",
            "            httpie_session.remove_cookies(",
            "                # TODO: take path & domain into account?",
            "                cookie['name'] for cookie in expired_cookies",
            "            )",
            "            httpie_session.save()",
            "",
            "",
            "# noinspection PyProtectedMember",
            "@contextmanager",
            "def max_headers(limit):",
            "    # <https://github.com/httpie/httpie/issues/802>",
            "    # noinspection PyUnresolvedReferences",
            "    orig = http.client._MAXHEADERS",
            "    http.client._MAXHEADERS = limit or float('Inf')",
            "    try:",
            "        yield",
            "    finally:",
            "        http.client._MAXHEADERS = orig",
            "",
            "",
            "def build_requests_session(",
            "    verify: bool,",
            "    ssl_version: str = None,",
            "    ciphers: str = None,",
            ") -> requests.Session:",
            "    requests_session = requests.Session()",
            "",
            "    # Install our adapter.",
            "    http_adapter = HTTPieHTTPAdapter()",
            "    https_adapter = HTTPieHTTPSAdapter(",
            "        ciphers=ciphers,",
            "        verify=verify,",
            "        ssl_version=(",
            "            AVAILABLE_SSL_VERSION_ARG_MAPPING[ssl_version]",
            "            if ssl_version else None",
            "        ),",
            "    )",
            "    requests_session.mount('http://', http_adapter)",
            "    requests_session.mount('https://', https_adapter)",
            "",
            "    # Install adapters from plugins.",
            "    for plugin_cls in plugin_manager.get_transport_plugins():",
            "        transport_plugin = plugin_cls()",
            "        requests_session.mount(",
            "            prefix=transport_plugin.prefix,",
            "            adapter=transport_plugin.get_adapter(),",
            "        )",
            "",
            "    return requests_session",
            "",
            "",
            "def dump_request(kwargs: dict):",
            "    sys.stderr.write(",
            "        f'\\n>>> requests.request(**{repr_dict(kwargs)})\\n\\n')",
            "",
            "",
            "def finalize_headers(headers: HTTPHeadersDict) -> HTTPHeadersDict:",
            "    final_headers = HTTPHeadersDict()",
            "    for name, value in headers.items():",
            "        if value is not None:",
            "            # \u201cleading or trailing LWS MAY be removed without",
            "            # changing the semantics of the field value\u201d",
            "            # <https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html>",
            "            # Also, requests raises `InvalidHeader` for leading spaces.",
            "            value = value.strip()",
            "            if isinstance(value, str):",
            "                # See <https://github.com/httpie/httpie/issues/212>",
            "                value = value.encode()",
            "        final_headers.add(name, value)",
            "    return final_headers",
            "",
            "",
            "def apply_missing_repeated_headers(",
            "    prepared_request: requests.PreparedRequest,",
            "    original_headers: HTTPHeadersDict",
            ") -> None:",
            "    \"\"\"Update the given `prepared_request`'s headers with the original",
            "    ones. This allows the requests to be prepared as usual, and then later",
            "    merged with headers that are specified multiple times.\"\"\"",
            "",
            "    new_headers = HTTPHeadersDict(prepared_request.headers)",
            "    for prepared_name, prepared_value in prepared_request.headers.items():",
            "        if prepared_name not in original_headers:",
            "            continue",
            "",
            "        original_keys, original_values = zip(*filter(",
            "            lambda item: item[0].casefold() == prepared_name.casefold(),",
            "            original_headers.items()",
            "        ))",
            "",
            "        if prepared_value not in original_values:",
            "            # If the current value is not among the initial values",
            "            # set for this field, then it means that this field got",
            "            # overridden on the way, and we should preserve it.",
            "            continue",
            "",
            "        new_headers.popone(prepared_name)",
            "        new_headers.update(zip(original_keys, original_values))",
            "",
            "    prepared_request.headers = new_headers",
            "",
            "",
            "def make_default_headers(args: argparse.Namespace) -> HTTPHeadersDict:",
            "    default_headers = HTTPHeadersDict({",
            "        'User-Agent': DEFAULT_UA",
            "    })",
            "",
            "    auto_json = args.data and not args.form",
            "    if args.json or auto_json:",
            "        default_headers['Accept'] = JSON_ACCEPT",
            "        if args.json or (auto_json and args.data):",
            "            default_headers['Content-Type'] = JSON_CONTENT_TYPE",
            "",
            "    elif args.form and not args.files:",
            "        # If sending files, `requests` will set",
            "        # the `Content-Type` for us.",
            "        default_headers['Content-Type'] = FORM_CONTENT_TYPE",
            "    return default_headers",
            "",
            "",
            "def make_send_kwargs(args: argparse.Namespace) -> dict:",
            "    return {",
            "        'timeout': args.timeout or None,",
            "        'allow_redirects': False,",
            "    }",
            "",
            "",
            "def make_send_kwargs_mergeable_from_env(args: argparse.Namespace) -> dict:",
            "    cert = None",
            "    if args.cert:",
            "        cert = args.cert",
            "        if args.cert_key:",
            "            # Having a client certificate key passphrase is not supported",
            "            # by requests. So we are using our own transportation structure",
            "            # which is compatible with their format (a tuple of minimum two",
            "            # items).",
            "            #",
            "            # See: https://github.com/psf/requests/issues/2519",
            "            cert = HTTPieCertificate(cert, args.cert_key, args.cert_key_pass.value)",
            "",
            "    return {",
            "        'proxies': {p.key: p.value for p in args.proxy},",
            "        'stream': True,",
            "        'verify': {",
            "            'yes': True,",
            "            'true': True,",
            "            'no': False,",
            "            'false': False,",
            "        }.get(args.verify.lower(), args.verify),",
            "        'cert': cert,",
            "    }",
            "",
            "",
            "def json_dict_to_request_body(data: Dict[str, Any]) -> str:",
            "    # Propagate the top-level list if there is only one",
            "    # item in the object, with an en empty key.",
            "    if len(data) == 1:",
            "        [(key, value)] = data.items()",
            "        if isinstance(value, NestedJSONArray):",
            "            assert key == EMPTY_STRING",
            "            data = value",
            "",
            "    if data:",
            "        data = json.dumps(data)",
            "    else:",
            "        # We need to set data to an empty string to prevent requests",
            "        # from assigning an empty list to `response.request.data`.",
            "        data = ''",
            "",
            "    return data",
            "",
            "",
            "def make_request_kwargs(",
            "    env: Environment,",
            "    args: argparse.Namespace,",
            "    base_headers: HTTPHeadersDict = None,",
            "    request_body_read_callback=lambda chunk: chunk",
            ") -> dict:",
            "    \"\"\"",
            "    Translate our `args` into `requests.Request` keyword arguments.",
            "",
            "    \"\"\"",
            "    files = args.files",
            "    # Serialize JSON data, if needed.",
            "    data = args.data",
            "    auto_json = data and not args.form",
            "    if (args.json or auto_json) and isinstance(data, dict):",
            "        data = json_dict_to_request_body(data)",
            "",
            "    # Finalize headers.",
            "    headers = make_default_headers(args)",
            "    if base_headers:",
            "        headers.update(base_headers)",
            "    headers.update(args.headers)",
            "    if args.offline and args.chunked and 'Transfer-Encoding' not in headers:",
            "        # When online, we let requests set the header instead to be able more",
            "        # easily verify chunking is taking place.",
            "        headers['Transfer-Encoding'] = 'chunked'",
            "    headers = finalize_headers(headers)",
            "",
            "    if (args.form and files) or args.multipart:",
            "        data, headers['Content-Type'] = get_multipart_data_and_content_type(",
            "            data=args.multipart_data,",
            "            boundary=args.boundary,",
            "            content_type=args.headers.get('Content-Type'),",
            "        )",
            "",
            "    return {",
            "        'method': args.method.lower(),",
            "        'url': args.url,",
            "        'headers': headers,",
            "        'data': prepare_request_body(",
            "            env,",
            "            data,",
            "            body_read_callback=request_body_read_callback,",
            "            chunked=args.chunked,",
            "            offline=args.offline,",
            "            content_length_header_value=headers.get('Content-Length'),",
            "        ),",
            "        'auth': args.auth,",
            "        'params': args.params.items(),",
            "    }",
            "",
            "",
            "def ensure_path_as_is(orig_url: str, prepped_url: str) -> str:",
            "    \"\"\"",
            "    Handle `--path-as-is` by replacing the path component of the prepared",
            "    URL with the path component from the original URL. Other parts stay",
            "    untouched because other (welcome) processing on the URL might have",
            "    taken place.",
            "",
            "    <https://github.com/httpie/httpie/issues/895>",
            "",
            "",
            "    <https://ec.haxx.se/http/http-basics#path-as-is>",
            "    <https://curl.haxx.se/libcurl/c/CURLOPT_PATH_AS_IS.html>",
            "",
            "    >>> ensure_path_as_is('http://foo/../', 'http://foo/?foo=bar')",
            "    'http://foo/../?foo=bar'",
            "",
            "    \"\"\"",
            "    parsed_orig, parsed_prepped = urlparse(orig_url), urlparse(prepped_url)",
            "    final_dict = {",
            "        # noinspection PyProtectedMember",
            "        **parsed_prepped._asdict(),",
            "        'path': parsed_orig.path,",
            "    }",
            "    return urlunparse(tuple(final_dict.values()))"
        ],
        "afterPatchFile": [
            "import argparse",
            "import http.client",
            "import json",
            "import sys",
            "from contextlib import contextmanager",
            "from time import monotonic",
            "from typing import Any, Dict, Callable, Iterable",
            "from urllib.parse import urlparse, urlunparse",
            "",
            "import requests",
            "# noinspection PyPackageRequirements",
            "import urllib3",
            "from . import __version__",
            "from .adapters import HTTPieHTTPAdapter",
            "from .context import Environment",
            "from .cli.constants import EMPTY_STRING",
            "from .cli.dicts import HTTPHeadersDict, NestedJSONArray",
            "from .encoding import UTF8",
            "from .models import RequestsMessage",
            "from .plugins.registry import plugin_manager",
            "from .sessions import get_httpie_session",
            "from .ssl_ import AVAILABLE_SSL_VERSION_ARG_MAPPING, HTTPieCertificate, HTTPieHTTPSAdapter",
            "from .uploads import (",
            "    compress_request, prepare_request_body,",
            "    get_multipart_data_and_content_type,",
            ")",
            "from .utils import get_expired_cookies, repr_dict",
            "",
            "",
            "urllib3.disable_warnings()",
            "",
            "FORM_CONTENT_TYPE = f'application/x-www-form-urlencoded; charset={UTF8}'",
            "JSON_CONTENT_TYPE = 'application/json'",
            "JSON_ACCEPT = f'{JSON_CONTENT_TYPE}, */*;q=0.5'",
            "DEFAULT_UA = f'HTTPie/{__version__}'",
            "",
            "",
            "def collect_messages(",
            "    env: Environment,",
            "    args: argparse.Namespace,",
            "    request_body_read_callback: Callable[[bytes], None] = None,",
            ") -> Iterable[RequestsMessage]:",
            "    httpie_session = None",
            "    httpie_session_headers = None",
            "    if args.session or args.session_read_only:",
            "        httpie_session = get_httpie_session(",
            "            env=env,",
            "            config_dir=env.config.directory,",
            "            session_name=args.session or args.session_read_only,",
            "            host=args.headers.get('Host'),",
            "            url=args.url,",
            "        )",
            "        httpie_session_headers = httpie_session.headers",
            "",
            "    request_kwargs = make_request_kwargs(",
            "        env,",
            "        args=args,",
            "        base_headers=httpie_session_headers,",
            "        request_body_read_callback=request_body_read_callback",
            "    )",
            "    send_kwargs = make_send_kwargs(args)",
            "    send_kwargs_mergeable_from_env = make_send_kwargs_mergeable_from_env(args)",
            "    requests_session = build_requests_session(",
            "        ssl_version=args.ssl_version,",
            "        ciphers=args.ciphers,",
            "        verify=bool(send_kwargs_mergeable_from_env['verify'])",
            "    )",
            "",
            "    if httpie_session:",
            "        httpie_session.update_headers(request_kwargs['headers'])",
            "        requests_session.cookies = httpie_session.cookies",
            "        if args.auth_plugin:",
            "            # Save auth from CLI to HTTPie session.",
            "            httpie_session.auth = {",
            "                'type': args.auth_plugin.auth_type,",
            "                'raw_auth': args.auth_plugin.raw_auth,",
            "            }",
            "        elif httpie_session.auth:",
            "            # Apply auth from HTTPie session",
            "            request_kwargs['auth'] = httpie_session.auth",
            "",
            "    if args.debug:",
            "        # TODO: reflect the split between request and send kwargs.",
            "        dump_request(request_kwargs)",
            "",
            "    request = requests.Request(**request_kwargs)",
            "    prepared_request = requests_session.prepare_request(request)",
            "    apply_missing_repeated_headers(prepared_request, request.headers)",
            "    if args.path_as_is:",
            "        prepared_request.url = ensure_path_as_is(",
            "            orig_url=args.url,",
            "            prepped_url=prepared_request.url,",
            "        )",
            "    if args.compress and prepared_request.body:",
            "        compress_request(",
            "            request=prepared_request,",
            "            always=args.compress > 1,",
            "        )",
            "    response_count = 0",
            "    expired_cookies = []",
            "    while prepared_request:",
            "        yield prepared_request",
            "        if not args.offline:",
            "            send_kwargs_merged = requests_session.merge_environment_settings(",
            "                url=prepared_request.url,",
            "                **send_kwargs_mergeable_from_env,",
            "            )",
            "            with max_headers(args.max_headers):",
            "                response = requests_session.send(",
            "                    request=prepared_request,",
            "                    **send_kwargs_merged,",
            "                    **send_kwargs,",
            "                )",
            "            response._httpie_headers_parsed_at = monotonic()",
            "            expired_cookies += get_expired_cookies(",
            "                response.headers.get('Set-Cookie', '')",
            "            )",
            "",
            "            response_count += 1",
            "            if response.next:",
            "                if args.max_redirects and response_count == args.max_redirects:",
            "                    raise requests.TooManyRedirects",
            "                if args.follow:",
            "                    prepared_request = response.next",
            "                    if args.all:",
            "                        yield response",
            "                    continue",
            "            yield response",
            "        break",
            "",
            "    if httpie_session:",
            "        if httpie_session.is_new() or not args.session_read_only:",
            "            httpie_session.cookies = requests_session.cookies",
            "            httpie_session.remove_cookies(expired_cookies)",
            "            httpie_session.save()",
            "",
            "",
            "# noinspection PyProtectedMember",
            "@contextmanager",
            "def max_headers(limit):",
            "    # <https://github.com/httpie/httpie/issues/802>",
            "    # noinspection PyUnresolvedReferences",
            "    orig = http.client._MAXHEADERS",
            "    http.client._MAXHEADERS = limit or float('Inf')",
            "    try:",
            "        yield",
            "    finally:",
            "        http.client._MAXHEADERS = orig",
            "",
            "",
            "def build_requests_session(",
            "    verify: bool,",
            "    ssl_version: str = None,",
            "    ciphers: str = None,",
            ") -> requests.Session:",
            "    requests_session = requests.Session()",
            "",
            "    # Install our adapter.",
            "    http_adapter = HTTPieHTTPAdapter()",
            "    https_adapter = HTTPieHTTPSAdapter(",
            "        ciphers=ciphers,",
            "        verify=verify,",
            "        ssl_version=(",
            "            AVAILABLE_SSL_VERSION_ARG_MAPPING[ssl_version]",
            "            if ssl_version else None",
            "        ),",
            "    )",
            "    requests_session.mount('http://', http_adapter)",
            "    requests_session.mount('https://', https_adapter)",
            "",
            "    # Install adapters from plugins.",
            "    for plugin_cls in plugin_manager.get_transport_plugins():",
            "        transport_plugin = plugin_cls()",
            "        requests_session.mount(",
            "            prefix=transport_plugin.prefix,",
            "            adapter=transport_plugin.get_adapter(),",
            "        )",
            "",
            "    return requests_session",
            "",
            "",
            "def dump_request(kwargs: dict):",
            "    sys.stderr.write(",
            "        f'\\n>>> requests.request(**{repr_dict(kwargs)})\\n\\n')",
            "",
            "",
            "def finalize_headers(headers: HTTPHeadersDict) -> HTTPHeadersDict:",
            "    final_headers = HTTPHeadersDict()",
            "    for name, value in headers.items():",
            "        if value is not None:",
            "            # \u201cleading or trailing LWS MAY be removed without",
            "            # changing the semantics of the field value\u201d",
            "            # <https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html>",
            "            # Also, requests raises `InvalidHeader` for leading spaces.",
            "            value = value.strip()",
            "            if isinstance(value, str):",
            "                # See <https://github.com/httpie/httpie/issues/212>",
            "                value = value.encode()",
            "        final_headers.add(name, value)",
            "    return final_headers",
            "",
            "",
            "def apply_missing_repeated_headers(",
            "    prepared_request: requests.PreparedRequest,",
            "    original_headers: HTTPHeadersDict",
            ") -> None:",
            "    \"\"\"Update the given `prepared_request`'s headers with the original",
            "    ones. This allows the requests to be prepared as usual, and then later",
            "    merged with headers that are specified multiple times.\"\"\"",
            "",
            "    new_headers = HTTPHeadersDict(prepared_request.headers)",
            "    for prepared_name, prepared_value in prepared_request.headers.items():",
            "        if prepared_name not in original_headers:",
            "            continue",
            "",
            "        original_keys, original_values = zip(*filter(",
            "            lambda item: item[0].casefold() == prepared_name.casefold(),",
            "            original_headers.items()",
            "        ))",
            "",
            "        if prepared_value not in original_values:",
            "            # If the current value is not among the initial values",
            "            # set for this field, then it means that this field got",
            "            # overridden on the way, and we should preserve it.",
            "            continue",
            "",
            "        new_headers.popone(prepared_name)",
            "        new_headers.update(zip(original_keys, original_values))",
            "",
            "    prepared_request.headers = new_headers",
            "",
            "",
            "def make_default_headers(args: argparse.Namespace) -> HTTPHeadersDict:",
            "    default_headers = HTTPHeadersDict({",
            "        'User-Agent': DEFAULT_UA",
            "    })",
            "",
            "    auto_json = args.data and not args.form",
            "    if args.json or auto_json:",
            "        default_headers['Accept'] = JSON_ACCEPT",
            "        if args.json or (auto_json and args.data):",
            "            default_headers['Content-Type'] = JSON_CONTENT_TYPE",
            "",
            "    elif args.form and not args.files:",
            "        # If sending files, `requests` will set",
            "        # the `Content-Type` for us.",
            "        default_headers['Content-Type'] = FORM_CONTENT_TYPE",
            "    return default_headers",
            "",
            "",
            "def make_send_kwargs(args: argparse.Namespace) -> dict:",
            "    return {",
            "        'timeout': args.timeout or None,",
            "        'allow_redirects': False,",
            "    }",
            "",
            "",
            "def make_send_kwargs_mergeable_from_env(args: argparse.Namespace) -> dict:",
            "    cert = None",
            "    if args.cert:",
            "        cert = args.cert",
            "        if args.cert_key:",
            "            # Having a client certificate key passphrase is not supported",
            "            # by requests. So we are using our own transportation structure",
            "            # which is compatible with their format (a tuple of minimum two",
            "            # items).",
            "            #",
            "            # See: https://github.com/psf/requests/issues/2519",
            "            cert = HTTPieCertificate(cert, args.cert_key, args.cert_key_pass.value)",
            "",
            "    return {",
            "        'proxies': {p.key: p.value for p in args.proxy},",
            "        'stream': True,",
            "        'verify': {",
            "            'yes': True,",
            "            'true': True,",
            "            'no': False,",
            "            'false': False,",
            "        }.get(args.verify.lower(), args.verify),",
            "        'cert': cert,",
            "    }",
            "",
            "",
            "def json_dict_to_request_body(data: Dict[str, Any]) -> str:",
            "    # Propagate the top-level list if there is only one",
            "    # item in the object, with an en empty key.",
            "    if len(data) == 1:",
            "        [(key, value)] = data.items()",
            "        if isinstance(value, NestedJSONArray):",
            "            assert key == EMPTY_STRING",
            "            data = value",
            "",
            "    if data:",
            "        data = json.dumps(data)",
            "    else:",
            "        # We need to set data to an empty string to prevent requests",
            "        # from assigning an empty list to `response.request.data`.",
            "        data = ''",
            "",
            "    return data",
            "",
            "",
            "def make_request_kwargs(",
            "    env: Environment,",
            "    args: argparse.Namespace,",
            "    base_headers: HTTPHeadersDict = None,",
            "    request_body_read_callback=lambda chunk: chunk",
            ") -> dict:",
            "    \"\"\"",
            "    Translate our `args` into `requests.Request` keyword arguments.",
            "",
            "    \"\"\"",
            "    files = args.files",
            "    # Serialize JSON data, if needed.",
            "    data = args.data",
            "    auto_json = data and not args.form",
            "    if (args.json or auto_json) and isinstance(data, dict):",
            "        data = json_dict_to_request_body(data)",
            "",
            "    # Finalize headers.",
            "    headers = make_default_headers(args)",
            "    if base_headers:",
            "        headers.update(base_headers)",
            "    headers.update(args.headers)",
            "    if args.offline and args.chunked and 'Transfer-Encoding' not in headers:",
            "        # When online, we let requests set the header instead to be able more",
            "        # easily verify chunking is taking place.",
            "        headers['Transfer-Encoding'] = 'chunked'",
            "    headers = finalize_headers(headers)",
            "",
            "    if (args.form and files) or args.multipart:",
            "        data, headers['Content-Type'] = get_multipart_data_and_content_type(",
            "            data=args.multipart_data,",
            "            boundary=args.boundary,",
            "            content_type=args.headers.get('Content-Type'),",
            "        )",
            "",
            "    return {",
            "        'method': args.method.lower(),",
            "        'url': args.url,",
            "        'headers': headers,",
            "        'data': prepare_request_body(",
            "            env,",
            "            data,",
            "            body_read_callback=request_body_read_callback,",
            "            chunked=args.chunked,",
            "            offline=args.offline,",
            "            content_length_header_value=headers.get('Content-Length'),",
            "        ),",
            "        'auth': args.auth,",
            "        'params': args.params.items(),",
            "    }",
            "",
            "",
            "def ensure_path_as_is(orig_url: str, prepped_url: str) -> str:",
            "    \"\"\"",
            "    Handle `--path-as-is` by replacing the path component of the prepared",
            "    URL with the path component from the original URL. Other parts stay",
            "    untouched because other (welcome) processing on the URL might have",
            "    taken place.",
            "",
            "    <https://github.com/httpie/httpie/issues/895>",
            "",
            "",
            "    <https://ec.haxx.se/http/http-basics#path-as-is>",
            "    <https://curl.haxx.se/libcurl/c/CURLOPT_PATH_AS_IS.html>",
            "",
            "    >>> ensure_path_as_is('http://foo/../', 'http://foo/?foo=bar')",
            "    'http://foo/../?foo=bar'",
            "",
            "    \"\"\"",
            "    parsed_orig, parsed_prepped = urlparse(orig_url), urlparse(prepped_url)",
            "    final_dict = {",
            "        # noinspection PyProtectedMember",
            "        **parsed_prepped._asdict(),",
            "        'path': parsed_orig.path,",
            "    }",
            "    return urlunparse(tuple(final_dict.values()))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "133": [
                "collect_messages"
            ],
            "134": [
                "collect_messages"
            ],
            "135": [
                "collect_messages"
            ],
            "136": [
                "collect_messages"
            ]
        },
        "addLocation": []
    },
    "httpie/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from pathlib import Path"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Union"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from typing import Any, Dict, Union"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from . import __version__"
            },
            "7": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from .compat import is_windows"
            },
            "8": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     pass"
            },
            "9": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+def read_raw_config(config_type: str, path: Path) -> Dict[str, Any]:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    try:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        with path.open(encoding=UTF8) as f:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            try:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                return json.load(f)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            except ValueError as e:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                raise ConfigFileError("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                    f'invalid {config_type} file: {e} [{path}]'"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                )"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+    except FileNotFoundError:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        pass"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    except OSError as e:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        raise ConfigFileError(f'cannot read {config_type} file: {e}')"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " class BaseConfigDict(dict):"
            },
            "27": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "     name = None"
            },
            "28": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     helpurl = None"
            },
            "29": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     def is_new(self) -> bool:"
            },
            "30": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         return not self.path.exists()"
            },
            "31": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    def pre_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        \"\"\"Hook for processing the incoming config data.\"\"\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        return data"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    def post_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        \"\"\"Hook for processing the outgoing config data.\"\"\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        return data"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     def load(self):"
            },
            "41": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         config_type = type(self).__name__.lower()"
            },
            "42": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "43": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            with self.path.open(encoding=UTF8) as f:"
            },
            "44": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "45": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    data = json.load(f)"
            },
            "46": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except ValueError as e:"
            },
            "47": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise ConfigFileError("
            },
            "48": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        f'invalid {config_type} file: {e} [{self.path}]'"
            },
            "49": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    )"
            },
            "50": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.update(data)"
            },
            "51": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except FileNotFoundError:"
            },
            "52": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            pass"
            },
            "53": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except OSError as e:"
            },
            "54": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ConfigFileError(f'cannot read {config_type} file: {e}')"
            },
            "55": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "56": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self):"
            },
            "57": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self['__meta__'] = {"
            },
            "58": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'httpie': __version__"
            },
            "59": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        }"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        data = read_raw_config(config_type, self.path)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        if data is not None:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            data = self.pre_process_data(data)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+            self.update(data)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+    def save(self, *, bump_version: bool = False):"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        self.setdefault('__meta__', {})"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        if bump_version or 'httpie' not in self['__meta__']:"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+            self['__meta__']['httpie'] = __version__"
            },
            "69": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         if self.helpurl:"
            },
            "70": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "             self['__meta__']['help'] = self.helpurl"
            },
            "71": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         self.ensure_directory()"
            },
            "73": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         json_string = json.dumps("
            },
            "75": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            obj=self,"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+            obj=self.post_process_data(self),"
            },
            "77": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "             indent=4,"
            },
            "78": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "             sort_keys=True,"
            },
            "79": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             ensure_ascii=True,"
            },
            "80": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         )"
            },
            "81": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         self.path.write_text(json_string + '\\n', encoding=UTF8)"
            },
            "82": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    @property"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    def version(self):"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        return self.get("
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+            '__meta__', {}"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        ).get('httpie', __version__)"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "90": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " class Config(BaseConfigDict):"
            },
            "91": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     FILENAME = 'config.json'"
            }
        },
        "frontPatchFile": [
            "import json",
            "import os",
            "from pathlib import Path",
            "from typing import Union",
            "",
            "from . import __version__",
            "from .compat import is_windows",
            "from .encoding import UTF8",
            "",
            "",
            "ENV_XDG_CONFIG_HOME = 'XDG_CONFIG_HOME'",
            "ENV_HTTPIE_CONFIG_DIR = 'HTTPIE_CONFIG_DIR'",
            "DEFAULT_CONFIG_DIRNAME = 'httpie'",
            "DEFAULT_RELATIVE_XDG_CONFIG_HOME = Path('.config')",
            "DEFAULT_RELATIVE_LEGACY_CONFIG_DIR = Path('.httpie')",
            "DEFAULT_WINDOWS_CONFIG_DIR = Path(",
            "    os.path.expandvars('%APPDATA%')) / DEFAULT_CONFIG_DIRNAME",
            "",
            "",
            "def get_default_config_dir() -> Path:",
            "    \"\"\"",
            "    Return the path to the httpie configuration directory.",
            "",
            "    This directory isn't guaranteed to exist, and nor are any of its",
            "    ancestors (only the legacy ~/.httpie, if returned, is guaranteed to exist).",
            "",
            "    XDG Base Directory Specification support:",
            "",
            "        <https://wiki.archlinux.org/index.php/XDG_Base_Directory>",
            "",
            "        $XDG_CONFIG_HOME is supported; $XDG_CONFIG_DIRS is not",
            "",
            "    \"\"\"",
            "    # 1. explicitly set through env",
            "    env_config_dir = os.environ.get(ENV_HTTPIE_CONFIG_DIR)",
            "    if env_config_dir:",
            "        return Path(env_config_dir)",
            "",
            "    # 2. Windows",
            "    if is_windows:",
            "        return DEFAULT_WINDOWS_CONFIG_DIR",
            "",
            "    home_dir = Path.home()",
            "",
            "    # 3. legacy ~/.httpie",
            "    legacy_config_dir = home_dir / DEFAULT_RELATIVE_LEGACY_CONFIG_DIR",
            "    if legacy_config_dir.exists():",
            "        return legacy_config_dir",
            "",
            "    # 4. XDG",
            "    xdg_config_home_dir = os.environ.get(",
            "        ENV_XDG_CONFIG_HOME,  # 4.1. explicit",
            "        home_dir / DEFAULT_RELATIVE_XDG_CONFIG_HOME  # 4.2. default",
            "    )",
            "    return Path(xdg_config_home_dir) / DEFAULT_CONFIG_DIRNAME",
            "",
            "",
            "DEFAULT_CONFIG_DIR = get_default_config_dir()",
            "",
            "",
            "class ConfigFileError(Exception):",
            "    pass",
            "",
            "",
            "class BaseConfigDict(dict):",
            "    name = None",
            "    helpurl = None",
            "    about = None",
            "",
            "    def __init__(self, path: Path):",
            "        super().__init__()",
            "        self.path = path",
            "",
            "    def ensure_directory(self):",
            "        self.path.parent.mkdir(mode=0o700, parents=True, exist_ok=True)",
            "",
            "    def is_new(self) -> bool:",
            "        return not self.path.exists()",
            "",
            "    def load(self):",
            "        config_type = type(self).__name__.lower()",
            "        try:",
            "            with self.path.open(encoding=UTF8) as f:",
            "                try:",
            "                    data = json.load(f)",
            "                except ValueError as e:",
            "                    raise ConfigFileError(",
            "                        f'invalid {config_type} file: {e} [{self.path}]'",
            "                    )",
            "                self.update(data)",
            "        except FileNotFoundError:",
            "            pass",
            "        except OSError as e:",
            "            raise ConfigFileError(f'cannot read {config_type} file: {e}')",
            "",
            "    def save(self):",
            "        self['__meta__'] = {",
            "            'httpie': __version__",
            "        }",
            "        if self.helpurl:",
            "            self['__meta__']['help'] = self.helpurl",
            "",
            "        if self.about:",
            "            self['__meta__']['about'] = self.about",
            "",
            "        self.ensure_directory()",
            "",
            "        json_string = json.dumps(",
            "            obj=self,",
            "            indent=4,",
            "            sort_keys=True,",
            "            ensure_ascii=True,",
            "        )",
            "        self.path.write_text(json_string + '\\n', encoding=UTF8)",
            "",
            "",
            "class Config(BaseConfigDict):",
            "    FILENAME = 'config.json'",
            "    DEFAULTS = {",
            "        'default_options': []",
            "    }",
            "",
            "    def __init__(self, directory: Union[str, Path] = DEFAULT_CONFIG_DIR):",
            "        self.directory = Path(directory)",
            "        super().__init__(path=self.directory / self.FILENAME)",
            "        self.update(self.DEFAULTS)",
            "",
            "    @property",
            "    def default_options(self) -> list:",
            "        return self['default_options']",
            "",
            "    @property",
            "    def plugins_dir(self) -> Path:",
            "        return Path(self.get('plugins_dir', self.directory / 'plugins')).resolve()"
        ],
        "afterPatchFile": [
            "import json",
            "import os",
            "from pathlib import Path",
            "from typing import Any, Dict, Union",
            "",
            "from . import __version__",
            "from .compat import is_windows",
            "from .encoding import UTF8",
            "",
            "",
            "ENV_XDG_CONFIG_HOME = 'XDG_CONFIG_HOME'",
            "ENV_HTTPIE_CONFIG_DIR = 'HTTPIE_CONFIG_DIR'",
            "DEFAULT_CONFIG_DIRNAME = 'httpie'",
            "DEFAULT_RELATIVE_XDG_CONFIG_HOME = Path('.config')",
            "DEFAULT_RELATIVE_LEGACY_CONFIG_DIR = Path('.httpie')",
            "DEFAULT_WINDOWS_CONFIG_DIR = Path(",
            "    os.path.expandvars('%APPDATA%')) / DEFAULT_CONFIG_DIRNAME",
            "",
            "",
            "def get_default_config_dir() -> Path:",
            "    \"\"\"",
            "    Return the path to the httpie configuration directory.",
            "",
            "    This directory isn't guaranteed to exist, and nor are any of its",
            "    ancestors (only the legacy ~/.httpie, if returned, is guaranteed to exist).",
            "",
            "    XDG Base Directory Specification support:",
            "",
            "        <https://wiki.archlinux.org/index.php/XDG_Base_Directory>",
            "",
            "        $XDG_CONFIG_HOME is supported; $XDG_CONFIG_DIRS is not",
            "",
            "    \"\"\"",
            "    # 1. explicitly set through env",
            "    env_config_dir = os.environ.get(ENV_HTTPIE_CONFIG_DIR)",
            "    if env_config_dir:",
            "        return Path(env_config_dir)",
            "",
            "    # 2. Windows",
            "    if is_windows:",
            "        return DEFAULT_WINDOWS_CONFIG_DIR",
            "",
            "    home_dir = Path.home()",
            "",
            "    # 3. legacy ~/.httpie",
            "    legacy_config_dir = home_dir / DEFAULT_RELATIVE_LEGACY_CONFIG_DIR",
            "    if legacy_config_dir.exists():",
            "        return legacy_config_dir",
            "",
            "    # 4. XDG",
            "    xdg_config_home_dir = os.environ.get(",
            "        ENV_XDG_CONFIG_HOME,  # 4.1. explicit",
            "        home_dir / DEFAULT_RELATIVE_XDG_CONFIG_HOME  # 4.2. default",
            "    )",
            "    return Path(xdg_config_home_dir) / DEFAULT_CONFIG_DIRNAME",
            "",
            "",
            "DEFAULT_CONFIG_DIR = get_default_config_dir()",
            "",
            "",
            "class ConfigFileError(Exception):",
            "    pass",
            "",
            "",
            "def read_raw_config(config_type: str, path: Path) -> Dict[str, Any]:",
            "    try:",
            "        with path.open(encoding=UTF8) as f:",
            "            try:",
            "                return json.load(f)",
            "            except ValueError as e:",
            "                raise ConfigFileError(",
            "                    f'invalid {config_type} file: {e} [{path}]'",
            "                )",
            "    except FileNotFoundError:",
            "        pass",
            "    except OSError as e:",
            "        raise ConfigFileError(f'cannot read {config_type} file: {e}')",
            "",
            "",
            "class BaseConfigDict(dict):",
            "    name = None",
            "    helpurl = None",
            "    about = None",
            "",
            "    def __init__(self, path: Path):",
            "        super().__init__()",
            "        self.path = path",
            "",
            "    def ensure_directory(self):",
            "        self.path.parent.mkdir(mode=0o700, parents=True, exist_ok=True)",
            "",
            "    def is_new(self) -> bool:",
            "        return not self.path.exists()",
            "",
            "    def pre_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Hook for processing the incoming config data.\"\"\"",
            "        return data",
            "",
            "    def post_process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Hook for processing the outgoing config data.\"\"\"",
            "        return data",
            "",
            "    def load(self):",
            "        config_type = type(self).__name__.lower()",
            "        data = read_raw_config(config_type, self.path)",
            "        if data is not None:",
            "            data = self.pre_process_data(data)",
            "            self.update(data)",
            "",
            "    def save(self, *, bump_version: bool = False):",
            "        self.setdefault('__meta__', {})",
            "        if bump_version or 'httpie' not in self['__meta__']:",
            "            self['__meta__']['httpie'] = __version__",
            "        if self.helpurl:",
            "            self['__meta__']['help'] = self.helpurl",
            "",
            "        if self.about:",
            "            self['__meta__']['about'] = self.about",
            "",
            "        self.ensure_directory()",
            "",
            "        json_string = json.dumps(",
            "            obj=self.post_process_data(self),",
            "            indent=4,",
            "            sort_keys=True,",
            "            ensure_ascii=True,",
            "        )",
            "        self.path.write_text(json_string + '\\n', encoding=UTF8)",
            "",
            "    @property",
            "    def version(self):",
            "        return self.get(",
            "            '__meta__', {}",
            "        ).get('httpie', __version__)",
            "",
            "",
            "class Config(BaseConfigDict):",
            "    FILENAME = 'config.json'",
            "    DEFAULTS = {",
            "        'default_options': []",
            "    }",
            "",
            "    def __init__(self, directory: Union[str, Path] = DEFAULT_CONFIG_DIR):",
            "        self.directory = Path(directory)",
            "        super().__init__(path=self.directory / self.FILENAME)",
            "        self.update(self.DEFAULTS)",
            "",
            "    @property",
            "    def default_options(self) -> list:",
            "        return self['default_options']",
            "",
            "    @property",
            "    def plugins_dir(self) -> Path:",
            "        return Path(self.get('plugins_dir', self.directory / 'plugins')).resolve()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": [],
            "82": [
                "BaseConfigDict",
                "load"
            ],
            "83": [
                "BaseConfigDict",
                "load"
            ],
            "84": [
                "BaseConfigDict",
                "load"
            ],
            "85": [
                "BaseConfigDict",
                "load"
            ],
            "86": [
                "BaseConfigDict",
                "load"
            ],
            "87": [
                "BaseConfigDict",
                "load"
            ],
            "88": [
                "BaseConfigDict",
                "load"
            ],
            "89": [
                "BaseConfigDict",
                "load"
            ],
            "90": [
                "BaseConfigDict",
                "load"
            ],
            "91": [
                "BaseConfigDict",
                "load"
            ],
            "92": [
                "BaseConfigDict",
                "load"
            ],
            "93": [
                "BaseConfigDict",
                "load"
            ],
            "94": [
                "BaseConfigDict",
                "load"
            ],
            "95": [
                "BaseConfigDict"
            ],
            "96": [
                "BaseConfigDict",
                "save"
            ],
            "97": [
                "BaseConfigDict",
                "save"
            ],
            "98": [
                "BaseConfigDict",
                "save"
            ],
            "99": [
                "BaseConfigDict",
                "save"
            ],
            "109": [
                "BaseConfigDict",
                "save"
            ]
        },
        "addLocation": []
    },
    "httpie/manager/cli.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from httpie.cli.argparser import HTTPieManagerArgumentParser"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from httpie import __version__"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+CLI_SESSION_UPGRADE_FLAGS = ["
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+    {"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+        'variadic': ['--bind-cookies'],"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+        'action': 'store_true',"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+        'default': False,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+        'help': 'Bind domainless cookies to the host that session belongs.'"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+    }"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " COMMANDS = {"
            },
            "13": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     'plugins': {"
            },
            "14": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "         'help': 'Manage HTTPie plugins.',"
            },
            "15": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "             'List all installed HTTPie plugins.'"
            },
            "16": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         ],"
            },
            "17": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     },"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    'cli': {"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        'help': 'Manage HTTPie for Terminal',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        'sessions': {"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            'help': 'Manage HTTPie sessions',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            'upgrade': ["
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+                'Upgrade the given HTTPie session with the latest '"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                'layout. A list of changes between different session versions '"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                'can be found in the official documentation.',"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                {"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                    'dest': 'hostname',"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+                    'metavar': 'HOSTNAME',"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+                    'help': 'The host this session belongs.'"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+                },"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+                {"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                    'dest': 'session',"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                    'metavar': 'SESSION_NAME_OR_PATH',"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+                    'help': 'The name or the path for the session that will be upgraded.'"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+                },"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                *CLI_SESSION_UPGRADE_FLAGS"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            ],"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            'upgrade-all': ["
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                'Upgrade all named sessions with the latest layout. A list of '"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                'changes between different session versions can be found in the official '"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                'documentation.',"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                *CLI_SESSION_UPGRADE_FLAGS"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            ],"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        }"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    }"
            },
            "46": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " }"
            },
            "47": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     )"
            },
            "50": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     for command, properties in definitions.items():"
            },
            "51": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         is_subparser = isinstance(properties, dict)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        properties = properties.copy()"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         descr = properties.pop('help', None) if is_subparser else properties.pop(0)"
            },
            "55": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         command_parser = actions.add_parser(command, description=descr)"
            },
            "56": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         command_parser.root = root"
            },
            "57": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "             continue"
            },
            "58": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         for argument in properties:"
            },
            "60": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            command_parser.add_argument(**argument)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            argument = argument.copy()"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            variadic = argument.pop('variadic', [])"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+            command_parser.add_argument(*variadic, **argument)"
            },
            "64": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " parser = HTTPieManagerArgumentParser("
            }
        },
        "frontPatchFile": [
            "from textwrap import dedent",
            "from httpie.cli.argparser import HTTPieManagerArgumentParser",
            "from httpie import __version__",
            "",
            "COMMANDS = {",
            "    'plugins': {",
            "        'help': 'Manage HTTPie plugins.',",
            "        'install': [",
            "            'Install the given targets from PyPI '",
            "            'or from a local paths.',",
            "            {",
            "                'dest': 'targets',",
            "                'nargs': '+',",
            "                'help': 'targets to install'",
            "            }",
            "        ],",
            "        'upgrade': [",
            "            'Upgrade the given plugins',",
            "            {",
            "                'dest': 'targets',",
            "                'nargs': '+',",
            "                'help': 'targets to upgrade'",
            "            }",
            "        ],",
            "        'uninstall': [",
            "            'Uninstall the given HTTPie plugins.',",
            "            {",
            "                'dest': 'targets',",
            "                'nargs': '+',",
            "                'help': 'targets to install'",
            "            }",
            "        ],",
            "        'list': [",
            "            'List all installed HTTPie plugins.'",
            "        ],",
            "    },",
            "}",
            "",
            "",
            "def missing_subcommand(*args) -> str:",
            "    base = COMMANDS",
            "    for arg in args:",
            "        base = base[arg]",
            "",
            "    assert isinstance(base, dict)",
            "    subcommands = ', '.join(map(repr, base.keys()))",
            "    return f'Please specify one of these: {subcommands}'",
            "",
            "",
            "def generate_subparsers(root, parent_parser, definitions):",
            "    action_dest = '_'.join(parent_parser.prog.split()[1:] + ['action'])",
            "    actions = parent_parser.add_subparsers(",
            "        dest=action_dest",
            "    )",
            "    for command, properties in definitions.items():",
            "        is_subparser = isinstance(properties, dict)",
            "        descr = properties.pop('help', None) if is_subparser else properties.pop(0)",
            "        command_parser = actions.add_parser(command, description=descr)",
            "        command_parser.root = root",
            "        if is_subparser:",
            "            generate_subparsers(root, command_parser, properties)",
            "            continue",
            "",
            "        for argument in properties:",
            "            command_parser.add_argument(**argument)",
            "",
            "",
            "parser = HTTPieManagerArgumentParser(",
            "    prog='httpie',",
            "    description=dedent(",
            "        '''",
            "        Managing interface for the HTTPie itself. <https://httpie.io/docs#manager>",
            "",
            "        Be aware that you might be looking for http/https commands for sending",
            "        HTTP requests. This command is only available for managing the HTTTPie",
            "        plugins and the configuration around it.",
            "        '''",
            "    ),",
            ")",
            "",
            "parser.add_argument(",
            "    '--debug',",
            "    action='store_true',",
            "    default=False,",
            "    help='''",
            "    Prints the exception traceback should one occur, as well as other",
            "    information useful for debugging HTTPie itself and for reporting bugs.",
            "",
            "    '''",
            ")",
            "",
            "parser.add_argument(",
            "    '--traceback',",
            "    action='store_true',",
            "    default=False,",
            "    help='''",
            "    Prints the exception traceback should one occur.",
            "",
            "    '''",
            ")",
            "",
            "parser.add_argument(",
            "    '--version',",
            "    action='version',",
            "    version=__version__,",
            "    help='''",
            "    Show version and exit.",
            "",
            "    '''",
            ")",
            "",
            "generate_subparsers(parser, parser, COMMANDS)"
        ],
        "afterPatchFile": [
            "from textwrap import dedent",
            "from httpie.cli.argparser import HTTPieManagerArgumentParser",
            "from httpie import __version__",
            "",
            "CLI_SESSION_UPGRADE_FLAGS = [",
            "    {",
            "        'variadic': ['--bind-cookies'],",
            "        'action': 'store_true',",
            "        'default': False,",
            "        'help': 'Bind domainless cookies to the host that session belongs.'",
            "    }",
            "]",
            "",
            "COMMANDS = {",
            "    'plugins': {",
            "        'help': 'Manage HTTPie plugins.',",
            "        'install': [",
            "            'Install the given targets from PyPI '",
            "            'or from a local paths.',",
            "            {",
            "                'dest': 'targets',",
            "                'nargs': '+',",
            "                'help': 'targets to install'",
            "            }",
            "        ],",
            "        'upgrade': [",
            "            'Upgrade the given plugins',",
            "            {",
            "                'dest': 'targets',",
            "                'nargs': '+',",
            "                'help': 'targets to upgrade'",
            "            }",
            "        ],",
            "        'uninstall': [",
            "            'Uninstall the given HTTPie plugins.',",
            "            {",
            "                'dest': 'targets',",
            "                'nargs': '+',",
            "                'help': 'targets to install'",
            "            }",
            "        ],",
            "        'list': [",
            "            'List all installed HTTPie plugins.'",
            "        ],",
            "    },",
            "    'cli': {",
            "        'help': 'Manage HTTPie for Terminal',",
            "        'sessions': {",
            "            'help': 'Manage HTTPie sessions',",
            "            'upgrade': [",
            "                'Upgrade the given HTTPie session with the latest '",
            "                'layout. A list of changes between different session versions '",
            "                'can be found in the official documentation.',",
            "                {",
            "                    'dest': 'hostname',",
            "                    'metavar': 'HOSTNAME',",
            "                    'help': 'The host this session belongs.'",
            "                },",
            "                {",
            "                    'dest': 'session',",
            "                    'metavar': 'SESSION_NAME_OR_PATH',",
            "                    'help': 'The name or the path for the session that will be upgraded.'",
            "                },",
            "                *CLI_SESSION_UPGRADE_FLAGS",
            "            ],",
            "            'upgrade-all': [",
            "                'Upgrade all named sessions with the latest layout. A list of '",
            "                'changes between different session versions can be found in the official '",
            "                'documentation.',",
            "                *CLI_SESSION_UPGRADE_FLAGS",
            "            ],",
            "        }",
            "    }",
            "}",
            "",
            "",
            "def missing_subcommand(*args) -> str:",
            "    base = COMMANDS",
            "    for arg in args:",
            "        base = base[arg]",
            "",
            "    assert isinstance(base, dict)",
            "    subcommands = ', '.join(map(repr, base.keys()))",
            "    return f'Please specify one of these: {subcommands}'",
            "",
            "",
            "def generate_subparsers(root, parent_parser, definitions):",
            "    action_dest = '_'.join(parent_parser.prog.split()[1:] + ['action'])",
            "    actions = parent_parser.add_subparsers(",
            "        dest=action_dest",
            "    )",
            "    for command, properties in definitions.items():",
            "        is_subparser = isinstance(properties, dict)",
            "        properties = properties.copy()",
            "",
            "        descr = properties.pop('help', None) if is_subparser else properties.pop(0)",
            "        command_parser = actions.add_parser(command, description=descr)",
            "        command_parser.root = root",
            "        if is_subparser:",
            "            generate_subparsers(root, command_parser, properties)",
            "            continue",
            "",
            "        for argument in properties:",
            "            argument = argument.copy()",
            "            variadic = argument.pop('variadic', [])",
            "            command_parser.add_argument(*variadic, **argument)",
            "",
            "",
            "parser = HTTPieManagerArgumentParser(",
            "    prog='httpie',",
            "    description=dedent(",
            "        '''",
            "        Managing interface for the HTTPie itself. <https://httpie.io/docs#manager>",
            "",
            "        Be aware that you might be looking for http/https commands for sending",
            "        HTTP requests. This command is only available for managing the HTTTPie",
            "        plugins and the configuration around it.",
            "        '''",
            "    ),",
            ")",
            "",
            "parser.add_argument(",
            "    '--debug',",
            "    action='store_true',",
            "    default=False,",
            "    help='''",
            "    Prints the exception traceback should one occur, as well as other",
            "    information useful for debugging HTTPie itself and for reporting bugs.",
            "",
            "    '''",
            ")",
            "",
            "parser.add_argument(",
            "    '--traceback',",
            "    action='store_true',",
            "    default=False,",
            "    help='''",
            "    Prints the exception traceback should one occur.",
            "",
            "    '''",
            ")",
            "",
            "parser.add_argument(",
            "    '--version',",
            "    action='version',",
            "    version=__version__,",
            "    help='''",
            "    Show version and exit.",
            "",
            "    '''",
            ")",
            "",
            "generate_subparsers(parser, parser, COMMANDS)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "65": [
                "generate_subparsers"
            ]
        },
        "addLocation": [
            "httpie.client",
            "httpie.manager.cli"
        ]
    },
    "httpie/manager/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import argparse"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from typing import Optional"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from httpie.context import Environment"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from httpie.manager.plugins import PluginInstaller"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from httpie.status import ExitStatus"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from httpie.manager.cli import missing_subcommand, parser"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from httpie.manager.tasks import CLI_TASKS"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " MSG_COMMAND_CONFUSION = '''\\"
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " This command is only for managing HTTPie plugins."
            },
            "11": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " '''.rstrip(\"\\n\").format(args='POST pie.dev/post hello=world')"
            },
            "12": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+def dispatch_cli_task(env: Environment, action: Optional[str], args: argparse.Namespace) -> ExitStatus:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    if action is None:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        parser.error(missing_subcommand('cli'))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    return CLI_TASKS[action](env, args)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " def program(args: argparse.Namespace, env: Environment) -> ExitStatus:"
            },
            "22": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     if args.action is None:"
            },
            "23": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         parser.error(MSG_NAKED_INVOCATION)"
            },
            "24": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     if args.action == 'plugins':"
            },
            "26": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         plugins = PluginInstaller(env, debug=args.debug)"
            },
            "27": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         return plugins.run(args.plugins_action, args)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    elif args.action == 'cli':"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        return dispatch_cli_task(env, args.cli_action, args)"
            },
            "30": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     return ExitStatus.SUCCESS"
            }
        },
        "frontPatchFile": [
            "import argparse",
            "",
            "from httpie.context import Environment",
            "from httpie.manager.plugins import PluginInstaller",
            "from httpie.status import ExitStatus",
            "from httpie.manager.cli import missing_subcommand, parser",
            "",
            "MSG_COMMAND_CONFUSION = '''\\",
            "This command is only for managing HTTPie plugins.",
            "To send a request, please use the http/https commands:",
            "",
            "  $ http {args}",
            "",
            "  $ https {args}",
            "'''",
            "",
            "# noinspection PyStringFormat",
            "MSG_NAKED_INVOCATION = f'''\\",
            "{missing_subcommand()}",
            "",
            "{MSG_COMMAND_CONFUSION}",
            "'''.rstrip(\"\\n\").format(args='POST pie.dev/post hello=world')",
            "",
            "",
            "def program(args: argparse.Namespace, env: Environment) -> ExitStatus:",
            "    if args.action is None:",
            "        parser.error(MSG_NAKED_INVOCATION)",
            "",
            "    if args.action == 'plugins':",
            "        plugins = PluginInstaller(env, debug=args.debug)",
            "        return plugins.run(args.plugins_action, args)",
            "",
            "    return ExitStatus.SUCCESS"
        ],
        "afterPatchFile": [
            "import argparse",
            "from typing import Optional",
            "",
            "from httpie.context import Environment",
            "from httpie.manager.plugins import PluginInstaller",
            "from httpie.status import ExitStatus",
            "from httpie.manager.cli import missing_subcommand, parser",
            "from httpie.manager.tasks import CLI_TASKS",
            "",
            "MSG_COMMAND_CONFUSION = '''\\",
            "This command is only for managing HTTPie plugins.",
            "To send a request, please use the http/https commands:",
            "",
            "  $ http {args}",
            "",
            "  $ https {args}",
            "'''",
            "",
            "# noinspection PyStringFormat",
            "MSG_NAKED_INVOCATION = f'''\\",
            "{missing_subcommand()}",
            "",
            "{MSG_COMMAND_CONFUSION}",
            "'''.rstrip(\"\\n\").format(args='POST pie.dev/post hello=world')",
            "",
            "",
            "def dispatch_cli_task(env: Environment, action: Optional[str], args: argparse.Namespace) -> ExitStatus:",
            "    if action is None:",
            "        parser.error(missing_subcommand('cli'))",
            "",
            "    return CLI_TASKS[action](env, args)",
            "",
            "",
            "def program(args: argparse.Namespace, env: Environment) -> ExitStatus:",
            "    if args.action is None:",
            "        parser.error(MSG_NAKED_INVOCATION)",
            "",
            "    if args.action == 'plugins':",
            "        plugins = PluginInstaller(env, debug=args.debug)",
            "        return plugins.run(args.plugins_action, args)",
            "    elif args.action == 'cli':",
            "        return dispatch_cli_task(env, args.cli_action, args)",
            "",
            "    return ExitStatus.SUCCESS"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "httpie.client",
            "httpie.manager.core.program"
        ]
    }
}