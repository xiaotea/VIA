{
    "superset/common/query_object.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     QueryClauseValidationException,"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     QueryObjectValidationError,"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from superset.sql_parse import validate_filter_clause"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from superset.sql_parse import sanitize_clause"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from superset.typing import Metric, OrderBy"
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from superset.utils import pandas_postprocessing"
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from superset.utils.core import ("
            },
            "8": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "         try:"
            },
            "9": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "             self._validate_there_are_no_missing_series()"
            },
            "10": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "             self._validate_no_have_duplicate_labels()"
            },
            "11": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._validate_filters()"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+            self._sanitize_filters()"
            },
            "13": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "             return None"
            },
            "14": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "         except QueryObjectValidationError as ex:"
            },
            "15": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "             if raise_exceptions:"
            },
            "16": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "                 )"
            },
            "17": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "             )"
            },
            "18": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 302,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _validate_filters(self) -> None:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+    def _sanitize_filters(self) -> None:"
            },
            "21": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "         for param in (\"where\", \"having\"):"
            },
            "22": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "             clause = self.extras.get(param)"
            },
            "23": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "             if clause:"
            },
            "24": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "                 try:"
            },
            "25": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    validate_filter_clause(clause)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+                    sanitized_clause = sanitize_clause(clause)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+                    if sanitized_clause != clause:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+                        self.extras[param] = sanitized_clause"
            },
            "29": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "                 except QueryClauseValidationException as ex:"
            },
            "30": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "                     raise QueryObjectValidationError(ex.message) from ex"
            },
            "31": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 313,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "# pylint: disable=invalid-name",
            "import logging",
            "from datetime import datetime, timedelta",
            "from typing import Any, Dict, List, NamedTuple, Optional, TYPE_CHECKING",
            "",
            "from flask_babel import gettext as _",
            "from pandas import DataFrame",
            "",
            "from superset import app, db",
            "from superset.connectors.base.models import BaseDatasource",
            "from superset.connectors.connector_registry import ConnectorRegistry",
            "from superset.exceptions import (",
            "    QueryClauseValidationException,",
            "    QueryObjectValidationError,",
            ")",
            "from superset.sql_parse import validate_filter_clause",
            "from superset.typing import Metric, OrderBy",
            "from superset.utils import pandas_postprocessing",
            "from superset.utils.core import (",
            "    apply_max_row_limit,",
            "    ChartDataResultType,",
            "    DatasourceDict,",
            "    DTTM_ALIAS,",
            "    find_duplicates,",
            "    get_metric_names,",
            "    is_adhoc_metric,",
            "    json_int_dttm_ser,",
            "    QueryObjectFilterClause,",
            ")",
            "from superset.utils.date_parser import get_since_until, parse_human_timedelta",
            "from superset.utils.hashing import md5_sha_from_dict",
            "from superset.views.utils import get_time_range_endpoints",
            "",
            "if TYPE_CHECKING:",
            "    from superset.common.query_context import QueryContext  # pragma: no cover",
            "",
            "",
            "config = app.config",
            "logger = logging.getLogger(__name__)",
            "",
            "# TODO: Type Metrics dictionary with TypedDict when it becomes a vanilla python type",
            "#  https://github.com/python/mypy/issues/5288",
            "",
            "",
            "class DeprecatedField(NamedTuple):",
            "    old_name: str",
            "    new_name: str",
            "",
            "",
            "DEPRECATED_FIELDS = (",
            "    DeprecatedField(old_name=\"granularity_sqla\", new_name=\"granularity\"),",
            "    DeprecatedField(old_name=\"groupby\", new_name=\"columns\"),",
            "    DeprecatedField(old_name=\"timeseries_limit\", new_name=\"series_limit\"),",
            "    DeprecatedField(old_name=\"timeseries_limit_metric\", new_name=\"series_limit_metric\"),",
            ")",
            "",
            "DEPRECATED_EXTRAS_FIELDS = (",
            "    DeprecatedField(old_name=\"where\", new_name=\"where\"),",
            "    DeprecatedField(old_name=\"having\", new_name=\"having\"),",
            "    DeprecatedField(old_name=\"having_filters\", new_name=\"having_druid\"),",
            "    DeprecatedField(old_name=\"druid_time_origin\", new_name=\"druid_time_origin\"),",
            ")",
            "",
            "",
            "class QueryObject:  # pylint: disable=too-many-instance-attributes",
            "    \"\"\"",
            "    The query object's schema matches the interfaces of DB connectors like sqla",
            "    and druid. The query objects are constructed on the client.",
            "    \"\"\"",
            "",
            "    annotation_layers: List[Dict[str, Any]]",
            "    applied_time_extras: Dict[str, str]",
            "    apply_fetch_values_predicate: bool",
            "    columns: List[str]",
            "    datasource: Optional[BaseDatasource]",
            "    extras: Dict[str, Any]",
            "    filter: List[QueryObjectFilterClause]",
            "    from_dttm: Optional[datetime]",
            "    granularity: Optional[str]",
            "    inner_from_dttm: Optional[datetime]",
            "    inner_to_dttm: Optional[datetime]",
            "    is_rowcount: bool",
            "    is_timeseries: bool",
            "    order_desc: bool",
            "    orderby: List[OrderBy]",
            "    metrics: Optional[List[Metric]]",
            "    result_type: Optional[ChartDataResultType]",
            "    row_limit: int",
            "    row_offset: int",
            "    series_columns: List[str]",
            "    series_limit: int",
            "    series_limit_metric: Optional[Metric]",
            "    time_offsets: List[str]",
            "    time_shift: Optional[timedelta]",
            "    to_dttm: Optional[datetime]",
            "    post_processing: List[Dict[str, Any]]",
            "",
            "    def __init__(  # pylint: disable=too-many-arguments,too-many-locals",
            "        self,",
            "        query_context: \"QueryContext\",",
            "        annotation_layers: Optional[List[Dict[str, Any]]] = None,",
            "        applied_time_extras: Optional[Dict[str, str]] = None,",
            "        apply_fetch_values_predicate: bool = False,",
            "        columns: Optional[List[str]] = None,",
            "        datasource: Optional[DatasourceDict] = None,",
            "        extras: Optional[Dict[str, Any]] = None,",
            "        filters: Optional[List[QueryObjectFilterClause]] = None,",
            "        granularity: Optional[str] = None,",
            "        is_rowcount: bool = False,",
            "        is_timeseries: Optional[bool] = None,",
            "        metrics: Optional[List[Metric]] = None,",
            "        order_desc: bool = True,",
            "        orderby: Optional[List[OrderBy]] = None,",
            "        post_processing: Optional[List[Optional[Dict[str, Any]]]] = None,",
            "        result_type: Optional[ChartDataResultType] = None,",
            "        row_limit: Optional[int] = None,",
            "        row_offset: Optional[int] = None,",
            "        series_columns: Optional[List[str]] = None,",
            "        series_limit: int = 0,",
            "        series_limit_metric: Optional[Metric] = None,",
            "        time_range: Optional[str] = None,",
            "        time_shift: Optional[str] = None,",
            "        **kwargs: Any,",
            "    ):",
            "        columns = columns or []",
            "        extras = extras or {}",
            "        annotation_layers = annotation_layers or []",
            "        self.time_offsets = kwargs.get(\"time_offsets\", [])",
            "        self.inner_from_dttm = kwargs.get(\"inner_from_dttm\")",
            "        self.inner_to_dttm = kwargs.get(\"inner_to_dttm\")",
            "        if series_columns:",
            "            self.series_columns = series_columns",
            "        elif is_timeseries and metrics:",
            "            self.series_columns = columns",
            "        else:",
            "            self.series_columns = []",
            "",
            "        self.is_rowcount = is_rowcount",
            "        self.datasource = None",
            "        if datasource:",
            "            self.datasource = ConnectorRegistry.get_datasource(",
            "                str(datasource[\"type\"]), int(datasource[\"id\"]), db.session",
            "            )",
            "        self.result_type = result_type or query_context.result_type",
            "        self.apply_fetch_values_predicate = apply_fetch_values_predicate or False",
            "        self.annotation_layers = [",
            "            layer",
            "            for layer in annotation_layers",
            "            # formula annotations don't affect the payload, hence can be dropped",
            "            if layer[\"annotationType\"] != \"FORMULA\"",
            "        ]",
            "        self.applied_time_extras = applied_time_extras or {}",
            "        self.granularity = granularity",
            "        self.from_dttm, self.to_dttm = get_since_until(",
            "            relative_start=extras.get(",
            "                \"relative_start\", config[\"DEFAULT_RELATIVE_START_TIME\"]",
            "            ),",
            "            relative_end=extras.get(",
            "                \"relative_end\", config[\"DEFAULT_RELATIVE_END_TIME\"]",
            "            ),",
            "            time_range=time_range,",
            "            time_shift=time_shift,",
            "        )",
            "        # is_timeseries is True if time column is in either columns or groupby",
            "        # (both are dimensions)",
            "        self.is_timeseries = (",
            "            is_timeseries if is_timeseries is not None else DTTM_ALIAS in columns",
            "        )",
            "        self.time_range = time_range",
            "        self.time_shift = parse_human_timedelta(time_shift)",
            "        self.post_processing = [",
            "            post_proc for post_proc in post_processing or [] if post_proc",
            "        ]",
            "",
            "        # Support metric reference/definition in the format of",
            "        #   1. 'metric_name'   - name of predefined metric",
            "        #   2. { label: 'label_name' }  - legacy format for a predefined metric",
            "        #   3. { expressionType: 'SIMPLE' | 'SQL', ... } - adhoc metric",
            "        self.metrics = metrics and [",
            "            x if isinstance(x, str) or is_adhoc_metric(x) else x[\"label\"]  # type: ignore",
            "            for x in metrics",
            "        ]",
            "",
            "        default_row_limit = (",
            "            config[\"SAMPLES_ROW_LIMIT\"]",
            "            if self.result_type == ChartDataResultType.SAMPLES",
            "            else config[\"ROW_LIMIT\"]",
            "        )",
            "        self.row_limit = apply_max_row_limit(row_limit or default_row_limit)",
            "        self.row_offset = row_offset or 0",
            "        self.filter = filters or []",
            "        self.series_limit = series_limit",
            "        self.series_limit_metric = series_limit_metric",
            "        self.order_desc = order_desc",
            "        self.extras = extras",
            "",
            "        if config[\"SIP_15_ENABLED\"]:",
            "            self.extras[\"time_range_endpoints\"] = get_time_range_endpoints(",
            "                form_data=self.extras",
            "            )",
            "",
            "        self.columns = columns",
            "        self.orderby = orderby or []",
            "",
            "        self._rename_deprecated_fields(kwargs)",
            "        self._move_deprecated_extra_fields(kwargs)",
            "",
            "    def _rename_deprecated_fields(self, kwargs: Dict[str, Any]) -> None:",
            "        # rename deprecated fields",
            "        for field in DEPRECATED_FIELDS:",
            "            if field.old_name in kwargs:",
            "                logger.warning(",
            "                    \"The field `%s` is deprecated, please use `%s` instead.\",",
            "                    field.old_name,",
            "                    field.new_name,",
            "                )",
            "                value = kwargs[field.old_name]",
            "                if value:",
            "                    if hasattr(self, field.new_name):",
            "                        logger.warning(",
            "                            \"The field `%s` is already populated, \"",
            "                            \"replacing value with contents from `%s`.\",",
            "                            field.new_name,",
            "                            field.old_name,",
            "                        )",
            "                    setattr(self, field.new_name, value)",
            "",
            "    def _move_deprecated_extra_fields(self, kwargs: Dict[str, Any]) -> None:",
            "        # move deprecated extras fields to extras",
            "        for field in DEPRECATED_EXTRAS_FIELDS:",
            "            if field.old_name in kwargs:",
            "                logger.warning(",
            "                    \"The field `%s` is deprecated and should \"",
            "                    \"be passed to `extras` via the `%s` property.\",",
            "                    field.old_name,",
            "                    field.new_name,",
            "                )",
            "                value = kwargs[field.old_name]",
            "                if value:",
            "                    if hasattr(self.extras, field.new_name):",
            "                        logger.warning(",
            "                            \"The field `%s` is already populated in \"",
            "                            \"`extras`, replacing value with contents \"",
            "                            \"from `%s`.\",",
            "                            field.new_name,",
            "                            field.old_name,",
            "                        )",
            "                    self.extras[field.new_name] = value",
            "",
            "    @property",
            "    def metric_names(self) -> List[str]:",
            "        \"\"\"Return metrics names (labels), coerce adhoc metrics to strings.\"\"\"",
            "        return get_metric_names(self.metrics or [])",
            "",
            "    @property",
            "    def column_names(self) -> List[str]:",
            "        \"\"\"Return column names (labels). Reserved for future adhoc calculated",
            "        columns.\"\"\"",
            "        return self.columns",
            "",
            "    def validate(",
            "        self, raise_exceptions: Optional[bool] = True",
            "    ) -> Optional[QueryObjectValidationError]:",
            "        \"\"\"Validate query object\"\"\"",
            "        try:",
            "            self._validate_there_are_no_missing_series()",
            "            self._validate_no_have_duplicate_labels()",
            "            self._validate_filters()",
            "            return None",
            "        except QueryObjectValidationError as ex:",
            "            if raise_exceptions:",
            "                raise ex",
            "            return ex",
            "",
            "    def _validate_no_have_duplicate_labels(self) -> None:",
            "        all_labels = self.metric_names + self.column_names",
            "        if len(set(all_labels)) < len(all_labels):",
            "            dup_labels = find_duplicates(all_labels)",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Duplicate column/metric labels: %(labels)s. Please make \"",
            "                    \"sure all columns and metrics have a unique label.\",",
            "                    labels=\", \".join(f'\"{x}\"' for x in dup_labels),",
            "                )",
            "            )",
            "",
            "    def _validate_filters(self) -> None:",
            "        for param in (\"where\", \"having\"):",
            "            clause = self.extras.get(param)",
            "            if clause:",
            "                try:",
            "                    validate_filter_clause(clause)",
            "                except QueryClauseValidationException as ex:",
            "                    raise QueryObjectValidationError(ex.message) from ex",
            "",
            "    def _validate_there_are_no_missing_series(self) -> None:",
            "        missing_series = [col for col in self.series_columns if col not in self.columns]",
            "        if missing_series:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"The following entries in `series_columns` are missing \"",
            "                    \"in `columns`: %(columns)s. \",",
            "                    columns=\", \".join(f'\"{x}\"' for x in missing_series),",
            "                )",
            "            )",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        query_object_dict = {",
            "            \"apply_fetch_values_predicate\": self.apply_fetch_values_predicate,",
            "            \"columns\": self.columns,",
            "            \"extras\": self.extras,",
            "            \"filter\": self.filter,",
            "            \"from_dttm\": self.from_dttm,",
            "            \"granularity\": self.granularity,",
            "            \"inner_from_dttm\": self.inner_from_dttm,",
            "            \"inner_to_dttm\": self.inner_to_dttm,",
            "            \"is_rowcount\": self.is_rowcount,",
            "            \"is_timeseries\": self.is_timeseries,",
            "            \"metrics\": self.metrics,",
            "            \"order_desc\": self.order_desc,",
            "            \"orderby\": self.orderby,",
            "            \"row_limit\": self.row_limit,",
            "            \"row_offset\": self.row_offset,",
            "            \"series_columns\": self.series_columns,",
            "            \"series_limit\": self.series_limit,",
            "            \"series_limit_metric\": self.series_limit_metric,",
            "            \"to_dttm\": self.to_dttm,",
            "        }",
            "        return query_object_dict",
            "",
            "    def cache_key(self, **extra: Any) -> str:",
            "        \"\"\"",
            "        The cache key is made out of the key/values from to_dict(), plus any",
            "        other key/values in `extra`",
            "        We remove datetime bounds that are hard values, and replace them with",
            "        the use-provided inputs to bounds, which may be time-relative (as in",
            "        \"5 days ago\" or \"now\").",
            "        \"\"\"",
            "        cache_dict = self.to_dict()",
            "        cache_dict.update(extra)",
            "",
            "        # TODO: the below KVs can all be cleaned up and moved to `to_dict()` at some",
            "        #  predetermined point in time when orgs are aware that the previously",
            "        #  chached results will be invalidated.",
            "        if not self.apply_fetch_values_predicate:",
            "            del cache_dict[\"apply_fetch_values_predicate\"]",
            "        if self.datasource:",
            "            cache_dict[\"datasource\"] = self.datasource.uid",
            "        if self.result_type:",
            "            cache_dict[\"result_type\"] = self.result_type",
            "        if self.time_range:",
            "            cache_dict[\"time_range\"] = self.time_range",
            "        if self.post_processing:",
            "            cache_dict[\"post_processing\"] = self.post_processing",
            "        if self.time_offsets:",
            "            cache_dict[\"time_offsets\"] = self.time_offsets",
            "",
            "        for k in [\"from_dttm\", \"to_dttm\"]:",
            "            del cache_dict[k]",
            "",
            "        annotation_fields = [",
            "            \"annotationType\",",
            "            \"descriptionColumns\",",
            "            \"intervalEndColumn\",",
            "            \"name\",",
            "            \"overrides\",",
            "            \"sourceType\",",
            "            \"timeColumn\",",
            "            \"titleColumn\",",
            "            \"value\",",
            "        ]",
            "        annotation_layers = [",
            "            {field: layer[field] for field in annotation_fields if field in layer}",
            "            for layer in self.annotation_layers",
            "        ]",
            "        # only add to key if there are annotations present that affect the payload",
            "        if annotation_layers:",
            "            cache_dict[\"annotation_layers\"] = annotation_layers",
            "",
            "        return md5_sha_from_dict(cache_dict, default=json_int_dttm_ser, ignore_nan=True)",
            "",
            "    def exec_post_processing(self, df: DataFrame) -> DataFrame:",
            "        \"\"\"",
            "        Perform post processing operations on DataFrame.",
            "",
            "        :param df: DataFrame returned from database model.",
            "        :return: new DataFrame to which all post processing operations have been",
            "                 applied",
            "        :raises QueryObjectValidationError: If the post processing operation",
            "                 is incorrect",
            "        \"\"\"",
            "        for post_process in self.post_processing:",
            "            operation = post_process.get(\"operation\")",
            "            if not operation:",
            "                raise QueryObjectValidationError(",
            "                    _(\"`operation` property of post processing object undefined\")",
            "                )",
            "            if not hasattr(pandas_postprocessing, operation):",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"Unsupported post processing operation: %(operation)s\",",
            "                        type=operation,",
            "                    )",
            "                )",
            "            options = post_process.get(\"options\", {})",
            "            df = getattr(pandas_postprocessing, operation)(df, **options)",
            "        return df"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "# pylint: disable=invalid-name",
            "import logging",
            "from datetime import datetime, timedelta",
            "from typing import Any, Dict, List, NamedTuple, Optional, TYPE_CHECKING",
            "",
            "from flask_babel import gettext as _",
            "from pandas import DataFrame",
            "",
            "from superset import app, db",
            "from superset.connectors.base.models import BaseDatasource",
            "from superset.connectors.connector_registry import ConnectorRegistry",
            "from superset.exceptions import (",
            "    QueryClauseValidationException,",
            "    QueryObjectValidationError,",
            ")",
            "from superset.sql_parse import sanitize_clause",
            "from superset.typing import Metric, OrderBy",
            "from superset.utils import pandas_postprocessing",
            "from superset.utils.core import (",
            "    apply_max_row_limit,",
            "    ChartDataResultType,",
            "    DatasourceDict,",
            "    DTTM_ALIAS,",
            "    find_duplicates,",
            "    get_metric_names,",
            "    is_adhoc_metric,",
            "    json_int_dttm_ser,",
            "    QueryObjectFilterClause,",
            ")",
            "from superset.utils.date_parser import get_since_until, parse_human_timedelta",
            "from superset.utils.hashing import md5_sha_from_dict",
            "from superset.views.utils import get_time_range_endpoints",
            "",
            "if TYPE_CHECKING:",
            "    from superset.common.query_context import QueryContext  # pragma: no cover",
            "",
            "",
            "config = app.config",
            "logger = logging.getLogger(__name__)",
            "",
            "# TODO: Type Metrics dictionary with TypedDict when it becomes a vanilla python type",
            "#  https://github.com/python/mypy/issues/5288",
            "",
            "",
            "class DeprecatedField(NamedTuple):",
            "    old_name: str",
            "    new_name: str",
            "",
            "",
            "DEPRECATED_FIELDS = (",
            "    DeprecatedField(old_name=\"granularity_sqla\", new_name=\"granularity\"),",
            "    DeprecatedField(old_name=\"groupby\", new_name=\"columns\"),",
            "    DeprecatedField(old_name=\"timeseries_limit\", new_name=\"series_limit\"),",
            "    DeprecatedField(old_name=\"timeseries_limit_metric\", new_name=\"series_limit_metric\"),",
            ")",
            "",
            "DEPRECATED_EXTRAS_FIELDS = (",
            "    DeprecatedField(old_name=\"where\", new_name=\"where\"),",
            "    DeprecatedField(old_name=\"having\", new_name=\"having\"),",
            "    DeprecatedField(old_name=\"having_filters\", new_name=\"having_druid\"),",
            "    DeprecatedField(old_name=\"druid_time_origin\", new_name=\"druid_time_origin\"),",
            ")",
            "",
            "",
            "class QueryObject:  # pylint: disable=too-many-instance-attributes",
            "    \"\"\"",
            "    The query object's schema matches the interfaces of DB connectors like sqla",
            "    and druid. The query objects are constructed on the client.",
            "    \"\"\"",
            "",
            "    annotation_layers: List[Dict[str, Any]]",
            "    applied_time_extras: Dict[str, str]",
            "    apply_fetch_values_predicate: bool",
            "    columns: List[str]",
            "    datasource: Optional[BaseDatasource]",
            "    extras: Dict[str, Any]",
            "    filter: List[QueryObjectFilterClause]",
            "    from_dttm: Optional[datetime]",
            "    granularity: Optional[str]",
            "    inner_from_dttm: Optional[datetime]",
            "    inner_to_dttm: Optional[datetime]",
            "    is_rowcount: bool",
            "    is_timeseries: bool",
            "    order_desc: bool",
            "    orderby: List[OrderBy]",
            "    metrics: Optional[List[Metric]]",
            "    result_type: Optional[ChartDataResultType]",
            "    row_limit: int",
            "    row_offset: int",
            "    series_columns: List[str]",
            "    series_limit: int",
            "    series_limit_metric: Optional[Metric]",
            "    time_offsets: List[str]",
            "    time_shift: Optional[timedelta]",
            "    to_dttm: Optional[datetime]",
            "    post_processing: List[Dict[str, Any]]",
            "",
            "    def __init__(  # pylint: disable=too-many-arguments,too-many-locals",
            "        self,",
            "        query_context: \"QueryContext\",",
            "        annotation_layers: Optional[List[Dict[str, Any]]] = None,",
            "        applied_time_extras: Optional[Dict[str, str]] = None,",
            "        apply_fetch_values_predicate: bool = False,",
            "        columns: Optional[List[str]] = None,",
            "        datasource: Optional[DatasourceDict] = None,",
            "        extras: Optional[Dict[str, Any]] = None,",
            "        filters: Optional[List[QueryObjectFilterClause]] = None,",
            "        granularity: Optional[str] = None,",
            "        is_rowcount: bool = False,",
            "        is_timeseries: Optional[bool] = None,",
            "        metrics: Optional[List[Metric]] = None,",
            "        order_desc: bool = True,",
            "        orderby: Optional[List[OrderBy]] = None,",
            "        post_processing: Optional[List[Optional[Dict[str, Any]]]] = None,",
            "        result_type: Optional[ChartDataResultType] = None,",
            "        row_limit: Optional[int] = None,",
            "        row_offset: Optional[int] = None,",
            "        series_columns: Optional[List[str]] = None,",
            "        series_limit: int = 0,",
            "        series_limit_metric: Optional[Metric] = None,",
            "        time_range: Optional[str] = None,",
            "        time_shift: Optional[str] = None,",
            "        **kwargs: Any,",
            "    ):",
            "        columns = columns or []",
            "        extras = extras or {}",
            "        annotation_layers = annotation_layers or []",
            "        self.time_offsets = kwargs.get(\"time_offsets\", [])",
            "        self.inner_from_dttm = kwargs.get(\"inner_from_dttm\")",
            "        self.inner_to_dttm = kwargs.get(\"inner_to_dttm\")",
            "        if series_columns:",
            "            self.series_columns = series_columns",
            "        elif is_timeseries and metrics:",
            "            self.series_columns = columns",
            "        else:",
            "            self.series_columns = []",
            "",
            "        self.is_rowcount = is_rowcount",
            "        self.datasource = None",
            "        if datasource:",
            "            self.datasource = ConnectorRegistry.get_datasource(",
            "                str(datasource[\"type\"]), int(datasource[\"id\"]), db.session",
            "            )",
            "        self.result_type = result_type or query_context.result_type",
            "        self.apply_fetch_values_predicate = apply_fetch_values_predicate or False",
            "        self.annotation_layers = [",
            "            layer",
            "            for layer in annotation_layers",
            "            # formula annotations don't affect the payload, hence can be dropped",
            "            if layer[\"annotationType\"] != \"FORMULA\"",
            "        ]",
            "        self.applied_time_extras = applied_time_extras or {}",
            "        self.granularity = granularity",
            "        self.from_dttm, self.to_dttm = get_since_until(",
            "            relative_start=extras.get(",
            "                \"relative_start\", config[\"DEFAULT_RELATIVE_START_TIME\"]",
            "            ),",
            "            relative_end=extras.get(",
            "                \"relative_end\", config[\"DEFAULT_RELATIVE_END_TIME\"]",
            "            ),",
            "            time_range=time_range,",
            "            time_shift=time_shift,",
            "        )",
            "        # is_timeseries is True if time column is in either columns or groupby",
            "        # (both are dimensions)",
            "        self.is_timeseries = (",
            "            is_timeseries if is_timeseries is not None else DTTM_ALIAS in columns",
            "        )",
            "        self.time_range = time_range",
            "        self.time_shift = parse_human_timedelta(time_shift)",
            "        self.post_processing = [",
            "            post_proc for post_proc in post_processing or [] if post_proc",
            "        ]",
            "",
            "        # Support metric reference/definition in the format of",
            "        #   1. 'metric_name'   - name of predefined metric",
            "        #   2. { label: 'label_name' }  - legacy format for a predefined metric",
            "        #   3. { expressionType: 'SIMPLE' | 'SQL', ... } - adhoc metric",
            "        self.metrics = metrics and [",
            "            x if isinstance(x, str) or is_adhoc_metric(x) else x[\"label\"]  # type: ignore",
            "            for x in metrics",
            "        ]",
            "",
            "        default_row_limit = (",
            "            config[\"SAMPLES_ROW_LIMIT\"]",
            "            if self.result_type == ChartDataResultType.SAMPLES",
            "            else config[\"ROW_LIMIT\"]",
            "        )",
            "        self.row_limit = apply_max_row_limit(row_limit or default_row_limit)",
            "        self.row_offset = row_offset or 0",
            "        self.filter = filters or []",
            "        self.series_limit = series_limit",
            "        self.series_limit_metric = series_limit_metric",
            "        self.order_desc = order_desc",
            "        self.extras = extras",
            "",
            "        if config[\"SIP_15_ENABLED\"]:",
            "            self.extras[\"time_range_endpoints\"] = get_time_range_endpoints(",
            "                form_data=self.extras",
            "            )",
            "",
            "        self.columns = columns",
            "        self.orderby = orderby or []",
            "",
            "        self._rename_deprecated_fields(kwargs)",
            "        self._move_deprecated_extra_fields(kwargs)",
            "",
            "    def _rename_deprecated_fields(self, kwargs: Dict[str, Any]) -> None:",
            "        # rename deprecated fields",
            "        for field in DEPRECATED_FIELDS:",
            "            if field.old_name in kwargs:",
            "                logger.warning(",
            "                    \"The field `%s` is deprecated, please use `%s` instead.\",",
            "                    field.old_name,",
            "                    field.new_name,",
            "                )",
            "                value = kwargs[field.old_name]",
            "                if value:",
            "                    if hasattr(self, field.new_name):",
            "                        logger.warning(",
            "                            \"The field `%s` is already populated, \"",
            "                            \"replacing value with contents from `%s`.\",",
            "                            field.new_name,",
            "                            field.old_name,",
            "                        )",
            "                    setattr(self, field.new_name, value)",
            "",
            "    def _move_deprecated_extra_fields(self, kwargs: Dict[str, Any]) -> None:",
            "        # move deprecated extras fields to extras",
            "        for field in DEPRECATED_EXTRAS_FIELDS:",
            "            if field.old_name in kwargs:",
            "                logger.warning(",
            "                    \"The field `%s` is deprecated and should \"",
            "                    \"be passed to `extras` via the `%s` property.\",",
            "                    field.old_name,",
            "                    field.new_name,",
            "                )",
            "                value = kwargs[field.old_name]",
            "                if value:",
            "                    if hasattr(self.extras, field.new_name):",
            "                        logger.warning(",
            "                            \"The field `%s` is already populated in \"",
            "                            \"`extras`, replacing value with contents \"",
            "                            \"from `%s`.\",",
            "                            field.new_name,",
            "                            field.old_name,",
            "                        )",
            "                    self.extras[field.new_name] = value",
            "",
            "    @property",
            "    def metric_names(self) -> List[str]:",
            "        \"\"\"Return metrics names (labels), coerce adhoc metrics to strings.\"\"\"",
            "        return get_metric_names(self.metrics or [])",
            "",
            "    @property",
            "    def column_names(self) -> List[str]:",
            "        \"\"\"Return column names (labels). Reserved for future adhoc calculated",
            "        columns.\"\"\"",
            "        return self.columns",
            "",
            "    def validate(",
            "        self, raise_exceptions: Optional[bool] = True",
            "    ) -> Optional[QueryObjectValidationError]:",
            "        \"\"\"Validate query object\"\"\"",
            "        try:",
            "            self._validate_there_are_no_missing_series()",
            "            self._validate_no_have_duplicate_labels()",
            "            self._sanitize_filters()",
            "            return None",
            "        except QueryObjectValidationError as ex:",
            "            if raise_exceptions:",
            "                raise ex",
            "            return ex",
            "",
            "    def _validate_no_have_duplicate_labels(self) -> None:",
            "        all_labels = self.metric_names + self.column_names",
            "        if len(set(all_labels)) < len(all_labels):",
            "            dup_labels = find_duplicates(all_labels)",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Duplicate column/metric labels: %(labels)s. Please make \"",
            "                    \"sure all columns and metrics have a unique label.\",",
            "                    labels=\", \".join(f'\"{x}\"' for x in dup_labels),",
            "                )",
            "            )",
            "",
            "    def _sanitize_filters(self) -> None:",
            "        for param in (\"where\", \"having\"):",
            "            clause = self.extras.get(param)",
            "            if clause:",
            "                try:",
            "                    sanitized_clause = sanitize_clause(clause)",
            "                    if sanitized_clause != clause:",
            "                        self.extras[param] = sanitized_clause",
            "                except QueryClauseValidationException as ex:",
            "                    raise QueryObjectValidationError(ex.message) from ex",
            "",
            "    def _validate_there_are_no_missing_series(self) -> None:",
            "        missing_series = [col for col in self.series_columns if col not in self.columns]",
            "        if missing_series:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"The following entries in `series_columns` are missing \"",
            "                    \"in `columns`: %(columns)s. \",",
            "                    columns=\", \".join(f'\"{x}\"' for x in missing_series),",
            "                )",
            "            )",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        query_object_dict = {",
            "            \"apply_fetch_values_predicate\": self.apply_fetch_values_predicate,",
            "            \"columns\": self.columns,",
            "            \"extras\": self.extras,",
            "            \"filter\": self.filter,",
            "            \"from_dttm\": self.from_dttm,",
            "            \"granularity\": self.granularity,",
            "            \"inner_from_dttm\": self.inner_from_dttm,",
            "            \"inner_to_dttm\": self.inner_to_dttm,",
            "            \"is_rowcount\": self.is_rowcount,",
            "            \"is_timeseries\": self.is_timeseries,",
            "            \"metrics\": self.metrics,",
            "            \"order_desc\": self.order_desc,",
            "            \"orderby\": self.orderby,",
            "            \"row_limit\": self.row_limit,",
            "            \"row_offset\": self.row_offset,",
            "            \"series_columns\": self.series_columns,",
            "            \"series_limit\": self.series_limit,",
            "            \"series_limit_metric\": self.series_limit_metric,",
            "            \"to_dttm\": self.to_dttm,",
            "        }",
            "        return query_object_dict",
            "",
            "    def cache_key(self, **extra: Any) -> str:",
            "        \"\"\"",
            "        The cache key is made out of the key/values from to_dict(), plus any",
            "        other key/values in `extra`",
            "        We remove datetime bounds that are hard values, and replace them with",
            "        the use-provided inputs to bounds, which may be time-relative (as in",
            "        \"5 days ago\" or \"now\").",
            "        \"\"\"",
            "        cache_dict = self.to_dict()",
            "        cache_dict.update(extra)",
            "",
            "        # TODO: the below KVs can all be cleaned up and moved to `to_dict()` at some",
            "        #  predetermined point in time when orgs are aware that the previously",
            "        #  chached results will be invalidated.",
            "        if not self.apply_fetch_values_predicate:",
            "            del cache_dict[\"apply_fetch_values_predicate\"]",
            "        if self.datasource:",
            "            cache_dict[\"datasource\"] = self.datasource.uid",
            "        if self.result_type:",
            "            cache_dict[\"result_type\"] = self.result_type",
            "        if self.time_range:",
            "            cache_dict[\"time_range\"] = self.time_range",
            "        if self.post_processing:",
            "            cache_dict[\"post_processing\"] = self.post_processing",
            "        if self.time_offsets:",
            "            cache_dict[\"time_offsets\"] = self.time_offsets",
            "",
            "        for k in [\"from_dttm\", \"to_dttm\"]:",
            "            del cache_dict[k]",
            "",
            "        annotation_fields = [",
            "            \"annotationType\",",
            "            \"descriptionColumns\",",
            "            \"intervalEndColumn\",",
            "            \"name\",",
            "            \"overrides\",",
            "            \"sourceType\",",
            "            \"timeColumn\",",
            "            \"titleColumn\",",
            "            \"value\",",
            "        ]",
            "        annotation_layers = [",
            "            {field: layer[field] for field in annotation_fields if field in layer}",
            "            for layer in self.annotation_layers",
            "        ]",
            "        # only add to key if there are annotations present that affect the payload",
            "        if annotation_layers:",
            "            cache_dict[\"annotation_layers\"] = annotation_layers",
            "",
            "        return md5_sha_from_dict(cache_dict, default=json_int_dttm_ser, ignore_nan=True)",
            "",
            "    def exec_post_processing(self, df: DataFrame) -> DataFrame:",
            "        \"\"\"",
            "        Perform post processing operations on DataFrame.",
            "",
            "        :param df: DataFrame returned from database model.",
            "        :return: new DataFrame to which all post processing operations have been",
            "                 applied",
            "        :raises QueryObjectValidationError: If the post processing operation",
            "                 is incorrect",
            "        \"\"\"",
            "        for post_process in self.post_processing:",
            "            operation = post_process.get(\"operation\")",
            "            if not operation:",
            "                raise QueryObjectValidationError(",
            "                    _(\"`operation` property of post processing object undefined\")",
            "                )",
            "            if not hasattr(pandas_postprocessing, operation):",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"Unsupported post processing operation: %(operation)s\",",
            "                        type=operation,",
            "                    )",
            "                )",
            "            options = post_process.get(\"options\", {})",
            "            df = getattr(pandas_postprocessing, operation)(df, **options)",
            "        return df"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "32": [],
            "284": [
                "QueryObject",
                "validate"
            ],
            "303": [
                "QueryObject",
                "_validate_filters"
            ],
            "308": [
                "QueryObject",
                "_validate_filters"
            ]
        },
        "addLocation": []
    },
    "superset/connectors/sqla/models.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     get_virtual_table_metadata,"
            },
            "1": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " )"
            },
            "2": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " from superset.db_engine_specs.base import BaseEngineSpec, TimestampExpression"
            },
            "3": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from superset.exceptions import QueryObjectValidationError"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+from superset.exceptions import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    QueryClauseValidationException,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+    QueryObjectValidationError,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+)"
            },
            "8": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " from superset.jinja_context import ("
            },
            "9": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     BaseTemplateProcessor,"
            },
            "10": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     ExtraCache,"
            },
            "11": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " from superset.models.annotations import Annotation"
            },
            "12": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " from superset.models.core import Database"
            },
            "13": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " from superset.models.helpers import AuditMixinNullable, CertificationMixin, QueryResult"
            },
            "14": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from superset.sql_parse import ParsedQuery"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+from superset.sql_parse import ParsedQuery, sanitize_clause"
            },
            "16": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " from superset.typing import AdhocMetric, Metric, OrderBy, QueryObjectDict"
            },
            "17": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " from superset.utils import core as utils"
            },
            "18": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " from superset.utils.core import ("
            },
            "19": {
                "beforePatchRowNumber": 858,
                "afterPatchRowNumber": 861,
                "PatchRowcode": "         elif expression_type == utils.AdhocMetricExpressionType.SQL:"
            },
            "20": {
                "beforePatchRowNumber": 859,
                "afterPatchRowNumber": 862,
                "PatchRowcode": "             tp = self.get_template_processor()"
            },
            "21": {
                "beforePatchRowNumber": 860,
                "afterPatchRowNumber": 863,
                "PatchRowcode": "             expression = tp.process_template(cast(str, metric[\"sqlExpression\"]))"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 864,
                "PatchRowcode": "+            try:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 865,
                "PatchRowcode": "+                expression = sanitize_clause(expression)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 866,
                "PatchRowcode": "+            except QueryClauseValidationException as ex:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 867,
                "PatchRowcode": "+                raise QueryObjectValidationError(ex.message) from ex"
            },
            "26": {
                "beforePatchRowNumber": 861,
                "afterPatchRowNumber": 868,
                "PatchRowcode": "             sqla_metric = literal_column(expression)"
            },
            "27": {
                "beforePatchRowNumber": 862,
                "afterPatchRowNumber": 869,
                "PatchRowcode": "         else:"
            },
            "28": {
                "beforePatchRowNumber": 863,
                "afterPatchRowNumber": 870,
                "PatchRowcode": "             raise QueryObjectValidationError(\"Adhoc metric expressionType is invalid\")"
            },
            "29": {
                "beforePatchRowNumber": 1265,
                "afterPatchRowNumber": 1272,
                "PatchRowcode": "             where = extras.get(\"where\")"
            },
            "30": {
                "beforePatchRowNumber": 1266,
                "afterPatchRowNumber": 1273,
                "PatchRowcode": "             if where:"
            },
            "31": {
                "beforePatchRowNumber": 1267,
                "afterPatchRowNumber": 1274,
                "PatchRowcode": "                 try:"
            },
            "32": {
                "beforePatchRowNumber": 1268,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    where = template_processor.process_template(where)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1275,
                "PatchRowcode": "+                    where = template_processor.process_template(f\"({where})\")"
            },
            "34": {
                "beforePatchRowNumber": 1269,
                "afterPatchRowNumber": 1276,
                "PatchRowcode": "                 except TemplateError as ex:"
            },
            "35": {
                "beforePatchRowNumber": 1270,
                "afterPatchRowNumber": 1277,
                "PatchRowcode": "                     raise QueryObjectValidationError("
            },
            "36": {
                "beforePatchRowNumber": 1271,
                "afterPatchRowNumber": 1278,
                "PatchRowcode": "                         _("
            },
            "37": {
                "beforePatchRowNumber": 1272,
                "afterPatchRowNumber": 1279,
                "PatchRowcode": "                             \"Error in jinja expression in WHERE clause: %(msg)s\","
            },
            "38": {
                "beforePatchRowNumber": 1273,
                "afterPatchRowNumber": 1280,
                "PatchRowcode": "                             msg=ex.message,"
            },
            "39": {
                "beforePatchRowNumber": 1274,
                "afterPatchRowNumber": 1281,
                "PatchRowcode": "                         )"
            },
            "40": {
                "beforePatchRowNumber": 1275,
                "afterPatchRowNumber": 1282,
                "PatchRowcode": "                     ) from ex"
            },
            "41": {
                "beforePatchRowNumber": 1276,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                where_clause_and += [text(f\"({where})\")]"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1283,
                "PatchRowcode": "+                where_clause_and += [self.text(where)]"
            },
            "43": {
                "beforePatchRowNumber": 1277,
                "afterPatchRowNumber": 1284,
                "PatchRowcode": "             having = extras.get(\"having\")"
            },
            "44": {
                "beforePatchRowNumber": 1278,
                "afterPatchRowNumber": 1285,
                "PatchRowcode": "             if having:"
            },
            "45": {
                "beforePatchRowNumber": 1279,
                "afterPatchRowNumber": 1286,
                "PatchRowcode": "                 try:"
            },
            "46": {
                "beforePatchRowNumber": 1280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    having = template_processor.process_template(having)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1287,
                "PatchRowcode": "+                    having = template_processor.process_template(f\"({having})\")"
            },
            "48": {
                "beforePatchRowNumber": 1281,
                "afterPatchRowNumber": 1288,
                "PatchRowcode": "                 except TemplateError as ex:"
            },
            "49": {
                "beforePatchRowNumber": 1282,
                "afterPatchRowNumber": 1289,
                "PatchRowcode": "                     raise QueryObjectValidationError("
            },
            "50": {
                "beforePatchRowNumber": 1283,
                "afterPatchRowNumber": 1290,
                "PatchRowcode": "                         _("
            },
            "51": {
                "beforePatchRowNumber": 1284,
                "afterPatchRowNumber": 1291,
                "PatchRowcode": "                             \"Error in jinja expression in HAVING clause: %(msg)s\","
            },
            "52": {
                "beforePatchRowNumber": 1285,
                "afterPatchRowNumber": 1292,
                "PatchRowcode": "                             msg=ex.message,"
            },
            "53": {
                "beforePatchRowNumber": 1286,
                "afterPatchRowNumber": 1293,
                "PatchRowcode": "                         )"
            },
            "54": {
                "beforePatchRowNumber": 1287,
                "afterPatchRowNumber": 1294,
                "PatchRowcode": "                     ) from ex"
            },
            "55": {
                "beforePatchRowNumber": 1288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                having_clause_and += [text(f\"({having})\")]"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1295,
                "PatchRowcode": "+                having_clause_and += [self.text(having)]"
            },
            "57": {
                "beforePatchRowNumber": 1289,
                "afterPatchRowNumber": 1296,
                "PatchRowcode": "         if apply_fetch_values_predicate and self.fetch_values_predicate:"
            },
            "58": {
                "beforePatchRowNumber": 1290,
                "afterPatchRowNumber": 1297,
                "PatchRowcode": "             qry = qry.where(self.get_fetch_values_predicate())"
            },
            "59": {
                "beforePatchRowNumber": 1291,
                "afterPatchRowNumber": 1298,
                "PatchRowcode": "         if granularity:"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "# pylint: disable=too-many-lines",
            "import dataclasses",
            "import json",
            "import logging",
            "import re",
            "from collections import defaultdict",
            "from dataclasses import dataclass, field",
            "from datetime import datetime, timedelta",
            "from typing import (",
            "    Any,",
            "    cast,",
            "    Dict,",
            "    Hashable,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    Union,",
            ")",
            "",
            "import dateutil.parser",
            "import pandas as pd",
            "import sqlalchemy as sa",
            "import sqlparse",
            "from flask import escape, Markup",
            "from flask_appbuilder import Model",
            "from flask_babel import lazy_gettext as _",
            "from jinja2.exceptions import TemplateError",
            "from sqlalchemy import (",
            "    and_,",
            "    asc,",
            "    Boolean,",
            "    Column,",
            "    DateTime,",
            "    desc,",
            "    Enum,",
            "    ForeignKey,",
            "    Integer,",
            "    or_,",
            "    select,",
            "    String,",
            "    Table,",
            "    Text,",
            "    update,",
            ")",
            "from sqlalchemy.engine.base import Connection",
            "from sqlalchemy.orm import backref, Query, relationship, RelationshipProperty, Session",
            "from sqlalchemy.orm.mapper import Mapper",
            "from sqlalchemy.schema import UniqueConstraint",
            "from sqlalchemy.sql import column, ColumnElement, literal_column, table",
            "from sqlalchemy.sql.elements import ColumnClause, TextClause",
            "from sqlalchemy.sql.expression import Label, Select, TextAsFrom",
            "from sqlalchemy.sql.selectable import Alias, TableClause",
            "",
            "from superset import app, db, is_feature_enabled, security_manager",
            "from superset.common.db_query_status import QueryStatus",
            "from superset.connectors.base.models import BaseColumn, BaseDatasource, BaseMetric",
            "from superset.connectors.sqla.utils import (",
            "    get_physical_table_metadata,",
            "    get_virtual_table_metadata,",
            ")",
            "from superset.db_engine_specs.base import BaseEngineSpec, TimestampExpression",
            "from superset.exceptions import QueryObjectValidationError",
            "from superset.jinja_context import (",
            "    BaseTemplateProcessor,",
            "    ExtraCache,",
            "    get_template_processor,",
            ")",
            "from superset.models.annotations import Annotation",
            "from superset.models.core import Database",
            "from superset.models.helpers import AuditMixinNullable, CertificationMixin, QueryResult",
            "from superset.sql_parse import ParsedQuery",
            "from superset.typing import AdhocMetric, Metric, OrderBy, QueryObjectDict",
            "from superset.utils import core as utils",
            "from superset.utils.core import (",
            "    GenericDataType,",
            "    QueryObjectFilterClause,",
            "    remove_duplicates,",
            ")",
            "",
            "config = app.config",
            "metadata = Model.metadata  # pylint: disable=no-member",
            "logger = logging.getLogger(__name__)",
            "",
            "VIRTUAL_TABLE_ALIAS = \"virtual_table\"",
            "",
            "",
            "def text(clause: str) -> TextClause:",
            "    \"\"\"",
            "    SQLALchemy wrapper to ensure text clauses are escaped properly",
            "",
            "    :param clause: clause potentially containing colons",
            "    :return: text clause with escaped colons",
            "    \"\"\"",
            "    return sa.text(clause.replace(\":\", \"\\\\:\"))",
            "",
            "",
            "class SqlaQuery(NamedTuple):",
            "    applied_template_filters: List[str]",
            "    extra_cache_keys: List[Any]",
            "    labels_expected: List[str]",
            "    prequeries: List[str]",
            "    sqla_query: Select",
            "",
            "",
            "class QueryStringExtended(NamedTuple):",
            "    applied_template_filters: Optional[List[str]]",
            "    labels_expected: List[str]",
            "    prequeries: List[str]",
            "    sql: str",
            "",
            "",
            "@dataclass",
            "class MetadataResult:",
            "    added: List[str] = field(default_factory=list)",
            "    removed: List[str] = field(default_factory=list)",
            "    modified: List[str] = field(default_factory=list)",
            "",
            "",
            "class AnnotationDatasource(BaseDatasource):",
            "    \"\"\"Dummy object so we can query annotations using 'Viz' objects just like",
            "    regular datasources.",
            "    \"\"\"",
            "",
            "    cache_timeout = 0",
            "    changed_on = None",
            "    type = \"annotation\"",
            "    column_names = [",
            "        \"created_on\",",
            "        \"changed_on\",",
            "        \"id\",",
            "        \"start_dttm\",",
            "        \"end_dttm\",",
            "        \"layer_id\",",
            "        \"short_descr\",",
            "        \"long_descr\",",
            "        \"json_metadata\",",
            "        \"created_by_fk\",",
            "        \"changed_by_fk\",",
            "    ]",
            "",
            "    def query(self, query_obj: QueryObjectDict) -> QueryResult:",
            "        error_message = None",
            "        qry = db.session.query(Annotation)",
            "        qry = qry.filter(Annotation.layer_id == query_obj[\"filter\"][0][\"val\"])",
            "        if query_obj[\"from_dttm\"]:",
            "            qry = qry.filter(Annotation.start_dttm >= query_obj[\"from_dttm\"])",
            "        if query_obj[\"to_dttm\"]:",
            "            qry = qry.filter(Annotation.end_dttm <= query_obj[\"to_dttm\"])",
            "        status = QueryStatus.SUCCESS",
            "        try:",
            "            df = pd.read_sql_query(qry.statement, db.engine)",
            "        except Exception as ex:  # pylint: disable=broad-except",
            "            df = pd.DataFrame()",
            "            status = QueryStatus.FAILED",
            "            logger.exception(ex)",
            "            error_message = utils.error_msg_from_exception(ex)",
            "        return QueryResult(",
            "            status=status,",
            "            df=df,",
            "            duration=timedelta(0),",
            "            query=\"\",",
            "            error_message=error_message,",
            "        )",
            "",
            "    def get_query_str(self, query_obj: QueryObjectDict) -> str:",
            "        raise NotImplementedError()",
            "",
            "    def values_for_column(self, column_name: str, limit: int = 10000) -> List[Any]:",
            "        raise NotImplementedError()",
            "",
            "",
            "class TableColumn(Model, BaseColumn, CertificationMixin):",
            "",
            "    \"\"\"ORM object for table columns, each table can have multiple columns\"\"\"",
            "",
            "    __tablename__ = \"table_columns\"",
            "    __table_args__ = (UniqueConstraint(\"table_id\", \"column_name\"),)",
            "    table_id = Column(Integer, ForeignKey(\"tables.id\"))",
            "    table = relationship(",
            "        \"SqlaTable\",",
            "        backref=backref(\"columns\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[table_id],",
            "    )",
            "    is_dttm = Column(Boolean, default=False)",
            "    expression = Column(Text)",
            "    python_date_format = Column(String(255))",
            "    extra = Column(Text)",
            "",
            "    export_fields = [",
            "        \"table_id\",",
            "        \"column_name\",",
            "        \"verbose_name\",",
            "        \"is_dttm\",",
            "        \"is_active\",",
            "        \"type\",",
            "        \"groupby\",",
            "        \"filterable\",",
            "        \"expression\",",
            "        \"description\",",
            "        \"python_date_format\",",
            "        \"extra\",",
            "    ]",
            "",
            "    update_from_object_fields = [s for s in export_fields if s not in (\"table_id\",)]",
            "    export_parent = \"table\"",
            "",
            "    @property",
            "    def is_boolean(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a boolean datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.BOOLEAN",
            "",
            "    @property",
            "    def is_numeric(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a numeric datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.NUMERIC",
            "",
            "    @property",
            "    def is_string(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a string datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.STRING",
            "",
            "    @property",
            "    def is_temporal(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a temporal datatype. If column has been set as",
            "        temporal/non-temporal (`is_dttm` is True or False respectively), return that",
            "        value. This usually happens during initial metadata fetching or when a column",
            "        is manually set as temporal (for this `python_date_format` needs to be set).",
            "        \"\"\"",
            "        if self.is_dttm is not None:",
            "            return self.is_dttm",
            "        return self.type_generic == GenericDataType.TEMPORAL",
            "",
            "    @property",
            "    def db_engine_spec(self) -> Type[BaseEngineSpec]:",
            "        return self.table.db_engine_spec",
            "",
            "    @property",
            "    def type_generic(self) -> Optional[utils.GenericDataType]:",
            "        if self.is_dttm:",
            "            return GenericDataType.TEMPORAL",
            "        column_spec = self.db_engine_spec.get_column_spec(self.type)",
            "        return column_spec.generic_type if column_spec else None",
            "",
            "    def get_sqla_col(self, label: Optional[str] = None) -> Column:",
            "        label = label or self.column_name",
            "        db_engine_spec = self.db_engine_spec",
            "        column_spec = db_engine_spec.get_column_spec(self.type)",
            "        type_ = column_spec.sqla_type if column_spec else None",
            "        if self.expression:",
            "            tp = self.table.get_template_processor()",
            "            expression = tp.process_template(self.expression)",
            "            col = literal_column(expression, type_=type_)",
            "        else:",
            "            col = column(self.column_name, type_=type_)",
            "        col = self.table.make_sqla_column_compatible(col, label)",
            "        return col",
            "",
            "    @property",
            "    def datasource(self) -> RelationshipProperty:",
            "        return self.table",
            "",
            "    def get_time_filter(",
            "        self,",
            "        start_dttm: DateTime,",
            "        end_dttm: DateTime,",
            "        time_range_endpoints: Optional[",
            "            Tuple[utils.TimeRangeEndpoint, utils.TimeRangeEndpoint]",
            "        ],",
            "    ) -> ColumnElement:",
            "        col = self.get_sqla_col(label=\"__time\")",
            "        l = []",
            "        if start_dttm:",
            "            l.append(",
            "                col >= text(self.dttm_sql_literal(start_dttm, time_range_endpoints))",
            "            )",
            "        if end_dttm:",
            "            if (",
            "                time_range_endpoints",
            "                and time_range_endpoints[1] == utils.TimeRangeEndpoint.EXCLUSIVE",
            "            ):",
            "                l.append(",
            "                    col < text(self.dttm_sql_literal(end_dttm, time_range_endpoints))",
            "                )",
            "            else:",
            "                l.append(col <= text(self.dttm_sql_literal(end_dttm, None)))",
            "        return and_(*l)",
            "",
            "    def get_timestamp_expression(",
            "        self, time_grain: Optional[str], label: Optional[str] = None",
            "    ) -> Union[TimestampExpression, Label]:",
            "        \"\"\"",
            "        Return a SQLAlchemy Core element representation of self to be used in a query.",
            "",
            "        :param time_grain: Optional time grain, e.g. P1Y",
            "        :param label: alias/label that column is expected to have",
            "        :return: A TimeExpression object wrapped in a Label if supported by db",
            "        \"\"\"",
            "        label = label or utils.DTTM_ALIAS",
            "",
            "        pdf = self.python_date_format",
            "        is_epoch = pdf in (\"epoch_s\", \"epoch_ms\")",
            "        column_spec = self.db_engine_spec.get_column_spec(self.type)",
            "        type_ = column_spec.sqla_type if column_spec else DateTime",
            "        if not self.expression and not time_grain and not is_epoch:",
            "            sqla_col = column(self.column_name, type_=type_)",
            "            return self.table.make_sqla_column_compatible(sqla_col, label)",
            "        if self.expression:",
            "            col = literal_column(self.expression, type_=type_)",
            "        else:",
            "            col = column(self.column_name, type_=type_)",
            "        time_expr = self.db_engine_spec.get_timestamp_expr(",
            "            col, pdf, time_grain, self.type",
            "        )",
            "        return self.table.make_sqla_column_compatible(time_expr, label)",
            "",
            "    def dttm_sql_literal(",
            "        self,",
            "        dttm: DateTime,",
            "        time_range_endpoints: Optional[",
            "            Tuple[utils.TimeRangeEndpoint, utils.TimeRangeEndpoint]",
            "        ],",
            "    ) -> str:",
            "        \"\"\"Convert datetime object to a SQL expression string\"\"\"",
            "        dttm_type = self.type or (\"DATETIME\" if self.is_dttm else None)",
            "        sql = self.db_engine_spec.convert_dttm(dttm_type, dttm) if dttm_type else None",
            "",
            "        if sql:",
            "            return sql",
            "",
            "        tf = self.python_date_format",
            "",
            "        # Fallback to the default format (if defined) only if the SIP-15 time range",
            "        # endpoints, i.e., [start, end) are enabled.",
            "        if not tf and time_range_endpoints == (",
            "            utils.TimeRangeEndpoint.INCLUSIVE,",
            "            utils.TimeRangeEndpoint.EXCLUSIVE,",
            "        ):",
            "            tf = (",
            "                self.table.database.get_extra()",
            "                .get(\"python_date_format_by_column_name\", {})",
            "                .get(self.column_name)",
            "            )",
            "",
            "        if tf:",
            "            if tf in [\"epoch_ms\", \"epoch_s\"]:",
            "                seconds_since_epoch = int(dttm.timestamp())",
            "                if tf == \"epoch_s\":",
            "                    return str(seconds_since_epoch)",
            "                return str(seconds_since_epoch * 1000)",
            "            return f\"'{dttm.strftime(tf)}'\"",
            "",
            "        # TODO(john-bodley): SIP-15 will explicitly require a type conversion.",
            "        return f\"\"\"'{dttm.strftime(\"%Y-%m-%d %H:%M:%S.%f\")}'\"\"\"",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        attrs = (",
            "            \"id\",",
            "            \"column_name\",",
            "            \"verbose_name\",",
            "            \"description\",",
            "            \"expression\",",
            "            \"filterable\",",
            "            \"groupby\",",
            "            \"is_dttm\",",
            "            \"type\",",
            "            \"type_generic\",",
            "            \"python_date_format\",",
            "            \"is_certified\",",
            "            \"certified_by\",",
            "            \"certification_details\",",
            "            \"warning_markdown\",",
            "        )",
            "",
            "        attr_dict = {s: getattr(self, s) for s in attrs if hasattr(self, s)}",
            "",
            "        attr_dict.update(super().data)",
            "",
            "        return attr_dict",
            "",
            "",
            "class SqlMetric(Model, BaseMetric, CertificationMixin):",
            "",
            "    \"\"\"ORM object for metrics, each table can have multiple metrics\"\"\"",
            "",
            "    __tablename__ = \"sql_metrics\"",
            "    __table_args__ = (UniqueConstraint(\"table_id\", \"metric_name\"),)",
            "    table_id = Column(Integer, ForeignKey(\"tables.id\"))",
            "    table = relationship(",
            "        \"SqlaTable\",",
            "        backref=backref(\"metrics\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[table_id],",
            "    )",
            "    expression = Column(Text, nullable=False)",
            "    extra = Column(Text)",
            "",
            "    export_fields = [",
            "        \"metric_name\",",
            "        \"verbose_name\",",
            "        \"metric_type\",",
            "        \"table_id\",",
            "        \"expression\",",
            "        \"description\",",
            "        \"d3format\",",
            "        \"extra\",",
            "        \"warning_text\",",
            "    ]",
            "    update_from_object_fields = list(s for s in export_fields if s != \"table_id\")",
            "    export_parent = \"table\"",
            "",
            "    def get_sqla_col(self, label: Optional[str] = None) -> Column:",
            "        label = label or self.metric_name",
            "        tp = self.table.get_template_processor()",
            "        sqla_col: ColumnClause = literal_column(tp.process_template(self.expression))",
            "        return self.table.make_sqla_column_compatible(sqla_col, label)",
            "",
            "    @property",
            "    def perm(self) -> Optional[str]:",
            "        return (",
            "            (\"{parent_name}.[{obj.metric_name}](id:{obj.id})\").format(",
            "                obj=self, parent_name=self.table.full_name",
            "            )",
            "            if self.table",
            "            else None",
            "        )",
            "",
            "    def get_perm(self) -> Optional[str]:",
            "        return self.perm",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        attrs = (",
            "            \"is_certified\",",
            "            \"certified_by\",",
            "            \"certification_details\",",
            "            \"warning_markdown\",",
            "        )",
            "        attr_dict = {s: getattr(self, s) for s in attrs}",
            "",
            "        attr_dict.update(super().data)",
            "        return attr_dict",
            "",
            "",
            "sqlatable_user = Table(",
            "    \"sqlatable_user\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"user_id\", Integer, ForeignKey(\"ab_user.id\")),",
            "    Column(\"table_id\", Integer, ForeignKey(\"tables.id\")),",
            ")",
            "",
            "",
            "class SqlaTable(Model, BaseDatasource):  # pylint: disable=too-many-public-methods",
            "    \"\"\"An ORM object for SqlAlchemy table references\"\"\"",
            "",
            "    type = \"table\"",
            "    query_language = \"sql\"",
            "    is_rls_supported = True",
            "    columns: List[TableColumn] = []",
            "    metrics: List[SqlMetric] = []",
            "    metric_class = SqlMetric",
            "    column_class = TableColumn",
            "    owner_class = security_manager.user_model",
            "",
            "    __tablename__ = \"tables\"",
            "",
            "    # Note this uniqueness constraint is not part of the physical schema, i.e., it does",
            "    # not exist in the migrations, but is required by `import_from_dict` to ensure the",
            "    # correct filters are applied in order to identify uniqueness.",
            "    #",
            "    # The reason it does not physically exist is MySQL, PostgreSQL, etc. have a",
            "    # different interpretation of uniqueness when it comes to NULL which is problematic",
            "    # given the schema is optional.",
            "    __table_args__ = (UniqueConstraint(\"database_id\", \"schema\", \"table_name\"),)",
            "",
            "    table_name = Column(String(250), nullable=False)",
            "    main_dttm_col = Column(String(250))",
            "    database_id = Column(Integer, ForeignKey(\"dbs.id\"), nullable=False)",
            "    fetch_values_predicate = Column(Text)",
            "    owners = relationship(owner_class, secondary=sqlatable_user, backref=\"tables\")",
            "    database: Database = relationship(",
            "        \"Database\",",
            "        backref=backref(\"tables\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[database_id],",
            "    )",
            "    schema = Column(String(255))",
            "    sql = Column(Text)",
            "    is_sqllab_view = Column(Boolean, default=False)",
            "    template_params = Column(Text)",
            "    extra = Column(Text)",
            "",
            "    baselink = \"tablemodelview\"",
            "",
            "    export_fields = [",
            "        \"table_name\",",
            "        \"main_dttm_col\",",
            "        \"description\",",
            "        \"default_endpoint\",",
            "        \"database_id\",",
            "        \"offset\",",
            "        \"cache_timeout\",",
            "        \"schema\",",
            "        \"sql\",",
            "        \"params\",",
            "        \"template_params\",",
            "        \"filter_select_enabled\",",
            "        \"fetch_values_predicate\",",
            "        \"extra\",",
            "    ]",
            "    update_from_object_fields = [f for f in export_fields if f != \"database_id\"]",
            "    export_parent = \"database\"",
            "    export_children = [\"metrics\", \"columns\"]",
            "",
            "    sqla_aggregations = {",
            "        \"COUNT_DISTINCT\": lambda column_name: sa.func.COUNT(sa.distinct(column_name)),",
            "        \"COUNT\": sa.func.COUNT,",
            "        \"SUM\": sa.func.SUM,",
            "        \"AVG\": sa.func.AVG,",
            "        \"MIN\": sa.func.MIN,",
            "        \"MAX\": sa.func.MAX,",
            "    }",
            "",
            "    def __repr__(self) -> str:",
            "        return self.name",
            "",
            "    @property",
            "    def db_engine_spec(self) -> Type[BaseEngineSpec]:",
            "        return self.database.db_engine_spec",
            "",
            "    @property",
            "    def changed_by_name(self) -> str:",
            "        if not self.changed_by:",
            "            return \"\"",
            "        return str(self.changed_by)",
            "",
            "    @property",
            "    def changed_by_url(self) -> str:",
            "        if not self.changed_by:",
            "            return \"\"",
            "        return f\"/superset/profile/{self.changed_by.username}\"",
            "",
            "    @property",
            "    def connection(self) -> str:",
            "        return str(self.database)",
            "",
            "    @property",
            "    def description_markeddown(self) -> str:",
            "        return utils.markdown(self.description)",
            "",
            "    @property",
            "    def datasource_name(self) -> str:",
            "        return self.table_name",
            "",
            "    @property",
            "    def datasource_type(self) -> str:",
            "        return self.type",
            "",
            "    @property",
            "    def database_name(self) -> str:",
            "        return self.database.name",
            "",
            "    @classmethod",
            "    def get_datasource_by_name(",
            "        cls,",
            "        session: Session,",
            "        datasource_name: str,",
            "        schema: Optional[str],",
            "        database_name: str,",
            "    ) -> Optional[\"SqlaTable\"]:",
            "        schema = schema or None",
            "        query = (",
            "            session.query(cls)",
            "            .join(Database)",
            "            .filter(cls.table_name == datasource_name)",
            "            .filter(Database.database_name == database_name)",
            "        )",
            "        # Handling schema being '' or None, which is easier to handle",
            "        # in python than in the SQLA query in a multi-dialect way",
            "        for tbl in query.all():",
            "            if schema == (tbl.schema or None):",
            "                return tbl",
            "        return None",
            "",
            "    @property",
            "    def link(self) -> Markup:",
            "        name = escape(self.name)",
            "        anchor = f'<a target=\"_blank\" href=\"{self.explore_url}\">{name}</a>'",
            "        return Markup(anchor)",
            "",
            "    def get_schema_perm(self) -> Optional[str]:",
            "        \"\"\"Returns schema permission if present, database one otherwise.\"\"\"",
            "        return security_manager.get_schema_perm(self.database, self.schema)",
            "",
            "    def get_perm(self) -> str:",
            "        return f\"[{self.database}].[{self.table_name}](id:{self.id})\"",
            "",
            "    @property",
            "    def name(self) -> str:",
            "        if not self.schema:",
            "            return self.table_name",
            "        return \"{}.{}\".format(self.schema, self.table_name)",
            "",
            "    @property",
            "    def full_name(self) -> str:",
            "        return utils.get_datasource_full_name(",
            "            self.database, self.table_name, schema=self.schema",
            "        )",
            "",
            "    @property",
            "    def dttm_cols(self) -> List[str]:",
            "        l = [c.column_name for c in self.columns if c.is_dttm]",
            "        if self.main_dttm_col and self.main_dttm_col not in l:",
            "            l.append(self.main_dttm_col)",
            "        return l",
            "",
            "    @property",
            "    def num_cols(self) -> List[str]:",
            "        return [c.column_name for c in self.columns if c.is_numeric]",
            "",
            "    @property",
            "    def any_dttm_col(self) -> Optional[str]:",
            "        cols = self.dttm_cols",
            "        return cols[0] if cols else None",
            "",
            "    @property",
            "    def html(self) -> str:",
            "        df = pd.DataFrame((c.column_name, c.type) for c in self.columns)",
            "        df.columns = [\"field\", \"type\"]",
            "        return df.to_html(",
            "            index=False,",
            "            classes=(\"dataframe table table-striped table-bordered \" \"table-condensed\"),",
            "        )",
            "",
            "    @property",
            "    def sql_url(self) -> str:",
            "        return self.database.sql_url + \"?table_name=\" + str(self.table_name)",
            "",
            "    def external_metadata(self) -> List[Dict[str, str]]:",
            "        if self.sql:",
            "            return get_virtual_table_metadata(dataset=self)",
            "        return get_physical_table_metadata(",
            "            database=self.database, table_name=self.table_name, schema_name=self.schema,",
            "        )",
            "",
            "    @property",
            "    def time_column_grains(self) -> Dict[str, Any]:",
            "        return {",
            "            \"time_columns\": self.dttm_cols,",
            "            \"time_grains\": [grain.name for grain in self.database.grains()],",
            "        }",
            "",
            "    @property",
            "    def select_star(self) -> Optional[str]:",
            "        # show_cols and latest_partition set to false to avoid",
            "        # the expensive cost of inspecting the DB",
            "        return self.database.select_star(",
            "            self.table_name, schema=self.schema, show_cols=False, latest_partition=False",
            "        )",
            "",
            "    @property",
            "    def health_check_message(self) -> Optional[str]:",
            "        check = config[\"DATASET_HEALTH_CHECK\"]",
            "        return check(self) if check else None",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        data_ = super().data",
            "        if self.type == \"table\":",
            "            data_[\"granularity_sqla\"] = utils.choicify(self.dttm_cols)",
            "            data_[\"time_grain_sqla\"] = [",
            "                (g.duration, g.name) for g in self.database.grains() or []",
            "            ]",
            "            data_[\"main_dttm_col\"] = self.main_dttm_col",
            "            data_[\"fetch_values_predicate\"] = self.fetch_values_predicate",
            "            data_[\"template_params\"] = self.template_params",
            "            data_[\"is_sqllab_view\"] = self.is_sqllab_view",
            "            data_[\"health_check_message\"] = self.health_check_message",
            "            data_[\"extra\"] = self.extra",
            "        return data_",
            "",
            "    @property",
            "    def extra_dict(self) -> Dict[str, Any]:",
            "        try:",
            "            return json.loads(self.extra)",
            "        except (TypeError, json.JSONDecodeError):",
            "            return {}",
            "",
            "    def get_fetch_values_predicate(self) -> TextClause:",
            "        tp = self.get_template_processor()",
            "        try:",
            "            return text(tp.process_template(self.fetch_values_predicate))",
            "        except TemplateError as ex:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Error in jinja expression in fetch values predicate: %(msg)s\",",
            "                    msg=ex.message,",
            "                )",
            "            ) from ex",
            "",
            "    def values_for_column(self, column_name: str, limit: int = 10000) -> List[Any]:",
            "        \"\"\"Runs query against sqla to retrieve some",
            "        sample values for the given column.",
            "        \"\"\"",
            "        cols = {col.column_name: col for col in self.columns}",
            "        target_col = cols[column_name]",
            "        tp = self.get_template_processor()",
            "",
            "        qry = (",
            "            select([target_col.get_sqla_col()])",
            "            .select_from(self.get_from_clause(tp))",
            "            .distinct()",
            "        )",
            "        if limit:",
            "            qry = qry.limit(limit)",
            "",
            "        if self.fetch_values_predicate:",
            "            qry = qry.where(self.get_fetch_values_predicate())",
            "",
            "        engine = self.database.get_sqla_engine()",
            "        sql = \"{}\".format(qry.compile(engine, compile_kwargs={\"literal_binds\": True}))",
            "        sql = self.mutate_query_from_config(sql)",
            "",
            "        df = pd.read_sql_query(sql=sql, con=engine)",
            "        return df[column_name].to_list()",
            "",
            "    def mutate_query_from_config(self, sql: str) -> str:",
            "        \"\"\"Apply config's SQL_QUERY_MUTATOR",
            "",
            "        Typically adds comments to the query with context\"\"\"",
            "        sql_query_mutator = config[\"SQL_QUERY_MUTATOR\"]",
            "        if sql_query_mutator:",
            "            username = utils.get_username()",
            "            sql = sql_query_mutator(sql, username, security_manager, self.database)",
            "        return sql",
            "",
            "    def get_template_processor(self, **kwargs: Any) -> BaseTemplateProcessor:",
            "        return get_template_processor(table=self, database=self.database, **kwargs)",
            "",
            "    def get_query_str_extended(self, query_obj: QueryObjectDict) -> QueryStringExtended:",
            "        sqlaq = self.get_sqla_query(**query_obj)",
            "        sql = self.database.compile_sqla_query(sqlaq.sqla_query)",
            "        sql = sqlparse.format(sql, reindent=True)",
            "        sql = self.mutate_query_from_config(sql)",
            "        return QueryStringExtended(",
            "            applied_template_filters=sqlaq.applied_template_filters,",
            "            labels_expected=sqlaq.labels_expected,",
            "            prequeries=sqlaq.prequeries,",
            "            sql=sql,",
            "        )",
            "",
            "    def get_query_str(self, query_obj: QueryObjectDict) -> str:",
            "        query_str_ext = self.get_query_str_extended(query_obj)",
            "        all_queries = query_str_ext.prequeries + [query_str_ext.sql]",
            "        return \";\\n\\n\".join(all_queries) + \";\"",
            "",
            "    def get_sqla_table(self) -> TableClause:",
            "        tbl = table(self.table_name)",
            "        if self.schema:",
            "            tbl.schema = self.schema",
            "        return tbl",
            "",
            "    def get_from_clause(",
            "        self, template_processor: Optional[BaseTemplateProcessor] = None",
            "    ) -> Union[TableClause, Alias]:",
            "        \"\"\"",
            "        Return where to select the columns and metrics from. Either a physical table",
            "        or a virtual table with it's own subquery.",
            "        \"\"\"",
            "        if not self.is_virtual:",
            "            return self.get_sqla_table()",
            "",
            "        from_sql = self.get_rendered_sql(template_processor)",
            "        parsed_query = ParsedQuery(from_sql)",
            "        if not (",
            "            parsed_query.is_unknown()",
            "            or self.db_engine_spec.is_readonly_query(parsed_query)",
            "        ):",
            "            raise QueryObjectValidationError(",
            "                _(\"Virtual dataset query must be read-only\")",
            "            )",
            "        return TextAsFrom(text(from_sql), []).alias(VIRTUAL_TABLE_ALIAS)",
            "",
            "    def get_rendered_sql(",
            "        self, template_processor: Optional[BaseTemplateProcessor] = None",
            "    ) -> str:",
            "        \"\"\"",
            "        Render sql with template engine (Jinja).",
            "        \"\"\"",
            "",
            "        sql = self.sql",
            "        if template_processor:",
            "            try:",
            "                sql = template_processor.process_template(sql)",
            "            except TemplateError as ex:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"Error while rendering virtual dataset query: %(msg)s\",",
            "                        msg=ex.message,",
            "                    )",
            "                ) from ex",
            "        sql = sqlparse.format(sql.strip(\"\\t\\r\\n; \"), strip_comments=True)",
            "        if not sql:",
            "            raise QueryObjectValidationError(_(\"Virtual dataset query cannot be empty\"))",
            "        if len(sqlparse.split(sql)) > 1:",
            "            raise QueryObjectValidationError(",
            "                _(\"Virtual dataset query cannot consist of multiple statements\")",
            "            )",
            "        return sql",
            "",
            "    def adhoc_metric_to_sqla(",
            "        self, metric: AdhocMetric, columns_by_name: Dict[str, TableColumn]",
            "    ) -> ColumnElement:",
            "        \"\"\"",
            "        Turn an adhoc metric into a sqlalchemy column.",
            "",
            "        :param dict metric: Adhoc metric definition",
            "        :param dict columns_by_name: Columns for the current table",
            "        :returns: The metric defined as a sqlalchemy column",
            "        :rtype: sqlalchemy.sql.column",
            "        \"\"\"",
            "        expression_type = metric.get(\"expressionType\")",
            "        label = utils.get_metric_name(metric)",
            "",
            "        if expression_type == utils.AdhocMetricExpressionType.SIMPLE:",
            "            metric_column = metric.get(\"column\") or {}",
            "            column_name = cast(str, metric_column.get(\"column_name\"))",
            "            table_column: Optional[TableColumn] = columns_by_name.get(column_name)",
            "            if table_column:",
            "                sqla_column = table_column.get_sqla_col()",
            "            else:",
            "                sqla_column = column(column_name)",
            "            sqla_metric = self.sqla_aggregations[metric[\"aggregate\"]](sqla_column)",
            "        elif expression_type == utils.AdhocMetricExpressionType.SQL:",
            "            tp = self.get_template_processor()",
            "            expression = tp.process_template(cast(str, metric[\"sqlExpression\"]))",
            "            sqla_metric = literal_column(expression)",
            "        else:",
            "            raise QueryObjectValidationError(\"Adhoc metric expressionType is invalid\")",
            "",
            "        return self.make_sqla_column_compatible(sqla_metric, label)",
            "",
            "    def make_sqla_column_compatible(",
            "        self, sqla_col: ColumnElement, label: Optional[str] = None",
            "    ) -> ColumnElement:",
            "        \"\"\"Takes a sqlalchemy column object and adds label info if supported by engine.",
            "        :param sqla_col: sqlalchemy column instance",
            "        :param label: alias/label that column is expected to have",
            "        :return: either a sql alchemy column or label instance if supported by engine",
            "        \"\"\"",
            "        label_expected = label or sqla_col.name",
            "        db_engine_spec = self.db_engine_spec",
            "        # add quotes to tables",
            "        if db_engine_spec.allows_alias_in_select:",
            "            label = db_engine_spec.make_label_compatible(label_expected)",
            "            sqla_col = sqla_col.label(label)",
            "        sqla_col.key = label_expected",
            "        return sqla_col",
            "",
            "    def make_orderby_compatible(",
            "        self, select_exprs: List[ColumnElement], orderby_exprs: List[ColumnElement]",
            "    ) -> None:",
            "        \"\"\"",
            "        If needed, make sure aliases for selected columns are not used in",
            "        `ORDER BY`.",
            "",
            "        In some databases (e.g. Presto), `ORDER BY` clause is not able to",
            "        automatically pick the source column if a `SELECT` clause alias is named",
            "        the same as a source column. In this case, we update the SELECT alias to",
            "        another name to avoid the conflict.",
            "        \"\"\"",
            "        if self.db_engine_spec.allows_alias_to_source_column:",
            "            return",
            "",
            "        def is_alias_used_in_orderby(col: ColumnElement) -> bool:",
            "            if not isinstance(col, Label):",
            "                return False",
            "            regexp = re.compile(f\"\\\\(.*\\\\b{re.escape(col.name)}\\\\b.*\\\\)\", re.IGNORECASE)",
            "            return any(regexp.search(str(x)) for x in orderby_exprs)",
            "",
            "        # Iterate through selected columns, if column alias appears in orderby",
            "        # use another `alias`. The final output columns will still use the",
            "        # original names, because they are updated by `labels_expected` after",
            "        # querying.",
            "        for col in select_exprs:",
            "            if is_alias_used_in_orderby(col):",
            "                col.name = f\"{col.name}__\"",
            "",
            "    def _get_sqla_row_level_filters(",
            "        self, template_processor: BaseTemplateProcessor",
            "    ) -> List[str]:",
            "        \"\"\"",
            "        Return the appropriate row level security filters for",
            "        this table and the current user.",
            "",
            "        :param BaseTemplateProcessor template_processor: The template",
            "        processor to apply to the filters.",
            "        :returns: A list of SQL clauses to be ANDed together.",
            "        :rtype: List[str]",
            "        \"\"\"",
            "        filters_grouped: Dict[Union[int, str], List[str]] = defaultdict(list)",
            "        try:",
            "            for filter_ in security_manager.get_rls_filters(self):",
            "                clause = text(",
            "                    f\"({template_processor.process_template(filter_.clause)})\"",
            "                )",
            "                filters_grouped[filter_.group_key or filter_.id].append(clause)",
            "            return [or_(*clauses) for clauses in filters_grouped.values()]",
            "        except TemplateError as ex:",
            "            raise QueryObjectValidationError(",
            "                _(\"Error in jinja expression in RLS filters: %(msg)s\", msg=ex.message,)",
            "            ) from ex",
            "",
            "    def get_sqla_query(  # pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements",
            "        self,",
            "        apply_fetch_values_predicate: bool = False,",
            "        columns: Optional[List[str]] = None,",
            "        extras: Optional[Dict[str, Any]] = None,",
            "        filter: Optional[  # pylint: disable=redefined-builtin",
            "            List[QueryObjectFilterClause]",
            "        ] = None,",
            "        from_dttm: Optional[datetime] = None,",
            "        granularity: Optional[str] = None,",
            "        groupby: Optional[List[str]] = None,",
            "        inner_from_dttm: Optional[datetime] = None,",
            "        inner_to_dttm: Optional[datetime] = None,",
            "        is_rowcount: bool = False,",
            "        is_timeseries: bool = True,",
            "        metrics: Optional[List[Metric]] = None,",
            "        orderby: Optional[List[OrderBy]] = None,",
            "        order_desc: bool = True,",
            "        to_dttm: Optional[datetime] = None,",
            "        series_columns: Optional[List[str]] = None,",
            "        series_limit: Optional[int] = None,",
            "        series_limit_metric: Optional[Metric] = None,",
            "        row_limit: Optional[int] = None,",
            "        row_offset: Optional[int] = None,",
            "        timeseries_limit: Optional[int] = None,",
            "        timeseries_limit_metric: Optional[Metric] = None,",
            "    ) -> SqlaQuery:",
            "        \"\"\"Querying any sqla table from this common interface\"\"\"",
            "        if granularity not in self.dttm_cols and granularity is not None:",
            "            granularity = self.main_dttm_col",
            "",
            "        extras = extras or {}",
            "        time_grain = extras.get(\"time_grain_sqla\")",
            "",
            "        template_kwargs = {",
            "            \"columns\": columns,",
            "            \"from_dttm\": from_dttm.isoformat() if from_dttm else None,",
            "            \"groupby\": groupby,",
            "            \"metrics\": metrics,",
            "            \"row_limit\": row_limit,",
            "            \"row_offset\": row_offset,",
            "            \"time_column\": granularity,",
            "            \"time_grain\": time_grain,",
            "            \"to_dttm\": to_dttm.isoformat() if to_dttm else None,",
            "            \"table_columns\": [col.column_name for col in self.columns],",
            "            \"filter\": filter,",
            "        }",
            "        series_columns = series_columns or []",
            "        # deprecated, to be removed in 2.0",
            "        if is_timeseries and timeseries_limit:",
            "            series_limit = timeseries_limit",
            "        series_limit_metric = series_limit_metric or timeseries_limit_metric",
            "        template_kwargs.update(self.template_params_dict)",
            "        extra_cache_keys: List[Any] = []",
            "        template_kwargs[\"extra_cache_keys\"] = extra_cache_keys",
            "        removed_filters: List[str] = []",
            "        applied_template_filters: List[str] = []",
            "        template_kwargs[\"removed_filters\"] = removed_filters",
            "        template_kwargs[\"applied_filters\"] = applied_template_filters",
            "        template_processor = self.get_template_processor(**template_kwargs)",
            "        db_engine_spec = self.db_engine_spec",
            "        prequeries: List[str] = []",
            "        orderby = orderby or []",
            "        need_groupby = bool(metrics is not None or groupby)",
            "        metrics = metrics or []",
            "",
            "        # For backward compatibility",
            "        if granularity not in self.dttm_cols and granularity is not None:",
            "            granularity = self.main_dttm_col",
            "",
            "        columns_by_name: Dict[str, TableColumn] = {",
            "            col.column_name: col for col in self.columns",
            "        }",
            "        metrics_by_name: Dict[str, SqlMetric] = {m.metric_name: m for m in self.metrics}",
            "",
            "        if not granularity and is_timeseries:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Datetime column not provided as part table configuration \"",
            "                    \"and is required by this type of chart\"",
            "                )",
            "            )",
            "        if not metrics and not columns and not groupby:",
            "            raise QueryObjectValidationError(_(\"Empty query?\"))",
            "",
            "        metrics_exprs: List[ColumnElement] = []",
            "        for metric in metrics:",
            "            if utils.is_adhoc_metric(metric):",
            "                assert isinstance(metric, dict)",
            "                metrics_exprs.append(self.adhoc_metric_to_sqla(metric, columns_by_name))",
            "            elif isinstance(metric, str) and metric in metrics_by_name:",
            "                metrics_exprs.append(metrics_by_name[metric].get_sqla_col())",
            "            else:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Metric '%(metric)s' does not exist\", metric=metric)",
            "                )",
            "",
            "        if metrics_exprs:",
            "            main_metric_expr = metrics_exprs[0]",
            "        else:",
            "            main_metric_expr, label = literal_column(\"COUNT(*)\"), \"ccount\"",
            "            main_metric_expr = self.make_sqla_column_compatible(main_metric_expr, label)",
            "",
            "        # To ensure correct handling of the ORDER BY labeling we need to reference the",
            "        # metric instance if defined in the SELECT clause.",
            "        # use the key of the ColumnClause for the expected label",
            "        metrics_exprs_by_label = {m.key: m for m in metrics_exprs}",
            "        metrics_exprs_by_expr = {str(m): m for m in metrics_exprs}",
            "",
            "        # Since orderby may use adhoc metrics, too; we need to process them first",
            "        orderby_exprs: List[ColumnElement] = []",
            "        for orig_col, ascending in orderby:",
            "            col: Union[AdhocMetric, ColumnElement] = orig_col",
            "            if isinstance(col, dict):",
            "                col = cast(AdhocMetric, col)",
            "                if utils.is_adhoc_metric(col):",
            "                    # add adhoc sort by column to columns_by_name if not exists",
            "                    col = self.adhoc_metric_to_sqla(col, columns_by_name)",
            "                    # if the adhoc metric has been defined before",
            "                    # use the existing instance.",
            "                    col = metrics_exprs_by_expr.get(str(col), col)",
            "                    need_groupby = True",
            "            elif col in columns_by_name:",
            "                col = columns_by_name[col].get_sqla_col()",
            "            elif col in metrics_exprs_by_label:",
            "                col = metrics_exprs_by_label[col]",
            "                need_groupby = True",
            "            elif col in metrics_by_name:",
            "                col = metrics_by_name[col].get_sqla_col()",
            "                need_groupby = True",
            "",
            "            if isinstance(col, ColumnElement):",
            "                orderby_exprs.append(col)",
            "            else:",
            "                # Could not convert a column reference to valid ColumnElement",
            "                raise QueryObjectValidationError(",
            "                    _(\"Unknown column used in orderby: %(col)s\", col=orig_col)",
            "                )",
            "",
            "        select_exprs: List[Union[Column, Label]] = []",
            "        groupby_all_columns = {}",
            "        groupby_series_columns = {}",
            "",
            "        # filter out the pseudo column  __timestamp from columns",
            "        columns = columns or []",
            "        columns = [col for col in columns if col != utils.DTTM_ALIAS]",
            "        dttm_col = columns_by_name.get(granularity) if granularity else None",
            "",
            "        if need_groupby:",
            "            # dedup columns while preserving order",
            "            columns = groupby or columns",
            "            for selected in columns:",
            "                # if groupby field/expr equals granularity field/expr",
            "                table_col = columns_by_name.get(selected)",
            "                if table_col and table_col.type_generic == GenericDataType.TEMPORAL:",
            "                    outer = table_col.get_timestamp_expression(time_grain, selected)",
            "                # if groupby field equals a selected column",
            "                elif table_col:",
            "                    outer = table_col.get_sqla_col()",
            "                else:",
            "                    outer = literal_column(f\"({selected})\")",
            "                    outer = self.make_sqla_column_compatible(outer, selected)",
            "                groupby_all_columns[outer.name] = outer",
            "                if not series_columns or outer.name in series_columns:",
            "                    groupby_series_columns[outer.name] = outer",
            "                select_exprs.append(outer)",
            "        elif columns:",
            "            for selected in columns:",
            "                select_exprs.append(",
            "                    columns_by_name[selected].get_sqla_col()",
            "                    if selected in columns_by_name",
            "                    else self.make_sqla_column_compatible(literal_column(selected))",
            "                )",
            "            metrics_exprs = []",
            "",
            "        time_range_endpoints = extras.get(\"time_range_endpoints\")",
            "",
            "        if granularity:",
            "            if granularity not in columns_by_name or not dttm_col:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        'Time column \"%(col)s\" does not exist in dataset',",
            "                        col=granularity,",
            "                    )",
            "                )",
            "            time_filters = []",
            "",
            "            if is_timeseries:",
            "                timestamp = dttm_col.get_timestamp_expression(time_grain)",
            "                # always put timestamp as the first column",
            "                select_exprs.insert(0, timestamp)",
            "                groupby_all_columns[timestamp.name] = timestamp",
            "",
            "            # Use main dttm column to support index with secondary dttm columns.",
            "            if (",
            "                db_engine_spec.time_secondary_columns",
            "                and self.main_dttm_col in self.dttm_cols",
            "                and self.main_dttm_col != dttm_col.column_name",
            "            ):",
            "                time_filters.append(",
            "                    columns_by_name[self.main_dttm_col].get_time_filter(",
            "                        from_dttm, to_dttm, time_range_endpoints",
            "                    )",
            "                )",
            "            time_filters.append(",
            "                dttm_col.get_time_filter(from_dttm, to_dttm, time_range_endpoints)",
            "            )",
            "",
            "        # Always remove duplicates by column name, as sometimes `metrics_exprs`",
            "        # can have the same name as a groupby column (e.g. when users use",
            "        # raw columns as custom SQL adhoc metric).",
            "        select_exprs = remove_duplicates(",
            "            select_exprs + metrics_exprs, key=lambda x: x.name",
            "        )",
            "",
            "        # Expected output columns",
            "        labels_expected = [c.key for c in select_exprs]",
            "",
            "        # Order by columns are \"hidden\" columns, some databases require them",
            "        # always be present in SELECT if an aggregation function is used",
            "        if not db_engine_spec.allows_hidden_ordeby_agg:",
            "            select_exprs = remove_duplicates(select_exprs + orderby_exprs)",
            "",
            "        qry = sa.select(select_exprs)",
            "",
            "        tbl = self.get_from_clause(template_processor)",
            "",
            "        if groupby_all_columns:",
            "            qry = qry.group_by(*groupby_all_columns.values())",
            "",
            "        where_clause_and = []",
            "        having_clause_and = []",
            "",
            "        for flt in filter:  # type: ignore",
            "            if not all(flt.get(s) for s in [\"col\", \"op\"]):",
            "                continue",
            "            col = flt[\"col\"]",
            "            val = flt.get(\"val\")",
            "            op = flt[\"op\"].upper()",
            "            col_obj = (",
            "                dttm_col",
            "                if col == utils.DTTM_ALIAS and is_timeseries and dttm_col",
            "                else columns_by_name.get(col)",
            "            )",
            "            filter_grain = flt.get(\"grain\")",
            "",
            "            if is_feature_enabled(\"ENABLE_TEMPLATE_REMOVE_FILTERS\"):",
            "                if col in removed_filters:",
            "                    # Skip generating SQLA filter when the jinja template handles it.",
            "                    continue",
            "",
            "            if col_obj:",
            "                if filter_grain:",
            "                    sqla_col = col_obj.get_timestamp_expression(filter_grain)",
            "                else:",
            "                    sqla_col = col_obj.get_sqla_col()",
            "                col_spec = db_engine_spec.get_column_spec(col_obj.type)",
            "                is_list_target = op in (",
            "                    utils.FilterOperator.IN.value,",
            "                    utils.FilterOperator.NOT_IN.value,",
            "                )",
            "                if col_spec:",
            "                    target_type = col_spec.generic_type",
            "                else:",
            "                    target_type = GenericDataType.STRING",
            "                eq = self.filter_values_handler(",
            "                    values=val,",
            "                    target_column_type=target_type,",
            "                    is_list_target=is_list_target,",
            "                )",
            "                if is_list_target:",
            "                    assert isinstance(eq, (tuple, list))",
            "                    if len(eq) == 0:",
            "                        raise QueryObjectValidationError(",
            "                            _(\"Filter value list cannot be empty\")",
            "                        )",
            "                    if None in eq:",
            "                        eq = [x for x in eq if x is not None]",
            "                        is_null_cond = sqla_col.is_(None)",
            "                        if eq:",
            "                            cond = or_(is_null_cond, sqla_col.in_(eq))",
            "                        else:",
            "                            cond = is_null_cond",
            "                    else:",
            "                        cond = sqla_col.in_(eq)",
            "                    if op == utils.FilterOperator.NOT_IN.value:",
            "                        cond = ~cond",
            "                    where_clause_and.append(cond)",
            "                elif op == utils.FilterOperator.IS_NULL.value:",
            "                    where_clause_and.append(sqla_col.is_(None))",
            "                elif op == utils.FilterOperator.IS_NOT_NULL.value:",
            "                    where_clause_and.append(sqla_col.isnot(None))",
            "                elif op == utils.FilterOperator.IS_TRUE.value:",
            "                    where_clause_and.append(sqla_col.is_(True))",
            "                elif op == utils.FilterOperator.IS_FALSE.value:",
            "                    where_clause_and.append(sqla_col.is_(False))",
            "                else:",
            "                    if eq is None:",
            "                        raise QueryObjectValidationError(",
            "                            _(",
            "                                \"Must specify a value for filters \"",
            "                                \"with comparison operators\"",
            "                            )",
            "                        )",
            "                    if op == utils.FilterOperator.EQUALS.value:",
            "                        where_clause_and.append(sqla_col == eq)",
            "                    elif op == utils.FilterOperator.NOT_EQUALS.value:",
            "                        where_clause_and.append(sqla_col != eq)",
            "                    elif op == utils.FilterOperator.GREATER_THAN.value:",
            "                        where_clause_and.append(sqla_col > eq)",
            "                    elif op == utils.FilterOperator.LESS_THAN.value:",
            "                        where_clause_and.append(sqla_col < eq)",
            "                    elif op == utils.FilterOperator.GREATER_THAN_OR_EQUALS.value:",
            "                        where_clause_and.append(sqla_col >= eq)",
            "                    elif op == utils.FilterOperator.LESS_THAN_OR_EQUALS.value:",
            "                        where_clause_and.append(sqla_col <= eq)",
            "                    elif op == utils.FilterOperator.LIKE.value:",
            "                        where_clause_and.append(sqla_col.like(eq))",
            "                    elif op == utils.FilterOperator.ILIKE.value:",
            "                        where_clause_and.append(sqla_col.ilike(eq))",
            "                    else:",
            "                        raise QueryObjectValidationError(",
            "                            _(\"Invalid filter operation type: %(op)s\", op=op)",
            "                        )",
            "        if is_feature_enabled(\"ROW_LEVEL_SECURITY\"):",
            "            where_clause_and += self._get_sqla_row_level_filters(template_processor)",
            "        if extras:",
            "            where = extras.get(\"where\")",
            "            if where:",
            "                try:",
            "                    where = template_processor.process_template(where)",
            "                except TemplateError as ex:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Error in jinja expression in WHERE clause: %(msg)s\",",
            "                            msg=ex.message,",
            "                        )",
            "                    ) from ex",
            "                where_clause_and += [text(f\"({where})\")]",
            "            having = extras.get(\"having\")",
            "            if having:",
            "                try:",
            "                    having = template_processor.process_template(having)",
            "                except TemplateError as ex:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Error in jinja expression in HAVING clause: %(msg)s\",",
            "                            msg=ex.message,",
            "                        )",
            "                    ) from ex",
            "                having_clause_and += [text(f\"({having})\")]",
            "        if apply_fetch_values_predicate and self.fetch_values_predicate:",
            "            qry = qry.where(self.get_fetch_values_predicate())",
            "        if granularity:",
            "            qry = qry.where(and_(*(time_filters + where_clause_and)))",
            "        else:",
            "            qry = qry.where(and_(*where_clause_and))",
            "        qry = qry.having(and_(*having_clause_and))",
            "",
            "        self.make_orderby_compatible(select_exprs, orderby_exprs)",
            "",
            "        for col, (orig_col, ascending) in zip(orderby_exprs, orderby):",
            "            if not db_engine_spec.allows_alias_in_orderby and isinstance(col, Label):",
            "                # if engine does not allow using SELECT alias in ORDER BY",
            "                # revert to the underlying column",
            "                col = col.element",
            "            direction = asc if ascending else desc",
            "            qry = qry.order_by(direction(col))",
            "",
            "        if row_limit:",
            "            qry = qry.limit(row_limit)",
            "        if row_offset:",
            "            qry = qry.offset(row_offset)",
            "",
            "        if series_limit and groupby_series_columns:",
            "            if db_engine_spec.allows_joins and db_engine_spec.allows_subqueries:",
            "                # some sql dialects require for order by expressions",
            "                # to also be in the select clause -- others, e.g. vertica,",
            "                # require a unique inner alias",
            "                inner_main_metric_expr = self.make_sqla_column_compatible(",
            "                    main_metric_expr, \"mme_inner__\"",
            "                )",
            "                inner_groupby_exprs = []",
            "                inner_select_exprs = []",
            "                for gby_name, gby_obj in groupby_series_columns.items():",
            "                    inner = self.make_sqla_column_compatible(gby_obj, gby_name + \"__\")",
            "                    inner_groupby_exprs.append(inner)",
            "                    inner_select_exprs.append(inner)",
            "",
            "                inner_select_exprs += [inner_main_metric_expr]",
            "                subq = select(inner_select_exprs).select_from(tbl)",
            "                inner_time_filter = []",
            "",
            "                if dttm_col and not db_engine_spec.time_groupby_inline:",
            "                    inner_time_filter = [",
            "                        dttm_col.get_time_filter(",
            "                            inner_from_dttm or from_dttm,",
            "                            inner_to_dttm or to_dttm,",
            "                            time_range_endpoints,",
            "                        )",
            "                    ]",
            "                subq = subq.where(and_(*(where_clause_and + inner_time_filter)))",
            "                subq = subq.group_by(*inner_groupby_exprs)",
            "",
            "                ob = inner_main_metric_expr",
            "                if series_limit_metric:",
            "                    ob = self._get_series_orderby(",
            "                        series_limit_metric, metrics_by_name, columns_by_name",
            "                    )",
            "                direction = desc if order_desc else asc",
            "                subq = subq.order_by(direction(ob))",
            "                subq = subq.limit(series_limit)",
            "",
            "                on_clause = []",
            "                for gby_name, gby_obj in groupby_series_columns.items():",
            "                    # in this case the column name, not the alias, needs to be",
            "                    # conditionally mutated, as it refers to the column alias in",
            "                    # the inner query",
            "                    col_name = db_engine_spec.make_label_compatible(gby_name + \"__\")",
            "                    on_clause.append(gby_obj == column(col_name))",
            "",
            "                tbl = tbl.join(subq.alias(), and_(*on_clause))",
            "            else:",
            "                if series_limit_metric:",
            "                    orderby = [",
            "                        (",
            "                            self._get_series_orderby(",
            "                                series_limit_metric, metrics_by_name, columns_by_name,",
            "                            ),",
            "                            False,",
            "                        )",
            "                    ]",
            "",
            "                # run prequery to get top groups",
            "                prequery_obj = {",
            "                    \"is_timeseries\": False,",
            "                    \"row_limit\": series_limit,",
            "                    \"metrics\": metrics,",
            "                    \"granularity\": granularity,",
            "                    \"groupby\": groupby,",
            "                    \"from_dttm\": inner_from_dttm or from_dttm,",
            "                    \"to_dttm\": inner_to_dttm or to_dttm,",
            "                    \"filter\": filter,",
            "                    \"orderby\": orderby,",
            "                    \"extras\": extras,",
            "                    \"columns\": columns,",
            "                    \"order_desc\": True,",
            "                }",
            "",
            "                result = self.query(prequery_obj)",
            "                prequeries.append(result.query)",
            "                dimensions = [",
            "                    c",
            "                    for c in result.df.columns",
            "                    if c not in metrics and c in groupby_series_columns",
            "                ]",
            "                top_groups = self._get_top_groups(",
            "                    result.df, dimensions, groupby_series_columns",
            "                )",
            "                qry = qry.where(top_groups)",
            "",
            "        qry = qry.select_from(tbl)",
            "",
            "        if is_rowcount:",
            "            if not db_engine_spec.allows_subqueries:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Database does not support subqueries\")",
            "                )",
            "            label = \"rowcount\"",
            "            col = self.make_sqla_column_compatible(literal_column(\"COUNT(*)\"), label)",
            "            qry = select([col]).select_from(qry.alias(\"rowcount_qry\"))",
            "            labels_expected = [label]",
            "",
            "        return SqlaQuery(",
            "            applied_template_filters=applied_template_filters,",
            "            extra_cache_keys=extra_cache_keys,",
            "            labels_expected=labels_expected,",
            "            sqla_query=qry,",
            "            prequeries=prequeries,",
            "        )",
            "",
            "    def _get_series_orderby(",
            "        self,",
            "        series_limit_metric: Metric,",
            "        metrics_by_name: Dict[str, SqlMetric],",
            "        columns_by_name: Dict[str, TableColumn],",
            "    ) -> Column:",
            "        if utils.is_adhoc_metric(series_limit_metric):",
            "            assert isinstance(series_limit_metric, dict)",
            "            ob = self.adhoc_metric_to_sqla(series_limit_metric, columns_by_name)",
            "        elif (",
            "            isinstance(series_limit_metric, str)",
            "            and series_limit_metric in metrics_by_name",
            "        ):",
            "            ob = metrics_by_name[series_limit_metric].get_sqla_col()",
            "        else:",
            "            raise QueryObjectValidationError(",
            "                _(\"Metric '%(metric)s' does not exist\", metric=series_limit_metric)",
            "            )",
            "        return ob",
            "",
            "    def _get_top_groups(",
            "        self, df: pd.DataFrame, dimensions: List[str], groupby_exprs: Dict[str, Any],",
            "    ) -> ColumnElement:",
            "        column_map = {column.column_name: column for column in self.columns}",
            "        groups = []",
            "        for _unused, row in df.iterrows():",
            "            group = []",
            "            for dimension in dimensions:",
            "                value = row[dimension]",
            "",
            "                # Some databases like Druid will return timestamps as strings, but",
            "                # do not perform automatic casting when comparing these strings to",
            "                # a timestamp. For cases like this we convert the value from a",
            "                # string into a timestamp.",
            "                if column_map[dimension].is_temporal and isinstance(value, str):",
            "                    dttm = dateutil.parser.parse(value)",
            "                    value = text(",
            "                        str(self.db_engine_spec.convert_dttm(\"TIMESTAMP\", dttm))",
            "                    )",
            "",
            "                group.append(groupby_exprs[dimension] == value)",
            "            groups.append(and_(*group))",
            "",
            "        return or_(*groups)",
            "",
            "    def query(self, query_obj: QueryObjectDict) -> QueryResult:",
            "        qry_start_dttm = datetime.now()",
            "        query_str_ext = self.get_query_str_extended(query_obj)",
            "        sql = query_str_ext.sql",
            "        status = QueryStatus.SUCCESS",
            "        errors = None",
            "        error_message = None",
            "",
            "        def assign_column_label(df: pd.DataFrame) -> Optional[pd.DataFrame]:",
            "            \"\"\"",
            "            Some engines change the case or generate bespoke column names, either by",
            "            default or due to lack of support for aliasing. This function ensures that",
            "            the column names in the DataFrame correspond to what is expected by",
            "            the viz components.",
            "",
            "            Sometimes a query may also contain only order by columns that are not used",
            "            as metrics or groupby columns, but need to present in the SQL `select`,",
            "            filtering by `labels_expected` make sure we only return columns users want.",
            "",
            "            :param df: Original DataFrame returned by the engine",
            "            :return: Mutated DataFrame",
            "            \"\"\"",
            "            labels_expected = query_str_ext.labels_expected",
            "            if df is not None and not df.empty:",
            "                if len(df.columns) < len(labels_expected):",
            "                    raise QueryObjectValidationError(",
            "                        _(\"Db engine did not return all queried columns\")",
            "                    )",
            "                if len(df.columns) > len(labels_expected):",
            "                    df = df.iloc[:, 0 : len(labels_expected)]",
            "                df.columns = labels_expected",
            "            return df",
            "",
            "        try:",
            "            df = self.database.get_df(sql, self.schema, mutator=assign_column_label)",
            "        except Exception as ex:  # pylint: disable=broad-except",
            "            df = pd.DataFrame()",
            "            status = QueryStatus.FAILED",
            "            logger.warning(",
            "                \"Query %s on schema %s failed\", sql, self.schema, exc_info=True",
            "            )",
            "            db_engine_spec = self.db_engine_spec",
            "            errors = [",
            "                dataclasses.asdict(error) for error in db_engine_spec.extract_errors(ex)",
            "            ]",
            "            error_message = utils.error_msg_from_exception(ex)",
            "",
            "        return QueryResult(",
            "            applied_template_filters=query_str_ext.applied_template_filters,",
            "            status=status,",
            "            df=df,",
            "            duration=datetime.now() - qry_start_dttm,",
            "            query=sql,",
            "            errors=errors,",
            "            error_message=error_message,",
            "        )",
            "",
            "    def get_sqla_table_object(self) -> Table:",
            "        return self.database.get_table(self.table_name, schema=self.schema)",
            "",
            "    def fetch_metadata(self, commit: bool = True) -> MetadataResult:",
            "        \"\"\"",
            "        Fetches the metadata for the table and merges it in",
            "",
            "        :param commit: should the changes be committed or not.",
            "        :return: Tuple with lists of added, removed and modified column names.",
            "        \"\"\"",
            "        new_columns = self.external_metadata()",
            "        metrics = []",
            "        any_date_col = None",
            "        db_engine_spec = self.db_engine_spec",
            "        old_columns = db.session.query(TableColumn).filter(TableColumn.table == self)",
            "",
            "        old_columns_by_name: Dict[str, TableColumn] = {",
            "            col.column_name: col for col in old_columns",
            "        }",
            "        results = MetadataResult(",
            "            removed=[",
            "                col",
            "                for col in old_columns_by_name",
            "                if col not in {col[\"name\"] for col in new_columns}",
            "            ]",
            "        )",
            "",
            "        # clear old columns before adding modified columns back",
            "        self.columns = []",
            "        for col in new_columns:",
            "            old_column = old_columns_by_name.pop(col[\"name\"], None)",
            "            if not old_column:",
            "                results.added.append(col[\"name\"])",
            "                new_column = TableColumn(",
            "                    column_name=col[\"name\"], type=col[\"type\"], table=self",
            "                )",
            "                new_column.is_dttm = new_column.is_temporal",
            "                db_engine_spec.alter_new_orm_column(new_column)",
            "            else:",
            "                new_column = old_column",
            "                if new_column.type != col[\"type\"]:",
            "                    results.modified.append(col[\"name\"])",
            "                new_column.type = col[\"type\"]",
            "                new_column.expression = \"\"",
            "            new_column.groupby = True",
            "            new_column.filterable = True",
            "            self.columns.append(new_column)",
            "            if not any_date_col and new_column.is_temporal:",
            "                any_date_col = col[\"name\"]",
            "        self.columns.extend(",
            "            [col for col in old_columns_by_name.values() if col.expression]",
            "        )",
            "        metrics.append(",
            "            SqlMetric(",
            "                metric_name=\"count\",",
            "                verbose_name=\"COUNT(*)\",",
            "                metric_type=\"count\",",
            "                expression=\"COUNT(*)\",",
            "            )",
            "        )",
            "        if not self.main_dttm_col:",
            "            self.main_dttm_col = any_date_col",
            "        self.add_missing_metrics(metrics)",
            "",
            "        # Apply config supplied mutations.",
            "        config[\"SQLA_TABLE_MUTATOR\"](self)",
            "",
            "        db.session.merge(self)",
            "        if commit:",
            "            db.session.commit()",
            "        return results",
            "",
            "    @classmethod",
            "    def query_datasources_by_name(",
            "        cls,",
            "        session: Session,",
            "        database: Database,",
            "        datasource_name: str,",
            "        schema: Optional[str] = None,",
            "    ) -> List[\"SqlaTable\"]:",
            "        query = (",
            "            session.query(cls)",
            "            .filter_by(database_id=database.id)",
            "            .filter_by(table_name=datasource_name)",
            "        )",
            "        if schema:",
            "            query = query.filter_by(schema=schema)",
            "        return query.all()",
            "",
            "    @staticmethod",
            "    def default_query(qry: Query) -> Query:",
            "        return qry.filter_by(is_sqllab_view=False)",
            "",
            "    def has_extra_cache_key_calls(self, query_obj: QueryObjectDict) -> bool:",
            "        \"\"\"",
            "        Detects the presence of calls to `ExtraCache` methods in items in query_obj that",
            "        can be templated. If any are present, the query must be evaluated to extract",
            "        additional keys for the cache key. This method is needed to avoid executing the",
            "        template code unnecessarily, as it may contain expensive calls, e.g. to extract",
            "        the latest partition of a database.",
            "",
            "        :param query_obj: query object to analyze",
            "        :return: True if there are call(s) to an `ExtraCache` method, False otherwise",
            "        \"\"\"",
            "        templatable_statements: List[str] = []",
            "        if self.sql:",
            "            templatable_statements.append(self.sql)",
            "        if self.fetch_values_predicate:",
            "            templatable_statements.append(self.fetch_values_predicate)",
            "        extras = query_obj.get(\"extras\", {})",
            "        if \"where\" in extras:",
            "            templatable_statements.append(extras[\"where\"])",
            "        if \"having\" in extras:",
            "            templatable_statements.append(extras[\"having\"])",
            "        if is_feature_enabled(\"ROW_LEVEL_SECURITY\") and self.is_rls_supported:",
            "            templatable_statements += [",
            "                f.clause for f in security_manager.get_rls_filters(self)",
            "            ]",
            "        for statement in templatable_statements:",
            "            if ExtraCache.regex.search(statement):",
            "                return True",
            "        return False",
            "",
            "    def get_extra_cache_keys(self, query_obj: QueryObjectDict) -> List[Hashable]:",
            "        \"\"\"",
            "        The cache key of a SqlaTable needs to consider any keys added by the parent",
            "        class and any keys added via `ExtraCache`.",
            "",
            "        :param query_obj: query object to analyze",
            "        :return: The extra cache keys",
            "        \"\"\"",
            "        extra_cache_keys = super().get_extra_cache_keys(query_obj)",
            "        if self.has_extra_cache_key_calls(query_obj):",
            "            sqla_query = self.get_sqla_query(**query_obj)",
            "            extra_cache_keys += sqla_query.extra_cache_keys",
            "        return extra_cache_keys",
            "",
            "    @staticmethod",
            "    def before_update(",
            "        mapper: Mapper,  # pylint: disable=unused-argument",
            "        connection: Connection,  # pylint: disable=unused-argument",
            "        target: \"SqlaTable\",",
            "    ) -> None:",
            "        \"\"\"",
            "        Check before update if the target table already exists.",
            "",
            "        Note this listener is called when any fields are being updated and thus it is",
            "        necessary to first check whether the reference table is being updated.",
            "",
            "        Note this logic is temporary, given uniqueness is handled via the dataset DAO,",
            "        but is necessary until both the legacy datasource editor and datasource/save",
            "        endpoints are deprecated.",
            "",
            "        :param mapper: The table mapper",
            "        :param connection: The DB-API connection",
            "        :param target: The mapped instance being persisted",
            "        :raises Exception: If the target table is not unique",
            "        \"\"\"",
            "",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset.datasets.commands.exceptions import get_dataset_exist_error_msg",
            "        from superset.datasets.dao import DatasetDAO",
            "",
            "        # Check whether the relevant attributes have changed.",
            "        state = db.inspect(target)  # pylint: disable=no-member",
            "",
            "        for attr in [\"database_id\", \"schema\", \"table_name\"]:",
            "            history = state.get_history(attr, True)",
            "",
            "            if history.has_changes():",
            "                break",
            "        else:",
            "            return None",
            "",
            "        if not DatasetDAO.validate_uniqueness(",
            "            target.database_id, target.schema, target.table_name",
            "        ):",
            "            raise Exception(get_dataset_exist_error_msg(target.full_name))",
            "",
            "    @staticmethod",
            "    def update_table(",
            "        _mapper: Mapper, _connection: Connection, obj: Union[SqlMetric, TableColumn]",
            "    ) -> None:",
            "        \"\"\"",
            "        Forces an update to the table's changed_on value when a metric or column on the",
            "        table is updated. This busts the cache key for all charts that use the table.",
            "",
            "        :param _mapper: Unused.",
            "        :param _connection: Unused.",
            "        :param obj: The metric or column that was updated.",
            "        \"\"\"",
            "        db.session.execute(update(SqlaTable).where(SqlaTable.id == obj.table.id))",
            "",
            "",
            "sa.event.listen(SqlaTable, \"after_insert\", security_manager.set_perm)",
            "sa.event.listen(SqlaTable, \"after_update\", security_manager.set_perm)",
            "sa.event.listen(SqlaTable, \"before_update\", SqlaTable.before_update)",
            "sa.event.listen(SqlMetric, \"after_update\", SqlaTable.update_table)",
            "sa.event.listen(TableColumn, \"after_update\", SqlaTable.update_table)",
            "",
            "RLSFilterRoles = Table(",
            "    \"rls_filter_roles\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"role_id\", Integer, ForeignKey(\"ab_role.id\"), nullable=False),",
            "    Column(\"rls_filter_id\", Integer, ForeignKey(\"row_level_security_filters.id\")),",
            ")",
            "",
            "RLSFilterTables = Table(",
            "    \"rls_filter_tables\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"table_id\", Integer, ForeignKey(\"tables.id\")),",
            "    Column(\"rls_filter_id\", Integer, ForeignKey(\"row_level_security_filters.id\")),",
            ")",
            "",
            "",
            "class RowLevelSecurityFilter(Model, AuditMixinNullable):",
            "    \"\"\"",
            "    Custom where clauses attached to Tables and Roles.",
            "    \"\"\"",
            "",
            "    __tablename__ = \"row_level_security_filters\"",
            "    id = Column(Integer, primary_key=True)",
            "    filter_type = Column(",
            "        Enum(*[filter_type.value for filter_type in utils.RowLevelSecurityFilterType])",
            "    )",
            "    group_key = Column(String(255), nullable=True)",
            "    roles = relationship(",
            "        security_manager.role_model,",
            "        secondary=RLSFilterRoles,",
            "        backref=\"row_level_security_filters\",",
            "    )",
            "    tables = relationship(",
            "        SqlaTable, secondary=RLSFilterTables, backref=\"row_level_security_filters\"",
            "    )",
            "",
            "    clause = Column(Text, nullable=False)"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "# pylint: disable=too-many-lines",
            "import dataclasses",
            "import json",
            "import logging",
            "import re",
            "from collections import defaultdict",
            "from dataclasses import dataclass, field",
            "from datetime import datetime, timedelta",
            "from typing import (",
            "    Any,",
            "    cast,",
            "    Dict,",
            "    Hashable,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    Union,",
            ")",
            "",
            "import dateutil.parser",
            "import pandas as pd",
            "import sqlalchemy as sa",
            "import sqlparse",
            "from flask import escape, Markup",
            "from flask_appbuilder import Model",
            "from flask_babel import lazy_gettext as _",
            "from jinja2.exceptions import TemplateError",
            "from sqlalchemy import (",
            "    and_,",
            "    asc,",
            "    Boolean,",
            "    Column,",
            "    DateTime,",
            "    desc,",
            "    Enum,",
            "    ForeignKey,",
            "    Integer,",
            "    or_,",
            "    select,",
            "    String,",
            "    Table,",
            "    Text,",
            "    update,",
            ")",
            "from sqlalchemy.engine.base import Connection",
            "from sqlalchemy.orm import backref, Query, relationship, RelationshipProperty, Session",
            "from sqlalchemy.orm.mapper import Mapper",
            "from sqlalchemy.schema import UniqueConstraint",
            "from sqlalchemy.sql import column, ColumnElement, literal_column, table",
            "from sqlalchemy.sql.elements import ColumnClause, TextClause",
            "from sqlalchemy.sql.expression import Label, Select, TextAsFrom",
            "from sqlalchemy.sql.selectable import Alias, TableClause",
            "",
            "from superset import app, db, is_feature_enabled, security_manager",
            "from superset.common.db_query_status import QueryStatus",
            "from superset.connectors.base.models import BaseColumn, BaseDatasource, BaseMetric",
            "from superset.connectors.sqla.utils import (",
            "    get_physical_table_metadata,",
            "    get_virtual_table_metadata,",
            ")",
            "from superset.db_engine_specs.base import BaseEngineSpec, TimestampExpression",
            "from superset.exceptions import (",
            "    QueryClauseValidationException,",
            "    QueryObjectValidationError,",
            ")",
            "from superset.jinja_context import (",
            "    BaseTemplateProcessor,",
            "    ExtraCache,",
            "    get_template_processor,",
            ")",
            "from superset.models.annotations import Annotation",
            "from superset.models.core import Database",
            "from superset.models.helpers import AuditMixinNullable, CertificationMixin, QueryResult",
            "from superset.sql_parse import ParsedQuery, sanitize_clause",
            "from superset.typing import AdhocMetric, Metric, OrderBy, QueryObjectDict",
            "from superset.utils import core as utils",
            "from superset.utils.core import (",
            "    GenericDataType,",
            "    QueryObjectFilterClause,",
            "    remove_duplicates,",
            ")",
            "",
            "config = app.config",
            "metadata = Model.metadata  # pylint: disable=no-member",
            "logger = logging.getLogger(__name__)",
            "",
            "VIRTUAL_TABLE_ALIAS = \"virtual_table\"",
            "",
            "",
            "def text(clause: str) -> TextClause:",
            "    \"\"\"",
            "    SQLALchemy wrapper to ensure text clauses are escaped properly",
            "",
            "    :param clause: clause potentially containing colons",
            "    :return: text clause with escaped colons",
            "    \"\"\"",
            "    return sa.text(clause.replace(\":\", \"\\\\:\"))",
            "",
            "",
            "class SqlaQuery(NamedTuple):",
            "    applied_template_filters: List[str]",
            "    extra_cache_keys: List[Any]",
            "    labels_expected: List[str]",
            "    prequeries: List[str]",
            "    sqla_query: Select",
            "",
            "",
            "class QueryStringExtended(NamedTuple):",
            "    applied_template_filters: Optional[List[str]]",
            "    labels_expected: List[str]",
            "    prequeries: List[str]",
            "    sql: str",
            "",
            "",
            "@dataclass",
            "class MetadataResult:",
            "    added: List[str] = field(default_factory=list)",
            "    removed: List[str] = field(default_factory=list)",
            "    modified: List[str] = field(default_factory=list)",
            "",
            "",
            "class AnnotationDatasource(BaseDatasource):",
            "    \"\"\"Dummy object so we can query annotations using 'Viz' objects just like",
            "    regular datasources.",
            "    \"\"\"",
            "",
            "    cache_timeout = 0",
            "    changed_on = None",
            "    type = \"annotation\"",
            "    column_names = [",
            "        \"created_on\",",
            "        \"changed_on\",",
            "        \"id\",",
            "        \"start_dttm\",",
            "        \"end_dttm\",",
            "        \"layer_id\",",
            "        \"short_descr\",",
            "        \"long_descr\",",
            "        \"json_metadata\",",
            "        \"created_by_fk\",",
            "        \"changed_by_fk\",",
            "    ]",
            "",
            "    def query(self, query_obj: QueryObjectDict) -> QueryResult:",
            "        error_message = None",
            "        qry = db.session.query(Annotation)",
            "        qry = qry.filter(Annotation.layer_id == query_obj[\"filter\"][0][\"val\"])",
            "        if query_obj[\"from_dttm\"]:",
            "            qry = qry.filter(Annotation.start_dttm >= query_obj[\"from_dttm\"])",
            "        if query_obj[\"to_dttm\"]:",
            "            qry = qry.filter(Annotation.end_dttm <= query_obj[\"to_dttm\"])",
            "        status = QueryStatus.SUCCESS",
            "        try:",
            "            df = pd.read_sql_query(qry.statement, db.engine)",
            "        except Exception as ex:  # pylint: disable=broad-except",
            "            df = pd.DataFrame()",
            "            status = QueryStatus.FAILED",
            "            logger.exception(ex)",
            "            error_message = utils.error_msg_from_exception(ex)",
            "        return QueryResult(",
            "            status=status,",
            "            df=df,",
            "            duration=timedelta(0),",
            "            query=\"\",",
            "            error_message=error_message,",
            "        )",
            "",
            "    def get_query_str(self, query_obj: QueryObjectDict) -> str:",
            "        raise NotImplementedError()",
            "",
            "    def values_for_column(self, column_name: str, limit: int = 10000) -> List[Any]:",
            "        raise NotImplementedError()",
            "",
            "",
            "class TableColumn(Model, BaseColumn, CertificationMixin):",
            "",
            "    \"\"\"ORM object for table columns, each table can have multiple columns\"\"\"",
            "",
            "    __tablename__ = \"table_columns\"",
            "    __table_args__ = (UniqueConstraint(\"table_id\", \"column_name\"),)",
            "    table_id = Column(Integer, ForeignKey(\"tables.id\"))",
            "    table = relationship(",
            "        \"SqlaTable\",",
            "        backref=backref(\"columns\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[table_id],",
            "    )",
            "    is_dttm = Column(Boolean, default=False)",
            "    expression = Column(Text)",
            "    python_date_format = Column(String(255))",
            "    extra = Column(Text)",
            "",
            "    export_fields = [",
            "        \"table_id\",",
            "        \"column_name\",",
            "        \"verbose_name\",",
            "        \"is_dttm\",",
            "        \"is_active\",",
            "        \"type\",",
            "        \"groupby\",",
            "        \"filterable\",",
            "        \"expression\",",
            "        \"description\",",
            "        \"python_date_format\",",
            "        \"extra\",",
            "    ]",
            "",
            "    update_from_object_fields = [s for s in export_fields if s not in (\"table_id\",)]",
            "    export_parent = \"table\"",
            "",
            "    @property",
            "    def is_boolean(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a boolean datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.BOOLEAN",
            "",
            "    @property",
            "    def is_numeric(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a numeric datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.NUMERIC",
            "",
            "    @property",
            "    def is_string(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a string datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.STRING",
            "",
            "    @property",
            "    def is_temporal(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a temporal datatype. If column has been set as",
            "        temporal/non-temporal (`is_dttm` is True or False respectively), return that",
            "        value. This usually happens during initial metadata fetching or when a column",
            "        is manually set as temporal (for this `python_date_format` needs to be set).",
            "        \"\"\"",
            "        if self.is_dttm is not None:",
            "            return self.is_dttm",
            "        return self.type_generic == GenericDataType.TEMPORAL",
            "",
            "    @property",
            "    def db_engine_spec(self) -> Type[BaseEngineSpec]:",
            "        return self.table.db_engine_spec",
            "",
            "    @property",
            "    def type_generic(self) -> Optional[utils.GenericDataType]:",
            "        if self.is_dttm:",
            "            return GenericDataType.TEMPORAL",
            "        column_spec = self.db_engine_spec.get_column_spec(self.type)",
            "        return column_spec.generic_type if column_spec else None",
            "",
            "    def get_sqla_col(self, label: Optional[str] = None) -> Column:",
            "        label = label or self.column_name",
            "        db_engine_spec = self.db_engine_spec",
            "        column_spec = db_engine_spec.get_column_spec(self.type)",
            "        type_ = column_spec.sqla_type if column_spec else None",
            "        if self.expression:",
            "            tp = self.table.get_template_processor()",
            "            expression = tp.process_template(self.expression)",
            "            col = literal_column(expression, type_=type_)",
            "        else:",
            "            col = column(self.column_name, type_=type_)",
            "        col = self.table.make_sqla_column_compatible(col, label)",
            "        return col",
            "",
            "    @property",
            "    def datasource(self) -> RelationshipProperty:",
            "        return self.table",
            "",
            "    def get_time_filter(",
            "        self,",
            "        start_dttm: DateTime,",
            "        end_dttm: DateTime,",
            "        time_range_endpoints: Optional[",
            "            Tuple[utils.TimeRangeEndpoint, utils.TimeRangeEndpoint]",
            "        ],",
            "    ) -> ColumnElement:",
            "        col = self.get_sqla_col(label=\"__time\")",
            "        l = []",
            "        if start_dttm:",
            "            l.append(",
            "                col >= text(self.dttm_sql_literal(start_dttm, time_range_endpoints))",
            "            )",
            "        if end_dttm:",
            "            if (",
            "                time_range_endpoints",
            "                and time_range_endpoints[1] == utils.TimeRangeEndpoint.EXCLUSIVE",
            "            ):",
            "                l.append(",
            "                    col < text(self.dttm_sql_literal(end_dttm, time_range_endpoints))",
            "                )",
            "            else:",
            "                l.append(col <= text(self.dttm_sql_literal(end_dttm, None)))",
            "        return and_(*l)",
            "",
            "    def get_timestamp_expression(",
            "        self, time_grain: Optional[str], label: Optional[str] = None",
            "    ) -> Union[TimestampExpression, Label]:",
            "        \"\"\"",
            "        Return a SQLAlchemy Core element representation of self to be used in a query.",
            "",
            "        :param time_grain: Optional time grain, e.g. P1Y",
            "        :param label: alias/label that column is expected to have",
            "        :return: A TimeExpression object wrapped in a Label if supported by db",
            "        \"\"\"",
            "        label = label or utils.DTTM_ALIAS",
            "",
            "        pdf = self.python_date_format",
            "        is_epoch = pdf in (\"epoch_s\", \"epoch_ms\")",
            "        column_spec = self.db_engine_spec.get_column_spec(self.type)",
            "        type_ = column_spec.sqla_type if column_spec else DateTime",
            "        if not self.expression and not time_grain and not is_epoch:",
            "            sqla_col = column(self.column_name, type_=type_)",
            "            return self.table.make_sqla_column_compatible(sqla_col, label)",
            "        if self.expression:",
            "            col = literal_column(self.expression, type_=type_)",
            "        else:",
            "            col = column(self.column_name, type_=type_)",
            "        time_expr = self.db_engine_spec.get_timestamp_expr(",
            "            col, pdf, time_grain, self.type",
            "        )",
            "        return self.table.make_sqla_column_compatible(time_expr, label)",
            "",
            "    def dttm_sql_literal(",
            "        self,",
            "        dttm: DateTime,",
            "        time_range_endpoints: Optional[",
            "            Tuple[utils.TimeRangeEndpoint, utils.TimeRangeEndpoint]",
            "        ],",
            "    ) -> str:",
            "        \"\"\"Convert datetime object to a SQL expression string\"\"\"",
            "        dttm_type = self.type or (\"DATETIME\" if self.is_dttm else None)",
            "        sql = self.db_engine_spec.convert_dttm(dttm_type, dttm) if dttm_type else None",
            "",
            "        if sql:",
            "            return sql",
            "",
            "        tf = self.python_date_format",
            "",
            "        # Fallback to the default format (if defined) only if the SIP-15 time range",
            "        # endpoints, i.e., [start, end) are enabled.",
            "        if not tf and time_range_endpoints == (",
            "            utils.TimeRangeEndpoint.INCLUSIVE,",
            "            utils.TimeRangeEndpoint.EXCLUSIVE,",
            "        ):",
            "            tf = (",
            "                self.table.database.get_extra()",
            "                .get(\"python_date_format_by_column_name\", {})",
            "                .get(self.column_name)",
            "            )",
            "",
            "        if tf:",
            "            if tf in [\"epoch_ms\", \"epoch_s\"]:",
            "                seconds_since_epoch = int(dttm.timestamp())",
            "                if tf == \"epoch_s\":",
            "                    return str(seconds_since_epoch)",
            "                return str(seconds_since_epoch * 1000)",
            "            return f\"'{dttm.strftime(tf)}'\"",
            "",
            "        # TODO(john-bodley): SIP-15 will explicitly require a type conversion.",
            "        return f\"\"\"'{dttm.strftime(\"%Y-%m-%d %H:%M:%S.%f\")}'\"\"\"",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        attrs = (",
            "            \"id\",",
            "            \"column_name\",",
            "            \"verbose_name\",",
            "            \"description\",",
            "            \"expression\",",
            "            \"filterable\",",
            "            \"groupby\",",
            "            \"is_dttm\",",
            "            \"type\",",
            "            \"type_generic\",",
            "            \"python_date_format\",",
            "            \"is_certified\",",
            "            \"certified_by\",",
            "            \"certification_details\",",
            "            \"warning_markdown\",",
            "        )",
            "",
            "        attr_dict = {s: getattr(self, s) for s in attrs if hasattr(self, s)}",
            "",
            "        attr_dict.update(super().data)",
            "",
            "        return attr_dict",
            "",
            "",
            "class SqlMetric(Model, BaseMetric, CertificationMixin):",
            "",
            "    \"\"\"ORM object for metrics, each table can have multiple metrics\"\"\"",
            "",
            "    __tablename__ = \"sql_metrics\"",
            "    __table_args__ = (UniqueConstraint(\"table_id\", \"metric_name\"),)",
            "    table_id = Column(Integer, ForeignKey(\"tables.id\"))",
            "    table = relationship(",
            "        \"SqlaTable\",",
            "        backref=backref(\"metrics\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[table_id],",
            "    )",
            "    expression = Column(Text, nullable=False)",
            "    extra = Column(Text)",
            "",
            "    export_fields = [",
            "        \"metric_name\",",
            "        \"verbose_name\",",
            "        \"metric_type\",",
            "        \"table_id\",",
            "        \"expression\",",
            "        \"description\",",
            "        \"d3format\",",
            "        \"extra\",",
            "        \"warning_text\",",
            "    ]",
            "    update_from_object_fields = list(s for s in export_fields if s != \"table_id\")",
            "    export_parent = \"table\"",
            "",
            "    def get_sqla_col(self, label: Optional[str] = None) -> Column:",
            "        label = label or self.metric_name",
            "        tp = self.table.get_template_processor()",
            "        sqla_col: ColumnClause = literal_column(tp.process_template(self.expression))",
            "        return self.table.make_sqla_column_compatible(sqla_col, label)",
            "",
            "    @property",
            "    def perm(self) -> Optional[str]:",
            "        return (",
            "            (\"{parent_name}.[{obj.metric_name}](id:{obj.id})\").format(",
            "                obj=self, parent_name=self.table.full_name",
            "            )",
            "            if self.table",
            "            else None",
            "        )",
            "",
            "    def get_perm(self) -> Optional[str]:",
            "        return self.perm",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        attrs = (",
            "            \"is_certified\",",
            "            \"certified_by\",",
            "            \"certification_details\",",
            "            \"warning_markdown\",",
            "        )",
            "        attr_dict = {s: getattr(self, s) for s in attrs}",
            "",
            "        attr_dict.update(super().data)",
            "        return attr_dict",
            "",
            "",
            "sqlatable_user = Table(",
            "    \"sqlatable_user\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"user_id\", Integer, ForeignKey(\"ab_user.id\")),",
            "    Column(\"table_id\", Integer, ForeignKey(\"tables.id\")),",
            ")",
            "",
            "",
            "class SqlaTable(Model, BaseDatasource):  # pylint: disable=too-many-public-methods",
            "    \"\"\"An ORM object for SqlAlchemy table references\"\"\"",
            "",
            "    type = \"table\"",
            "    query_language = \"sql\"",
            "    is_rls_supported = True",
            "    columns: List[TableColumn] = []",
            "    metrics: List[SqlMetric] = []",
            "    metric_class = SqlMetric",
            "    column_class = TableColumn",
            "    owner_class = security_manager.user_model",
            "",
            "    __tablename__ = \"tables\"",
            "",
            "    # Note this uniqueness constraint is not part of the physical schema, i.e., it does",
            "    # not exist in the migrations, but is required by `import_from_dict` to ensure the",
            "    # correct filters are applied in order to identify uniqueness.",
            "    #",
            "    # The reason it does not physically exist is MySQL, PostgreSQL, etc. have a",
            "    # different interpretation of uniqueness when it comes to NULL which is problematic",
            "    # given the schema is optional.",
            "    __table_args__ = (UniqueConstraint(\"database_id\", \"schema\", \"table_name\"),)",
            "",
            "    table_name = Column(String(250), nullable=False)",
            "    main_dttm_col = Column(String(250))",
            "    database_id = Column(Integer, ForeignKey(\"dbs.id\"), nullable=False)",
            "    fetch_values_predicate = Column(Text)",
            "    owners = relationship(owner_class, secondary=sqlatable_user, backref=\"tables\")",
            "    database: Database = relationship(",
            "        \"Database\",",
            "        backref=backref(\"tables\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[database_id],",
            "    )",
            "    schema = Column(String(255))",
            "    sql = Column(Text)",
            "    is_sqllab_view = Column(Boolean, default=False)",
            "    template_params = Column(Text)",
            "    extra = Column(Text)",
            "",
            "    baselink = \"tablemodelview\"",
            "",
            "    export_fields = [",
            "        \"table_name\",",
            "        \"main_dttm_col\",",
            "        \"description\",",
            "        \"default_endpoint\",",
            "        \"database_id\",",
            "        \"offset\",",
            "        \"cache_timeout\",",
            "        \"schema\",",
            "        \"sql\",",
            "        \"params\",",
            "        \"template_params\",",
            "        \"filter_select_enabled\",",
            "        \"fetch_values_predicate\",",
            "        \"extra\",",
            "    ]",
            "    update_from_object_fields = [f for f in export_fields if f != \"database_id\"]",
            "    export_parent = \"database\"",
            "    export_children = [\"metrics\", \"columns\"]",
            "",
            "    sqla_aggregations = {",
            "        \"COUNT_DISTINCT\": lambda column_name: sa.func.COUNT(sa.distinct(column_name)),",
            "        \"COUNT\": sa.func.COUNT,",
            "        \"SUM\": sa.func.SUM,",
            "        \"AVG\": sa.func.AVG,",
            "        \"MIN\": sa.func.MIN,",
            "        \"MAX\": sa.func.MAX,",
            "    }",
            "",
            "    def __repr__(self) -> str:",
            "        return self.name",
            "",
            "    @property",
            "    def db_engine_spec(self) -> Type[BaseEngineSpec]:",
            "        return self.database.db_engine_spec",
            "",
            "    @property",
            "    def changed_by_name(self) -> str:",
            "        if not self.changed_by:",
            "            return \"\"",
            "        return str(self.changed_by)",
            "",
            "    @property",
            "    def changed_by_url(self) -> str:",
            "        if not self.changed_by:",
            "            return \"\"",
            "        return f\"/superset/profile/{self.changed_by.username}\"",
            "",
            "    @property",
            "    def connection(self) -> str:",
            "        return str(self.database)",
            "",
            "    @property",
            "    def description_markeddown(self) -> str:",
            "        return utils.markdown(self.description)",
            "",
            "    @property",
            "    def datasource_name(self) -> str:",
            "        return self.table_name",
            "",
            "    @property",
            "    def datasource_type(self) -> str:",
            "        return self.type",
            "",
            "    @property",
            "    def database_name(self) -> str:",
            "        return self.database.name",
            "",
            "    @classmethod",
            "    def get_datasource_by_name(",
            "        cls,",
            "        session: Session,",
            "        datasource_name: str,",
            "        schema: Optional[str],",
            "        database_name: str,",
            "    ) -> Optional[\"SqlaTable\"]:",
            "        schema = schema or None",
            "        query = (",
            "            session.query(cls)",
            "            .join(Database)",
            "            .filter(cls.table_name == datasource_name)",
            "            .filter(Database.database_name == database_name)",
            "        )",
            "        # Handling schema being '' or None, which is easier to handle",
            "        # in python than in the SQLA query in a multi-dialect way",
            "        for tbl in query.all():",
            "            if schema == (tbl.schema or None):",
            "                return tbl",
            "        return None",
            "",
            "    @property",
            "    def link(self) -> Markup:",
            "        name = escape(self.name)",
            "        anchor = f'<a target=\"_blank\" href=\"{self.explore_url}\">{name}</a>'",
            "        return Markup(anchor)",
            "",
            "    def get_schema_perm(self) -> Optional[str]:",
            "        \"\"\"Returns schema permission if present, database one otherwise.\"\"\"",
            "        return security_manager.get_schema_perm(self.database, self.schema)",
            "",
            "    def get_perm(self) -> str:",
            "        return f\"[{self.database}].[{self.table_name}](id:{self.id})\"",
            "",
            "    @property",
            "    def name(self) -> str:",
            "        if not self.schema:",
            "            return self.table_name",
            "        return \"{}.{}\".format(self.schema, self.table_name)",
            "",
            "    @property",
            "    def full_name(self) -> str:",
            "        return utils.get_datasource_full_name(",
            "            self.database, self.table_name, schema=self.schema",
            "        )",
            "",
            "    @property",
            "    def dttm_cols(self) -> List[str]:",
            "        l = [c.column_name for c in self.columns if c.is_dttm]",
            "        if self.main_dttm_col and self.main_dttm_col not in l:",
            "            l.append(self.main_dttm_col)",
            "        return l",
            "",
            "    @property",
            "    def num_cols(self) -> List[str]:",
            "        return [c.column_name for c in self.columns if c.is_numeric]",
            "",
            "    @property",
            "    def any_dttm_col(self) -> Optional[str]:",
            "        cols = self.dttm_cols",
            "        return cols[0] if cols else None",
            "",
            "    @property",
            "    def html(self) -> str:",
            "        df = pd.DataFrame((c.column_name, c.type) for c in self.columns)",
            "        df.columns = [\"field\", \"type\"]",
            "        return df.to_html(",
            "            index=False,",
            "            classes=(\"dataframe table table-striped table-bordered \" \"table-condensed\"),",
            "        )",
            "",
            "    @property",
            "    def sql_url(self) -> str:",
            "        return self.database.sql_url + \"?table_name=\" + str(self.table_name)",
            "",
            "    def external_metadata(self) -> List[Dict[str, str]]:",
            "        if self.sql:",
            "            return get_virtual_table_metadata(dataset=self)",
            "        return get_physical_table_metadata(",
            "            database=self.database, table_name=self.table_name, schema_name=self.schema,",
            "        )",
            "",
            "    @property",
            "    def time_column_grains(self) -> Dict[str, Any]:",
            "        return {",
            "            \"time_columns\": self.dttm_cols,",
            "            \"time_grains\": [grain.name for grain in self.database.grains()],",
            "        }",
            "",
            "    @property",
            "    def select_star(self) -> Optional[str]:",
            "        # show_cols and latest_partition set to false to avoid",
            "        # the expensive cost of inspecting the DB",
            "        return self.database.select_star(",
            "            self.table_name, schema=self.schema, show_cols=False, latest_partition=False",
            "        )",
            "",
            "    @property",
            "    def health_check_message(self) -> Optional[str]:",
            "        check = config[\"DATASET_HEALTH_CHECK\"]",
            "        return check(self) if check else None",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        data_ = super().data",
            "        if self.type == \"table\":",
            "            data_[\"granularity_sqla\"] = utils.choicify(self.dttm_cols)",
            "            data_[\"time_grain_sqla\"] = [",
            "                (g.duration, g.name) for g in self.database.grains() or []",
            "            ]",
            "            data_[\"main_dttm_col\"] = self.main_dttm_col",
            "            data_[\"fetch_values_predicate\"] = self.fetch_values_predicate",
            "            data_[\"template_params\"] = self.template_params",
            "            data_[\"is_sqllab_view\"] = self.is_sqllab_view",
            "            data_[\"health_check_message\"] = self.health_check_message",
            "            data_[\"extra\"] = self.extra",
            "        return data_",
            "",
            "    @property",
            "    def extra_dict(self) -> Dict[str, Any]:",
            "        try:",
            "            return json.loads(self.extra)",
            "        except (TypeError, json.JSONDecodeError):",
            "            return {}",
            "",
            "    def get_fetch_values_predicate(self) -> TextClause:",
            "        tp = self.get_template_processor()",
            "        try:",
            "            return text(tp.process_template(self.fetch_values_predicate))",
            "        except TemplateError as ex:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Error in jinja expression in fetch values predicate: %(msg)s\",",
            "                    msg=ex.message,",
            "                )",
            "            ) from ex",
            "",
            "    def values_for_column(self, column_name: str, limit: int = 10000) -> List[Any]:",
            "        \"\"\"Runs query against sqla to retrieve some",
            "        sample values for the given column.",
            "        \"\"\"",
            "        cols = {col.column_name: col for col in self.columns}",
            "        target_col = cols[column_name]",
            "        tp = self.get_template_processor()",
            "",
            "        qry = (",
            "            select([target_col.get_sqla_col()])",
            "            .select_from(self.get_from_clause(tp))",
            "            .distinct()",
            "        )",
            "        if limit:",
            "            qry = qry.limit(limit)",
            "",
            "        if self.fetch_values_predicate:",
            "            qry = qry.where(self.get_fetch_values_predicate())",
            "",
            "        engine = self.database.get_sqla_engine()",
            "        sql = \"{}\".format(qry.compile(engine, compile_kwargs={\"literal_binds\": True}))",
            "        sql = self.mutate_query_from_config(sql)",
            "",
            "        df = pd.read_sql_query(sql=sql, con=engine)",
            "        return df[column_name].to_list()",
            "",
            "    def mutate_query_from_config(self, sql: str) -> str:",
            "        \"\"\"Apply config's SQL_QUERY_MUTATOR",
            "",
            "        Typically adds comments to the query with context\"\"\"",
            "        sql_query_mutator = config[\"SQL_QUERY_MUTATOR\"]",
            "        if sql_query_mutator:",
            "            username = utils.get_username()",
            "            sql = sql_query_mutator(sql, username, security_manager, self.database)",
            "        return sql",
            "",
            "    def get_template_processor(self, **kwargs: Any) -> BaseTemplateProcessor:",
            "        return get_template_processor(table=self, database=self.database, **kwargs)",
            "",
            "    def get_query_str_extended(self, query_obj: QueryObjectDict) -> QueryStringExtended:",
            "        sqlaq = self.get_sqla_query(**query_obj)",
            "        sql = self.database.compile_sqla_query(sqlaq.sqla_query)",
            "        sql = sqlparse.format(sql, reindent=True)",
            "        sql = self.mutate_query_from_config(sql)",
            "        return QueryStringExtended(",
            "            applied_template_filters=sqlaq.applied_template_filters,",
            "            labels_expected=sqlaq.labels_expected,",
            "            prequeries=sqlaq.prequeries,",
            "            sql=sql,",
            "        )",
            "",
            "    def get_query_str(self, query_obj: QueryObjectDict) -> str:",
            "        query_str_ext = self.get_query_str_extended(query_obj)",
            "        all_queries = query_str_ext.prequeries + [query_str_ext.sql]",
            "        return \";\\n\\n\".join(all_queries) + \";\"",
            "",
            "    def get_sqla_table(self) -> TableClause:",
            "        tbl = table(self.table_name)",
            "        if self.schema:",
            "            tbl.schema = self.schema",
            "        return tbl",
            "",
            "    def get_from_clause(",
            "        self, template_processor: Optional[BaseTemplateProcessor] = None",
            "    ) -> Union[TableClause, Alias]:",
            "        \"\"\"",
            "        Return where to select the columns and metrics from. Either a physical table",
            "        or a virtual table with it's own subquery.",
            "        \"\"\"",
            "        if not self.is_virtual:",
            "            return self.get_sqla_table()",
            "",
            "        from_sql = self.get_rendered_sql(template_processor)",
            "        parsed_query = ParsedQuery(from_sql)",
            "        if not (",
            "            parsed_query.is_unknown()",
            "            or self.db_engine_spec.is_readonly_query(parsed_query)",
            "        ):",
            "            raise QueryObjectValidationError(",
            "                _(\"Virtual dataset query must be read-only\")",
            "            )",
            "        return TextAsFrom(text(from_sql), []).alias(VIRTUAL_TABLE_ALIAS)",
            "",
            "    def get_rendered_sql(",
            "        self, template_processor: Optional[BaseTemplateProcessor] = None",
            "    ) -> str:",
            "        \"\"\"",
            "        Render sql with template engine (Jinja).",
            "        \"\"\"",
            "",
            "        sql = self.sql",
            "        if template_processor:",
            "            try:",
            "                sql = template_processor.process_template(sql)",
            "            except TemplateError as ex:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"Error while rendering virtual dataset query: %(msg)s\",",
            "                        msg=ex.message,",
            "                    )",
            "                ) from ex",
            "        sql = sqlparse.format(sql.strip(\"\\t\\r\\n; \"), strip_comments=True)",
            "        if not sql:",
            "            raise QueryObjectValidationError(_(\"Virtual dataset query cannot be empty\"))",
            "        if len(sqlparse.split(sql)) > 1:",
            "            raise QueryObjectValidationError(",
            "                _(\"Virtual dataset query cannot consist of multiple statements\")",
            "            )",
            "        return sql",
            "",
            "    def adhoc_metric_to_sqla(",
            "        self, metric: AdhocMetric, columns_by_name: Dict[str, TableColumn]",
            "    ) -> ColumnElement:",
            "        \"\"\"",
            "        Turn an adhoc metric into a sqlalchemy column.",
            "",
            "        :param dict metric: Adhoc metric definition",
            "        :param dict columns_by_name: Columns for the current table",
            "        :returns: The metric defined as a sqlalchemy column",
            "        :rtype: sqlalchemy.sql.column",
            "        \"\"\"",
            "        expression_type = metric.get(\"expressionType\")",
            "        label = utils.get_metric_name(metric)",
            "",
            "        if expression_type == utils.AdhocMetricExpressionType.SIMPLE:",
            "            metric_column = metric.get(\"column\") or {}",
            "            column_name = cast(str, metric_column.get(\"column_name\"))",
            "            table_column: Optional[TableColumn] = columns_by_name.get(column_name)",
            "            if table_column:",
            "                sqla_column = table_column.get_sqla_col()",
            "            else:",
            "                sqla_column = column(column_name)",
            "            sqla_metric = self.sqla_aggregations[metric[\"aggregate\"]](sqla_column)",
            "        elif expression_type == utils.AdhocMetricExpressionType.SQL:",
            "            tp = self.get_template_processor()",
            "            expression = tp.process_template(cast(str, metric[\"sqlExpression\"]))",
            "            try:",
            "                expression = sanitize_clause(expression)",
            "            except QueryClauseValidationException as ex:",
            "                raise QueryObjectValidationError(ex.message) from ex",
            "            sqla_metric = literal_column(expression)",
            "        else:",
            "            raise QueryObjectValidationError(\"Adhoc metric expressionType is invalid\")",
            "",
            "        return self.make_sqla_column_compatible(sqla_metric, label)",
            "",
            "    def make_sqla_column_compatible(",
            "        self, sqla_col: ColumnElement, label: Optional[str] = None",
            "    ) -> ColumnElement:",
            "        \"\"\"Takes a sqlalchemy column object and adds label info if supported by engine.",
            "        :param sqla_col: sqlalchemy column instance",
            "        :param label: alias/label that column is expected to have",
            "        :return: either a sql alchemy column or label instance if supported by engine",
            "        \"\"\"",
            "        label_expected = label or sqla_col.name",
            "        db_engine_spec = self.db_engine_spec",
            "        # add quotes to tables",
            "        if db_engine_spec.allows_alias_in_select:",
            "            label = db_engine_spec.make_label_compatible(label_expected)",
            "            sqla_col = sqla_col.label(label)",
            "        sqla_col.key = label_expected",
            "        return sqla_col",
            "",
            "    def make_orderby_compatible(",
            "        self, select_exprs: List[ColumnElement], orderby_exprs: List[ColumnElement]",
            "    ) -> None:",
            "        \"\"\"",
            "        If needed, make sure aliases for selected columns are not used in",
            "        `ORDER BY`.",
            "",
            "        In some databases (e.g. Presto), `ORDER BY` clause is not able to",
            "        automatically pick the source column if a `SELECT` clause alias is named",
            "        the same as a source column. In this case, we update the SELECT alias to",
            "        another name to avoid the conflict.",
            "        \"\"\"",
            "        if self.db_engine_spec.allows_alias_to_source_column:",
            "            return",
            "",
            "        def is_alias_used_in_orderby(col: ColumnElement) -> bool:",
            "            if not isinstance(col, Label):",
            "                return False",
            "            regexp = re.compile(f\"\\\\(.*\\\\b{re.escape(col.name)}\\\\b.*\\\\)\", re.IGNORECASE)",
            "            return any(regexp.search(str(x)) for x in orderby_exprs)",
            "",
            "        # Iterate through selected columns, if column alias appears in orderby",
            "        # use another `alias`. The final output columns will still use the",
            "        # original names, because they are updated by `labels_expected` after",
            "        # querying.",
            "        for col in select_exprs:",
            "            if is_alias_used_in_orderby(col):",
            "                col.name = f\"{col.name}__\"",
            "",
            "    def _get_sqla_row_level_filters(",
            "        self, template_processor: BaseTemplateProcessor",
            "    ) -> List[str]:",
            "        \"\"\"",
            "        Return the appropriate row level security filters for",
            "        this table and the current user.",
            "",
            "        :param BaseTemplateProcessor template_processor: The template",
            "        processor to apply to the filters.",
            "        :returns: A list of SQL clauses to be ANDed together.",
            "        :rtype: List[str]",
            "        \"\"\"",
            "        filters_grouped: Dict[Union[int, str], List[str]] = defaultdict(list)",
            "        try:",
            "            for filter_ in security_manager.get_rls_filters(self):",
            "                clause = text(",
            "                    f\"({template_processor.process_template(filter_.clause)})\"",
            "                )",
            "                filters_grouped[filter_.group_key or filter_.id].append(clause)",
            "            return [or_(*clauses) for clauses in filters_grouped.values()]",
            "        except TemplateError as ex:",
            "            raise QueryObjectValidationError(",
            "                _(\"Error in jinja expression in RLS filters: %(msg)s\", msg=ex.message,)",
            "            ) from ex",
            "",
            "    def get_sqla_query(  # pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements",
            "        self,",
            "        apply_fetch_values_predicate: bool = False,",
            "        columns: Optional[List[str]] = None,",
            "        extras: Optional[Dict[str, Any]] = None,",
            "        filter: Optional[  # pylint: disable=redefined-builtin",
            "            List[QueryObjectFilterClause]",
            "        ] = None,",
            "        from_dttm: Optional[datetime] = None,",
            "        granularity: Optional[str] = None,",
            "        groupby: Optional[List[str]] = None,",
            "        inner_from_dttm: Optional[datetime] = None,",
            "        inner_to_dttm: Optional[datetime] = None,",
            "        is_rowcount: bool = False,",
            "        is_timeseries: bool = True,",
            "        metrics: Optional[List[Metric]] = None,",
            "        orderby: Optional[List[OrderBy]] = None,",
            "        order_desc: bool = True,",
            "        to_dttm: Optional[datetime] = None,",
            "        series_columns: Optional[List[str]] = None,",
            "        series_limit: Optional[int] = None,",
            "        series_limit_metric: Optional[Metric] = None,",
            "        row_limit: Optional[int] = None,",
            "        row_offset: Optional[int] = None,",
            "        timeseries_limit: Optional[int] = None,",
            "        timeseries_limit_metric: Optional[Metric] = None,",
            "    ) -> SqlaQuery:",
            "        \"\"\"Querying any sqla table from this common interface\"\"\"",
            "        if granularity not in self.dttm_cols and granularity is not None:",
            "            granularity = self.main_dttm_col",
            "",
            "        extras = extras or {}",
            "        time_grain = extras.get(\"time_grain_sqla\")",
            "",
            "        template_kwargs = {",
            "            \"columns\": columns,",
            "            \"from_dttm\": from_dttm.isoformat() if from_dttm else None,",
            "            \"groupby\": groupby,",
            "            \"metrics\": metrics,",
            "            \"row_limit\": row_limit,",
            "            \"row_offset\": row_offset,",
            "            \"time_column\": granularity,",
            "            \"time_grain\": time_grain,",
            "            \"to_dttm\": to_dttm.isoformat() if to_dttm else None,",
            "            \"table_columns\": [col.column_name for col in self.columns],",
            "            \"filter\": filter,",
            "        }",
            "        series_columns = series_columns or []",
            "        # deprecated, to be removed in 2.0",
            "        if is_timeseries and timeseries_limit:",
            "            series_limit = timeseries_limit",
            "        series_limit_metric = series_limit_metric or timeseries_limit_metric",
            "        template_kwargs.update(self.template_params_dict)",
            "        extra_cache_keys: List[Any] = []",
            "        template_kwargs[\"extra_cache_keys\"] = extra_cache_keys",
            "        removed_filters: List[str] = []",
            "        applied_template_filters: List[str] = []",
            "        template_kwargs[\"removed_filters\"] = removed_filters",
            "        template_kwargs[\"applied_filters\"] = applied_template_filters",
            "        template_processor = self.get_template_processor(**template_kwargs)",
            "        db_engine_spec = self.db_engine_spec",
            "        prequeries: List[str] = []",
            "        orderby = orderby or []",
            "        need_groupby = bool(metrics is not None or groupby)",
            "        metrics = metrics or []",
            "",
            "        # For backward compatibility",
            "        if granularity not in self.dttm_cols and granularity is not None:",
            "            granularity = self.main_dttm_col",
            "",
            "        columns_by_name: Dict[str, TableColumn] = {",
            "            col.column_name: col for col in self.columns",
            "        }",
            "        metrics_by_name: Dict[str, SqlMetric] = {m.metric_name: m for m in self.metrics}",
            "",
            "        if not granularity and is_timeseries:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Datetime column not provided as part table configuration \"",
            "                    \"and is required by this type of chart\"",
            "                )",
            "            )",
            "        if not metrics and not columns and not groupby:",
            "            raise QueryObjectValidationError(_(\"Empty query?\"))",
            "",
            "        metrics_exprs: List[ColumnElement] = []",
            "        for metric in metrics:",
            "            if utils.is_adhoc_metric(metric):",
            "                assert isinstance(metric, dict)",
            "                metrics_exprs.append(self.adhoc_metric_to_sqla(metric, columns_by_name))",
            "            elif isinstance(metric, str) and metric in metrics_by_name:",
            "                metrics_exprs.append(metrics_by_name[metric].get_sqla_col())",
            "            else:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Metric '%(metric)s' does not exist\", metric=metric)",
            "                )",
            "",
            "        if metrics_exprs:",
            "            main_metric_expr = metrics_exprs[0]",
            "        else:",
            "            main_metric_expr, label = literal_column(\"COUNT(*)\"), \"ccount\"",
            "            main_metric_expr = self.make_sqla_column_compatible(main_metric_expr, label)",
            "",
            "        # To ensure correct handling of the ORDER BY labeling we need to reference the",
            "        # metric instance if defined in the SELECT clause.",
            "        # use the key of the ColumnClause for the expected label",
            "        metrics_exprs_by_label = {m.key: m for m in metrics_exprs}",
            "        metrics_exprs_by_expr = {str(m): m for m in metrics_exprs}",
            "",
            "        # Since orderby may use adhoc metrics, too; we need to process them first",
            "        orderby_exprs: List[ColumnElement] = []",
            "        for orig_col, ascending in orderby:",
            "            col: Union[AdhocMetric, ColumnElement] = orig_col",
            "            if isinstance(col, dict):",
            "                col = cast(AdhocMetric, col)",
            "                if utils.is_adhoc_metric(col):",
            "                    # add adhoc sort by column to columns_by_name if not exists",
            "                    col = self.adhoc_metric_to_sqla(col, columns_by_name)",
            "                    # if the adhoc metric has been defined before",
            "                    # use the existing instance.",
            "                    col = metrics_exprs_by_expr.get(str(col), col)",
            "                    need_groupby = True",
            "            elif col in columns_by_name:",
            "                col = columns_by_name[col].get_sqla_col()",
            "            elif col in metrics_exprs_by_label:",
            "                col = metrics_exprs_by_label[col]",
            "                need_groupby = True",
            "            elif col in metrics_by_name:",
            "                col = metrics_by_name[col].get_sqla_col()",
            "                need_groupby = True",
            "",
            "            if isinstance(col, ColumnElement):",
            "                orderby_exprs.append(col)",
            "            else:",
            "                # Could not convert a column reference to valid ColumnElement",
            "                raise QueryObjectValidationError(",
            "                    _(\"Unknown column used in orderby: %(col)s\", col=orig_col)",
            "                )",
            "",
            "        select_exprs: List[Union[Column, Label]] = []",
            "        groupby_all_columns = {}",
            "        groupby_series_columns = {}",
            "",
            "        # filter out the pseudo column  __timestamp from columns",
            "        columns = columns or []",
            "        columns = [col for col in columns if col != utils.DTTM_ALIAS]",
            "        dttm_col = columns_by_name.get(granularity) if granularity else None",
            "",
            "        if need_groupby:",
            "            # dedup columns while preserving order",
            "            columns = groupby or columns",
            "            for selected in columns:",
            "                # if groupby field/expr equals granularity field/expr",
            "                table_col = columns_by_name.get(selected)",
            "                if table_col and table_col.type_generic == GenericDataType.TEMPORAL:",
            "                    outer = table_col.get_timestamp_expression(time_grain, selected)",
            "                # if groupby field equals a selected column",
            "                elif table_col:",
            "                    outer = table_col.get_sqla_col()",
            "                else:",
            "                    outer = literal_column(f\"({selected})\")",
            "                    outer = self.make_sqla_column_compatible(outer, selected)",
            "                groupby_all_columns[outer.name] = outer",
            "                if not series_columns or outer.name in series_columns:",
            "                    groupby_series_columns[outer.name] = outer",
            "                select_exprs.append(outer)",
            "        elif columns:",
            "            for selected in columns:",
            "                select_exprs.append(",
            "                    columns_by_name[selected].get_sqla_col()",
            "                    if selected in columns_by_name",
            "                    else self.make_sqla_column_compatible(literal_column(selected))",
            "                )",
            "            metrics_exprs = []",
            "",
            "        time_range_endpoints = extras.get(\"time_range_endpoints\")",
            "",
            "        if granularity:",
            "            if granularity not in columns_by_name or not dttm_col:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        'Time column \"%(col)s\" does not exist in dataset',",
            "                        col=granularity,",
            "                    )",
            "                )",
            "            time_filters = []",
            "",
            "            if is_timeseries:",
            "                timestamp = dttm_col.get_timestamp_expression(time_grain)",
            "                # always put timestamp as the first column",
            "                select_exprs.insert(0, timestamp)",
            "                groupby_all_columns[timestamp.name] = timestamp",
            "",
            "            # Use main dttm column to support index with secondary dttm columns.",
            "            if (",
            "                db_engine_spec.time_secondary_columns",
            "                and self.main_dttm_col in self.dttm_cols",
            "                and self.main_dttm_col != dttm_col.column_name",
            "            ):",
            "                time_filters.append(",
            "                    columns_by_name[self.main_dttm_col].get_time_filter(",
            "                        from_dttm, to_dttm, time_range_endpoints",
            "                    )",
            "                )",
            "            time_filters.append(",
            "                dttm_col.get_time_filter(from_dttm, to_dttm, time_range_endpoints)",
            "            )",
            "",
            "        # Always remove duplicates by column name, as sometimes `metrics_exprs`",
            "        # can have the same name as a groupby column (e.g. when users use",
            "        # raw columns as custom SQL adhoc metric).",
            "        select_exprs = remove_duplicates(",
            "            select_exprs + metrics_exprs, key=lambda x: x.name",
            "        )",
            "",
            "        # Expected output columns",
            "        labels_expected = [c.key for c in select_exprs]",
            "",
            "        # Order by columns are \"hidden\" columns, some databases require them",
            "        # always be present in SELECT if an aggregation function is used",
            "        if not db_engine_spec.allows_hidden_ordeby_agg:",
            "            select_exprs = remove_duplicates(select_exprs + orderby_exprs)",
            "",
            "        qry = sa.select(select_exprs)",
            "",
            "        tbl = self.get_from_clause(template_processor)",
            "",
            "        if groupby_all_columns:",
            "            qry = qry.group_by(*groupby_all_columns.values())",
            "",
            "        where_clause_and = []",
            "        having_clause_and = []",
            "",
            "        for flt in filter:  # type: ignore",
            "            if not all(flt.get(s) for s in [\"col\", \"op\"]):",
            "                continue",
            "            col = flt[\"col\"]",
            "            val = flt.get(\"val\")",
            "            op = flt[\"op\"].upper()",
            "            col_obj = (",
            "                dttm_col",
            "                if col == utils.DTTM_ALIAS and is_timeseries and dttm_col",
            "                else columns_by_name.get(col)",
            "            )",
            "            filter_grain = flt.get(\"grain\")",
            "",
            "            if is_feature_enabled(\"ENABLE_TEMPLATE_REMOVE_FILTERS\"):",
            "                if col in removed_filters:",
            "                    # Skip generating SQLA filter when the jinja template handles it.",
            "                    continue",
            "",
            "            if col_obj:",
            "                if filter_grain:",
            "                    sqla_col = col_obj.get_timestamp_expression(filter_grain)",
            "                else:",
            "                    sqla_col = col_obj.get_sqla_col()",
            "                col_spec = db_engine_spec.get_column_spec(col_obj.type)",
            "                is_list_target = op in (",
            "                    utils.FilterOperator.IN.value,",
            "                    utils.FilterOperator.NOT_IN.value,",
            "                )",
            "                if col_spec:",
            "                    target_type = col_spec.generic_type",
            "                else:",
            "                    target_type = GenericDataType.STRING",
            "                eq = self.filter_values_handler(",
            "                    values=val,",
            "                    target_column_type=target_type,",
            "                    is_list_target=is_list_target,",
            "                )",
            "                if is_list_target:",
            "                    assert isinstance(eq, (tuple, list))",
            "                    if len(eq) == 0:",
            "                        raise QueryObjectValidationError(",
            "                            _(\"Filter value list cannot be empty\")",
            "                        )",
            "                    if None in eq:",
            "                        eq = [x for x in eq if x is not None]",
            "                        is_null_cond = sqla_col.is_(None)",
            "                        if eq:",
            "                            cond = or_(is_null_cond, sqla_col.in_(eq))",
            "                        else:",
            "                            cond = is_null_cond",
            "                    else:",
            "                        cond = sqla_col.in_(eq)",
            "                    if op == utils.FilterOperator.NOT_IN.value:",
            "                        cond = ~cond",
            "                    where_clause_and.append(cond)",
            "                elif op == utils.FilterOperator.IS_NULL.value:",
            "                    where_clause_and.append(sqla_col.is_(None))",
            "                elif op == utils.FilterOperator.IS_NOT_NULL.value:",
            "                    where_clause_and.append(sqla_col.isnot(None))",
            "                elif op == utils.FilterOperator.IS_TRUE.value:",
            "                    where_clause_and.append(sqla_col.is_(True))",
            "                elif op == utils.FilterOperator.IS_FALSE.value:",
            "                    where_clause_and.append(sqla_col.is_(False))",
            "                else:",
            "                    if eq is None:",
            "                        raise QueryObjectValidationError(",
            "                            _(",
            "                                \"Must specify a value for filters \"",
            "                                \"with comparison operators\"",
            "                            )",
            "                        )",
            "                    if op == utils.FilterOperator.EQUALS.value:",
            "                        where_clause_and.append(sqla_col == eq)",
            "                    elif op == utils.FilterOperator.NOT_EQUALS.value:",
            "                        where_clause_and.append(sqla_col != eq)",
            "                    elif op == utils.FilterOperator.GREATER_THAN.value:",
            "                        where_clause_and.append(sqla_col > eq)",
            "                    elif op == utils.FilterOperator.LESS_THAN.value:",
            "                        where_clause_and.append(sqla_col < eq)",
            "                    elif op == utils.FilterOperator.GREATER_THAN_OR_EQUALS.value:",
            "                        where_clause_and.append(sqla_col >= eq)",
            "                    elif op == utils.FilterOperator.LESS_THAN_OR_EQUALS.value:",
            "                        where_clause_and.append(sqla_col <= eq)",
            "                    elif op == utils.FilterOperator.LIKE.value:",
            "                        where_clause_and.append(sqla_col.like(eq))",
            "                    elif op == utils.FilterOperator.ILIKE.value:",
            "                        where_clause_and.append(sqla_col.ilike(eq))",
            "                    else:",
            "                        raise QueryObjectValidationError(",
            "                            _(\"Invalid filter operation type: %(op)s\", op=op)",
            "                        )",
            "        if is_feature_enabled(\"ROW_LEVEL_SECURITY\"):",
            "            where_clause_and += self._get_sqla_row_level_filters(template_processor)",
            "        if extras:",
            "            where = extras.get(\"where\")",
            "            if where:",
            "                try:",
            "                    where = template_processor.process_template(f\"({where})\")",
            "                except TemplateError as ex:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Error in jinja expression in WHERE clause: %(msg)s\",",
            "                            msg=ex.message,",
            "                        )",
            "                    ) from ex",
            "                where_clause_and += [self.text(where)]",
            "            having = extras.get(\"having\")",
            "            if having:",
            "                try:",
            "                    having = template_processor.process_template(f\"({having})\")",
            "                except TemplateError as ex:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Error in jinja expression in HAVING clause: %(msg)s\",",
            "                            msg=ex.message,",
            "                        )",
            "                    ) from ex",
            "                having_clause_and += [self.text(having)]",
            "        if apply_fetch_values_predicate and self.fetch_values_predicate:",
            "            qry = qry.where(self.get_fetch_values_predicate())",
            "        if granularity:",
            "            qry = qry.where(and_(*(time_filters + where_clause_and)))",
            "        else:",
            "            qry = qry.where(and_(*where_clause_and))",
            "        qry = qry.having(and_(*having_clause_and))",
            "",
            "        self.make_orderby_compatible(select_exprs, orderby_exprs)",
            "",
            "        for col, (orig_col, ascending) in zip(orderby_exprs, orderby):",
            "            if not db_engine_spec.allows_alias_in_orderby and isinstance(col, Label):",
            "                # if engine does not allow using SELECT alias in ORDER BY",
            "                # revert to the underlying column",
            "                col = col.element",
            "            direction = asc if ascending else desc",
            "            qry = qry.order_by(direction(col))",
            "",
            "        if row_limit:",
            "            qry = qry.limit(row_limit)",
            "        if row_offset:",
            "            qry = qry.offset(row_offset)",
            "",
            "        if series_limit and groupby_series_columns:",
            "            if db_engine_spec.allows_joins and db_engine_spec.allows_subqueries:",
            "                # some sql dialects require for order by expressions",
            "                # to also be in the select clause -- others, e.g. vertica,",
            "                # require a unique inner alias",
            "                inner_main_metric_expr = self.make_sqla_column_compatible(",
            "                    main_metric_expr, \"mme_inner__\"",
            "                )",
            "                inner_groupby_exprs = []",
            "                inner_select_exprs = []",
            "                for gby_name, gby_obj in groupby_series_columns.items():",
            "                    inner = self.make_sqla_column_compatible(gby_obj, gby_name + \"__\")",
            "                    inner_groupby_exprs.append(inner)",
            "                    inner_select_exprs.append(inner)",
            "",
            "                inner_select_exprs += [inner_main_metric_expr]",
            "                subq = select(inner_select_exprs).select_from(tbl)",
            "                inner_time_filter = []",
            "",
            "                if dttm_col and not db_engine_spec.time_groupby_inline:",
            "                    inner_time_filter = [",
            "                        dttm_col.get_time_filter(",
            "                            inner_from_dttm or from_dttm,",
            "                            inner_to_dttm or to_dttm,",
            "                            time_range_endpoints,",
            "                        )",
            "                    ]",
            "                subq = subq.where(and_(*(where_clause_and + inner_time_filter)))",
            "                subq = subq.group_by(*inner_groupby_exprs)",
            "",
            "                ob = inner_main_metric_expr",
            "                if series_limit_metric:",
            "                    ob = self._get_series_orderby(",
            "                        series_limit_metric, metrics_by_name, columns_by_name",
            "                    )",
            "                direction = desc if order_desc else asc",
            "                subq = subq.order_by(direction(ob))",
            "                subq = subq.limit(series_limit)",
            "",
            "                on_clause = []",
            "                for gby_name, gby_obj in groupby_series_columns.items():",
            "                    # in this case the column name, not the alias, needs to be",
            "                    # conditionally mutated, as it refers to the column alias in",
            "                    # the inner query",
            "                    col_name = db_engine_spec.make_label_compatible(gby_name + \"__\")",
            "                    on_clause.append(gby_obj == column(col_name))",
            "",
            "                tbl = tbl.join(subq.alias(), and_(*on_clause))",
            "            else:",
            "                if series_limit_metric:",
            "                    orderby = [",
            "                        (",
            "                            self._get_series_orderby(",
            "                                series_limit_metric, metrics_by_name, columns_by_name,",
            "                            ),",
            "                            False,",
            "                        )",
            "                    ]",
            "",
            "                # run prequery to get top groups",
            "                prequery_obj = {",
            "                    \"is_timeseries\": False,",
            "                    \"row_limit\": series_limit,",
            "                    \"metrics\": metrics,",
            "                    \"granularity\": granularity,",
            "                    \"groupby\": groupby,",
            "                    \"from_dttm\": inner_from_dttm or from_dttm,",
            "                    \"to_dttm\": inner_to_dttm or to_dttm,",
            "                    \"filter\": filter,",
            "                    \"orderby\": orderby,",
            "                    \"extras\": extras,",
            "                    \"columns\": columns,",
            "                    \"order_desc\": True,",
            "                }",
            "",
            "                result = self.query(prequery_obj)",
            "                prequeries.append(result.query)",
            "                dimensions = [",
            "                    c",
            "                    for c in result.df.columns",
            "                    if c not in metrics and c in groupby_series_columns",
            "                ]",
            "                top_groups = self._get_top_groups(",
            "                    result.df, dimensions, groupby_series_columns",
            "                )",
            "                qry = qry.where(top_groups)",
            "",
            "        qry = qry.select_from(tbl)",
            "",
            "        if is_rowcount:",
            "            if not db_engine_spec.allows_subqueries:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Database does not support subqueries\")",
            "                )",
            "            label = \"rowcount\"",
            "            col = self.make_sqla_column_compatible(literal_column(\"COUNT(*)\"), label)",
            "            qry = select([col]).select_from(qry.alias(\"rowcount_qry\"))",
            "            labels_expected = [label]",
            "",
            "        return SqlaQuery(",
            "            applied_template_filters=applied_template_filters,",
            "            extra_cache_keys=extra_cache_keys,",
            "            labels_expected=labels_expected,",
            "            sqla_query=qry,",
            "            prequeries=prequeries,",
            "        )",
            "",
            "    def _get_series_orderby(",
            "        self,",
            "        series_limit_metric: Metric,",
            "        metrics_by_name: Dict[str, SqlMetric],",
            "        columns_by_name: Dict[str, TableColumn],",
            "    ) -> Column:",
            "        if utils.is_adhoc_metric(series_limit_metric):",
            "            assert isinstance(series_limit_metric, dict)",
            "            ob = self.adhoc_metric_to_sqla(series_limit_metric, columns_by_name)",
            "        elif (",
            "            isinstance(series_limit_metric, str)",
            "            and series_limit_metric in metrics_by_name",
            "        ):",
            "            ob = metrics_by_name[series_limit_metric].get_sqla_col()",
            "        else:",
            "            raise QueryObjectValidationError(",
            "                _(\"Metric '%(metric)s' does not exist\", metric=series_limit_metric)",
            "            )",
            "        return ob",
            "",
            "    def _get_top_groups(",
            "        self, df: pd.DataFrame, dimensions: List[str], groupby_exprs: Dict[str, Any],",
            "    ) -> ColumnElement:",
            "        column_map = {column.column_name: column for column in self.columns}",
            "        groups = []",
            "        for _unused, row in df.iterrows():",
            "            group = []",
            "            for dimension in dimensions:",
            "                value = row[dimension]",
            "",
            "                # Some databases like Druid will return timestamps as strings, but",
            "                # do not perform automatic casting when comparing these strings to",
            "                # a timestamp. For cases like this we convert the value from a",
            "                # string into a timestamp.",
            "                if column_map[dimension].is_temporal and isinstance(value, str):",
            "                    dttm = dateutil.parser.parse(value)",
            "                    value = text(",
            "                        str(self.db_engine_spec.convert_dttm(\"TIMESTAMP\", dttm))",
            "                    )",
            "",
            "                group.append(groupby_exprs[dimension] == value)",
            "            groups.append(and_(*group))",
            "",
            "        return or_(*groups)",
            "",
            "    def query(self, query_obj: QueryObjectDict) -> QueryResult:",
            "        qry_start_dttm = datetime.now()",
            "        query_str_ext = self.get_query_str_extended(query_obj)",
            "        sql = query_str_ext.sql",
            "        status = QueryStatus.SUCCESS",
            "        errors = None",
            "        error_message = None",
            "",
            "        def assign_column_label(df: pd.DataFrame) -> Optional[pd.DataFrame]:",
            "            \"\"\"",
            "            Some engines change the case or generate bespoke column names, either by",
            "            default or due to lack of support for aliasing. This function ensures that",
            "            the column names in the DataFrame correspond to what is expected by",
            "            the viz components.",
            "",
            "            Sometimes a query may also contain only order by columns that are not used",
            "            as metrics or groupby columns, but need to present in the SQL `select`,",
            "            filtering by `labels_expected` make sure we only return columns users want.",
            "",
            "            :param df: Original DataFrame returned by the engine",
            "            :return: Mutated DataFrame",
            "            \"\"\"",
            "            labels_expected = query_str_ext.labels_expected",
            "            if df is not None and not df.empty:",
            "                if len(df.columns) < len(labels_expected):",
            "                    raise QueryObjectValidationError(",
            "                        _(\"Db engine did not return all queried columns\")",
            "                    )",
            "                if len(df.columns) > len(labels_expected):",
            "                    df = df.iloc[:, 0 : len(labels_expected)]",
            "                df.columns = labels_expected",
            "            return df",
            "",
            "        try:",
            "            df = self.database.get_df(sql, self.schema, mutator=assign_column_label)",
            "        except Exception as ex:  # pylint: disable=broad-except",
            "            df = pd.DataFrame()",
            "            status = QueryStatus.FAILED",
            "            logger.warning(",
            "                \"Query %s on schema %s failed\", sql, self.schema, exc_info=True",
            "            )",
            "            db_engine_spec = self.db_engine_spec",
            "            errors = [",
            "                dataclasses.asdict(error) for error in db_engine_spec.extract_errors(ex)",
            "            ]",
            "            error_message = utils.error_msg_from_exception(ex)",
            "",
            "        return QueryResult(",
            "            applied_template_filters=query_str_ext.applied_template_filters,",
            "            status=status,",
            "            df=df,",
            "            duration=datetime.now() - qry_start_dttm,",
            "            query=sql,",
            "            errors=errors,",
            "            error_message=error_message,",
            "        )",
            "",
            "    def get_sqla_table_object(self) -> Table:",
            "        return self.database.get_table(self.table_name, schema=self.schema)",
            "",
            "    def fetch_metadata(self, commit: bool = True) -> MetadataResult:",
            "        \"\"\"",
            "        Fetches the metadata for the table and merges it in",
            "",
            "        :param commit: should the changes be committed or not.",
            "        :return: Tuple with lists of added, removed and modified column names.",
            "        \"\"\"",
            "        new_columns = self.external_metadata()",
            "        metrics = []",
            "        any_date_col = None",
            "        db_engine_spec = self.db_engine_spec",
            "        old_columns = db.session.query(TableColumn).filter(TableColumn.table == self)",
            "",
            "        old_columns_by_name: Dict[str, TableColumn] = {",
            "            col.column_name: col for col in old_columns",
            "        }",
            "        results = MetadataResult(",
            "            removed=[",
            "                col",
            "                for col in old_columns_by_name",
            "                if col not in {col[\"name\"] for col in new_columns}",
            "            ]",
            "        )",
            "",
            "        # clear old columns before adding modified columns back",
            "        self.columns = []",
            "        for col in new_columns:",
            "            old_column = old_columns_by_name.pop(col[\"name\"], None)",
            "            if not old_column:",
            "                results.added.append(col[\"name\"])",
            "                new_column = TableColumn(",
            "                    column_name=col[\"name\"], type=col[\"type\"], table=self",
            "                )",
            "                new_column.is_dttm = new_column.is_temporal",
            "                db_engine_spec.alter_new_orm_column(new_column)",
            "            else:",
            "                new_column = old_column",
            "                if new_column.type != col[\"type\"]:",
            "                    results.modified.append(col[\"name\"])",
            "                new_column.type = col[\"type\"]",
            "                new_column.expression = \"\"",
            "            new_column.groupby = True",
            "            new_column.filterable = True",
            "            self.columns.append(new_column)",
            "            if not any_date_col and new_column.is_temporal:",
            "                any_date_col = col[\"name\"]",
            "        self.columns.extend(",
            "            [col for col in old_columns_by_name.values() if col.expression]",
            "        )",
            "        metrics.append(",
            "            SqlMetric(",
            "                metric_name=\"count\",",
            "                verbose_name=\"COUNT(*)\",",
            "                metric_type=\"count\",",
            "                expression=\"COUNT(*)\",",
            "            )",
            "        )",
            "        if not self.main_dttm_col:",
            "            self.main_dttm_col = any_date_col",
            "        self.add_missing_metrics(metrics)",
            "",
            "        # Apply config supplied mutations.",
            "        config[\"SQLA_TABLE_MUTATOR\"](self)",
            "",
            "        db.session.merge(self)",
            "        if commit:",
            "            db.session.commit()",
            "        return results",
            "",
            "    @classmethod",
            "    def query_datasources_by_name(",
            "        cls,",
            "        session: Session,",
            "        database: Database,",
            "        datasource_name: str,",
            "        schema: Optional[str] = None,",
            "    ) -> List[\"SqlaTable\"]:",
            "        query = (",
            "            session.query(cls)",
            "            .filter_by(database_id=database.id)",
            "            .filter_by(table_name=datasource_name)",
            "        )",
            "        if schema:",
            "            query = query.filter_by(schema=schema)",
            "        return query.all()",
            "",
            "    @staticmethod",
            "    def default_query(qry: Query) -> Query:",
            "        return qry.filter_by(is_sqllab_view=False)",
            "",
            "    def has_extra_cache_key_calls(self, query_obj: QueryObjectDict) -> bool:",
            "        \"\"\"",
            "        Detects the presence of calls to `ExtraCache` methods in items in query_obj that",
            "        can be templated. If any are present, the query must be evaluated to extract",
            "        additional keys for the cache key. This method is needed to avoid executing the",
            "        template code unnecessarily, as it may contain expensive calls, e.g. to extract",
            "        the latest partition of a database.",
            "",
            "        :param query_obj: query object to analyze",
            "        :return: True if there are call(s) to an `ExtraCache` method, False otherwise",
            "        \"\"\"",
            "        templatable_statements: List[str] = []",
            "        if self.sql:",
            "            templatable_statements.append(self.sql)",
            "        if self.fetch_values_predicate:",
            "            templatable_statements.append(self.fetch_values_predicate)",
            "        extras = query_obj.get(\"extras\", {})",
            "        if \"where\" in extras:",
            "            templatable_statements.append(extras[\"where\"])",
            "        if \"having\" in extras:",
            "            templatable_statements.append(extras[\"having\"])",
            "        if is_feature_enabled(\"ROW_LEVEL_SECURITY\") and self.is_rls_supported:",
            "            templatable_statements += [",
            "                f.clause for f in security_manager.get_rls_filters(self)",
            "            ]",
            "        for statement in templatable_statements:",
            "            if ExtraCache.regex.search(statement):",
            "                return True",
            "        return False",
            "",
            "    def get_extra_cache_keys(self, query_obj: QueryObjectDict) -> List[Hashable]:",
            "        \"\"\"",
            "        The cache key of a SqlaTable needs to consider any keys added by the parent",
            "        class and any keys added via `ExtraCache`.",
            "",
            "        :param query_obj: query object to analyze",
            "        :return: The extra cache keys",
            "        \"\"\"",
            "        extra_cache_keys = super().get_extra_cache_keys(query_obj)",
            "        if self.has_extra_cache_key_calls(query_obj):",
            "            sqla_query = self.get_sqla_query(**query_obj)",
            "            extra_cache_keys += sqla_query.extra_cache_keys",
            "        return extra_cache_keys",
            "",
            "    @staticmethod",
            "    def before_update(",
            "        mapper: Mapper,  # pylint: disable=unused-argument",
            "        connection: Connection,  # pylint: disable=unused-argument",
            "        target: \"SqlaTable\",",
            "    ) -> None:",
            "        \"\"\"",
            "        Check before update if the target table already exists.",
            "",
            "        Note this listener is called when any fields are being updated and thus it is",
            "        necessary to first check whether the reference table is being updated.",
            "",
            "        Note this logic is temporary, given uniqueness is handled via the dataset DAO,",
            "        but is necessary until both the legacy datasource editor and datasource/save",
            "        endpoints are deprecated.",
            "",
            "        :param mapper: The table mapper",
            "        :param connection: The DB-API connection",
            "        :param target: The mapped instance being persisted",
            "        :raises Exception: If the target table is not unique",
            "        \"\"\"",
            "",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset.datasets.commands.exceptions import get_dataset_exist_error_msg",
            "        from superset.datasets.dao import DatasetDAO",
            "",
            "        # Check whether the relevant attributes have changed.",
            "        state = db.inspect(target)  # pylint: disable=no-member",
            "",
            "        for attr in [\"database_id\", \"schema\", \"table_name\"]:",
            "            history = state.get_history(attr, True)",
            "",
            "            if history.has_changes():",
            "                break",
            "        else:",
            "            return None",
            "",
            "        if not DatasetDAO.validate_uniqueness(",
            "            target.database_id, target.schema, target.table_name",
            "        ):",
            "            raise Exception(get_dataset_exist_error_msg(target.full_name))",
            "",
            "    @staticmethod",
            "    def update_table(",
            "        _mapper: Mapper, _connection: Connection, obj: Union[SqlMetric, TableColumn]",
            "    ) -> None:",
            "        \"\"\"",
            "        Forces an update to the table's changed_on value when a metric or column on the",
            "        table is updated. This busts the cache key for all charts that use the table.",
            "",
            "        :param _mapper: Unused.",
            "        :param _connection: Unused.",
            "        :param obj: The metric or column that was updated.",
            "        \"\"\"",
            "        db.session.execute(update(SqlaTable).where(SqlaTable.id == obj.table.id))",
            "",
            "",
            "sa.event.listen(SqlaTable, \"after_insert\", security_manager.set_perm)",
            "sa.event.listen(SqlaTable, \"after_update\", security_manager.set_perm)",
            "sa.event.listen(SqlaTable, \"before_update\", SqlaTable.before_update)",
            "sa.event.listen(SqlMetric, \"after_update\", SqlaTable.update_table)",
            "sa.event.listen(TableColumn, \"after_update\", SqlaTable.update_table)",
            "",
            "RLSFilterRoles = Table(",
            "    \"rls_filter_roles\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"role_id\", Integer, ForeignKey(\"ab_role.id\"), nullable=False),",
            "    Column(\"rls_filter_id\", Integer, ForeignKey(\"row_level_security_filters.id\")),",
            ")",
            "",
            "RLSFilterTables = Table(",
            "    \"rls_filter_tables\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"table_id\", Integer, ForeignKey(\"tables.id\")),",
            "    Column(\"rls_filter_id\", Integer, ForeignKey(\"row_level_security_filters.id\")),",
            ")",
            "",
            "",
            "class RowLevelSecurityFilter(Model, AuditMixinNullable):",
            "    \"\"\"",
            "    Custom where clauses attached to Tables and Roles.",
            "    \"\"\"",
            "",
            "    __tablename__ = \"row_level_security_filters\"",
            "    id = Column(Integer, primary_key=True)",
            "    filter_type = Column(",
            "        Enum(*[filter_type.value for filter_type in utils.RowLevelSecurityFilterType])",
            "    )",
            "    group_key = Column(String(255), nullable=True)",
            "    roles = relationship(",
            "        security_manager.role_model,",
            "        secondary=RLSFilterRoles,",
            "        backref=\"row_level_security_filters\",",
            "    )",
            "    tables = relationship(",
            "        SqlaTable, secondary=RLSFilterTables, backref=\"row_level_security_filters\"",
            "    )",
            "",
            "    clause = Column(Text, nullable=False)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "80": [],
            "89": [],
            "1268": [
                "SqlaTable",
                "get_sqla_query"
            ],
            "1276": [
                "SqlaTable",
                "get_sqla_query"
            ],
            "1280": [
                "SqlaTable",
                "get_sqla_query"
            ],
            "1288": [
                "SqlaTable",
                "get_sqla_query"
            ]
        },
        "addLocation": []
    },
    "superset/sql_parse.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     remove_quotes,"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     Token,"
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     TokenList,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    Where,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+from sqlparse.tokens import ("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    Comment,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    CTE,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    DDL,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    DML,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    Keyword,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    Name,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    Punctuation,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    String,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    Whitespace,"
            },
            "15": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " )"
            },
            "16": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " from sqlparse.tokens import Keyword, Name, Punctuation, String, Whitespace"
            },
            "17": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " from sqlparse.utils import imt"
            },
            "18": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "         return str_res"
            },
            "19": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 362,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 363,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def validate_filter_clause(clause: str) -> None:"
            },
            "22": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if sqlparse.format(clause, strip_comments=True) != sqlparse.format(clause):"
            },
            "23": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise QueryClauseValidationException(\"Filter clause contains comment\")"
            },
            "24": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+def sanitize_clause(clause: str) -> str:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+    # clause = sqlparse.format(clause, strip_comments=True)"
            },
            "27": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "     statements = sqlparse.parse(clause)"
            },
            "28": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "     if len(statements) != 1:"
            },
            "29": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise QueryClauseValidationException(\"Filter clause contains multiple queries\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+        raise QueryClauseValidationException(\"Clause contains multiple statements\")"
            },
            "31": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "     open_parens = 0"
            },
            "32": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 370,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+    previous_token = None"
            },
            "34": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 372,
                "PatchRowcode": "     for token in statements[0]:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+        if token.value == \"/\" and previous_token and previous_token.value == \"*\":"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+            raise QueryClauseValidationException(\"Closing unopened multiline comment\")"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+        if token.value == \"*\" and previous_token and previous_token.value == \"/\":"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+            raise QueryClauseValidationException(\"Unclosed multiline comment\")"
            },
            "39": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "         if token.value in (\")\", \"(\"):"
            },
            "40": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "             open_parens += 1 if token.value == \"(\" else -1"
            },
            "41": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "             if open_parens < 0:"
            },
            "42": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "                 raise QueryClauseValidationException("
            },
            "43": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "                     \"Closing unclosed parenthesis in filter clause\""
            },
            "44": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "                 )"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+        previous_token = token"
            },
            "46": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "     if open_parens > 0:"
            },
            "47": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "         raise QueryClauseValidationException(\"Unclosed parenthesis in filter clause\")"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+    if previous_token and previous_token.ttype in Comment:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+        if previous_token.value[-1] != \"\\n\":"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+            clause = f\"{clause}\\n\""
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+    return clause"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "import logging",
            "from dataclasses import dataclass",
            "from enum import Enum",
            "from typing import List, Optional, Set",
            "from urllib import parse",
            "",
            "import sqlparse",
            "from sqlparse.sql import (",
            "    Identifier,",
            "    IdentifierList,",
            "    Parenthesis,",
            "    remove_quotes,",
            "    Token,",
            "    TokenList,",
            ")",
            "from sqlparse.tokens import Keyword, Name, Punctuation, String, Whitespace",
            "from sqlparse.utils import imt",
            "",
            "from superset.exceptions import QueryClauseValidationException",
            "",
            "RESULT_OPERATIONS = {\"UNION\", \"INTERSECT\", \"EXCEPT\", \"SELECT\"}",
            "ON_KEYWORD = \"ON\"",
            "PRECEDES_TABLE_NAME = {\"FROM\", \"JOIN\", \"DESCRIBE\", \"WITH\", \"LEFT JOIN\", \"RIGHT JOIN\"}",
            "CTE_PREFIX = \"CTE__\"",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class CtasMethod(str, Enum):",
            "    TABLE = \"TABLE\"",
            "    VIEW = \"VIEW\"",
            "",
            "",
            "def _extract_limit_from_query(statement: TokenList) -> Optional[int]:",
            "    \"\"\"",
            "    Extract limit clause from SQL statement.",
            "",
            "    :param statement: SQL statement",
            "    :return: Limit extracted from query, None if no limit present in statement",
            "    \"\"\"",
            "    idx, _ = statement.token_next_by(m=(Keyword, \"LIMIT\"))",
            "    if idx is not None:",
            "        _, token = statement.token_next(idx=idx)",
            "        if token:",
            "            if isinstance(token, IdentifierList):",
            "                # In case of \"LIMIT <offset>, <limit>\", find comma and extract",
            "                # first succeeding non-whitespace token",
            "                idx, _ = token.token_next_by(m=(sqlparse.tokens.Punctuation, \",\"))",
            "                _, token = token.token_next(idx=idx)",
            "            if token and token.ttype == sqlparse.tokens.Literal.Number.Integer:",
            "                return int(token.value)",
            "    return None",
            "",
            "",
            "def strip_comments_from_sql(statement: str) -> str:",
            "    \"\"\"",
            "    Strips comments from a SQL statement, does a simple test first",
            "    to avoid always instantiating the expensive ParsedQuery constructor",
            "",
            "    This is useful for engines that don't support comments",
            "",
            "    :param statement: A string with the SQL statement",
            "    :return: SQL statement without comments",
            "    \"\"\"",
            "    return ParsedQuery(statement).strip_comments() if \"--\" in statement else statement",
            "",
            "",
            "@dataclass(eq=True, frozen=True)",
            "class Table:",
            "    \"\"\"",
            "    A fully qualified SQL table conforming to [[catalog.]schema.]table.",
            "    \"\"\"",
            "",
            "    table: str",
            "    schema: Optional[str] = None",
            "    catalog: Optional[str] = None",
            "",
            "    def __str__(self) -> str:",
            "        \"\"\"",
            "        Return the fully qualified SQL table name.",
            "        \"\"\"",
            "",
            "        return \".\".join(",
            "            parse.quote(part, safe=\"\").replace(\".\", \"%2E\")",
            "            for part in [self.catalog, self.schema, self.table]",
            "            if part",
            "        )",
            "",
            "",
            "class ParsedQuery:",
            "    def __init__(self, sql_statement: str, strip_comments: bool = False):",
            "        if strip_comments:",
            "            sql_statement = sqlparse.format(sql_statement, strip_comments=True)",
            "",
            "        self.sql: str = sql_statement",
            "        self._tables: Set[Table] = set()",
            "        self._alias_names: Set[str] = set()",
            "        self._limit: Optional[int] = None",
            "",
            "        logger.debug(\"Parsing with sqlparse statement: %s\", self.sql)",
            "        self._parsed = sqlparse.parse(self.stripped())",
            "        for statement in self._parsed:",
            "            self._limit = _extract_limit_from_query(statement)",
            "",
            "    @property",
            "    def tables(self) -> Set[Table]:",
            "        if not self._tables:",
            "            for statement in self._parsed:",
            "                self._extract_from_token(statement)",
            "",
            "            self._tables = {",
            "                table for table in self._tables if str(table) not in self._alias_names",
            "            }",
            "        return self._tables",
            "",
            "    @property",
            "    def limit(self) -> Optional[int]:",
            "        return self._limit",
            "",
            "    def is_select(self) -> bool:",
            "        # make sure we strip comments; prevents a bug with coments in the CTE",
            "        parsed = sqlparse.parse(self.strip_comments())",
            "        return parsed[0].get_type() == \"SELECT\"",
            "",
            "    def is_valid_ctas(self) -> bool:",
            "        parsed = sqlparse.parse(self.strip_comments())",
            "        return parsed[-1].get_type() == \"SELECT\"",
            "",
            "    def is_valid_cvas(self) -> bool:",
            "        parsed = sqlparse.parse(self.strip_comments())",
            "        return len(parsed) == 1 and parsed[0].get_type() == \"SELECT\"",
            "",
            "    def is_explain(self) -> bool:",
            "        # Remove comments",
            "        statements_without_comments = sqlparse.format(",
            "            self.stripped(), strip_comments=True",
            "        )",
            "",
            "        # Explain statements will only be the first statement",
            "        return statements_without_comments.startswith(\"EXPLAIN\")",
            "",
            "    def is_show(self) -> bool:",
            "        # Remove comments",
            "        statements_without_comments = sqlparse.format(",
            "            self.stripped(), strip_comments=True",
            "        )",
            "        # Show statements will only be the first statement",
            "        return statements_without_comments.upper().startswith(\"SHOW\")",
            "",
            "    def is_set(self) -> bool:",
            "        # Remove comments",
            "        statements_without_comments = sqlparse.format(",
            "            self.stripped(), strip_comments=True",
            "        )",
            "        # Set statements will only be the first statement",
            "        return statements_without_comments.upper().startswith(\"SET\")",
            "",
            "    def is_unknown(self) -> bool:",
            "        return self._parsed[0].get_type() == \"UNKNOWN\"",
            "",
            "    def stripped(self) -> str:",
            "        return self.sql.strip(\" \\t\\n;\")",
            "",
            "    def strip_comments(self) -> str:",
            "        return sqlparse.format(self.stripped(), strip_comments=True)",
            "",
            "    def get_statements(self) -> List[str]:",
            "        \"\"\"Returns a list of SQL statements as strings, stripped\"\"\"",
            "        statements = []",
            "        for statement in self._parsed:",
            "            if statement:",
            "                sql = str(statement).strip(\" \\n;\\t\")",
            "                if sql:",
            "                    statements.append(sql)",
            "        return statements",
            "",
            "    @staticmethod",
            "    def _get_table(tlist: TokenList) -> Optional[Table]:",
            "        \"\"\"",
            "        Return the table if valid, i.e., conforms to the [[catalog.]schema.]table",
            "        construct.",
            "",
            "        :param tlist: The SQL tokens",
            "        :returns: The table if the name conforms",
            "        \"\"\"",
            "",
            "        # Strip the alias if present.",
            "        idx = len(tlist.tokens)",
            "",
            "        if tlist.has_alias():",
            "            ws_idx, _ = tlist.token_next_by(t=Whitespace)",
            "",
            "            if ws_idx != -1:",
            "                idx = ws_idx",
            "",
            "        tokens = tlist.tokens[:idx]",
            "",
            "        if (",
            "            len(tokens) in (1, 3, 5)",
            "            and all(imt(token, t=[Name, String]) for token in tokens[::2])",
            "            and all(imt(token, m=(Punctuation, \".\")) for token in tokens[1::2])",
            "        ):",
            "            return Table(*[remove_quotes(token.value) for token in tokens[::-2]])",
            "",
            "        return None",
            "",
            "    @staticmethod",
            "    def _is_identifier(token: Token) -> bool:",
            "        return isinstance(token, (IdentifierList, Identifier))",
            "",
            "    def _process_tokenlist(self, token_list: TokenList) -> None:",
            "        \"\"\"",
            "        Add table names to table set",
            "",
            "        :param token_list: TokenList to be processed",
            "        \"\"\"",
            "        # exclude subselects",
            "        if \"(\" not in str(token_list):",
            "            table = self._get_table(token_list)",
            "            if table and not table.table.startswith(CTE_PREFIX):",
            "                self._tables.add(table)",
            "            return",
            "",
            "        # store aliases",
            "        if token_list.has_alias():",
            "            self._alias_names.add(token_list.get_alias())",
            "",
            "        # some aliases are not parsed properly",
            "        if token_list.tokens[0].ttype == Name:",
            "            self._alias_names.add(token_list.tokens[0].value)",
            "        self._extract_from_token(token_list)",
            "",
            "    def as_create_table(",
            "        self,",
            "        table_name: str,",
            "        schema_name: Optional[str] = None,",
            "        overwrite: bool = False,",
            "        method: CtasMethod = CtasMethod.TABLE,",
            "    ) -> str:",
            "        \"\"\"Reformats the query into the create table as query.",
            "",
            "        Works only for the single select SQL statements, in all other cases",
            "        the sql query is not modified.",
            "        :param table_name: table that will contain the results of the query execution",
            "        :param schema_name: schema name for the target table",
            "        :param overwrite: table_name will be dropped if true",
            "        :param method: method for the CTA query, currently view or table creation",
            "        :return: Create table as query",
            "        \"\"\"",
            "        exec_sql = \"\"",
            "        sql = self.stripped()",
            "        # TODO(bkyryliuk): quote full_table_name",
            "        full_table_name = f\"{schema_name}.{table_name}\" if schema_name else table_name",
            "        if overwrite:",
            "            exec_sql = f\"DROP {method} IF EXISTS {full_table_name};\\n\"",
            "        exec_sql += f\"CREATE {method} {full_table_name} AS \\n{sql}\"",
            "        return exec_sql",
            "",
            "    def _extract_from_token(self, token: Token) -> None:",
            "        \"\"\"",
            "        <Identifier> store a list of subtokens and <IdentifierList> store lists of",
            "        subtoken list.",
            "",
            "        It extracts <IdentifierList> and <Identifier> from :param token: and loops",
            "        through all subtokens recursively. It finds table_name_preceding_token and",
            "        passes <IdentifierList> and <Identifier> to self._process_tokenlist to populate",
            "        self._tables.",
            "",
            "        :param token: instance of Token or child class, e.g. TokenList, to be processed",
            "        \"\"\"",
            "        if not hasattr(token, \"tokens\"):",
            "            return",
            "",
            "        table_name_preceding_token = False",
            "",
            "        for item in token.tokens:",
            "            if item.is_group and (",
            "                not self._is_identifier(item) or isinstance(item.tokens[0], Parenthesis)",
            "            ):",
            "                self._extract_from_token(item)",
            "",
            "            if item.ttype in Keyword and (",
            "                item.normalized in PRECEDES_TABLE_NAME",
            "                or item.normalized.endswith(\" JOIN\")",
            "            ):",
            "                table_name_preceding_token = True",
            "                continue",
            "",
            "            if item.ttype in Keyword:",
            "                table_name_preceding_token = False",
            "                continue",
            "            if table_name_preceding_token:",
            "                if isinstance(item, Identifier):",
            "                    self._process_tokenlist(item)",
            "                elif isinstance(item, IdentifierList):",
            "                    for token2 in item.get_identifiers():",
            "                        if isinstance(token2, TokenList):",
            "                            self._process_tokenlist(token2)",
            "            elif isinstance(item, IdentifierList):",
            "                if any(not self._is_identifier(token2) for token2 in item.tokens):",
            "                    self._extract_from_token(item)",
            "",
            "    def set_or_update_query_limit(self, new_limit: int, force: bool = False) -> str:",
            "        \"\"\"Returns the query with the specified limit.",
            "",
            "        Does not change the underlying query if user did not apply the limit,",
            "        otherwise replaces the limit with the lower value between existing limit",
            "        in the query and new_limit.",
            "",
            "        :param new_limit: Limit to be incorporated into returned query",
            "        :return: The original query with new limit",
            "        \"\"\"",
            "        if not self._limit:",
            "            return f\"{self.stripped()}\\nLIMIT {new_limit}\"",
            "        limit_pos = None",
            "        statement = self._parsed[0]",
            "        # Add all items to before_str until there is a limit",
            "        for pos, item in enumerate(statement.tokens):",
            "            if item.ttype in Keyword and item.value.lower() == \"limit\":",
            "                limit_pos = pos",
            "                break",
            "        _, limit = statement.token_next(idx=limit_pos)",
            "        # Override the limit only when it exceeds the configured value.",
            "        if limit.ttype == sqlparse.tokens.Literal.Number.Integer and (",
            "            force or new_limit < int(limit.value)",
            "        ):",
            "            limit.value = new_limit",
            "        elif limit.is_group:",
            "            limit.value = f\"{next(limit.get_identifiers())}, {new_limit}\"",
            "",
            "        str_res = \"\"",
            "        for i in statement.tokens:",
            "            str_res += str(i.value)",
            "        return str_res",
            "",
            "",
            "def validate_filter_clause(clause: str) -> None:",
            "    if sqlparse.format(clause, strip_comments=True) != sqlparse.format(clause):",
            "        raise QueryClauseValidationException(\"Filter clause contains comment\")",
            "",
            "    statements = sqlparse.parse(clause)",
            "    if len(statements) != 1:",
            "        raise QueryClauseValidationException(\"Filter clause contains multiple queries\")",
            "    open_parens = 0",
            "",
            "    for token in statements[0]:",
            "        if token.value in (\")\", \"(\"):",
            "            open_parens += 1 if token.value == \"(\" else -1",
            "            if open_parens < 0:",
            "                raise QueryClauseValidationException(",
            "                    \"Closing unclosed parenthesis in filter clause\"",
            "                )",
            "    if open_parens > 0:",
            "        raise QueryClauseValidationException(\"Unclosed parenthesis in filter clause\")"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "import logging",
            "from dataclasses import dataclass",
            "from enum import Enum",
            "from typing import List, Optional, Set",
            "from urllib import parse",
            "",
            "import sqlparse",
            "from sqlparse.sql import (",
            "    Identifier,",
            "    IdentifierList,",
            "    Parenthesis,",
            "    remove_quotes,",
            "    Token,",
            "    TokenList,",
            "    Where,",
            ")",
            "from sqlparse.tokens import (",
            "    Comment,",
            "    CTE,",
            "    DDL,",
            "    DML,",
            "    Keyword,",
            "    Name,",
            "    Punctuation,",
            "    String,",
            "    Whitespace,",
            ")",
            "from sqlparse.tokens import Keyword, Name, Punctuation, String, Whitespace",
            "from sqlparse.utils import imt",
            "",
            "from superset.exceptions import QueryClauseValidationException",
            "",
            "RESULT_OPERATIONS = {\"UNION\", \"INTERSECT\", \"EXCEPT\", \"SELECT\"}",
            "ON_KEYWORD = \"ON\"",
            "PRECEDES_TABLE_NAME = {\"FROM\", \"JOIN\", \"DESCRIBE\", \"WITH\", \"LEFT JOIN\", \"RIGHT JOIN\"}",
            "CTE_PREFIX = \"CTE__\"",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class CtasMethod(str, Enum):",
            "    TABLE = \"TABLE\"",
            "    VIEW = \"VIEW\"",
            "",
            "",
            "def _extract_limit_from_query(statement: TokenList) -> Optional[int]:",
            "    \"\"\"",
            "    Extract limit clause from SQL statement.",
            "",
            "    :param statement: SQL statement",
            "    :return: Limit extracted from query, None if no limit present in statement",
            "    \"\"\"",
            "    idx, _ = statement.token_next_by(m=(Keyword, \"LIMIT\"))",
            "    if idx is not None:",
            "        _, token = statement.token_next(idx=idx)",
            "        if token:",
            "            if isinstance(token, IdentifierList):",
            "                # In case of \"LIMIT <offset>, <limit>\", find comma and extract",
            "                # first succeeding non-whitespace token",
            "                idx, _ = token.token_next_by(m=(sqlparse.tokens.Punctuation, \",\"))",
            "                _, token = token.token_next(idx=idx)",
            "            if token and token.ttype == sqlparse.tokens.Literal.Number.Integer:",
            "                return int(token.value)",
            "    return None",
            "",
            "",
            "def strip_comments_from_sql(statement: str) -> str:",
            "    \"\"\"",
            "    Strips comments from a SQL statement, does a simple test first",
            "    to avoid always instantiating the expensive ParsedQuery constructor",
            "",
            "    This is useful for engines that don't support comments",
            "",
            "    :param statement: A string with the SQL statement",
            "    :return: SQL statement without comments",
            "    \"\"\"",
            "    return ParsedQuery(statement).strip_comments() if \"--\" in statement else statement",
            "",
            "",
            "@dataclass(eq=True, frozen=True)",
            "class Table:",
            "    \"\"\"",
            "    A fully qualified SQL table conforming to [[catalog.]schema.]table.",
            "    \"\"\"",
            "",
            "    table: str",
            "    schema: Optional[str] = None",
            "    catalog: Optional[str] = None",
            "",
            "    def __str__(self) -> str:",
            "        \"\"\"",
            "        Return the fully qualified SQL table name.",
            "        \"\"\"",
            "",
            "        return \".\".join(",
            "            parse.quote(part, safe=\"\").replace(\".\", \"%2E\")",
            "            for part in [self.catalog, self.schema, self.table]",
            "            if part",
            "        )",
            "",
            "",
            "class ParsedQuery:",
            "    def __init__(self, sql_statement: str, strip_comments: bool = False):",
            "        if strip_comments:",
            "            sql_statement = sqlparse.format(sql_statement, strip_comments=True)",
            "",
            "        self.sql: str = sql_statement",
            "        self._tables: Set[Table] = set()",
            "        self._alias_names: Set[str] = set()",
            "        self._limit: Optional[int] = None",
            "",
            "        logger.debug(\"Parsing with sqlparse statement: %s\", self.sql)",
            "        self._parsed = sqlparse.parse(self.stripped())",
            "        for statement in self._parsed:",
            "            self._limit = _extract_limit_from_query(statement)",
            "",
            "    @property",
            "    def tables(self) -> Set[Table]:",
            "        if not self._tables:",
            "            for statement in self._parsed:",
            "                self._extract_from_token(statement)",
            "",
            "            self._tables = {",
            "                table for table in self._tables if str(table) not in self._alias_names",
            "            }",
            "        return self._tables",
            "",
            "    @property",
            "    def limit(self) -> Optional[int]:",
            "        return self._limit",
            "",
            "    def is_select(self) -> bool:",
            "        # make sure we strip comments; prevents a bug with coments in the CTE",
            "        parsed = sqlparse.parse(self.strip_comments())",
            "        return parsed[0].get_type() == \"SELECT\"",
            "",
            "    def is_valid_ctas(self) -> bool:",
            "        parsed = sqlparse.parse(self.strip_comments())",
            "        return parsed[-1].get_type() == \"SELECT\"",
            "",
            "    def is_valid_cvas(self) -> bool:",
            "        parsed = sqlparse.parse(self.strip_comments())",
            "        return len(parsed) == 1 and parsed[0].get_type() == \"SELECT\"",
            "",
            "    def is_explain(self) -> bool:",
            "        # Remove comments",
            "        statements_without_comments = sqlparse.format(",
            "            self.stripped(), strip_comments=True",
            "        )",
            "",
            "        # Explain statements will only be the first statement",
            "        return statements_without_comments.startswith(\"EXPLAIN\")",
            "",
            "    def is_show(self) -> bool:",
            "        # Remove comments",
            "        statements_without_comments = sqlparse.format(",
            "            self.stripped(), strip_comments=True",
            "        )",
            "        # Show statements will only be the first statement",
            "        return statements_without_comments.upper().startswith(\"SHOW\")",
            "",
            "    def is_set(self) -> bool:",
            "        # Remove comments",
            "        statements_without_comments = sqlparse.format(",
            "            self.stripped(), strip_comments=True",
            "        )",
            "        # Set statements will only be the first statement",
            "        return statements_without_comments.upper().startswith(\"SET\")",
            "",
            "    def is_unknown(self) -> bool:",
            "        return self._parsed[0].get_type() == \"UNKNOWN\"",
            "",
            "    def stripped(self) -> str:",
            "        return self.sql.strip(\" \\t\\n;\")",
            "",
            "    def strip_comments(self) -> str:",
            "        return sqlparse.format(self.stripped(), strip_comments=True)",
            "",
            "    def get_statements(self) -> List[str]:",
            "        \"\"\"Returns a list of SQL statements as strings, stripped\"\"\"",
            "        statements = []",
            "        for statement in self._parsed:",
            "            if statement:",
            "                sql = str(statement).strip(\" \\n;\\t\")",
            "                if sql:",
            "                    statements.append(sql)",
            "        return statements",
            "",
            "    @staticmethod",
            "    def _get_table(tlist: TokenList) -> Optional[Table]:",
            "        \"\"\"",
            "        Return the table if valid, i.e., conforms to the [[catalog.]schema.]table",
            "        construct.",
            "",
            "        :param tlist: The SQL tokens",
            "        :returns: The table if the name conforms",
            "        \"\"\"",
            "",
            "        # Strip the alias if present.",
            "        idx = len(tlist.tokens)",
            "",
            "        if tlist.has_alias():",
            "            ws_idx, _ = tlist.token_next_by(t=Whitespace)",
            "",
            "            if ws_idx != -1:",
            "                idx = ws_idx",
            "",
            "        tokens = tlist.tokens[:idx]",
            "",
            "        if (",
            "            len(tokens) in (1, 3, 5)",
            "            and all(imt(token, t=[Name, String]) for token in tokens[::2])",
            "            and all(imt(token, m=(Punctuation, \".\")) for token in tokens[1::2])",
            "        ):",
            "            return Table(*[remove_quotes(token.value) for token in tokens[::-2]])",
            "",
            "        return None",
            "",
            "    @staticmethod",
            "    def _is_identifier(token: Token) -> bool:",
            "        return isinstance(token, (IdentifierList, Identifier))",
            "",
            "    def _process_tokenlist(self, token_list: TokenList) -> None:",
            "        \"\"\"",
            "        Add table names to table set",
            "",
            "        :param token_list: TokenList to be processed",
            "        \"\"\"",
            "        # exclude subselects",
            "        if \"(\" not in str(token_list):",
            "            table = self._get_table(token_list)",
            "            if table and not table.table.startswith(CTE_PREFIX):",
            "                self._tables.add(table)",
            "            return",
            "",
            "        # store aliases",
            "        if token_list.has_alias():",
            "            self._alias_names.add(token_list.get_alias())",
            "",
            "        # some aliases are not parsed properly",
            "        if token_list.tokens[0].ttype == Name:",
            "            self._alias_names.add(token_list.tokens[0].value)",
            "        self._extract_from_token(token_list)",
            "",
            "    def as_create_table(",
            "        self,",
            "        table_name: str,",
            "        schema_name: Optional[str] = None,",
            "        overwrite: bool = False,",
            "        method: CtasMethod = CtasMethod.TABLE,",
            "    ) -> str:",
            "        \"\"\"Reformats the query into the create table as query.",
            "",
            "        Works only for the single select SQL statements, in all other cases",
            "        the sql query is not modified.",
            "        :param table_name: table that will contain the results of the query execution",
            "        :param schema_name: schema name for the target table",
            "        :param overwrite: table_name will be dropped if true",
            "        :param method: method for the CTA query, currently view or table creation",
            "        :return: Create table as query",
            "        \"\"\"",
            "        exec_sql = \"\"",
            "        sql = self.stripped()",
            "        # TODO(bkyryliuk): quote full_table_name",
            "        full_table_name = f\"{schema_name}.{table_name}\" if schema_name else table_name",
            "        if overwrite:",
            "            exec_sql = f\"DROP {method} IF EXISTS {full_table_name};\\n\"",
            "        exec_sql += f\"CREATE {method} {full_table_name} AS \\n{sql}\"",
            "        return exec_sql",
            "",
            "    def _extract_from_token(self, token: Token) -> None:",
            "        \"\"\"",
            "        <Identifier> store a list of subtokens and <IdentifierList> store lists of",
            "        subtoken list.",
            "",
            "        It extracts <IdentifierList> and <Identifier> from :param token: and loops",
            "        through all subtokens recursively. It finds table_name_preceding_token and",
            "        passes <IdentifierList> and <Identifier> to self._process_tokenlist to populate",
            "        self._tables.",
            "",
            "        :param token: instance of Token or child class, e.g. TokenList, to be processed",
            "        \"\"\"",
            "        if not hasattr(token, \"tokens\"):",
            "            return",
            "",
            "        table_name_preceding_token = False",
            "",
            "        for item in token.tokens:",
            "            if item.is_group and (",
            "                not self._is_identifier(item) or isinstance(item.tokens[0], Parenthesis)",
            "            ):",
            "                self._extract_from_token(item)",
            "",
            "            if item.ttype in Keyword and (",
            "                item.normalized in PRECEDES_TABLE_NAME",
            "                or item.normalized.endswith(\" JOIN\")",
            "            ):",
            "                table_name_preceding_token = True",
            "                continue",
            "",
            "            if item.ttype in Keyword:",
            "                table_name_preceding_token = False",
            "                continue",
            "            if table_name_preceding_token:",
            "                if isinstance(item, Identifier):",
            "                    self._process_tokenlist(item)",
            "                elif isinstance(item, IdentifierList):",
            "                    for token2 in item.get_identifiers():",
            "                        if isinstance(token2, TokenList):",
            "                            self._process_tokenlist(token2)",
            "            elif isinstance(item, IdentifierList):",
            "                if any(not self._is_identifier(token2) for token2 in item.tokens):",
            "                    self._extract_from_token(item)",
            "",
            "    def set_or_update_query_limit(self, new_limit: int, force: bool = False) -> str:",
            "        \"\"\"Returns the query with the specified limit.",
            "",
            "        Does not change the underlying query if user did not apply the limit,",
            "        otherwise replaces the limit with the lower value between existing limit",
            "        in the query and new_limit.",
            "",
            "        :param new_limit: Limit to be incorporated into returned query",
            "        :return: The original query with new limit",
            "        \"\"\"",
            "        if not self._limit:",
            "            return f\"{self.stripped()}\\nLIMIT {new_limit}\"",
            "        limit_pos = None",
            "        statement = self._parsed[0]",
            "        # Add all items to before_str until there is a limit",
            "        for pos, item in enumerate(statement.tokens):",
            "            if item.ttype in Keyword and item.value.lower() == \"limit\":",
            "                limit_pos = pos",
            "                break",
            "        _, limit = statement.token_next(idx=limit_pos)",
            "        # Override the limit only when it exceeds the configured value.",
            "        if limit.ttype == sqlparse.tokens.Literal.Number.Integer and (",
            "            force or new_limit < int(limit.value)",
            "        ):",
            "            limit.value = new_limit",
            "        elif limit.is_group:",
            "            limit.value = f\"{next(limit.get_identifiers())}, {new_limit}\"",
            "",
            "        str_res = \"\"",
            "        for i in statement.tokens:",
            "            str_res += str(i.value)",
            "        return str_res",
            "",
            "",
            "def sanitize_clause(clause: str) -> str:",
            "    # clause = sqlparse.format(clause, strip_comments=True)",
            "    statements = sqlparse.parse(clause)",
            "    if len(statements) != 1:",
            "        raise QueryClauseValidationException(\"Clause contains multiple statements\")",
            "    open_parens = 0",
            "",
            "    previous_token = None",
            "    for token in statements[0]:",
            "        if token.value == \"/\" and previous_token and previous_token.value == \"*\":",
            "            raise QueryClauseValidationException(\"Closing unopened multiline comment\")",
            "        if token.value == \"*\" and previous_token and previous_token.value == \"/\":",
            "            raise QueryClauseValidationException(\"Unclosed multiline comment\")",
            "        if token.value in (\")\", \"(\"):",
            "            open_parens += 1 if token.value == \"(\" else -1",
            "            if open_parens < 0:",
            "                raise QueryClauseValidationException(",
            "                    \"Closing unclosed parenthesis in filter clause\"",
            "                )",
            "        previous_token = token",
            "    if open_parens > 0:",
            "        raise QueryClauseValidationException(\"Unclosed parenthesis in filter clause\")",
            "",
            "    if previous_token and previous_token.ttype in Comment:",
            "        if previous_token.value[-1] != \"\\n\":",
            "            clause = f\"{clause}\\n\"",
            "",
            "    return clause"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "352": [
                "validate_filter_clause"
            ],
            "353": [
                "validate_filter_clause"
            ],
            "354": [
                "validate_filter_clause"
            ],
            "355": [
                "validate_filter_clause"
            ],
            "358": [
                "validate_filter_clause"
            ]
        },
        "addLocation": []
    },
    "superset/utils/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     SupersetException,"
            },
            "1": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     SupersetTimeoutException,"
            },
            "2": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+from superset.sql_parse import sanitize_clause"
            },
            "4": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " from superset.typing import ("
            },
            "5": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     AdhocMetric,"
            },
            "6": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     AdhocMetricColumn,"
            },
            "7": {
                "beforePatchRowNumber": 1392,
                "afterPatchRowNumber": 1393,
                "PatchRowcode": "                         }"
            },
            "8": {
                "beforePatchRowNumber": 1393,
                "afterPatchRowNumber": 1394,
                "PatchRowcode": "                     )"
            },
            "9": {
                "beforePatchRowNumber": 1394,
                "afterPatchRowNumber": 1395,
                "PatchRowcode": "             elif expression_type == \"SQL\":"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1396,
                "PatchRowcode": "+                sql_expression = adhoc_filter.get(\"sqlExpression\")"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1397,
                "PatchRowcode": "+                sql_expression = sanitize_clause(sql_expression)"
            },
            "12": {
                "beforePatchRowNumber": 1395,
                "afterPatchRowNumber": 1398,
                "PatchRowcode": "                 if clause == \"WHERE\":"
            },
            "13": {
                "beforePatchRowNumber": 1396,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    sql_where_filters.append(adhoc_filter.get(\"sqlExpression\"))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1399,
                "PatchRowcode": "+                    sql_where_filters.append(sql_expression)"
            },
            "15": {
                "beforePatchRowNumber": 1397,
                "afterPatchRowNumber": 1400,
                "PatchRowcode": "                 elif clause == \"HAVING\":"
            },
            "16": {
                "beforePatchRowNumber": 1398,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    sql_having_filters.append(adhoc_filter.get(\"sqlExpression\"))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1401,
                "PatchRowcode": "+                    sql_having_filters.append(sql_expression)"
            },
            "18": {
                "beforePatchRowNumber": 1399,
                "afterPatchRowNumber": 1402,
                "PatchRowcode": "         form_data[\"where\"] = \" AND \".join("
            },
            "19": {
                "beforePatchRowNumber": 1400,
                "afterPatchRowNumber": 1403,
                "PatchRowcode": "             [\"({})\".format(sql) for sql in sql_where_filters]"
            },
            "20": {
                "beforePatchRowNumber": 1401,
                "afterPatchRowNumber": 1404,
                "PatchRowcode": "         )"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"Utility functions used across Superset\"\"\"",
            "# pylint: disable=too-many-lines",
            "import collections",
            "import decimal",
            "import errno",
            "import json",
            "import logging",
            "import os",
            "import platform",
            "import re",
            "import signal",
            "import smtplib",
            "import tempfile",
            "import threading",
            "import traceback",
            "import uuid",
            "import zlib",
            "from datetime import date, datetime, time, timedelta",
            "from distutils.util import strtobool",
            "from email.mime.application import MIMEApplication",
            "from email.mime.image import MIMEImage",
            "from email.mime.multipart import MIMEMultipart",
            "from email.mime.text import MIMEText",
            "from email.utils import formatdate",
            "from enum import Enum, IntEnum",
            "from timeit import default_timer",
            "from types import TracebackType",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    cast,",
            "    Dict,",
            "    Iterable,",
            "    Iterator,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Sequence,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TYPE_CHECKING,",
            "    TypeVar,",
            "    Union,",
            ")",
            "from urllib.parse import unquote_plus",
            "",
            "import bleach",
            "import markdown as md",
            "import numpy as np",
            "import pandas as pd",
            "import sqlalchemy as sa",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.backends.openssl.x509 import _Certificate",
            "from flask import current_app, flash, g, Markup, render_template, request",
            "from flask_appbuilder import SQLA",
            "from flask_appbuilder.security.sqla.models import Role, User",
            "from flask_babel import gettext as __",
            "from flask_babel.speaklater import LazyString",
            "from pandas.api.types import infer_dtype",
            "from pandas.core.dtypes.common import is_numeric_dtype",
            "from sqlalchemy import event, exc, inspect, select, Text",
            "from sqlalchemy.dialects.mysql import MEDIUMTEXT",
            "from sqlalchemy.engine import Connection, Engine",
            "from sqlalchemy.engine.reflection import Inspector",
            "from sqlalchemy.sql.type_api import Variant",
            "from sqlalchemy.types import TEXT, TypeDecorator, TypeEngine",
            "from typing_extensions import TypedDict, TypeGuard",
            "",
            "import _thread  # pylint: disable=C0411",
            "from superset.constants import (",
            "    EXAMPLES_DB_UUID,",
            "    EXTRA_FORM_DATA_APPEND_KEYS,",
            "    EXTRA_FORM_DATA_OVERRIDE_EXTRA_KEYS,",
            "    EXTRA_FORM_DATA_OVERRIDE_REGULAR_MAPPINGS,",
            ")",
            "from superset.errors import ErrorLevel, SupersetErrorType",
            "from superset.exceptions import (",
            "    CertificateException,",
            "    SupersetException,",
            "    SupersetTimeoutException,",
            ")",
            "from superset.typing import (",
            "    AdhocMetric,",
            "    AdhocMetricColumn,",
            "    FilterValues,",
            "    FlaskResponse,",
            "    FormData,",
            "    Metric,",
            ")",
            "from superset.utils.dates import datetime_to_epoch, EPOCH",
            "from superset.utils.hashing import md5_sha_from_dict, md5_sha_from_str",
            "",
            "try:",
            "    from pydruid.utils.having import Having",
            "except ImportError:",
            "    pass",
            "",
            "if TYPE_CHECKING:",
            "    from superset.connectors.base.models import BaseColumn, BaseDatasource",
            "    from superset.models.core import Database",
            "",
            "",
            "logging.getLogger(\"MARKDOWN\").setLevel(logging.INFO)",
            "logger = logging.getLogger(__name__)",
            "",
            "DTTM_ALIAS = \"__timestamp\"",
            "",
            "NO_TIME_RANGE = \"No filter\"",
            "",
            "TIME_COMPARISION = \"__\"",
            "",
            "JS_MAX_INTEGER = 9007199254740991  # Largest int Java Script can handle 2^53-1",
            "",
            "InputType = TypeVar(\"InputType\")",
            "",
            "",
            "class LenientEnum(Enum):",
            "    \"\"\"Enums with a `get` method that convert a enum value to `Enum` if it is a",
            "    valid value.\"\"\"",
            "",
            "    @classmethod",
            "    def get(cls, value: Any) -> Any:",
            "        try:",
            "            return super().__new__(cls, value)",
            "        except ValueError:",
            "            return None",
            "",
            "",
            "class AdhocMetricExpressionType(str, Enum):",
            "    SIMPLE = \"SIMPLE\"",
            "    SQL = \"SQL\"",
            "",
            "",
            "class AnnotationType(str, Enum):",
            "    FORMULA = \"FORMULA\"",
            "    INTERVAL = \"INTERVAL\"",
            "    EVENT = \"EVENT\"",
            "    TIME_SERIES = \"TIME_SERIES\"",
            "",
            "",
            "class GenericDataType(IntEnum):",
            "    \"\"\"",
            "    Generic database column type that fits both frontend and backend.",
            "    \"\"\"",
            "",
            "    NUMERIC = 0",
            "    STRING = 1",
            "    TEMPORAL = 2",
            "    BOOLEAN = 3",
            "    # ARRAY = 4     # Mapping all the complex data types to STRING for now",
            "    # JSON = 5      # and leaving these as a reminder.",
            "    # MAP = 6",
            "    # ROW = 7",
            "",
            "",
            "class ChartDataResultFormat(str, Enum):",
            "    \"\"\"",
            "    Chart data response format",
            "    \"\"\"",
            "",
            "    CSV = \"csv\"",
            "    JSON = \"json\"",
            "",
            "",
            "class ChartDataResultType(str, Enum):",
            "    \"\"\"",
            "    Chart data response type",
            "    \"\"\"",
            "",
            "    COLUMNS = \"columns\"",
            "    FULL = \"full\"",
            "    QUERY = \"query\"",
            "    RESULTS = \"results\"",
            "    SAMPLES = \"samples\"",
            "    TIMEGRAINS = \"timegrains\"",
            "    POST_PROCESSED = \"post_processed\"",
            "",
            "",
            "class DatasourceDict(TypedDict):",
            "    type: str",
            "    id: int",
            "",
            "",
            "class AdhocFilterClause(TypedDict, total=False):",
            "    clause: str",
            "    expressionType: str",
            "    filterOptionName: Optional[str]",
            "    comparator: Optional[FilterValues]",
            "    operator: str",
            "    subject: str",
            "    isExtra: Optional[bool]",
            "    sqlExpression: Optional[str]",
            "",
            "",
            "class QueryObjectFilterClause(TypedDict, total=False):",
            "    col: str",
            "    op: str  # pylint: disable=invalid-name",
            "    val: Optional[FilterValues]",
            "    grain: Optional[str]",
            "    isExtra: Optional[bool]",
            "",
            "",
            "class ExtraFiltersTimeColumnType(str, Enum):",
            "    GRANULARITY = \"__granularity\"",
            "    TIME_COL = \"__time_col\"",
            "    TIME_GRAIN = \"__time_grain\"",
            "    TIME_ORIGIN = \"__time_origin\"",
            "    TIME_RANGE = \"__time_range\"",
            "",
            "",
            "class ExtraFiltersReasonType(str, Enum):",
            "    NO_TEMPORAL_COLUMN = \"no_temporal_column\"",
            "    COL_NOT_IN_DATASOURCE = \"not_in_datasource\"",
            "    NOT_DRUID_DATASOURCE = \"not_druid_datasource\"",
            "",
            "",
            "class FilterOperator(str, Enum):",
            "    \"\"\"",
            "    Operators used filter controls",
            "    \"\"\"",
            "",
            "    EQUALS = \"==\"",
            "    NOT_EQUALS = \"!=\"",
            "    GREATER_THAN = \">\"",
            "    LESS_THAN = \"<\"",
            "    GREATER_THAN_OR_EQUALS = \">=\"",
            "    LESS_THAN_OR_EQUALS = \"<=\"",
            "    LIKE = \"LIKE\"",
            "    ILIKE = \"ILIKE\"",
            "    IS_NULL = \"IS NULL\"",
            "    IS_NOT_NULL = \"IS NOT NULL\"",
            "    IN = \"IN\"",
            "    NOT_IN = \"NOT IN\"",
            "    REGEX = \"REGEX\"",
            "    IS_TRUE = \"IS TRUE\"",
            "    IS_FALSE = \"IS FALSE\"",
            "",
            "",
            "class PostProcessingBoxplotWhiskerType(str, Enum):",
            "    \"\"\"",
            "    Calculate cell contribution to row/column total",
            "    \"\"\"",
            "",
            "    TUKEY = \"tukey\"",
            "    MINMAX = \"min/max\"",
            "    PERCENTILE = \"percentile\"",
            "",
            "",
            "class PostProcessingContributionOrientation(str, Enum):",
            "    \"\"\"",
            "    Calculate cell contribution to row/column total",
            "    \"\"\"",
            "",
            "    ROW = \"row\"",
            "    COLUMN = \"column\"",
            "",
            "",
            "class QueryMode(str, LenientEnum):",
            "    \"\"\"",
            "    Whether the query runs on aggregate or returns raw records",
            "    \"\"\"",
            "",
            "    RAW = \"raw\"",
            "    AGGREGATE = \"aggregate\"",
            "",
            "",
            "class QuerySource(Enum):",
            "    \"\"\"",
            "    The source of a SQL query.",
            "    \"\"\"",
            "",
            "    CHART = 0",
            "    DASHBOARD = 1",
            "    SQL_LAB = 2",
            "",
            "",
            "class QueryStatus(str, Enum):",
            "    \"\"\"Enum-type class for query statuses\"\"\"",
            "",
            "    STOPPED: str = \"stopped\"",
            "    FAILED: str = \"failed\"",
            "    PENDING: str = \"pending\"",
            "    RUNNING: str = \"running\"",
            "    SCHEDULED: str = \"scheduled\"",
            "    SUCCESS: str = \"success\"",
            "    FETCHING: str = \"fetching\"",
            "    TIMED_OUT: str = \"timed_out\"",
            "",
            "",
            "class DashboardStatus(str, Enum):",
            "    \"\"\"Dashboard status used for frontend filters\"\"\"",
            "",
            "    PUBLISHED = \"published\"",
            "    DRAFT = \"draft\"",
            "",
            "",
            "class ReservedUrlParameters(str, Enum):",
            "    \"\"\"",
            "    Reserved URL parameters that are used internally by Superset. These will not be",
            "    passed to chart queries, as they control the behavior of the UI.",
            "    \"\"\"",
            "",
            "    STANDALONE = \"standalone\"",
            "    EDIT_MODE = \"edit\"",
            "",
            "    @staticmethod",
            "    def is_standalone_mode() -> Optional[bool]:",
            "        standalone_param = request.args.get(ReservedUrlParameters.STANDALONE.value)",
            "        standalone: Optional[bool] = (",
            "            standalone_param and standalone_param != \"false\" and standalone_param != \"0\"",
            "        )",
            "        return standalone",
            "",
            "",
            "class RowLevelSecurityFilterType(str, Enum):",
            "    REGULAR = \"Regular\"",
            "    BASE = \"Base\"",
            "",
            "",
            "class TimeRangeEndpoint(str, Enum):",
            "    \"\"\"",
            "    The time range endpoint types which represent inclusive, exclusive, or unknown.",
            "",
            "    Unknown represents endpoints which are ill-defined as though the interval may be",
            "    [start, end] the filter may behave like (start, end] due to mixed data types and",
            "    lexicographical ordering.",
            "",
            "    :see: https://github.com/apache/superset/issues/6360",
            "    \"\"\"",
            "",
            "    EXCLUSIVE = \"exclusive\"",
            "    INCLUSIVE = \"inclusive\"",
            "    UNKNOWN = \"unknown\"",
            "",
            "",
            "class TemporalType(str, Enum):",
            "    \"\"\"",
            "    Supported temporal types",
            "    \"\"\"",
            "",
            "    DATE = \"DATE\"",
            "    DATETIME = \"DATETIME\"",
            "    SMALLDATETIME = \"SMALLDATETIME\"",
            "    TEXT = \"TEXT\"",
            "    TIME = \"TIME\"",
            "    TIMESTAMP = \"TIMESTAMP\"",
            "",
            "",
            "class ColumnTypeSource(Enum):",
            "    GET_TABLE = 1",
            "    CURSOR_DESCRIPION = 2",
            "",
            "",
            "class ColumnSpec(NamedTuple):",
            "    sqla_type: Union[TypeEngine, str]",
            "    generic_type: GenericDataType",
            "    is_dttm: bool",
            "    python_date_format: Optional[str] = None",
            "",
            "",
            "try:",
            "    # Having might not have been imported.",
            "    class DimSelector(Having):",
            "        def __init__(self, **args: Any) -> None:",
            "            # Just a hack to prevent any exceptions",
            "            Having.__init__(self, type=\"equalTo\", aggregation=None, value=None)",
            "",
            "            self.having = {",
            "                \"having\": {",
            "                    \"type\": \"dimSelector\",",
            "                    \"dimension\": args[\"dimension\"],",
            "                    \"value\": args[\"value\"],",
            "                }",
            "            }",
            "",
            "",
            "except NameError:",
            "    pass",
            "",
            "",
            "def flasher(msg: str, severity: str = \"message\") -> None:",
            "    \"\"\"Flask's flash if available, logging call if not\"\"\"",
            "    try:",
            "        flash(msg, severity)",
            "    except RuntimeError:",
            "        if severity == \"danger\":",
            "            logger.error(msg, exc_info=True)",
            "        else:",
            "            logger.info(msg)",
            "",
            "",
            "def parse_js_uri_path_item(",
            "    item: Optional[str], unquote: bool = True, eval_undefined: bool = False",
            ") -> Optional[str]:",
            "    \"\"\"Parse a uri path item made with js.",
            "",
            "    :param item: a uri path component",
            "    :param unquote: Perform unquoting of string using urllib.parse.unquote_plus()",
            "    :param eval_undefined: When set to True and item is either 'null'  or 'undefined',",
            "    assume item is undefined and return None.",
            "    :return: Either None, the original item or unquoted item",
            "    \"\"\"",
            "    item = None if eval_undefined and item in (\"null\", \"undefined\") else item",
            "    return unquote_plus(item) if unquote and item else item",
            "",
            "",
            "def cast_to_num(value: Optional[Union[float, int, str]]) -> Optional[Union[float, int]]:",
            "    \"\"\"Casts a value to an int/float",
            "",
            "    >>> cast_to_num('1 ')",
            "    1.0",
            "    >>> cast_to_num(' 2')",
            "    2.0",
            "    >>> cast_to_num('5')",
            "    5",
            "    >>> cast_to_num('5.2')",
            "    5.2",
            "    >>> cast_to_num(10)",
            "    10",
            "    >>> cast_to_num(10.1)",
            "    10.1",
            "    >>> cast_to_num(None) is None",
            "    True",
            "    >>> cast_to_num('this is not a string') is None",
            "    True",
            "",
            "    :param value: value to be converted to numeric representation",
            "    :returns: value cast to `int` if value is all digits, `float` if `value` is",
            "              decimal value and `None`` if it can't be converted",
            "    \"\"\"",
            "    if value is None:",
            "        return None",
            "    if isinstance(value, (int, float)):",
            "        return value",
            "    if value.isdigit():",
            "        return int(value)",
            "    try:",
            "        return float(value)",
            "    except ValueError:",
            "        return None",
            "",
            "",
            "def cast_to_boolean(value: Any) -> Optional[bool]:",
            "    \"\"\"Casts a value to an int/float",
            "",
            "    >>> cast_to_boolean(1)",
            "    True",
            "    >>> cast_to_boolean(0)",
            "    False",
            "    >>> cast_to_boolean(0.5)",
            "    True",
            "    >>> cast_to_boolean('true')",
            "    True",
            "    >>> cast_to_boolean('false')",
            "    False",
            "    >>> cast_to_boolean('False')",
            "    False",
            "    >>> cast_to_boolean(None)",
            "",
            "    :param value: value to be converted to boolean representation",
            "    :returns: value cast to `bool`. when value is 'true' or value that are not 0",
            "              converted into True. Return `None` if value is `None`",
            "    \"\"\"",
            "    if value is None:",
            "        return None",
            "    if isinstance(value, (int, float)):",
            "        return value != 0",
            "    if isinstance(value, str):",
            "        return value.strip().lower() == \"true\"",
            "    return False",
            "",
            "",
            "def list_minus(l: List[Any], minus: List[Any]) -> List[Any]:",
            "    \"\"\"Returns l without what is in minus",
            "",
            "    >>> list_minus([1, 2, 3], [2])",
            "    [1, 3]",
            "    \"\"\"",
            "    return [o for o in l if o not in minus]",
            "",
            "",
            "class DashboardEncoder(json.JSONEncoder):",
            "    def __init__(self, *args: Any, **kwargs: Any) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.sort_keys = True",
            "",
            "    def default(self, o: Any) -> Union[Dict[Any, Any], str]:",
            "        if isinstance(o, uuid.UUID):",
            "            return str(o)",
            "        try:",
            "            vals = {k: v for k, v in o.__dict__.items() if k != \"_sa_instance_state\"}",
            "            return {\"__{}__\".format(o.__class__.__name__): vals}",
            "        except Exception:  # pylint: disable=broad-except",
            "            if isinstance(o, datetime):",
            "                return {\"__datetime__\": o.replace(microsecond=0).isoformat()}",
            "            return json.JSONEncoder(sort_keys=True).default(o)",
            "",
            "",
            "class JSONEncodedDict(TypeDecorator):  # pylint: disable=abstract-method",
            "    \"\"\"Represents an immutable structure as a json-encoded string.\"\"\"",
            "",
            "    impl = TEXT",
            "",
            "    def process_bind_param(",
            "        self, value: Optional[Dict[Any, Any]], dialect: str",
            "    ) -> Optional[str]:",
            "        return json.dumps(value) if value is not None else None",
            "",
            "    def process_result_value(",
            "        self, value: Optional[str], dialect: str",
            "    ) -> Optional[Dict[Any, Any]]:",
            "        return json.loads(value) if value is not None else None",
            "",
            "",
            "def format_timedelta(time_delta: timedelta) -> str:",
            "    \"\"\"",
            "    Ensures negative time deltas are easily interpreted by humans",
            "",
            "    >>> td = timedelta(0) - timedelta(days=1, hours=5,minutes=6)",
            "    >>> str(td)",
            "    '-2 days, 18:54:00'",
            "    >>> format_timedelta(td)",
            "    '-1 day, 5:06:00'",
            "    \"\"\"",
            "    if time_delta < timedelta(0):",
            "        return \"-\" + str(abs(time_delta))",
            "",
            "    # Change this to format positive time deltas the way you want",
            "    return str(time_delta)",
            "",
            "",
            "def base_json_conv(obj: Any,) -> Any:  # pylint: disable=inconsistent-return-statements",
            "    if isinstance(obj, memoryview):",
            "        obj = obj.tobytes()",
            "    if isinstance(obj, np.int64):",
            "        return int(obj)",
            "    if isinstance(obj, np.bool_):",
            "        return bool(obj)",
            "    if isinstance(obj, np.ndarray):",
            "        return obj.tolist()",
            "    if isinstance(obj, set):",
            "        return list(obj)",
            "    if isinstance(obj, decimal.Decimal):",
            "        return float(obj)",
            "    if isinstance(obj, (uuid.UUID, time, LazyString)):",
            "        return str(obj)",
            "    if isinstance(obj, timedelta):",
            "        return format_timedelta(obj)",
            "    if isinstance(obj, bytes):",
            "        try:",
            "            return obj.decode(\"utf-8\")",
            "        except Exception:  # pylint: disable=broad-except",
            "            return \"[bytes]\"",
            "",
            "",
            "def json_iso_dttm_ser(obj: Any, pessimistic: bool = False) -> str:",
            "    \"\"\"",
            "    json serializer that deals with dates",
            "",
            "    >>> dttm = datetime(1970, 1, 1)",
            "    >>> json.dumps({'dttm': dttm}, default=json_iso_dttm_ser)",
            "    '{\"dttm\": \"1970-01-01T00:00:00\"}'",
            "    \"\"\"",
            "    val = base_json_conv(obj)",
            "    if val is not None:",
            "        return val",
            "    if isinstance(obj, (datetime, date, pd.Timestamp)):",
            "        obj = obj.isoformat()",
            "    else:",
            "        if pessimistic:",
            "            return \"Unserializable [{}]\".format(type(obj))",
            "",
            "        raise TypeError(\"Unserializable object {} of type {}\".format(obj, type(obj)))",
            "    return obj",
            "",
            "",
            "def pessimistic_json_iso_dttm_ser(obj: Any) -> str:",
            "    \"\"\"Proxy to call json_iso_dttm_ser in a pessimistic way",
            "",
            "    If one of object is not serializable to json, it will still succeed\"\"\"",
            "    return json_iso_dttm_ser(obj, pessimistic=True)",
            "",
            "",
            "def json_int_dttm_ser(obj: Any) -> float:",
            "    \"\"\"json serializer that deals with dates\"\"\"",
            "    val = base_json_conv(obj)",
            "    if val is not None:",
            "        return val",
            "    if isinstance(obj, (datetime, pd.Timestamp)):",
            "        obj = datetime_to_epoch(obj)",
            "    elif isinstance(obj, date):",
            "        obj = (obj - EPOCH.date()).total_seconds() * 1000",
            "    else:",
            "        raise TypeError(\"Unserializable object {} of type {}\".format(obj, type(obj)))",
            "    return obj",
            "",
            "",
            "def json_dumps_w_dates(payload: Dict[Any, Any]) -> str:",
            "    return json.dumps(payload, default=json_int_dttm_ser)",
            "",
            "",
            "def error_msg_from_exception(ex: Exception) -> str:",
            "    \"\"\"Translate exception into error message",
            "",
            "    Database have different ways to handle exception. This function attempts",
            "    to make sense of the exception object and construct a human readable",
            "    sentence.",
            "",
            "    TODO(bkyryliuk): parse the Presto error message from the connection",
            "                     created via create_engine.",
            "    engine = create_engine('presto://localhost:3506/silver') -",
            "      gives an e.message as the str(dict)",
            "    presto.connect('localhost', port=3506, catalog='silver') - as a dict.",
            "    The latter version is parsed correctly by this function.",
            "    \"\"\"",
            "    msg = \"\"",
            "    if hasattr(ex, \"message\"):",
            "        if isinstance(ex.message, dict):  # type: ignore",
            "            msg = ex.message.get(\"message\")  # type: ignore",
            "        elif ex.message:  # type: ignore",
            "            msg = ex.message  # type: ignore",
            "    return msg or str(ex)",
            "",
            "",
            "def markdown(raw: str, markup_wrap: Optional[bool] = False) -> str:",
            "    safe_markdown_tags = [",
            "        \"h1\",",
            "        \"h2\",",
            "        \"h3\",",
            "        \"h4\",",
            "        \"h5\",",
            "        \"h6\",",
            "        \"b\",",
            "        \"i\",",
            "        \"strong\",",
            "        \"em\",",
            "        \"tt\",",
            "        \"p\",",
            "        \"br\",",
            "        \"span\",",
            "        \"div\",",
            "        \"blockquote\",",
            "        \"code\",",
            "        \"hr\",",
            "        \"ul\",",
            "        \"ol\",",
            "        \"li\",",
            "        \"dd\",",
            "        \"dt\",",
            "        \"img\",",
            "        \"a\",",
            "    ]",
            "    safe_markdown_attrs = {",
            "        \"img\": [\"src\", \"alt\", \"title\"],",
            "        \"a\": [\"href\", \"alt\", \"title\"],",
            "    }",
            "    safe = md.markdown(",
            "        raw or \"\",",
            "        extensions=[",
            "            \"markdown.extensions.tables\",",
            "            \"markdown.extensions.fenced_code\",",
            "            \"markdown.extensions.codehilite\",",
            "        ],",
            "    )",
            "    safe = bleach.clean(safe, safe_markdown_tags, safe_markdown_attrs)",
            "    if markup_wrap:",
            "        safe = Markup(safe)",
            "    return safe",
            "",
            "",
            "def readfile(file_path: str) -> Optional[str]:",
            "    with open(file_path) as f:",
            "        content = f.read()",
            "    return content",
            "",
            "",
            "def generic_find_constraint_name(",
            "    table: str, columns: Set[str], referenced: str, database: SQLA",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a constraint name in alembic migrations\"\"\"",
            "    tbl = sa.Table(",
            "        table, database.metadata, autoload=True, autoload_with=database.engine",
            "    )",
            "",
            "    for fk in tbl.foreign_key_constraints:",
            "        if fk.referred_table.name == referenced and set(fk.column_keys) == columns:",
            "            return fk.name",
            "",
            "    return None",
            "",
            "",
            "def generic_find_fk_constraint_name(",
            "    table: str, columns: Set[str], referenced: str, insp: Inspector",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a foreign-key constraint name in alembic migrations\"\"\"",
            "    for fk in insp.get_foreign_keys(table):",
            "        if (",
            "            fk[\"referred_table\"] == referenced",
            "            and set(fk[\"referred_columns\"]) == columns",
            "        ):",
            "            return fk[\"name\"]",
            "",
            "    return None",
            "",
            "",
            "def generic_find_fk_constraint_names(  # pylint: disable=invalid-name",
            "    table: str, columns: Set[str], referenced: str, insp: Inspector",
            ") -> Set[str]:",
            "    \"\"\"Utility to find foreign-key constraint names in alembic migrations\"\"\"",
            "    names = set()",
            "",
            "    for fk in insp.get_foreign_keys(table):",
            "        if (",
            "            fk[\"referred_table\"] == referenced",
            "            and set(fk[\"referred_columns\"]) == columns",
            "        ):",
            "            names.add(fk[\"name\"])",
            "",
            "    return names",
            "",
            "",
            "def generic_find_uq_constraint_name(",
            "    table: str, columns: Set[str], insp: Inspector",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a unique constraint name in alembic migrations\"\"\"",
            "",
            "    for uq in insp.get_unique_constraints(table):",
            "        if columns == set(uq[\"column_names\"]):",
            "            return uq[\"name\"]",
            "",
            "    return None",
            "",
            "",
            "def get_datasource_full_name(",
            "    database_name: str, datasource_name: str, schema: Optional[str] = None",
            ") -> str:",
            "    if not schema:",
            "        return \"[{}].[{}]\".format(database_name, datasource_name)",
            "    return \"[{}].[{}].[{}]\".format(database_name, schema, datasource_name)",
            "",
            "",
            "def validate_json(obj: Union[bytes, bytearray, str]) -> None:",
            "    if obj:",
            "        try:",
            "            json.loads(obj)",
            "        except Exception as ex:",
            "            logger.error(\"JSON is not valid %s\", str(ex), exc_info=True)",
            "            raise SupersetException(\"JSON is not valid\") from ex",
            "",
            "",
            "class SigalrmTimeout:",
            "    \"\"\"",
            "    To be used in a ``with`` block and timeout its content.",
            "    \"\"\"",
            "",
            "    def __init__(self, seconds: int = 1, error_message: str = \"Timeout\") -> None:",
            "        self.seconds = seconds",
            "        self.error_message = error_message",
            "",
            "    def handle_timeout(  # pylint: disable=unused-argument",
            "        self, signum: int, frame: Any",
            "    ) -> None:",
            "        logger.error(\"Process timed out\", exc_info=True)",
            "        raise SupersetTimeoutException(",
            "            error_type=SupersetErrorType.BACKEND_TIMEOUT_ERROR,",
            "            message=self.error_message,",
            "            level=ErrorLevel.ERROR,",
            "            extra={\"timeout\": self.seconds},",
            "        )",
            "",
            "    def __enter__(self) -> None:",
            "        try:",
            "            if threading.current_thread() == threading.main_thread():",
            "                signal.signal(signal.SIGALRM, self.handle_timeout)",
            "                signal.alarm(self.seconds)",
            "        except ValueError as ex:",
            "            logger.warning(\"timeout can't be used in the current context\")",
            "            logger.exception(ex)",
            "",
            "    def __exit__(  # pylint: disable=redefined-outer-name,redefined-builtin",
            "        self, type: Any, value: Any, traceback: TracebackType",
            "    ) -> None:",
            "        try:",
            "            signal.alarm(0)",
            "        except ValueError as ex:",
            "            logger.warning(\"timeout can't be used in the current context\")",
            "            logger.exception(ex)",
            "",
            "",
            "class TimerTimeout:",
            "    def __init__(self, seconds: int = 1, error_message: str = \"Timeout\") -> None:",
            "        self.seconds = seconds",
            "        self.error_message = error_message",
            "        self.timer = threading.Timer(seconds, _thread.interrupt_main)",
            "",
            "    def __enter__(self) -> None:",
            "        self.timer.start()",
            "",
            "    def __exit__(  # pylint: disable=redefined-outer-name,redefined-builtin",
            "        self, type: Any, value: Any, traceback: TracebackType",
            "    ) -> None:",
            "        self.timer.cancel()",
            "        if type is KeyboardInterrupt:  # raised by _thread.interrupt_main",
            "            raise SupersetTimeoutException(",
            "                error_type=SupersetErrorType.BACKEND_TIMEOUT_ERROR,",
            "                message=self.error_message,",
            "                level=ErrorLevel.ERROR,",
            "                extra={\"timeout\": self.seconds},",
            "            )",
            "",
            "",
            "# Windows has no support for SIGALRM, so we use the timer based timeout",
            "timeout: Union[Type[TimerTimeout], Type[SigalrmTimeout]] = (",
            "    TimerTimeout if platform.system() == \"Windows\" else SigalrmTimeout",
            ")",
            "",
            "",
            "def pessimistic_connection_handling(some_engine: Engine) -> None:",
            "    @event.listens_for(some_engine, \"engine_connect\")",
            "    def ping_connection(connection: Connection, branch: bool) -> None:",
            "        if branch:",
            "            # 'branch' refers to a sub-connection of a connection,",
            "            # we don't want to bother pinging on these.",
            "            return",
            "",
            "        # turn off 'close with result'.  This flag is only used with",
            "        # 'connectionless' execution, otherwise will be False in any case",
            "        save_should_close_with_result = connection.should_close_with_result",
            "        connection.should_close_with_result = False",
            "",
            "        try:",
            "            # run a SELECT 1.   use a core select() so that",
            "            # the SELECT of a scalar value without a table is",
            "            # appropriately formatted for the backend",
            "            connection.scalar(select([1]))",
            "        except exc.DBAPIError as err:",
            "            # catch SQLAlchemy's DBAPIError, which is a wrapper",
            "            # for the DBAPI's exception.  It includes a .connection_invalidated",
            "            # attribute which specifies if this connection is a 'disconnect'",
            "            # condition, which is based on inspection of the original exception",
            "            # by the dialect in use.",
            "            if err.connection_invalidated:",
            "                # run the same SELECT again - the connection will re-validate",
            "                # itself and establish a new connection.  The disconnect detection",
            "                # here also causes the whole connection pool to be invalidated",
            "                # so that all stale connections are discarded.",
            "                connection.scalar(select([1]))",
            "            else:",
            "                raise",
            "        finally:",
            "            # restore 'close with result'",
            "            connection.should_close_with_result = save_should_close_with_result",
            "",
            "",
            "def notify_user_about_perm_udate(  # pylint: disable=too-many-arguments",
            "    granter: User,",
            "    user: User,",
            "    role: Role,",
            "    datasource: \"BaseDatasource\",",
            "    tpl_name: str,",
            "    config: Dict[str, Any],",
            ") -> None:",
            "    msg = render_template(",
            "        tpl_name, granter=granter, user=user, role=role, datasource=datasource",
            "    )",
            "    logger.info(msg)",
            "    subject = __(",
            "        \"[Superset] Access to the datasource %(name)s was granted\",",
            "        name=datasource.full_name,",
            "    )",
            "    send_email_smtp(",
            "        user.email,",
            "        subject,",
            "        msg,",
            "        config,",
            "        bcc=granter.email,",
            "        dryrun=not config[\"EMAIL_NOTIFICATIONS\"],",
            "    )",
            "",
            "",
            "def send_email_smtp(  # pylint: disable=invalid-name,too-many-arguments,too-many-locals",
            "    to: str,",
            "    subject: str,",
            "    html_content: str,",
            "    config: Dict[str, Any],",
            "    files: Optional[List[str]] = None,",
            "    data: Optional[Dict[str, str]] = None,",
            "    images: Optional[Dict[str, bytes]] = None,",
            "    dryrun: bool = False,",
            "    cc: Optional[str] = None,",
            "    bcc: Optional[str] = None,",
            "    mime_subtype: str = \"mixed\",",
            ") -> None:",
            "    \"\"\"",
            "    Send an email with html content, eg:",
            "    send_email_smtp(",
            "        'test@example.com', 'foo', '<b>Foo</b> bar',['/dev/null'], dryrun=True)",
            "    \"\"\"",
            "    smtp_mail_from = config[\"SMTP_MAIL_FROM\"]",
            "    smtp_mail_to = get_email_address_list(to)",
            "",
            "    msg = MIMEMultipart(mime_subtype)",
            "    msg[\"Subject\"] = subject",
            "    msg[\"From\"] = smtp_mail_from",
            "    msg[\"To\"] = \", \".join(smtp_mail_to)",
            "    msg.preamble = \"This is a multi-part message in MIME format.\"",
            "",
            "    recipients = smtp_mail_to",
            "    if cc:",
            "        smtp_mail_cc = get_email_address_list(cc)",
            "        msg[\"CC\"] = \", \".join(smtp_mail_cc)",
            "        recipients = recipients + smtp_mail_cc",
            "",
            "    if bcc:",
            "        # don't add bcc in header",
            "        smtp_mail_bcc = get_email_address_list(bcc)",
            "        recipients = recipients + smtp_mail_bcc",
            "",
            "    msg[\"Date\"] = formatdate(localtime=True)",
            "    mime_text = MIMEText(html_content, \"html\")",
            "    msg.attach(mime_text)",
            "",
            "    # Attach files by reading them from disk",
            "    for fname in files or []:",
            "        basename = os.path.basename(fname)",
            "        with open(fname, \"rb\") as f:",
            "            msg.attach(",
            "                MIMEApplication(",
            "                    f.read(),",
            "                    Content_Disposition=\"attachment; filename='%s'\" % basename,",
            "                    Name=basename,",
            "                )",
            "            )",
            "",
            "    # Attach any files passed directly",
            "    for name, body in (data or {}).items():",
            "        msg.attach(",
            "            MIMEApplication(",
            "                body, Content_Disposition=\"attachment; filename='%s'\" % name, Name=name",
            "            )",
            "        )",
            "",
            "    # Attach any inline images, which may be required for display in",
            "    # HTML content (inline)",
            "    for msgid, imgdata in (images or {}).items():",
            "        image = MIMEImage(imgdata)",
            "        image.add_header(\"Content-ID\", \"<%s>\" % msgid)",
            "        image.add_header(\"Content-Disposition\", \"inline\")",
            "        msg.attach(image)",
            "",
            "    send_mime_email(smtp_mail_from, recipients, msg, config, dryrun=dryrun)",
            "",
            "",
            "def send_mime_email(",
            "    e_from: str,",
            "    e_to: List[str],",
            "    mime_msg: MIMEMultipart,",
            "    config: Dict[str, Any],",
            "    dryrun: bool = False,",
            ") -> None:",
            "    smtp_host = config[\"SMTP_HOST\"]",
            "    smtp_port = config[\"SMTP_PORT\"]",
            "    smtp_user = config[\"SMTP_USER\"]",
            "    smtp_password = config[\"SMTP_PASSWORD\"]",
            "    smtp_starttls = config[\"SMTP_STARTTLS\"]",
            "    smtp_ssl = config[\"SMTP_SSL\"]",
            "",
            "    if not dryrun:",
            "        smtp = (",
            "            smtplib.SMTP_SSL(smtp_host, smtp_port)",
            "            if smtp_ssl",
            "            else smtplib.SMTP(smtp_host, smtp_port)",
            "        )",
            "        if smtp_starttls:",
            "            smtp.starttls()",
            "        if smtp_user and smtp_password:",
            "            smtp.login(smtp_user, smtp_password)",
            "        logger.debug(\"Sent an email to %s\", str(e_to))",
            "        smtp.sendmail(e_from, e_to, mime_msg.as_string())",
            "        smtp.quit()",
            "    else:",
            "        logger.info(\"Dryrun enabled, email notification content is below:\")",
            "        logger.info(mime_msg.as_string())",
            "",
            "",
            "def get_email_address_list(address_string: str) -> List[str]:",
            "    address_string_list: List[str] = []",
            "    if isinstance(address_string, str):",
            "        address_string_list = re.split(r\",|\\s|;\", address_string)",
            "    return [x.strip() for x in address_string_list if x.strip()]",
            "",
            "",
            "def get_email_address_str(address_string: str) -> str:",
            "    address_list = get_email_address_list(address_string)",
            "    address_list_str = \", \".join(address_list)",
            "",
            "    return address_list_str",
            "",
            "",
            "def choicify(values: Iterable[Any]) -> List[Tuple[Any, Any]]:",
            "    \"\"\"Takes an iterable and makes an iterable of tuples with it\"\"\"",
            "    return [(v, v) for v in values]",
            "",
            "",
            "def zlib_compress(data: Union[bytes, str]) -> bytes:",
            "    \"\"\"",
            "    Compress things in a py2/3 safe fashion",
            "    >>> json_str = '{\"test\": 1}'",
            "    >>> blob = zlib_compress(json_str)",
            "    \"\"\"",
            "    if isinstance(data, str):",
            "        return zlib.compress(bytes(data, \"utf-8\"))",
            "    return zlib.compress(data)",
            "",
            "",
            "def zlib_decompress(blob: bytes, decode: Optional[bool] = True) -> Union[bytes, str]:",
            "    \"\"\"",
            "    Decompress things to a string in a py2/3 safe fashion",
            "    >>> json_str = '{\"test\": 1}'",
            "    >>> blob = zlib_compress(json_str)",
            "    >>> got_str = zlib_decompress(blob)",
            "    >>> got_str == json_str",
            "    True",
            "    \"\"\"",
            "    if isinstance(blob, bytes):",
            "        decompressed = zlib.decompress(blob)",
            "    else:",
            "        decompressed = zlib.decompress(bytes(blob, \"utf-8\"))",
            "    return decompressed.decode(\"utf-8\") if decode else decompressed",
            "",
            "",
            "def simple_filter_to_adhoc(",
            "    filter_clause: QueryObjectFilterClause, clause: str = \"where\",",
            ") -> AdhocFilterClause:",
            "    result: AdhocFilterClause = {",
            "        \"clause\": clause.upper(),",
            "        \"expressionType\": \"SIMPLE\",",
            "        \"comparator\": filter_clause.get(\"val\"),",
            "        \"operator\": filter_clause[\"op\"],",
            "        \"subject\": filter_clause[\"col\"],",
            "    }",
            "    if filter_clause.get(\"isExtra\"):",
            "        result[\"isExtra\"] = True",
            "    result[\"filterOptionName\"] = md5_sha_from_dict(cast(Dict[Any, Any], result))",
            "",
            "    return result",
            "",
            "",
            "def form_data_to_adhoc(form_data: Dict[str, Any], clause: str) -> AdhocFilterClause:",
            "    if clause not in (\"where\", \"having\"):",
            "        raise ValueError(__(\"Unsupported clause type: %(clause)s\", clause=clause))",
            "    result: AdhocFilterClause = {",
            "        \"clause\": clause.upper(),",
            "        \"expressionType\": \"SQL\",",
            "        \"sqlExpression\": form_data.get(clause),",
            "    }",
            "    result[\"filterOptionName\"] = md5_sha_from_dict(cast(Dict[Any, Any], result))",
            "",
            "    return result",
            "",
            "",
            "def merge_extra_form_data(form_data: Dict[str, Any]) -> None:",
            "    \"\"\"",
            "    Merge extra form data (appends and overrides) into the main payload",
            "    and add applied time extras to the payload.",
            "    \"\"\"",
            "    filter_keys = [\"filters\", \"adhoc_filters\"]",
            "    extra_form_data = form_data.pop(\"extra_form_data\", {})",
            "    append_filters: List[QueryObjectFilterClause] = extra_form_data.get(\"filters\", None)",
            "",
            "    # merge append extras",
            "    for key in [key for key in EXTRA_FORM_DATA_APPEND_KEYS if key not in filter_keys]:",
            "        extra_value = getattr(extra_form_data, key, {})",
            "        form_value = getattr(form_data, key, {})",
            "        form_value.update(extra_value)",
            "        if form_value:",
            "            form_data[\"key\"] = extra_value",
            "",
            "    # map regular extras that apply to form data properties",
            "    for src_key, target_key in EXTRA_FORM_DATA_OVERRIDE_REGULAR_MAPPINGS.items():",
            "        value = extra_form_data.get(src_key)",
            "        if value is not None:",
            "            form_data[target_key] = value",
            "",
            "    # map extras that apply to form data extra properties",
            "    extras = form_data.get(\"extras\", {})",
            "    for key in EXTRA_FORM_DATA_OVERRIDE_EXTRA_KEYS:",
            "        value = extra_form_data.get(key)",
            "        if value is not None:",
            "            extras[key] = value",
            "    if extras:",
            "        form_data[\"extras\"] = extras",
            "",
            "    adhoc_filters: List[AdhocFilterClause] = form_data.get(\"adhoc_filters\", [])",
            "    form_data[\"adhoc_filters\"] = adhoc_filters",
            "    append_adhoc_filters: List[AdhocFilterClause] = extra_form_data.get(",
            "        \"adhoc_filters\", []",
            "    )",
            "    adhoc_filters.extend(",
            "        {\"isExtra\": True, **fltr} for fltr in append_adhoc_filters  # type: ignore",
            "    )",
            "    if append_filters:",
            "        adhoc_filters.extend(",
            "            simple_filter_to_adhoc({\"isExtra\": True, **fltr})  # type: ignore",
            "            for fltr in append_filters",
            "            if fltr",
            "        )",
            "",
            "",
            "def merge_extra_filters(form_data: Dict[str, Any]) -> None:",
            "    # extra_filters are temporary/contextual filters (using the legacy constructs)",
            "    # that are external to the slice definition. We use those for dynamic",
            "    # interactive filters like the ones emitted by the \"Filter Box\" visualization.",
            "    # Note extra_filters only support simple filters.",
            "    applied_time_extras: Dict[str, str] = {}",
            "    form_data[\"applied_time_extras\"] = applied_time_extras",
            "    adhoc_filters = form_data.get(\"adhoc_filters\", [])",
            "    form_data[\"adhoc_filters\"] = adhoc_filters",
            "    merge_extra_form_data(form_data)",
            "    if \"extra_filters\" in form_data:",
            "        # __form and __to are special extra_filters that target time",
            "        # boundaries. The rest of extra_filters are simple",
            "        # [column_name in list_of_values]. `__` prefix is there to avoid",
            "        # potential conflicts with column that would be named `from` or `to`",
            "        date_options = {",
            "            \"__time_range\": \"time_range\",",
            "            \"__time_col\": \"granularity_sqla\",",
            "            \"__time_grain\": \"time_grain_sqla\",",
            "            \"__time_origin\": \"druid_time_origin\",",
            "            \"__granularity\": \"granularity\",",
            "        }",
            "        # Grab list of existing filters 'keyed' on the column and operator",
            "",
            "        def get_filter_key(f: Dict[str, Any]) -> str:",
            "            if \"expressionType\" in f:",
            "                return \"{}__{}\".format(f[\"subject\"], f[\"operator\"])",
            "",
            "            return \"{}__{}\".format(f[\"col\"], f[\"op\"])",
            "",
            "        existing_filters = {}",
            "        for existing in adhoc_filters:",
            "            if (",
            "                existing[\"expressionType\"] == \"SIMPLE\"",
            "                and existing.get(\"comparator\") is not None",
            "                and existing.get(\"subject\") is not None",
            "            ):",
            "                existing_filters[get_filter_key(existing)] = existing[\"comparator\"]",
            "",
            "        for filtr in form_data[  # pylint: disable=too-many-nested-blocks",
            "            \"extra_filters\"",
            "        ]:",
            "            filtr[\"isExtra\"] = True",
            "            # Pull out time filters/options and merge into form data",
            "            filter_column = filtr[\"col\"]",
            "            time_extra = date_options.get(filter_column)",
            "            if time_extra:",
            "                time_extra_value = filtr.get(\"val\")",
            "                if time_extra_value and time_extra_value != NO_TIME_RANGE:",
            "                    form_data[time_extra] = time_extra_value",
            "                    applied_time_extras[filter_column] = time_extra_value",
            "            elif filtr[\"val\"]:",
            "                # Merge column filters",
            "                filter_key = get_filter_key(filtr)",
            "                if filter_key in existing_filters:",
            "                    # Check if the filter already exists",
            "                    if isinstance(filtr[\"val\"], list):",
            "                        if isinstance(existing_filters[filter_key], list):",
            "                            # Add filters for unequal lists",
            "                            # order doesn't matter",
            "                            if set(existing_filters[filter_key]) != set(filtr[\"val\"]):",
            "                                adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                        else:",
            "                            adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                    else:",
            "                        # Do not add filter if same value already exists",
            "                        if filtr[\"val\"] != existing_filters[filter_key]:",
            "                            adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                else:",
            "                    # Filter not found, add it",
            "                    adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "        # Remove extra filters from the form data since no longer needed",
            "        del form_data[\"extra_filters\"]",
            "",
            "",
            "def merge_request_params(form_data: Dict[str, Any], params: Dict[str, Any]) -> None:",
            "    \"\"\"",
            "    Merge request parameters to the key `url_params` in form_data. Only updates",
            "    or appends parameters to `form_data` that are defined in `params; pre-existing",
            "    parameters not defined in params are left unchanged.",
            "",
            "    :param form_data: object to be updated",
            "    :param params: request parameters received via query string",
            "    \"\"\"",
            "    url_params = form_data.get(\"url_params\", {})",
            "    for key, value in params.items():",
            "        if key in (\"form_data\", \"r\"):",
            "            continue",
            "        url_params[key] = value",
            "    form_data[\"url_params\"] = url_params",
            "",
            "",
            "def user_label(user: User) -> Optional[str]:",
            "    \"\"\"Given a user ORM FAB object, returns a label\"\"\"",
            "    if user:",
            "        if user.first_name and user.last_name:",
            "            return user.first_name + \" \" + user.last_name",
            "",
            "        return user.username",
            "",
            "    return None",
            "",
            "",
            "def get_or_create_db(",
            "    database_name: str, sqlalchemy_uri: str, always_create: Optional[bool] = True",
            ") -> \"Database\":",
            "    # pylint: disable=import-outside-toplevel",
            "    from superset import db",
            "    from superset.models import core as models",
            "",
            "    database = (",
            "        db.session.query(models.Database).filter_by(database_name=database_name).first()",
            "    )",
            "",
            "    # databases with a fixed UUID",
            "    uuids = {",
            "        \"examples\": EXAMPLES_DB_UUID,",
            "    }",
            "",
            "    if not database and always_create:",
            "        logger.info(\"Creating database reference for %s\", database_name)",
            "        database = models.Database(",
            "            database_name=database_name, uuid=uuids.get(database_name)",
            "        )",
            "        db.session.add(database)",
            "",
            "    if database:",
            "        database.set_sqlalchemy_uri(sqlalchemy_uri)",
            "        db.session.commit()",
            "",
            "    return database",
            "",
            "",
            "def get_example_database() -> \"Database\":",
            "    db_uri = (",
            "        current_app.config.get(\"SQLALCHEMY_EXAMPLES_URI\")",
            "        or current_app.config[\"SQLALCHEMY_DATABASE_URI\"]",
            "    )",
            "    return get_or_create_db(\"examples\", db_uri)",
            "",
            "",
            "def get_main_database() -> \"Database\":",
            "    db_uri = current_app.config[\"SQLALCHEMY_DATABASE_URI\"]",
            "    return get_or_create_db(\"main\", db_uri)",
            "",
            "",
            "def get_example_default_schema() -> Optional[str]:",
            "    \"\"\"",
            "    Return the default schema of the examples database, if any.",
            "    \"\"\"",
            "    database = get_example_database()",
            "    engine = database.get_sqla_engine()",
            "    return inspect(engine).default_schema_name",
            "",
            "",
            "def backend() -> str:",
            "    return get_example_database().backend",
            "",
            "",
            "def is_adhoc_metric(metric: Metric) -> TypeGuard[AdhocMetric]:",
            "    return isinstance(metric, dict) and \"expressionType\" in metric",
            "",
            "",
            "def get_metric_name(metric: Metric) -> str:",
            "    \"\"\"",
            "    Extract label from metric",
            "",
            "    :param metric: object to extract label from",
            "    :return: String representation of metric",
            "    :raises ValueError: if metric object is invalid",
            "    \"\"\"",
            "    if is_adhoc_metric(metric):",
            "        label = metric.get(\"label\")",
            "        if label:",
            "            return label",
            "        expression_type = metric.get(\"expressionType\")",
            "        if expression_type == \"SQL\":",
            "            sql_expression = metric.get(\"sqlExpression\")",
            "            if sql_expression:",
            "                return sql_expression",
            "        elif expression_type == \"SIMPLE\":",
            "            column: AdhocMetricColumn = metric.get(\"column\") or {}",
            "            column_name = column.get(\"column_name\")",
            "            aggregate = metric.get(\"aggregate\")",
            "            if column and aggregate:",
            "                return f\"{aggregate}({column_name})\"",
            "            if column_name:",
            "                return column_name",
            "        raise ValueError(__(\"Invalid metric object\"))",
            "    return metric  # type: ignore",
            "",
            "",
            "def get_metric_names(metrics: Sequence[Metric]) -> List[str]:",
            "    return [metric for metric in map(get_metric_name, metrics) if metric]",
            "",
            "",
            "def get_first_metric_name(metrics: Sequence[Metric]) -> Optional[str]:",
            "    metric_labels = get_metric_names(metrics)",
            "    return metric_labels[0] if metric_labels else None",
            "",
            "",
            "def ensure_path_exists(path: str) -> None:",
            "    try:",
            "        os.makedirs(path)",
            "    except OSError as ex:",
            "        if not (os.path.isdir(path) and ex.errno == errno.EEXIST):",
            "            raise",
            "",
            "",
            "def convert_legacy_filters_into_adhoc(  # pylint: disable=invalid-name",
            "    form_data: FormData,",
            ") -> None:",
            "    mapping = {\"having\": \"having_filters\", \"where\": \"filters\"}",
            "",
            "    if not form_data.get(\"adhoc_filters\"):",
            "        adhoc_filters: List[AdhocFilterClause] = []",
            "        form_data[\"adhoc_filters\"] = adhoc_filters",
            "",
            "        for clause, filters in mapping.items():",
            "            if clause in form_data and form_data[clause] != \"\":",
            "                adhoc_filters.append(form_data_to_adhoc(form_data, clause))",
            "",
            "            if filters in form_data:",
            "                for filt in filter(lambda x: x is not None, form_data[filters]):",
            "                    adhoc_filters.append(simple_filter_to_adhoc(filt, clause))",
            "",
            "    for key in (\"filters\", \"having\", \"having_filters\", \"where\"):",
            "        if key in form_data:",
            "            del form_data[key]",
            "",
            "",
            "def split_adhoc_filters_into_base_filters(  # pylint: disable=invalid-name",
            "    form_data: FormData,",
            ") -> None:",
            "    \"\"\"",
            "    Mutates form data to restructure the adhoc filters in the form of the four base",
            "    filters, `where`, `having`, `filters`, and `having_filters` which represent",
            "    free form where sql, free form having sql, structured where clauses and structured",
            "    having clauses.",
            "    \"\"\"",
            "    adhoc_filters = form_data.get(\"adhoc_filters\")",
            "    if isinstance(adhoc_filters, list):",
            "        simple_where_filters = []",
            "        simple_having_filters = []",
            "        sql_where_filters = []",
            "        sql_having_filters = []",
            "        for adhoc_filter in adhoc_filters:",
            "            expression_type = adhoc_filter.get(\"expressionType\")",
            "            clause = adhoc_filter.get(\"clause\")",
            "            if expression_type == \"SIMPLE\":",
            "                if clause == \"WHERE\":",
            "                    simple_where_filters.append(",
            "                        {",
            "                            \"col\": adhoc_filter.get(\"subject\"),",
            "                            \"op\": adhoc_filter.get(\"operator\"),",
            "                            \"val\": adhoc_filter.get(\"comparator\"),",
            "                        }",
            "                    )",
            "                elif clause == \"HAVING\":",
            "                    simple_having_filters.append(",
            "                        {",
            "                            \"col\": adhoc_filter.get(\"subject\"),",
            "                            \"op\": adhoc_filter.get(\"operator\"),",
            "                            \"val\": adhoc_filter.get(\"comparator\"),",
            "                        }",
            "                    )",
            "            elif expression_type == \"SQL\":",
            "                if clause == \"WHERE\":",
            "                    sql_where_filters.append(adhoc_filter.get(\"sqlExpression\"))",
            "                elif clause == \"HAVING\":",
            "                    sql_having_filters.append(adhoc_filter.get(\"sqlExpression\"))",
            "        form_data[\"where\"] = \" AND \".join(",
            "            [\"({})\".format(sql) for sql in sql_where_filters]",
            "        )",
            "        form_data[\"having\"] = \" AND \".join(",
            "            [\"({})\".format(sql) for sql in sql_having_filters]",
            "        )",
            "        form_data[\"having_filters\"] = simple_having_filters",
            "        form_data[\"filters\"] = simple_where_filters",
            "",
            "",
            "def get_username() -> Optional[str]:",
            "    \"\"\"Get username if within the flask context, otherwise return noffin'\"\"\"",
            "    try:",
            "        return g.user.username",
            "    except Exception:  # pylint: disable=broad-except",
            "        return None",
            "",
            "",
            "def parse_ssl_cert(certificate: str) -> _Certificate:",
            "    \"\"\"",
            "    Parses the contents of a certificate and returns a valid certificate object",
            "    if valid.",
            "",
            "    :param certificate: Contents of certificate file",
            "    :return: Valid certificate instance",
            "    :raises CertificateException: If certificate is not valid/unparseable",
            "    \"\"\"",
            "    try:",
            "        return x509.load_pem_x509_certificate(",
            "            certificate.encode(\"utf-8\"), default_backend()",
            "        )",
            "    except ValueError as ex:",
            "        raise CertificateException(\"Invalid certificate\") from ex",
            "",
            "",
            "def create_ssl_cert_file(certificate: str) -> str:",
            "    \"\"\"",
            "    This creates a certificate file that can be used to validate HTTPS",
            "    sessions. A certificate is only written to disk once; on subsequent calls,",
            "    only the path of the existing certificate is returned.",
            "",
            "    :param certificate: The contents of the certificate",
            "    :return: The path to the certificate file",
            "    :raises CertificateException: If certificate is not valid/unparseable",
            "    \"\"\"",
            "    filename = f\"{md5_sha_from_str(certificate)}.crt\"",
            "    cert_dir = current_app.config[\"SSL_CERT_PATH\"]",
            "    path = cert_dir if cert_dir else tempfile.gettempdir()",
            "    path = os.path.join(path, filename)",
            "    if not os.path.exists(path):",
            "        # Validate certificate prior to persisting to temporary directory",
            "        parse_ssl_cert(certificate)",
            "        with open(path, \"w\") as cert_file:",
            "            cert_file.write(certificate)",
            "    return path",
            "",
            "",
            "def time_function(",
            "    func: Callable[..., FlaskResponse], *args: Any, **kwargs: Any",
            ") -> Tuple[float, Any]:",
            "    \"\"\"",
            "    Measures the amount of time a function takes to execute in ms",
            "",
            "    :param func: The function execution time to measure",
            "    :param args: args to be passed to the function",
            "    :param kwargs: kwargs to be passed to the function",
            "    :return: A tuple with the duration and response from the function",
            "    \"\"\"",
            "    start = default_timer()",
            "    response = func(*args, **kwargs)",
            "    stop = default_timer()",
            "    return (stop - start) * 1000.0, response",
            "",
            "",
            "def MediumText() -> Variant:  # pylint:disable=invalid-name",
            "    return Text().with_variant(MEDIUMTEXT(), \"mysql\")",
            "",
            "",
            "def shortid() -> str:",
            "    return \"{}\".format(uuid.uuid4())[-12:]",
            "",
            "",
            "class DatasourceName(NamedTuple):",
            "    table: str",
            "    schema: str",
            "",
            "",
            "def get_stacktrace() -> Optional[str]:",
            "    if current_app.config[\"SHOW_STACKTRACE\"]:",
            "        return traceback.format_exc()",
            "    return None",
            "",
            "",
            "def split(",
            "    string: str, delimiter: str = \" \", quote: str = '\"', escaped_quote: str = r\"\\\"\"",
            ") -> Iterator[str]:",
            "    \"\"\"",
            "    A split function that is aware of quotes and parentheses.",
            "",
            "    :param string: string to split",
            "    :param delimiter: string defining where to split, usually a comma or space",
            "    :param quote: string, either a single or a double quote",
            "    :param escaped_quote: string representing an escaped quote",
            "    :return: list of strings",
            "    \"\"\"",
            "    parens = 0",
            "    quotes = False",
            "    i = 0",
            "    for j, character in enumerate(string):",
            "        complete = parens == 0 and not quotes",
            "        if complete and character == delimiter:",
            "            yield string[i:j]",
            "            i = j + len(delimiter)",
            "        elif character == \"(\":",
            "            parens += 1",
            "        elif character == \")\":",
            "            parens -= 1",
            "        elif character == quote:",
            "            if quotes and string[j - len(escaped_quote) + 1 : j + 1] != escaped_quote:",
            "                quotes = False",
            "            elif not quotes:",
            "                quotes = True",
            "    yield string[i:]",
            "",
            "",
            "def get_iterable(x: Any) -> List[Any]:",
            "    \"\"\"",
            "    Get an iterable (list) representation of the object.",
            "",
            "    :param x: The object",
            "    :returns: An iterable representation",
            "    \"\"\"",
            "    return x if isinstance(x, list) else [x]",
            "",
            "",
            "def get_form_data_token(form_data: Dict[str, Any]) -> str:",
            "    \"\"\"",
            "    Return the token contained within form data or generate a new one.",
            "",
            "    :param form_data: chart form data",
            "    :return: original token if predefined, otherwise new uuid4 based token",
            "    \"\"\"",
            "    return form_data.get(\"token\") or \"token_\" + uuid.uuid4().hex[:8]",
            "",
            "",
            "def get_column_name_from_metric(metric: Metric) -> Optional[str]:",
            "    \"\"\"",
            "    Extract the column that a metric is referencing. If the metric isn't",
            "    a simple metric, always returns `None`.",
            "",
            "    :param metric: Ad-hoc metric",
            "    :return: column name if simple metric, otherwise None",
            "    \"\"\"",
            "    if is_adhoc_metric(metric):",
            "        metric = cast(AdhocMetric, metric)",
            "        if metric[\"expressionType\"] == AdhocMetricExpressionType.SIMPLE:",
            "            return cast(Dict[str, Any], metric[\"column\"])[\"column_name\"]",
            "    return None",
            "",
            "",
            "def get_column_names_from_metrics(metrics: List[Metric]) -> List[str]:",
            "    \"\"\"",
            "    Extract the columns that a list of metrics are referencing. Expcludes all",
            "    SQL metrics.",
            "",
            "    :param metrics: Ad-hoc metric",
            "    :return: column name if simple metric, otherwise None",
            "    \"\"\"",
            "    return [col for col in map(get_column_name_from_metric, metrics) if col]",
            "",
            "",
            "def extract_dataframe_dtypes(df: pd.DataFrame) -> List[GenericDataType]:",
            "    \"\"\"Serialize pandas/numpy dtypes to generic types\"\"\"",
            "",
            "    # omitting string types as those will be the default type",
            "    inferred_type_map: Dict[str, GenericDataType] = {",
            "        \"floating\": GenericDataType.NUMERIC,",
            "        \"integer\": GenericDataType.NUMERIC,",
            "        \"mixed-integer-float\": GenericDataType.NUMERIC,",
            "        \"decimal\": GenericDataType.NUMERIC,",
            "        \"boolean\": GenericDataType.BOOLEAN,",
            "        \"datetime64\": GenericDataType.TEMPORAL,",
            "        \"datetime\": GenericDataType.TEMPORAL,",
            "        \"date\": GenericDataType.TEMPORAL,",
            "    }",
            "",
            "    generic_types: List[GenericDataType] = []",
            "    for column in df.columns:",
            "        series = df[column]",
            "        inferred_type = infer_dtype(series)",
            "        generic_type = inferred_type_map.get(inferred_type, GenericDataType.STRING)",
            "        generic_types.append(generic_type)",
            "",
            "    return generic_types",
            "",
            "",
            "def extract_column_dtype(col: \"BaseColumn\") -> GenericDataType:",
            "    if col.is_temporal:",
            "        return GenericDataType.TEMPORAL",
            "    if col.is_numeric:",
            "        return GenericDataType.NUMERIC",
            "    # TODO: add check for boolean data type when proper support is added",
            "    return GenericDataType.STRING",
            "",
            "",
            "def indexed(",
            "    items: List[Any], key: Union[str, Callable[[Any], Any]]",
            ") -> Dict[Any, List[Any]]:",
            "    \"\"\"Build an index for a list of objects\"\"\"",
            "    idx: Dict[Any, Any] = {}",
            "    for item in items:",
            "        key_ = getattr(item, key) if isinstance(key, str) else key(item)",
            "        idx.setdefault(key_, []).append(item)",
            "    return idx",
            "",
            "",
            "def is_test() -> bool:",
            "    return strtobool(os.environ.get(\"SUPERSET_TESTENV\", \"false\"))",
            "",
            "",
            "def get_time_filter_status(",
            "    datasource: \"BaseDatasource\", applied_time_extras: Dict[str, str],",
            ") -> Tuple[List[Dict[str, str]], List[Dict[str, str]]]:",
            "    temporal_columns = {col.column_name for col in datasource.columns if col.is_dttm}",
            "    applied: List[Dict[str, str]] = []",
            "    rejected: List[Dict[str, str]] = []",
            "    time_column = applied_time_extras.get(ExtraFiltersTimeColumnType.TIME_COL)",
            "    if time_column:",
            "        if time_column in temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_COL})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.COL_NOT_IN_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_COL,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.TIME_GRAIN in applied_time_extras:",
            "        # are there any temporal columns to assign the time grain to?",
            "        if temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_GRAIN})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NO_TEMPORAL_COLUMN,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_GRAIN,",
            "                }",
            "            )",
            "",
            "    time_range = applied_time_extras.get(ExtraFiltersTimeColumnType.TIME_RANGE)",
            "    if time_range:",
            "        # are there any temporal columns to assign the time grain to?",
            "        if temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_RANGE})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NO_TEMPORAL_COLUMN,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_RANGE,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.TIME_ORIGIN in applied_time_extras:",
            "        if datasource.type == \"druid\":",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_ORIGIN})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NOT_DRUID_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_ORIGIN,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.GRANULARITY in applied_time_extras:",
            "        if datasource.type == \"druid\":",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.GRANULARITY})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NOT_DRUID_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.GRANULARITY,",
            "                }",
            "            )",
            "",
            "    return applied, rejected",
            "",
            "",
            "def format_list(items: Sequence[str], sep: str = \", \", quote: str = '\"') -> str:",
            "    quote_escaped = \"\\\\\" + quote",
            "    return sep.join(f\"{quote}{x.replace(quote, quote_escaped)}{quote}\" for x in items)",
            "",
            "",
            "def find_duplicates(items: Iterable[InputType]) -> List[InputType]:",
            "    \"\"\"Find duplicate items in an iterable.\"\"\"",
            "    return [item for item, count in collections.Counter(items).items() if count > 1]",
            "",
            "",
            "def remove_duplicates(",
            "    items: Iterable[InputType], key: Optional[Callable[[InputType], Any]] = None",
            ") -> List[InputType]:",
            "    \"\"\"Remove duplicate items in an iterable.\"\"\"",
            "    if not key:",
            "        return list(dict.fromkeys(items).keys())",
            "    seen = set()",
            "    result = []",
            "    for item in items:",
            "        item_key = key(item)",
            "        if item_key not in seen:",
            "            seen.add(item_key)",
            "            result.append(item)",
            "    return result",
            "",
            "",
            "def normalize_dttm_col(",
            "    df: pd.DataFrame,",
            "    timestamp_format: Optional[str],",
            "    offset: int,",
            "    time_shift: Optional[timedelta],",
            ") -> None:",
            "    if DTTM_ALIAS not in df.columns:",
            "        return",
            "    if timestamp_format in (\"epoch_s\", \"epoch_ms\"):",
            "        dttm_col = df[DTTM_ALIAS]",
            "        if is_numeric_dtype(dttm_col):",
            "            # Column is formatted as a numeric value",
            "            unit = timestamp_format.replace(\"epoch_\", \"\")",
            "            df[DTTM_ALIAS] = pd.to_datetime(",
            "                dttm_col, utc=False, unit=unit, origin=\"unix\"",
            "            )",
            "        else:",
            "            # Column has already been formatted as a timestamp.",
            "            df[DTTM_ALIAS] = dttm_col.apply(pd.Timestamp)",
            "    else:",
            "        df[DTTM_ALIAS] = pd.to_datetime(",
            "            df[DTTM_ALIAS], utc=False, format=timestamp_format",
            "        )",
            "    if offset:",
            "        df[DTTM_ALIAS] += timedelta(hours=offset)",
            "    if time_shift is not None:",
            "        df[DTTM_ALIAS] += time_shift",
            "",
            "",
            "def parse_boolean_string(bool_str: Optional[str]) -> bool:",
            "    \"\"\"",
            "    Convert a string representation of a true/false value into a boolean",
            "",
            "    >>> parse_boolean_string(None)",
            "    False",
            "    >>> parse_boolean_string('false')",
            "    False",
            "    >>> parse_boolean_string('true')",
            "    True",
            "    >>> parse_boolean_string('False')",
            "    False",
            "    >>> parse_boolean_string('True')",
            "    True",
            "    >>> parse_boolean_string('foo')",
            "    False",
            "    >>> parse_boolean_string('0')",
            "    False",
            "    >>> parse_boolean_string('1')",
            "    True",
            "",
            "    :param bool_str: string representation of a value that is assumed to be boolean",
            "    :return: parsed boolean value",
            "    \"\"\"",
            "    if bool_str is None:",
            "        return False",
            "    try:",
            "        return bool(strtobool(bool_str.lower()))",
            "    except ValueError:",
            "        return False",
            "",
            "",
            "def apply_max_row_limit(limit: int, max_limit: Optional[int] = None,) -> int:",
            "    \"\"\"",
            "    Override row limit if max global limit is defined",
            "",
            "    :param limit: requested row limit",
            "    :param max_limit: Maximum allowed row limit",
            "    :return: Capped row limit",
            "",
            "    >>> apply_max_row_limit(100000, 10)",
            "    10",
            "    >>> apply_max_row_limit(10, 100000)",
            "    10",
            "    >>> apply_max_row_limit(0, 10000)",
            "    10000",
            "    \"\"\"",
            "    if max_limit is None:",
            "        max_limit = current_app.config[\"SQL_MAX_ROW\"]",
            "    if limit != 0:",
            "        return min(max_limit, limit)",
            "    return max_limit"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"Utility functions used across Superset\"\"\"",
            "# pylint: disable=too-many-lines",
            "import collections",
            "import decimal",
            "import errno",
            "import json",
            "import logging",
            "import os",
            "import platform",
            "import re",
            "import signal",
            "import smtplib",
            "import tempfile",
            "import threading",
            "import traceback",
            "import uuid",
            "import zlib",
            "from datetime import date, datetime, time, timedelta",
            "from distutils.util import strtobool",
            "from email.mime.application import MIMEApplication",
            "from email.mime.image import MIMEImage",
            "from email.mime.multipart import MIMEMultipart",
            "from email.mime.text import MIMEText",
            "from email.utils import formatdate",
            "from enum import Enum, IntEnum",
            "from timeit import default_timer",
            "from types import TracebackType",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    cast,",
            "    Dict,",
            "    Iterable,",
            "    Iterator,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Sequence,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TYPE_CHECKING,",
            "    TypeVar,",
            "    Union,",
            ")",
            "from urllib.parse import unquote_plus",
            "",
            "import bleach",
            "import markdown as md",
            "import numpy as np",
            "import pandas as pd",
            "import sqlalchemy as sa",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.backends.openssl.x509 import _Certificate",
            "from flask import current_app, flash, g, Markup, render_template, request",
            "from flask_appbuilder import SQLA",
            "from flask_appbuilder.security.sqla.models import Role, User",
            "from flask_babel import gettext as __",
            "from flask_babel.speaklater import LazyString",
            "from pandas.api.types import infer_dtype",
            "from pandas.core.dtypes.common import is_numeric_dtype",
            "from sqlalchemy import event, exc, inspect, select, Text",
            "from sqlalchemy.dialects.mysql import MEDIUMTEXT",
            "from sqlalchemy.engine import Connection, Engine",
            "from sqlalchemy.engine.reflection import Inspector",
            "from sqlalchemy.sql.type_api import Variant",
            "from sqlalchemy.types import TEXT, TypeDecorator, TypeEngine",
            "from typing_extensions import TypedDict, TypeGuard",
            "",
            "import _thread  # pylint: disable=C0411",
            "from superset.constants import (",
            "    EXAMPLES_DB_UUID,",
            "    EXTRA_FORM_DATA_APPEND_KEYS,",
            "    EXTRA_FORM_DATA_OVERRIDE_EXTRA_KEYS,",
            "    EXTRA_FORM_DATA_OVERRIDE_REGULAR_MAPPINGS,",
            ")",
            "from superset.errors import ErrorLevel, SupersetErrorType",
            "from superset.exceptions import (",
            "    CertificateException,",
            "    SupersetException,",
            "    SupersetTimeoutException,",
            ")",
            "from superset.sql_parse import sanitize_clause",
            "from superset.typing import (",
            "    AdhocMetric,",
            "    AdhocMetricColumn,",
            "    FilterValues,",
            "    FlaskResponse,",
            "    FormData,",
            "    Metric,",
            ")",
            "from superset.utils.dates import datetime_to_epoch, EPOCH",
            "from superset.utils.hashing import md5_sha_from_dict, md5_sha_from_str",
            "",
            "try:",
            "    from pydruid.utils.having import Having",
            "except ImportError:",
            "    pass",
            "",
            "if TYPE_CHECKING:",
            "    from superset.connectors.base.models import BaseColumn, BaseDatasource",
            "    from superset.models.core import Database",
            "",
            "",
            "logging.getLogger(\"MARKDOWN\").setLevel(logging.INFO)",
            "logger = logging.getLogger(__name__)",
            "",
            "DTTM_ALIAS = \"__timestamp\"",
            "",
            "NO_TIME_RANGE = \"No filter\"",
            "",
            "TIME_COMPARISION = \"__\"",
            "",
            "JS_MAX_INTEGER = 9007199254740991  # Largest int Java Script can handle 2^53-1",
            "",
            "InputType = TypeVar(\"InputType\")",
            "",
            "",
            "class LenientEnum(Enum):",
            "    \"\"\"Enums with a `get` method that convert a enum value to `Enum` if it is a",
            "    valid value.\"\"\"",
            "",
            "    @classmethod",
            "    def get(cls, value: Any) -> Any:",
            "        try:",
            "            return super().__new__(cls, value)",
            "        except ValueError:",
            "            return None",
            "",
            "",
            "class AdhocMetricExpressionType(str, Enum):",
            "    SIMPLE = \"SIMPLE\"",
            "    SQL = \"SQL\"",
            "",
            "",
            "class AnnotationType(str, Enum):",
            "    FORMULA = \"FORMULA\"",
            "    INTERVAL = \"INTERVAL\"",
            "    EVENT = \"EVENT\"",
            "    TIME_SERIES = \"TIME_SERIES\"",
            "",
            "",
            "class GenericDataType(IntEnum):",
            "    \"\"\"",
            "    Generic database column type that fits both frontend and backend.",
            "    \"\"\"",
            "",
            "    NUMERIC = 0",
            "    STRING = 1",
            "    TEMPORAL = 2",
            "    BOOLEAN = 3",
            "    # ARRAY = 4     # Mapping all the complex data types to STRING for now",
            "    # JSON = 5      # and leaving these as a reminder.",
            "    # MAP = 6",
            "    # ROW = 7",
            "",
            "",
            "class ChartDataResultFormat(str, Enum):",
            "    \"\"\"",
            "    Chart data response format",
            "    \"\"\"",
            "",
            "    CSV = \"csv\"",
            "    JSON = \"json\"",
            "",
            "",
            "class ChartDataResultType(str, Enum):",
            "    \"\"\"",
            "    Chart data response type",
            "    \"\"\"",
            "",
            "    COLUMNS = \"columns\"",
            "    FULL = \"full\"",
            "    QUERY = \"query\"",
            "    RESULTS = \"results\"",
            "    SAMPLES = \"samples\"",
            "    TIMEGRAINS = \"timegrains\"",
            "    POST_PROCESSED = \"post_processed\"",
            "",
            "",
            "class DatasourceDict(TypedDict):",
            "    type: str",
            "    id: int",
            "",
            "",
            "class AdhocFilterClause(TypedDict, total=False):",
            "    clause: str",
            "    expressionType: str",
            "    filterOptionName: Optional[str]",
            "    comparator: Optional[FilterValues]",
            "    operator: str",
            "    subject: str",
            "    isExtra: Optional[bool]",
            "    sqlExpression: Optional[str]",
            "",
            "",
            "class QueryObjectFilterClause(TypedDict, total=False):",
            "    col: str",
            "    op: str  # pylint: disable=invalid-name",
            "    val: Optional[FilterValues]",
            "    grain: Optional[str]",
            "    isExtra: Optional[bool]",
            "",
            "",
            "class ExtraFiltersTimeColumnType(str, Enum):",
            "    GRANULARITY = \"__granularity\"",
            "    TIME_COL = \"__time_col\"",
            "    TIME_GRAIN = \"__time_grain\"",
            "    TIME_ORIGIN = \"__time_origin\"",
            "    TIME_RANGE = \"__time_range\"",
            "",
            "",
            "class ExtraFiltersReasonType(str, Enum):",
            "    NO_TEMPORAL_COLUMN = \"no_temporal_column\"",
            "    COL_NOT_IN_DATASOURCE = \"not_in_datasource\"",
            "    NOT_DRUID_DATASOURCE = \"not_druid_datasource\"",
            "",
            "",
            "class FilterOperator(str, Enum):",
            "    \"\"\"",
            "    Operators used filter controls",
            "    \"\"\"",
            "",
            "    EQUALS = \"==\"",
            "    NOT_EQUALS = \"!=\"",
            "    GREATER_THAN = \">\"",
            "    LESS_THAN = \"<\"",
            "    GREATER_THAN_OR_EQUALS = \">=\"",
            "    LESS_THAN_OR_EQUALS = \"<=\"",
            "    LIKE = \"LIKE\"",
            "    ILIKE = \"ILIKE\"",
            "    IS_NULL = \"IS NULL\"",
            "    IS_NOT_NULL = \"IS NOT NULL\"",
            "    IN = \"IN\"",
            "    NOT_IN = \"NOT IN\"",
            "    REGEX = \"REGEX\"",
            "    IS_TRUE = \"IS TRUE\"",
            "    IS_FALSE = \"IS FALSE\"",
            "",
            "",
            "class PostProcessingBoxplotWhiskerType(str, Enum):",
            "    \"\"\"",
            "    Calculate cell contribution to row/column total",
            "    \"\"\"",
            "",
            "    TUKEY = \"tukey\"",
            "    MINMAX = \"min/max\"",
            "    PERCENTILE = \"percentile\"",
            "",
            "",
            "class PostProcessingContributionOrientation(str, Enum):",
            "    \"\"\"",
            "    Calculate cell contribution to row/column total",
            "    \"\"\"",
            "",
            "    ROW = \"row\"",
            "    COLUMN = \"column\"",
            "",
            "",
            "class QueryMode(str, LenientEnum):",
            "    \"\"\"",
            "    Whether the query runs on aggregate or returns raw records",
            "    \"\"\"",
            "",
            "    RAW = \"raw\"",
            "    AGGREGATE = \"aggregate\"",
            "",
            "",
            "class QuerySource(Enum):",
            "    \"\"\"",
            "    The source of a SQL query.",
            "    \"\"\"",
            "",
            "    CHART = 0",
            "    DASHBOARD = 1",
            "    SQL_LAB = 2",
            "",
            "",
            "class QueryStatus(str, Enum):",
            "    \"\"\"Enum-type class for query statuses\"\"\"",
            "",
            "    STOPPED: str = \"stopped\"",
            "    FAILED: str = \"failed\"",
            "    PENDING: str = \"pending\"",
            "    RUNNING: str = \"running\"",
            "    SCHEDULED: str = \"scheduled\"",
            "    SUCCESS: str = \"success\"",
            "    FETCHING: str = \"fetching\"",
            "    TIMED_OUT: str = \"timed_out\"",
            "",
            "",
            "class DashboardStatus(str, Enum):",
            "    \"\"\"Dashboard status used for frontend filters\"\"\"",
            "",
            "    PUBLISHED = \"published\"",
            "    DRAFT = \"draft\"",
            "",
            "",
            "class ReservedUrlParameters(str, Enum):",
            "    \"\"\"",
            "    Reserved URL parameters that are used internally by Superset. These will not be",
            "    passed to chart queries, as they control the behavior of the UI.",
            "    \"\"\"",
            "",
            "    STANDALONE = \"standalone\"",
            "    EDIT_MODE = \"edit\"",
            "",
            "    @staticmethod",
            "    def is_standalone_mode() -> Optional[bool]:",
            "        standalone_param = request.args.get(ReservedUrlParameters.STANDALONE.value)",
            "        standalone: Optional[bool] = (",
            "            standalone_param and standalone_param != \"false\" and standalone_param != \"0\"",
            "        )",
            "        return standalone",
            "",
            "",
            "class RowLevelSecurityFilterType(str, Enum):",
            "    REGULAR = \"Regular\"",
            "    BASE = \"Base\"",
            "",
            "",
            "class TimeRangeEndpoint(str, Enum):",
            "    \"\"\"",
            "    The time range endpoint types which represent inclusive, exclusive, or unknown.",
            "",
            "    Unknown represents endpoints which are ill-defined as though the interval may be",
            "    [start, end] the filter may behave like (start, end] due to mixed data types and",
            "    lexicographical ordering.",
            "",
            "    :see: https://github.com/apache/superset/issues/6360",
            "    \"\"\"",
            "",
            "    EXCLUSIVE = \"exclusive\"",
            "    INCLUSIVE = \"inclusive\"",
            "    UNKNOWN = \"unknown\"",
            "",
            "",
            "class TemporalType(str, Enum):",
            "    \"\"\"",
            "    Supported temporal types",
            "    \"\"\"",
            "",
            "    DATE = \"DATE\"",
            "    DATETIME = \"DATETIME\"",
            "    SMALLDATETIME = \"SMALLDATETIME\"",
            "    TEXT = \"TEXT\"",
            "    TIME = \"TIME\"",
            "    TIMESTAMP = \"TIMESTAMP\"",
            "",
            "",
            "class ColumnTypeSource(Enum):",
            "    GET_TABLE = 1",
            "    CURSOR_DESCRIPION = 2",
            "",
            "",
            "class ColumnSpec(NamedTuple):",
            "    sqla_type: Union[TypeEngine, str]",
            "    generic_type: GenericDataType",
            "    is_dttm: bool",
            "    python_date_format: Optional[str] = None",
            "",
            "",
            "try:",
            "    # Having might not have been imported.",
            "    class DimSelector(Having):",
            "        def __init__(self, **args: Any) -> None:",
            "            # Just a hack to prevent any exceptions",
            "            Having.__init__(self, type=\"equalTo\", aggregation=None, value=None)",
            "",
            "            self.having = {",
            "                \"having\": {",
            "                    \"type\": \"dimSelector\",",
            "                    \"dimension\": args[\"dimension\"],",
            "                    \"value\": args[\"value\"],",
            "                }",
            "            }",
            "",
            "",
            "except NameError:",
            "    pass",
            "",
            "",
            "def flasher(msg: str, severity: str = \"message\") -> None:",
            "    \"\"\"Flask's flash if available, logging call if not\"\"\"",
            "    try:",
            "        flash(msg, severity)",
            "    except RuntimeError:",
            "        if severity == \"danger\":",
            "            logger.error(msg, exc_info=True)",
            "        else:",
            "            logger.info(msg)",
            "",
            "",
            "def parse_js_uri_path_item(",
            "    item: Optional[str], unquote: bool = True, eval_undefined: bool = False",
            ") -> Optional[str]:",
            "    \"\"\"Parse a uri path item made with js.",
            "",
            "    :param item: a uri path component",
            "    :param unquote: Perform unquoting of string using urllib.parse.unquote_plus()",
            "    :param eval_undefined: When set to True and item is either 'null'  or 'undefined',",
            "    assume item is undefined and return None.",
            "    :return: Either None, the original item or unquoted item",
            "    \"\"\"",
            "    item = None if eval_undefined and item in (\"null\", \"undefined\") else item",
            "    return unquote_plus(item) if unquote and item else item",
            "",
            "",
            "def cast_to_num(value: Optional[Union[float, int, str]]) -> Optional[Union[float, int]]:",
            "    \"\"\"Casts a value to an int/float",
            "",
            "    >>> cast_to_num('1 ')",
            "    1.0",
            "    >>> cast_to_num(' 2')",
            "    2.0",
            "    >>> cast_to_num('5')",
            "    5",
            "    >>> cast_to_num('5.2')",
            "    5.2",
            "    >>> cast_to_num(10)",
            "    10",
            "    >>> cast_to_num(10.1)",
            "    10.1",
            "    >>> cast_to_num(None) is None",
            "    True",
            "    >>> cast_to_num('this is not a string') is None",
            "    True",
            "",
            "    :param value: value to be converted to numeric representation",
            "    :returns: value cast to `int` if value is all digits, `float` if `value` is",
            "              decimal value and `None`` if it can't be converted",
            "    \"\"\"",
            "    if value is None:",
            "        return None",
            "    if isinstance(value, (int, float)):",
            "        return value",
            "    if value.isdigit():",
            "        return int(value)",
            "    try:",
            "        return float(value)",
            "    except ValueError:",
            "        return None",
            "",
            "",
            "def cast_to_boolean(value: Any) -> Optional[bool]:",
            "    \"\"\"Casts a value to an int/float",
            "",
            "    >>> cast_to_boolean(1)",
            "    True",
            "    >>> cast_to_boolean(0)",
            "    False",
            "    >>> cast_to_boolean(0.5)",
            "    True",
            "    >>> cast_to_boolean('true')",
            "    True",
            "    >>> cast_to_boolean('false')",
            "    False",
            "    >>> cast_to_boolean('False')",
            "    False",
            "    >>> cast_to_boolean(None)",
            "",
            "    :param value: value to be converted to boolean representation",
            "    :returns: value cast to `bool`. when value is 'true' or value that are not 0",
            "              converted into True. Return `None` if value is `None`",
            "    \"\"\"",
            "    if value is None:",
            "        return None",
            "    if isinstance(value, (int, float)):",
            "        return value != 0",
            "    if isinstance(value, str):",
            "        return value.strip().lower() == \"true\"",
            "    return False",
            "",
            "",
            "def list_minus(l: List[Any], minus: List[Any]) -> List[Any]:",
            "    \"\"\"Returns l without what is in minus",
            "",
            "    >>> list_minus([1, 2, 3], [2])",
            "    [1, 3]",
            "    \"\"\"",
            "    return [o for o in l if o not in minus]",
            "",
            "",
            "class DashboardEncoder(json.JSONEncoder):",
            "    def __init__(self, *args: Any, **kwargs: Any) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.sort_keys = True",
            "",
            "    def default(self, o: Any) -> Union[Dict[Any, Any], str]:",
            "        if isinstance(o, uuid.UUID):",
            "            return str(o)",
            "        try:",
            "            vals = {k: v for k, v in o.__dict__.items() if k != \"_sa_instance_state\"}",
            "            return {\"__{}__\".format(o.__class__.__name__): vals}",
            "        except Exception:  # pylint: disable=broad-except",
            "            if isinstance(o, datetime):",
            "                return {\"__datetime__\": o.replace(microsecond=0).isoformat()}",
            "            return json.JSONEncoder(sort_keys=True).default(o)",
            "",
            "",
            "class JSONEncodedDict(TypeDecorator):  # pylint: disable=abstract-method",
            "    \"\"\"Represents an immutable structure as a json-encoded string.\"\"\"",
            "",
            "    impl = TEXT",
            "",
            "    def process_bind_param(",
            "        self, value: Optional[Dict[Any, Any]], dialect: str",
            "    ) -> Optional[str]:",
            "        return json.dumps(value) if value is not None else None",
            "",
            "    def process_result_value(",
            "        self, value: Optional[str], dialect: str",
            "    ) -> Optional[Dict[Any, Any]]:",
            "        return json.loads(value) if value is not None else None",
            "",
            "",
            "def format_timedelta(time_delta: timedelta) -> str:",
            "    \"\"\"",
            "    Ensures negative time deltas are easily interpreted by humans",
            "",
            "    >>> td = timedelta(0) - timedelta(days=1, hours=5,minutes=6)",
            "    >>> str(td)",
            "    '-2 days, 18:54:00'",
            "    >>> format_timedelta(td)",
            "    '-1 day, 5:06:00'",
            "    \"\"\"",
            "    if time_delta < timedelta(0):",
            "        return \"-\" + str(abs(time_delta))",
            "",
            "    # Change this to format positive time deltas the way you want",
            "    return str(time_delta)",
            "",
            "",
            "def base_json_conv(obj: Any,) -> Any:  # pylint: disable=inconsistent-return-statements",
            "    if isinstance(obj, memoryview):",
            "        obj = obj.tobytes()",
            "    if isinstance(obj, np.int64):",
            "        return int(obj)",
            "    if isinstance(obj, np.bool_):",
            "        return bool(obj)",
            "    if isinstance(obj, np.ndarray):",
            "        return obj.tolist()",
            "    if isinstance(obj, set):",
            "        return list(obj)",
            "    if isinstance(obj, decimal.Decimal):",
            "        return float(obj)",
            "    if isinstance(obj, (uuid.UUID, time, LazyString)):",
            "        return str(obj)",
            "    if isinstance(obj, timedelta):",
            "        return format_timedelta(obj)",
            "    if isinstance(obj, bytes):",
            "        try:",
            "            return obj.decode(\"utf-8\")",
            "        except Exception:  # pylint: disable=broad-except",
            "            return \"[bytes]\"",
            "",
            "",
            "def json_iso_dttm_ser(obj: Any, pessimistic: bool = False) -> str:",
            "    \"\"\"",
            "    json serializer that deals with dates",
            "",
            "    >>> dttm = datetime(1970, 1, 1)",
            "    >>> json.dumps({'dttm': dttm}, default=json_iso_dttm_ser)",
            "    '{\"dttm\": \"1970-01-01T00:00:00\"}'",
            "    \"\"\"",
            "    val = base_json_conv(obj)",
            "    if val is not None:",
            "        return val",
            "    if isinstance(obj, (datetime, date, pd.Timestamp)):",
            "        obj = obj.isoformat()",
            "    else:",
            "        if pessimistic:",
            "            return \"Unserializable [{}]\".format(type(obj))",
            "",
            "        raise TypeError(\"Unserializable object {} of type {}\".format(obj, type(obj)))",
            "    return obj",
            "",
            "",
            "def pessimistic_json_iso_dttm_ser(obj: Any) -> str:",
            "    \"\"\"Proxy to call json_iso_dttm_ser in a pessimistic way",
            "",
            "    If one of object is not serializable to json, it will still succeed\"\"\"",
            "    return json_iso_dttm_ser(obj, pessimistic=True)",
            "",
            "",
            "def json_int_dttm_ser(obj: Any) -> float:",
            "    \"\"\"json serializer that deals with dates\"\"\"",
            "    val = base_json_conv(obj)",
            "    if val is not None:",
            "        return val",
            "    if isinstance(obj, (datetime, pd.Timestamp)):",
            "        obj = datetime_to_epoch(obj)",
            "    elif isinstance(obj, date):",
            "        obj = (obj - EPOCH.date()).total_seconds() * 1000",
            "    else:",
            "        raise TypeError(\"Unserializable object {} of type {}\".format(obj, type(obj)))",
            "    return obj",
            "",
            "",
            "def json_dumps_w_dates(payload: Dict[Any, Any]) -> str:",
            "    return json.dumps(payload, default=json_int_dttm_ser)",
            "",
            "",
            "def error_msg_from_exception(ex: Exception) -> str:",
            "    \"\"\"Translate exception into error message",
            "",
            "    Database have different ways to handle exception. This function attempts",
            "    to make sense of the exception object and construct a human readable",
            "    sentence.",
            "",
            "    TODO(bkyryliuk): parse the Presto error message from the connection",
            "                     created via create_engine.",
            "    engine = create_engine('presto://localhost:3506/silver') -",
            "      gives an e.message as the str(dict)",
            "    presto.connect('localhost', port=3506, catalog='silver') - as a dict.",
            "    The latter version is parsed correctly by this function.",
            "    \"\"\"",
            "    msg = \"\"",
            "    if hasattr(ex, \"message\"):",
            "        if isinstance(ex.message, dict):  # type: ignore",
            "            msg = ex.message.get(\"message\")  # type: ignore",
            "        elif ex.message:  # type: ignore",
            "            msg = ex.message  # type: ignore",
            "    return msg or str(ex)",
            "",
            "",
            "def markdown(raw: str, markup_wrap: Optional[bool] = False) -> str:",
            "    safe_markdown_tags = [",
            "        \"h1\",",
            "        \"h2\",",
            "        \"h3\",",
            "        \"h4\",",
            "        \"h5\",",
            "        \"h6\",",
            "        \"b\",",
            "        \"i\",",
            "        \"strong\",",
            "        \"em\",",
            "        \"tt\",",
            "        \"p\",",
            "        \"br\",",
            "        \"span\",",
            "        \"div\",",
            "        \"blockquote\",",
            "        \"code\",",
            "        \"hr\",",
            "        \"ul\",",
            "        \"ol\",",
            "        \"li\",",
            "        \"dd\",",
            "        \"dt\",",
            "        \"img\",",
            "        \"a\",",
            "    ]",
            "    safe_markdown_attrs = {",
            "        \"img\": [\"src\", \"alt\", \"title\"],",
            "        \"a\": [\"href\", \"alt\", \"title\"],",
            "    }",
            "    safe = md.markdown(",
            "        raw or \"\",",
            "        extensions=[",
            "            \"markdown.extensions.tables\",",
            "            \"markdown.extensions.fenced_code\",",
            "            \"markdown.extensions.codehilite\",",
            "        ],",
            "    )",
            "    safe = bleach.clean(safe, safe_markdown_tags, safe_markdown_attrs)",
            "    if markup_wrap:",
            "        safe = Markup(safe)",
            "    return safe",
            "",
            "",
            "def readfile(file_path: str) -> Optional[str]:",
            "    with open(file_path) as f:",
            "        content = f.read()",
            "    return content",
            "",
            "",
            "def generic_find_constraint_name(",
            "    table: str, columns: Set[str], referenced: str, database: SQLA",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a constraint name in alembic migrations\"\"\"",
            "    tbl = sa.Table(",
            "        table, database.metadata, autoload=True, autoload_with=database.engine",
            "    )",
            "",
            "    for fk in tbl.foreign_key_constraints:",
            "        if fk.referred_table.name == referenced and set(fk.column_keys) == columns:",
            "            return fk.name",
            "",
            "    return None",
            "",
            "",
            "def generic_find_fk_constraint_name(",
            "    table: str, columns: Set[str], referenced: str, insp: Inspector",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a foreign-key constraint name in alembic migrations\"\"\"",
            "    for fk in insp.get_foreign_keys(table):",
            "        if (",
            "            fk[\"referred_table\"] == referenced",
            "            and set(fk[\"referred_columns\"]) == columns",
            "        ):",
            "            return fk[\"name\"]",
            "",
            "    return None",
            "",
            "",
            "def generic_find_fk_constraint_names(  # pylint: disable=invalid-name",
            "    table: str, columns: Set[str], referenced: str, insp: Inspector",
            ") -> Set[str]:",
            "    \"\"\"Utility to find foreign-key constraint names in alembic migrations\"\"\"",
            "    names = set()",
            "",
            "    for fk in insp.get_foreign_keys(table):",
            "        if (",
            "            fk[\"referred_table\"] == referenced",
            "            and set(fk[\"referred_columns\"]) == columns",
            "        ):",
            "            names.add(fk[\"name\"])",
            "",
            "    return names",
            "",
            "",
            "def generic_find_uq_constraint_name(",
            "    table: str, columns: Set[str], insp: Inspector",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a unique constraint name in alembic migrations\"\"\"",
            "",
            "    for uq in insp.get_unique_constraints(table):",
            "        if columns == set(uq[\"column_names\"]):",
            "            return uq[\"name\"]",
            "",
            "    return None",
            "",
            "",
            "def get_datasource_full_name(",
            "    database_name: str, datasource_name: str, schema: Optional[str] = None",
            ") -> str:",
            "    if not schema:",
            "        return \"[{}].[{}]\".format(database_name, datasource_name)",
            "    return \"[{}].[{}].[{}]\".format(database_name, schema, datasource_name)",
            "",
            "",
            "def validate_json(obj: Union[bytes, bytearray, str]) -> None:",
            "    if obj:",
            "        try:",
            "            json.loads(obj)",
            "        except Exception as ex:",
            "            logger.error(\"JSON is not valid %s\", str(ex), exc_info=True)",
            "            raise SupersetException(\"JSON is not valid\") from ex",
            "",
            "",
            "class SigalrmTimeout:",
            "    \"\"\"",
            "    To be used in a ``with`` block and timeout its content.",
            "    \"\"\"",
            "",
            "    def __init__(self, seconds: int = 1, error_message: str = \"Timeout\") -> None:",
            "        self.seconds = seconds",
            "        self.error_message = error_message",
            "",
            "    def handle_timeout(  # pylint: disable=unused-argument",
            "        self, signum: int, frame: Any",
            "    ) -> None:",
            "        logger.error(\"Process timed out\", exc_info=True)",
            "        raise SupersetTimeoutException(",
            "            error_type=SupersetErrorType.BACKEND_TIMEOUT_ERROR,",
            "            message=self.error_message,",
            "            level=ErrorLevel.ERROR,",
            "            extra={\"timeout\": self.seconds},",
            "        )",
            "",
            "    def __enter__(self) -> None:",
            "        try:",
            "            if threading.current_thread() == threading.main_thread():",
            "                signal.signal(signal.SIGALRM, self.handle_timeout)",
            "                signal.alarm(self.seconds)",
            "        except ValueError as ex:",
            "            logger.warning(\"timeout can't be used in the current context\")",
            "            logger.exception(ex)",
            "",
            "    def __exit__(  # pylint: disable=redefined-outer-name,redefined-builtin",
            "        self, type: Any, value: Any, traceback: TracebackType",
            "    ) -> None:",
            "        try:",
            "            signal.alarm(0)",
            "        except ValueError as ex:",
            "            logger.warning(\"timeout can't be used in the current context\")",
            "            logger.exception(ex)",
            "",
            "",
            "class TimerTimeout:",
            "    def __init__(self, seconds: int = 1, error_message: str = \"Timeout\") -> None:",
            "        self.seconds = seconds",
            "        self.error_message = error_message",
            "        self.timer = threading.Timer(seconds, _thread.interrupt_main)",
            "",
            "    def __enter__(self) -> None:",
            "        self.timer.start()",
            "",
            "    def __exit__(  # pylint: disable=redefined-outer-name,redefined-builtin",
            "        self, type: Any, value: Any, traceback: TracebackType",
            "    ) -> None:",
            "        self.timer.cancel()",
            "        if type is KeyboardInterrupt:  # raised by _thread.interrupt_main",
            "            raise SupersetTimeoutException(",
            "                error_type=SupersetErrorType.BACKEND_TIMEOUT_ERROR,",
            "                message=self.error_message,",
            "                level=ErrorLevel.ERROR,",
            "                extra={\"timeout\": self.seconds},",
            "            )",
            "",
            "",
            "# Windows has no support for SIGALRM, so we use the timer based timeout",
            "timeout: Union[Type[TimerTimeout], Type[SigalrmTimeout]] = (",
            "    TimerTimeout if platform.system() == \"Windows\" else SigalrmTimeout",
            ")",
            "",
            "",
            "def pessimistic_connection_handling(some_engine: Engine) -> None:",
            "    @event.listens_for(some_engine, \"engine_connect\")",
            "    def ping_connection(connection: Connection, branch: bool) -> None:",
            "        if branch:",
            "            # 'branch' refers to a sub-connection of a connection,",
            "            # we don't want to bother pinging on these.",
            "            return",
            "",
            "        # turn off 'close with result'.  This flag is only used with",
            "        # 'connectionless' execution, otherwise will be False in any case",
            "        save_should_close_with_result = connection.should_close_with_result",
            "        connection.should_close_with_result = False",
            "",
            "        try:",
            "            # run a SELECT 1.   use a core select() so that",
            "            # the SELECT of a scalar value without a table is",
            "            # appropriately formatted for the backend",
            "            connection.scalar(select([1]))",
            "        except exc.DBAPIError as err:",
            "            # catch SQLAlchemy's DBAPIError, which is a wrapper",
            "            # for the DBAPI's exception.  It includes a .connection_invalidated",
            "            # attribute which specifies if this connection is a 'disconnect'",
            "            # condition, which is based on inspection of the original exception",
            "            # by the dialect in use.",
            "            if err.connection_invalidated:",
            "                # run the same SELECT again - the connection will re-validate",
            "                # itself and establish a new connection.  The disconnect detection",
            "                # here also causes the whole connection pool to be invalidated",
            "                # so that all stale connections are discarded.",
            "                connection.scalar(select([1]))",
            "            else:",
            "                raise",
            "        finally:",
            "            # restore 'close with result'",
            "            connection.should_close_with_result = save_should_close_with_result",
            "",
            "",
            "def notify_user_about_perm_udate(  # pylint: disable=too-many-arguments",
            "    granter: User,",
            "    user: User,",
            "    role: Role,",
            "    datasource: \"BaseDatasource\",",
            "    tpl_name: str,",
            "    config: Dict[str, Any],",
            ") -> None:",
            "    msg = render_template(",
            "        tpl_name, granter=granter, user=user, role=role, datasource=datasource",
            "    )",
            "    logger.info(msg)",
            "    subject = __(",
            "        \"[Superset] Access to the datasource %(name)s was granted\",",
            "        name=datasource.full_name,",
            "    )",
            "    send_email_smtp(",
            "        user.email,",
            "        subject,",
            "        msg,",
            "        config,",
            "        bcc=granter.email,",
            "        dryrun=not config[\"EMAIL_NOTIFICATIONS\"],",
            "    )",
            "",
            "",
            "def send_email_smtp(  # pylint: disable=invalid-name,too-many-arguments,too-many-locals",
            "    to: str,",
            "    subject: str,",
            "    html_content: str,",
            "    config: Dict[str, Any],",
            "    files: Optional[List[str]] = None,",
            "    data: Optional[Dict[str, str]] = None,",
            "    images: Optional[Dict[str, bytes]] = None,",
            "    dryrun: bool = False,",
            "    cc: Optional[str] = None,",
            "    bcc: Optional[str] = None,",
            "    mime_subtype: str = \"mixed\",",
            ") -> None:",
            "    \"\"\"",
            "    Send an email with html content, eg:",
            "    send_email_smtp(",
            "        'test@example.com', 'foo', '<b>Foo</b> bar',['/dev/null'], dryrun=True)",
            "    \"\"\"",
            "    smtp_mail_from = config[\"SMTP_MAIL_FROM\"]",
            "    smtp_mail_to = get_email_address_list(to)",
            "",
            "    msg = MIMEMultipart(mime_subtype)",
            "    msg[\"Subject\"] = subject",
            "    msg[\"From\"] = smtp_mail_from",
            "    msg[\"To\"] = \", \".join(smtp_mail_to)",
            "    msg.preamble = \"This is a multi-part message in MIME format.\"",
            "",
            "    recipients = smtp_mail_to",
            "    if cc:",
            "        smtp_mail_cc = get_email_address_list(cc)",
            "        msg[\"CC\"] = \", \".join(smtp_mail_cc)",
            "        recipients = recipients + smtp_mail_cc",
            "",
            "    if bcc:",
            "        # don't add bcc in header",
            "        smtp_mail_bcc = get_email_address_list(bcc)",
            "        recipients = recipients + smtp_mail_bcc",
            "",
            "    msg[\"Date\"] = formatdate(localtime=True)",
            "    mime_text = MIMEText(html_content, \"html\")",
            "    msg.attach(mime_text)",
            "",
            "    # Attach files by reading them from disk",
            "    for fname in files or []:",
            "        basename = os.path.basename(fname)",
            "        with open(fname, \"rb\") as f:",
            "            msg.attach(",
            "                MIMEApplication(",
            "                    f.read(),",
            "                    Content_Disposition=\"attachment; filename='%s'\" % basename,",
            "                    Name=basename,",
            "                )",
            "            )",
            "",
            "    # Attach any files passed directly",
            "    for name, body in (data or {}).items():",
            "        msg.attach(",
            "            MIMEApplication(",
            "                body, Content_Disposition=\"attachment; filename='%s'\" % name, Name=name",
            "            )",
            "        )",
            "",
            "    # Attach any inline images, which may be required for display in",
            "    # HTML content (inline)",
            "    for msgid, imgdata in (images or {}).items():",
            "        image = MIMEImage(imgdata)",
            "        image.add_header(\"Content-ID\", \"<%s>\" % msgid)",
            "        image.add_header(\"Content-Disposition\", \"inline\")",
            "        msg.attach(image)",
            "",
            "    send_mime_email(smtp_mail_from, recipients, msg, config, dryrun=dryrun)",
            "",
            "",
            "def send_mime_email(",
            "    e_from: str,",
            "    e_to: List[str],",
            "    mime_msg: MIMEMultipart,",
            "    config: Dict[str, Any],",
            "    dryrun: bool = False,",
            ") -> None:",
            "    smtp_host = config[\"SMTP_HOST\"]",
            "    smtp_port = config[\"SMTP_PORT\"]",
            "    smtp_user = config[\"SMTP_USER\"]",
            "    smtp_password = config[\"SMTP_PASSWORD\"]",
            "    smtp_starttls = config[\"SMTP_STARTTLS\"]",
            "    smtp_ssl = config[\"SMTP_SSL\"]",
            "",
            "    if not dryrun:",
            "        smtp = (",
            "            smtplib.SMTP_SSL(smtp_host, smtp_port)",
            "            if smtp_ssl",
            "            else smtplib.SMTP(smtp_host, smtp_port)",
            "        )",
            "        if smtp_starttls:",
            "            smtp.starttls()",
            "        if smtp_user and smtp_password:",
            "            smtp.login(smtp_user, smtp_password)",
            "        logger.debug(\"Sent an email to %s\", str(e_to))",
            "        smtp.sendmail(e_from, e_to, mime_msg.as_string())",
            "        smtp.quit()",
            "    else:",
            "        logger.info(\"Dryrun enabled, email notification content is below:\")",
            "        logger.info(mime_msg.as_string())",
            "",
            "",
            "def get_email_address_list(address_string: str) -> List[str]:",
            "    address_string_list: List[str] = []",
            "    if isinstance(address_string, str):",
            "        address_string_list = re.split(r\",|\\s|;\", address_string)",
            "    return [x.strip() for x in address_string_list if x.strip()]",
            "",
            "",
            "def get_email_address_str(address_string: str) -> str:",
            "    address_list = get_email_address_list(address_string)",
            "    address_list_str = \", \".join(address_list)",
            "",
            "    return address_list_str",
            "",
            "",
            "def choicify(values: Iterable[Any]) -> List[Tuple[Any, Any]]:",
            "    \"\"\"Takes an iterable and makes an iterable of tuples with it\"\"\"",
            "    return [(v, v) for v in values]",
            "",
            "",
            "def zlib_compress(data: Union[bytes, str]) -> bytes:",
            "    \"\"\"",
            "    Compress things in a py2/3 safe fashion",
            "    >>> json_str = '{\"test\": 1}'",
            "    >>> blob = zlib_compress(json_str)",
            "    \"\"\"",
            "    if isinstance(data, str):",
            "        return zlib.compress(bytes(data, \"utf-8\"))",
            "    return zlib.compress(data)",
            "",
            "",
            "def zlib_decompress(blob: bytes, decode: Optional[bool] = True) -> Union[bytes, str]:",
            "    \"\"\"",
            "    Decompress things to a string in a py2/3 safe fashion",
            "    >>> json_str = '{\"test\": 1}'",
            "    >>> blob = zlib_compress(json_str)",
            "    >>> got_str = zlib_decompress(blob)",
            "    >>> got_str == json_str",
            "    True",
            "    \"\"\"",
            "    if isinstance(blob, bytes):",
            "        decompressed = zlib.decompress(blob)",
            "    else:",
            "        decompressed = zlib.decompress(bytes(blob, \"utf-8\"))",
            "    return decompressed.decode(\"utf-8\") if decode else decompressed",
            "",
            "",
            "def simple_filter_to_adhoc(",
            "    filter_clause: QueryObjectFilterClause, clause: str = \"where\",",
            ") -> AdhocFilterClause:",
            "    result: AdhocFilterClause = {",
            "        \"clause\": clause.upper(),",
            "        \"expressionType\": \"SIMPLE\",",
            "        \"comparator\": filter_clause.get(\"val\"),",
            "        \"operator\": filter_clause[\"op\"],",
            "        \"subject\": filter_clause[\"col\"],",
            "    }",
            "    if filter_clause.get(\"isExtra\"):",
            "        result[\"isExtra\"] = True",
            "    result[\"filterOptionName\"] = md5_sha_from_dict(cast(Dict[Any, Any], result))",
            "",
            "    return result",
            "",
            "",
            "def form_data_to_adhoc(form_data: Dict[str, Any], clause: str) -> AdhocFilterClause:",
            "    if clause not in (\"where\", \"having\"):",
            "        raise ValueError(__(\"Unsupported clause type: %(clause)s\", clause=clause))",
            "    result: AdhocFilterClause = {",
            "        \"clause\": clause.upper(),",
            "        \"expressionType\": \"SQL\",",
            "        \"sqlExpression\": form_data.get(clause),",
            "    }",
            "    result[\"filterOptionName\"] = md5_sha_from_dict(cast(Dict[Any, Any], result))",
            "",
            "    return result",
            "",
            "",
            "def merge_extra_form_data(form_data: Dict[str, Any]) -> None:",
            "    \"\"\"",
            "    Merge extra form data (appends and overrides) into the main payload",
            "    and add applied time extras to the payload.",
            "    \"\"\"",
            "    filter_keys = [\"filters\", \"adhoc_filters\"]",
            "    extra_form_data = form_data.pop(\"extra_form_data\", {})",
            "    append_filters: List[QueryObjectFilterClause] = extra_form_data.get(\"filters\", None)",
            "",
            "    # merge append extras",
            "    for key in [key for key in EXTRA_FORM_DATA_APPEND_KEYS if key not in filter_keys]:",
            "        extra_value = getattr(extra_form_data, key, {})",
            "        form_value = getattr(form_data, key, {})",
            "        form_value.update(extra_value)",
            "        if form_value:",
            "            form_data[\"key\"] = extra_value",
            "",
            "    # map regular extras that apply to form data properties",
            "    for src_key, target_key in EXTRA_FORM_DATA_OVERRIDE_REGULAR_MAPPINGS.items():",
            "        value = extra_form_data.get(src_key)",
            "        if value is not None:",
            "            form_data[target_key] = value",
            "",
            "    # map extras that apply to form data extra properties",
            "    extras = form_data.get(\"extras\", {})",
            "    for key in EXTRA_FORM_DATA_OVERRIDE_EXTRA_KEYS:",
            "        value = extra_form_data.get(key)",
            "        if value is not None:",
            "            extras[key] = value",
            "    if extras:",
            "        form_data[\"extras\"] = extras",
            "",
            "    adhoc_filters: List[AdhocFilterClause] = form_data.get(\"adhoc_filters\", [])",
            "    form_data[\"adhoc_filters\"] = adhoc_filters",
            "    append_adhoc_filters: List[AdhocFilterClause] = extra_form_data.get(",
            "        \"adhoc_filters\", []",
            "    )",
            "    adhoc_filters.extend(",
            "        {\"isExtra\": True, **fltr} for fltr in append_adhoc_filters  # type: ignore",
            "    )",
            "    if append_filters:",
            "        adhoc_filters.extend(",
            "            simple_filter_to_adhoc({\"isExtra\": True, **fltr})  # type: ignore",
            "            for fltr in append_filters",
            "            if fltr",
            "        )",
            "",
            "",
            "def merge_extra_filters(form_data: Dict[str, Any]) -> None:",
            "    # extra_filters are temporary/contextual filters (using the legacy constructs)",
            "    # that are external to the slice definition. We use those for dynamic",
            "    # interactive filters like the ones emitted by the \"Filter Box\" visualization.",
            "    # Note extra_filters only support simple filters.",
            "    applied_time_extras: Dict[str, str] = {}",
            "    form_data[\"applied_time_extras\"] = applied_time_extras",
            "    adhoc_filters = form_data.get(\"adhoc_filters\", [])",
            "    form_data[\"adhoc_filters\"] = adhoc_filters",
            "    merge_extra_form_data(form_data)",
            "    if \"extra_filters\" in form_data:",
            "        # __form and __to are special extra_filters that target time",
            "        # boundaries. The rest of extra_filters are simple",
            "        # [column_name in list_of_values]. `__` prefix is there to avoid",
            "        # potential conflicts with column that would be named `from` or `to`",
            "        date_options = {",
            "            \"__time_range\": \"time_range\",",
            "            \"__time_col\": \"granularity_sqla\",",
            "            \"__time_grain\": \"time_grain_sqla\",",
            "            \"__time_origin\": \"druid_time_origin\",",
            "            \"__granularity\": \"granularity\",",
            "        }",
            "        # Grab list of existing filters 'keyed' on the column and operator",
            "",
            "        def get_filter_key(f: Dict[str, Any]) -> str:",
            "            if \"expressionType\" in f:",
            "                return \"{}__{}\".format(f[\"subject\"], f[\"operator\"])",
            "",
            "            return \"{}__{}\".format(f[\"col\"], f[\"op\"])",
            "",
            "        existing_filters = {}",
            "        for existing in adhoc_filters:",
            "            if (",
            "                existing[\"expressionType\"] == \"SIMPLE\"",
            "                and existing.get(\"comparator\") is not None",
            "                and existing.get(\"subject\") is not None",
            "            ):",
            "                existing_filters[get_filter_key(existing)] = existing[\"comparator\"]",
            "",
            "        for filtr in form_data[  # pylint: disable=too-many-nested-blocks",
            "            \"extra_filters\"",
            "        ]:",
            "            filtr[\"isExtra\"] = True",
            "            # Pull out time filters/options and merge into form data",
            "            filter_column = filtr[\"col\"]",
            "            time_extra = date_options.get(filter_column)",
            "            if time_extra:",
            "                time_extra_value = filtr.get(\"val\")",
            "                if time_extra_value and time_extra_value != NO_TIME_RANGE:",
            "                    form_data[time_extra] = time_extra_value",
            "                    applied_time_extras[filter_column] = time_extra_value",
            "            elif filtr[\"val\"]:",
            "                # Merge column filters",
            "                filter_key = get_filter_key(filtr)",
            "                if filter_key in existing_filters:",
            "                    # Check if the filter already exists",
            "                    if isinstance(filtr[\"val\"], list):",
            "                        if isinstance(existing_filters[filter_key], list):",
            "                            # Add filters for unequal lists",
            "                            # order doesn't matter",
            "                            if set(existing_filters[filter_key]) != set(filtr[\"val\"]):",
            "                                adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                        else:",
            "                            adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                    else:",
            "                        # Do not add filter if same value already exists",
            "                        if filtr[\"val\"] != existing_filters[filter_key]:",
            "                            adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                else:",
            "                    # Filter not found, add it",
            "                    adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "        # Remove extra filters from the form data since no longer needed",
            "        del form_data[\"extra_filters\"]",
            "",
            "",
            "def merge_request_params(form_data: Dict[str, Any], params: Dict[str, Any]) -> None:",
            "    \"\"\"",
            "    Merge request parameters to the key `url_params` in form_data. Only updates",
            "    or appends parameters to `form_data` that are defined in `params; pre-existing",
            "    parameters not defined in params are left unchanged.",
            "",
            "    :param form_data: object to be updated",
            "    :param params: request parameters received via query string",
            "    \"\"\"",
            "    url_params = form_data.get(\"url_params\", {})",
            "    for key, value in params.items():",
            "        if key in (\"form_data\", \"r\"):",
            "            continue",
            "        url_params[key] = value",
            "    form_data[\"url_params\"] = url_params",
            "",
            "",
            "def user_label(user: User) -> Optional[str]:",
            "    \"\"\"Given a user ORM FAB object, returns a label\"\"\"",
            "    if user:",
            "        if user.first_name and user.last_name:",
            "            return user.first_name + \" \" + user.last_name",
            "",
            "        return user.username",
            "",
            "    return None",
            "",
            "",
            "def get_or_create_db(",
            "    database_name: str, sqlalchemy_uri: str, always_create: Optional[bool] = True",
            ") -> \"Database\":",
            "    # pylint: disable=import-outside-toplevel",
            "    from superset import db",
            "    from superset.models import core as models",
            "",
            "    database = (",
            "        db.session.query(models.Database).filter_by(database_name=database_name).first()",
            "    )",
            "",
            "    # databases with a fixed UUID",
            "    uuids = {",
            "        \"examples\": EXAMPLES_DB_UUID,",
            "    }",
            "",
            "    if not database and always_create:",
            "        logger.info(\"Creating database reference for %s\", database_name)",
            "        database = models.Database(",
            "            database_name=database_name, uuid=uuids.get(database_name)",
            "        )",
            "        db.session.add(database)",
            "",
            "    if database:",
            "        database.set_sqlalchemy_uri(sqlalchemy_uri)",
            "        db.session.commit()",
            "",
            "    return database",
            "",
            "",
            "def get_example_database() -> \"Database\":",
            "    db_uri = (",
            "        current_app.config.get(\"SQLALCHEMY_EXAMPLES_URI\")",
            "        or current_app.config[\"SQLALCHEMY_DATABASE_URI\"]",
            "    )",
            "    return get_or_create_db(\"examples\", db_uri)",
            "",
            "",
            "def get_main_database() -> \"Database\":",
            "    db_uri = current_app.config[\"SQLALCHEMY_DATABASE_URI\"]",
            "    return get_or_create_db(\"main\", db_uri)",
            "",
            "",
            "def get_example_default_schema() -> Optional[str]:",
            "    \"\"\"",
            "    Return the default schema of the examples database, if any.",
            "    \"\"\"",
            "    database = get_example_database()",
            "    engine = database.get_sqla_engine()",
            "    return inspect(engine).default_schema_name",
            "",
            "",
            "def backend() -> str:",
            "    return get_example_database().backend",
            "",
            "",
            "def is_adhoc_metric(metric: Metric) -> TypeGuard[AdhocMetric]:",
            "    return isinstance(metric, dict) and \"expressionType\" in metric",
            "",
            "",
            "def get_metric_name(metric: Metric) -> str:",
            "    \"\"\"",
            "    Extract label from metric",
            "",
            "    :param metric: object to extract label from",
            "    :return: String representation of metric",
            "    :raises ValueError: if metric object is invalid",
            "    \"\"\"",
            "    if is_adhoc_metric(metric):",
            "        label = metric.get(\"label\")",
            "        if label:",
            "            return label",
            "        expression_type = metric.get(\"expressionType\")",
            "        if expression_type == \"SQL\":",
            "            sql_expression = metric.get(\"sqlExpression\")",
            "            if sql_expression:",
            "                return sql_expression",
            "        elif expression_type == \"SIMPLE\":",
            "            column: AdhocMetricColumn = metric.get(\"column\") or {}",
            "            column_name = column.get(\"column_name\")",
            "            aggregate = metric.get(\"aggregate\")",
            "            if column and aggregate:",
            "                return f\"{aggregate}({column_name})\"",
            "            if column_name:",
            "                return column_name",
            "        raise ValueError(__(\"Invalid metric object\"))",
            "    return metric  # type: ignore",
            "",
            "",
            "def get_metric_names(metrics: Sequence[Metric]) -> List[str]:",
            "    return [metric for metric in map(get_metric_name, metrics) if metric]",
            "",
            "",
            "def get_first_metric_name(metrics: Sequence[Metric]) -> Optional[str]:",
            "    metric_labels = get_metric_names(metrics)",
            "    return metric_labels[0] if metric_labels else None",
            "",
            "",
            "def ensure_path_exists(path: str) -> None:",
            "    try:",
            "        os.makedirs(path)",
            "    except OSError as ex:",
            "        if not (os.path.isdir(path) and ex.errno == errno.EEXIST):",
            "            raise",
            "",
            "",
            "def convert_legacy_filters_into_adhoc(  # pylint: disable=invalid-name",
            "    form_data: FormData,",
            ") -> None:",
            "    mapping = {\"having\": \"having_filters\", \"where\": \"filters\"}",
            "",
            "    if not form_data.get(\"adhoc_filters\"):",
            "        adhoc_filters: List[AdhocFilterClause] = []",
            "        form_data[\"adhoc_filters\"] = adhoc_filters",
            "",
            "        for clause, filters in mapping.items():",
            "            if clause in form_data and form_data[clause] != \"\":",
            "                adhoc_filters.append(form_data_to_adhoc(form_data, clause))",
            "",
            "            if filters in form_data:",
            "                for filt in filter(lambda x: x is not None, form_data[filters]):",
            "                    adhoc_filters.append(simple_filter_to_adhoc(filt, clause))",
            "",
            "    for key in (\"filters\", \"having\", \"having_filters\", \"where\"):",
            "        if key in form_data:",
            "            del form_data[key]",
            "",
            "",
            "def split_adhoc_filters_into_base_filters(  # pylint: disable=invalid-name",
            "    form_data: FormData,",
            ") -> None:",
            "    \"\"\"",
            "    Mutates form data to restructure the adhoc filters in the form of the four base",
            "    filters, `where`, `having`, `filters`, and `having_filters` which represent",
            "    free form where sql, free form having sql, structured where clauses and structured",
            "    having clauses.",
            "    \"\"\"",
            "    adhoc_filters = form_data.get(\"adhoc_filters\")",
            "    if isinstance(adhoc_filters, list):",
            "        simple_where_filters = []",
            "        simple_having_filters = []",
            "        sql_where_filters = []",
            "        sql_having_filters = []",
            "        for adhoc_filter in adhoc_filters:",
            "            expression_type = adhoc_filter.get(\"expressionType\")",
            "            clause = adhoc_filter.get(\"clause\")",
            "            if expression_type == \"SIMPLE\":",
            "                if clause == \"WHERE\":",
            "                    simple_where_filters.append(",
            "                        {",
            "                            \"col\": adhoc_filter.get(\"subject\"),",
            "                            \"op\": adhoc_filter.get(\"operator\"),",
            "                            \"val\": adhoc_filter.get(\"comparator\"),",
            "                        }",
            "                    )",
            "                elif clause == \"HAVING\":",
            "                    simple_having_filters.append(",
            "                        {",
            "                            \"col\": adhoc_filter.get(\"subject\"),",
            "                            \"op\": adhoc_filter.get(\"operator\"),",
            "                            \"val\": adhoc_filter.get(\"comparator\"),",
            "                        }",
            "                    )",
            "            elif expression_type == \"SQL\":",
            "                sql_expression = adhoc_filter.get(\"sqlExpression\")",
            "                sql_expression = sanitize_clause(sql_expression)",
            "                if clause == \"WHERE\":",
            "                    sql_where_filters.append(sql_expression)",
            "                elif clause == \"HAVING\":",
            "                    sql_having_filters.append(sql_expression)",
            "        form_data[\"where\"] = \" AND \".join(",
            "            [\"({})\".format(sql) for sql in sql_where_filters]",
            "        )",
            "        form_data[\"having\"] = \" AND \".join(",
            "            [\"({})\".format(sql) for sql in sql_having_filters]",
            "        )",
            "        form_data[\"having_filters\"] = simple_having_filters",
            "        form_data[\"filters\"] = simple_where_filters",
            "",
            "",
            "def get_username() -> Optional[str]:",
            "    \"\"\"Get username if within the flask context, otherwise return noffin'\"\"\"",
            "    try:",
            "        return g.user.username",
            "    except Exception:  # pylint: disable=broad-except",
            "        return None",
            "",
            "",
            "def parse_ssl_cert(certificate: str) -> _Certificate:",
            "    \"\"\"",
            "    Parses the contents of a certificate and returns a valid certificate object",
            "    if valid.",
            "",
            "    :param certificate: Contents of certificate file",
            "    :return: Valid certificate instance",
            "    :raises CertificateException: If certificate is not valid/unparseable",
            "    \"\"\"",
            "    try:",
            "        return x509.load_pem_x509_certificate(",
            "            certificate.encode(\"utf-8\"), default_backend()",
            "        )",
            "    except ValueError as ex:",
            "        raise CertificateException(\"Invalid certificate\") from ex",
            "",
            "",
            "def create_ssl_cert_file(certificate: str) -> str:",
            "    \"\"\"",
            "    This creates a certificate file that can be used to validate HTTPS",
            "    sessions. A certificate is only written to disk once; on subsequent calls,",
            "    only the path of the existing certificate is returned.",
            "",
            "    :param certificate: The contents of the certificate",
            "    :return: The path to the certificate file",
            "    :raises CertificateException: If certificate is not valid/unparseable",
            "    \"\"\"",
            "    filename = f\"{md5_sha_from_str(certificate)}.crt\"",
            "    cert_dir = current_app.config[\"SSL_CERT_PATH\"]",
            "    path = cert_dir if cert_dir else tempfile.gettempdir()",
            "    path = os.path.join(path, filename)",
            "    if not os.path.exists(path):",
            "        # Validate certificate prior to persisting to temporary directory",
            "        parse_ssl_cert(certificate)",
            "        with open(path, \"w\") as cert_file:",
            "            cert_file.write(certificate)",
            "    return path",
            "",
            "",
            "def time_function(",
            "    func: Callable[..., FlaskResponse], *args: Any, **kwargs: Any",
            ") -> Tuple[float, Any]:",
            "    \"\"\"",
            "    Measures the amount of time a function takes to execute in ms",
            "",
            "    :param func: The function execution time to measure",
            "    :param args: args to be passed to the function",
            "    :param kwargs: kwargs to be passed to the function",
            "    :return: A tuple with the duration and response from the function",
            "    \"\"\"",
            "    start = default_timer()",
            "    response = func(*args, **kwargs)",
            "    stop = default_timer()",
            "    return (stop - start) * 1000.0, response",
            "",
            "",
            "def MediumText() -> Variant:  # pylint:disable=invalid-name",
            "    return Text().with_variant(MEDIUMTEXT(), \"mysql\")",
            "",
            "",
            "def shortid() -> str:",
            "    return \"{}\".format(uuid.uuid4())[-12:]",
            "",
            "",
            "class DatasourceName(NamedTuple):",
            "    table: str",
            "    schema: str",
            "",
            "",
            "def get_stacktrace() -> Optional[str]:",
            "    if current_app.config[\"SHOW_STACKTRACE\"]:",
            "        return traceback.format_exc()",
            "    return None",
            "",
            "",
            "def split(",
            "    string: str, delimiter: str = \" \", quote: str = '\"', escaped_quote: str = r\"\\\"\"",
            ") -> Iterator[str]:",
            "    \"\"\"",
            "    A split function that is aware of quotes and parentheses.",
            "",
            "    :param string: string to split",
            "    :param delimiter: string defining where to split, usually a comma or space",
            "    :param quote: string, either a single or a double quote",
            "    :param escaped_quote: string representing an escaped quote",
            "    :return: list of strings",
            "    \"\"\"",
            "    parens = 0",
            "    quotes = False",
            "    i = 0",
            "    for j, character in enumerate(string):",
            "        complete = parens == 0 and not quotes",
            "        if complete and character == delimiter:",
            "            yield string[i:j]",
            "            i = j + len(delimiter)",
            "        elif character == \"(\":",
            "            parens += 1",
            "        elif character == \")\":",
            "            parens -= 1",
            "        elif character == quote:",
            "            if quotes and string[j - len(escaped_quote) + 1 : j + 1] != escaped_quote:",
            "                quotes = False",
            "            elif not quotes:",
            "                quotes = True",
            "    yield string[i:]",
            "",
            "",
            "def get_iterable(x: Any) -> List[Any]:",
            "    \"\"\"",
            "    Get an iterable (list) representation of the object.",
            "",
            "    :param x: The object",
            "    :returns: An iterable representation",
            "    \"\"\"",
            "    return x if isinstance(x, list) else [x]",
            "",
            "",
            "def get_form_data_token(form_data: Dict[str, Any]) -> str:",
            "    \"\"\"",
            "    Return the token contained within form data or generate a new one.",
            "",
            "    :param form_data: chart form data",
            "    :return: original token if predefined, otherwise new uuid4 based token",
            "    \"\"\"",
            "    return form_data.get(\"token\") or \"token_\" + uuid.uuid4().hex[:8]",
            "",
            "",
            "def get_column_name_from_metric(metric: Metric) -> Optional[str]:",
            "    \"\"\"",
            "    Extract the column that a metric is referencing. If the metric isn't",
            "    a simple metric, always returns `None`.",
            "",
            "    :param metric: Ad-hoc metric",
            "    :return: column name if simple metric, otherwise None",
            "    \"\"\"",
            "    if is_adhoc_metric(metric):",
            "        metric = cast(AdhocMetric, metric)",
            "        if metric[\"expressionType\"] == AdhocMetricExpressionType.SIMPLE:",
            "            return cast(Dict[str, Any], metric[\"column\"])[\"column_name\"]",
            "    return None",
            "",
            "",
            "def get_column_names_from_metrics(metrics: List[Metric]) -> List[str]:",
            "    \"\"\"",
            "    Extract the columns that a list of metrics are referencing. Expcludes all",
            "    SQL metrics.",
            "",
            "    :param metrics: Ad-hoc metric",
            "    :return: column name if simple metric, otherwise None",
            "    \"\"\"",
            "    return [col for col in map(get_column_name_from_metric, metrics) if col]",
            "",
            "",
            "def extract_dataframe_dtypes(df: pd.DataFrame) -> List[GenericDataType]:",
            "    \"\"\"Serialize pandas/numpy dtypes to generic types\"\"\"",
            "",
            "    # omitting string types as those will be the default type",
            "    inferred_type_map: Dict[str, GenericDataType] = {",
            "        \"floating\": GenericDataType.NUMERIC,",
            "        \"integer\": GenericDataType.NUMERIC,",
            "        \"mixed-integer-float\": GenericDataType.NUMERIC,",
            "        \"decimal\": GenericDataType.NUMERIC,",
            "        \"boolean\": GenericDataType.BOOLEAN,",
            "        \"datetime64\": GenericDataType.TEMPORAL,",
            "        \"datetime\": GenericDataType.TEMPORAL,",
            "        \"date\": GenericDataType.TEMPORAL,",
            "    }",
            "",
            "    generic_types: List[GenericDataType] = []",
            "    for column in df.columns:",
            "        series = df[column]",
            "        inferred_type = infer_dtype(series)",
            "        generic_type = inferred_type_map.get(inferred_type, GenericDataType.STRING)",
            "        generic_types.append(generic_type)",
            "",
            "    return generic_types",
            "",
            "",
            "def extract_column_dtype(col: \"BaseColumn\") -> GenericDataType:",
            "    if col.is_temporal:",
            "        return GenericDataType.TEMPORAL",
            "    if col.is_numeric:",
            "        return GenericDataType.NUMERIC",
            "    # TODO: add check for boolean data type when proper support is added",
            "    return GenericDataType.STRING",
            "",
            "",
            "def indexed(",
            "    items: List[Any], key: Union[str, Callable[[Any], Any]]",
            ") -> Dict[Any, List[Any]]:",
            "    \"\"\"Build an index for a list of objects\"\"\"",
            "    idx: Dict[Any, Any] = {}",
            "    for item in items:",
            "        key_ = getattr(item, key) if isinstance(key, str) else key(item)",
            "        idx.setdefault(key_, []).append(item)",
            "    return idx",
            "",
            "",
            "def is_test() -> bool:",
            "    return strtobool(os.environ.get(\"SUPERSET_TESTENV\", \"false\"))",
            "",
            "",
            "def get_time_filter_status(",
            "    datasource: \"BaseDatasource\", applied_time_extras: Dict[str, str],",
            ") -> Tuple[List[Dict[str, str]], List[Dict[str, str]]]:",
            "    temporal_columns = {col.column_name for col in datasource.columns if col.is_dttm}",
            "    applied: List[Dict[str, str]] = []",
            "    rejected: List[Dict[str, str]] = []",
            "    time_column = applied_time_extras.get(ExtraFiltersTimeColumnType.TIME_COL)",
            "    if time_column:",
            "        if time_column in temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_COL})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.COL_NOT_IN_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_COL,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.TIME_GRAIN in applied_time_extras:",
            "        # are there any temporal columns to assign the time grain to?",
            "        if temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_GRAIN})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NO_TEMPORAL_COLUMN,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_GRAIN,",
            "                }",
            "            )",
            "",
            "    time_range = applied_time_extras.get(ExtraFiltersTimeColumnType.TIME_RANGE)",
            "    if time_range:",
            "        # are there any temporal columns to assign the time grain to?",
            "        if temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_RANGE})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NO_TEMPORAL_COLUMN,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_RANGE,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.TIME_ORIGIN in applied_time_extras:",
            "        if datasource.type == \"druid\":",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_ORIGIN})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NOT_DRUID_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_ORIGIN,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.GRANULARITY in applied_time_extras:",
            "        if datasource.type == \"druid\":",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.GRANULARITY})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NOT_DRUID_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.GRANULARITY,",
            "                }",
            "            )",
            "",
            "    return applied, rejected",
            "",
            "",
            "def format_list(items: Sequence[str], sep: str = \", \", quote: str = '\"') -> str:",
            "    quote_escaped = \"\\\\\" + quote",
            "    return sep.join(f\"{quote}{x.replace(quote, quote_escaped)}{quote}\" for x in items)",
            "",
            "",
            "def find_duplicates(items: Iterable[InputType]) -> List[InputType]:",
            "    \"\"\"Find duplicate items in an iterable.\"\"\"",
            "    return [item for item, count in collections.Counter(items).items() if count > 1]",
            "",
            "",
            "def remove_duplicates(",
            "    items: Iterable[InputType], key: Optional[Callable[[InputType], Any]] = None",
            ") -> List[InputType]:",
            "    \"\"\"Remove duplicate items in an iterable.\"\"\"",
            "    if not key:",
            "        return list(dict.fromkeys(items).keys())",
            "    seen = set()",
            "    result = []",
            "    for item in items:",
            "        item_key = key(item)",
            "        if item_key not in seen:",
            "            seen.add(item_key)",
            "            result.append(item)",
            "    return result",
            "",
            "",
            "def normalize_dttm_col(",
            "    df: pd.DataFrame,",
            "    timestamp_format: Optional[str],",
            "    offset: int,",
            "    time_shift: Optional[timedelta],",
            ") -> None:",
            "    if DTTM_ALIAS not in df.columns:",
            "        return",
            "    if timestamp_format in (\"epoch_s\", \"epoch_ms\"):",
            "        dttm_col = df[DTTM_ALIAS]",
            "        if is_numeric_dtype(dttm_col):",
            "            # Column is formatted as a numeric value",
            "            unit = timestamp_format.replace(\"epoch_\", \"\")",
            "            df[DTTM_ALIAS] = pd.to_datetime(",
            "                dttm_col, utc=False, unit=unit, origin=\"unix\"",
            "            )",
            "        else:",
            "            # Column has already been formatted as a timestamp.",
            "            df[DTTM_ALIAS] = dttm_col.apply(pd.Timestamp)",
            "    else:",
            "        df[DTTM_ALIAS] = pd.to_datetime(",
            "            df[DTTM_ALIAS], utc=False, format=timestamp_format",
            "        )",
            "    if offset:",
            "        df[DTTM_ALIAS] += timedelta(hours=offset)",
            "    if time_shift is not None:",
            "        df[DTTM_ALIAS] += time_shift",
            "",
            "",
            "def parse_boolean_string(bool_str: Optional[str]) -> bool:",
            "    \"\"\"",
            "    Convert a string representation of a true/false value into a boolean",
            "",
            "    >>> parse_boolean_string(None)",
            "    False",
            "    >>> parse_boolean_string('false')",
            "    False",
            "    >>> parse_boolean_string('true')",
            "    True",
            "    >>> parse_boolean_string('False')",
            "    False",
            "    >>> parse_boolean_string('True')",
            "    True",
            "    >>> parse_boolean_string('foo')",
            "    False",
            "    >>> parse_boolean_string('0')",
            "    False",
            "    >>> parse_boolean_string('1')",
            "    True",
            "",
            "    :param bool_str: string representation of a value that is assumed to be boolean",
            "    :return: parsed boolean value",
            "    \"\"\"",
            "    if bool_str is None:",
            "        return False",
            "    try:",
            "        return bool(strtobool(bool_str.lower()))",
            "    except ValueError:",
            "        return False",
            "",
            "",
            "def apply_max_row_limit(limit: int, max_limit: Optional[int] = None,) -> int:",
            "    \"\"\"",
            "    Override row limit if max global limit is defined",
            "",
            "    :param limit: requested row limit",
            "    :param max_limit: Maximum allowed row limit",
            "    :return: Capped row limit",
            "",
            "    >>> apply_max_row_limit(100000, 10)",
            "    10",
            "    >>> apply_max_row_limit(10, 100000)",
            "    10",
            "    >>> apply_max_row_limit(0, 10000)",
            "    10000",
            "    \"\"\"",
            "    if max_limit is None:",
            "        max_limit = current_app.config[\"SQL_MAX_ROW\"]",
            "    if limit != 0:",
            "        return min(max_limit, limit)",
            "    return max_limit"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1396": [
                "split_adhoc_filters_into_base_filters"
            ],
            "1398": [
                "split_adhoc_filters_into_base_filters"
            ]
        },
        "addLocation": [
            "superset.utils.core.split_adhoc_filters_into_base_filters.sql_where_filters",
            "superset.utils.core.split_adhoc_filters_into_base_filters.simple_having_filters",
            "superset.utils.core.split_adhoc_filters_into_base_filters.simple_where_filters",
            "pypdf.generic._data_structures",
            "superset.utils.core.split_adhoc_filters_into_base_filters.sql_having_filters"
        ]
    },
    "superset/viz.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " from superset.exceptions import ("
            },
            "1": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     CacheLoadError,"
            },
            "2": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     NullValueException,"
            },
            "3": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    QueryClauseValidationException,"
            },
            "4": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     QueryObjectValidationError,"
            },
            "5": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     SpatialException,"
            },
            "6": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     SupersetSecurityException,"
            },
            "7": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " )"
            },
            "8": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " from superset.extensions import cache_manager, security_manager"
            },
            "9": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " from superset.models.helpers import QueryResult"
            },
            "10": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from superset.sql_parse import validate_filter_clause"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+from superset.sql_parse import sanitize_clause"
            },
            "12": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " from superset.typing import Metric, QueryObjectDict, VizData, VizPayload"
            },
            "13": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " from superset.utils import core as utils, csv"
            },
            "14": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " from superset.utils.cache import set_and_log_cache"
            },
            "15": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "         for param in (\"where\", \"having\"):"
            },
            "16": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "             clause = self.form_data.get(param)"
            },
            "17": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "             if clause:"
            },
            "18": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "19": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    validate_filter_clause(clause)"
            },
            "20": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except QueryClauseValidationException as ex:"
            },
            "21": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise QueryObjectValidationError(ex.message) from ex"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+                sanitized_clause = sanitize_clause(clause)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+                if sanitized_clause != clause:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+                    self.form_data[param] = sanitized_clause"
            },
            "25": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 365,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "         # extras are used to query elements specific to a datasource type"
            },
            "27": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "         # for instance the extra where clause that applies only to Tables"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "# pylint: disable=too-many-lines",
            "\"\"\"This module contains the 'Viz' objects",
            "",
            "These objects represent the backend of all the visualizations that",
            "Superset can render.",
            "\"\"\"",
            "import copy",
            "import dataclasses",
            "import logging",
            "import math",
            "import re",
            "from collections import defaultdict, OrderedDict",
            "from datetime import date, datetime, timedelta",
            "from itertools import product",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    cast,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TYPE_CHECKING,",
            "    Union,",
            ")",
            "",
            "import geohash",
            "import numpy as np",
            "import pandas as pd",
            "import polyline",
            "import simplejson as json",
            "from dateutil import relativedelta as rdelta",
            "from flask import request",
            "from flask_babel import lazy_gettext as _",
            "from geopy.point import Point",
            "from pandas.tseries.frequencies import to_offset",
            "",
            "from superset import app, is_feature_enabled",
            "from superset.common.db_query_status import QueryStatus",
            "from superset.constants import NULL_STRING",
            "from superset.errors import ErrorLevel, SupersetError, SupersetErrorType",
            "from superset.exceptions import (",
            "    CacheLoadError,",
            "    NullValueException,",
            "    QueryClauseValidationException,",
            "    QueryObjectValidationError,",
            "    SpatialException,",
            "    SupersetSecurityException,",
            ")",
            "from superset.extensions import cache_manager, security_manager",
            "from superset.models.helpers import QueryResult",
            "from superset.sql_parse import validate_filter_clause",
            "from superset.typing import Metric, QueryObjectDict, VizData, VizPayload",
            "from superset.utils import core as utils, csv",
            "from superset.utils.cache import set_and_log_cache",
            "from superset.utils.core import (",
            "    apply_max_row_limit,",
            "    DTTM_ALIAS,",
            "    ExtraFiltersReasonType,",
            "    JS_MAX_INTEGER,",
            "    merge_extra_filters,",
            "    QueryMode,",
            "    simple_filter_to_adhoc,",
            ")",
            "from superset.utils.date_parser import get_since_until, parse_past_timedelta",
            "from superset.utils.dates import datetime_to_epoch",
            "from superset.utils.hashing import md5_sha_from_str",
            "",
            "if TYPE_CHECKING:",
            "    from superset.connectors.base.models import BaseDatasource",
            "",
            "config = app.config",
            "stats_logger = config[\"STATS_LOGGER\"]",
            "relative_start = config[\"DEFAULT_RELATIVE_START_TIME\"]",
            "relative_end = config[\"DEFAULT_RELATIVE_END_TIME\"]",
            "logger = logging.getLogger(__name__)",
            "",
            "METRIC_KEYS = [",
            "    \"metric\",",
            "    \"metrics\",",
            "    \"percent_metrics\",",
            "    \"metric_2\",",
            "    \"secondary_metric\",",
            "    \"x\",",
            "    \"y\",",
            "    \"size\",",
            "]",
            "",
            "",
            "class BaseViz:  # pylint: disable=too-many-public-methods",
            "",
            "    \"\"\"All visualizations derive this base class\"\"\"",
            "",
            "    viz_type: Optional[str] = None",
            "    verbose_name = \"Base Viz\"",
            "    credits = \"\"",
            "    is_timeseries = False",
            "    cache_type = \"df\"",
            "    enforce_numerical_metrics = True",
            "",
            "    def __init__(",
            "        self,",
            "        datasource: \"BaseDatasource\",",
            "        form_data: Dict[str, Any],",
            "        force: bool = False,",
            "        force_cached: bool = False,",
            "    ) -> None:",
            "        if not datasource:",
            "            raise QueryObjectValidationError(_(\"Viz is missing a datasource\"))",
            "",
            "        self.datasource = datasource",
            "        self.request = request",
            "        self.viz_type = form_data.get(\"viz_type\")",
            "        self.form_data = form_data",
            "",
            "        self.query = \"\"",
            "        self.token = utils.get_form_data_token(form_data)",
            "",
            "        self.groupby: List[str] = self.form_data.get(\"groupby\") or []",
            "        self.time_shift = timedelta()",
            "",
            "        self.status: Optional[str] = None",
            "        self.error_msg = \"\"",
            "        self.results: Optional[QueryResult] = None",
            "        self.applied_template_filters: List[str] = []",
            "        self.errors: List[Dict[str, Any]] = []",
            "        self.force = force",
            "        self._force_cached = force_cached",
            "        self.from_dttm: Optional[datetime] = None",
            "        self.to_dttm: Optional[datetime] = None",
            "        self._extra_chart_data: List[Tuple[str, pd.DataFrame]] = []",
            "",
            "        self.process_metrics()",
            "",
            "        self.applied_filters: List[Dict[str, str]] = []",
            "        self.rejected_filters: List[Dict[str, str]] = []",
            "",
            "    @property",
            "    def force_cached(self) -> bool:",
            "        return self._force_cached",
            "",
            "    def process_metrics(self) -> None:",
            "        # metrics in Viz is order sensitive, so metric_dict should be",
            "        # OrderedDict",
            "        self.metric_dict = OrderedDict()",
            "        for mkey in METRIC_KEYS:",
            "            val = self.form_data.get(mkey)",
            "            if val:",
            "                if not isinstance(val, list):",
            "                    val = [val]",
            "                for o in val:",
            "                    label = utils.get_metric_name(o)",
            "                    self.metric_dict[label] = o",
            "",
            "        # Cast to list needed to return serializable object in py3",
            "        self.all_metrics = list(self.metric_dict.values())",
            "        self.metric_labels = list(self.metric_dict.keys())",
            "",
            "    @staticmethod",
            "    def handle_js_int_overflow(",
            "        data: Dict[str, List[Dict[str, Any]]]",
            "    ) -> Dict[str, List[Dict[str, Any]]]:",
            "        for record in data.get(\"records\", {}):",
            "            for k, v in list(record.items()):",
            "                if isinstance(v, int):",
            "                    # if an int is too big for Java Script to handle",
            "                    # convert it to a string",
            "                    if abs(v) > JS_MAX_INTEGER:",
            "                        record[k] = str(v)",
            "        return data",
            "",
            "    def run_extra_queries(self) -> None:",
            "        \"\"\"Lifecycle method to use when more than one query is needed",
            "",
            "        In rare-ish cases, a visualization may need to execute multiple",
            "        queries. That is the case for FilterBox or for time comparison",
            "        in Line chart for instance.",
            "",
            "        In those cases, we need to make sure these queries run before the",
            "        main `get_payload` method gets called, so that the overall caching",
            "        metadata can be right. The way it works here is that if any of",
            "        the previous `get_df_payload` calls hit the cache, the main",
            "        payload's metadata will reflect that.",
            "",
            "        The multi-query support may need more work to become a first class",
            "        use case in the framework, and for the UI to reflect the subtleties",
            "        (show that only some of the queries were served from cache for",
            "        instance). In the meantime, since multi-query is rare, we treat",
            "        it with a bit of a hack. Note that the hack became necessary",
            "        when moving from caching the visualization's data itself, to caching",
            "        the underlying query(ies).",
            "        \"\"\"",
            "",
            "    def apply_rolling(self, df: pd.DataFrame) -> pd.DataFrame:",
            "        rolling_type = self.form_data.get(\"rolling_type\")",
            "        rolling_periods = int(self.form_data.get(\"rolling_periods\") or 0)",
            "        min_periods = int(self.form_data.get(\"min_periods\") or 0)",
            "",
            "        if rolling_type in (\"mean\", \"std\", \"sum\") and rolling_periods:",
            "            kwargs = dict(window=rolling_periods, min_periods=min_periods)",
            "            if rolling_type == \"mean\":",
            "                df = df.rolling(**kwargs).mean()",
            "            elif rolling_type == \"std\":",
            "                df = df.rolling(**kwargs).std()",
            "            elif rolling_type == \"sum\":",
            "                df = df.rolling(**kwargs).sum()",
            "        elif rolling_type == \"cumsum\":",
            "            df = df.cumsum()",
            "        if min_periods:",
            "            df = df[min_periods:]",
            "        if df.empty:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Applied rolling window did not return any data. Please make sure \"",
            "                    \"the source query satisfies the minimum periods defined in the \"",
            "                    \"rolling window.\"",
            "                )",
            "            )",
            "        return df",
            "",
            "    def get_samples(self) -> List[Dict[str, Any]]:",
            "        query_obj = self.query_obj()",
            "        query_obj.update(",
            "            {",
            "                \"is_timeseries\": False,",
            "                \"groupby\": [],",
            "                \"metrics\": [],",
            "                \"orderby\": [],",
            "                \"row_limit\": config[\"SAMPLES_ROW_LIMIT\"],",
            "                \"columns\": [o.column_name for o in self.datasource.columns],",
            "            }",
            "        )",
            "        df = self.get_df_payload(query_obj)[\"df\"]  # leverage caching logic",
            "        return df.to_dict(orient=\"records\")",
            "",
            "    def get_df(self, query_obj: Optional[QueryObjectDict] = None) -> pd.DataFrame:",
            "        \"\"\"Returns a pandas dataframe based on the query object\"\"\"",
            "        if not query_obj:",
            "            query_obj = self.query_obj()",
            "        if not query_obj:",
            "            return pd.DataFrame()",
            "",
            "        self.error_msg = \"\"",
            "",
            "        timestamp_format = None",
            "        if self.datasource.type == \"table\":",
            "            granularity_col = self.datasource.get_column(query_obj[\"granularity\"])",
            "            if granularity_col:",
            "                timestamp_format = granularity_col.python_date_format",
            "",
            "        # The datasource here can be different backend but the interface is common",
            "        self.results = self.datasource.query(query_obj)",
            "        self.applied_template_filters = self.results.applied_template_filters or []",
            "        self.query = self.results.query",
            "        self.status = self.results.status",
            "        self.errors = self.results.errors",
            "",
            "        df = self.results.df",
            "        # Transform the timestamp we received from database to pandas supported",
            "        # datetime format. If no python_date_format is specified, the pattern will",
            "        # be considered as the default ISO date format",
            "        # If the datetime format is unix, the parse will use the corresponding",
            "        # parsing logic.",
            "        if not df.empty:",
            "            utils.normalize_dttm_col(",
            "                df=df,",
            "                timestamp_format=timestamp_format,",
            "                offset=self.datasource.offset,",
            "                time_shift=self.time_shift,",
            "            )",
            "",
            "            if self.enforce_numerical_metrics:",
            "                self.df_metrics_to_num(df)",
            "",
            "            df.replace([np.inf, -np.inf], np.nan, inplace=True)",
            "        return df",
            "",
            "    def df_metrics_to_num(self, df: pd.DataFrame) -> None:",
            "        \"\"\"Converting metrics to numeric when pandas.read_sql cannot\"\"\"",
            "        metrics = self.metric_labels",
            "        for col, dtype in df.dtypes.items():",
            "            if dtype.type == np.object_ and col in metrics:",
            "                df[col] = pd.to_numeric(df[col], errors=\"coerce\")",
            "",
            "    def process_query_filters(self) -> None:",
            "        utils.convert_legacy_filters_into_adhoc(self.form_data)",
            "        merge_extra_filters(self.form_data)",
            "        utils.split_adhoc_filters_into_base_filters(self.form_data)",
            "",
            "    def query_obj(self) -> QueryObjectDict:  # pylint: disable=too-many-locals",
            "        \"\"\"Building a query object\"\"\"",
            "        self.process_query_filters()",
            "",
            "        gb = self.groupby",
            "        metrics = self.all_metrics or []",
            "        columns = self.form_data.get(\"columns\") or []",
            "        # merge list and dedup while preserving order",
            "        groupby = list(OrderedDict.fromkeys(gb + columns))",
            "",
            "        is_timeseries = self.is_timeseries",
            "        if DTTM_ALIAS in groupby:",
            "            groupby.remove(DTTM_ALIAS)",
            "            is_timeseries = True",
            "",
            "        granularity = self.form_data.get(\"granularity\") or self.form_data.get(",
            "            \"granularity_sqla\"",
            "        )",
            "        limit = int(self.form_data.get(\"limit\") or 0)",
            "        timeseries_limit_metric = self.form_data.get(\"timeseries_limit_metric\")",
            "",
            "        # apply row limit to query",
            "        row_limit = int(self.form_data.get(\"row_limit\") or config[\"ROW_LIMIT\"])",
            "        row_limit = apply_max_row_limit(row_limit)",
            "",
            "        # default order direction",
            "        order_desc = self.form_data.get(\"order_desc\", True)",
            "",
            "        try:",
            "            since, until = get_since_until(",
            "                relative_start=relative_start,",
            "                relative_end=relative_end,",
            "                time_range=self.form_data.get(\"time_range\"),",
            "                since=self.form_data.get(\"since\"),",
            "                until=self.form_data.get(\"until\"),",
            "            )",
            "        except ValueError as ex:",
            "            raise QueryObjectValidationError(str(ex)) from ex",
            "",
            "        time_shift = self.form_data.get(\"time_shift\", \"\")",
            "        self.time_shift = parse_past_timedelta(time_shift)",
            "        from_dttm = None if since is None else (since - self.time_shift)",
            "        to_dttm = None if until is None else (until - self.time_shift)",
            "        if from_dttm and to_dttm and from_dttm > to_dttm:",
            "            raise QueryObjectValidationError(",
            "                _(\"From date cannot be larger than to date\")",
            "            )",
            "",
            "        self.from_dttm = from_dttm",
            "        self.to_dttm = to_dttm",
            "",
            "        # validate sql filters",
            "        for param in (\"where\", \"having\"):",
            "            clause = self.form_data.get(param)",
            "            if clause:",
            "                try:",
            "                    validate_filter_clause(clause)",
            "                except QueryClauseValidationException as ex:",
            "                    raise QueryObjectValidationError(ex.message) from ex",
            "",
            "        # extras are used to query elements specific to a datasource type",
            "        # for instance the extra where clause that applies only to Tables",
            "        extras = {",
            "            \"druid_time_origin\": self.form_data.get(\"druid_time_origin\", \"\"),",
            "            \"having\": self.form_data.get(\"having\", \"\"),",
            "            \"having_druid\": self.form_data.get(\"having_filters\", []),",
            "            \"time_grain_sqla\": self.form_data.get(\"time_grain_sqla\"),",
            "            \"time_range_endpoints\": self.form_data.get(\"time_range_endpoints\"),",
            "            \"where\": self.form_data.get(\"where\", \"\"),",
            "        }",
            "",
            "        return {",
            "            \"granularity\": granularity,",
            "            \"from_dttm\": from_dttm,",
            "            \"to_dttm\": to_dttm,",
            "            \"is_timeseries\": is_timeseries,",
            "            \"groupby\": groupby,",
            "            \"metrics\": metrics,",
            "            \"row_limit\": row_limit,",
            "            \"filter\": self.form_data.get(\"filters\", []),",
            "            \"timeseries_limit\": limit,",
            "            \"extras\": extras,",
            "            \"timeseries_limit_metric\": timeseries_limit_metric,",
            "            \"order_desc\": order_desc,",
            "        }",
            "",
            "    @property",
            "    def cache_timeout(self) -> int:",
            "        if self.form_data.get(\"cache_timeout\") is not None:",
            "            return int(self.form_data[\"cache_timeout\"])",
            "        if self.datasource.cache_timeout is not None:",
            "            return self.datasource.cache_timeout",
            "        if (",
            "            hasattr(self.datasource, \"database\")",
            "            and self.datasource.database.cache_timeout",
            "        ) is not None:",
            "            return self.datasource.database.cache_timeout",
            "        if config[\"DATA_CACHE_CONFIG\"].get(\"CACHE_DEFAULT_TIMEOUT\") is not None:",
            "            return config[\"DATA_CACHE_CONFIG\"][\"CACHE_DEFAULT_TIMEOUT\"]",
            "        return config[\"CACHE_DEFAULT_TIMEOUT\"]",
            "",
            "    def get_json(self) -> str:",
            "        return json.dumps(",
            "            self.get_payload(), default=utils.json_int_dttm_ser, ignore_nan=True",
            "        )",
            "",
            "    def cache_key(self, query_obj: QueryObjectDict, **extra: Any) -> str:",
            "        \"\"\"",
            "        The cache key is made out of the key/values in `query_obj`, plus any",
            "        other key/values in `extra`.",
            "",
            "        We remove datetime bounds that are hard values, and replace them with",
            "        the use-provided inputs to bounds, which may be time-relative (as in",
            "        \"5 days ago\" or \"now\").",
            "",
            "        The `extra` arguments are currently used by time shift queries, since",
            "        different time shifts wil differ only in the `from_dttm`, `to_dttm`,",
            "        `inner_from_dttm`, and `inner_to_dttm` values which are stripped.",
            "        \"\"\"",
            "        cache_dict = copy.copy(query_obj)",
            "        cache_dict.update(extra)",
            "",
            "        for k in [\"from_dttm\", \"to_dttm\", \"inner_from_dttm\", \"inner_to_dttm\"]:",
            "            if k in cache_dict:",
            "                del cache_dict[k]",
            "",
            "        cache_dict[\"time_range\"] = self.form_data.get(\"time_range\")",
            "        cache_dict[\"datasource\"] = self.datasource.uid",
            "        cache_dict[\"extra_cache_keys\"] = self.datasource.get_extra_cache_keys(query_obj)",
            "        cache_dict[\"rls\"] = (",
            "            security_manager.get_rls_ids(self.datasource)",
            "            if is_feature_enabled(\"ROW_LEVEL_SECURITY\")",
            "            and self.datasource.is_rls_supported",
            "            else []",
            "        )",
            "        cache_dict[\"changed_on\"] = self.datasource.changed_on",
            "        json_data = self.json_dumps(cache_dict, sort_keys=True)",
            "        return md5_sha_from_str(json_data)",
            "",
            "    def get_payload(self, query_obj: Optional[QueryObjectDict] = None) -> VizPayload:",
            "        \"\"\"Returns a payload of metadata and data\"\"\"",
            "",
            "        try:",
            "            self.run_extra_queries()",
            "        except SupersetSecurityException as ex:",
            "            error = dataclasses.asdict(ex.error)",
            "            self.errors.append(error)",
            "            self.status = QueryStatus.FAILED",
            "",
            "        payload = self.get_df_payload(query_obj)",
            "",
            "        # if payload does not have a df, we are raising an error here.",
            "        df = cast(Optional[pd.DataFrame], payload[\"df\"])",
            "",
            "        if self.status != QueryStatus.FAILED:",
            "            payload[\"data\"] = self.get_data(df)",
            "        if \"df\" in payload:",
            "            del payload[\"df\"]",
            "",
            "        filters = self.form_data.get(\"filters\", [])",
            "        filter_columns = [flt.get(\"col\") for flt in filters]",
            "        columns = set(self.datasource.column_names)",
            "        applied_template_filters = self.applied_template_filters or []",
            "        applied_time_extras = self.form_data.get(\"applied_time_extras\", {})",
            "        applied_time_columns, rejected_time_columns = utils.get_time_filter_status(",
            "            self.datasource, applied_time_extras",
            "        )",
            "        payload[\"applied_filters\"] = [",
            "            {\"column\": col}",
            "            for col in filter_columns",
            "            if col in columns or col in applied_template_filters",
            "        ] + applied_time_columns",
            "        payload[\"rejected_filters\"] = [",
            "            {\"reason\": ExtraFiltersReasonType.COL_NOT_IN_DATASOURCE, \"column\": col}",
            "            for col in filter_columns",
            "            if col not in columns and col not in applied_template_filters",
            "        ] + rejected_time_columns",
            "        if df is not None:",
            "            payload[\"colnames\"] = list(df.columns)",
            "        return payload",
            "",
            "    def get_df_payload(  # pylint: disable=too-many-statements",
            "        self, query_obj: Optional[QueryObjectDict] = None, **kwargs: Any",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"Handles caching around the df payload retrieval\"\"\"",
            "        if not query_obj:",
            "            query_obj = self.query_obj()",
            "        cache_key = self.cache_key(query_obj, **kwargs) if query_obj else None",
            "        cache_value = None",
            "        logger.info(\"Cache key: %s\", cache_key)",
            "        is_loaded = False",
            "        stacktrace = None",
            "        df = None",
            "        if cache_key and cache_manager.data_cache and not self.force:",
            "            cache_value = cache_manager.data_cache.get(cache_key)",
            "            if cache_value:",
            "                stats_logger.incr(\"loading_from_cache\")",
            "                try:",
            "                    df = cache_value[\"df\"]",
            "                    self.query = cache_value[\"query\"]",
            "                    self.applied_template_filters = cache_value.get(",
            "                        \"applied_template_filters\", []",
            "                    )",
            "                    self.status = QueryStatus.SUCCESS",
            "                    is_loaded = True",
            "                    stats_logger.incr(\"loaded_from_cache\")",
            "                except Exception as ex:  # pylint: disable=broad-except",
            "                    logger.exception(ex)",
            "                    logger.error(",
            "                        \"Error reading cache: %s\",",
            "                        utils.error_msg_from_exception(ex),",
            "                        exc_info=True,",
            "                    )",
            "                logger.info(\"Serving from cache\")",
            "",
            "        if query_obj and not is_loaded:",
            "            if self.force_cached:",
            "                logger.warning(",
            "                    \"force_cached (viz.py): value not found for cache key %s\",",
            "                    cache_key,",
            "                )",
            "                raise CacheLoadError(_(\"Cached value not found\"))",
            "            try:",
            "                invalid_columns = [",
            "                    col",
            "                    for col in (query_obj.get(\"columns\") or [])",
            "                    + (query_obj.get(\"groupby\") or [])",
            "                    + utils.get_column_names_from_metrics(",
            "                        cast(List[Metric], query_obj.get(\"metrics\") or [],)",
            "                    )",
            "                    if col not in self.datasource.column_names",
            "                ]",
            "                if invalid_columns:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Columns missing in datasource: %(invalid_columns)s\",",
            "                            invalid_columns=invalid_columns,",
            "                        )",
            "                    )",
            "                df = self.get_df(query_obj)",
            "                if self.status != QueryStatus.FAILED:",
            "                    stats_logger.incr(\"loaded_from_source\")",
            "                    if not self.force:",
            "                        stats_logger.incr(\"loaded_from_source_without_force\")",
            "                    is_loaded = True",
            "            except QueryObjectValidationError as ex:",
            "                error = dataclasses.asdict(",
            "                    SupersetError(",
            "                        message=str(ex),",
            "                        level=ErrorLevel.ERROR,",
            "                        error_type=SupersetErrorType.VIZ_GET_DF_ERROR,",
            "                    )",
            "                )",
            "                self.errors.append(error)",
            "                self.status = QueryStatus.FAILED",
            "            except Exception as ex:  # pylint: disable=broad-except",
            "                logger.exception(ex)",
            "",
            "                error = dataclasses.asdict(",
            "                    SupersetError(",
            "                        message=str(ex),",
            "                        level=ErrorLevel.ERROR,",
            "                        error_type=SupersetErrorType.VIZ_GET_DF_ERROR,",
            "                    )",
            "                )",
            "                self.errors.append(error)",
            "                self.status = QueryStatus.FAILED",
            "                stacktrace = utils.get_stacktrace()",
            "",
            "            if is_loaded and cache_key and self.status != QueryStatus.FAILED:",
            "                set_and_log_cache(",
            "                    cache_manager.data_cache,",
            "                    cache_key,",
            "                    {\"df\": df, \"query\": self.query},",
            "                    self.cache_timeout,",
            "                    self.datasource.uid,",
            "                )",
            "        return {",
            "            \"cache_key\": cache_key,",
            "            \"cached_dttm\": cache_value[\"dttm\"] if cache_value is not None else None,",
            "            \"cache_timeout\": self.cache_timeout,",
            "            \"df\": df,",
            "            \"errors\": self.errors,",
            "            \"form_data\": self.form_data,",
            "            \"is_cached\": cache_value is not None,",
            "            \"query\": self.query,",
            "            \"from_dttm\": self.from_dttm,",
            "            \"to_dttm\": self.to_dttm,",
            "            \"status\": self.status,",
            "            \"stacktrace\": stacktrace,",
            "            \"rowcount\": len(df.index) if df is not None else 0,",
            "        }",
            "",
            "    @staticmethod",
            "    def json_dumps(query_obj: Any, sort_keys: bool = False) -> str:",
            "        return json.dumps(",
            "            query_obj,",
            "            default=utils.json_int_dttm_ser,",
            "            ignore_nan=True,",
            "            sort_keys=sort_keys,",
            "        )",
            "",
            "    @staticmethod",
            "    def has_error(payload: VizPayload) -> bool:",
            "        return (",
            "            payload.get(\"status\") == QueryStatus.FAILED",
            "            or payload.get(\"error\") is not None",
            "            or bool(payload.get(\"errors\"))",
            "        )",
            "",
            "    def payload_json_and_has_error(self, payload: VizPayload) -> Tuple[str, bool]:",
            "        return self.json_dumps(payload), self.has_error(payload)",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        \"\"\"This is the data object serialized to the js layer\"\"\"",
            "        content = {",
            "            \"form_data\": self.form_data,",
            "            \"token\": self.token,",
            "            \"viz_name\": self.viz_type,",
            "            \"filter_select_enabled\": self.datasource.filter_select_enabled,",
            "        }",
            "        return content",
            "",
            "    def get_csv(self) -> Optional[str]:",
            "        df = self.get_df_payload()[\"df\"]  # leverage caching logic",
            "        include_index = not isinstance(df.index, pd.RangeIndex)",
            "        return csv.df_to_escaped_csv(df, index=include_index, **config[\"CSV_EXPORT\"])",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:  # pylint: disable=no-self-use",
            "        return df.to_dict(orient=\"records\")",
            "",
            "    @property",
            "    def json_data(self) -> str:",
            "        return json.dumps(self.data)",
            "",
            "    def raise_for_access(self) -> None:",
            "        \"\"\"",
            "        Raise an exception if the user cannot access the resource.",
            "",
            "        :raises SupersetSecurityException: If the user cannot access the resource",
            "        \"\"\"",
            "",
            "        security_manager.raise_for_access(viz=self)",
            "",
            "",
            "class TableViz(BaseViz):",
            "",
            "    \"\"\"A basic html table that is sortable and searchable\"\"\"",
            "",
            "    viz_type = \"table\"",
            "    verbose_name = _(\"Table View\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = False",
            "    enforce_numerical_metrics = False",
            "",
            "    def process_metrics(self) -> None:",
            "        \"\"\"Process form data and store parsed column configs.",
            "        1. Determine query mode based on form_data params.",
            "             - Use `query_mode` if it has a valid value",
            "             - Set as RAW mode if `all_columns` is set",
            "             - Otherwise defaults to AGG mode",
            "        2. Determine output columns based on query mode.",
            "        \"\"\"",
            "        # Verify form data first: if not specifying query mode, then cannot have both",
            "        # GROUP BY and RAW COLUMNS.",
            "        if (",
            "            not self.form_data.get(\"query_mode\")",
            "            and self.form_data.get(\"all_columns\")",
            "            and (",
            "                self.form_data.get(\"groupby\")",
            "                or self.form_data.get(\"metrics\")",
            "                or self.form_data.get(\"percent_metrics\")",
            "            )",
            "        ):",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"You cannot use [Columns] in combination with \"",
            "                    \"[Group By]/[Metrics]/[Percentage Metrics]. \"",
            "                    \"Please choose one or the other.\"",
            "                )",
            "            )",
            "",
            "        super().process_metrics()",
            "",
            "        self.query_mode: QueryMode = QueryMode.get(",
            "            self.form_data.get(\"query_mode\")",
            "        ) or (",
            "            # infer query mode from the presence of other fields",
            "            QueryMode.RAW",
            "            if len(self.form_data.get(\"all_columns\") or []) > 0",
            "            else QueryMode.AGGREGATE",
            "        )",
            "",
            "        columns: List[str] = []  # output columns sans time and percent_metric column",
            "        percent_columns: List[str] = []  # percent columns that needs extra computation",
            "",
            "        if self.query_mode == QueryMode.RAW:",
            "            columns = utils.get_metric_names(self.form_data.get(\"all_columns\") or [])",
            "        else:",
            "            columns = utils.get_metric_names(",
            "                self.groupby + (self.form_data.get(\"metrics\") or [])",
            "            )",
            "            percent_columns = utils.get_metric_names(",
            "                self.form_data.get(\"percent_metrics\") or []",
            "            )",
            "",
            "        self.columns = columns",
            "        self.percent_columns = percent_columns",
            "        self.is_timeseries = self.should_be_timeseries()",
            "",
            "    def should_be_timeseries(self) -> bool:",
            "        # TODO handle datasource-type-specific code in datasource",
            "        conditions_met = (",
            "            self.form_data.get(\"granularity\")",
            "            and self.form_data.get(\"granularity\") != \"all\"",
            "        ) or (",
            "            self.form_data.get(\"granularity_sqla\")",
            "            and self.form_data.get(\"time_grain_sqla\")",
            "        )",
            "        if self.form_data.get(\"include_time\") and not conditions_met:",
            "            raise QueryObjectValidationError(",
            "                _(\"Pick a granularity in the Time section or \" \"uncheck 'Include Time'\")",
            "            )",
            "        return bool(self.form_data.get(\"include_time\"))",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        if self.query_mode == QueryMode.RAW:",
            "            query_obj[\"columns\"] = self.form_data.get(\"all_columns\")",
            "            order_by_cols = self.form_data.get(\"order_by_cols\") or []",
            "            query_obj[\"orderby\"] = [json.loads(t) for t in order_by_cols]",
            "            # must disable groupby and metrics in raw mode",
            "            query_obj[\"groupby\"] = []",
            "            query_obj[\"metrics\"] = []",
            "            # raw mode does not support timeseries queries",
            "            query_obj[\"timeseries_limit_metric\"] = None",
            "            query_obj[\"timeseries_limit\"] = None",
            "            query_obj[\"is_timeseries\"] = None",
            "        else:",
            "            sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "            if sort_by:",
            "                sort_by_label = utils.get_metric_name(sort_by)",
            "                if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                    query_obj[\"metrics\"].append(sort_by)",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "            elif query_obj[\"metrics\"]:",
            "                # Legacy behavior of sorting by first metric by default",
            "                first_metric = query_obj[\"metrics\"][0]",
            "                query_obj[\"orderby\"] = [",
            "                    (first_metric, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        \"\"\"",
            "        Transform the query result to the table representation.",
            "",
            "        :param df: The interim dataframe",
            "        :returns: The table visualization data",
            "",
            "        The interim dataframe comprises of the group-by and non-group-by columns and",
            "        the union of the metrics representing the non-percent and percent metrics. Note",
            "        the percent metrics have yet to be transformed.",
            "        \"\"\"",
            "        # Transform the data frame to adhere to the UI ordering of the columns and",
            "        # metrics whilst simultaneously computing the percentages (via normalization)",
            "        # for the percent metrics.",
            "        if df.empty:",
            "            return None",
            "",
            "        columns, percent_columns = self.columns, self.percent_columns",
            "        if DTTM_ALIAS in df and self.is_timeseries:",
            "            columns = [DTTM_ALIAS] + columns",
            "        df = pd.concat(",
            "            [",
            "                df[columns],",
            "                (df[percent_columns].div(df[percent_columns].sum()).add_prefix(\"%\")),",
            "            ],",
            "            axis=1,",
            "        )",
            "        return self.handle_js_int_overflow(",
            "            dict(records=df.to_dict(orient=\"records\"), columns=list(df.columns))",
            "        )",
            "",
            "    @staticmethod",
            "    def json_dumps(query_obj: Any, sort_keys: bool = False) -> str:",
            "        return json.dumps(",
            "            query_obj,",
            "            default=utils.json_iso_dttm_ser,",
            "            sort_keys=sort_keys,",
            "            ignore_nan=True,",
            "        )",
            "",
            "",
            "class TimeTableViz(BaseViz):",
            "",
            "    \"\"\"A data table with rich time-series related columns\"\"\"",
            "",
            "    viz_type = \"time_table\"",
            "    verbose_name = _(\"Time Table View\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "",
            "        if not self.form_data.get(\"metrics\"):",
            "            raise QueryObjectValidationError(_(\"Pick at least one metric\"))",
            "",
            "        if self.form_data.get(\"groupby\") and len(self.form_data[\"metrics\"]) > 1:",
            "            raise QueryObjectValidationError(",
            "                _(\"When using 'Group By' you are limited to use a single metric\")",
            "            )",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        columns = None",
            "        values: Union[List[str], str] = self.metric_labels",
            "        if self.form_data.get(\"groupby\"):",
            "            values = self.metric_labels[0]",
            "            columns = self.form_data.get(\"groupby\")",
            "        pt = df.pivot_table(index=DTTM_ALIAS, columns=columns, values=values)",
            "        pt.index = pt.index.map(str)",
            "        pt = pt.sort_index()",
            "        return dict(",
            "            records=pt.to_dict(orient=\"index\"),",
            "            columns=list(pt.columns),",
            "            is_group_by=bool(self.form_data.get(\"groupby\")),",
            "        )",
            "",
            "",
            "class PivotTableViz(BaseViz):",
            "",
            "    \"\"\"A pivot table view, define your rows, columns and metrics\"\"\"",
            "",
            "    viz_type = \"pivot_table\"",
            "    verbose_name = _(\"Pivot Table\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = False",
            "    enforce_numerical_metrics = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        groupby = self.form_data.get(\"groupby\")",
            "        columns = self.form_data.get(\"columns\")",
            "        metrics = self.form_data.get(\"metrics\")",
            "        transpose = self.form_data.get(\"transpose_pivot\")",
            "        if not columns:",
            "            columns = []",
            "        if not groupby:",
            "            groupby = []",
            "        if not groupby:",
            "            raise QueryObjectValidationError(",
            "                _(\"Please choose at least one 'Group by' field \")",
            "            )",
            "        if transpose and not columns:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    (",
            "                        \"Please choose at least one 'Columns' field when \"",
            "                        \"select 'Transpose Pivot' option\"",
            "                    )",
            "                )",
            "            )",
            "        if not metrics:",
            "            raise QueryObjectValidationError(_(\"Please choose at least one metric\"))",
            "        if set(groupby) & set(columns):",
            "            raise QueryObjectValidationError(_(\"Group By' and 'Columns' can't overlap\"))",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            if self.form_data.get(\"order_desc\"):",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    @staticmethod",
            "    def get_aggfunc(",
            "        metric: str, df: pd.DataFrame, form_data: Dict[str, Any]",
            "    ) -> Union[str, Callable[[Any], Any]]:",
            "        aggfunc = form_data.get(\"pandas_aggfunc\") or \"sum\"",
            "        if pd.api.types.is_numeric_dtype(df[metric]):",
            "            # Ensure that Pandas's sum function mimics that of SQL.",
            "            if aggfunc == \"sum\":",
            "                return lambda x: x.sum(min_count=1)",
            "        # only min and max work properly for non-numerics",
            "        return aggfunc if aggfunc in (\"min\", \"max\") else \"max\"",
            "",
            "    @staticmethod",
            "    def _format_datetime(value: Union[pd.Timestamp, datetime, date, str]) -> str:",
            "        \"\"\"",
            "        Format a timestamp in such a way that the viz will be able to apply",
            "        the correct formatting in the frontend.",
            "",
            "        :param value: the value of a temporal column",
            "        :return: formatted timestamp if it is a valid timestamp, otherwise",
            "                 the original value",
            "        \"\"\"",
            "        tstamp: Optional[pd.Timestamp] = None",
            "        if isinstance(value, pd.Timestamp):",
            "            tstamp = value",
            "        if isinstance(value, (date, datetime)):",
            "            tstamp = pd.Timestamp(value)",
            "        if isinstance(value, str):",
            "            try:",
            "                tstamp = pd.Timestamp(value)",
            "            except ValueError:",
            "                pass",
            "        if tstamp:",
            "            return f\"__timestamp:{datetime_to_epoch(tstamp)}\"",
            "        # fallback in case something incompatible is returned",
            "        return cast(str, value)",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        if self.form_data.get(\"granularity\") == \"all\" and DTTM_ALIAS in df:",
            "            del df[DTTM_ALIAS]",
            "",
            "        metrics = [utils.get_metric_name(m) for m in self.form_data[\"metrics\"]]",
            "        aggfuncs: Dict[str, Union[str, Callable[[Any], Any]]] = {}",
            "        for metric in metrics:",
            "            aggfuncs[metric] = self.get_aggfunc(metric, df, self.form_data)",
            "",
            "        groupby = self.form_data.get(\"groupby\") or []",
            "        columns = self.form_data.get(\"columns\") or []",
            "",
            "        for column_name in groupby + columns:",
            "            column = self.datasource.get_column(column_name)",
            "            if column and column.is_temporal:",
            "                ts = df[column_name].apply(self._format_datetime)",
            "                df[column_name] = ts",
            "",
            "        if self.form_data.get(\"transpose_pivot\"):",
            "            groupby, columns = columns, groupby",
            "",
            "        df = df.pivot_table(",
            "            index=groupby,",
            "            columns=columns,",
            "            values=metrics,",
            "            aggfunc=aggfuncs,",
            "            margins=self.form_data.get(\"pivot_margins\"),",
            "        )",
            "",
            "        # Re-order the columns adhering to the metric ordering.",
            "        df = df[metrics]",
            "",
            "        # Display metrics side by side with each column",
            "        if self.form_data.get(\"combine_metric\"):",
            "            df = df.stack(0).unstack().reindex(level=-1, columns=metrics)",
            "        return dict(",
            "            columns=list(df.columns),",
            "            html=df.to_html(",
            "                na_rep=\"null\",",
            "                classes=(",
            "                    \"dataframe table table-striped table-bordered \"",
            "                    \"table-condensed table-hover\"",
            "                ).split(\" \"),",
            "            ),",
            "        )",
            "",
            "",
            "class TreemapViz(BaseViz):",
            "",
            "    \"\"\"Tree map visualisation for hierarchical data.\"\"\"",
            "",
            "    viz_type = \"treemap\"",
            "    verbose_name = _(\"Treemap\")",
            "    credits = '<a href=\"https://d3js.org\">d3.js</a>'",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            if self.form_data.get(\"order_desc\"):",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    def _nest(self, metric: str, df: pd.DataFrame) -> List[Dict[str, Any]]:",
            "        nlevels = df.index.nlevels",
            "        if nlevels == 1:",
            "            result = [{\"name\": n, \"value\": v} for n, v in zip(df.index, df[metric])]",
            "        else:",
            "            result = [",
            "                {\"name\": l, \"children\": self._nest(metric, df.loc[l])}",
            "                for l in df.index.levels[0]",
            "            ]",
            "        return result",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df = df.set_index(self.form_data.get(\"groupby\"))",
            "        chart_data = [",
            "            {\"name\": metric, \"children\": self._nest(metric, df)}",
            "            for metric in df.columns",
            "        ]",
            "        return chart_data",
            "",
            "",
            "class CalHeatmapViz(BaseViz):",
            "",
            "    \"\"\"Calendar heatmap.\"\"\"",
            "",
            "    viz_type = \"cal_heatmap\"",
            "    verbose_name = _(\"Calendar Heatmap\")",
            "    credits = \"<a href=https://github.com/wa0x6e/cal-heatmap>cal-heatmap</a>\"",
            "    is_timeseries = True",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:  # pylint: disable=too-many-locals",
            "        if df.empty:",
            "            return None",
            "",
            "        form_data = self.form_data",
            "        data = {}",
            "        records = df.to_dict(\"records\")",
            "        for metric in self.metric_labels:",
            "            values = {}",
            "            for query_obj in records:",
            "                v = query_obj[DTTM_ALIAS]",
            "                if hasattr(v, \"value\"):",
            "                    v = v.value",
            "                values[str(v / 10 ** 9)] = query_obj.get(metric)",
            "            data[metric] = values",
            "",
            "        try:",
            "            start, end = get_since_until(",
            "                relative_start=relative_start,",
            "                relative_end=relative_end,",
            "                time_range=form_data.get(\"time_range\"),",
            "                since=form_data.get(\"since\"),",
            "                until=form_data.get(\"until\"),",
            "            )",
            "        except ValueError as ex:",
            "            raise QueryObjectValidationError(str(ex)) from ex",
            "        if not start or not end:",
            "            raise QueryObjectValidationError(",
            "                \"Please provide both time bounds (Since and Until)\"",
            "            )",
            "        domain = form_data.get(\"domain_granularity\")",
            "        diff_delta = rdelta.relativedelta(end, start)",
            "        diff_secs = (end - start).total_seconds()",
            "",
            "        if domain == \"year\":",
            "            range_ = end.year - start.year + 1",
            "        elif domain == \"month\":",
            "            range_ = diff_delta.years * 12 + diff_delta.months + 1",
            "        elif domain == \"week\":",
            "            range_ = diff_delta.years * 53 + diff_delta.weeks + 1",
            "        elif domain == \"day\":",
            "            range_ = diff_secs // (24 * 60 * 60) + 1  # type: ignore",
            "        else:",
            "            range_ = diff_secs // (60 * 60) + 1  # type: ignore",
            "",
            "        return {",
            "            \"data\": data,",
            "            \"start\": start,",
            "            \"domain\": domain,",
            "            \"subdomain\": form_data.get(\"subdomain_granularity\"),",
            "            \"range\": range_,",
            "        }",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"metrics\"] = self.form_data.get(\"metrics\")",
            "        mapping = {",
            "            \"min\": \"PT1M\",",
            "            \"hour\": \"PT1H\",",
            "            \"day\": \"P1D\",",
            "            \"week\": \"P1W\",",
            "            \"month\": \"P1M\",",
            "            \"year\": \"P1Y\",",
            "        }",
            "        time_grain = mapping[self.form_data.get(\"subdomain_granularity\", \"min\")]",
            "        if self.datasource.type == \"druid\":",
            "            query_obj[\"granularity\"] = time_grain",
            "        else:",
            "            query_obj[\"extras\"][\"time_grain_sqla\"] = time_grain",
            "        return query_obj",
            "",
            "",
            "class NVD3Viz(BaseViz):",
            "",
            "    \"\"\"Base class for all nvd3 vizs\"\"\"",
            "",
            "    credits = '<a href=\"http://nvd3.org/\">NVD3.org</a>'",
            "    viz_type: Optional[str] = None",
            "    verbose_name = \"Base NVD3 Viz\"",
            "    is_timeseries = False",
            "",
            "",
            "class BubbleViz(NVD3Viz):",
            "",
            "    \"\"\"Based on the NVD3 bubble chart\"\"\"",
            "",
            "    viz_type = \"bubble\"",
            "    verbose_name = _(\"Bubble Chart\")",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"groupby\"] = [self.form_data.get(\"entity\")]",
            "        if self.form_data.get(\"series\"):",
            "            query_obj[\"groupby\"].append(self.form_data.get(\"series\"))",
            "",
            "        # dedup groupby if it happens to be the same",
            "        query_obj[\"groupby\"] = list(dict.fromkeys(query_obj[\"groupby\"]))",
            "",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.x_metric = self.form_data[\"x\"]",
            "        self.y_metric = self.form_data[\"y\"]",
            "        self.z_metric = self.form_data[\"size\"]",
            "        self.entity = self.form_data.get(\"entity\")",
            "        self.series = self.form_data.get(\"series\") or self.entity",
            "        query_obj[\"row_limit\"] = self.form_data.get(\"limit\")",
            "",
            "        query_obj[\"metrics\"] = [self.z_metric, self.x_metric, self.y_metric]",
            "        if len(set(self.metric_labels)) < 3:",
            "            raise QueryObjectValidationError(_(\"Please use 3 different metric labels\"))",
            "        if not all(query_obj[\"metrics\"] + [self.entity]):",
            "            raise QueryObjectValidationError(_(\"Pick a metric for x, y and size\"))",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df[\"x\"] = df[[utils.get_metric_name(self.x_metric)]]",
            "        df[\"y\"] = df[[utils.get_metric_name(self.y_metric)]]",
            "        df[\"size\"] = df[[utils.get_metric_name(self.z_metric)]]",
            "        df[\"shape\"] = \"circle\"",
            "        df[\"group\"] = df[[self.series]]",
            "",
            "        series: Dict[Any, List[Any]] = defaultdict(list)",
            "        for row in df.to_dict(orient=\"records\"):",
            "            series[row[\"group\"]].append(row)",
            "        chart_data = []",
            "        for k, v in series.items():",
            "            chart_data.append({\"key\": k, \"values\": v})",
            "        return chart_data",
            "",
            "",
            "class BulletViz(NVD3Viz):",
            "",
            "    \"\"\"Based on the NVD3 bullet chart\"\"\"",
            "",
            "    viz_type = \"bullet\"",
            "    verbose_name = _(\"Bullet Chart\")",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        form_data = self.form_data",
            "        query_obj = super().query_obj()",
            "        self.metric = form_data[  # pylint: disable=attribute-defined-outside-init",
            "            \"metric\"",
            "        ]",
            "",
            "        query_obj[\"metrics\"] = [self.metric]",
            "        if not self.metric:",
            "            raise QueryObjectValidationError(_(\"Pick a metric to display\"))",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        df[\"metric\"] = df[[utils.get_metric_name(self.metric)]]",
            "        values = df[\"metric\"].values",
            "        return {",
            "            \"measures\": values.tolist(),",
            "        }",
            "",
            "",
            "class BigNumberViz(BaseViz):",
            "",
            "    \"\"\"Put emphasis on a single metric with this big number viz\"\"\"",
            "",
            "    viz_type = \"big_number\"",
            "    verbose_name = _(\"Big Number with Trendline\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        metric = self.form_data.get(\"metric\")",
            "        if not metric:",
            "            raise QueryObjectValidationError(_(\"Pick a metric!\"))",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        self.form_data[\"metric\"] = metric",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df = df.pivot_table(",
            "            index=DTTM_ALIAS,",
            "            columns=[],",
            "            values=self.metric_labels,",
            "            dropna=False,",
            "            aggfunc=np.min,  # looking for any (only) value, preserving `None`",
            "        )",
            "        df = self.apply_rolling(df)",
            "        df[DTTM_ALIAS] = df.index",
            "        return super().get_data(df)",
            "",
            "",
            "class BigNumberTotalViz(BaseViz):",
            "",
            "    \"\"\"Put emphasis on a single metric with this big number viz\"\"\"",
            "",
            "    viz_type = \"big_number_total\"",
            "    verbose_name = _(\"Big Number\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        metric = self.form_data.get(\"metric\")",
            "        if not metric:",
            "            raise QueryObjectValidationError(_(\"Pick a metric!\"))",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        self.form_data[\"metric\"] = metric",
            "",
            "        # Limiting rows is not required as only one cell is returned",
            "        query_obj[\"row_limit\"] = None",
            "        return query_obj",
            "",
            "",
            "class NVD3TimeSeriesViz(NVD3Viz):",
            "",
            "    \"\"\"A rich line chart component with tons of options\"\"\"",
            "",
            "    viz_type = \"line\"",
            "    verbose_name = _(\"Time Series - Line Chart\")",
            "    sort_series = False",
            "    is_timeseries = True",
            "    pivot_fill_value: Optional[int] = None",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        sort_by = self.form_data.get(",
            "            \"timeseries_limit_metric\"",
            "        ) or utils.get_first_metric_name(query_obj.get(\"metrics\") or [])",
            "        is_asc = not self.form_data.get(\"order_desc\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            query_obj[\"orderby\"] = [(sort_by, is_asc)]",
            "        return query_obj",
            "",
            "    def to_series(  # pylint: disable=too-many-branches",
            "        self, df: pd.DataFrame, classed: str = \"\", title_suffix: str = \"\"",
            "    ) -> List[Dict[str, Any]]:",
            "        cols = []",
            "        for col in df.columns:",
            "            if col == \"\":",
            "                cols.append(\"N/A\")",
            "            elif col is None:",
            "                cols.append(\"NULL\")",
            "            else:",
            "                cols.append(col)",
            "        df.columns = cols",
            "        series = df.to_dict(\"series\")",
            "",
            "        chart_data = []",
            "        for name in df.T.index.tolist():",
            "            ys = series[name]",
            "            if df[name].dtype.kind not in \"biufc\":",
            "                continue",
            "            series_title: Union[List[str], str, Tuple[str, ...]]",
            "            if isinstance(name, list):",
            "                series_title = [str(title) for title in name]",
            "            elif isinstance(name, tuple):",
            "                series_title = tuple(str(title) for title in name)",
            "            else:",
            "                series_title = str(name)",
            "            if (",
            "                isinstance(series_title, (list, tuple))",
            "                and len(series_title) > 1",
            "                and len(self.metric_labels) == 1",
            "            ):",
            "                # Removing metric from series name if only one metric",
            "                series_title = series_title[1:]",
            "            if title_suffix:",
            "                if isinstance(series_title, str):",
            "                    series_title = (series_title, title_suffix)",
            "                elif isinstance(series_title, list):",
            "                    series_title = series_title + [title_suffix]",
            "                elif isinstance(series_title, tuple):",
            "                    series_title = series_title + (title_suffix,)",
            "",
            "            values = []",
            "            non_nan_cnt = 0",
            "            for ds in df.index:",
            "                if ds in ys:",
            "                    data = {\"x\": ds, \"y\": ys[ds]}",
            "                    if not np.isnan(ys[ds]):",
            "                        non_nan_cnt += 1",
            "                else:",
            "                    data = {}",
            "                values.append(data)",
            "",
            "            if non_nan_cnt == 0:",
            "                continue",
            "",
            "            data = {\"key\": series_title, \"values\": values}",
            "            if classed:",
            "                data[\"classed\"] = classed",
            "            chart_data.append(data)",
            "        return chart_data",
            "",
            "    def process_data(self, df: pd.DataFrame, aggregate: bool = False) -> VizData:",
            "        if self.form_data.get(\"granularity\") == \"all\":",
            "            raise QueryObjectValidationError(",
            "                _(\"Pick a time granularity for your time series\")",
            "            )",
            "",
            "        if df.empty:",
            "            return df",
            "",
            "        if aggregate:",
            "            df = df.pivot_table(",
            "                index=DTTM_ALIAS,",
            "                columns=self.form_data.get(\"groupby\"),",
            "                values=self.metric_labels,",
            "                fill_value=0,",
            "                aggfunc=sum,",
            "            )",
            "        else:",
            "            df = df.pivot_table(",
            "                index=DTTM_ALIAS,",
            "                columns=self.form_data.get(\"groupby\"),",
            "                values=self.metric_labels,",
            "                fill_value=self.pivot_fill_value,",
            "            )",
            "",
            "        rule = self.form_data.get(\"resample_rule\")",
            "        method = self.form_data.get(\"resample_method\")",
            "",
            "        if rule and method:",
            "            df = getattr(df.resample(rule), method)()",
            "",
            "        if self.sort_series:",
            "            dfs = df.sum()",
            "            dfs.sort_values(ascending=False, inplace=True)",
            "            df = df[dfs.index]",
            "",
            "        df = self.apply_rolling(df)",
            "        if self.form_data.get(\"contribution\"):",
            "            dft = df.T",
            "            df = (dft / dft.sum()).T",
            "",
            "        return df",
            "",
            "    def run_extra_queries(self) -> None:",
            "        time_compare = self.form_data.get(\"time_compare\") or []",
            "        # backwards compatibility",
            "        if not isinstance(time_compare, list):",
            "            time_compare = [time_compare]",
            "",
            "        for option in time_compare:",
            "            query_object = self.query_obj()",
            "            try:",
            "                delta = parse_past_timedelta(option)",
            "            except ValueError as ex:",
            "                raise QueryObjectValidationError(str(ex)) from ex",
            "            query_object[\"inner_from_dttm\"] = query_object[\"from_dttm\"]",
            "            query_object[\"inner_to_dttm\"] = query_object[\"to_dttm\"]",
            "",
            "            if not query_object[\"from_dttm\"] or not query_object[\"to_dttm\"]:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"An enclosed time range (both start and end) must be specified \"",
            "                        \"when using a Time Comparison.\"",
            "                    )",
            "                )",
            "            query_object[\"from_dttm\"] -= delta",
            "            query_object[\"to_dttm\"] -= delta",
            "",
            "            df2 = self.get_df_payload(query_object, time_compare=option).get(\"df\")",
            "            if df2 is not None and DTTM_ALIAS in df2:",
            "                dttm_series = df2[DTTM_ALIAS] + delta",
            "                df2 = df2.drop(DTTM_ALIAS, axis=1)",
            "                df2 = pd.concat([dttm_series, df2], axis=1)",
            "                label = \"{} offset\".format(option)",
            "                df2 = self.process_data(df2)",
            "                self._extra_chart_data.append((label, df2))",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        comparison_type = self.form_data.get(\"comparison_type\") or \"values\"",
            "        df = self.process_data(df)",
            "        if comparison_type == \"values\":",
            "            # Filter out series with all NaN",
            "            chart_data = self.to_series(df.dropna(axis=1, how=\"all\"))",
            "",
            "            for i, (label, df2) in enumerate(self._extra_chart_data):",
            "                chart_data.extend(",
            "                    self.to_series(",
            "                        df2, classed=\"time-shift-{}\".format(i), title_suffix=label",
            "                    )",
            "                )",
            "        else:",
            "            chart_data = []",
            "            for i, (label, df2) in enumerate(self._extra_chart_data):",
            "                # reindex df2 into the df2 index",
            "                combined_index = df.index.union(df2.index)",
            "                df2 = (",
            "                    df2.reindex(combined_index)",
            "                    .interpolate(method=\"time\")",
            "                    .reindex(df.index)",
            "                )",
            "",
            "                if comparison_type == \"absolute\":",
            "                    diff = df - df2",
            "                elif comparison_type == \"percentage\":",
            "                    diff = (df - df2) / df2",
            "                elif comparison_type == \"ratio\":",
            "                    diff = df / df2",
            "                else:",
            "                    raise QueryObjectValidationError(",
            "                        \"Invalid `comparison_type`: {0}\".format(comparison_type)",
            "                    )",
            "",
            "                # remove leading/trailing NaNs from the time shift difference",
            "                diff = diff[diff.first_valid_index() : diff.last_valid_index()]",
            "",
            "                chart_data.extend(",
            "                    self.to_series(",
            "                        diff, classed=\"time-shift-{}\".format(i), title_suffix=label",
            "                    )",
            "                )",
            "",
            "        if not self.sort_series:",
            "            chart_data = sorted(chart_data, key=lambda x: tuple(x[\"key\"]))",
            "        return chart_data",
            "",
            "",
            "class MultiLineViz(NVD3Viz):",
            "",
            "    \"\"\"Pile on multiple line charts\"\"\"",
            "",
            "    viz_type = \"line_multi\"",
            "    verbose_name = _(\"Time Series - Multiple Line Charts\")",
            "",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        return {}",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        # pylint: disable=import-outside-toplevel,too-many-locals",
            "        multiline_fd = self.form_data",
            "        # Late import to avoid circular import issues",
            "        from superset.charts.dao import ChartDAO",
            "",
            "        axis1_chart_ids = multiline_fd.get(\"line_charts\", [])",
            "        axis2_chart_ids = multiline_fd.get(\"line_charts_2\", [])",
            "        all_charts = {",
            "            chart.id: chart",
            "            for chart in ChartDAO.find_by_ids(axis1_chart_ids + axis2_chart_ids)",
            "        }",
            "        axis1_charts = [all_charts[chart_id] for chart_id in axis1_chart_ids]",
            "        axis2_charts = [all_charts[chart_id] for chart_id in axis2_chart_ids]",
            "",
            "        filters = multiline_fd.get(\"filters\", [])",
            "        add_prefix = multiline_fd.get(\"prefix_metric_with_slice_name\", False)",
            "        data = []",
            "        min_x, max_x = None, None",
            "",
            "        for chart, y_axis in [(chart, 1) for chart in axis1_charts] + [",
            "            (chart, 2) for chart in axis2_charts",
            "        ]:",
            "            prefix = f\"{chart.chart}: \" if add_prefix else \"\"",
            "            chart_fd = chart.form_data",
            "            chart_fd[\"filters\"] = chart_fd.get(\"filters\", []) + filters",
            "            if \"extra_filters\" in multiline_fd:",
            "                chart_fd[\"extra_filters\"] = multiline_fd[\"extra_filters\"]",
            "            if \"time_range\" in multiline_fd:",
            "                chart_fd[\"time_range\"] = multiline_fd[\"time_range\"]",
            "            viz_obj = viz_types[chart.viz_type](",
            "                chart.datasource,",
            "                form_data=chart_fd,",
            "                force=self.force,",
            "                force_cached=self.force_cached,",
            "            )",
            "            df = viz_obj.get_df_payload()[\"df\"]",
            "            chart_series = viz_obj.get_data(df) or []",
            "            for series in chart_series:",
            "                x_values = [value[\"x\"] for value in series[\"values\"]]",
            "                min_x = min(x_values + ([min_x] if min_x is not None else []))",
            "                max_x = max(x_values + ([max_x] if max_x is not None else []))",
            "                series_key = (",
            "                    series[\"key\"]",
            "                    if isinstance(series[\"key\"], (list, tuple))",
            "                    else [series[\"key\"]]",
            "                )",
            "                data.append(",
            "                    {",
            "                        \"key\": prefix + \", \".join(series_key),",
            "                        \"type\": \"line\",",
            "                        \"values\": series[\"values\"],",
            "                        \"yAxis\": y_axis,",
            "                    }",
            "                )",
            "        bounds = []",
            "        if min_x is not None:",
            "            bounds.append({\"x\": min_x, \"y\": None})",
            "        if max_x is not None:",
            "            bounds.append({\"x\": max_x, \"y\": None})",
            "",
            "        for series in data:",
            "            series[\"values\"].extend(bounds)",
            "        return data",
            "",
            "",
            "class NVD3DualLineViz(NVD3Viz):",
            "",
            "    \"\"\"A rich line chart with dual axis\"\"\"",
            "",
            "    viz_type = \"dual_line\"",
            "    verbose_name = _(\"Time Series - Dual Axis Line Chart\")",
            "    sort_series = False",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        m1 = self.form_data.get(\"metric\")",
            "        m2 = self.form_data.get(\"metric_2\")",
            "        if not m1:",
            "            raise QueryObjectValidationError(_(\"Pick a metric for left axis!\"))",
            "        if not m2:",
            "            raise QueryObjectValidationError(_(\"Pick a metric for right axis!\"))",
            "        if m1 == m2:",
            "            raise QueryObjectValidationError(",
            "                _(\"Please choose different metrics\" \" on left and right axis\")",
            "            )",
            "        query_obj[\"metrics\"] = [m1, m2]",
            "        return query_obj",
            "",
            "    def to_series(self, df: pd.DataFrame, classed: str = \"\") -> List[Dict[str, Any]]:",
            "        cols = []",
            "        for col in df.columns:",
            "            if col == \"\":",
            "                cols.append(\"N/A\")",
            "            elif col is None:",
            "                cols.append(\"NULL\")",
            "            else:",
            "                cols.append(col)",
            "        df.columns = cols",
            "        series = df.to_dict(\"series\")",
            "        chart_data = []",
            "        metrics = [self.form_data[\"metric\"], self.form_data[\"metric_2\"]]",
            "        for i, metric in enumerate(metrics):",
            "            metric_name = utils.get_metric_name(metric)",
            "            ys = series[metric_name]",
            "            if df[metric_name].dtype.kind not in \"biufc\":",
            "                continue",
            "            series_title = metric_name",
            "            chart_data.append(",
            "                {",
            "                    \"key\": series_title,",
            "                    \"classed\": classed,",
            "                    \"values\": [",
            "                        {\"x\": ds, \"y\": ys[ds] if ds in ys else None} for ds in df.index",
            "                    ],",
            "                    \"yAxis\": i + 1,",
            "                    \"type\": \"line\",",
            "                }",
            "            )",
            "        return chart_data",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        if self.form_data.get(\"granularity\") == \"all\":",
            "            raise QueryObjectValidationError(",
            "                _(\"Pick a time granularity for your time series\")",
            "            )",
            "",
            "        metric = utils.get_metric_name(self.form_data[\"metric\"])",
            "        metric_2 = utils.get_metric_name(self.form_data[\"metric_2\"])",
            "        df = df.pivot_table(index=DTTM_ALIAS, values=[metric, metric_2])",
            "",
            "        chart_data = self.to_series(df)",
            "        return chart_data",
            "",
            "",
            "class NVD3TimeSeriesBarViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"A bar chart where the x axis is time\"\"\"",
            "",
            "    viz_type = \"bar\"",
            "    sort_series = True",
            "    verbose_name = _(\"Time Series - Bar Chart\")",
            "",
            "",
            "class NVD3TimePivotViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"Time Series - Periodicity Pivot\"\"\"",
            "",
            "    viz_type = \"time_pivot\"",
            "    sort_series = True",
            "    verbose_name = _(\"Time Series - Period Pivot\")",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df = self.process_data(df)",
            "        freq = to_offset(self.form_data.get(\"freq\"))",
            "        try:",
            "            freq = type(freq)(freq.n, normalize=True, **freq.kwds)",
            "        except ValueError:",
            "            freq = type(freq)(freq.n, **freq.kwds)",
            "        df.index.name = None",
            "        df[DTTM_ALIAS] = df.index.map(freq.rollback)",
            "        df[\"ranked\"] = df[DTTM_ALIAS].rank(method=\"dense\", ascending=False) - 1",
            "        df.ranked = df.ranked.map(int)",
            "        df[\"series\"] = \"-\" + df.ranked.map(str)",
            "        df[\"series\"] = df[\"series\"].str.replace(\"-0\", \"current\")",
            "        rank_lookup = {",
            "            row[\"series\"]: row[\"ranked\"] for row in df.to_dict(orient=\"records\")",
            "        }",
            "        max_ts = df[DTTM_ALIAS].max()",
            "        max_rank = df[\"ranked\"].max()",
            "        df[DTTM_ALIAS] = df.index + (max_ts - df[DTTM_ALIAS])",
            "        df = df.pivot_table(",
            "            index=DTTM_ALIAS,",
            "            columns=\"series\",",
            "            values=utils.get_metric_name(self.form_data[\"metric\"]),",
            "        )",
            "        chart_data = self.to_series(df)",
            "        for serie in chart_data:",
            "            serie[\"rank\"] = rank_lookup[serie[\"key\"]]",
            "            serie[\"perc\"] = 1 - (serie[\"rank\"] / (max_rank + 1))",
            "        return chart_data",
            "",
            "",
            "class NVD3CompareTimeSeriesViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"A line chart component where you can compare the % change over time\"\"\"",
            "",
            "    viz_type = \"compare\"",
            "    verbose_name = _(\"Time Series - Percent Change\")",
            "",
            "",
            "class NVD3TimeSeriesStackedViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"A rich stack area chart\"\"\"",
            "",
            "    viz_type = \"area\"",
            "    verbose_name = _(\"Time Series - Stacked\")",
            "    sort_series = True",
            "    pivot_fill_value = 0",
            "",
            "",
            "class HistogramViz(BaseViz):",
            "",
            "    \"\"\"Histogram\"\"\"",
            "",
            "    viz_type = \"histogram\"",
            "    verbose_name = _(\"Histogram\")",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        \"\"\"Returns the query object for this visualization\"\"\"",
            "        query_obj = super().query_obj()",
            "        numeric_columns = self.form_data.get(\"all_columns_x\")",
            "        if numeric_columns is None:",
            "            raise QueryObjectValidationError(",
            "                _(\"Must have at least one numeric column specified\")",
            "            )",
            "        self.columns = (  #  pylint: disable=attribute-defined-outside-init",
            "            numeric_columns",
            "        )",
            "        query_obj[\"columns\"] = numeric_columns + self.groupby",
            "        # override groupby entry to avoid aggregation",
            "        query_obj[\"groupby\"] = None",
            "        query_obj[\"metrics\"] = None",
            "        return query_obj",
            "",
            "    def labelify(self, keys: Union[List[str], str], column: str) -> str:",
            "        if isinstance(keys, str):",
            "            keys = [keys]",
            "        # removing undesirable characters",
            "        labels = [re.sub(r\"\\W+\", r\"_\", k) for k in keys]",
            "        if len(self.columns) > 1 or not self.groupby:",
            "            # Only show numeric column in label if there are many",
            "            labels = [column] + labels",
            "        return \"__\".join(labels)",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        \"\"\"Returns the chart data\"\"\"",
            "        if df.empty:",
            "            return None",
            "",
            "        chart_data = []",
            "        if len(self.groupby) > 0:",
            "            groups = df.groupby(self.groupby)",
            "        else:",
            "            groups = [((), df)]",
            "        for keys, data in groups:",
            "            chart_data.extend(",
            "                [",
            "                    {",
            "                        \"key\": self.labelify(keys, column),",
            "                        \"values\": data[column].tolist(),",
            "                    }",
            "                    for column in self.columns",
            "                ]",
            "            )",
            "        return chart_data",
            "",
            "",
            "class DistributionBarViz(BaseViz):",
            "",
            "    \"\"\"A good old bar chart\"\"\"",
            "",
            "    viz_type = \"dist_bar\"",
            "    verbose_name = _(\"Distribution - Bar Chart\")",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        if len(query_obj[\"groupby\"]) < len(self.form_data.get(\"groupby\") or []) + len(",
            "            self.form_data.get(\"columns\") or []",
            "        ):",
            "            raise QueryObjectValidationError(",
            "                _(\"Can't have overlap between Series and Breakdowns\")",
            "            )",
            "        if not self.form_data.get(\"metrics\"):",
            "            raise QueryObjectValidationError(_(\"Pick at least one metric\"))",
            "        if not self.form_data.get(\"groupby\"):",
            "            raise QueryObjectValidationError(_(\"Pick at least one field for [Series]\"))",
            "",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            query_obj[\"orderby\"] = [",
            "                (sort_by, not self.form_data.get(\"order_desc\", True))",
            "            ]",
            "        elif query_obj[\"metrics\"]:",
            "            # Legacy behavior of sorting by first metric by default",
            "            first_metric = query_obj[\"metrics\"][0]",
            "            query_obj[\"orderby\"] = [",
            "                (first_metric, not self.form_data.get(\"order_desc\", True))",
            "            ]",
            "",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:  # pylint: disable=too-many-locals",
            "        if df.empty:",
            "            return None",
            "",
            "        metrics = self.metric_labels",
            "        columns = self.form_data.get(\"columns\") or []",
            "",
            "        # pandas will throw away nulls when grouping/pivoting,",
            "        # so we substitute NULL_STRING for any nulls in the necessary columns",
            "        filled_cols = self.groupby + columns",
            "        df = df.copy()",
            "        df[filled_cols] = df[filled_cols].fillna(value=NULL_STRING)",
            "",
            "        sortby = utils.get_metric_name(",
            "            self.form_data.get(\"timeseries_limit_metric\") or metrics[0]",
            "        )",
            "        row = df.groupby(self.groupby).sum()[sortby].copy()",
            "        is_asc = not self.form_data.get(\"order_desc\")",
            "        row.sort_values(ascending=is_asc, inplace=True)",
            "        pt = df.pivot_table(index=self.groupby, columns=columns, values=metrics)",
            "        if self.form_data.get(\"contribution\"):",
            "            pt = pt.T",
            "            pt = (pt / pt.sum()).T",
            "        pt = pt.reindex(row.index)",
            "",
            "        # Re-order the columns adhering to the metric ordering.",
            "        pt = pt[metrics]",
            "        chart_data = []",
            "        for name, ys in pt.items():",
            "            if pt[name].dtype.kind not in \"biufc\" or name in self.groupby:",
            "                continue",
            "            if isinstance(name, str):",
            "                series_title = name",
            "            else:",
            "                offset = 0 if len(metrics) > 1 else 1",
            "                series_title = \", \".join([str(s) for s in name[offset:]])",
            "            values = []",
            "            for i, v in ys.items():",
            "                x = i",
            "                if isinstance(x, (tuple, list)):",
            "                    x = \", \".join([str(s) for s in x])",
            "                else:",
            "                    x = str(x)",
            "                values.append({\"x\": x, \"y\": v})",
            "            chart_data.append({\"key\": series_title, \"values\": values})",
            "        return chart_data",
            "",
            "",
            "class SunburstViz(BaseViz):",
            "",
            "    \"\"\"A multi level sunburst chart\"\"\"",
            "",
            "    viz_type = \"sunburst\"",
            "    verbose_name = _(\"Sunburst\")",
            "    is_timeseries = False",
            "    credits = (",
            "        \"Kerry Rodden \"",
            "        '@<a href=\"https://bl.ocks.org/kerryrodden/7090426\">bl.ocks.org</a>'",
            "    )",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        form_data = copy.deepcopy(self.form_data)",
            "        cols = form_data.get(\"groupby\") or []",
            "        cols.extend([\"m1\", \"m2\"])",
            "        metric = utils.get_metric_name(form_data[\"metric\"])",
            "        secondary_metric = (",
            "            utils.get_metric_name(form_data[\"secondary_metric\"])",
            "            if \"secondary_metric\" in form_data",
            "            else None",
            "        )",
            "        if metric == secondary_metric or secondary_metric is None:",
            "            df.rename(columns={df.columns[-1]: \"m1\"}, inplace=True)",
            "            df[\"m2\"] = df[\"m1\"]",
            "        else:",
            "            df.rename(columns={df.columns[-2]: \"m1\"}, inplace=True)",
            "            df.rename(columns={df.columns[-1]: \"m2\"}, inplace=True)",
            "",
            "        # Re-order the columns as the query result set column ordering may differ from",
            "        # that listed in the hierarchy.",
            "        df = df[cols]",
            "        return df.to_numpy().tolist()",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"metrics\"] = [self.form_data[\"metric\"]]",
            "        secondary_metric = self.form_data.get(\"secondary_metric\")",
            "        if secondary_metric and secondary_metric != self.form_data[\"metric\"]:",
            "            query_obj[\"metrics\"].append(secondary_metric)",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "        return query_obj",
            "",
            "",
            "class SankeyViz(BaseViz):",
            "",
            "    \"\"\"A Sankey diagram that requires a parent-child dataset\"\"\"",
            "",
            "    viz_type = \"sankey\"",
            "    verbose_name = _(\"Sankey\")",
            "    is_timeseries = False",
            "    credits = '<a href=\"https://www.npmjs.com/package/d3-sankey\">d3-sankey on npm</a>'",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        if len(query_obj[\"groupby\"]) != 2:",
            "            raise QueryObjectValidationError(",
            "                _(\"Pick exactly 2 columns as [Source / Target]\")",
            "            )",
            "        query_obj[\"metrics\"] = [self.form_data[\"metric\"]]",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        source, target = self.groupby",
            "        (value,) = self.metric_labels",
            "        df.rename(",
            "            columns={source: \"source\", target: \"target\", value: \"value\",}, inplace=True,",
            "        )",
            "        df[\"source\"] = df[\"source\"].astype(str)",
            "        df[\"target\"] = df[\"target\"].astype(str)",
            "        recs = df.to_dict(orient=\"records\")",
            "",
            "        hierarchy: Dict[str, Set[str]] = defaultdict(set)",
            "        for row in recs:",
            "            hierarchy[row[\"source\"]].add(row[\"target\"])",
            "",
            "        def find_cycle(graph: Dict[str, Set[str]]) -> Optional[Tuple[str, str]]:",
            "            \"\"\"Whether there's a cycle in a directed graph\"\"\"",
            "            path = set()",
            "",
            "            def visit(vertex: str) -> Optional[Tuple[str, str]]:",
            "                path.add(vertex)",
            "                for neighbour in graph.get(vertex, ()):",
            "                    if neighbour in path or visit(neighbour):",
            "                        return (vertex, neighbour)",
            "                path.remove(vertex)",
            "                return None",
            "",
            "            for vertex in graph:",
            "                cycle = visit(vertex)",
            "                if cycle:",
            "                    return cycle",
            "            return None",
            "",
            "        cycle = find_cycle(hierarchy)",
            "        if cycle:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"There's a loop in your Sankey, please provide a tree. \"",
            "                    \"Here's a faulty link: {}\"",
            "                ).format(cycle)",
            "            )",
            "        return recs",
            "",
            "",
            "class ChordViz(BaseViz):",
            "",
            "    \"\"\"A Chord diagram\"\"\"",
            "",
            "    viz_type = \"chord\"",
            "    verbose_name = _(\"Directed Force Layout\")",
            "    credits = '<a href=\"https://github.com/d3/d3-chord\">Bostock</a>'",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"groupby\"] = [",
            "            self.form_data.get(\"groupby\"),",
            "            self.form_data.get(\"columns\"),",
            "        ]",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df.columns = [\"source\", \"target\", \"value\"]",
            "",
            "        # Preparing a symetrical matrix like d3.chords calls for",
            "        nodes = list(set(df[\"source\"]) | set(df[\"target\"]))",
            "        matrix = {}",
            "        for source, target in product(nodes, nodes):",
            "            matrix[(source, target)] = 0",
            "        for source, target, value in df.to_records(index=False):",
            "            matrix[(source, target)] = value",
            "        return {",
            "            \"nodes\": list(nodes),",
            "            \"matrix\": [[matrix[(n1, n2)] for n1 in nodes] for n2 in nodes],",
            "        }",
            "",
            "",
            "class CountryMapViz(BaseViz):",
            "",
            "    \"\"\"A country centric\"\"\"",
            "",
            "    viz_type = \"country_map\"",
            "    verbose_name = _(\"Country Map\")",
            "    is_timeseries = False",
            "    credits = \"From bl.ocks.org By john-guerra\"",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        metric = self.form_data.get(\"metric\")",
            "        entity = self.form_data.get(\"entity\")",
            "        if not self.form_data.get(\"select_country\"):",
            "            raise QueryObjectValidationError(\"Must specify a country\")",
            "        if not metric:",
            "            raise QueryObjectValidationError(\"Must specify a metric\")",
            "        if not entity:",
            "            raise QueryObjectValidationError(\"Must provide ISO codes\")",
            "        query_obj[\"metrics\"] = [metric]",
            "        query_obj[\"groupby\"] = [entity]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        cols = [self.form_data.get(\"entity\")]",
            "        metric = self.metric_labels[0]",
            "        cols += [metric]",
            "        ndf = df[cols]",
            "        df = ndf",
            "        df.columns = [\"country_id\", \"metric\"]",
            "        return df.to_dict(orient=\"records\")",
            "",
            "",
            "class WorldMapViz(BaseViz):",
            "",
            "    \"\"\"A country centric world map\"\"\"",
            "",
            "    viz_type = \"world_map\"",
            "    verbose_name = _(\"World Map\")",
            "    is_timeseries = False",
            "    credits = 'datamaps on <a href=\"https://www.npmjs.com/package/datamaps\">npm</a>'",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"groupby\"] = [self.form_data[\"entity\"]]",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset.examples import countries",
            "",
            "        cols = [self.form_data.get(\"entity\")]",
            "        metric = utils.get_metric_name(self.form_data[\"metric\"])",
            "        secondary_metric = (",
            "            utils.get_metric_name(self.form_data[\"secondary_metric\"])",
            "            if \"secondary_metric\" in self.form_data",
            "            else None",
            "        )",
            "        columns = [\"country\", \"m1\", \"m2\"]",
            "        if metric == secondary_metric:",
            "            ndf = df[cols]",
            "            ndf[\"m1\"] = df[metric]",
            "            ndf[\"m2\"] = ndf[\"m1\"]",
            "        else:",
            "            if secondary_metric:",
            "                cols += [metric, secondary_metric]",
            "            else:",
            "                cols += [metric]",
            "                columns = [\"country\", \"m1\"]",
            "            ndf = df[cols]",
            "        df = ndf",
            "        df.columns = columns",
            "        data = df.to_dict(orient=\"records\")",
            "        for row in data:",
            "            country = None",
            "            if isinstance(row[\"country\"], str):",
            "                if \"country_fieldtype\" in self.form_data:",
            "                    country = countries.get(",
            "                        self.form_data[\"country_fieldtype\"], row[\"country\"]",
            "                    )",
            "            if country:",
            "                row[\"country\"] = country[\"cca3\"]",
            "                row[\"latitude\"] = country[\"lat\"]",
            "                row[\"longitude\"] = country[\"lng\"]",
            "                row[\"name\"] = country[\"name\"]",
            "            else:",
            "                row[\"country\"] = \"XXX\"",
            "        return data",
            "",
            "",
            "class FilterBoxViz(BaseViz):",
            "",
            "    \"\"\"A multi filter, multi-choice filter box to make dashboards interactive\"\"\"",
            "",
            "    viz_type = \"filter_box\"",
            "    verbose_name = _(\"Filters\")",
            "    is_timeseries = False",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    cache_type = \"get_data\"",
            "    filter_row_limit = 1000",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        return {}",
            "",
            "    def run_extra_queries(self) -> None:",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset.common.query_context import QueryContext",
            "",
            "        query_obj = super().query_obj()",
            "        filters = self.form_data.get(\"filter_configs\") or []",
            "        query_obj[\"row_limit\"] = self.filter_row_limit",
            "        self.dataframes = {}  # pylint: disable=attribute-defined-outside-init",
            "        for flt in filters:",
            "            col = flt.get(\"column\")",
            "            if not col:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Invalid filter configuration, please select a column\")",
            "                )",
            "            query_obj[\"groupby\"] = [col]",
            "            metric = flt.get(\"metric\")",
            "            query_obj[\"metrics\"] = [metric] if metric else []",
            "            asc = flt.get(\"asc\")",
            "            if metric and asc is not None:",
            "                query_obj[\"orderby\"] = [(metric, asc)]",
            "            QueryContext(",
            "                datasource={\"id\": self.datasource.id, \"type\": self.datasource.type},",
            "                queries=[query_obj],",
            "            ).raise_for_access()",
            "            df = self.get_df_payload(query_obj=query_obj).get(\"df\")",
            "            self.dataframes[col] = df",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        filters = self.form_data.get(\"filter_configs\") or []",
            "        data = {}",
            "        for flt in filters:",
            "            col = flt.get(\"column\")",
            "            metric = flt.get(\"metric\")",
            "            df = self.dataframes.get(col)",
            "            if df is not None and not df.empty:",
            "                if metric:",
            "                    df = df.sort_values(",
            "                        utils.get_metric_name(metric), ascending=flt.get(\"asc\")",
            "                    )",
            "                    data[col] = [",
            "                        {\"id\": row[0], \"text\": row[0], \"metric\": row[1]}",
            "                        for row in df.itertuples(index=False)",
            "                    ]",
            "                else:",
            "                    df = df.sort_values(col, ascending=flt.get(\"asc\"))",
            "                    data[col] = [",
            "                        {\"id\": row[0], \"text\": row[0]}",
            "                        for row in df.itertuples(index=False)",
            "                    ]",
            "            else:",
            "                data[col] = []",
            "        return data",
            "",
            "",
            "class ParallelCoordinatesViz(BaseViz):",
            "",
            "    \"\"\"Interactive parallel coordinate implementation",
            "",
            "    Uses this amazing javascript library",
            "    https://github.com/syntagmatic/parallel-coordinates",
            "    \"\"\"",
            "",
            "    viz_type = \"para\"",
            "    verbose_name = _(\"Parallel Coordinates\")",
            "    credits = (",
            "        '<a href=\"https://syntagmatic.github.io/parallel-coordinates/\">'",
            "        \"Syntagmatic's library</a>\"",
            "    )",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"groupby\"] = [self.form_data.get(\"series\")]",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            if self.form_data.get(\"order_desc\"):",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        return df.to_dict(orient=\"records\")",
            "",
            "",
            "class HeatmapViz(BaseViz):",
            "",
            "    \"\"\"A nice heatmap visualization that support high density through canvas\"\"\"",
            "",
            "    viz_type = \"heatmap\"",
            "    verbose_name = _(\"Heatmap\")",
            "    is_timeseries = False",
            "    credits = (",
            "        'inspired from mbostock @<a href=\"http://bl.ocks.org/mbostock/3074470\">'",
            "        \"bl.ocks.org</a>\"",
            "    )",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        query_obj[\"groupby\"] = [",
            "            self.form_data.get(\"all_columns_x\"),",
            "            self.form_data.get(\"all_columns_y\"),",
            "        ]",
            "",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        x = self.form_data.get(\"all_columns_x\")",
            "        y = self.form_data.get(\"all_columns_y\")",
            "        v = self.metric_labels[0]",
            "        if x == y:",
            "            df.columns = [\"x\", \"y\", \"v\"]",
            "        else:",
            "            df = df[[x, y, v]]",
            "            df.columns = [\"x\", \"y\", \"v\"]",
            "        norm = self.form_data.get(\"normalize_across\")",
            "        overall = False",
            "        max_ = df.v.max()",
            "        min_ = df.v.min()",
            "        if norm == \"heatmap\":",
            "            overall = True",
            "        else:",
            "            gb = df.groupby(norm, group_keys=False)",
            "            if len(gb) <= 1:",
            "                overall = True",
            "            else:",
            "                df[\"perc\"] = gb.apply(",
            "                    lambda x: (x.v - x.v.min()) / (x.v.max() - x.v.min())",
            "                )",
            "                df[\"rank\"] = gb.apply(lambda x: x.v.rank(pct=True))",
            "        if overall:",
            "            df[\"perc\"] = (df.v - min_) / (max_ - min_)",
            "            df[\"rank\"] = df.v.rank(pct=True)",
            "        return {\"records\": df.to_dict(orient=\"records\"), \"extents\": [min_, max_]}",
            "",
            "",
            "class HorizonViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"Horizon chart",
            "",
            "    https://www.npmjs.com/package/d3-horizon-chart",
            "    \"\"\"",
            "",
            "    viz_type = \"horizon\"",
            "    verbose_name = _(\"Horizon Charts\")",
            "    credits = (",
            "        '<a href=\"https://www.npmjs.com/package/d3-horizon-chart\">'",
            "        \"d3-horizon-chart</a>\"",
            "    )",
            "",
            "",
            "class MapboxViz(BaseViz):",
            "",
            "    \"\"\"Rich maps made with Mapbox\"\"\"",
            "",
            "    viz_type = \"mapbox\"",
            "    verbose_name = _(\"Mapbox\")",
            "    is_timeseries = False",
            "    credits = \"<a href=https://www.mapbox.com/mapbox-gl-js/api/>Mapbox GL JS</a>\"",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        label_col = self.form_data.get(\"mapbox_label\")",
            "",
            "        if not self.form_data.get(\"groupby\"):",
            "            if (",
            "                self.form_data.get(\"all_columns_x\") is None",
            "                or self.form_data.get(\"all_columns_y\") is None",
            "            ):",
            "                raise QueryObjectValidationError(",
            "                    _(\"[Longitude] and [Latitude] must be set\")",
            "                )",
            "            query_obj[\"columns\"] = [",
            "                self.form_data.get(\"all_columns_x\"),",
            "                self.form_data.get(\"all_columns_y\"),",
            "            ]",
            "",
            "            if label_col and len(label_col) >= 1:",
            "                if label_col[0] == \"count\":",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Must have a [Group By] column to have 'count' as the \"",
            "                            + \"[Label]\"",
            "                        )",
            "                    )",
            "                query_obj[\"columns\"].append(label_col[0])",
            "",
            "            if self.form_data.get(\"point_radius\") != \"Auto\":",
            "                query_obj[\"columns\"].append(self.form_data.get(\"point_radius\"))",
            "",
            "            # Ensure this value is sorted so that it does not",
            "            # cause the cache key generation (which hashes the",
            "            # query object) to generate different keys for values",
            "            # that should be considered the same.",
            "            query_obj[\"columns\"] = sorted(set(query_obj[\"columns\"]))",
            "        else:",
            "            # Ensuring columns chosen are all in group by",
            "            if (",
            "                label_col",
            "                and len(label_col) >= 1",
            "                and label_col[0] != \"count\"",
            "                and label_col[0] not in self.form_data[\"groupby\"]",
            "            ):",
            "                raise QueryObjectValidationError(",
            "                    _(\"Choice of [Label] must be present in [Group By]\")",
            "                )",
            "",
            "            if (",
            "                self.form_data.get(\"point_radius\") != \"Auto\"",
            "                and self.form_data.get(\"point_radius\") not in self.form_data[\"groupby\"]",
            "            ):",
            "                raise QueryObjectValidationError(",
            "                    _(\"Choice of [Point Radius] must be present in [Group By]\")",
            "                )",
            "",
            "            if (",
            "                self.form_data.get(\"all_columns_x\") not in self.form_data[\"groupby\"]",
            "                or self.form_data.get(\"all_columns_y\") not in self.form_data[\"groupby\"]",
            "            ):",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"[Longitude] and [Latitude] columns must be present in \"",
            "                        + \"[Group By]\"",
            "                    )",
            "                )",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        label_col = self.form_data.get(\"mapbox_label\")",
            "        has_custom_metric = label_col is not None and len(label_col) > 0",
            "        metric_col = [None] * len(df.index)",
            "        if has_custom_metric:",
            "            if label_col[0] == self.form_data.get(\"all_columns_x\"):  # type: ignore",
            "                metric_col = df[self.form_data.get(\"all_columns_x\")]",
            "            elif label_col[0] == self.form_data.get(\"all_columns_y\"):  # type: ignore",
            "                metric_col = df[self.form_data.get(\"all_columns_y\")]",
            "            else:",
            "                metric_col = df[label_col[0]]  # type: ignore",
            "        point_radius_col = (",
            "            [None] * len(df.index)",
            "            if self.form_data.get(\"point_radius\") == \"Auto\"",
            "            else df[self.form_data.get(\"point_radius\")]",
            "        )",
            "",
            "        # limiting geo precision as long decimal values trigger issues",
            "        # around json-bignumber in Mapbox",
            "        geo_precision = 10",
            "        # using geoJSON formatting",
            "        geo_json = {",
            "            \"type\": \"FeatureCollection\",",
            "            \"features\": [",
            "                {",
            "                    \"type\": \"Feature\",",
            "                    \"properties\": {\"metric\": metric, \"radius\": point_radius},",
            "                    \"geometry\": {",
            "                        \"type\": \"Point\",",
            "                        \"coordinates\": [",
            "                            round(lon, geo_precision),",
            "                            round(lat, geo_precision),",
            "                        ],",
            "                    },",
            "                }",
            "                for lon, lat, metric, point_radius in zip(",
            "                    df[self.form_data.get(\"all_columns_x\")],",
            "                    df[self.form_data.get(\"all_columns_y\")],",
            "                    metric_col,",
            "                    point_radius_col,",
            "                )",
            "            ],",
            "        }",
            "",
            "        x_series, y_series = (",
            "            df[self.form_data.get(\"all_columns_x\")],",
            "            df[self.form_data.get(\"all_columns_y\")],",
            "        )",
            "        south_west = [x_series.min(), y_series.min()]",
            "        north_east = [x_series.max(), y_series.max()]",
            "",
            "        return {",
            "            \"geoJSON\": geo_json,",
            "            \"hasCustomMetric\": has_custom_metric,",
            "            \"mapboxApiKey\": config[\"MAPBOX_API_KEY\"],",
            "            \"mapStyle\": self.form_data.get(\"mapbox_style\"),",
            "            \"aggregatorName\": self.form_data.get(\"pandas_aggfunc\"),",
            "            \"clusteringRadius\": self.form_data.get(\"clustering_radius\"),",
            "            \"pointRadiusUnit\": self.form_data.get(\"point_radius_unit\"),",
            "            \"globalOpacity\": self.form_data.get(\"global_opacity\"),",
            "            \"bounds\": [south_west, north_east],",
            "            \"renderWhileDragging\": self.form_data.get(\"render_while_dragging\"),",
            "            \"tooltip\": self.form_data.get(\"rich_tooltip\"),",
            "            \"color\": self.form_data.get(\"mapbox_color\"),",
            "        }",
            "",
            "",
            "class DeckGLMultiLayer(BaseViz):",
            "",
            "    \"\"\"Pile on multiple DeckGL layers\"\"\"",
            "",
            "    viz_type = \"deck_multi\"",
            "    verbose_name = _(\"Deck.gl - Multiple Layers\")",
            "",
            "    is_timeseries = False",
            "    credits = '<a href=\"https://uber.github.io/deck.gl/\">deck.gl</a>'",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        return {}",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        # Late imports to avoid circular import issues",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset import db",
            "        from superset.models.slice import Slice",
            "",
            "        slice_ids = self.form_data.get(\"deck_slices\")",
            "        slices = db.session.query(Slice).filter(Slice.id.in_(slice_ids)).all()",
            "        return {",
            "            \"mapboxApiKey\": config[\"MAPBOX_API_KEY\"],",
            "            \"slices\": [slc.data for slc in slices],",
            "        }",
            "",
            "",
            "class BaseDeckGLViz(BaseViz):",
            "",
            "    \"\"\"Base class for deck.gl visualizations\"\"\"",
            "",
            "    is_timeseries = False",
            "    credits = '<a href=\"https://uber.github.io/deck.gl/\">deck.gl</a>'",
            "    spatial_control_keys: List[str] = []",
            "",
            "    def get_metrics(self) -> List[str]:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.metric = self.form_data.get(\"size\")",
            "        return [self.metric] if self.metric else []",
            "",
            "    def process_spatial_query_obj(self, key: str, group_by: List[str]) -> None:",
            "        group_by.extend(self.get_spatial_columns(key))",
            "",
            "    def get_spatial_columns(self, key: str) -> List[str]:",
            "        spatial = self.form_data.get(key)",
            "        if spatial is None:",
            "            raise ValueError(_(\"Bad spatial key\"))",
            "",
            "        if spatial.get(\"type\") == \"latlong\":",
            "            return [spatial.get(\"lonCol\"), spatial.get(\"latCol\")]",
            "",
            "        if spatial.get(\"type\") == \"delimited\":",
            "            return [spatial.get(\"lonlatCol\")]",
            "",
            "        if spatial.get(\"type\") == \"geohash\":",
            "            return [spatial.get(\"geohashCol\")]",
            "        return []",
            "",
            "    @staticmethod",
            "    def parse_coordinates(latlog: Any) -> Optional[Tuple[float, float]]:",
            "        if not latlog:",
            "            return None",
            "        try:",
            "            point = Point(latlog)",
            "            return (point.latitude, point.longitude)",
            "        except Exception as ex:",
            "            raise SpatialException(",
            "                _(\"Invalid spatial point encountered: %s\" % latlog)",
            "            ) from ex",
            "",
            "    @staticmethod",
            "    def reverse_geohash_decode(geohash_code: str) -> Tuple[str, str]:",
            "        lat, lng = geohash.decode(geohash_code)",
            "        return (lng, lat)",
            "",
            "    @staticmethod",
            "    def reverse_latlong(df: pd.DataFrame, key: str) -> None:",
            "        df[key] = [tuple(reversed(o)) for o in df[key] if isinstance(o, (list, tuple))]",
            "",
            "    def process_spatial_data_obj(self, key: str, df: pd.DataFrame) -> pd.DataFrame:",
            "        spatial = self.form_data.get(key)",
            "        if spatial is None:",
            "            raise ValueError(_(\"Bad spatial key\"))",
            "",
            "        if spatial.get(\"type\") == \"latlong\":",
            "            df[key] = list(",
            "                zip(",
            "                    pd.to_numeric(df[spatial.get(\"lonCol\")], errors=\"coerce\"),",
            "                    pd.to_numeric(df[spatial.get(\"latCol\")], errors=\"coerce\"),",
            "                )",
            "            )",
            "        elif spatial.get(\"type\") == \"delimited\":",
            "            lon_lat_col = spatial.get(\"lonlatCol\")",
            "            df[key] = df[lon_lat_col].apply(self.parse_coordinates)",
            "            del df[lon_lat_col]",
            "        elif spatial.get(\"type\") == \"geohash\":",
            "            df[key] = df[spatial.get(\"geohashCol\")].map(self.reverse_geohash_decode)",
            "            del df[spatial.get(\"geohashCol\")]",
            "",
            "        if spatial.get(\"reverseCheckbox\"):",
            "            self.reverse_latlong(df, key)",
            "",
            "        if df.get(key) is None:",
            "            raise NullValueException(",
            "                _(",
            "                    \"Encountered invalid NULL spatial entry, \\",
            "                                       please consider filtering those out\"",
            "                )",
            "            )",
            "        return df",
            "",
            "    def add_null_filters(self) -> None:",
            "        spatial_columns = set()",
            "        for key in self.spatial_control_keys:",
            "            for column in self.get_spatial_columns(key):",
            "                spatial_columns.add(column)",
            "",
            "        if self.form_data.get(\"adhoc_filters\") is None:",
            "            self.form_data[\"adhoc_filters\"] = []",
            "",
            "        line_column = self.form_data.get(\"line_column\")",
            "        if line_column:",
            "            spatial_columns.add(line_column)",
            "",
            "        for column in sorted(spatial_columns):",
            "            filter_ = simple_filter_to_adhoc(",
            "                {\"col\": column, \"op\": \"IS NOT NULL\", \"val\": \"\"}",
            "            )",
            "            self.form_data[\"adhoc_filters\"].append(filter_)",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        # add NULL filters",
            "        if self.form_data.get(\"filter_nulls\", True):",
            "            self.add_null_filters()",
            "",
            "        query_obj = super().query_obj()",
            "        group_by: List[str] = []",
            "",
            "        for key in self.spatial_control_keys:",
            "            self.process_spatial_query_obj(key, group_by)",
            "",
            "        if self.form_data.get(\"dimension\"):",
            "            group_by += [self.form_data[\"dimension\"]]",
            "",
            "        if self.form_data.get(\"js_columns\"):",
            "            group_by += self.form_data.get(\"js_columns\") or []",
            "        metrics = self.get_metrics()",
            "        # Ensure this value is sorted so that it does not",
            "        # cause the cache key generation (which hashes the",
            "        # query object) to generate different keys for values",
            "        # that should be considered the same.",
            "        group_by = sorted(set(group_by))",
            "        if metrics:",
            "            query_obj[\"groupby\"] = group_by",
            "            query_obj[\"metrics\"] = metrics",
            "            query_obj[\"columns\"] = []",
            "            first_metric = query_obj[\"metrics\"][0]",
            "            query_obj[\"orderby\"] = [",
            "                (first_metric, not self.form_data.get(\"order_desc\", True))",
            "            ]",
            "        else:",
            "            query_obj[\"columns\"] = group_by",
            "        return query_obj",
            "",
            "    def get_js_columns(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        cols = self.form_data.get(\"js_columns\") or []",
            "        return {col: data.get(col) for col in cols}",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        # Processing spatial info",
            "        for key in self.spatial_control_keys:",
            "            df = self.process_spatial_data_obj(key, df)",
            "",
            "        features = []",
            "        for data in df.to_dict(orient=\"records\"):",
            "            feature = self.get_properties(data)",
            "            extra_props = self.get_js_columns(data)",
            "            if extra_props:",
            "                feature[\"extraProps\"] = extra_props",
            "            features.append(feature)",
            "",
            "        return {",
            "            \"features\": features,",
            "            \"mapboxApiKey\": config[\"MAPBOX_API_KEY\"],",
            "            \"metricLabels\": self.metric_labels,",
            "        }",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        raise NotImplementedError()",
            "",
            "",
            "class DeckScatterViz(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's ScatterLayer\"\"\"",
            "",
            "    viz_type = \"deck_scatter\"",
            "    verbose_name = _(\"Deck.gl - Scatter plot\")",
            "    spatial_control_keys = [\"spatial\"]",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.is_timeseries = bool(",
            "            self.form_data.get(\"time_grain_sqla\") or self.form_data.get(\"granularity\")",
            "        )",
            "        self.point_radius_fixed = self.form_data.get(\"point_radius_fixed\") or {",
            "            \"type\": \"fix\",",
            "            \"value\": 500,",
            "        }",
            "        return super().query_obj()",
            "",
            "    def get_metrics(self) -> List[str]:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.metric = None",
            "        if self.point_radius_fixed.get(\"type\") == \"metric\":",
            "            self.metric = self.point_radius_fixed[\"value\"]",
            "            return [self.metric]",
            "        return []",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        return {",
            "            \"metric\": data.get(self.metric_label) if self.metric_label else None,",
            "            \"radius\": self.fixed_value",
            "            if self.fixed_value",
            "            else data.get(self.metric_label)",
            "            if self.metric_label",
            "            else None,",
            "            \"cat_color\": data.get(self.dim) if self.dim else None,",
            "            \"position\": data.get(\"spatial\"),",
            "            DTTM_ALIAS: data.get(DTTM_ALIAS),",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.metric_label = utils.get_metric_name(self.metric) if self.metric else None",
            "        self.point_radius_fixed = self.form_data.get(\"point_radius_fixed\")",
            "        self.fixed_value = None",
            "        self.dim = self.form_data.get(\"dimension\")",
            "        if self.point_radius_fixed and self.point_radius_fixed.get(\"type\") != \"metric\":",
            "            self.fixed_value = self.point_radius_fixed.get(\"value\")",
            "        return super().get_data(df)",
            "",
            "",
            "class DeckScreengrid(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's ScreenGridLayer\"\"\"",
            "",
            "    viz_type = \"deck_screengrid\"",
            "    verbose_name = _(\"Deck.gl - Screen Grid\")",
            "    spatial_control_keys = [\"spatial\"]",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        self.is_timeseries = bool(",
            "            self.form_data.get(\"time_grain_sqla\") or self.form_data.get(\"granularity\")",
            "        )",
            "        return super().query_obj()",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        return {",
            "            \"position\": data.get(\"spatial\"),",
            "            \"weight\": (data.get(self.metric_label) if self.metric_label else None) or 1,",
            "            \"__timestamp\": data.get(DTTM_ALIAS) or data.get(\"__time\"),",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        self.metric_label = (  # pylint: disable=attribute-defined-outside-init",
            "            utils.get_metric_name(self.metric) if self.metric else None",
            "        )",
            "        return super().get_data(df)",
            "",
            "",
            "class DeckGrid(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's DeckLayer\"\"\"",
            "",
            "    viz_type = \"deck_grid\"",
            "    verbose_name = _(\"Deck.gl - 3D Grid\")",
            "    spatial_control_keys = [\"spatial\"]",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        return {",
            "            \"position\": data.get(\"spatial\"),",
            "            \"weight\": (data.get(self.metric_label) if self.metric_label else None) or 1,",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        self.metric_label = (  # pylint: disable=attribute-defined-outside-init",
            "            utils.get_metric_name(self.metric) if self.metric else None",
            "        )",
            "        return super().get_data(df)",
            "",
            "",
            "def geohash_to_json(geohash_code: str) -> List[List[float]]:",
            "    bbox = geohash.bbox(geohash_code)",
            "    return [",
            "        [bbox.get(\"w\"), bbox.get(\"n\")],",
            "        [bbox.get(\"e\"), bbox.get(\"n\")],",
            "        [bbox.get(\"e\"), bbox.get(\"s\")],",
            "        [bbox.get(\"w\"), bbox.get(\"s\")],",
            "        [bbox.get(\"w\"), bbox.get(\"n\")],",
            "    ]",
            "",
            "",
            "class DeckPathViz(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's PathLayer\"\"\"",
            "",
            "    viz_type = \"deck_path\"",
            "    verbose_name = _(\"Deck.gl - Paths\")",
            "    deck_viz_key = \"path\"",
            "    is_timeseries = True",
            "    deser_map = {",
            "        \"json\": json.loads,",
            "        \"polyline\": polyline.decode,",
            "        \"geohash\": geohash_to_json,",
            "    }",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.is_timeseries = bool(",
            "            self.form_data.get(\"time_grain_sqla\") or self.form_data.get(\"granularity\")",
            "        )",
            "        query_obj = super().query_obj()",
            "        self.metric = self.form_data.get(\"metric\")",
            "        line_col = self.form_data.get(\"line_column\")",
            "        if query_obj[\"metrics\"]:",
            "            self.has_metrics = True",
            "            query_obj[\"groupby\"].append(line_col)",
            "        else:",
            "            self.has_metrics = False",
            "            query_obj[\"columns\"].append(line_col)",
            "        return query_obj",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        line_type = self.form_data[\"line_type\"]",
            "        deser = self.deser_map[line_type]",
            "        line_column = self.form_data[\"line_column\"]",
            "        path = deser(data[line_column])",
            "        if self.form_data.get(\"reverse_long_lat\"):",
            "            path = [(o[1], o[0]) for o in path]",
            "        data[self.deck_viz_key] = path",
            "        if line_type != \"geohash\":",
            "            del data[line_column]",
            "        data[\"__timestamp\"] = data.get(DTTM_ALIAS) or data.get(\"__time\")",
            "        return data",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        self.metric_label = (  # pylint: disable=attribute-defined-outside-init",
            "            utils.get_metric_name(self.metric) if self.metric else None",
            "        )",
            "        return super().get_data(df)",
            "",
            "",
            "class DeckPolygon(DeckPathViz):",
            "",
            "    \"\"\"deck.gl's Polygon Layer\"\"\"",
            "",
            "    viz_type = \"deck_polygon\"",
            "    deck_viz_key = \"polygon\"",
            "    verbose_name = _(\"Deck.gl - Polygon\")",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.elevation = self.form_data.get(\"point_radius_fixed\") or {",
            "            \"type\": \"fix\",",
            "            \"value\": 500,",
            "        }",
            "        return super().query_obj()",
            "",
            "    def get_metrics(self) -> List[str]:",
            "        metrics = [self.form_data.get(\"metric\")]",
            "        if self.elevation.get(\"type\") == \"metric\":",
            "            metrics.append(self.elevation.get(\"value\"))",
            "        return [metric for metric in metrics if metric]",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        super().get_properties(data)",
            "        elevation = self.form_data[\"point_radius_fixed\"][\"value\"]",
            "        type_ = self.form_data[\"point_radius_fixed\"][\"type\"]",
            "        data[\"elevation\"] = (",
            "            data.get(utils.get_metric_name(elevation))",
            "            if type_ == \"metric\"",
            "            else elevation",
            "        )",
            "        return data",
            "",
            "",
            "class DeckHex(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's DeckLayer\"\"\"",
            "",
            "    viz_type = \"deck_hex\"",
            "    verbose_name = _(\"Deck.gl - 3D HEX\")",
            "    spatial_control_keys = [\"spatial\"]",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        return {",
            "            \"position\": data.get(\"spatial\"),",
            "            \"weight\": (data.get(self.metric_label) if self.metric_label else None) or 1,",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        self.metric_label = (  # pylint: disable=attribute-defined-outside-init",
            "            utils.get_metric_name(self.metric) if self.metric else None",
            "        )",
            "        return super().get_data(df)",
            "",
            "",
            "class DeckGeoJson(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's GeoJSONLayer\"\"\"",
            "",
            "    viz_type = \"deck_geojson\"",
            "    verbose_name = _(\"Deck.gl - GeoJSON\")",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"columns\"] += [self.form_data.get(\"geojson\")]",
            "        query_obj[\"metrics\"] = []",
            "        query_obj[\"groupby\"] = []",
            "        return query_obj",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        geojson = data[self.form_data[\"geojson\"]]",
            "        return json.loads(geojson)",
            "",
            "",
            "class DeckArc(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's Arc Layer\"\"\"",
            "",
            "    viz_type = \"deck_arc\"",
            "    verbose_name = _(\"Deck.gl - Arc\")",
            "    spatial_control_keys = [\"start_spatial\", \"end_spatial\"]",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        self.is_timeseries = bool(",
            "            self.form_data.get(\"time_grain_sqla\") or self.form_data.get(\"granularity\")",
            "        )",
            "        return super().query_obj()",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        dim = self.form_data.get(\"dimension\")",
            "        return {",
            "            \"sourcePosition\": data.get(\"start_spatial\"),",
            "            \"targetPosition\": data.get(\"end_spatial\"),",
            "            \"cat_color\": data.get(dim) if dim else None,",
            "            DTTM_ALIAS: data.get(DTTM_ALIAS),",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        return {",
            "            \"features\": super().get_data(df)[\"features\"],  # type: ignore",
            "            \"mapboxApiKey\": config[\"MAPBOX_API_KEY\"],",
            "        }",
            "",
            "",
            "class EventFlowViz(BaseViz):",
            "",
            "    \"\"\"A visualization to explore patterns in event sequences\"\"\"",
            "",
            "    viz_type = \"event_flow\"",
            "    verbose_name = _(\"Event flow\")",
            "    credits = 'from <a href=\"https://github.com/williaster/data-ui\">@data-ui</a>'",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query = super().query_obj()",
            "        form_data = self.form_data",
            "",
            "        event_key = form_data[\"all_columns_x\"]",
            "        entity_key = form_data[\"entity\"]",
            "        meta_keys = [",
            "            col",
            "            for col in form_data[\"all_columns\"] or []",
            "            if col not in (event_key, entity_key)",
            "        ]",
            "",
            "        query[\"columns\"] = [event_key, entity_key] + meta_keys",
            "",
            "        if form_data[\"order_by_entity\"]:",
            "            query[\"orderby\"] = [(entity_key, True)]",
            "",
            "        return query",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        return df.to_dict(orient=\"records\")",
            "",
            "",
            "class PairedTTestViz(BaseViz):",
            "",
            "    \"\"\"A table displaying paired t-test values\"\"\"",
            "",
            "    viz_type = \"paired_ttest\"",
            "    verbose_name = _(\"Time Series - Paired t-test\")",
            "    sort_series = False",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            if self.form_data.get(\"order_desc\"):",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        \"\"\"",
            "        Transform received data frame into an object of the form:",
            "        {",
            "            'metric1': [",
            "                {",
            "                    groups: ('groupA', ... ),",
            "                    values: [ {x, y}, ... ],",
            "                }, ...",
            "            ], ...",
            "        }",
            "        \"\"\"",
            "",
            "        if df.empty:",
            "            return None",
            "",
            "        groups = self.form_data.get(\"groupby\")",
            "        metrics = self.metric_labels",
            "        df = df.pivot_table(index=DTTM_ALIAS, columns=groups, values=metrics)",
            "        cols = []",
            "        # Be rid of falsey keys",
            "        for col in df.columns:",
            "            if col == \"\":",
            "                cols.append(\"N/A\")",
            "            elif col is None:",
            "                cols.append(\"NULL\")",
            "            else:",
            "                cols.append(col)",
            "        df.columns = cols",
            "        data: Dict[str, List[Dict[str, Any]]] = {}",
            "        series = df.to_dict(\"series\")",
            "        for name_set in df.columns:",
            "            # If no groups are defined, nameSet will be the metric name",
            "            has_group = not isinstance(name_set, str)",
            "            data_ = {",
            "                \"group\": name_set[1:] if has_group else \"All\",",
            "                \"values\": [",
            "                    {",
            "                        \"x\": t,",
            "                        \"y\": series[name_set][t] if t in series[name_set] else None,",
            "                    }",
            "                    for t in df.index",
            "                ],",
            "            }",
            "            key = name_set[0] if has_group else name_set",
            "            if key in data:",
            "                data[key].append(data_)",
            "            else:",
            "                data[key] = [data_]",
            "        return data",
            "",
            "",
            "class RoseViz(NVD3TimeSeriesViz):",
            "",
            "    viz_type = \"rose\"",
            "    verbose_name = _(\"Time Series - Nightingale Rose Chart\")",
            "    sort_series = False",
            "    is_timeseries = True",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        data = super().get_data(df)",
            "        result: Dict[str, List[Dict[str, str]]] = {}",
            "        for datum in data:  # type: ignore",
            "            key = datum[\"key\"]",
            "            for val in datum[\"values\"]:",
            "                timestamp = val[\"x\"].value",
            "                if not result.get(timestamp):",
            "                    result[timestamp] = []",
            "                value = 0 if math.isnan(val[\"y\"]) else val[\"y\"]",
            "                result[timestamp].append(",
            "                    {",
            "                        \"key\": key,",
            "                        \"value\": value,",
            "                        \"name\": \", \".join(key) if isinstance(key, list) else key,",
            "                        \"time\": val[\"x\"],",
            "                    }",
            "                )",
            "        return result",
            "",
            "",
            "class PartitionViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"",
            "    A hierarchical data visualization with support for time series.",
            "    \"\"\"",
            "",
            "    viz_type = \"partition\"",
            "    verbose_name = _(\"Partition Diagram\")",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        time_op = self.form_data.get(\"time_series_option\", \"not_time\")",
            "        # Return time series data if the user specifies so",
            "        query_obj[\"is_timeseries\"] = time_op != \"not_time\"",
            "        return query_obj",
            "",
            "    @staticmethod",
            "    def levels_for(",
            "        time_op: str, groups: List[str], df: pd.DataFrame",
            "    ) -> Dict[int, pd.Series]:",
            "        \"\"\"",
            "        Compute the partition at each `level` from the dataframe.",
            "        \"\"\"",
            "        levels = {}",
            "        for i in range(0, len(groups) + 1):",
            "            agg_df = df.groupby(groups[:i]) if i else df",
            "            levels[i] = (",
            "                agg_df.mean()",
            "                if time_op == \"agg_mean\"",
            "                else agg_df.sum(numeric_only=True)",
            "            )",
            "        return levels",
            "",
            "    @staticmethod",
            "    def levels_for_diff(",
            "        time_op: str, groups: List[str], df: pd.DataFrame",
            "    ) -> Dict[int, pd.DataFrame]:",
            "        # Obtain a unique list of the time grains",
            "        times = list(set(df[DTTM_ALIAS]))",
            "        times.sort()",
            "        until = times[len(times) - 1]",
            "        since = times[0]",
            "        # Function describing how to calculate the difference",
            "        func = {",
            "            \"point_diff\": [pd.Series.sub, lambda a, b, fill_value: a - b],",
            "            \"point_factor\": [pd.Series.div, lambda a, b, fill_value: a / float(b)],",
            "            \"point_percent\": [",
            "                lambda a, b, fill_value=0: a.div(b, fill_value=fill_value) - 1,",
            "                lambda a, b, fill_value: a / float(b) - 1,",
            "            ],",
            "        }[time_op]",
            "        agg_df = df.groupby(DTTM_ALIAS).sum()",
            "        levels = {",
            "            0: pd.Series(",
            "                {",
            "                    m: func[1](agg_df[m][until], agg_df[m][since], 0)",
            "                    for m in agg_df.columns",
            "                }",
            "            )",
            "        }",
            "        for i in range(1, len(groups) + 1):",
            "            agg_df = df.groupby([DTTM_ALIAS] + groups[:i]).sum()",
            "            levels[i] = pd.DataFrame(",
            "                {",
            "                    m: func[0](agg_df[m][until], agg_df[m][since], fill_value=0)",
            "                    for m in agg_df.columns",
            "                }",
            "            )",
            "        return levels",
            "",
            "    def levels_for_time(",
            "        self, groups: List[str], df: pd.DataFrame",
            "    ) -> Dict[int, VizData]:",
            "        procs = {}",
            "        for i in range(0, len(groups) + 1):",
            "            self.form_data[\"groupby\"] = groups[:i]",
            "            df_drop = df.drop(groups[i:], 1)",
            "            procs[i] = self.process_data(df_drop, aggregate=True)",
            "        self.form_data[\"groupby\"] = groups",
            "        return procs",
            "",
            "    def nest_values(",
            "        self,",
            "        levels: Dict[int, pd.DataFrame],",
            "        level: int = 0,",
            "        metric: Optional[str] = None,",
            "        dims: Optional[List[str]] = None,",
            "    ) -> List[Dict[str, Any]]:",
            "        \"\"\"",
            "        Nest values at each level on the back-end with",
            "        access and setting, instead of summing from the bottom.",
            "        \"\"\"",
            "        if dims is None:",
            "            dims = []",
            "        if not level:",
            "            return [",
            "                {",
            "                    \"name\": m,",
            "                    \"val\": levels[0][m],",
            "                    \"children\": self.nest_values(levels, 1, m),",
            "                }",
            "                for m in levels[0].index",
            "            ]",
            "        if level == 1:",
            "            metric_level = levels[1][metric]",
            "            return [",
            "                {",
            "                    \"name\": i,",
            "                    \"val\": metric_level[i],",
            "                    \"children\": self.nest_values(levels, 2, metric, [i]),",
            "                }",
            "                for i in metric_level.index",
            "            ]",
            "        if level >= len(levels):",
            "            return []",
            "        dim_level = levels[level][metric][[dims[0]]]",
            "        return [",
            "            {",
            "                \"name\": i,",
            "                \"val\": dim_level[i],",
            "                \"children\": self.nest_values(levels, level + 1, metric, dims + [i]),",
            "            }",
            "            for i in dim_level.index",
            "        ]",
            "",
            "    def nest_procs(",
            "        self,",
            "        procs: Dict[int, pd.DataFrame],",
            "        level: int = -1,",
            "        dims: Optional[Tuple[str, ...]] = None,",
            "        time: Any = None,",
            "    ) -> List[Dict[str, Any]]:",
            "        if dims is None:",
            "            dims = ()",
            "        if level == -1:",
            "            return [",
            "                {\"name\": m, \"children\": self.nest_procs(procs, 0, (m,))}",
            "                for m in procs[0].columns",
            "            ]",
            "        if not level:",
            "            return [",
            "                {",
            "                    \"name\": t,",
            "                    \"val\": procs[0][dims[0]][t],",
            "                    \"children\": self.nest_procs(procs, 1, dims, t),",
            "                }",
            "                for t in procs[0].index",
            "            ]",
            "        if level >= len(procs):",
            "            return []",
            "        return [",
            "            {",
            "                \"name\": i,",
            "                \"val\": procs[level][dims][i][time],",
            "                \"children\": self.nest_procs(procs, level + 1, dims + (i,), time),",
            "            }",
            "            for i in procs[level][dims].columns",
            "        ]",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        groups = self.form_data.get(\"groupby\", [])",
            "        time_op = self.form_data.get(\"time_series_option\", \"not_time\")",
            "        if not groups:",
            "            raise ValueError(\"Please choose at least one groupby\")",
            "        if time_op == \"not_time\":",
            "            levels = self.levels_for(\"agg_sum\", groups, df)",
            "        elif time_op in [\"agg_sum\", \"agg_mean\"]:",
            "            levels = self.levels_for(time_op, groups, df)",
            "        elif time_op in [\"point_diff\", \"point_factor\", \"point_percent\"]:",
            "            levels = self.levels_for_diff(time_op, groups, df)",
            "        elif time_op == \"adv_anal\":",
            "            procs = self.levels_for_time(groups, df)",
            "            return self.nest_procs(procs)",
            "        else:",
            "            levels = self.levels_for(\"agg_sum\", [DTTM_ALIAS] + groups, df)",
            "        return self.nest_values(levels)",
            "",
            "",
            "def get_subclasses(cls: Type[BaseViz]) -> Set[Type[BaseViz]]:",
            "    return set(cls.__subclasses__()).union(",
            "        [sc for c in cls.__subclasses__() for sc in get_subclasses(c)]",
            "    )",
            "",
            "",
            "viz_types = {",
            "    o.viz_type: o",
            "    for o in get_subclasses(BaseViz)",
            "    if o.viz_type not in config[\"VIZ_TYPE_DENYLIST\"]",
            "}"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "# pylint: disable=too-many-lines",
            "\"\"\"This module contains the 'Viz' objects",
            "",
            "These objects represent the backend of all the visualizations that",
            "Superset can render.",
            "\"\"\"",
            "import copy",
            "import dataclasses",
            "import logging",
            "import math",
            "import re",
            "from collections import defaultdict, OrderedDict",
            "from datetime import date, datetime, timedelta",
            "from itertools import product",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    cast,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TYPE_CHECKING,",
            "    Union,",
            ")",
            "",
            "import geohash",
            "import numpy as np",
            "import pandas as pd",
            "import polyline",
            "import simplejson as json",
            "from dateutil import relativedelta as rdelta",
            "from flask import request",
            "from flask_babel import lazy_gettext as _",
            "from geopy.point import Point",
            "from pandas.tseries.frequencies import to_offset",
            "",
            "from superset import app, is_feature_enabled",
            "from superset.common.db_query_status import QueryStatus",
            "from superset.constants import NULL_STRING",
            "from superset.errors import ErrorLevel, SupersetError, SupersetErrorType",
            "from superset.exceptions import (",
            "    CacheLoadError,",
            "    NullValueException,",
            "    QueryObjectValidationError,",
            "    SpatialException,",
            "    SupersetSecurityException,",
            ")",
            "from superset.extensions import cache_manager, security_manager",
            "from superset.models.helpers import QueryResult",
            "from superset.sql_parse import sanitize_clause",
            "from superset.typing import Metric, QueryObjectDict, VizData, VizPayload",
            "from superset.utils import core as utils, csv",
            "from superset.utils.cache import set_and_log_cache",
            "from superset.utils.core import (",
            "    apply_max_row_limit,",
            "    DTTM_ALIAS,",
            "    ExtraFiltersReasonType,",
            "    JS_MAX_INTEGER,",
            "    merge_extra_filters,",
            "    QueryMode,",
            "    simple_filter_to_adhoc,",
            ")",
            "from superset.utils.date_parser import get_since_until, parse_past_timedelta",
            "from superset.utils.dates import datetime_to_epoch",
            "from superset.utils.hashing import md5_sha_from_str",
            "",
            "if TYPE_CHECKING:",
            "    from superset.connectors.base.models import BaseDatasource",
            "",
            "config = app.config",
            "stats_logger = config[\"STATS_LOGGER\"]",
            "relative_start = config[\"DEFAULT_RELATIVE_START_TIME\"]",
            "relative_end = config[\"DEFAULT_RELATIVE_END_TIME\"]",
            "logger = logging.getLogger(__name__)",
            "",
            "METRIC_KEYS = [",
            "    \"metric\",",
            "    \"metrics\",",
            "    \"percent_metrics\",",
            "    \"metric_2\",",
            "    \"secondary_metric\",",
            "    \"x\",",
            "    \"y\",",
            "    \"size\",",
            "]",
            "",
            "",
            "class BaseViz:  # pylint: disable=too-many-public-methods",
            "",
            "    \"\"\"All visualizations derive this base class\"\"\"",
            "",
            "    viz_type: Optional[str] = None",
            "    verbose_name = \"Base Viz\"",
            "    credits = \"\"",
            "    is_timeseries = False",
            "    cache_type = \"df\"",
            "    enforce_numerical_metrics = True",
            "",
            "    def __init__(",
            "        self,",
            "        datasource: \"BaseDatasource\",",
            "        form_data: Dict[str, Any],",
            "        force: bool = False,",
            "        force_cached: bool = False,",
            "    ) -> None:",
            "        if not datasource:",
            "            raise QueryObjectValidationError(_(\"Viz is missing a datasource\"))",
            "",
            "        self.datasource = datasource",
            "        self.request = request",
            "        self.viz_type = form_data.get(\"viz_type\")",
            "        self.form_data = form_data",
            "",
            "        self.query = \"\"",
            "        self.token = utils.get_form_data_token(form_data)",
            "",
            "        self.groupby: List[str] = self.form_data.get(\"groupby\") or []",
            "        self.time_shift = timedelta()",
            "",
            "        self.status: Optional[str] = None",
            "        self.error_msg = \"\"",
            "        self.results: Optional[QueryResult] = None",
            "        self.applied_template_filters: List[str] = []",
            "        self.errors: List[Dict[str, Any]] = []",
            "        self.force = force",
            "        self._force_cached = force_cached",
            "        self.from_dttm: Optional[datetime] = None",
            "        self.to_dttm: Optional[datetime] = None",
            "        self._extra_chart_data: List[Tuple[str, pd.DataFrame]] = []",
            "",
            "        self.process_metrics()",
            "",
            "        self.applied_filters: List[Dict[str, str]] = []",
            "        self.rejected_filters: List[Dict[str, str]] = []",
            "",
            "    @property",
            "    def force_cached(self) -> bool:",
            "        return self._force_cached",
            "",
            "    def process_metrics(self) -> None:",
            "        # metrics in Viz is order sensitive, so metric_dict should be",
            "        # OrderedDict",
            "        self.metric_dict = OrderedDict()",
            "        for mkey in METRIC_KEYS:",
            "            val = self.form_data.get(mkey)",
            "            if val:",
            "                if not isinstance(val, list):",
            "                    val = [val]",
            "                for o in val:",
            "                    label = utils.get_metric_name(o)",
            "                    self.metric_dict[label] = o",
            "",
            "        # Cast to list needed to return serializable object in py3",
            "        self.all_metrics = list(self.metric_dict.values())",
            "        self.metric_labels = list(self.metric_dict.keys())",
            "",
            "    @staticmethod",
            "    def handle_js_int_overflow(",
            "        data: Dict[str, List[Dict[str, Any]]]",
            "    ) -> Dict[str, List[Dict[str, Any]]]:",
            "        for record in data.get(\"records\", {}):",
            "            for k, v in list(record.items()):",
            "                if isinstance(v, int):",
            "                    # if an int is too big for Java Script to handle",
            "                    # convert it to a string",
            "                    if abs(v) > JS_MAX_INTEGER:",
            "                        record[k] = str(v)",
            "        return data",
            "",
            "    def run_extra_queries(self) -> None:",
            "        \"\"\"Lifecycle method to use when more than one query is needed",
            "",
            "        In rare-ish cases, a visualization may need to execute multiple",
            "        queries. That is the case for FilterBox or for time comparison",
            "        in Line chart for instance.",
            "",
            "        In those cases, we need to make sure these queries run before the",
            "        main `get_payload` method gets called, so that the overall caching",
            "        metadata can be right. The way it works here is that if any of",
            "        the previous `get_df_payload` calls hit the cache, the main",
            "        payload's metadata will reflect that.",
            "",
            "        The multi-query support may need more work to become a first class",
            "        use case in the framework, and for the UI to reflect the subtleties",
            "        (show that only some of the queries were served from cache for",
            "        instance). In the meantime, since multi-query is rare, we treat",
            "        it with a bit of a hack. Note that the hack became necessary",
            "        when moving from caching the visualization's data itself, to caching",
            "        the underlying query(ies).",
            "        \"\"\"",
            "",
            "    def apply_rolling(self, df: pd.DataFrame) -> pd.DataFrame:",
            "        rolling_type = self.form_data.get(\"rolling_type\")",
            "        rolling_periods = int(self.form_data.get(\"rolling_periods\") or 0)",
            "        min_periods = int(self.form_data.get(\"min_periods\") or 0)",
            "",
            "        if rolling_type in (\"mean\", \"std\", \"sum\") and rolling_periods:",
            "            kwargs = dict(window=rolling_periods, min_periods=min_periods)",
            "            if rolling_type == \"mean\":",
            "                df = df.rolling(**kwargs).mean()",
            "            elif rolling_type == \"std\":",
            "                df = df.rolling(**kwargs).std()",
            "            elif rolling_type == \"sum\":",
            "                df = df.rolling(**kwargs).sum()",
            "        elif rolling_type == \"cumsum\":",
            "            df = df.cumsum()",
            "        if min_periods:",
            "            df = df[min_periods:]",
            "        if df.empty:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Applied rolling window did not return any data. Please make sure \"",
            "                    \"the source query satisfies the minimum periods defined in the \"",
            "                    \"rolling window.\"",
            "                )",
            "            )",
            "        return df",
            "",
            "    def get_samples(self) -> List[Dict[str, Any]]:",
            "        query_obj = self.query_obj()",
            "        query_obj.update(",
            "            {",
            "                \"is_timeseries\": False,",
            "                \"groupby\": [],",
            "                \"metrics\": [],",
            "                \"orderby\": [],",
            "                \"row_limit\": config[\"SAMPLES_ROW_LIMIT\"],",
            "                \"columns\": [o.column_name for o in self.datasource.columns],",
            "            }",
            "        )",
            "        df = self.get_df_payload(query_obj)[\"df\"]  # leverage caching logic",
            "        return df.to_dict(orient=\"records\")",
            "",
            "    def get_df(self, query_obj: Optional[QueryObjectDict] = None) -> pd.DataFrame:",
            "        \"\"\"Returns a pandas dataframe based on the query object\"\"\"",
            "        if not query_obj:",
            "            query_obj = self.query_obj()",
            "        if not query_obj:",
            "            return pd.DataFrame()",
            "",
            "        self.error_msg = \"\"",
            "",
            "        timestamp_format = None",
            "        if self.datasource.type == \"table\":",
            "            granularity_col = self.datasource.get_column(query_obj[\"granularity\"])",
            "            if granularity_col:",
            "                timestamp_format = granularity_col.python_date_format",
            "",
            "        # The datasource here can be different backend but the interface is common",
            "        self.results = self.datasource.query(query_obj)",
            "        self.applied_template_filters = self.results.applied_template_filters or []",
            "        self.query = self.results.query",
            "        self.status = self.results.status",
            "        self.errors = self.results.errors",
            "",
            "        df = self.results.df",
            "        # Transform the timestamp we received from database to pandas supported",
            "        # datetime format. If no python_date_format is specified, the pattern will",
            "        # be considered as the default ISO date format",
            "        # If the datetime format is unix, the parse will use the corresponding",
            "        # parsing logic.",
            "        if not df.empty:",
            "            utils.normalize_dttm_col(",
            "                df=df,",
            "                timestamp_format=timestamp_format,",
            "                offset=self.datasource.offset,",
            "                time_shift=self.time_shift,",
            "            )",
            "",
            "            if self.enforce_numerical_metrics:",
            "                self.df_metrics_to_num(df)",
            "",
            "            df.replace([np.inf, -np.inf], np.nan, inplace=True)",
            "        return df",
            "",
            "    def df_metrics_to_num(self, df: pd.DataFrame) -> None:",
            "        \"\"\"Converting metrics to numeric when pandas.read_sql cannot\"\"\"",
            "        metrics = self.metric_labels",
            "        for col, dtype in df.dtypes.items():",
            "            if dtype.type == np.object_ and col in metrics:",
            "                df[col] = pd.to_numeric(df[col], errors=\"coerce\")",
            "",
            "    def process_query_filters(self) -> None:",
            "        utils.convert_legacy_filters_into_adhoc(self.form_data)",
            "        merge_extra_filters(self.form_data)",
            "        utils.split_adhoc_filters_into_base_filters(self.form_data)",
            "",
            "    def query_obj(self) -> QueryObjectDict:  # pylint: disable=too-many-locals",
            "        \"\"\"Building a query object\"\"\"",
            "        self.process_query_filters()",
            "",
            "        gb = self.groupby",
            "        metrics = self.all_metrics or []",
            "        columns = self.form_data.get(\"columns\") or []",
            "        # merge list and dedup while preserving order",
            "        groupby = list(OrderedDict.fromkeys(gb + columns))",
            "",
            "        is_timeseries = self.is_timeseries",
            "        if DTTM_ALIAS in groupby:",
            "            groupby.remove(DTTM_ALIAS)",
            "            is_timeseries = True",
            "",
            "        granularity = self.form_data.get(\"granularity\") or self.form_data.get(",
            "            \"granularity_sqla\"",
            "        )",
            "        limit = int(self.form_data.get(\"limit\") or 0)",
            "        timeseries_limit_metric = self.form_data.get(\"timeseries_limit_metric\")",
            "",
            "        # apply row limit to query",
            "        row_limit = int(self.form_data.get(\"row_limit\") or config[\"ROW_LIMIT\"])",
            "        row_limit = apply_max_row_limit(row_limit)",
            "",
            "        # default order direction",
            "        order_desc = self.form_data.get(\"order_desc\", True)",
            "",
            "        try:",
            "            since, until = get_since_until(",
            "                relative_start=relative_start,",
            "                relative_end=relative_end,",
            "                time_range=self.form_data.get(\"time_range\"),",
            "                since=self.form_data.get(\"since\"),",
            "                until=self.form_data.get(\"until\"),",
            "            )",
            "        except ValueError as ex:",
            "            raise QueryObjectValidationError(str(ex)) from ex",
            "",
            "        time_shift = self.form_data.get(\"time_shift\", \"\")",
            "        self.time_shift = parse_past_timedelta(time_shift)",
            "        from_dttm = None if since is None else (since - self.time_shift)",
            "        to_dttm = None if until is None else (until - self.time_shift)",
            "        if from_dttm and to_dttm and from_dttm > to_dttm:",
            "            raise QueryObjectValidationError(",
            "                _(\"From date cannot be larger than to date\")",
            "            )",
            "",
            "        self.from_dttm = from_dttm",
            "        self.to_dttm = to_dttm",
            "",
            "        # validate sql filters",
            "        for param in (\"where\", \"having\"):",
            "            clause = self.form_data.get(param)",
            "            if clause:",
            "                sanitized_clause = sanitize_clause(clause)",
            "                if sanitized_clause != clause:",
            "                    self.form_data[param] = sanitized_clause",
            "",
            "        # extras are used to query elements specific to a datasource type",
            "        # for instance the extra where clause that applies only to Tables",
            "        extras = {",
            "            \"druid_time_origin\": self.form_data.get(\"druid_time_origin\", \"\"),",
            "            \"having\": self.form_data.get(\"having\", \"\"),",
            "            \"having_druid\": self.form_data.get(\"having_filters\", []),",
            "            \"time_grain_sqla\": self.form_data.get(\"time_grain_sqla\"),",
            "            \"time_range_endpoints\": self.form_data.get(\"time_range_endpoints\"),",
            "            \"where\": self.form_data.get(\"where\", \"\"),",
            "        }",
            "",
            "        return {",
            "            \"granularity\": granularity,",
            "            \"from_dttm\": from_dttm,",
            "            \"to_dttm\": to_dttm,",
            "            \"is_timeseries\": is_timeseries,",
            "            \"groupby\": groupby,",
            "            \"metrics\": metrics,",
            "            \"row_limit\": row_limit,",
            "            \"filter\": self.form_data.get(\"filters\", []),",
            "            \"timeseries_limit\": limit,",
            "            \"extras\": extras,",
            "            \"timeseries_limit_metric\": timeseries_limit_metric,",
            "            \"order_desc\": order_desc,",
            "        }",
            "",
            "    @property",
            "    def cache_timeout(self) -> int:",
            "        if self.form_data.get(\"cache_timeout\") is not None:",
            "            return int(self.form_data[\"cache_timeout\"])",
            "        if self.datasource.cache_timeout is not None:",
            "            return self.datasource.cache_timeout",
            "        if (",
            "            hasattr(self.datasource, \"database\")",
            "            and self.datasource.database.cache_timeout",
            "        ) is not None:",
            "            return self.datasource.database.cache_timeout",
            "        if config[\"DATA_CACHE_CONFIG\"].get(\"CACHE_DEFAULT_TIMEOUT\") is not None:",
            "            return config[\"DATA_CACHE_CONFIG\"][\"CACHE_DEFAULT_TIMEOUT\"]",
            "        return config[\"CACHE_DEFAULT_TIMEOUT\"]",
            "",
            "    def get_json(self) -> str:",
            "        return json.dumps(",
            "            self.get_payload(), default=utils.json_int_dttm_ser, ignore_nan=True",
            "        )",
            "",
            "    def cache_key(self, query_obj: QueryObjectDict, **extra: Any) -> str:",
            "        \"\"\"",
            "        The cache key is made out of the key/values in `query_obj`, plus any",
            "        other key/values in `extra`.",
            "",
            "        We remove datetime bounds that are hard values, and replace them with",
            "        the use-provided inputs to bounds, which may be time-relative (as in",
            "        \"5 days ago\" or \"now\").",
            "",
            "        The `extra` arguments are currently used by time shift queries, since",
            "        different time shifts wil differ only in the `from_dttm`, `to_dttm`,",
            "        `inner_from_dttm`, and `inner_to_dttm` values which are stripped.",
            "        \"\"\"",
            "        cache_dict = copy.copy(query_obj)",
            "        cache_dict.update(extra)",
            "",
            "        for k in [\"from_dttm\", \"to_dttm\", \"inner_from_dttm\", \"inner_to_dttm\"]:",
            "            if k in cache_dict:",
            "                del cache_dict[k]",
            "",
            "        cache_dict[\"time_range\"] = self.form_data.get(\"time_range\")",
            "        cache_dict[\"datasource\"] = self.datasource.uid",
            "        cache_dict[\"extra_cache_keys\"] = self.datasource.get_extra_cache_keys(query_obj)",
            "        cache_dict[\"rls\"] = (",
            "            security_manager.get_rls_ids(self.datasource)",
            "            if is_feature_enabled(\"ROW_LEVEL_SECURITY\")",
            "            and self.datasource.is_rls_supported",
            "            else []",
            "        )",
            "        cache_dict[\"changed_on\"] = self.datasource.changed_on",
            "        json_data = self.json_dumps(cache_dict, sort_keys=True)",
            "        return md5_sha_from_str(json_data)",
            "",
            "    def get_payload(self, query_obj: Optional[QueryObjectDict] = None) -> VizPayload:",
            "        \"\"\"Returns a payload of metadata and data\"\"\"",
            "",
            "        try:",
            "            self.run_extra_queries()",
            "        except SupersetSecurityException as ex:",
            "            error = dataclasses.asdict(ex.error)",
            "            self.errors.append(error)",
            "            self.status = QueryStatus.FAILED",
            "",
            "        payload = self.get_df_payload(query_obj)",
            "",
            "        # if payload does not have a df, we are raising an error here.",
            "        df = cast(Optional[pd.DataFrame], payload[\"df\"])",
            "",
            "        if self.status != QueryStatus.FAILED:",
            "            payload[\"data\"] = self.get_data(df)",
            "        if \"df\" in payload:",
            "            del payload[\"df\"]",
            "",
            "        filters = self.form_data.get(\"filters\", [])",
            "        filter_columns = [flt.get(\"col\") for flt in filters]",
            "        columns = set(self.datasource.column_names)",
            "        applied_template_filters = self.applied_template_filters or []",
            "        applied_time_extras = self.form_data.get(\"applied_time_extras\", {})",
            "        applied_time_columns, rejected_time_columns = utils.get_time_filter_status(",
            "            self.datasource, applied_time_extras",
            "        )",
            "        payload[\"applied_filters\"] = [",
            "            {\"column\": col}",
            "            for col in filter_columns",
            "            if col in columns or col in applied_template_filters",
            "        ] + applied_time_columns",
            "        payload[\"rejected_filters\"] = [",
            "            {\"reason\": ExtraFiltersReasonType.COL_NOT_IN_DATASOURCE, \"column\": col}",
            "            for col in filter_columns",
            "            if col not in columns and col not in applied_template_filters",
            "        ] + rejected_time_columns",
            "        if df is not None:",
            "            payload[\"colnames\"] = list(df.columns)",
            "        return payload",
            "",
            "    def get_df_payload(  # pylint: disable=too-many-statements",
            "        self, query_obj: Optional[QueryObjectDict] = None, **kwargs: Any",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"Handles caching around the df payload retrieval\"\"\"",
            "        if not query_obj:",
            "            query_obj = self.query_obj()",
            "        cache_key = self.cache_key(query_obj, **kwargs) if query_obj else None",
            "        cache_value = None",
            "        logger.info(\"Cache key: %s\", cache_key)",
            "        is_loaded = False",
            "        stacktrace = None",
            "        df = None",
            "        if cache_key and cache_manager.data_cache and not self.force:",
            "            cache_value = cache_manager.data_cache.get(cache_key)",
            "            if cache_value:",
            "                stats_logger.incr(\"loading_from_cache\")",
            "                try:",
            "                    df = cache_value[\"df\"]",
            "                    self.query = cache_value[\"query\"]",
            "                    self.applied_template_filters = cache_value.get(",
            "                        \"applied_template_filters\", []",
            "                    )",
            "                    self.status = QueryStatus.SUCCESS",
            "                    is_loaded = True",
            "                    stats_logger.incr(\"loaded_from_cache\")",
            "                except Exception as ex:  # pylint: disable=broad-except",
            "                    logger.exception(ex)",
            "                    logger.error(",
            "                        \"Error reading cache: %s\",",
            "                        utils.error_msg_from_exception(ex),",
            "                        exc_info=True,",
            "                    )",
            "                logger.info(\"Serving from cache\")",
            "",
            "        if query_obj and not is_loaded:",
            "            if self.force_cached:",
            "                logger.warning(",
            "                    \"force_cached (viz.py): value not found for cache key %s\",",
            "                    cache_key,",
            "                )",
            "                raise CacheLoadError(_(\"Cached value not found\"))",
            "            try:",
            "                invalid_columns = [",
            "                    col",
            "                    for col in (query_obj.get(\"columns\") or [])",
            "                    + (query_obj.get(\"groupby\") or [])",
            "                    + utils.get_column_names_from_metrics(",
            "                        cast(List[Metric], query_obj.get(\"metrics\") or [],)",
            "                    )",
            "                    if col not in self.datasource.column_names",
            "                ]",
            "                if invalid_columns:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Columns missing in datasource: %(invalid_columns)s\",",
            "                            invalid_columns=invalid_columns,",
            "                        )",
            "                    )",
            "                df = self.get_df(query_obj)",
            "                if self.status != QueryStatus.FAILED:",
            "                    stats_logger.incr(\"loaded_from_source\")",
            "                    if not self.force:",
            "                        stats_logger.incr(\"loaded_from_source_without_force\")",
            "                    is_loaded = True",
            "            except QueryObjectValidationError as ex:",
            "                error = dataclasses.asdict(",
            "                    SupersetError(",
            "                        message=str(ex),",
            "                        level=ErrorLevel.ERROR,",
            "                        error_type=SupersetErrorType.VIZ_GET_DF_ERROR,",
            "                    )",
            "                )",
            "                self.errors.append(error)",
            "                self.status = QueryStatus.FAILED",
            "            except Exception as ex:  # pylint: disable=broad-except",
            "                logger.exception(ex)",
            "",
            "                error = dataclasses.asdict(",
            "                    SupersetError(",
            "                        message=str(ex),",
            "                        level=ErrorLevel.ERROR,",
            "                        error_type=SupersetErrorType.VIZ_GET_DF_ERROR,",
            "                    )",
            "                )",
            "                self.errors.append(error)",
            "                self.status = QueryStatus.FAILED",
            "                stacktrace = utils.get_stacktrace()",
            "",
            "            if is_loaded and cache_key and self.status != QueryStatus.FAILED:",
            "                set_and_log_cache(",
            "                    cache_manager.data_cache,",
            "                    cache_key,",
            "                    {\"df\": df, \"query\": self.query},",
            "                    self.cache_timeout,",
            "                    self.datasource.uid,",
            "                )",
            "        return {",
            "            \"cache_key\": cache_key,",
            "            \"cached_dttm\": cache_value[\"dttm\"] if cache_value is not None else None,",
            "            \"cache_timeout\": self.cache_timeout,",
            "            \"df\": df,",
            "            \"errors\": self.errors,",
            "            \"form_data\": self.form_data,",
            "            \"is_cached\": cache_value is not None,",
            "            \"query\": self.query,",
            "            \"from_dttm\": self.from_dttm,",
            "            \"to_dttm\": self.to_dttm,",
            "            \"status\": self.status,",
            "            \"stacktrace\": stacktrace,",
            "            \"rowcount\": len(df.index) if df is not None else 0,",
            "        }",
            "",
            "    @staticmethod",
            "    def json_dumps(query_obj: Any, sort_keys: bool = False) -> str:",
            "        return json.dumps(",
            "            query_obj,",
            "            default=utils.json_int_dttm_ser,",
            "            ignore_nan=True,",
            "            sort_keys=sort_keys,",
            "        )",
            "",
            "    @staticmethod",
            "    def has_error(payload: VizPayload) -> bool:",
            "        return (",
            "            payload.get(\"status\") == QueryStatus.FAILED",
            "            or payload.get(\"error\") is not None",
            "            or bool(payload.get(\"errors\"))",
            "        )",
            "",
            "    def payload_json_and_has_error(self, payload: VizPayload) -> Tuple[str, bool]:",
            "        return self.json_dumps(payload), self.has_error(payload)",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        \"\"\"This is the data object serialized to the js layer\"\"\"",
            "        content = {",
            "            \"form_data\": self.form_data,",
            "            \"token\": self.token,",
            "            \"viz_name\": self.viz_type,",
            "            \"filter_select_enabled\": self.datasource.filter_select_enabled,",
            "        }",
            "        return content",
            "",
            "    def get_csv(self) -> Optional[str]:",
            "        df = self.get_df_payload()[\"df\"]  # leverage caching logic",
            "        include_index = not isinstance(df.index, pd.RangeIndex)",
            "        return csv.df_to_escaped_csv(df, index=include_index, **config[\"CSV_EXPORT\"])",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:  # pylint: disable=no-self-use",
            "        return df.to_dict(orient=\"records\")",
            "",
            "    @property",
            "    def json_data(self) -> str:",
            "        return json.dumps(self.data)",
            "",
            "    def raise_for_access(self) -> None:",
            "        \"\"\"",
            "        Raise an exception if the user cannot access the resource.",
            "",
            "        :raises SupersetSecurityException: If the user cannot access the resource",
            "        \"\"\"",
            "",
            "        security_manager.raise_for_access(viz=self)",
            "",
            "",
            "class TableViz(BaseViz):",
            "",
            "    \"\"\"A basic html table that is sortable and searchable\"\"\"",
            "",
            "    viz_type = \"table\"",
            "    verbose_name = _(\"Table View\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = False",
            "    enforce_numerical_metrics = False",
            "",
            "    def process_metrics(self) -> None:",
            "        \"\"\"Process form data and store parsed column configs.",
            "        1. Determine query mode based on form_data params.",
            "             - Use `query_mode` if it has a valid value",
            "             - Set as RAW mode if `all_columns` is set",
            "             - Otherwise defaults to AGG mode",
            "        2. Determine output columns based on query mode.",
            "        \"\"\"",
            "        # Verify form data first: if not specifying query mode, then cannot have both",
            "        # GROUP BY and RAW COLUMNS.",
            "        if (",
            "            not self.form_data.get(\"query_mode\")",
            "            and self.form_data.get(\"all_columns\")",
            "            and (",
            "                self.form_data.get(\"groupby\")",
            "                or self.form_data.get(\"metrics\")",
            "                or self.form_data.get(\"percent_metrics\")",
            "            )",
            "        ):",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"You cannot use [Columns] in combination with \"",
            "                    \"[Group By]/[Metrics]/[Percentage Metrics]. \"",
            "                    \"Please choose one or the other.\"",
            "                )",
            "            )",
            "",
            "        super().process_metrics()",
            "",
            "        self.query_mode: QueryMode = QueryMode.get(",
            "            self.form_data.get(\"query_mode\")",
            "        ) or (",
            "            # infer query mode from the presence of other fields",
            "            QueryMode.RAW",
            "            if len(self.form_data.get(\"all_columns\") or []) > 0",
            "            else QueryMode.AGGREGATE",
            "        )",
            "",
            "        columns: List[str] = []  # output columns sans time and percent_metric column",
            "        percent_columns: List[str] = []  # percent columns that needs extra computation",
            "",
            "        if self.query_mode == QueryMode.RAW:",
            "            columns = utils.get_metric_names(self.form_data.get(\"all_columns\") or [])",
            "        else:",
            "            columns = utils.get_metric_names(",
            "                self.groupby + (self.form_data.get(\"metrics\") or [])",
            "            )",
            "            percent_columns = utils.get_metric_names(",
            "                self.form_data.get(\"percent_metrics\") or []",
            "            )",
            "",
            "        self.columns = columns",
            "        self.percent_columns = percent_columns",
            "        self.is_timeseries = self.should_be_timeseries()",
            "",
            "    def should_be_timeseries(self) -> bool:",
            "        # TODO handle datasource-type-specific code in datasource",
            "        conditions_met = (",
            "            self.form_data.get(\"granularity\")",
            "            and self.form_data.get(\"granularity\") != \"all\"",
            "        ) or (",
            "            self.form_data.get(\"granularity_sqla\")",
            "            and self.form_data.get(\"time_grain_sqla\")",
            "        )",
            "        if self.form_data.get(\"include_time\") and not conditions_met:",
            "            raise QueryObjectValidationError(",
            "                _(\"Pick a granularity in the Time section or \" \"uncheck 'Include Time'\")",
            "            )",
            "        return bool(self.form_data.get(\"include_time\"))",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        if self.query_mode == QueryMode.RAW:",
            "            query_obj[\"columns\"] = self.form_data.get(\"all_columns\")",
            "            order_by_cols = self.form_data.get(\"order_by_cols\") or []",
            "            query_obj[\"orderby\"] = [json.loads(t) for t in order_by_cols]",
            "            # must disable groupby and metrics in raw mode",
            "            query_obj[\"groupby\"] = []",
            "            query_obj[\"metrics\"] = []",
            "            # raw mode does not support timeseries queries",
            "            query_obj[\"timeseries_limit_metric\"] = None",
            "            query_obj[\"timeseries_limit\"] = None",
            "            query_obj[\"is_timeseries\"] = None",
            "        else:",
            "            sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "            if sort_by:",
            "                sort_by_label = utils.get_metric_name(sort_by)",
            "                if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                    query_obj[\"metrics\"].append(sort_by)",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "            elif query_obj[\"metrics\"]:",
            "                # Legacy behavior of sorting by first metric by default",
            "                first_metric = query_obj[\"metrics\"][0]",
            "                query_obj[\"orderby\"] = [",
            "                    (first_metric, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        \"\"\"",
            "        Transform the query result to the table representation.",
            "",
            "        :param df: The interim dataframe",
            "        :returns: The table visualization data",
            "",
            "        The interim dataframe comprises of the group-by and non-group-by columns and",
            "        the union of the metrics representing the non-percent and percent metrics. Note",
            "        the percent metrics have yet to be transformed.",
            "        \"\"\"",
            "        # Transform the data frame to adhere to the UI ordering of the columns and",
            "        # metrics whilst simultaneously computing the percentages (via normalization)",
            "        # for the percent metrics.",
            "        if df.empty:",
            "            return None",
            "",
            "        columns, percent_columns = self.columns, self.percent_columns",
            "        if DTTM_ALIAS in df and self.is_timeseries:",
            "            columns = [DTTM_ALIAS] + columns",
            "        df = pd.concat(",
            "            [",
            "                df[columns],",
            "                (df[percent_columns].div(df[percent_columns].sum()).add_prefix(\"%\")),",
            "            ],",
            "            axis=1,",
            "        )",
            "        return self.handle_js_int_overflow(",
            "            dict(records=df.to_dict(orient=\"records\"), columns=list(df.columns))",
            "        )",
            "",
            "    @staticmethod",
            "    def json_dumps(query_obj: Any, sort_keys: bool = False) -> str:",
            "        return json.dumps(",
            "            query_obj,",
            "            default=utils.json_iso_dttm_ser,",
            "            sort_keys=sort_keys,",
            "            ignore_nan=True,",
            "        )",
            "",
            "",
            "class TimeTableViz(BaseViz):",
            "",
            "    \"\"\"A data table with rich time-series related columns\"\"\"",
            "",
            "    viz_type = \"time_table\"",
            "    verbose_name = _(\"Time Table View\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "",
            "        if not self.form_data.get(\"metrics\"):",
            "            raise QueryObjectValidationError(_(\"Pick at least one metric\"))",
            "",
            "        if self.form_data.get(\"groupby\") and len(self.form_data[\"metrics\"]) > 1:",
            "            raise QueryObjectValidationError(",
            "                _(\"When using 'Group By' you are limited to use a single metric\")",
            "            )",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        columns = None",
            "        values: Union[List[str], str] = self.metric_labels",
            "        if self.form_data.get(\"groupby\"):",
            "            values = self.metric_labels[0]",
            "            columns = self.form_data.get(\"groupby\")",
            "        pt = df.pivot_table(index=DTTM_ALIAS, columns=columns, values=values)",
            "        pt.index = pt.index.map(str)",
            "        pt = pt.sort_index()",
            "        return dict(",
            "            records=pt.to_dict(orient=\"index\"),",
            "            columns=list(pt.columns),",
            "            is_group_by=bool(self.form_data.get(\"groupby\")),",
            "        )",
            "",
            "",
            "class PivotTableViz(BaseViz):",
            "",
            "    \"\"\"A pivot table view, define your rows, columns and metrics\"\"\"",
            "",
            "    viz_type = \"pivot_table\"",
            "    verbose_name = _(\"Pivot Table\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = False",
            "    enforce_numerical_metrics = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        groupby = self.form_data.get(\"groupby\")",
            "        columns = self.form_data.get(\"columns\")",
            "        metrics = self.form_data.get(\"metrics\")",
            "        transpose = self.form_data.get(\"transpose_pivot\")",
            "        if not columns:",
            "            columns = []",
            "        if not groupby:",
            "            groupby = []",
            "        if not groupby:",
            "            raise QueryObjectValidationError(",
            "                _(\"Please choose at least one 'Group by' field \")",
            "            )",
            "        if transpose and not columns:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    (",
            "                        \"Please choose at least one 'Columns' field when \"",
            "                        \"select 'Transpose Pivot' option\"",
            "                    )",
            "                )",
            "            )",
            "        if not metrics:",
            "            raise QueryObjectValidationError(_(\"Please choose at least one metric\"))",
            "        if set(groupby) & set(columns):",
            "            raise QueryObjectValidationError(_(\"Group By' and 'Columns' can't overlap\"))",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            if self.form_data.get(\"order_desc\"):",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    @staticmethod",
            "    def get_aggfunc(",
            "        metric: str, df: pd.DataFrame, form_data: Dict[str, Any]",
            "    ) -> Union[str, Callable[[Any], Any]]:",
            "        aggfunc = form_data.get(\"pandas_aggfunc\") or \"sum\"",
            "        if pd.api.types.is_numeric_dtype(df[metric]):",
            "            # Ensure that Pandas's sum function mimics that of SQL.",
            "            if aggfunc == \"sum\":",
            "                return lambda x: x.sum(min_count=1)",
            "        # only min and max work properly for non-numerics",
            "        return aggfunc if aggfunc in (\"min\", \"max\") else \"max\"",
            "",
            "    @staticmethod",
            "    def _format_datetime(value: Union[pd.Timestamp, datetime, date, str]) -> str:",
            "        \"\"\"",
            "        Format a timestamp in such a way that the viz will be able to apply",
            "        the correct formatting in the frontend.",
            "",
            "        :param value: the value of a temporal column",
            "        :return: formatted timestamp if it is a valid timestamp, otherwise",
            "                 the original value",
            "        \"\"\"",
            "        tstamp: Optional[pd.Timestamp] = None",
            "        if isinstance(value, pd.Timestamp):",
            "            tstamp = value",
            "        if isinstance(value, (date, datetime)):",
            "            tstamp = pd.Timestamp(value)",
            "        if isinstance(value, str):",
            "            try:",
            "                tstamp = pd.Timestamp(value)",
            "            except ValueError:",
            "                pass",
            "        if tstamp:",
            "            return f\"__timestamp:{datetime_to_epoch(tstamp)}\"",
            "        # fallback in case something incompatible is returned",
            "        return cast(str, value)",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        if self.form_data.get(\"granularity\") == \"all\" and DTTM_ALIAS in df:",
            "            del df[DTTM_ALIAS]",
            "",
            "        metrics = [utils.get_metric_name(m) for m in self.form_data[\"metrics\"]]",
            "        aggfuncs: Dict[str, Union[str, Callable[[Any], Any]]] = {}",
            "        for metric in metrics:",
            "            aggfuncs[metric] = self.get_aggfunc(metric, df, self.form_data)",
            "",
            "        groupby = self.form_data.get(\"groupby\") or []",
            "        columns = self.form_data.get(\"columns\") or []",
            "",
            "        for column_name in groupby + columns:",
            "            column = self.datasource.get_column(column_name)",
            "            if column and column.is_temporal:",
            "                ts = df[column_name].apply(self._format_datetime)",
            "                df[column_name] = ts",
            "",
            "        if self.form_data.get(\"transpose_pivot\"):",
            "            groupby, columns = columns, groupby",
            "",
            "        df = df.pivot_table(",
            "            index=groupby,",
            "            columns=columns,",
            "            values=metrics,",
            "            aggfunc=aggfuncs,",
            "            margins=self.form_data.get(\"pivot_margins\"),",
            "        )",
            "",
            "        # Re-order the columns adhering to the metric ordering.",
            "        df = df[metrics]",
            "",
            "        # Display metrics side by side with each column",
            "        if self.form_data.get(\"combine_metric\"):",
            "            df = df.stack(0).unstack().reindex(level=-1, columns=metrics)",
            "        return dict(",
            "            columns=list(df.columns),",
            "            html=df.to_html(",
            "                na_rep=\"null\",",
            "                classes=(",
            "                    \"dataframe table table-striped table-bordered \"",
            "                    \"table-condensed table-hover\"",
            "                ).split(\" \"),",
            "            ),",
            "        )",
            "",
            "",
            "class TreemapViz(BaseViz):",
            "",
            "    \"\"\"Tree map visualisation for hierarchical data.\"\"\"",
            "",
            "    viz_type = \"treemap\"",
            "    verbose_name = _(\"Treemap\")",
            "    credits = '<a href=\"https://d3js.org\">d3.js</a>'",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            if self.form_data.get(\"order_desc\"):",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    def _nest(self, metric: str, df: pd.DataFrame) -> List[Dict[str, Any]]:",
            "        nlevels = df.index.nlevels",
            "        if nlevels == 1:",
            "            result = [{\"name\": n, \"value\": v} for n, v in zip(df.index, df[metric])]",
            "        else:",
            "            result = [",
            "                {\"name\": l, \"children\": self._nest(metric, df.loc[l])}",
            "                for l in df.index.levels[0]",
            "            ]",
            "        return result",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df = df.set_index(self.form_data.get(\"groupby\"))",
            "        chart_data = [",
            "            {\"name\": metric, \"children\": self._nest(metric, df)}",
            "            for metric in df.columns",
            "        ]",
            "        return chart_data",
            "",
            "",
            "class CalHeatmapViz(BaseViz):",
            "",
            "    \"\"\"Calendar heatmap.\"\"\"",
            "",
            "    viz_type = \"cal_heatmap\"",
            "    verbose_name = _(\"Calendar Heatmap\")",
            "    credits = \"<a href=https://github.com/wa0x6e/cal-heatmap>cal-heatmap</a>\"",
            "    is_timeseries = True",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:  # pylint: disable=too-many-locals",
            "        if df.empty:",
            "            return None",
            "",
            "        form_data = self.form_data",
            "        data = {}",
            "        records = df.to_dict(\"records\")",
            "        for metric in self.metric_labels:",
            "            values = {}",
            "            for query_obj in records:",
            "                v = query_obj[DTTM_ALIAS]",
            "                if hasattr(v, \"value\"):",
            "                    v = v.value",
            "                values[str(v / 10 ** 9)] = query_obj.get(metric)",
            "            data[metric] = values",
            "",
            "        try:",
            "            start, end = get_since_until(",
            "                relative_start=relative_start,",
            "                relative_end=relative_end,",
            "                time_range=form_data.get(\"time_range\"),",
            "                since=form_data.get(\"since\"),",
            "                until=form_data.get(\"until\"),",
            "            )",
            "        except ValueError as ex:",
            "            raise QueryObjectValidationError(str(ex)) from ex",
            "        if not start or not end:",
            "            raise QueryObjectValidationError(",
            "                \"Please provide both time bounds (Since and Until)\"",
            "            )",
            "        domain = form_data.get(\"domain_granularity\")",
            "        diff_delta = rdelta.relativedelta(end, start)",
            "        diff_secs = (end - start).total_seconds()",
            "",
            "        if domain == \"year\":",
            "            range_ = end.year - start.year + 1",
            "        elif domain == \"month\":",
            "            range_ = diff_delta.years * 12 + diff_delta.months + 1",
            "        elif domain == \"week\":",
            "            range_ = diff_delta.years * 53 + diff_delta.weeks + 1",
            "        elif domain == \"day\":",
            "            range_ = diff_secs // (24 * 60 * 60) + 1  # type: ignore",
            "        else:",
            "            range_ = diff_secs // (60 * 60) + 1  # type: ignore",
            "",
            "        return {",
            "            \"data\": data,",
            "            \"start\": start,",
            "            \"domain\": domain,",
            "            \"subdomain\": form_data.get(\"subdomain_granularity\"),",
            "            \"range\": range_,",
            "        }",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"metrics\"] = self.form_data.get(\"metrics\")",
            "        mapping = {",
            "            \"min\": \"PT1M\",",
            "            \"hour\": \"PT1H\",",
            "            \"day\": \"P1D\",",
            "            \"week\": \"P1W\",",
            "            \"month\": \"P1M\",",
            "            \"year\": \"P1Y\",",
            "        }",
            "        time_grain = mapping[self.form_data.get(\"subdomain_granularity\", \"min\")]",
            "        if self.datasource.type == \"druid\":",
            "            query_obj[\"granularity\"] = time_grain",
            "        else:",
            "            query_obj[\"extras\"][\"time_grain_sqla\"] = time_grain",
            "        return query_obj",
            "",
            "",
            "class NVD3Viz(BaseViz):",
            "",
            "    \"\"\"Base class for all nvd3 vizs\"\"\"",
            "",
            "    credits = '<a href=\"http://nvd3.org/\">NVD3.org</a>'",
            "    viz_type: Optional[str] = None",
            "    verbose_name = \"Base NVD3 Viz\"",
            "    is_timeseries = False",
            "",
            "",
            "class BubbleViz(NVD3Viz):",
            "",
            "    \"\"\"Based on the NVD3 bubble chart\"\"\"",
            "",
            "    viz_type = \"bubble\"",
            "    verbose_name = _(\"Bubble Chart\")",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"groupby\"] = [self.form_data.get(\"entity\")]",
            "        if self.form_data.get(\"series\"):",
            "            query_obj[\"groupby\"].append(self.form_data.get(\"series\"))",
            "",
            "        # dedup groupby if it happens to be the same",
            "        query_obj[\"groupby\"] = list(dict.fromkeys(query_obj[\"groupby\"]))",
            "",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.x_metric = self.form_data[\"x\"]",
            "        self.y_metric = self.form_data[\"y\"]",
            "        self.z_metric = self.form_data[\"size\"]",
            "        self.entity = self.form_data.get(\"entity\")",
            "        self.series = self.form_data.get(\"series\") or self.entity",
            "        query_obj[\"row_limit\"] = self.form_data.get(\"limit\")",
            "",
            "        query_obj[\"metrics\"] = [self.z_metric, self.x_metric, self.y_metric]",
            "        if len(set(self.metric_labels)) < 3:",
            "            raise QueryObjectValidationError(_(\"Please use 3 different metric labels\"))",
            "        if not all(query_obj[\"metrics\"] + [self.entity]):",
            "            raise QueryObjectValidationError(_(\"Pick a metric for x, y and size\"))",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df[\"x\"] = df[[utils.get_metric_name(self.x_metric)]]",
            "        df[\"y\"] = df[[utils.get_metric_name(self.y_metric)]]",
            "        df[\"size\"] = df[[utils.get_metric_name(self.z_metric)]]",
            "        df[\"shape\"] = \"circle\"",
            "        df[\"group\"] = df[[self.series]]",
            "",
            "        series: Dict[Any, List[Any]] = defaultdict(list)",
            "        for row in df.to_dict(orient=\"records\"):",
            "            series[row[\"group\"]].append(row)",
            "        chart_data = []",
            "        for k, v in series.items():",
            "            chart_data.append({\"key\": k, \"values\": v})",
            "        return chart_data",
            "",
            "",
            "class BulletViz(NVD3Viz):",
            "",
            "    \"\"\"Based on the NVD3 bullet chart\"\"\"",
            "",
            "    viz_type = \"bullet\"",
            "    verbose_name = _(\"Bullet Chart\")",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        form_data = self.form_data",
            "        query_obj = super().query_obj()",
            "        self.metric = form_data[  # pylint: disable=attribute-defined-outside-init",
            "            \"metric\"",
            "        ]",
            "",
            "        query_obj[\"metrics\"] = [self.metric]",
            "        if not self.metric:",
            "            raise QueryObjectValidationError(_(\"Pick a metric to display\"))",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        df[\"metric\"] = df[[utils.get_metric_name(self.metric)]]",
            "        values = df[\"metric\"].values",
            "        return {",
            "            \"measures\": values.tolist(),",
            "        }",
            "",
            "",
            "class BigNumberViz(BaseViz):",
            "",
            "    \"\"\"Put emphasis on a single metric with this big number viz\"\"\"",
            "",
            "    viz_type = \"big_number\"",
            "    verbose_name = _(\"Big Number with Trendline\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        metric = self.form_data.get(\"metric\")",
            "        if not metric:",
            "            raise QueryObjectValidationError(_(\"Pick a metric!\"))",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        self.form_data[\"metric\"] = metric",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df = df.pivot_table(",
            "            index=DTTM_ALIAS,",
            "            columns=[],",
            "            values=self.metric_labels,",
            "            dropna=False,",
            "            aggfunc=np.min,  # looking for any (only) value, preserving `None`",
            "        )",
            "        df = self.apply_rolling(df)",
            "        df[DTTM_ALIAS] = df.index",
            "        return super().get_data(df)",
            "",
            "",
            "class BigNumberTotalViz(BaseViz):",
            "",
            "    \"\"\"Put emphasis on a single metric with this big number viz\"\"\"",
            "",
            "    viz_type = \"big_number_total\"",
            "    verbose_name = _(\"Big Number\")",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        metric = self.form_data.get(\"metric\")",
            "        if not metric:",
            "            raise QueryObjectValidationError(_(\"Pick a metric!\"))",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        self.form_data[\"metric\"] = metric",
            "",
            "        # Limiting rows is not required as only one cell is returned",
            "        query_obj[\"row_limit\"] = None",
            "        return query_obj",
            "",
            "",
            "class NVD3TimeSeriesViz(NVD3Viz):",
            "",
            "    \"\"\"A rich line chart component with tons of options\"\"\"",
            "",
            "    viz_type = \"line\"",
            "    verbose_name = _(\"Time Series - Line Chart\")",
            "    sort_series = False",
            "    is_timeseries = True",
            "    pivot_fill_value: Optional[int] = None",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        sort_by = self.form_data.get(",
            "            \"timeseries_limit_metric\"",
            "        ) or utils.get_first_metric_name(query_obj.get(\"metrics\") or [])",
            "        is_asc = not self.form_data.get(\"order_desc\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            query_obj[\"orderby\"] = [(sort_by, is_asc)]",
            "        return query_obj",
            "",
            "    def to_series(  # pylint: disable=too-many-branches",
            "        self, df: pd.DataFrame, classed: str = \"\", title_suffix: str = \"\"",
            "    ) -> List[Dict[str, Any]]:",
            "        cols = []",
            "        for col in df.columns:",
            "            if col == \"\":",
            "                cols.append(\"N/A\")",
            "            elif col is None:",
            "                cols.append(\"NULL\")",
            "            else:",
            "                cols.append(col)",
            "        df.columns = cols",
            "        series = df.to_dict(\"series\")",
            "",
            "        chart_data = []",
            "        for name in df.T.index.tolist():",
            "            ys = series[name]",
            "            if df[name].dtype.kind not in \"biufc\":",
            "                continue",
            "            series_title: Union[List[str], str, Tuple[str, ...]]",
            "            if isinstance(name, list):",
            "                series_title = [str(title) for title in name]",
            "            elif isinstance(name, tuple):",
            "                series_title = tuple(str(title) for title in name)",
            "            else:",
            "                series_title = str(name)",
            "            if (",
            "                isinstance(series_title, (list, tuple))",
            "                and len(series_title) > 1",
            "                and len(self.metric_labels) == 1",
            "            ):",
            "                # Removing metric from series name if only one metric",
            "                series_title = series_title[1:]",
            "            if title_suffix:",
            "                if isinstance(series_title, str):",
            "                    series_title = (series_title, title_suffix)",
            "                elif isinstance(series_title, list):",
            "                    series_title = series_title + [title_suffix]",
            "                elif isinstance(series_title, tuple):",
            "                    series_title = series_title + (title_suffix,)",
            "",
            "            values = []",
            "            non_nan_cnt = 0",
            "            for ds in df.index:",
            "                if ds in ys:",
            "                    data = {\"x\": ds, \"y\": ys[ds]}",
            "                    if not np.isnan(ys[ds]):",
            "                        non_nan_cnt += 1",
            "                else:",
            "                    data = {}",
            "                values.append(data)",
            "",
            "            if non_nan_cnt == 0:",
            "                continue",
            "",
            "            data = {\"key\": series_title, \"values\": values}",
            "            if classed:",
            "                data[\"classed\"] = classed",
            "            chart_data.append(data)",
            "        return chart_data",
            "",
            "    def process_data(self, df: pd.DataFrame, aggregate: bool = False) -> VizData:",
            "        if self.form_data.get(\"granularity\") == \"all\":",
            "            raise QueryObjectValidationError(",
            "                _(\"Pick a time granularity for your time series\")",
            "            )",
            "",
            "        if df.empty:",
            "            return df",
            "",
            "        if aggregate:",
            "            df = df.pivot_table(",
            "                index=DTTM_ALIAS,",
            "                columns=self.form_data.get(\"groupby\"),",
            "                values=self.metric_labels,",
            "                fill_value=0,",
            "                aggfunc=sum,",
            "            )",
            "        else:",
            "            df = df.pivot_table(",
            "                index=DTTM_ALIAS,",
            "                columns=self.form_data.get(\"groupby\"),",
            "                values=self.metric_labels,",
            "                fill_value=self.pivot_fill_value,",
            "            )",
            "",
            "        rule = self.form_data.get(\"resample_rule\")",
            "        method = self.form_data.get(\"resample_method\")",
            "",
            "        if rule and method:",
            "            df = getattr(df.resample(rule), method)()",
            "",
            "        if self.sort_series:",
            "            dfs = df.sum()",
            "            dfs.sort_values(ascending=False, inplace=True)",
            "            df = df[dfs.index]",
            "",
            "        df = self.apply_rolling(df)",
            "        if self.form_data.get(\"contribution\"):",
            "            dft = df.T",
            "            df = (dft / dft.sum()).T",
            "",
            "        return df",
            "",
            "    def run_extra_queries(self) -> None:",
            "        time_compare = self.form_data.get(\"time_compare\") or []",
            "        # backwards compatibility",
            "        if not isinstance(time_compare, list):",
            "            time_compare = [time_compare]",
            "",
            "        for option in time_compare:",
            "            query_object = self.query_obj()",
            "            try:",
            "                delta = parse_past_timedelta(option)",
            "            except ValueError as ex:",
            "                raise QueryObjectValidationError(str(ex)) from ex",
            "            query_object[\"inner_from_dttm\"] = query_object[\"from_dttm\"]",
            "            query_object[\"inner_to_dttm\"] = query_object[\"to_dttm\"]",
            "",
            "            if not query_object[\"from_dttm\"] or not query_object[\"to_dttm\"]:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"An enclosed time range (both start and end) must be specified \"",
            "                        \"when using a Time Comparison.\"",
            "                    )",
            "                )",
            "            query_object[\"from_dttm\"] -= delta",
            "            query_object[\"to_dttm\"] -= delta",
            "",
            "            df2 = self.get_df_payload(query_object, time_compare=option).get(\"df\")",
            "            if df2 is not None and DTTM_ALIAS in df2:",
            "                dttm_series = df2[DTTM_ALIAS] + delta",
            "                df2 = df2.drop(DTTM_ALIAS, axis=1)",
            "                df2 = pd.concat([dttm_series, df2], axis=1)",
            "                label = \"{} offset\".format(option)",
            "                df2 = self.process_data(df2)",
            "                self._extra_chart_data.append((label, df2))",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        comparison_type = self.form_data.get(\"comparison_type\") or \"values\"",
            "        df = self.process_data(df)",
            "        if comparison_type == \"values\":",
            "            # Filter out series with all NaN",
            "            chart_data = self.to_series(df.dropna(axis=1, how=\"all\"))",
            "",
            "            for i, (label, df2) in enumerate(self._extra_chart_data):",
            "                chart_data.extend(",
            "                    self.to_series(",
            "                        df2, classed=\"time-shift-{}\".format(i), title_suffix=label",
            "                    )",
            "                )",
            "        else:",
            "            chart_data = []",
            "            for i, (label, df2) in enumerate(self._extra_chart_data):",
            "                # reindex df2 into the df2 index",
            "                combined_index = df.index.union(df2.index)",
            "                df2 = (",
            "                    df2.reindex(combined_index)",
            "                    .interpolate(method=\"time\")",
            "                    .reindex(df.index)",
            "                )",
            "",
            "                if comparison_type == \"absolute\":",
            "                    diff = df - df2",
            "                elif comparison_type == \"percentage\":",
            "                    diff = (df - df2) / df2",
            "                elif comparison_type == \"ratio\":",
            "                    diff = df / df2",
            "                else:",
            "                    raise QueryObjectValidationError(",
            "                        \"Invalid `comparison_type`: {0}\".format(comparison_type)",
            "                    )",
            "",
            "                # remove leading/trailing NaNs from the time shift difference",
            "                diff = diff[diff.first_valid_index() : diff.last_valid_index()]",
            "",
            "                chart_data.extend(",
            "                    self.to_series(",
            "                        diff, classed=\"time-shift-{}\".format(i), title_suffix=label",
            "                    )",
            "                )",
            "",
            "        if not self.sort_series:",
            "            chart_data = sorted(chart_data, key=lambda x: tuple(x[\"key\"]))",
            "        return chart_data",
            "",
            "",
            "class MultiLineViz(NVD3Viz):",
            "",
            "    \"\"\"Pile on multiple line charts\"\"\"",
            "",
            "    viz_type = \"line_multi\"",
            "    verbose_name = _(\"Time Series - Multiple Line Charts\")",
            "",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        return {}",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        # pylint: disable=import-outside-toplevel,too-many-locals",
            "        multiline_fd = self.form_data",
            "        # Late import to avoid circular import issues",
            "        from superset.charts.dao import ChartDAO",
            "",
            "        axis1_chart_ids = multiline_fd.get(\"line_charts\", [])",
            "        axis2_chart_ids = multiline_fd.get(\"line_charts_2\", [])",
            "        all_charts = {",
            "            chart.id: chart",
            "            for chart in ChartDAO.find_by_ids(axis1_chart_ids + axis2_chart_ids)",
            "        }",
            "        axis1_charts = [all_charts[chart_id] for chart_id in axis1_chart_ids]",
            "        axis2_charts = [all_charts[chart_id] for chart_id in axis2_chart_ids]",
            "",
            "        filters = multiline_fd.get(\"filters\", [])",
            "        add_prefix = multiline_fd.get(\"prefix_metric_with_slice_name\", False)",
            "        data = []",
            "        min_x, max_x = None, None",
            "",
            "        for chart, y_axis in [(chart, 1) for chart in axis1_charts] + [",
            "            (chart, 2) for chart in axis2_charts",
            "        ]:",
            "            prefix = f\"{chart.chart}: \" if add_prefix else \"\"",
            "            chart_fd = chart.form_data",
            "            chart_fd[\"filters\"] = chart_fd.get(\"filters\", []) + filters",
            "            if \"extra_filters\" in multiline_fd:",
            "                chart_fd[\"extra_filters\"] = multiline_fd[\"extra_filters\"]",
            "            if \"time_range\" in multiline_fd:",
            "                chart_fd[\"time_range\"] = multiline_fd[\"time_range\"]",
            "            viz_obj = viz_types[chart.viz_type](",
            "                chart.datasource,",
            "                form_data=chart_fd,",
            "                force=self.force,",
            "                force_cached=self.force_cached,",
            "            )",
            "            df = viz_obj.get_df_payload()[\"df\"]",
            "            chart_series = viz_obj.get_data(df) or []",
            "            for series in chart_series:",
            "                x_values = [value[\"x\"] for value in series[\"values\"]]",
            "                min_x = min(x_values + ([min_x] if min_x is not None else []))",
            "                max_x = max(x_values + ([max_x] if max_x is not None else []))",
            "                series_key = (",
            "                    series[\"key\"]",
            "                    if isinstance(series[\"key\"], (list, tuple))",
            "                    else [series[\"key\"]]",
            "                )",
            "                data.append(",
            "                    {",
            "                        \"key\": prefix + \", \".join(series_key),",
            "                        \"type\": \"line\",",
            "                        \"values\": series[\"values\"],",
            "                        \"yAxis\": y_axis,",
            "                    }",
            "                )",
            "        bounds = []",
            "        if min_x is not None:",
            "            bounds.append({\"x\": min_x, \"y\": None})",
            "        if max_x is not None:",
            "            bounds.append({\"x\": max_x, \"y\": None})",
            "",
            "        for series in data:",
            "            series[\"values\"].extend(bounds)",
            "        return data",
            "",
            "",
            "class NVD3DualLineViz(NVD3Viz):",
            "",
            "    \"\"\"A rich line chart with dual axis\"\"\"",
            "",
            "    viz_type = \"dual_line\"",
            "    verbose_name = _(\"Time Series - Dual Axis Line Chart\")",
            "    sort_series = False",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        m1 = self.form_data.get(\"metric\")",
            "        m2 = self.form_data.get(\"metric_2\")",
            "        if not m1:",
            "            raise QueryObjectValidationError(_(\"Pick a metric for left axis!\"))",
            "        if not m2:",
            "            raise QueryObjectValidationError(_(\"Pick a metric for right axis!\"))",
            "        if m1 == m2:",
            "            raise QueryObjectValidationError(",
            "                _(\"Please choose different metrics\" \" on left and right axis\")",
            "            )",
            "        query_obj[\"metrics\"] = [m1, m2]",
            "        return query_obj",
            "",
            "    def to_series(self, df: pd.DataFrame, classed: str = \"\") -> List[Dict[str, Any]]:",
            "        cols = []",
            "        for col in df.columns:",
            "            if col == \"\":",
            "                cols.append(\"N/A\")",
            "            elif col is None:",
            "                cols.append(\"NULL\")",
            "            else:",
            "                cols.append(col)",
            "        df.columns = cols",
            "        series = df.to_dict(\"series\")",
            "        chart_data = []",
            "        metrics = [self.form_data[\"metric\"], self.form_data[\"metric_2\"]]",
            "        for i, metric in enumerate(metrics):",
            "            metric_name = utils.get_metric_name(metric)",
            "            ys = series[metric_name]",
            "            if df[metric_name].dtype.kind not in \"biufc\":",
            "                continue",
            "            series_title = metric_name",
            "            chart_data.append(",
            "                {",
            "                    \"key\": series_title,",
            "                    \"classed\": classed,",
            "                    \"values\": [",
            "                        {\"x\": ds, \"y\": ys[ds] if ds in ys else None} for ds in df.index",
            "                    ],",
            "                    \"yAxis\": i + 1,",
            "                    \"type\": \"line\",",
            "                }",
            "            )",
            "        return chart_data",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        if self.form_data.get(\"granularity\") == \"all\":",
            "            raise QueryObjectValidationError(",
            "                _(\"Pick a time granularity for your time series\")",
            "            )",
            "",
            "        metric = utils.get_metric_name(self.form_data[\"metric\"])",
            "        metric_2 = utils.get_metric_name(self.form_data[\"metric_2\"])",
            "        df = df.pivot_table(index=DTTM_ALIAS, values=[metric, metric_2])",
            "",
            "        chart_data = self.to_series(df)",
            "        return chart_data",
            "",
            "",
            "class NVD3TimeSeriesBarViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"A bar chart where the x axis is time\"\"\"",
            "",
            "    viz_type = \"bar\"",
            "    sort_series = True",
            "    verbose_name = _(\"Time Series - Bar Chart\")",
            "",
            "",
            "class NVD3TimePivotViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"Time Series - Periodicity Pivot\"\"\"",
            "",
            "    viz_type = \"time_pivot\"",
            "    sort_series = True",
            "    verbose_name = _(\"Time Series - Period Pivot\")",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df = self.process_data(df)",
            "        freq = to_offset(self.form_data.get(\"freq\"))",
            "        try:",
            "            freq = type(freq)(freq.n, normalize=True, **freq.kwds)",
            "        except ValueError:",
            "            freq = type(freq)(freq.n, **freq.kwds)",
            "        df.index.name = None",
            "        df[DTTM_ALIAS] = df.index.map(freq.rollback)",
            "        df[\"ranked\"] = df[DTTM_ALIAS].rank(method=\"dense\", ascending=False) - 1",
            "        df.ranked = df.ranked.map(int)",
            "        df[\"series\"] = \"-\" + df.ranked.map(str)",
            "        df[\"series\"] = df[\"series\"].str.replace(\"-0\", \"current\")",
            "        rank_lookup = {",
            "            row[\"series\"]: row[\"ranked\"] for row in df.to_dict(orient=\"records\")",
            "        }",
            "        max_ts = df[DTTM_ALIAS].max()",
            "        max_rank = df[\"ranked\"].max()",
            "        df[DTTM_ALIAS] = df.index + (max_ts - df[DTTM_ALIAS])",
            "        df = df.pivot_table(",
            "            index=DTTM_ALIAS,",
            "            columns=\"series\",",
            "            values=utils.get_metric_name(self.form_data[\"metric\"]),",
            "        )",
            "        chart_data = self.to_series(df)",
            "        for serie in chart_data:",
            "            serie[\"rank\"] = rank_lookup[serie[\"key\"]]",
            "            serie[\"perc\"] = 1 - (serie[\"rank\"] / (max_rank + 1))",
            "        return chart_data",
            "",
            "",
            "class NVD3CompareTimeSeriesViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"A line chart component where you can compare the % change over time\"\"\"",
            "",
            "    viz_type = \"compare\"",
            "    verbose_name = _(\"Time Series - Percent Change\")",
            "",
            "",
            "class NVD3TimeSeriesStackedViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"A rich stack area chart\"\"\"",
            "",
            "    viz_type = \"area\"",
            "    verbose_name = _(\"Time Series - Stacked\")",
            "    sort_series = True",
            "    pivot_fill_value = 0",
            "",
            "",
            "class HistogramViz(BaseViz):",
            "",
            "    \"\"\"Histogram\"\"\"",
            "",
            "    viz_type = \"histogram\"",
            "    verbose_name = _(\"Histogram\")",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        \"\"\"Returns the query object for this visualization\"\"\"",
            "        query_obj = super().query_obj()",
            "        numeric_columns = self.form_data.get(\"all_columns_x\")",
            "        if numeric_columns is None:",
            "            raise QueryObjectValidationError(",
            "                _(\"Must have at least one numeric column specified\")",
            "            )",
            "        self.columns = (  #  pylint: disable=attribute-defined-outside-init",
            "            numeric_columns",
            "        )",
            "        query_obj[\"columns\"] = numeric_columns + self.groupby",
            "        # override groupby entry to avoid aggregation",
            "        query_obj[\"groupby\"] = None",
            "        query_obj[\"metrics\"] = None",
            "        return query_obj",
            "",
            "    def labelify(self, keys: Union[List[str], str], column: str) -> str:",
            "        if isinstance(keys, str):",
            "            keys = [keys]",
            "        # removing undesirable characters",
            "        labels = [re.sub(r\"\\W+\", r\"_\", k) for k in keys]",
            "        if len(self.columns) > 1 or not self.groupby:",
            "            # Only show numeric column in label if there are many",
            "            labels = [column] + labels",
            "        return \"__\".join(labels)",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        \"\"\"Returns the chart data\"\"\"",
            "        if df.empty:",
            "            return None",
            "",
            "        chart_data = []",
            "        if len(self.groupby) > 0:",
            "            groups = df.groupby(self.groupby)",
            "        else:",
            "            groups = [((), df)]",
            "        for keys, data in groups:",
            "            chart_data.extend(",
            "                [",
            "                    {",
            "                        \"key\": self.labelify(keys, column),",
            "                        \"values\": data[column].tolist(),",
            "                    }",
            "                    for column in self.columns",
            "                ]",
            "            )",
            "        return chart_data",
            "",
            "",
            "class DistributionBarViz(BaseViz):",
            "",
            "    \"\"\"A good old bar chart\"\"\"",
            "",
            "    viz_type = \"dist_bar\"",
            "    verbose_name = _(\"Distribution - Bar Chart\")",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        if len(query_obj[\"groupby\"]) < len(self.form_data.get(\"groupby\") or []) + len(",
            "            self.form_data.get(\"columns\") or []",
            "        ):",
            "            raise QueryObjectValidationError(",
            "                _(\"Can't have overlap between Series and Breakdowns\")",
            "            )",
            "        if not self.form_data.get(\"metrics\"):",
            "            raise QueryObjectValidationError(_(\"Pick at least one metric\"))",
            "        if not self.form_data.get(\"groupby\"):",
            "            raise QueryObjectValidationError(_(\"Pick at least one field for [Series]\"))",
            "",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            query_obj[\"orderby\"] = [",
            "                (sort_by, not self.form_data.get(\"order_desc\", True))",
            "            ]",
            "        elif query_obj[\"metrics\"]:",
            "            # Legacy behavior of sorting by first metric by default",
            "            first_metric = query_obj[\"metrics\"][0]",
            "            query_obj[\"orderby\"] = [",
            "                (first_metric, not self.form_data.get(\"order_desc\", True))",
            "            ]",
            "",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:  # pylint: disable=too-many-locals",
            "        if df.empty:",
            "            return None",
            "",
            "        metrics = self.metric_labels",
            "        columns = self.form_data.get(\"columns\") or []",
            "",
            "        # pandas will throw away nulls when grouping/pivoting,",
            "        # so we substitute NULL_STRING for any nulls in the necessary columns",
            "        filled_cols = self.groupby + columns",
            "        df = df.copy()",
            "        df[filled_cols] = df[filled_cols].fillna(value=NULL_STRING)",
            "",
            "        sortby = utils.get_metric_name(",
            "            self.form_data.get(\"timeseries_limit_metric\") or metrics[0]",
            "        )",
            "        row = df.groupby(self.groupby).sum()[sortby].copy()",
            "        is_asc = not self.form_data.get(\"order_desc\")",
            "        row.sort_values(ascending=is_asc, inplace=True)",
            "        pt = df.pivot_table(index=self.groupby, columns=columns, values=metrics)",
            "        if self.form_data.get(\"contribution\"):",
            "            pt = pt.T",
            "            pt = (pt / pt.sum()).T",
            "        pt = pt.reindex(row.index)",
            "",
            "        # Re-order the columns adhering to the metric ordering.",
            "        pt = pt[metrics]",
            "        chart_data = []",
            "        for name, ys in pt.items():",
            "            if pt[name].dtype.kind not in \"biufc\" or name in self.groupby:",
            "                continue",
            "            if isinstance(name, str):",
            "                series_title = name",
            "            else:",
            "                offset = 0 if len(metrics) > 1 else 1",
            "                series_title = \", \".join([str(s) for s in name[offset:]])",
            "            values = []",
            "            for i, v in ys.items():",
            "                x = i",
            "                if isinstance(x, (tuple, list)):",
            "                    x = \", \".join([str(s) for s in x])",
            "                else:",
            "                    x = str(x)",
            "                values.append({\"x\": x, \"y\": v})",
            "            chart_data.append({\"key\": series_title, \"values\": values})",
            "        return chart_data",
            "",
            "",
            "class SunburstViz(BaseViz):",
            "",
            "    \"\"\"A multi level sunburst chart\"\"\"",
            "",
            "    viz_type = \"sunburst\"",
            "    verbose_name = _(\"Sunburst\")",
            "    is_timeseries = False",
            "    credits = (",
            "        \"Kerry Rodden \"",
            "        '@<a href=\"https://bl.ocks.org/kerryrodden/7090426\">bl.ocks.org</a>'",
            "    )",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        form_data = copy.deepcopy(self.form_data)",
            "        cols = form_data.get(\"groupby\") or []",
            "        cols.extend([\"m1\", \"m2\"])",
            "        metric = utils.get_metric_name(form_data[\"metric\"])",
            "        secondary_metric = (",
            "            utils.get_metric_name(form_data[\"secondary_metric\"])",
            "            if \"secondary_metric\" in form_data",
            "            else None",
            "        )",
            "        if metric == secondary_metric or secondary_metric is None:",
            "            df.rename(columns={df.columns[-1]: \"m1\"}, inplace=True)",
            "            df[\"m2\"] = df[\"m1\"]",
            "        else:",
            "            df.rename(columns={df.columns[-2]: \"m1\"}, inplace=True)",
            "            df.rename(columns={df.columns[-1]: \"m2\"}, inplace=True)",
            "",
            "        # Re-order the columns as the query result set column ordering may differ from",
            "        # that listed in the hierarchy.",
            "        df = df[cols]",
            "        return df.to_numpy().tolist()",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"metrics\"] = [self.form_data[\"metric\"]]",
            "        secondary_metric = self.form_data.get(\"secondary_metric\")",
            "        if secondary_metric and secondary_metric != self.form_data[\"metric\"]:",
            "            query_obj[\"metrics\"].append(secondary_metric)",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "        return query_obj",
            "",
            "",
            "class SankeyViz(BaseViz):",
            "",
            "    \"\"\"A Sankey diagram that requires a parent-child dataset\"\"\"",
            "",
            "    viz_type = \"sankey\"",
            "    verbose_name = _(\"Sankey\")",
            "    is_timeseries = False",
            "    credits = '<a href=\"https://www.npmjs.com/package/d3-sankey\">d3-sankey on npm</a>'",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        if len(query_obj[\"groupby\"]) != 2:",
            "            raise QueryObjectValidationError(",
            "                _(\"Pick exactly 2 columns as [Source / Target]\")",
            "            )",
            "        query_obj[\"metrics\"] = [self.form_data[\"metric\"]]",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        source, target = self.groupby",
            "        (value,) = self.metric_labels",
            "        df.rename(",
            "            columns={source: \"source\", target: \"target\", value: \"value\",}, inplace=True,",
            "        )",
            "        df[\"source\"] = df[\"source\"].astype(str)",
            "        df[\"target\"] = df[\"target\"].astype(str)",
            "        recs = df.to_dict(orient=\"records\")",
            "",
            "        hierarchy: Dict[str, Set[str]] = defaultdict(set)",
            "        for row in recs:",
            "            hierarchy[row[\"source\"]].add(row[\"target\"])",
            "",
            "        def find_cycle(graph: Dict[str, Set[str]]) -> Optional[Tuple[str, str]]:",
            "            \"\"\"Whether there's a cycle in a directed graph\"\"\"",
            "            path = set()",
            "",
            "            def visit(vertex: str) -> Optional[Tuple[str, str]]:",
            "                path.add(vertex)",
            "                for neighbour in graph.get(vertex, ()):",
            "                    if neighbour in path or visit(neighbour):",
            "                        return (vertex, neighbour)",
            "                path.remove(vertex)",
            "                return None",
            "",
            "            for vertex in graph:",
            "                cycle = visit(vertex)",
            "                if cycle:",
            "                    return cycle",
            "            return None",
            "",
            "        cycle = find_cycle(hierarchy)",
            "        if cycle:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"There's a loop in your Sankey, please provide a tree. \"",
            "                    \"Here's a faulty link: {}\"",
            "                ).format(cycle)",
            "            )",
            "        return recs",
            "",
            "",
            "class ChordViz(BaseViz):",
            "",
            "    \"\"\"A Chord diagram\"\"\"",
            "",
            "    viz_type = \"chord\"",
            "    verbose_name = _(\"Directed Force Layout\")",
            "    credits = '<a href=\"https://github.com/d3/d3-chord\">Bostock</a>'",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"groupby\"] = [",
            "            self.form_data.get(\"groupby\"),",
            "            self.form_data.get(\"columns\"),",
            "        ]",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        df.columns = [\"source\", \"target\", \"value\"]",
            "",
            "        # Preparing a symetrical matrix like d3.chords calls for",
            "        nodes = list(set(df[\"source\"]) | set(df[\"target\"]))",
            "        matrix = {}",
            "        for source, target in product(nodes, nodes):",
            "            matrix[(source, target)] = 0",
            "        for source, target, value in df.to_records(index=False):",
            "            matrix[(source, target)] = value",
            "        return {",
            "            \"nodes\": list(nodes),",
            "            \"matrix\": [[matrix[(n1, n2)] for n1 in nodes] for n2 in nodes],",
            "        }",
            "",
            "",
            "class CountryMapViz(BaseViz):",
            "",
            "    \"\"\"A country centric\"\"\"",
            "",
            "    viz_type = \"country_map\"",
            "    verbose_name = _(\"Country Map\")",
            "    is_timeseries = False",
            "    credits = \"From bl.ocks.org By john-guerra\"",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        metric = self.form_data.get(\"metric\")",
            "        entity = self.form_data.get(\"entity\")",
            "        if not self.form_data.get(\"select_country\"):",
            "            raise QueryObjectValidationError(\"Must specify a country\")",
            "        if not metric:",
            "            raise QueryObjectValidationError(\"Must specify a metric\")",
            "        if not entity:",
            "            raise QueryObjectValidationError(\"Must provide ISO codes\")",
            "        query_obj[\"metrics\"] = [metric]",
            "        query_obj[\"groupby\"] = [entity]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        cols = [self.form_data.get(\"entity\")]",
            "        metric = self.metric_labels[0]",
            "        cols += [metric]",
            "        ndf = df[cols]",
            "        df = ndf",
            "        df.columns = [\"country_id\", \"metric\"]",
            "        return df.to_dict(orient=\"records\")",
            "",
            "",
            "class WorldMapViz(BaseViz):",
            "",
            "    \"\"\"A country centric world map\"\"\"",
            "",
            "    viz_type = \"world_map\"",
            "    verbose_name = _(\"World Map\")",
            "    is_timeseries = False",
            "    credits = 'datamaps on <a href=\"https://www.npmjs.com/package/datamaps\">npm</a>'",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"groupby\"] = [self.form_data[\"entity\"]]",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset.examples import countries",
            "",
            "        cols = [self.form_data.get(\"entity\")]",
            "        metric = utils.get_metric_name(self.form_data[\"metric\"])",
            "        secondary_metric = (",
            "            utils.get_metric_name(self.form_data[\"secondary_metric\"])",
            "            if \"secondary_metric\" in self.form_data",
            "            else None",
            "        )",
            "        columns = [\"country\", \"m1\", \"m2\"]",
            "        if metric == secondary_metric:",
            "            ndf = df[cols]",
            "            ndf[\"m1\"] = df[metric]",
            "            ndf[\"m2\"] = ndf[\"m1\"]",
            "        else:",
            "            if secondary_metric:",
            "                cols += [metric, secondary_metric]",
            "            else:",
            "                cols += [metric]",
            "                columns = [\"country\", \"m1\"]",
            "            ndf = df[cols]",
            "        df = ndf",
            "        df.columns = columns",
            "        data = df.to_dict(orient=\"records\")",
            "        for row in data:",
            "            country = None",
            "            if isinstance(row[\"country\"], str):",
            "                if \"country_fieldtype\" in self.form_data:",
            "                    country = countries.get(",
            "                        self.form_data[\"country_fieldtype\"], row[\"country\"]",
            "                    )",
            "            if country:",
            "                row[\"country\"] = country[\"cca3\"]",
            "                row[\"latitude\"] = country[\"lat\"]",
            "                row[\"longitude\"] = country[\"lng\"]",
            "                row[\"name\"] = country[\"name\"]",
            "            else:",
            "                row[\"country\"] = \"XXX\"",
            "        return data",
            "",
            "",
            "class FilterBoxViz(BaseViz):",
            "",
            "    \"\"\"A multi filter, multi-choice filter box to make dashboards interactive\"\"\"",
            "",
            "    viz_type = \"filter_box\"",
            "    verbose_name = _(\"Filters\")",
            "    is_timeseries = False",
            "    credits = 'a <a href=\"https://github.com/airbnb/superset\">Superset</a> original'",
            "    cache_type = \"get_data\"",
            "    filter_row_limit = 1000",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        return {}",
            "",
            "    def run_extra_queries(self) -> None:",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset.common.query_context import QueryContext",
            "",
            "        query_obj = super().query_obj()",
            "        filters = self.form_data.get(\"filter_configs\") or []",
            "        query_obj[\"row_limit\"] = self.filter_row_limit",
            "        self.dataframes = {}  # pylint: disable=attribute-defined-outside-init",
            "        for flt in filters:",
            "            col = flt.get(\"column\")",
            "            if not col:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Invalid filter configuration, please select a column\")",
            "                )",
            "            query_obj[\"groupby\"] = [col]",
            "            metric = flt.get(\"metric\")",
            "            query_obj[\"metrics\"] = [metric] if metric else []",
            "            asc = flt.get(\"asc\")",
            "            if metric and asc is not None:",
            "                query_obj[\"orderby\"] = [(metric, asc)]",
            "            QueryContext(",
            "                datasource={\"id\": self.datasource.id, \"type\": self.datasource.type},",
            "                queries=[query_obj],",
            "            ).raise_for_access()",
            "            df = self.get_df_payload(query_obj=query_obj).get(\"df\")",
            "            self.dataframes[col] = df",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        filters = self.form_data.get(\"filter_configs\") or []",
            "        data = {}",
            "        for flt in filters:",
            "            col = flt.get(\"column\")",
            "            metric = flt.get(\"metric\")",
            "            df = self.dataframes.get(col)",
            "            if df is not None and not df.empty:",
            "                if metric:",
            "                    df = df.sort_values(",
            "                        utils.get_metric_name(metric), ascending=flt.get(\"asc\")",
            "                    )",
            "                    data[col] = [",
            "                        {\"id\": row[0], \"text\": row[0], \"metric\": row[1]}",
            "                        for row in df.itertuples(index=False)",
            "                    ]",
            "                else:",
            "                    df = df.sort_values(col, ascending=flt.get(\"asc\"))",
            "                    data[col] = [",
            "                        {\"id\": row[0], \"text\": row[0]}",
            "                        for row in df.itertuples(index=False)",
            "                    ]",
            "            else:",
            "                data[col] = []",
            "        return data",
            "",
            "",
            "class ParallelCoordinatesViz(BaseViz):",
            "",
            "    \"\"\"Interactive parallel coordinate implementation",
            "",
            "    Uses this amazing javascript library",
            "    https://github.com/syntagmatic/parallel-coordinates",
            "    \"\"\"",
            "",
            "    viz_type = \"para\"",
            "    verbose_name = _(\"Parallel Coordinates\")",
            "    credits = (",
            "        '<a href=\"https://syntagmatic.github.io/parallel-coordinates/\">'",
            "        \"Syntagmatic's library</a>\"",
            "    )",
            "    is_timeseries = False",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"groupby\"] = [self.form_data.get(\"series\")]",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            if self.form_data.get(\"order_desc\"):",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        return df.to_dict(orient=\"records\")",
            "",
            "",
            "class HeatmapViz(BaseViz):",
            "",
            "    \"\"\"A nice heatmap visualization that support high density through canvas\"\"\"",
            "",
            "    viz_type = \"heatmap\"",
            "    verbose_name = _(\"Heatmap\")",
            "    is_timeseries = False",
            "    credits = (",
            "        'inspired from mbostock @<a href=\"http://bl.ocks.org/mbostock/3074470\">'",
            "        \"bl.ocks.org</a>\"",
            "    )",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"metrics\"] = [self.form_data.get(\"metric\")]",
            "        query_obj[\"groupby\"] = [",
            "            self.form_data.get(\"all_columns_x\"),",
            "            self.form_data.get(\"all_columns_y\"),",
            "        ]",
            "",
            "        if self.form_data.get(\"sort_by_metric\", False):",
            "            query_obj[\"orderby\"] = [(query_obj[\"metrics\"][0], False)]",
            "",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        x = self.form_data.get(\"all_columns_x\")",
            "        y = self.form_data.get(\"all_columns_y\")",
            "        v = self.metric_labels[0]",
            "        if x == y:",
            "            df.columns = [\"x\", \"y\", \"v\"]",
            "        else:",
            "            df = df[[x, y, v]]",
            "            df.columns = [\"x\", \"y\", \"v\"]",
            "        norm = self.form_data.get(\"normalize_across\")",
            "        overall = False",
            "        max_ = df.v.max()",
            "        min_ = df.v.min()",
            "        if norm == \"heatmap\":",
            "            overall = True",
            "        else:",
            "            gb = df.groupby(norm, group_keys=False)",
            "            if len(gb) <= 1:",
            "                overall = True",
            "            else:",
            "                df[\"perc\"] = gb.apply(",
            "                    lambda x: (x.v - x.v.min()) / (x.v.max() - x.v.min())",
            "                )",
            "                df[\"rank\"] = gb.apply(lambda x: x.v.rank(pct=True))",
            "        if overall:",
            "            df[\"perc\"] = (df.v - min_) / (max_ - min_)",
            "            df[\"rank\"] = df.v.rank(pct=True)",
            "        return {\"records\": df.to_dict(orient=\"records\"), \"extents\": [min_, max_]}",
            "",
            "",
            "class HorizonViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"Horizon chart",
            "",
            "    https://www.npmjs.com/package/d3-horizon-chart",
            "    \"\"\"",
            "",
            "    viz_type = \"horizon\"",
            "    verbose_name = _(\"Horizon Charts\")",
            "    credits = (",
            "        '<a href=\"https://www.npmjs.com/package/d3-horizon-chart\">'",
            "        \"d3-horizon-chart</a>\"",
            "    )",
            "",
            "",
            "class MapboxViz(BaseViz):",
            "",
            "    \"\"\"Rich maps made with Mapbox\"\"\"",
            "",
            "    viz_type = \"mapbox\"",
            "    verbose_name = _(\"Mapbox\")",
            "    is_timeseries = False",
            "    credits = \"<a href=https://www.mapbox.com/mapbox-gl-js/api/>Mapbox GL JS</a>\"",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        label_col = self.form_data.get(\"mapbox_label\")",
            "",
            "        if not self.form_data.get(\"groupby\"):",
            "            if (",
            "                self.form_data.get(\"all_columns_x\") is None",
            "                or self.form_data.get(\"all_columns_y\") is None",
            "            ):",
            "                raise QueryObjectValidationError(",
            "                    _(\"[Longitude] and [Latitude] must be set\")",
            "                )",
            "            query_obj[\"columns\"] = [",
            "                self.form_data.get(\"all_columns_x\"),",
            "                self.form_data.get(\"all_columns_y\"),",
            "            ]",
            "",
            "            if label_col and len(label_col) >= 1:",
            "                if label_col[0] == \"count\":",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Must have a [Group By] column to have 'count' as the \"",
            "                            + \"[Label]\"",
            "                        )",
            "                    )",
            "                query_obj[\"columns\"].append(label_col[0])",
            "",
            "            if self.form_data.get(\"point_radius\") != \"Auto\":",
            "                query_obj[\"columns\"].append(self.form_data.get(\"point_radius\"))",
            "",
            "            # Ensure this value is sorted so that it does not",
            "            # cause the cache key generation (which hashes the",
            "            # query object) to generate different keys for values",
            "            # that should be considered the same.",
            "            query_obj[\"columns\"] = sorted(set(query_obj[\"columns\"]))",
            "        else:",
            "            # Ensuring columns chosen are all in group by",
            "            if (",
            "                label_col",
            "                and len(label_col) >= 1",
            "                and label_col[0] != \"count\"",
            "                and label_col[0] not in self.form_data[\"groupby\"]",
            "            ):",
            "                raise QueryObjectValidationError(",
            "                    _(\"Choice of [Label] must be present in [Group By]\")",
            "                )",
            "",
            "            if (",
            "                self.form_data.get(\"point_radius\") != \"Auto\"",
            "                and self.form_data.get(\"point_radius\") not in self.form_data[\"groupby\"]",
            "            ):",
            "                raise QueryObjectValidationError(",
            "                    _(\"Choice of [Point Radius] must be present in [Group By]\")",
            "                )",
            "",
            "            if (",
            "                self.form_data.get(\"all_columns_x\") not in self.form_data[\"groupby\"]",
            "                or self.form_data.get(\"all_columns_y\") not in self.form_data[\"groupby\"]",
            "            ):",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"[Longitude] and [Latitude] columns must be present in \"",
            "                        + \"[Group By]\"",
            "                    )",
            "                )",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        label_col = self.form_data.get(\"mapbox_label\")",
            "        has_custom_metric = label_col is not None and len(label_col) > 0",
            "        metric_col = [None] * len(df.index)",
            "        if has_custom_metric:",
            "            if label_col[0] == self.form_data.get(\"all_columns_x\"):  # type: ignore",
            "                metric_col = df[self.form_data.get(\"all_columns_x\")]",
            "            elif label_col[0] == self.form_data.get(\"all_columns_y\"):  # type: ignore",
            "                metric_col = df[self.form_data.get(\"all_columns_y\")]",
            "            else:",
            "                metric_col = df[label_col[0]]  # type: ignore",
            "        point_radius_col = (",
            "            [None] * len(df.index)",
            "            if self.form_data.get(\"point_radius\") == \"Auto\"",
            "            else df[self.form_data.get(\"point_radius\")]",
            "        )",
            "",
            "        # limiting geo precision as long decimal values trigger issues",
            "        # around json-bignumber in Mapbox",
            "        geo_precision = 10",
            "        # using geoJSON formatting",
            "        geo_json = {",
            "            \"type\": \"FeatureCollection\",",
            "            \"features\": [",
            "                {",
            "                    \"type\": \"Feature\",",
            "                    \"properties\": {\"metric\": metric, \"radius\": point_radius},",
            "                    \"geometry\": {",
            "                        \"type\": \"Point\",",
            "                        \"coordinates\": [",
            "                            round(lon, geo_precision),",
            "                            round(lat, geo_precision),",
            "                        ],",
            "                    },",
            "                }",
            "                for lon, lat, metric, point_radius in zip(",
            "                    df[self.form_data.get(\"all_columns_x\")],",
            "                    df[self.form_data.get(\"all_columns_y\")],",
            "                    metric_col,",
            "                    point_radius_col,",
            "                )",
            "            ],",
            "        }",
            "",
            "        x_series, y_series = (",
            "            df[self.form_data.get(\"all_columns_x\")],",
            "            df[self.form_data.get(\"all_columns_y\")],",
            "        )",
            "        south_west = [x_series.min(), y_series.min()]",
            "        north_east = [x_series.max(), y_series.max()]",
            "",
            "        return {",
            "            \"geoJSON\": geo_json,",
            "            \"hasCustomMetric\": has_custom_metric,",
            "            \"mapboxApiKey\": config[\"MAPBOX_API_KEY\"],",
            "            \"mapStyle\": self.form_data.get(\"mapbox_style\"),",
            "            \"aggregatorName\": self.form_data.get(\"pandas_aggfunc\"),",
            "            \"clusteringRadius\": self.form_data.get(\"clustering_radius\"),",
            "            \"pointRadiusUnit\": self.form_data.get(\"point_radius_unit\"),",
            "            \"globalOpacity\": self.form_data.get(\"global_opacity\"),",
            "            \"bounds\": [south_west, north_east],",
            "            \"renderWhileDragging\": self.form_data.get(\"render_while_dragging\"),",
            "            \"tooltip\": self.form_data.get(\"rich_tooltip\"),",
            "            \"color\": self.form_data.get(\"mapbox_color\"),",
            "        }",
            "",
            "",
            "class DeckGLMultiLayer(BaseViz):",
            "",
            "    \"\"\"Pile on multiple DeckGL layers\"\"\"",
            "",
            "    viz_type = \"deck_multi\"",
            "    verbose_name = _(\"Deck.gl - Multiple Layers\")",
            "",
            "    is_timeseries = False",
            "    credits = '<a href=\"https://uber.github.io/deck.gl/\">deck.gl</a>'",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        return {}",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        # Late imports to avoid circular import issues",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset import db",
            "        from superset.models.slice import Slice",
            "",
            "        slice_ids = self.form_data.get(\"deck_slices\")",
            "        slices = db.session.query(Slice).filter(Slice.id.in_(slice_ids)).all()",
            "        return {",
            "            \"mapboxApiKey\": config[\"MAPBOX_API_KEY\"],",
            "            \"slices\": [slc.data for slc in slices],",
            "        }",
            "",
            "",
            "class BaseDeckGLViz(BaseViz):",
            "",
            "    \"\"\"Base class for deck.gl visualizations\"\"\"",
            "",
            "    is_timeseries = False",
            "    credits = '<a href=\"https://uber.github.io/deck.gl/\">deck.gl</a>'",
            "    spatial_control_keys: List[str] = []",
            "",
            "    def get_metrics(self) -> List[str]:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.metric = self.form_data.get(\"size\")",
            "        return [self.metric] if self.metric else []",
            "",
            "    def process_spatial_query_obj(self, key: str, group_by: List[str]) -> None:",
            "        group_by.extend(self.get_spatial_columns(key))",
            "",
            "    def get_spatial_columns(self, key: str) -> List[str]:",
            "        spatial = self.form_data.get(key)",
            "        if spatial is None:",
            "            raise ValueError(_(\"Bad spatial key\"))",
            "",
            "        if spatial.get(\"type\") == \"latlong\":",
            "            return [spatial.get(\"lonCol\"), spatial.get(\"latCol\")]",
            "",
            "        if spatial.get(\"type\") == \"delimited\":",
            "            return [spatial.get(\"lonlatCol\")]",
            "",
            "        if spatial.get(\"type\") == \"geohash\":",
            "            return [spatial.get(\"geohashCol\")]",
            "        return []",
            "",
            "    @staticmethod",
            "    def parse_coordinates(latlog: Any) -> Optional[Tuple[float, float]]:",
            "        if not latlog:",
            "            return None",
            "        try:",
            "            point = Point(latlog)",
            "            return (point.latitude, point.longitude)",
            "        except Exception as ex:",
            "            raise SpatialException(",
            "                _(\"Invalid spatial point encountered: %s\" % latlog)",
            "            ) from ex",
            "",
            "    @staticmethod",
            "    def reverse_geohash_decode(geohash_code: str) -> Tuple[str, str]:",
            "        lat, lng = geohash.decode(geohash_code)",
            "        return (lng, lat)",
            "",
            "    @staticmethod",
            "    def reverse_latlong(df: pd.DataFrame, key: str) -> None:",
            "        df[key] = [tuple(reversed(o)) for o in df[key] if isinstance(o, (list, tuple))]",
            "",
            "    def process_spatial_data_obj(self, key: str, df: pd.DataFrame) -> pd.DataFrame:",
            "        spatial = self.form_data.get(key)",
            "        if spatial is None:",
            "            raise ValueError(_(\"Bad spatial key\"))",
            "",
            "        if spatial.get(\"type\") == \"latlong\":",
            "            df[key] = list(",
            "                zip(",
            "                    pd.to_numeric(df[spatial.get(\"lonCol\")], errors=\"coerce\"),",
            "                    pd.to_numeric(df[spatial.get(\"latCol\")], errors=\"coerce\"),",
            "                )",
            "            )",
            "        elif spatial.get(\"type\") == \"delimited\":",
            "            lon_lat_col = spatial.get(\"lonlatCol\")",
            "            df[key] = df[lon_lat_col].apply(self.parse_coordinates)",
            "            del df[lon_lat_col]",
            "        elif spatial.get(\"type\") == \"geohash\":",
            "            df[key] = df[spatial.get(\"geohashCol\")].map(self.reverse_geohash_decode)",
            "            del df[spatial.get(\"geohashCol\")]",
            "",
            "        if spatial.get(\"reverseCheckbox\"):",
            "            self.reverse_latlong(df, key)",
            "",
            "        if df.get(key) is None:",
            "            raise NullValueException(",
            "                _(",
            "                    \"Encountered invalid NULL spatial entry, \\",
            "                                       please consider filtering those out\"",
            "                )",
            "            )",
            "        return df",
            "",
            "    def add_null_filters(self) -> None:",
            "        spatial_columns = set()",
            "        for key in self.spatial_control_keys:",
            "            for column in self.get_spatial_columns(key):",
            "                spatial_columns.add(column)",
            "",
            "        if self.form_data.get(\"adhoc_filters\") is None:",
            "            self.form_data[\"adhoc_filters\"] = []",
            "",
            "        line_column = self.form_data.get(\"line_column\")",
            "        if line_column:",
            "            spatial_columns.add(line_column)",
            "",
            "        for column in sorted(spatial_columns):",
            "            filter_ = simple_filter_to_adhoc(",
            "                {\"col\": column, \"op\": \"IS NOT NULL\", \"val\": \"\"}",
            "            )",
            "            self.form_data[\"adhoc_filters\"].append(filter_)",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        # add NULL filters",
            "        if self.form_data.get(\"filter_nulls\", True):",
            "            self.add_null_filters()",
            "",
            "        query_obj = super().query_obj()",
            "        group_by: List[str] = []",
            "",
            "        for key in self.spatial_control_keys:",
            "            self.process_spatial_query_obj(key, group_by)",
            "",
            "        if self.form_data.get(\"dimension\"):",
            "            group_by += [self.form_data[\"dimension\"]]",
            "",
            "        if self.form_data.get(\"js_columns\"):",
            "            group_by += self.form_data.get(\"js_columns\") or []",
            "        metrics = self.get_metrics()",
            "        # Ensure this value is sorted so that it does not",
            "        # cause the cache key generation (which hashes the",
            "        # query object) to generate different keys for values",
            "        # that should be considered the same.",
            "        group_by = sorted(set(group_by))",
            "        if metrics:",
            "            query_obj[\"groupby\"] = group_by",
            "            query_obj[\"metrics\"] = metrics",
            "            query_obj[\"columns\"] = []",
            "            first_metric = query_obj[\"metrics\"][0]",
            "            query_obj[\"orderby\"] = [",
            "                (first_metric, not self.form_data.get(\"order_desc\", True))",
            "            ]",
            "        else:",
            "            query_obj[\"columns\"] = group_by",
            "        return query_obj",
            "",
            "    def get_js_columns(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        cols = self.form_data.get(\"js_columns\") or []",
            "        return {col: data.get(col) for col in cols}",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        # Processing spatial info",
            "        for key in self.spatial_control_keys:",
            "            df = self.process_spatial_data_obj(key, df)",
            "",
            "        features = []",
            "        for data in df.to_dict(orient=\"records\"):",
            "            feature = self.get_properties(data)",
            "            extra_props = self.get_js_columns(data)",
            "            if extra_props:",
            "                feature[\"extraProps\"] = extra_props",
            "            features.append(feature)",
            "",
            "        return {",
            "            \"features\": features,",
            "            \"mapboxApiKey\": config[\"MAPBOX_API_KEY\"],",
            "            \"metricLabels\": self.metric_labels,",
            "        }",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        raise NotImplementedError()",
            "",
            "",
            "class DeckScatterViz(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's ScatterLayer\"\"\"",
            "",
            "    viz_type = \"deck_scatter\"",
            "    verbose_name = _(\"Deck.gl - Scatter plot\")",
            "    spatial_control_keys = [\"spatial\"]",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.is_timeseries = bool(",
            "            self.form_data.get(\"time_grain_sqla\") or self.form_data.get(\"granularity\")",
            "        )",
            "        self.point_radius_fixed = self.form_data.get(\"point_radius_fixed\") or {",
            "            \"type\": \"fix\",",
            "            \"value\": 500,",
            "        }",
            "        return super().query_obj()",
            "",
            "    def get_metrics(self) -> List[str]:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.metric = None",
            "        if self.point_radius_fixed.get(\"type\") == \"metric\":",
            "            self.metric = self.point_radius_fixed[\"value\"]",
            "            return [self.metric]",
            "        return []",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        return {",
            "            \"metric\": data.get(self.metric_label) if self.metric_label else None,",
            "            \"radius\": self.fixed_value",
            "            if self.fixed_value",
            "            else data.get(self.metric_label)",
            "            if self.metric_label",
            "            else None,",
            "            \"cat_color\": data.get(self.dim) if self.dim else None,",
            "            \"position\": data.get(\"spatial\"),",
            "            DTTM_ALIAS: data.get(DTTM_ALIAS),",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.metric_label = utils.get_metric_name(self.metric) if self.metric else None",
            "        self.point_radius_fixed = self.form_data.get(\"point_radius_fixed\")",
            "        self.fixed_value = None",
            "        self.dim = self.form_data.get(\"dimension\")",
            "        if self.point_radius_fixed and self.point_radius_fixed.get(\"type\") != \"metric\":",
            "            self.fixed_value = self.point_radius_fixed.get(\"value\")",
            "        return super().get_data(df)",
            "",
            "",
            "class DeckScreengrid(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's ScreenGridLayer\"\"\"",
            "",
            "    viz_type = \"deck_screengrid\"",
            "    verbose_name = _(\"Deck.gl - Screen Grid\")",
            "    spatial_control_keys = [\"spatial\"]",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        self.is_timeseries = bool(",
            "            self.form_data.get(\"time_grain_sqla\") or self.form_data.get(\"granularity\")",
            "        )",
            "        return super().query_obj()",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        return {",
            "            \"position\": data.get(\"spatial\"),",
            "            \"weight\": (data.get(self.metric_label) if self.metric_label else None) or 1,",
            "            \"__timestamp\": data.get(DTTM_ALIAS) or data.get(\"__time\"),",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        self.metric_label = (  # pylint: disable=attribute-defined-outside-init",
            "            utils.get_metric_name(self.metric) if self.metric else None",
            "        )",
            "        return super().get_data(df)",
            "",
            "",
            "class DeckGrid(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's DeckLayer\"\"\"",
            "",
            "    viz_type = \"deck_grid\"",
            "    verbose_name = _(\"Deck.gl - 3D Grid\")",
            "    spatial_control_keys = [\"spatial\"]",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        return {",
            "            \"position\": data.get(\"spatial\"),",
            "            \"weight\": (data.get(self.metric_label) if self.metric_label else None) or 1,",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        self.metric_label = (  # pylint: disable=attribute-defined-outside-init",
            "            utils.get_metric_name(self.metric) if self.metric else None",
            "        )",
            "        return super().get_data(df)",
            "",
            "",
            "def geohash_to_json(geohash_code: str) -> List[List[float]]:",
            "    bbox = geohash.bbox(geohash_code)",
            "    return [",
            "        [bbox.get(\"w\"), bbox.get(\"n\")],",
            "        [bbox.get(\"e\"), bbox.get(\"n\")],",
            "        [bbox.get(\"e\"), bbox.get(\"s\")],",
            "        [bbox.get(\"w\"), bbox.get(\"s\")],",
            "        [bbox.get(\"w\"), bbox.get(\"n\")],",
            "    ]",
            "",
            "",
            "class DeckPathViz(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's PathLayer\"\"\"",
            "",
            "    viz_type = \"deck_path\"",
            "    verbose_name = _(\"Deck.gl - Paths\")",
            "    deck_viz_key = \"path\"",
            "    is_timeseries = True",
            "    deser_map = {",
            "        \"json\": json.loads,",
            "        \"polyline\": polyline.decode,",
            "        \"geohash\": geohash_to_json,",
            "    }",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.is_timeseries = bool(",
            "            self.form_data.get(\"time_grain_sqla\") or self.form_data.get(\"granularity\")",
            "        )",
            "        query_obj = super().query_obj()",
            "        self.metric = self.form_data.get(\"metric\")",
            "        line_col = self.form_data.get(\"line_column\")",
            "        if query_obj[\"metrics\"]:",
            "            self.has_metrics = True",
            "            query_obj[\"groupby\"].append(line_col)",
            "        else:",
            "            self.has_metrics = False",
            "            query_obj[\"columns\"].append(line_col)",
            "        return query_obj",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        line_type = self.form_data[\"line_type\"]",
            "        deser = self.deser_map[line_type]",
            "        line_column = self.form_data[\"line_column\"]",
            "        path = deser(data[line_column])",
            "        if self.form_data.get(\"reverse_long_lat\"):",
            "            path = [(o[1], o[0]) for o in path]",
            "        data[self.deck_viz_key] = path",
            "        if line_type != \"geohash\":",
            "            del data[line_column]",
            "        data[\"__timestamp\"] = data.get(DTTM_ALIAS) or data.get(\"__time\")",
            "        return data",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        self.metric_label = (  # pylint: disable=attribute-defined-outside-init",
            "            utils.get_metric_name(self.metric) if self.metric else None",
            "        )",
            "        return super().get_data(df)",
            "",
            "",
            "class DeckPolygon(DeckPathViz):",
            "",
            "    \"\"\"deck.gl's Polygon Layer\"\"\"",
            "",
            "    viz_type = \"deck_polygon\"",
            "    deck_viz_key = \"polygon\"",
            "    verbose_name = _(\"Deck.gl - Polygon\")",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        # pylint: disable=attribute-defined-outside-init",
            "        self.elevation = self.form_data.get(\"point_radius_fixed\") or {",
            "            \"type\": \"fix\",",
            "            \"value\": 500,",
            "        }",
            "        return super().query_obj()",
            "",
            "    def get_metrics(self) -> List[str]:",
            "        metrics = [self.form_data.get(\"metric\")]",
            "        if self.elevation.get(\"type\") == \"metric\":",
            "            metrics.append(self.elevation.get(\"value\"))",
            "        return [metric for metric in metrics if metric]",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        super().get_properties(data)",
            "        elevation = self.form_data[\"point_radius_fixed\"][\"value\"]",
            "        type_ = self.form_data[\"point_radius_fixed\"][\"type\"]",
            "        data[\"elevation\"] = (",
            "            data.get(utils.get_metric_name(elevation))",
            "            if type_ == \"metric\"",
            "            else elevation",
            "        )",
            "        return data",
            "",
            "",
            "class DeckHex(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's DeckLayer\"\"\"",
            "",
            "    viz_type = \"deck_hex\"",
            "    verbose_name = _(\"Deck.gl - 3D HEX\")",
            "    spatial_control_keys = [\"spatial\"]",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        return {",
            "            \"position\": data.get(\"spatial\"),",
            "            \"weight\": (data.get(self.metric_label) if self.metric_label else None) or 1,",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        self.metric_label = (  # pylint: disable=attribute-defined-outside-init",
            "            utils.get_metric_name(self.metric) if self.metric else None",
            "        )",
            "        return super().get_data(df)",
            "",
            "",
            "class DeckGeoJson(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's GeoJSONLayer\"\"\"",
            "",
            "    viz_type = \"deck_geojson\"",
            "    verbose_name = _(\"Deck.gl - GeoJSON\")",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        query_obj[\"columns\"] += [self.form_data.get(\"geojson\")]",
            "        query_obj[\"metrics\"] = []",
            "        query_obj[\"groupby\"] = []",
            "        return query_obj",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        geojson = data[self.form_data[\"geojson\"]]",
            "        return json.loads(geojson)",
            "",
            "",
            "class DeckArc(BaseDeckGLViz):",
            "",
            "    \"\"\"deck.gl's Arc Layer\"\"\"",
            "",
            "    viz_type = \"deck_arc\"",
            "    verbose_name = _(\"Deck.gl - Arc\")",
            "    spatial_control_keys = [\"start_spatial\", \"end_spatial\"]",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        self.is_timeseries = bool(",
            "            self.form_data.get(\"time_grain_sqla\") or self.form_data.get(\"granularity\")",
            "        )",
            "        return super().query_obj()",
            "",
            "    def get_properties(self, data: Dict[str, Any]) -> Dict[str, Any]:",
            "        dim = self.form_data.get(\"dimension\")",
            "        return {",
            "            \"sourcePosition\": data.get(\"start_spatial\"),",
            "            \"targetPosition\": data.get(\"end_spatial\"),",
            "            \"cat_color\": data.get(dim) if dim else None,",
            "            DTTM_ALIAS: data.get(DTTM_ALIAS),",
            "        }",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        return {",
            "            \"features\": super().get_data(df)[\"features\"],  # type: ignore",
            "            \"mapboxApiKey\": config[\"MAPBOX_API_KEY\"],",
            "        }",
            "",
            "",
            "class EventFlowViz(BaseViz):",
            "",
            "    \"\"\"A visualization to explore patterns in event sequences\"\"\"",
            "",
            "    viz_type = \"event_flow\"",
            "    verbose_name = _(\"Event flow\")",
            "    credits = 'from <a href=\"https://github.com/williaster/data-ui\">@data-ui</a>'",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query = super().query_obj()",
            "        form_data = self.form_data",
            "",
            "        event_key = form_data[\"all_columns_x\"]",
            "        entity_key = form_data[\"entity\"]",
            "        meta_keys = [",
            "            col",
            "            for col in form_data[\"all_columns\"] or []",
            "            if col not in (event_key, entity_key)",
            "        ]",
            "",
            "        query[\"columns\"] = [event_key, entity_key] + meta_keys",
            "",
            "        if form_data[\"order_by_entity\"]:",
            "            query[\"orderby\"] = [(entity_key, True)]",
            "",
            "        return query",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        return df.to_dict(orient=\"records\")",
            "",
            "",
            "class PairedTTestViz(BaseViz):",
            "",
            "    \"\"\"A table displaying paired t-test values\"\"\"",
            "",
            "    viz_type = \"paired_ttest\"",
            "    verbose_name = _(\"Time Series - Paired t-test\")",
            "    sort_series = False",
            "    is_timeseries = True",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        sort_by = self.form_data.get(\"timeseries_limit_metric\")",
            "        if sort_by:",
            "            sort_by_label = utils.get_metric_name(sort_by)",
            "            if sort_by_label not in utils.get_metric_names(query_obj[\"metrics\"]):",
            "                query_obj[\"metrics\"].append(sort_by)",
            "            if self.form_data.get(\"order_desc\"):",
            "                query_obj[\"orderby\"] = [",
            "                    (sort_by, not self.form_data.get(\"order_desc\", True))",
            "                ]",
            "        return query_obj",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        \"\"\"",
            "        Transform received data frame into an object of the form:",
            "        {",
            "            'metric1': [",
            "                {",
            "                    groups: ('groupA', ... ),",
            "                    values: [ {x, y}, ... ],",
            "                }, ...",
            "            ], ...",
            "        }",
            "        \"\"\"",
            "",
            "        if df.empty:",
            "            return None",
            "",
            "        groups = self.form_data.get(\"groupby\")",
            "        metrics = self.metric_labels",
            "        df = df.pivot_table(index=DTTM_ALIAS, columns=groups, values=metrics)",
            "        cols = []",
            "        # Be rid of falsey keys",
            "        for col in df.columns:",
            "            if col == \"\":",
            "                cols.append(\"N/A\")",
            "            elif col is None:",
            "                cols.append(\"NULL\")",
            "            else:",
            "                cols.append(col)",
            "        df.columns = cols",
            "        data: Dict[str, List[Dict[str, Any]]] = {}",
            "        series = df.to_dict(\"series\")",
            "        for name_set in df.columns:",
            "            # If no groups are defined, nameSet will be the metric name",
            "            has_group = not isinstance(name_set, str)",
            "            data_ = {",
            "                \"group\": name_set[1:] if has_group else \"All\",",
            "                \"values\": [",
            "                    {",
            "                        \"x\": t,",
            "                        \"y\": series[name_set][t] if t in series[name_set] else None,",
            "                    }",
            "                    for t in df.index",
            "                ],",
            "            }",
            "            key = name_set[0] if has_group else name_set",
            "            if key in data:",
            "                data[key].append(data_)",
            "            else:",
            "                data[key] = [data_]",
            "        return data",
            "",
            "",
            "class RoseViz(NVD3TimeSeriesViz):",
            "",
            "    viz_type = \"rose\"",
            "    verbose_name = _(\"Time Series - Nightingale Rose Chart\")",
            "    sort_series = False",
            "    is_timeseries = True",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "",
            "        data = super().get_data(df)",
            "        result: Dict[str, List[Dict[str, str]]] = {}",
            "        for datum in data:  # type: ignore",
            "            key = datum[\"key\"]",
            "            for val in datum[\"values\"]:",
            "                timestamp = val[\"x\"].value",
            "                if not result.get(timestamp):",
            "                    result[timestamp] = []",
            "                value = 0 if math.isnan(val[\"y\"]) else val[\"y\"]",
            "                result[timestamp].append(",
            "                    {",
            "                        \"key\": key,",
            "                        \"value\": value,",
            "                        \"name\": \", \".join(key) if isinstance(key, list) else key,",
            "                        \"time\": val[\"x\"],",
            "                    }",
            "                )",
            "        return result",
            "",
            "",
            "class PartitionViz(NVD3TimeSeriesViz):",
            "",
            "    \"\"\"",
            "    A hierarchical data visualization with support for time series.",
            "    \"\"\"",
            "",
            "    viz_type = \"partition\"",
            "    verbose_name = _(\"Partition Diagram\")",
            "",
            "    def query_obj(self) -> QueryObjectDict:",
            "        query_obj = super().query_obj()",
            "        time_op = self.form_data.get(\"time_series_option\", \"not_time\")",
            "        # Return time series data if the user specifies so",
            "        query_obj[\"is_timeseries\"] = time_op != \"not_time\"",
            "        return query_obj",
            "",
            "    @staticmethod",
            "    def levels_for(",
            "        time_op: str, groups: List[str], df: pd.DataFrame",
            "    ) -> Dict[int, pd.Series]:",
            "        \"\"\"",
            "        Compute the partition at each `level` from the dataframe.",
            "        \"\"\"",
            "        levels = {}",
            "        for i in range(0, len(groups) + 1):",
            "            agg_df = df.groupby(groups[:i]) if i else df",
            "            levels[i] = (",
            "                agg_df.mean()",
            "                if time_op == \"agg_mean\"",
            "                else agg_df.sum(numeric_only=True)",
            "            )",
            "        return levels",
            "",
            "    @staticmethod",
            "    def levels_for_diff(",
            "        time_op: str, groups: List[str], df: pd.DataFrame",
            "    ) -> Dict[int, pd.DataFrame]:",
            "        # Obtain a unique list of the time grains",
            "        times = list(set(df[DTTM_ALIAS]))",
            "        times.sort()",
            "        until = times[len(times) - 1]",
            "        since = times[0]",
            "        # Function describing how to calculate the difference",
            "        func = {",
            "            \"point_diff\": [pd.Series.sub, lambda a, b, fill_value: a - b],",
            "            \"point_factor\": [pd.Series.div, lambda a, b, fill_value: a / float(b)],",
            "            \"point_percent\": [",
            "                lambda a, b, fill_value=0: a.div(b, fill_value=fill_value) - 1,",
            "                lambda a, b, fill_value: a / float(b) - 1,",
            "            ],",
            "        }[time_op]",
            "        agg_df = df.groupby(DTTM_ALIAS).sum()",
            "        levels = {",
            "            0: pd.Series(",
            "                {",
            "                    m: func[1](agg_df[m][until], agg_df[m][since], 0)",
            "                    for m in agg_df.columns",
            "                }",
            "            )",
            "        }",
            "        for i in range(1, len(groups) + 1):",
            "            agg_df = df.groupby([DTTM_ALIAS] + groups[:i]).sum()",
            "            levels[i] = pd.DataFrame(",
            "                {",
            "                    m: func[0](agg_df[m][until], agg_df[m][since], fill_value=0)",
            "                    for m in agg_df.columns",
            "                }",
            "            )",
            "        return levels",
            "",
            "    def levels_for_time(",
            "        self, groups: List[str], df: pd.DataFrame",
            "    ) -> Dict[int, VizData]:",
            "        procs = {}",
            "        for i in range(0, len(groups) + 1):",
            "            self.form_data[\"groupby\"] = groups[:i]",
            "            df_drop = df.drop(groups[i:], 1)",
            "            procs[i] = self.process_data(df_drop, aggregate=True)",
            "        self.form_data[\"groupby\"] = groups",
            "        return procs",
            "",
            "    def nest_values(",
            "        self,",
            "        levels: Dict[int, pd.DataFrame],",
            "        level: int = 0,",
            "        metric: Optional[str] = None,",
            "        dims: Optional[List[str]] = None,",
            "    ) -> List[Dict[str, Any]]:",
            "        \"\"\"",
            "        Nest values at each level on the back-end with",
            "        access and setting, instead of summing from the bottom.",
            "        \"\"\"",
            "        if dims is None:",
            "            dims = []",
            "        if not level:",
            "            return [",
            "                {",
            "                    \"name\": m,",
            "                    \"val\": levels[0][m],",
            "                    \"children\": self.nest_values(levels, 1, m),",
            "                }",
            "                for m in levels[0].index",
            "            ]",
            "        if level == 1:",
            "            metric_level = levels[1][metric]",
            "            return [",
            "                {",
            "                    \"name\": i,",
            "                    \"val\": metric_level[i],",
            "                    \"children\": self.nest_values(levels, 2, metric, [i]),",
            "                }",
            "                for i in metric_level.index",
            "            ]",
            "        if level >= len(levels):",
            "            return []",
            "        dim_level = levels[level][metric][[dims[0]]]",
            "        return [",
            "            {",
            "                \"name\": i,",
            "                \"val\": dim_level[i],",
            "                \"children\": self.nest_values(levels, level + 1, metric, dims + [i]),",
            "            }",
            "            for i in dim_level.index",
            "        ]",
            "",
            "    def nest_procs(",
            "        self,",
            "        procs: Dict[int, pd.DataFrame],",
            "        level: int = -1,",
            "        dims: Optional[Tuple[str, ...]] = None,",
            "        time: Any = None,",
            "    ) -> List[Dict[str, Any]]:",
            "        if dims is None:",
            "            dims = ()",
            "        if level == -1:",
            "            return [",
            "                {\"name\": m, \"children\": self.nest_procs(procs, 0, (m,))}",
            "                for m in procs[0].columns",
            "            ]",
            "        if not level:",
            "            return [",
            "                {",
            "                    \"name\": t,",
            "                    \"val\": procs[0][dims[0]][t],",
            "                    \"children\": self.nest_procs(procs, 1, dims, t),",
            "                }",
            "                for t in procs[0].index",
            "            ]",
            "        if level >= len(procs):",
            "            return []",
            "        return [",
            "            {",
            "                \"name\": i,",
            "                \"val\": procs[level][dims][i][time],",
            "                \"children\": self.nest_procs(procs, level + 1, dims + (i,), time),",
            "            }",
            "            for i in procs[level][dims].columns",
            "        ]",
            "",
            "    def get_data(self, df: pd.DataFrame) -> VizData:",
            "        if df.empty:",
            "            return None",
            "        groups = self.form_data.get(\"groupby\", [])",
            "        time_op = self.form_data.get(\"time_series_option\", \"not_time\")",
            "        if not groups:",
            "            raise ValueError(\"Please choose at least one groupby\")",
            "        if time_op == \"not_time\":",
            "            levels = self.levels_for(\"agg_sum\", groups, df)",
            "        elif time_op in [\"agg_sum\", \"agg_mean\"]:",
            "            levels = self.levels_for(time_op, groups, df)",
            "        elif time_op in [\"point_diff\", \"point_factor\", \"point_percent\"]:",
            "            levels = self.levels_for_diff(time_op, groups, df)",
            "        elif time_op == \"adv_anal\":",
            "            procs = self.levels_for_time(groups, df)",
            "            return self.nest_procs(procs)",
            "        else:",
            "            levels = self.levels_for(\"agg_sum\", [DTTM_ALIAS] + groups, df)",
            "        return self.nest_values(levels)",
            "",
            "",
            "def get_subclasses(cls: Type[BaseViz]) -> Set[Type[BaseViz]]:",
            "    return set(cls.__subclasses__()).union(",
            "        [sc for c in cls.__subclasses__() for sc in get_subclasses(c)]",
            "    )",
            "",
            "",
            "viz_types = {",
            "    o.viz_type: o",
            "    for o in get_subclasses(BaseViz)",
            "    if o.viz_type not in config[\"VIZ_TYPE_DENYLIST\"]",
            "}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "63": [],
            "70": [],
            "363": [
                "BaseViz",
                "query_obj"
            ],
            "364": [
                "BaseViz",
                "query_obj"
            ],
            "365": [
                "BaseViz",
                "query_obj"
            ],
            "366": [
                "BaseViz",
                "query_obj"
            ]
        },
        "addLocation": []
    }
}