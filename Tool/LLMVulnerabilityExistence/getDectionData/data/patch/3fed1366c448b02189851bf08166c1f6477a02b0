{
    "haystack/components/builders/chat_prompt_builder.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from typing import Any, Dict, List, Optional, Set"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from jinja2 import Template, meta"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from jinja2 import meta"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from jinja2.sandbox import SandboxedEnvironment"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from haystack import component, default_from_dict, default_to_dict, logging"
            },
            "8": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from haystack.dataclasses.chat_message import ChatMessage, ChatRole"
            },
            "9": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         self.required_variables = required_variables or []"
            },
            "10": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         self.template = template"
            },
            "11": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         variables = variables or []"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        self._env = SandboxedEnvironment()"
            },
            "13": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         if template and not variables:"
            },
            "14": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "             for message in template:"
            },
            "15": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "                 if message.is_from(ChatRole.USER) or message.is_from(ChatRole.SYSTEM):"
            },
            "16": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "                     # infere variables from template"
            },
            "17": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    msg_template = Template(message.content)"
            },
            "18": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ast = msg_template.environment.parse(message.content)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+                    ast = self._env.parse(message.content)"
            },
            "20": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "                     template_variables = meta.find_undeclared_variables(ast)"
            },
            "21": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                     variables += list(template_variables)"
            },
            "22": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "         for message in template:"
            },
            "24": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "             if message.is_from(ChatRole.USER) or message.is_from(ChatRole.SYSTEM):"
            },
            "25": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "                 self._validate_variables(set(template_variables_combined.keys()))"
            },
            "26": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                compiled_template = Template(message.content)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                compiled_template = self._env.from_string(message.content)"
            },
            "29": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "                 rendered_content = compiled_template.render(template_variables_combined)"
            },
            "30": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "                 rendered_message = ("
            },
            "31": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "                     ChatMessage.from_user(rendered_content)"
            }
        },
        "frontPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "from typing import Any, Dict, List, Optional, Set",
            "",
            "from jinja2 import Template, meta",
            "",
            "from haystack import component, default_from_dict, default_to_dict, logging",
            "from haystack.dataclasses.chat_message import ChatMessage, ChatRole",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@component",
            "class ChatPromptBuilder:",
            "    \"\"\"",
            "    ChatPromptBuilder is a component that renders a chat prompt from a template string using Jinja2 templates.",
            "",
            "    It is designed to construct prompts for the pipeline using static or dynamic templates: Users can change",
            "    the prompt template at runtime by providing a new template for each pipeline run invocation if needed.",
            "",
            "    The template variables found in the init template string are used as input types for the component and are all",
            "    optional, unless explicitly specified. If an optional template variable is not provided as an input, it will be",
            "    replaced with an empty string in the rendered prompt. Use `variable` and `required_variables` to specify the input",
            "    types and required variables.",
            "",
            "    Usage example with static prompt template:",
            "    ```python",
            "    template = [ChatMessage.from_user(\"Translate to {{ target_language }}. Context: {{ snippet }}; Translation:\")]",
            "    builder = ChatPromptBuilder(template=template)",
            "    builder.run(target_language=\"spanish\", snippet=\"I can't speak spanish.\")",
            "    ```",
            "",
            "    Usage example of overriding the static template at runtime:",
            "    ```python",
            "    template = [ChatMessage.from_user(\"Translate to {{ target_language }}. Context: {{ snippet }}; Translation:\")]",
            "    builder = ChatPromptBuilder(template=template)",
            "    builder.run(target_language=\"spanish\", snippet=\"I can't speak spanish.\")",
            "",
            "    msg = \"Translate to {{ target_language }} and summarize. Context: {{ snippet }}; Summary:\"",
            "    summary_template = [ChatMessage.from_user(msg)]",
            "    builder.run(target_language=\"spanish\", snippet=\"I can't speak spanish.\", template=summary_template)",
            "    ```",
            "",
            "    Usage example with dynamic prompt template:",
            "    ```python",
            "    from haystack.components.builders import ChatPromptBuilder",
            "    from haystack.components.generators.chat import OpenAIChatGenerator",
            "    from haystack.dataclasses import ChatMessage",
            "    from haystack import Pipeline",
            "    from haystack.utils import Secret",
            "",
            "    # no parameter init, we don't use any runtime template variables",
            "    prompt_builder = ChatPromptBuilder()",
            "    llm = OpenAIChatGenerator(api_key=Secret.from_token(\"<your-api-key>\"), model=\"gpt-3.5-turbo\")",
            "",
            "    pipe = Pipeline()",
            "    pipe.add_component(\"prompt_builder\", prompt_builder)",
            "    pipe.add_component(\"llm\", llm)",
            "    pipe.connect(\"prompt_builder.prompt\", \"llm.messages\")",
            "",
            "    location = \"Berlin\"",
            "    language = \"English\"",
            "    system_message = ChatMessage.from_system(\"You are an assistant giving information to tourists in {{language}}\")",
            "    messages = [system_message, ChatMessage.from_user(\"Tell me about {{location}}\")]",
            "",
            "    res = pipe.run(data={\"prompt_builder\": {\"template_variables\": {\"location\": location, \"language\": language},",
            "                                        \"template\": messages}})",
            "    print(res)",
            "",
            "    >> {'llm': {'replies': [ChatMessage(content=\"Berlin is the capital city of Germany and one of the most vibrant",
            "    and diverse cities in Europe. Here are some key things to know...Enjoy your time exploring the vibrant and dynamic",
            "    capital of Germany!\", role=<ChatRole.ASSISTANT: 'assistant'>, name=None, meta={'model': 'gpt-3.5-turbo-0613',",
            "    'index': 0, 'finish_reason': 'stop', 'usage': {'prompt_tokens': 27, 'completion_tokens': 681, 'total_tokens':",
            "    708}})]}}",
            "",
            "",
            "    messages = [system_message, ChatMessage.from_user(\"What's the weather forecast for {{location}} in the next",
            "    {{day_count}} days?\")]",
            "",
            "    res = pipe.run(data={\"prompt_builder\": {\"template_variables\": {\"location\": location, \"day_count\": \"5\"},",
            "                                        \"template\": messages}})",
            "",
            "    print(res)",
            "    >> {'llm': {'replies': [ChatMessage(content=\"Here is the weather forecast for Berlin in the next 5",
            "    days:\\n\\nDay 1: Mostly cloudy with a high of 22\u00b0C (72\u00b0F) and...so it's always a good idea to check for updates",
            "    closer to your visit.\", role=<ChatRole.ASSISTANT: 'assistant'>, name=None, meta={'model': 'gpt-3.5-turbo-0613',",
            "    'index': 0, 'finish_reason': 'stop', 'usage': {'prompt_tokens': 37, 'completion_tokens': 201,",
            "    'total_tokens': 238}})]}}",
            "    ```",
            "",
            "    Note how in the example above, we can dynamically change the prompt template by providing a new template to the",
            "    run method of the pipeline.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        template: Optional[List[ChatMessage]] = None,",
            "        required_variables: Optional[List[str]] = None,",
            "        variables: Optional[List[str]] = None,",
            "    ):",
            "        \"\"\"",
            "        Constructs a ChatPromptBuilder component.",
            "",
            "        :param template:",
            "            A list of `ChatMessage` instances. All user and system messages are treated as potentially having jinja2",
            "            templates and are rendered with the provided template variables. If not provided, the template",
            "            must be provided at runtime using the `template` parameter of the `run` method.",
            "        :param required_variables: An optional list of input variables that must be provided at all times.",
            "            If not provided, an exception will be raised.",
            "        :param variables:",
            "            A list of template variable names you can use in prompt construction. For example,",
            "            if `variables` contains the string `documents`, the component will create an input called",
            "            `documents` of type `Any`. These variable names are used to resolve variables and their values during",
            "            pipeline execution. The values associated with variables from the pipeline runtime are then injected into",
            "            template placeholders of a prompt text template that is provided to the `run` method.",
            "            If not provided, variables are inferred from `template`.",
            "        \"\"\"",
            "        self._variables = variables",
            "        self._required_variables = required_variables",
            "        self.required_variables = required_variables or []",
            "        self.template = template",
            "        variables = variables or []",
            "        if template and not variables:",
            "            for message in template:",
            "                if message.is_from(ChatRole.USER) or message.is_from(ChatRole.SYSTEM):",
            "                    # infere variables from template",
            "                    msg_template = Template(message.content)",
            "                    ast = msg_template.environment.parse(message.content)",
            "                    template_variables = meta.find_undeclared_variables(ast)",
            "                    variables += list(template_variables)",
            "",
            "        # setup inputs",
            "        static_input_slots = {\"template\": Optional[str], \"template_variables\": Optional[Dict[str, Any]]}",
            "        component.set_input_types(self, **static_input_slots)",
            "        for var in variables:",
            "            if var in self.required_variables:",
            "                component.set_input_type(self, var, Any)",
            "            else:",
            "                component.set_input_type(self, var, Any, \"\")",
            "",
            "    @component.output_types(prompt=List[ChatMessage])",
            "    def run(",
            "        self,",
            "        template: Optional[List[ChatMessage]] = None,",
            "        template_variables: Optional[Dict[str, Any]] = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Executes the prompt building process.",
            "",
            "        It applies the template variables to render the final prompt. You can provide variables either via pipeline",
            "        (set through `variables` or inferred from `template` at initialization) or via additional template variables",
            "        set directly to this method. On collision, the variables provided directly to this method take precedence.",
            "",
            "        :param template:",
            "            An optional list of ChatMessages to overwrite ChatPromptBuilder's default template. If None, the default",
            "            template provided at initialization is used.",
            "        :param template_variables:",
            "            An optional dictionary of template variables. These are additional variables users can provide directly",
            "            to this method in contrast to pipeline variables.",
            "        :param kwargs:",
            "            Pipeline variables (typically resolved from a pipeline) which are merged with the provided template",
            "            variables.",
            "",
            "        :returns: A dictionary with the following keys:",
            "            - `prompt`: The updated list of `ChatMessage` instances after rendering the found templates.",
            "        :raises ValueError:",
            "            If `chat_messages` is empty or contains elements that are not instances of `ChatMessage`.",
            "        \"\"\"",
            "        kwargs = kwargs or {}",
            "        template_variables = template_variables or {}",
            "        template_variables_combined = {**kwargs, **template_variables}",
            "",
            "        if template is None:",
            "            template = self.template",
            "",
            "        if not template:",
            "            raise ValueError(",
            "                f\"The {self.__class__.__name__} requires a non-empty list of ChatMessage instances. \"",
            "                f\"Please provide a valid list of ChatMessage instances to render the prompt.\"",
            "            )",
            "",
            "        if not all(isinstance(message, ChatMessage) for message in template):",
            "            raise ValueError(",
            "                f\"The {self.__class__.__name__} expects a list containing only ChatMessage instances. \"",
            "                f\"The provided list contains other types. Please ensure that all elements in the list \"",
            "                f\"are ChatMessage instances.\"",
            "            )",
            "",
            "        processed_messages = []",
            "        for message in template:",
            "            if message.is_from(ChatRole.USER) or message.is_from(ChatRole.SYSTEM):",
            "                self._validate_variables(set(template_variables_combined.keys()))",
            "                compiled_template = Template(message.content)",
            "                rendered_content = compiled_template.render(template_variables_combined)",
            "                rendered_message = (",
            "                    ChatMessage.from_user(rendered_content)",
            "                    if message.is_from(ChatRole.USER)",
            "                    else ChatMessage.from_system(rendered_content)",
            "                )",
            "                processed_messages.append(rendered_message)",
            "            else:",
            "                processed_messages.append(message)",
            "",
            "        return {\"prompt\": processed_messages}",
            "",
            "    def _validate_variables(self, provided_variables: Set[str]):",
            "        \"\"\"",
            "        Checks if all the required template variables are provided.",
            "",
            "        :param provided_variables:",
            "            A set of provided template variables.",
            "        :raises ValueError:",
            "            If no template is provided or if all the required template variables are not provided.",
            "        \"\"\"",
            "        missing_variables = [var for var in self.required_variables if var not in provided_variables]",
            "        if missing_variables:",
            "            missing_vars_str = \", \".join(missing_variables)",
            "            raise ValueError(",
            "                f\"Missing required input variables in ChatPromptBuilder: {missing_vars_str}. \"",
            "                f\"Required variables: {self.required_variables}. Provided variables: {provided_variables}.\"",
            "            )",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Returns a dictionary representation of the component.",
            "",
            "        :returns:",
            "            Serialized dictionary representation of the component.",
            "        \"\"\"",
            "        if self.template is not None:",
            "            template = [m.to_dict() for m in self.template]",
            "        else:",
            "            template = None",
            "",
            "        return default_to_dict(",
            "            self, template=template, variables=self._variables, required_variables=self._required_variables",
            "        )",
            "",
            "    @classmethod",
            "    def from_dict(cls, data: Dict[str, Any]) -> \"ChatPromptBuilder\":",
            "        \"\"\"",
            "        Deserialize this component from a dictionary.",
            "",
            "        :param data:",
            "            The dictionary to deserialize and create the component.",
            "",
            "        :returns:",
            "            The deserialized component.",
            "        \"\"\"",
            "        init_parameters = data[\"init_parameters\"]",
            "        template = init_parameters.get(\"template\", [])",
            "        init_parameters[\"template\"] = [ChatMessage.from_dict(d) for d in template]",
            "",
            "        return default_from_dict(cls, data)"
        ],
        "afterPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "from typing import Any, Dict, List, Optional, Set",
            "",
            "from jinja2 import meta",
            "from jinja2.sandbox import SandboxedEnvironment",
            "",
            "from haystack import component, default_from_dict, default_to_dict, logging",
            "from haystack.dataclasses.chat_message import ChatMessage, ChatRole",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@component",
            "class ChatPromptBuilder:",
            "    \"\"\"",
            "    ChatPromptBuilder is a component that renders a chat prompt from a template string using Jinja2 templates.",
            "",
            "    It is designed to construct prompts for the pipeline using static or dynamic templates: Users can change",
            "    the prompt template at runtime by providing a new template for each pipeline run invocation if needed.",
            "",
            "    The template variables found in the init template string are used as input types for the component and are all",
            "    optional, unless explicitly specified. If an optional template variable is not provided as an input, it will be",
            "    replaced with an empty string in the rendered prompt. Use `variable` and `required_variables` to specify the input",
            "    types and required variables.",
            "",
            "    Usage example with static prompt template:",
            "    ```python",
            "    template = [ChatMessage.from_user(\"Translate to {{ target_language }}. Context: {{ snippet }}; Translation:\")]",
            "    builder = ChatPromptBuilder(template=template)",
            "    builder.run(target_language=\"spanish\", snippet=\"I can't speak spanish.\")",
            "    ```",
            "",
            "    Usage example of overriding the static template at runtime:",
            "    ```python",
            "    template = [ChatMessage.from_user(\"Translate to {{ target_language }}. Context: {{ snippet }}; Translation:\")]",
            "    builder = ChatPromptBuilder(template=template)",
            "    builder.run(target_language=\"spanish\", snippet=\"I can't speak spanish.\")",
            "",
            "    msg = \"Translate to {{ target_language }} and summarize. Context: {{ snippet }}; Summary:\"",
            "    summary_template = [ChatMessage.from_user(msg)]",
            "    builder.run(target_language=\"spanish\", snippet=\"I can't speak spanish.\", template=summary_template)",
            "    ```",
            "",
            "    Usage example with dynamic prompt template:",
            "    ```python",
            "    from haystack.components.builders import ChatPromptBuilder",
            "    from haystack.components.generators.chat import OpenAIChatGenerator",
            "    from haystack.dataclasses import ChatMessage",
            "    from haystack import Pipeline",
            "    from haystack.utils import Secret",
            "",
            "    # no parameter init, we don't use any runtime template variables",
            "    prompt_builder = ChatPromptBuilder()",
            "    llm = OpenAIChatGenerator(api_key=Secret.from_token(\"<your-api-key>\"), model=\"gpt-3.5-turbo\")",
            "",
            "    pipe = Pipeline()",
            "    pipe.add_component(\"prompt_builder\", prompt_builder)",
            "    pipe.add_component(\"llm\", llm)",
            "    pipe.connect(\"prompt_builder.prompt\", \"llm.messages\")",
            "",
            "    location = \"Berlin\"",
            "    language = \"English\"",
            "    system_message = ChatMessage.from_system(\"You are an assistant giving information to tourists in {{language}}\")",
            "    messages = [system_message, ChatMessage.from_user(\"Tell me about {{location}}\")]",
            "",
            "    res = pipe.run(data={\"prompt_builder\": {\"template_variables\": {\"location\": location, \"language\": language},",
            "                                        \"template\": messages}})",
            "    print(res)",
            "",
            "    >> {'llm': {'replies': [ChatMessage(content=\"Berlin is the capital city of Germany and one of the most vibrant",
            "    and diverse cities in Europe. Here are some key things to know...Enjoy your time exploring the vibrant and dynamic",
            "    capital of Germany!\", role=<ChatRole.ASSISTANT: 'assistant'>, name=None, meta={'model': 'gpt-3.5-turbo-0613',",
            "    'index': 0, 'finish_reason': 'stop', 'usage': {'prompt_tokens': 27, 'completion_tokens': 681, 'total_tokens':",
            "    708}})]}}",
            "",
            "",
            "    messages = [system_message, ChatMessage.from_user(\"What's the weather forecast for {{location}} in the next",
            "    {{day_count}} days?\")]",
            "",
            "    res = pipe.run(data={\"prompt_builder\": {\"template_variables\": {\"location\": location, \"day_count\": \"5\"},",
            "                                        \"template\": messages}})",
            "",
            "    print(res)",
            "    >> {'llm': {'replies': [ChatMessage(content=\"Here is the weather forecast for Berlin in the next 5",
            "    days:\\n\\nDay 1: Mostly cloudy with a high of 22\u00b0C (72\u00b0F) and...so it's always a good idea to check for updates",
            "    closer to your visit.\", role=<ChatRole.ASSISTANT: 'assistant'>, name=None, meta={'model': 'gpt-3.5-turbo-0613',",
            "    'index': 0, 'finish_reason': 'stop', 'usage': {'prompt_tokens': 37, 'completion_tokens': 201,",
            "    'total_tokens': 238}})]}}",
            "    ```",
            "",
            "    Note how in the example above, we can dynamically change the prompt template by providing a new template to the",
            "    run method of the pipeline.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        template: Optional[List[ChatMessage]] = None,",
            "        required_variables: Optional[List[str]] = None,",
            "        variables: Optional[List[str]] = None,",
            "    ):",
            "        \"\"\"",
            "        Constructs a ChatPromptBuilder component.",
            "",
            "        :param template:",
            "            A list of `ChatMessage` instances. All user and system messages are treated as potentially having jinja2",
            "            templates and are rendered with the provided template variables. If not provided, the template",
            "            must be provided at runtime using the `template` parameter of the `run` method.",
            "        :param required_variables: An optional list of input variables that must be provided at all times.",
            "            If not provided, an exception will be raised.",
            "        :param variables:",
            "            A list of template variable names you can use in prompt construction. For example,",
            "            if `variables` contains the string `documents`, the component will create an input called",
            "            `documents` of type `Any`. These variable names are used to resolve variables and their values during",
            "            pipeline execution. The values associated with variables from the pipeline runtime are then injected into",
            "            template placeholders of a prompt text template that is provided to the `run` method.",
            "            If not provided, variables are inferred from `template`.",
            "        \"\"\"",
            "        self._variables = variables",
            "        self._required_variables = required_variables",
            "        self.required_variables = required_variables or []",
            "        self.template = template",
            "        variables = variables or []",
            "        self._env = SandboxedEnvironment()",
            "        if template and not variables:",
            "            for message in template:",
            "                if message.is_from(ChatRole.USER) or message.is_from(ChatRole.SYSTEM):",
            "                    # infere variables from template",
            "                    ast = self._env.parse(message.content)",
            "                    template_variables = meta.find_undeclared_variables(ast)",
            "                    variables += list(template_variables)",
            "",
            "        # setup inputs",
            "        static_input_slots = {\"template\": Optional[str], \"template_variables\": Optional[Dict[str, Any]]}",
            "        component.set_input_types(self, **static_input_slots)",
            "        for var in variables:",
            "            if var in self.required_variables:",
            "                component.set_input_type(self, var, Any)",
            "            else:",
            "                component.set_input_type(self, var, Any, \"\")",
            "",
            "    @component.output_types(prompt=List[ChatMessage])",
            "    def run(",
            "        self,",
            "        template: Optional[List[ChatMessage]] = None,",
            "        template_variables: Optional[Dict[str, Any]] = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Executes the prompt building process.",
            "",
            "        It applies the template variables to render the final prompt. You can provide variables either via pipeline",
            "        (set through `variables` or inferred from `template` at initialization) or via additional template variables",
            "        set directly to this method. On collision, the variables provided directly to this method take precedence.",
            "",
            "        :param template:",
            "            An optional list of ChatMessages to overwrite ChatPromptBuilder's default template. If None, the default",
            "            template provided at initialization is used.",
            "        :param template_variables:",
            "            An optional dictionary of template variables. These are additional variables users can provide directly",
            "            to this method in contrast to pipeline variables.",
            "        :param kwargs:",
            "            Pipeline variables (typically resolved from a pipeline) which are merged with the provided template",
            "            variables.",
            "",
            "        :returns: A dictionary with the following keys:",
            "            - `prompt`: The updated list of `ChatMessage` instances after rendering the found templates.",
            "        :raises ValueError:",
            "            If `chat_messages` is empty or contains elements that are not instances of `ChatMessage`.",
            "        \"\"\"",
            "        kwargs = kwargs or {}",
            "        template_variables = template_variables or {}",
            "        template_variables_combined = {**kwargs, **template_variables}",
            "",
            "        if template is None:",
            "            template = self.template",
            "",
            "        if not template:",
            "            raise ValueError(",
            "                f\"The {self.__class__.__name__} requires a non-empty list of ChatMessage instances. \"",
            "                f\"Please provide a valid list of ChatMessage instances to render the prompt.\"",
            "            )",
            "",
            "        if not all(isinstance(message, ChatMessage) for message in template):",
            "            raise ValueError(",
            "                f\"The {self.__class__.__name__} expects a list containing only ChatMessage instances. \"",
            "                f\"The provided list contains other types. Please ensure that all elements in the list \"",
            "                f\"are ChatMessage instances.\"",
            "            )",
            "",
            "        processed_messages = []",
            "        for message in template:",
            "            if message.is_from(ChatRole.USER) or message.is_from(ChatRole.SYSTEM):",
            "                self._validate_variables(set(template_variables_combined.keys()))",
            "",
            "                compiled_template = self._env.from_string(message.content)",
            "                rendered_content = compiled_template.render(template_variables_combined)",
            "                rendered_message = (",
            "                    ChatMessage.from_user(rendered_content)",
            "                    if message.is_from(ChatRole.USER)",
            "                    else ChatMessage.from_system(rendered_content)",
            "                )",
            "                processed_messages.append(rendered_message)",
            "            else:",
            "                processed_messages.append(message)",
            "",
            "        return {\"prompt\": processed_messages}",
            "",
            "    def _validate_variables(self, provided_variables: Set[str]):",
            "        \"\"\"",
            "        Checks if all the required template variables are provided.",
            "",
            "        :param provided_variables:",
            "            A set of provided template variables.",
            "        :raises ValueError:",
            "            If no template is provided or if all the required template variables are not provided.",
            "        \"\"\"",
            "        missing_variables = [var for var in self.required_variables if var not in provided_variables]",
            "        if missing_variables:",
            "            missing_vars_str = \", \".join(missing_variables)",
            "            raise ValueError(",
            "                f\"Missing required input variables in ChatPromptBuilder: {missing_vars_str}. \"",
            "                f\"Required variables: {self.required_variables}. Provided variables: {provided_variables}.\"",
            "            )",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Returns a dictionary representation of the component.",
            "",
            "        :returns:",
            "            Serialized dictionary representation of the component.",
            "        \"\"\"",
            "        if self.template is not None:",
            "            template = [m.to_dict() for m in self.template]",
            "        else:",
            "            template = None",
            "",
            "        return default_to_dict(",
            "            self, template=template, variables=self._variables, required_variables=self._required_variables",
            "        )",
            "",
            "    @classmethod",
            "    def from_dict(cls, data: Dict[str, Any]) -> \"ChatPromptBuilder\":",
            "        \"\"\"",
            "        Deserialize this component from a dictionary.",
            "",
            "        :param data:",
            "            The dictionary to deserialize and create the component.",
            "",
            "        :returns:",
            "            The deserialized component.",
            "        \"\"\"",
            "        init_parameters = data[\"init_parameters\"]",
            "        template = init_parameters.get(\"template\", [])",
            "        init_parameters[\"template\"] = [ChatMessage.from_dict(d) for d in template]",
            "",
            "        return default_from_dict(cls, data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": [],
            "130": [
                "ChatPromptBuilder",
                "__init__"
            ],
            "131": [
                "ChatPromptBuilder",
                "__init__"
            ],
            "197": [
                "ChatPromptBuilder",
                "run"
            ]
        },
        "addLocation": []
    },
    "haystack/components/builders/prompt_builder.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from typing import Any, Dict, List, Optional, Set"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from jinja2 import Template, meta"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from jinja2 import meta"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from jinja2.sandbox import SandboxedEnvironment"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from haystack import component, default_to_dict"
            },
            "8": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         self._variables = variables"
            },
            "10": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         self._required_variables = required_variables"
            },
            "11": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         self.required_variables = required_variables or []"
            },
            "12": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.template = Template(template)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        self._env = SandboxedEnvironment()"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        self.template = self._env.from_string(template)"
            },
            "16": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         if not variables:"
            },
            "17": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "             # infere variables from template"
            },
            "18": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ast = self.template.environment.parse(template)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            ast = self._env.parse(template)"
            },
            "20": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "             template_variables = meta.find_undeclared_variables(ast)"
            },
            "21": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             variables = list(template_variables)"
            },
            "22": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "         self._validate_variables(set(template_variables_combined.keys()))"
            },
            "24": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         compiled_template = self.template"
            },
            "26": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if isinstance(template, str):"
            },
            "27": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            compiled_template = Template(template)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        if template is not None:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            compiled_template = self._env.from_string(template)"
            },
            "30": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 224,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         result = compiled_template.render(template_variables_combined)"
            },
            "32": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         return {\"prompt\": result}"
            }
        },
        "frontPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "from typing import Any, Dict, List, Optional, Set",
            "",
            "from jinja2 import Template, meta",
            "",
            "from haystack import component, default_to_dict",
            "",
            "",
            "@component",
            "class PromptBuilder:",
            "    \"\"\"",
            "",
            "    Renders a prompt filling in any variables so that it can send it to a Generator.",
            "",
            "    The prompt uses Jinja2 template syntax.",
            "    The variables in the default template are used as PromptBuilder's input and are all optional.",
            "    If they're not provided, they're replaced with an empty string in the rendered prompt.",
            "    To try out different prompts, you can replace the prompt template at runtime by",
            "    providing a template for each pipeline run invocation.",
            "",
            "    ### Usage examples",
            "",
            "    #### On its own",
            "",
            "    This example uses PromptBuilder to render a prompt template and fill it with `target_language`",
            "    and `snippet`. PromptBuilder returns a prompt with the string \"Translate the following context to Spanish.",
            "    Context: I can't speak Spanish.; Translation:\".",
            "    ```python",
            "    from haystack.components.builders import PromptBuilder",
            "",
            "    template = \"Translate the following context to {{ target_language }}. Context: {{ snippet }}; Translation:\"",
            "    builder = PromptBuilder(template=template)",
            "    builder.run(target_language=\"spanish\", snippet=\"I can't speak spanish.\")",
            "    ```",
            "",
            "    #### In a Pipeline",
            "",
            "    This is an example of a RAG pipeline where PromptBuilder renders a custom prompt template and fills it",
            "    with the contents of the retrieved documents and a query. The rendered prompt is then sent to a Generator.",
            "    ```python",
            "    from haystack import Pipeline, Document",
            "    from haystack.utils import Secret",
            "    from haystack.components.generators import OpenAIGenerator",
            "    from haystack.components.builders.prompt_builder import PromptBuilder",
            "",
            "    # in a real world use case documents could come from a retriever, web, or any other source",
            "    documents = [Document(content=\"Joe lives in Berlin\"), Document(content=\"Joe is a software engineer\")]",
            "    prompt_template = \\\"\\\"\\\"",
            "        Given these documents, answer the question.",
            "        Documents:",
            "        {% for doc in documents %}",
            "            {{ doc.content }}",
            "        {% endfor %}",
            "",
            "        Question: {{query}}",
            "        Answer:",
            "        \\\"\\\"\\\"",
            "    p = Pipeline()",
            "    p.add_component(instance=PromptBuilder(template=prompt_template), name=\"prompt_builder\")",
            "    p.add_component(instance=OpenAIGenerator(api_key=Secret.from_env_var(\"OPENAI_API_KEY\")), name=\"llm\")",
            "    p.connect(\"prompt_builder\", \"llm\")",
            "",
            "    question = \"Where does Joe live?\"",
            "    result = p.run({\"prompt_builder\": {\"documents\": documents, \"query\": question}})",
            "    print(result)",
            "    ```",
            "",
            "    #### Changing the template at runtime (prompt engineering)",
            "",
            "    You can change the prompt template of an existing pipeline, like in this example:",
            "    ```python",
            "    documents = [",
            "        Document(content=\"Joe lives in Berlin\", meta={\"name\": \"doc1\"}),",
            "        Document(content=\"Joe is a software engineer\", meta={\"name\": \"doc1\"}),",
            "    ]",
            "    new_template = \\\"\\\"\\\"",
            "        You are a helpful assistant.",
            "        Given these documents, answer the question.",
            "        Documents:",
            "        {% for doc in documents %}",
            "            Document {{ loop.index }}:",
            "            Document name: {{ doc.meta['name'] }}",
            "            {{ doc.content }}",
            "        {% endfor %}",
            "",
            "        Question: {{ query }}",
            "        Answer:",
            "        \\\"\\\"\\\"",
            "    p.run({",
            "        \"prompt_builder\": {",
            "            \"documents\": documents,",
            "            \"query\": question,",
            "            \"template\": new_template,",
            "        },",
            "    })",
            "    ```",
            "    To replace the variables in the default template when testing your prompt,",
            "    pass the new variables in the `variables` parameter.",
            "",
            "    #### Overwriting variables at runtime",
            "",
            "    To overwrite the values of variables, use `template_variables` during runtime:",
            "    ```python",
            "    language_template = \\\"\\\"\\\"",
            "    You are a helpful assistant.",
            "    Given these documents, answer the question.",
            "    Documents:",
            "    {% for doc in documents %}",
            "        Document {{ loop.index }}:",
            "        Document name: {{ doc.meta['name'] }}",
            "        {{ doc.content }}",
            "    {% endfor %}",
            "",
            "    Question: {{ query }}",
            "    Please provide your answer in {{ answer_language | default('English') }}",
            "    Answer:",
            "    \\\"\\\"\\\"",
            "    p.run({",
            "        \"prompt_builder\": {",
            "            \"documents\": documents,",
            "            \"query\": question,",
            "            \"template\": language_template,",
            "            \"template_variables\": {\"answer_language\": \"German\"},",
            "        },",
            "    })",
            "    ```",
            "    Note that `language_template` introduces variable `answer_language` which is not bound to any pipeline variable.",
            "    If not set otherwise, it will use its default value 'English'.",
            "    This example overwrites its value to 'German'.",
            "    Use `template_variables` to overwrite pipeline variables (such as documents) as well.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self, template: str, required_variables: Optional[List[str]] = None, variables: Optional[List[str]] = None",
            "    ):",
            "        \"\"\"",
            "        Constructs a PromptBuilder component.",
            "",
            "        :param template:",
            "            A prompt template that uses Jinja2 syntax to add variables. For example:",
            "            `\"Summarize this document: {{ documents[0].content }}\\\\nSummary:\"`",
            "            It's used to render the prompt.",
            "            The variables in the default template are input for PromptBuilder and are all optional,",
            "            unless explicitly specified.",
            "            If an optional variable is not provided, it's replaced with an empty string in the rendered prompt.",
            "        :param required_variables: List variables that must be provided as input to PromptBuilder.",
            "            If a variable listed as required is not provided, an exception is raised. Optional.",
            "        :param variables:",
            "            List input variables to use in prompt templates instead of the ones inferred from the",
            "            `template` parameter. For example, to use more variables during prompt engineering than the ones present",
            "            in the default template, you can provide them here.",
            "        \"\"\"",
            "        self._template_string = template",
            "        self._variables = variables",
            "        self._required_variables = required_variables",
            "        self.required_variables = required_variables or []",
            "        self.template = Template(template)",
            "        if not variables:",
            "            # infere variables from template",
            "            ast = self.template.environment.parse(template)",
            "            template_variables = meta.find_undeclared_variables(ast)",
            "            variables = list(template_variables)",
            "",
            "        variables = variables or []",
            "",
            "        # setup inputs",
            "        static_input_slots = {\"template\": Optional[str], \"template_variables\": Optional[Dict[str, Any]]}",
            "        component.set_input_types(self, **static_input_slots)",
            "        for var in variables:",
            "            if var in self.required_variables:",
            "                component.set_input_type(self, var, Any)",
            "            else:",
            "                component.set_input_type(self, var, Any, \"\")",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Returns a dictionary representation of the component.",
            "",
            "        :returns:",
            "            Serialized dictionary representation of the component.",
            "        \"\"\"",
            "        return default_to_dict(",
            "            self, template=self._template_string, variables=self._variables, required_variables=self._required_variables",
            "        )",
            "",
            "    @component.output_types(prompt=str)",
            "    def run(self, template: Optional[str] = None, template_variables: Optional[Dict[str, Any]] = None, **kwargs):",
            "        \"\"\"",
            "        Renders the prompt template with the provided variables.",
            "",
            "        It applies the template variables to render the final prompt. You can provide variables via pipeline kwargs.",
            "        In order to overwrite the default template, you can set the `template` parameter.",
            "        In order to overwrite pipeline kwargs, you can set the `template_variables` parameter.",
            "",
            "        :param template:",
            "            An optional string template to overwrite PromptBuilder's default template. If None, the default template",
            "            provided at initialization is used.",
            "        :param template_variables:",
            "            An optional dictionary of template variables to overwrite the pipeline variables.",
            "        :param kwargs:",
            "            Pipeline variables used for rendering the prompt.",
            "",
            "        :returns: A dictionary with the following keys:",
            "            - `prompt`: The updated prompt text after rendering the prompt template.",
            "",
            "        :raises ValueError:",
            "            If any of the required template variables is not provided.",
            "        \"\"\"",
            "        kwargs = kwargs or {}",
            "        template_variables = template_variables or {}",
            "        template_variables_combined = {**kwargs, **template_variables}",
            "        self._validate_variables(set(template_variables_combined.keys()))",
            "",
            "        compiled_template = self.template",
            "        if isinstance(template, str):",
            "            compiled_template = Template(template)",
            "",
            "        result = compiled_template.render(template_variables_combined)",
            "        return {\"prompt\": result}",
            "",
            "    def _validate_variables(self, provided_variables: Set[str]):",
            "        \"\"\"",
            "        Checks if all the required template variables are provided.",
            "",
            "        :param provided_variables:",
            "            A set of provided template variables.",
            "        :raises ValueError:",
            "            If any of the required template variables is not provided.",
            "        \"\"\"",
            "        missing_variables = [var for var in self.required_variables if var not in provided_variables]",
            "        if missing_variables:",
            "            missing_vars_str = \", \".join(missing_variables)",
            "            raise ValueError(",
            "                f\"Missing required input variables in PromptBuilder: {missing_vars_str}. \"",
            "                f\"Required variables: {self.required_variables}. Provided variables: {provided_variables}.\"",
            "            )"
        ],
        "afterPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "from typing import Any, Dict, List, Optional, Set",
            "",
            "from jinja2 import meta",
            "from jinja2.sandbox import SandboxedEnvironment",
            "",
            "from haystack import component, default_to_dict",
            "",
            "",
            "@component",
            "class PromptBuilder:",
            "    \"\"\"",
            "",
            "    Renders a prompt filling in any variables so that it can send it to a Generator.",
            "",
            "    The prompt uses Jinja2 template syntax.",
            "    The variables in the default template are used as PromptBuilder's input and are all optional.",
            "    If they're not provided, they're replaced with an empty string in the rendered prompt.",
            "    To try out different prompts, you can replace the prompt template at runtime by",
            "    providing a template for each pipeline run invocation.",
            "",
            "    ### Usage examples",
            "",
            "    #### On its own",
            "",
            "    This example uses PromptBuilder to render a prompt template and fill it with `target_language`",
            "    and `snippet`. PromptBuilder returns a prompt with the string \"Translate the following context to Spanish.",
            "    Context: I can't speak Spanish.; Translation:\".",
            "    ```python",
            "    from haystack.components.builders import PromptBuilder",
            "",
            "    template = \"Translate the following context to {{ target_language }}. Context: {{ snippet }}; Translation:\"",
            "    builder = PromptBuilder(template=template)",
            "    builder.run(target_language=\"spanish\", snippet=\"I can't speak spanish.\")",
            "    ```",
            "",
            "    #### In a Pipeline",
            "",
            "    This is an example of a RAG pipeline where PromptBuilder renders a custom prompt template and fills it",
            "    with the contents of the retrieved documents and a query. The rendered prompt is then sent to a Generator.",
            "    ```python",
            "    from haystack import Pipeline, Document",
            "    from haystack.utils import Secret",
            "    from haystack.components.generators import OpenAIGenerator",
            "    from haystack.components.builders.prompt_builder import PromptBuilder",
            "",
            "    # in a real world use case documents could come from a retriever, web, or any other source",
            "    documents = [Document(content=\"Joe lives in Berlin\"), Document(content=\"Joe is a software engineer\")]",
            "    prompt_template = \\\"\\\"\\\"",
            "        Given these documents, answer the question.",
            "        Documents:",
            "        {% for doc in documents %}",
            "            {{ doc.content }}",
            "        {% endfor %}",
            "",
            "        Question: {{query}}",
            "        Answer:",
            "        \\\"\\\"\\\"",
            "    p = Pipeline()",
            "    p.add_component(instance=PromptBuilder(template=prompt_template), name=\"prompt_builder\")",
            "    p.add_component(instance=OpenAIGenerator(api_key=Secret.from_env_var(\"OPENAI_API_KEY\")), name=\"llm\")",
            "    p.connect(\"prompt_builder\", \"llm\")",
            "",
            "    question = \"Where does Joe live?\"",
            "    result = p.run({\"prompt_builder\": {\"documents\": documents, \"query\": question}})",
            "    print(result)",
            "    ```",
            "",
            "    #### Changing the template at runtime (prompt engineering)",
            "",
            "    You can change the prompt template of an existing pipeline, like in this example:",
            "    ```python",
            "    documents = [",
            "        Document(content=\"Joe lives in Berlin\", meta={\"name\": \"doc1\"}),",
            "        Document(content=\"Joe is a software engineer\", meta={\"name\": \"doc1\"}),",
            "    ]",
            "    new_template = \\\"\\\"\\\"",
            "        You are a helpful assistant.",
            "        Given these documents, answer the question.",
            "        Documents:",
            "        {% for doc in documents %}",
            "            Document {{ loop.index }}:",
            "            Document name: {{ doc.meta['name'] }}",
            "            {{ doc.content }}",
            "        {% endfor %}",
            "",
            "        Question: {{ query }}",
            "        Answer:",
            "        \\\"\\\"\\\"",
            "    p.run({",
            "        \"prompt_builder\": {",
            "            \"documents\": documents,",
            "            \"query\": question,",
            "            \"template\": new_template,",
            "        },",
            "    })",
            "    ```",
            "    To replace the variables in the default template when testing your prompt,",
            "    pass the new variables in the `variables` parameter.",
            "",
            "    #### Overwriting variables at runtime",
            "",
            "    To overwrite the values of variables, use `template_variables` during runtime:",
            "    ```python",
            "    language_template = \\\"\\\"\\\"",
            "    You are a helpful assistant.",
            "    Given these documents, answer the question.",
            "    Documents:",
            "    {% for doc in documents %}",
            "        Document {{ loop.index }}:",
            "        Document name: {{ doc.meta['name'] }}",
            "        {{ doc.content }}",
            "    {% endfor %}",
            "",
            "    Question: {{ query }}",
            "    Please provide your answer in {{ answer_language | default('English') }}",
            "    Answer:",
            "    \\\"\\\"\\\"",
            "    p.run({",
            "        \"prompt_builder\": {",
            "            \"documents\": documents,",
            "            \"query\": question,",
            "            \"template\": language_template,",
            "            \"template_variables\": {\"answer_language\": \"German\"},",
            "        },",
            "    })",
            "    ```",
            "    Note that `language_template` introduces variable `answer_language` which is not bound to any pipeline variable.",
            "    If not set otherwise, it will use its default value 'English'.",
            "    This example overwrites its value to 'German'.",
            "    Use `template_variables` to overwrite pipeline variables (such as documents) as well.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self, template: str, required_variables: Optional[List[str]] = None, variables: Optional[List[str]] = None",
            "    ):",
            "        \"\"\"",
            "        Constructs a PromptBuilder component.",
            "",
            "        :param template:",
            "            A prompt template that uses Jinja2 syntax to add variables. For example:",
            "            `\"Summarize this document: {{ documents[0].content }}\\\\nSummary:\"`",
            "            It's used to render the prompt.",
            "            The variables in the default template are input for PromptBuilder and are all optional,",
            "            unless explicitly specified.",
            "            If an optional variable is not provided, it's replaced with an empty string in the rendered prompt.",
            "        :param required_variables: List variables that must be provided as input to PromptBuilder.",
            "            If a variable listed as required is not provided, an exception is raised. Optional.",
            "        :param variables:",
            "            List input variables to use in prompt templates instead of the ones inferred from the",
            "            `template` parameter. For example, to use more variables during prompt engineering than the ones present",
            "            in the default template, you can provide them here.",
            "        \"\"\"",
            "        self._template_string = template",
            "        self._variables = variables",
            "        self._required_variables = required_variables",
            "        self.required_variables = required_variables or []",
            "",
            "        self._env = SandboxedEnvironment()",
            "        self.template = self._env.from_string(template)",
            "        if not variables:",
            "            # infere variables from template",
            "            ast = self._env.parse(template)",
            "            template_variables = meta.find_undeclared_variables(ast)",
            "            variables = list(template_variables)",
            "",
            "        variables = variables or []",
            "",
            "        # setup inputs",
            "        static_input_slots = {\"template\": Optional[str], \"template_variables\": Optional[Dict[str, Any]]}",
            "        component.set_input_types(self, **static_input_slots)",
            "        for var in variables:",
            "            if var in self.required_variables:",
            "                component.set_input_type(self, var, Any)",
            "            else:",
            "                component.set_input_type(self, var, Any, \"\")",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Returns a dictionary representation of the component.",
            "",
            "        :returns:",
            "            Serialized dictionary representation of the component.",
            "        \"\"\"",
            "        return default_to_dict(",
            "            self, template=self._template_string, variables=self._variables, required_variables=self._required_variables",
            "        )",
            "",
            "    @component.output_types(prompt=str)",
            "    def run(self, template: Optional[str] = None, template_variables: Optional[Dict[str, Any]] = None, **kwargs):",
            "        \"\"\"",
            "        Renders the prompt template with the provided variables.",
            "",
            "        It applies the template variables to render the final prompt. You can provide variables via pipeline kwargs.",
            "        In order to overwrite the default template, you can set the `template` parameter.",
            "        In order to overwrite pipeline kwargs, you can set the `template_variables` parameter.",
            "",
            "        :param template:",
            "            An optional string template to overwrite PromptBuilder's default template. If None, the default template",
            "            provided at initialization is used.",
            "        :param template_variables:",
            "            An optional dictionary of template variables to overwrite the pipeline variables.",
            "        :param kwargs:",
            "            Pipeline variables used for rendering the prompt.",
            "",
            "        :returns: A dictionary with the following keys:",
            "            - `prompt`: The updated prompt text after rendering the prompt template.",
            "",
            "        :raises ValueError:",
            "            If any of the required template variables is not provided.",
            "        \"\"\"",
            "        kwargs = kwargs or {}",
            "        template_variables = template_variables or {}",
            "        template_variables_combined = {**kwargs, **template_variables}",
            "        self._validate_variables(set(template_variables_combined.keys()))",
            "",
            "        compiled_template = self.template",
            "        if template is not None:",
            "            compiled_template = self._env.from_string(template)",
            "",
            "        result = compiled_template.render(template_variables_combined)",
            "        return {\"prompt\": result}",
            "",
            "    def _validate_variables(self, provided_variables: Set[str]):",
            "        \"\"\"",
            "        Checks if all the required template variables are provided.",
            "",
            "        :param provided_variables:",
            "            A set of provided template variables.",
            "        :raises ValueError:",
            "            If any of the required template variables is not provided.",
            "        \"\"\"",
            "        missing_variables = [var for var in self.required_variables if var not in provided_variables]",
            "        if missing_variables:",
            "            missing_vars_str = \", \".join(missing_variables)",
            "            raise ValueError(",
            "                f\"Missing required input variables in PromptBuilder: {missing_vars_str}. \"",
            "                f\"Required variables: {self.required_variables}. Provided variables: {provided_variables}.\"",
            "            )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": [],
            "161": [
                "PromptBuilder",
                "__init__"
            ],
            "164": [
                "PromptBuilder",
                "__init__"
            ],
            "219": [
                "PromptBuilder",
                "run"
            ],
            "220": [
                "PromptBuilder",
                "run"
            ]
        },
        "addLocation": []
    },
    "haystack/components/converters/output_adapter.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " #"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # SPDX-License-Identifier: Apache-2.0"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+import ast"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+import contextlib"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from typing import Any, Callable, Dict, Optional, Set"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import jinja2.runtime"
            },
            "8": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from jinja2 import TemplateSyntaxError, meta"
            },
            "9": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from jinja2.nativetypes import NativeEnvironment"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from jinja2.sandbox import SandboxedEnvironment"
            },
            "11": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from typing_extensions import TypeAlias"
            },
            "12": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from haystack import component, default_from_dict, default_to_dict"
            },
            "14": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         # Create a Jinja native environment, we need it to:"
            },
            "16": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         # a) add custom filters to the environment for filter compilation stage"
            },
            "17": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        env = NativeEnvironment()"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        self._env = SandboxedEnvironment(undefined=jinja2.runtime.StrictUndefined)"
            },
            "19": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         try:"
            },
            "20": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            env.parse(template)  # Validate template syntax"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            self._env.parse(template)  # Validate template syntax"
            },
            "22": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "             self.template = template"
            },
            "23": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         except TemplateSyntaxError as e:"
            },
            "24": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "             raise ValueError(f\"Invalid Jinja template '{template}': {e}\") from e"
            },
            "25": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         for name, filter_func in self.custom_filters.items():"
            },
            "27": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            env.filters[name] = filter_func"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            self._env.filters[name] = filter_func"
            },
            "29": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         # b) extract variables in the template"
            },
            "31": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        route_input_names = self._extract_variables(env)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        route_input_names = self._extract_variables(self._env)"
            },
            "33": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         input_types.update(route_input_names)"
            },
            "34": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         # the env is not needed, discarded automatically"
            },
            "36": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         # check if kwargs are empty"
            },
            "37": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         if not kwargs:"
            },
            "38": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "             raise ValueError(\"No input data provided for output adaptation\")"
            },
            "39": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        env = NativeEnvironment()"
            },
            "40": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         for name, filter_func in self.custom_filters.items():"
            },
            "41": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            env.filters[name] = filter_func"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            self._env.filters[name] = filter_func"
            },
            "43": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         adapted_outputs = {}"
            },
            "44": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         try:"
            },
            "45": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            adapted_output_template = env.from_string(self.template)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            adapted_output_template = self._env.from_string(self.template)"
            },
            "47": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "             output_result = adapted_output_template.render(**kwargs)"
            },
            "48": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "             if isinstance(output_result, jinja2.runtime.Undefined):"
            },
            "49": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "                 raise OutputAdaptationException(f\"Undefined variable in the template {self.template}; kwargs: {kwargs}\")"
            },
            "50": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+            # We suppress the exception in case the output is already a string, otherwise"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            # we try to evaluate it and would fail."
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+            # This must be done cause the output could be different literal structures."
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            # This doesn't support any user types."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+            with contextlib.suppress(Exception):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+                output_result = ast.literal_eval(output_result)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "             adapted_outputs[\"output\"] = output_result"
            },
            "59": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         except Exception as e:"
            },
            "60": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "             raise OutputAdaptationException(f\"Error adapting {self.template} with {kwargs}: {e}\") from e"
            },
            "61": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             init_params[\"custom_filters\"][name] = deserialize_callable(filter_func) if filter_func else None"
            },
            "62": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         return default_from_dict(cls, data)"
            },
            "63": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _extract_variables(self, env: NativeEnvironment) -> Set[str]:"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    def _extract_variables(self, env: SandboxedEnvironment) -> Set[str]:"
            },
            "66": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         \"\"\""
            },
            "67": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         Extracts all variables from a list of Jinja template strings."
            },
            "68": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         :param env: A Jinja native environment."
            },
            "70": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         :return: A set of variable names extracted from the template strings."
            },
            "71": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         \"\"\""
            },
            "72": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        variables = set()"
            },
            "73": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         ast = env.parse(self.template)"
            },
            "74": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        variables.update(meta.find_undeclared_variables(ast))"
            },
            "75": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return variables"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        return meta.find_undeclared_variables(ast)"
            }
        },
        "frontPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "from typing import Any, Callable, Dict, Optional, Set",
            "",
            "import jinja2.runtime",
            "from jinja2 import TemplateSyntaxError, meta",
            "from jinja2.nativetypes import NativeEnvironment",
            "from typing_extensions import TypeAlias",
            "",
            "from haystack import component, default_from_dict, default_to_dict",
            "from haystack.utils import deserialize_callable, deserialize_type, serialize_callable, serialize_type",
            "",
            "",
            "class OutputAdaptationException(Exception):",
            "    \"\"\"Exception raised when there is an error during output adaptation.\"\"\"",
            "",
            "",
            "@component",
            "class OutputAdapter:",
            "    \"\"\"",
            "    Adapts output of a Component using Jinja templates.",
            "",
            "    Usage example:",
            "    ```python",
            "    from haystack import Document",
            "    from haystack.components.converters import OutputAdapter",
            "",
            "    adapter = OutputAdapter(template=\"{{ documents[0].content }}\", output_type=str)",
            "    documents = [Document(content=\"Test content\"]",
            "    result = adapter.run(documents=documents)",
            "",
            "    assert result[\"output\"] == \"Test content\"",
            "    ```",
            "    \"\"\"",
            "",
            "    def __init__(self, template: str, output_type: TypeAlias, custom_filters: Optional[Dict[str, Callable]] = None):",
            "        \"\"\"",
            "        Create an OutputAdapter component.",
            "",
            "        :param template:",
            "            A Jinja template that defines how to adapt the input data.",
            "            The variables in the template define the input of this instance.",
            "            e.g.",
            "            With this template:",
            "            ```",
            "            {{ documents[0].content }}",
            "            ```",
            "            The Component input will be `documents`.",
            "        :param output_type:",
            "            The type of output this instance will return.",
            "        :param custom_filters:",
            "            A dictionary of custom Jinja filters used in the template.",
            "        \"\"\"",
            "        self.custom_filters = {**(custom_filters or {})}",
            "        input_types: Set[str] = set()",
            "",
            "        # Create a Jinja native environment, we need it to:",
            "        # a) add custom filters to the environment for filter compilation stage",
            "        env = NativeEnvironment()",
            "        try:",
            "            env.parse(template)  # Validate template syntax",
            "            self.template = template",
            "        except TemplateSyntaxError as e:",
            "            raise ValueError(f\"Invalid Jinja template '{template}': {e}\") from e",
            "",
            "        for name, filter_func in self.custom_filters.items():",
            "            env.filters[name] = filter_func",
            "",
            "        # b) extract variables in the template",
            "        route_input_names = self._extract_variables(env)",
            "        input_types.update(route_input_names)",
            "",
            "        # the env is not needed, discarded automatically",
            "        component.set_input_types(self, **{var: Any for var in input_types})",
            "        component.set_output_types(self, **{\"output\": output_type})",
            "        self.output_type = output_type",
            "",
            "    def run(self, **kwargs):",
            "        \"\"\"",
            "        Renders the Jinja template with the provided inputs.",
            "",
            "        :param kwargs:",
            "            Must contain all variables used in the `template` string.",
            "        :returns:",
            "            A dictionary with the following keys:",
            "            - `output`: Rendered Jinja template.",
            "",
            "        :raises OutputAdaptationException: If template rendering fails.",
            "        \"\"\"",
            "        # check if kwargs are empty",
            "        if not kwargs:",
            "            raise ValueError(\"No input data provided for output adaptation\")",
            "        env = NativeEnvironment()",
            "        for name, filter_func in self.custom_filters.items():",
            "            env.filters[name] = filter_func",
            "        adapted_outputs = {}",
            "        try:",
            "            adapted_output_template = env.from_string(self.template)",
            "            output_result = adapted_output_template.render(**kwargs)",
            "            if isinstance(output_result, jinja2.runtime.Undefined):",
            "                raise OutputAdaptationException(f\"Undefined variable in the template {self.template}; kwargs: {kwargs}\")",
            "",
            "            adapted_outputs[\"output\"] = output_result",
            "        except Exception as e:",
            "            raise OutputAdaptationException(f\"Error adapting {self.template} with {kwargs}: {e}\") from e",
            "        return adapted_outputs",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Serializes the component to a dictionary.",
            "",
            "        :returns:",
            "            Dictionary with serialized data.",
            "        \"\"\"",
            "        se_filters = {name: serialize_callable(filter_func) for name, filter_func in self.custom_filters.items()}",
            "        return default_to_dict(",
            "            self, template=self.template, output_type=serialize_type(self.output_type), custom_filters=se_filters",
            "        )",
            "",
            "    @classmethod",
            "    def from_dict(cls, data: Dict[str, Any]) -> \"OutputAdapter\":",
            "        \"\"\"",
            "        Deserializes the component from a dictionary.",
            "",
            "        :param data:",
            "            The dictionary to deserialize from.",
            "        :returns:",
            "            The deserialized component.",
            "        \"\"\"",
            "        init_params = data.get(\"init_parameters\", {})",
            "        init_params[\"output_type\"] = deserialize_type(init_params[\"output_type\"])",
            "        for name, filter_func in init_params.get(\"custom_filters\", {}).items():",
            "            init_params[\"custom_filters\"][name] = deserialize_callable(filter_func) if filter_func else None",
            "        return default_from_dict(cls, data)",
            "",
            "    def _extract_variables(self, env: NativeEnvironment) -> Set[str]:",
            "        \"\"\"",
            "        Extracts all variables from a list of Jinja template strings.",
            "",
            "        :param env: A Jinja native environment.",
            "        :return: A set of variable names extracted from the template strings.",
            "        \"\"\"",
            "        variables = set()",
            "        ast = env.parse(self.template)",
            "        variables.update(meta.find_undeclared_variables(ast))",
            "        return variables"
        ],
        "afterPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "import ast",
            "import contextlib",
            "from typing import Any, Callable, Dict, Optional, Set",
            "",
            "import jinja2.runtime",
            "from jinja2 import TemplateSyntaxError, meta",
            "from jinja2.sandbox import SandboxedEnvironment",
            "from typing_extensions import TypeAlias",
            "",
            "from haystack import component, default_from_dict, default_to_dict",
            "from haystack.utils import deserialize_callable, deserialize_type, serialize_callable, serialize_type",
            "",
            "",
            "class OutputAdaptationException(Exception):",
            "    \"\"\"Exception raised when there is an error during output adaptation.\"\"\"",
            "",
            "",
            "@component",
            "class OutputAdapter:",
            "    \"\"\"",
            "    Adapts output of a Component using Jinja templates.",
            "",
            "    Usage example:",
            "    ```python",
            "    from haystack import Document",
            "    from haystack.components.converters import OutputAdapter",
            "",
            "    adapter = OutputAdapter(template=\"{{ documents[0].content }}\", output_type=str)",
            "    documents = [Document(content=\"Test content\"]",
            "    result = adapter.run(documents=documents)",
            "",
            "    assert result[\"output\"] == \"Test content\"",
            "    ```",
            "    \"\"\"",
            "",
            "    def __init__(self, template: str, output_type: TypeAlias, custom_filters: Optional[Dict[str, Callable]] = None):",
            "        \"\"\"",
            "        Create an OutputAdapter component.",
            "",
            "        :param template:",
            "            A Jinja template that defines how to adapt the input data.",
            "            The variables in the template define the input of this instance.",
            "            e.g.",
            "            With this template:",
            "            ```",
            "            {{ documents[0].content }}",
            "            ```",
            "            The Component input will be `documents`.",
            "        :param output_type:",
            "            The type of output this instance will return.",
            "        :param custom_filters:",
            "            A dictionary of custom Jinja filters used in the template.",
            "        \"\"\"",
            "        self.custom_filters = {**(custom_filters or {})}",
            "        input_types: Set[str] = set()",
            "",
            "        # Create a Jinja native environment, we need it to:",
            "        # a) add custom filters to the environment for filter compilation stage",
            "        self._env = SandboxedEnvironment(undefined=jinja2.runtime.StrictUndefined)",
            "        try:",
            "            self._env.parse(template)  # Validate template syntax",
            "            self.template = template",
            "        except TemplateSyntaxError as e:",
            "            raise ValueError(f\"Invalid Jinja template '{template}': {e}\") from e",
            "",
            "        for name, filter_func in self.custom_filters.items():",
            "            self._env.filters[name] = filter_func",
            "",
            "        # b) extract variables in the template",
            "        route_input_names = self._extract_variables(self._env)",
            "        input_types.update(route_input_names)",
            "",
            "        # the env is not needed, discarded automatically",
            "        component.set_input_types(self, **{var: Any for var in input_types})",
            "        component.set_output_types(self, **{\"output\": output_type})",
            "        self.output_type = output_type",
            "",
            "    def run(self, **kwargs):",
            "        \"\"\"",
            "        Renders the Jinja template with the provided inputs.",
            "",
            "        :param kwargs:",
            "            Must contain all variables used in the `template` string.",
            "        :returns:",
            "            A dictionary with the following keys:",
            "            - `output`: Rendered Jinja template.",
            "",
            "        :raises OutputAdaptationException: If template rendering fails.",
            "        \"\"\"",
            "        # check if kwargs are empty",
            "        if not kwargs:",
            "            raise ValueError(\"No input data provided for output adaptation\")",
            "        for name, filter_func in self.custom_filters.items():",
            "            self._env.filters[name] = filter_func",
            "        adapted_outputs = {}",
            "        try:",
            "            adapted_output_template = self._env.from_string(self.template)",
            "            output_result = adapted_output_template.render(**kwargs)",
            "            if isinstance(output_result, jinja2.runtime.Undefined):",
            "                raise OutputAdaptationException(f\"Undefined variable in the template {self.template}; kwargs: {kwargs}\")",
            "",
            "            # We suppress the exception in case the output is already a string, otherwise",
            "            # we try to evaluate it and would fail.",
            "            # This must be done cause the output could be different literal structures.",
            "            # This doesn't support any user types.",
            "            with contextlib.suppress(Exception):",
            "                output_result = ast.literal_eval(output_result)",
            "",
            "            adapted_outputs[\"output\"] = output_result",
            "        except Exception as e:",
            "            raise OutputAdaptationException(f\"Error adapting {self.template} with {kwargs}: {e}\") from e",
            "        return adapted_outputs",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Serializes the component to a dictionary.",
            "",
            "        :returns:",
            "            Dictionary with serialized data.",
            "        \"\"\"",
            "        se_filters = {name: serialize_callable(filter_func) for name, filter_func in self.custom_filters.items()}",
            "        return default_to_dict(",
            "            self, template=self.template, output_type=serialize_type(self.output_type), custom_filters=se_filters",
            "        )",
            "",
            "    @classmethod",
            "    def from_dict(cls, data: Dict[str, Any]) -> \"OutputAdapter\":",
            "        \"\"\"",
            "        Deserializes the component from a dictionary.",
            "",
            "        :param data:",
            "            The dictionary to deserialize from.",
            "        :returns:",
            "            The deserialized component.",
            "        \"\"\"",
            "        init_params = data.get(\"init_parameters\", {})",
            "        init_params[\"output_type\"] = deserialize_type(init_params[\"output_type\"])",
            "        for name, filter_func in init_params.get(\"custom_filters\", {}).items():",
            "            init_params[\"custom_filters\"][name] = deserialize_callable(filter_func) if filter_func else None",
            "        return default_from_dict(cls, data)",
            "",
            "    def _extract_variables(self, env: SandboxedEnvironment) -> Set[str]:",
            "        \"\"\"",
            "        Extracts all variables from a list of Jinja template strings.",
            "",
            "        :param env: A Jinja native environment.",
            "        :return: A set of variable names extracted from the template strings.",
            "        \"\"\"",
            "        ast = env.parse(self.template)",
            "        return meta.find_undeclared_variables(ast)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "9": [],
            "61": [
                "OutputAdapter",
                "__init__"
            ],
            "63": [
                "OutputAdapter",
                "__init__"
            ],
            "69": [
                "OutputAdapter",
                "__init__"
            ],
            "72": [
                "OutputAdapter",
                "__init__"
            ],
            "95": [
                "OutputAdapter",
                "run"
            ],
            "97": [
                "OutputAdapter",
                "run"
            ],
            "100": [
                "OutputAdapter",
                "run"
            ],
            "138": [
                "OutputAdapter",
                "_extract_variables"
            ],
            "145": [
                "OutputAdapter",
                "_extract_variables"
            ],
            "147": [
                "OutputAdapter",
                "_extract_variables"
            ],
            "148": [
                "OutputAdapter",
                "_extract_variables"
            ]
        },
        "addLocation": []
    },
    "haystack/components/routers/conditional_router.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " #"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # SPDX-License-Identifier: Apache-2.0"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+import ast"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+import contextlib"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from typing import Any, Callable, Dict, List, Optional, Set"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from jinja2 import Environment, TemplateSyntaxError, meta"
            },
            "8": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from jinja2.nativetypes import NativeEnvironment"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from jinja2.sandbox import SandboxedEnvironment"
            },
            "10": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from haystack import component, default_from_dict, default_to_dict, logging"
            },
            "12": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from haystack.utils import deserialize_callable, deserialize_type, serialize_callable, serialize_type"
            },
            "13": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         self.custom_filters = custom_filters or {}"
            },
            "14": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         # Create a Jinja native environment to inspect variables in the condition templates"
            },
            "16": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        env = NativeEnvironment()"
            },
            "17": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        env.filters.update(self.custom_filters)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        self._env = SandboxedEnvironment()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        self._env.filters.update(self.custom_filters)"
            },
            "20": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         # Inspect the routes to determine input and output types."
            },
            "22": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         input_types: Set[str] = set()  # let's just store the name, type will always be Any"
            },
            "23": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         output_types: Dict[str, str] = {}"
            },
            "24": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         for route in routes:"
            },
            "26": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "             # extract inputs"
            },
            "27": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            route_input_names = self._extract_variables(env, [route[\"output\"], route[\"condition\"]])"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+            route_input_names = self._extract_variables(self._env, [route[\"output\"], route[\"condition\"]])"
            },
            "29": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "             input_types.update(route_input_names)"
            },
            "30": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             # extract outputs"
            },
            "32": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "             routes."
            },
            "33": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         \"\"\""
            },
            "34": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "         # Create a Jinja native environment to evaluate the condition templates as Python expressions"
            },
            "35": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        env = NativeEnvironment()"
            },
            "36": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        env.filters.update(self.custom_filters)"
            },
            "37": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "38": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         for route in self.routes:"
            },
            "39": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "             try:"
            },
            "40": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                t = env.from_string(route[\"condition\"])"
            },
            "41": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if t.render(**kwargs):"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+                t = self._env.from_string(route[\"condition\"])"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+                rendered = t.render(**kwargs)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+                if ast.literal_eval(rendered):"
            },
            "45": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "                     # We now evaluate the `output` expression to determine the route output"
            },
            "46": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    t_output = env.from_string(route[\"output\"])"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+                    t_output = self._env.from_string(route[\"output\"])"
            },
            "48": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "                     output = t_output.render(**kwargs)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+                    # We suppress the exception in case the output is already a string, otherwise"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                    # we try to evaluate it and would fail."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                    # This must be done cause the output could be different literal structures."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                    # This doesn't support any user types."
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                    with contextlib.suppress(Exception):"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                        output = ast.literal_eval(output)"
            },
            "55": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "                     # and return the output as a dictionary under the output_name key"
            },
            "56": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "                     return {route[\"output_name\"]: output}"
            },
            "57": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "             except Exception as e:"
            },
            "58": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "                 if not self._validate_template(env, route[field]):"
            },
            "59": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "                     raise ValueError(f\"Invalid template for field '{field}': {route[field]}\")"
            },
            "60": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _extract_variables(self, env: NativeEnvironment, templates: List[str]) -> Set[str]:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+    def _extract_variables(self, env: SandboxedEnvironment, templates: List[str]) -> Set[str]:"
            },
            "63": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         \"\"\""
            },
            "64": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "         Extracts all variables from a list of Jinja template strings."
            },
            "65": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 247,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "from typing import Any, Callable, Dict, List, Optional, Set",
            "",
            "from jinja2 import Environment, TemplateSyntaxError, meta",
            "from jinja2.nativetypes import NativeEnvironment",
            "",
            "from haystack import component, default_from_dict, default_to_dict, logging",
            "from haystack.utils import deserialize_callable, deserialize_type, serialize_callable, serialize_type",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NoRouteSelectedException(Exception):",
            "    \"\"\"Exception raised when no route is selected in ConditionalRouter.\"\"\"",
            "",
            "",
            "class RouteConditionException(Exception):",
            "    \"\"\"Exception raised when there is an error parsing or evaluating the condition expression in ConditionalRouter.\"\"\"",
            "",
            "",
            "@component",
            "class ConditionalRouter:",
            "    \"\"\"",
            "    `ConditionalRouter` allows data routing based on specific conditions.",
            "",
            "    This is achieved by defining a list named `routes`. Each element in this list is a dictionary representing a",
            "    single route.",
            "    A route dictionary comprises four key elements:",
            "    - `condition`: A Jinja2 string expression that determines if the route is selected.",
            "    - `output`: A Jinja2 expression defining the route's output value.",
            "    - `output_type`: The type of the output data (e.g., `str`, `List[int]`).",
            "    - `output_name`: The name under which the `output` value of the route is published. This name is used to connect",
            "    the router to other components in the pipeline.",
            "",
            "    Usage example:",
            "    ```python",
            "    from typing import List",
            "    from haystack.components.routers import ConditionalRouter",
            "",
            "    routes = [",
            "        {",
            "            \"condition\": \"{{streams|length > 2}}\",",
            "            \"output\": \"{{streams}}\",",
            "            \"output_name\": \"enough_streams\",",
            "            \"output_type\": List[int],",
            "        },",
            "        {",
            "            \"condition\": \"{{streams|length <= 2}}\",",
            "            \"output\": \"{{streams}}\",",
            "            \"output_name\": \"insufficient_streams\",",
            "            \"output_type\": List[int],",
            "        },",
            "    ]",
            "    router = ConditionalRouter(routes)",
            "    # When 'streams' has more than 2 items, 'enough_streams' output will activate, emitting the list [1, 2, 3]",
            "    kwargs = {\"streams\": [1, 2, 3], \"query\": \"Haystack\"}",
            "    result = router.run(**kwargs)",
            "    assert result == {\"enough_streams\": [1, 2, 3]}",
            "    ```",
            "",
            "    In this example, we configure two routes. The first route sends the 'streams' value to 'enough_streams' if the",
            "    stream count exceeds two. Conversely, the second route directs 'streams' to 'insufficient_streams' when there",
            "    are two or fewer streams.",
            "",
            "    In the pipeline setup, the router is connected to other components using the output names. For example, the",
            "    'enough_streams' output might be connected to another component that processes the streams, while the",
            "    'insufficient_streams' output might be connected to a component that fetches more streams, and so on.",
            "",
            "",
            "    Here is a pseudocode example of a pipeline that uses the `ConditionalRouter` and routes fetched `ByteStreams` to",
            "    different components depending on the number of streams fetched:",
            "    ```python",
            "    from typing import List",
            "    from haystack import Pipeline",
            "    from haystack.dataclasses import ByteStream",
            "    from haystack.components.routers import ConditionalRouter",
            "",
            "    routes = [",
            "        {",
            "            \"condition\": \"{{streams|length > 2}}\",",
            "            \"output\": \"{{streams}}\",",
            "            \"output_name\": \"enough_streams\",",
            "            \"output_type\": List[ByteStream],",
            "        },",
            "        {",
            "            \"condition\": \"{{streams|length <= 2}}\",",
            "            \"output\": \"{{streams}}\",",
            "            \"output_name\": \"insufficient_streams\",",
            "            \"output_type\": List[ByteStream],",
            "        },",
            "    ]",
            "",
            "    pipe = Pipeline()",
            "    pipe.add_component(\"router\", router)",
            "    ...",
            "    pipe.connect(\"router.enough_streams\", \"some_component_a.streams\")",
            "    pipe.connect(\"router.insufficient_streams\", \"some_component_b.streams_or_some_other_input\")",
            "    ...",
            "    ```",
            "    \"\"\"",
            "",
            "    def __init__(self, routes: List[Dict], custom_filters: Optional[Dict[str, Callable]] = None):",
            "        \"\"\"",
            "        Initializes the `ConditionalRouter` with a list of routes detailing the conditions for routing.",
            "",
            "        :param routes: A list of dictionaries, each defining a route.",
            "            A route dictionary comprises four key elements:",
            "            - `condition`: A Jinja2 string expression that determines if the route is selected.",
            "            - `output`: A Jinja2 expression defining the route's output value.",
            "            - `output_type`: The type of the output data (e.g., str, List[int]).",
            "            - `output_name`: The name under which the `output` value of the route is published. This name is used to",
            "                connect the router to other components in the pipeline.",
            "        :param custom_filters: A dictionary of custom Jinja2 filters to be used in the condition expressions.",
            "            For example, passing `{\"my_filter\": my_filter_fcn}` where:",
            "            - `my_filter` is the name of the custom filter.",
            "            - `my_filter_fcn` is a callable that takes `my_var:str` and returns `my_var[:3]`.",
            "              `{{ my_var|my_filter }}` can then be used inside a route condition expression like so:",
            "                `\"condition\": \"{{ my_var|my_filter == 'foo' }}\"`.",
            "        \"\"\"",
            "        self._validate_routes(routes)",
            "        self.routes: List[dict] = routes",
            "        self.custom_filters = custom_filters or {}",
            "",
            "        # Create a Jinja native environment to inspect variables in the condition templates",
            "        env = NativeEnvironment()",
            "        env.filters.update(self.custom_filters)",
            "",
            "        # Inspect the routes to determine input and output types.",
            "        input_types: Set[str] = set()  # let's just store the name, type will always be Any",
            "        output_types: Dict[str, str] = {}",
            "",
            "        for route in routes:",
            "            # extract inputs",
            "            route_input_names = self._extract_variables(env, [route[\"output\"], route[\"condition\"]])",
            "            input_types.update(route_input_names)",
            "",
            "            # extract outputs",
            "            output_types.update({route[\"output_name\"]: route[\"output_type\"]})",
            "",
            "        component.set_input_types(self, **{var: Any for var in input_types})",
            "        component.set_output_types(self, **output_types)",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Serializes the component to a dictionary.",
            "",
            "        :returns:",
            "            Dictionary with serialized data.",
            "        \"\"\"",
            "        for route in self.routes:",
            "            # output_type needs to be serialized to a string",
            "            route[\"output_type\"] = serialize_type(route[\"output_type\"])",
            "        se_filters = {name: serialize_callable(filter_func) for name, filter_func in self.custom_filters.items()}",
            "        return default_to_dict(self, routes=self.routes, custom_filters=se_filters)",
            "",
            "    @classmethod",
            "    def from_dict(cls, data: Dict[str, Any]) -> \"ConditionalRouter\":",
            "        \"\"\"",
            "        Deserializes the component from a dictionary.",
            "",
            "        :param data:",
            "            The dictionary to deserialize from.",
            "        :returns:",
            "            The deserialized component.",
            "        \"\"\"",
            "        init_params = data.get(\"init_parameters\", {})",
            "        routes = init_params.get(\"routes\")",
            "        for route in routes:",
            "            # output_type needs to be deserialized from a string to a type",
            "            route[\"output_type\"] = deserialize_type(route[\"output_type\"])",
            "        for name, filter_func in init_params.get(\"custom_filters\", {}).items():",
            "            init_params[\"custom_filters\"][name] = deserialize_callable(filter_func) if filter_func else None",
            "        return default_from_dict(cls, data)",
            "",
            "    def run(self, **kwargs):",
            "        \"\"\"",
            "        Executes the routing logic.",
            "",
            "        Executes the routing logic by evaluating the specified boolean condition expressions for each route in the",
            "        order they are listed. The method directs the flow of data to the output specified in the first route whose",
            "        `condition` is True.",
            "",
            "        :param kwargs: All variables used in the `condition` expressed in the routes. When the component is used in a",
            "            pipeline, these variables are passed from the previous component's output.",
            "",
            "        :returns: A dictionary where the key is the `output_name` of the selected route and the value is the `output`",
            "            of the selected route.",
            "",
            "        :raises NoRouteSelectedException: If no `condition' in the routes is `True`.",
            "        :raises RouteConditionException: If there is an error parsing or evaluating the `condition` expression in the",
            "            routes.",
            "        \"\"\"",
            "        # Create a Jinja native environment to evaluate the condition templates as Python expressions",
            "        env = NativeEnvironment()",
            "        env.filters.update(self.custom_filters)",
            "",
            "        for route in self.routes:",
            "            try:",
            "                t = env.from_string(route[\"condition\"])",
            "                if t.render(**kwargs):",
            "                    # We now evaluate the `output` expression to determine the route output",
            "                    t_output = env.from_string(route[\"output\"])",
            "                    output = t_output.render(**kwargs)",
            "                    # and return the output as a dictionary under the output_name key",
            "                    return {route[\"output_name\"]: output}",
            "            except Exception as e:",
            "                raise RouteConditionException(f\"Error evaluating condition for route '{route}': {e}\") from e",
            "",
            "        raise NoRouteSelectedException(f\"No route fired. Routes: {self.routes}\")",
            "",
            "    def _validate_routes(self, routes: List[Dict]):",
            "        \"\"\"",
            "        Validates a list of routes.",
            "",
            "        :param routes: A list of routes.",
            "        \"\"\"",
            "        env = NativeEnvironment()",
            "        for route in routes:",
            "            try:",
            "                keys = set(route.keys())",
            "            except AttributeError:",
            "                raise ValueError(f\"Route must be a dictionary, got: {route}\")",
            "",
            "            mandatory_fields = {\"condition\", \"output\", \"output_type\", \"output_name\"}",
            "            has_all_mandatory_fields = mandatory_fields.issubset(keys)",
            "            if not has_all_mandatory_fields:",
            "                raise ValueError(",
            "                    f\"Route must contain 'condition', 'output', 'output_type' and 'output_name' fields: {route}\"",
            "                )",
            "            for field in [\"condition\", \"output\"]:",
            "                if not self._validate_template(env, route[field]):",
            "                    raise ValueError(f\"Invalid template for field '{field}': {route[field]}\")",
            "",
            "    def _extract_variables(self, env: NativeEnvironment, templates: List[str]) -> Set[str]:",
            "        \"\"\"",
            "        Extracts all variables from a list of Jinja template strings.",
            "",
            "        :param env: A Jinja environment.",
            "        :param templates: A list of Jinja template strings.",
            "        :returns: A set of variable names.",
            "        \"\"\"",
            "        variables = set()",
            "        for template in templates:",
            "            ast = env.parse(template)",
            "            variables.update(meta.find_undeclared_variables(ast))",
            "        return variables",
            "",
            "    def _validate_template(self, env: Environment, template_text: str):",
            "        \"\"\"",
            "        Validates a template string by parsing it with Jinja.",
            "",
            "        :param env: A Jinja environment.",
            "        :param template_text: A Jinja template string.",
            "        :returns: `True` if the template is valid, `False` otherwise.",
            "        \"\"\"",
            "        try:",
            "            env.parse(template_text)",
            "            return True",
            "        except TemplateSyntaxError:",
            "            return False"
        ],
        "afterPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "import ast",
            "import contextlib",
            "from typing import Any, Callable, Dict, List, Optional, Set",
            "",
            "from jinja2 import Environment, TemplateSyntaxError, meta",
            "from jinja2.nativetypes import NativeEnvironment",
            "from jinja2.sandbox import SandboxedEnvironment",
            "",
            "from haystack import component, default_from_dict, default_to_dict, logging",
            "from haystack.utils import deserialize_callable, deserialize_type, serialize_callable, serialize_type",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class NoRouteSelectedException(Exception):",
            "    \"\"\"Exception raised when no route is selected in ConditionalRouter.\"\"\"",
            "",
            "",
            "class RouteConditionException(Exception):",
            "    \"\"\"Exception raised when there is an error parsing or evaluating the condition expression in ConditionalRouter.\"\"\"",
            "",
            "",
            "@component",
            "class ConditionalRouter:",
            "    \"\"\"",
            "    `ConditionalRouter` allows data routing based on specific conditions.",
            "",
            "    This is achieved by defining a list named `routes`. Each element in this list is a dictionary representing a",
            "    single route.",
            "    A route dictionary comprises four key elements:",
            "    - `condition`: A Jinja2 string expression that determines if the route is selected.",
            "    - `output`: A Jinja2 expression defining the route's output value.",
            "    - `output_type`: The type of the output data (e.g., `str`, `List[int]`).",
            "    - `output_name`: The name under which the `output` value of the route is published. This name is used to connect",
            "    the router to other components in the pipeline.",
            "",
            "    Usage example:",
            "    ```python",
            "    from typing import List",
            "    from haystack.components.routers import ConditionalRouter",
            "",
            "    routes = [",
            "        {",
            "            \"condition\": \"{{streams|length > 2}}\",",
            "            \"output\": \"{{streams}}\",",
            "            \"output_name\": \"enough_streams\",",
            "            \"output_type\": List[int],",
            "        },",
            "        {",
            "            \"condition\": \"{{streams|length <= 2}}\",",
            "            \"output\": \"{{streams}}\",",
            "            \"output_name\": \"insufficient_streams\",",
            "            \"output_type\": List[int],",
            "        },",
            "    ]",
            "    router = ConditionalRouter(routes)",
            "    # When 'streams' has more than 2 items, 'enough_streams' output will activate, emitting the list [1, 2, 3]",
            "    kwargs = {\"streams\": [1, 2, 3], \"query\": \"Haystack\"}",
            "    result = router.run(**kwargs)",
            "    assert result == {\"enough_streams\": [1, 2, 3]}",
            "    ```",
            "",
            "    In this example, we configure two routes. The first route sends the 'streams' value to 'enough_streams' if the",
            "    stream count exceeds two. Conversely, the second route directs 'streams' to 'insufficient_streams' when there",
            "    are two or fewer streams.",
            "",
            "    In the pipeline setup, the router is connected to other components using the output names. For example, the",
            "    'enough_streams' output might be connected to another component that processes the streams, while the",
            "    'insufficient_streams' output might be connected to a component that fetches more streams, and so on.",
            "",
            "",
            "    Here is a pseudocode example of a pipeline that uses the `ConditionalRouter` and routes fetched `ByteStreams` to",
            "    different components depending on the number of streams fetched:",
            "    ```python",
            "    from typing import List",
            "    from haystack import Pipeline",
            "    from haystack.dataclasses import ByteStream",
            "    from haystack.components.routers import ConditionalRouter",
            "",
            "    routes = [",
            "        {",
            "            \"condition\": \"{{streams|length > 2}}\",",
            "            \"output\": \"{{streams}}\",",
            "            \"output_name\": \"enough_streams\",",
            "            \"output_type\": List[ByteStream],",
            "        },",
            "        {",
            "            \"condition\": \"{{streams|length <= 2}}\",",
            "            \"output\": \"{{streams}}\",",
            "            \"output_name\": \"insufficient_streams\",",
            "            \"output_type\": List[ByteStream],",
            "        },",
            "    ]",
            "",
            "    pipe = Pipeline()",
            "    pipe.add_component(\"router\", router)",
            "    ...",
            "    pipe.connect(\"router.enough_streams\", \"some_component_a.streams\")",
            "    pipe.connect(\"router.insufficient_streams\", \"some_component_b.streams_or_some_other_input\")",
            "    ...",
            "    ```",
            "    \"\"\"",
            "",
            "    def __init__(self, routes: List[Dict], custom_filters: Optional[Dict[str, Callable]] = None):",
            "        \"\"\"",
            "        Initializes the `ConditionalRouter` with a list of routes detailing the conditions for routing.",
            "",
            "        :param routes: A list of dictionaries, each defining a route.",
            "            A route dictionary comprises four key elements:",
            "            - `condition`: A Jinja2 string expression that determines if the route is selected.",
            "            - `output`: A Jinja2 expression defining the route's output value.",
            "            - `output_type`: The type of the output data (e.g., str, List[int]).",
            "            - `output_name`: The name under which the `output` value of the route is published. This name is used to",
            "                connect the router to other components in the pipeline.",
            "        :param custom_filters: A dictionary of custom Jinja2 filters to be used in the condition expressions.",
            "            For example, passing `{\"my_filter\": my_filter_fcn}` where:",
            "            - `my_filter` is the name of the custom filter.",
            "            - `my_filter_fcn` is a callable that takes `my_var:str` and returns `my_var[:3]`.",
            "              `{{ my_var|my_filter }}` can then be used inside a route condition expression like so:",
            "                `\"condition\": \"{{ my_var|my_filter == 'foo' }}\"`.",
            "        \"\"\"",
            "        self._validate_routes(routes)",
            "        self.routes: List[dict] = routes",
            "        self.custom_filters = custom_filters or {}",
            "",
            "        # Create a Jinja native environment to inspect variables in the condition templates",
            "        self._env = SandboxedEnvironment()",
            "        self._env.filters.update(self.custom_filters)",
            "",
            "        # Inspect the routes to determine input and output types.",
            "        input_types: Set[str] = set()  # let's just store the name, type will always be Any",
            "        output_types: Dict[str, str] = {}",
            "",
            "        for route in routes:",
            "            # extract inputs",
            "            route_input_names = self._extract_variables(self._env, [route[\"output\"], route[\"condition\"]])",
            "            input_types.update(route_input_names)",
            "",
            "            # extract outputs",
            "            output_types.update({route[\"output_name\"]: route[\"output_type\"]})",
            "",
            "        component.set_input_types(self, **{var: Any for var in input_types})",
            "        component.set_output_types(self, **output_types)",
            "",
            "    def to_dict(self) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Serializes the component to a dictionary.",
            "",
            "        :returns:",
            "            Dictionary with serialized data.",
            "        \"\"\"",
            "        for route in self.routes:",
            "            # output_type needs to be serialized to a string",
            "            route[\"output_type\"] = serialize_type(route[\"output_type\"])",
            "        se_filters = {name: serialize_callable(filter_func) for name, filter_func in self.custom_filters.items()}",
            "        return default_to_dict(self, routes=self.routes, custom_filters=se_filters)",
            "",
            "    @classmethod",
            "    def from_dict(cls, data: Dict[str, Any]) -> \"ConditionalRouter\":",
            "        \"\"\"",
            "        Deserializes the component from a dictionary.",
            "",
            "        :param data:",
            "            The dictionary to deserialize from.",
            "        :returns:",
            "            The deserialized component.",
            "        \"\"\"",
            "        init_params = data.get(\"init_parameters\", {})",
            "        routes = init_params.get(\"routes\")",
            "        for route in routes:",
            "            # output_type needs to be deserialized from a string to a type",
            "            route[\"output_type\"] = deserialize_type(route[\"output_type\"])",
            "        for name, filter_func in init_params.get(\"custom_filters\", {}).items():",
            "            init_params[\"custom_filters\"][name] = deserialize_callable(filter_func) if filter_func else None",
            "        return default_from_dict(cls, data)",
            "",
            "    def run(self, **kwargs):",
            "        \"\"\"",
            "        Executes the routing logic.",
            "",
            "        Executes the routing logic by evaluating the specified boolean condition expressions for each route in the",
            "        order they are listed. The method directs the flow of data to the output specified in the first route whose",
            "        `condition` is True.",
            "",
            "        :param kwargs: All variables used in the `condition` expressed in the routes. When the component is used in a",
            "            pipeline, these variables are passed from the previous component's output.",
            "",
            "        :returns: A dictionary where the key is the `output_name` of the selected route and the value is the `output`",
            "            of the selected route.",
            "",
            "        :raises NoRouteSelectedException: If no `condition' in the routes is `True`.",
            "        :raises RouteConditionException: If there is an error parsing or evaluating the `condition` expression in the",
            "            routes.",
            "        \"\"\"",
            "        # Create a Jinja native environment to evaluate the condition templates as Python expressions",
            "        for route in self.routes:",
            "            try:",
            "                t = self._env.from_string(route[\"condition\"])",
            "                rendered = t.render(**kwargs)",
            "                if ast.literal_eval(rendered):",
            "                    # We now evaluate the `output` expression to determine the route output",
            "                    t_output = self._env.from_string(route[\"output\"])",
            "                    output = t_output.render(**kwargs)",
            "                    # We suppress the exception in case the output is already a string, otherwise",
            "                    # we try to evaluate it and would fail.",
            "                    # This must be done cause the output could be different literal structures.",
            "                    # This doesn't support any user types.",
            "                    with contextlib.suppress(Exception):",
            "                        output = ast.literal_eval(output)",
            "                    # and return the output as a dictionary under the output_name key",
            "                    return {route[\"output_name\"]: output}",
            "            except Exception as e:",
            "                raise RouteConditionException(f\"Error evaluating condition for route '{route}': {e}\") from e",
            "",
            "        raise NoRouteSelectedException(f\"No route fired. Routes: {self.routes}\")",
            "",
            "    def _validate_routes(self, routes: List[Dict]):",
            "        \"\"\"",
            "        Validates a list of routes.",
            "",
            "        :param routes: A list of routes.",
            "        \"\"\"",
            "        env = NativeEnvironment()",
            "        for route in routes:",
            "            try:",
            "                keys = set(route.keys())",
            "            except AttributeError:",
            "                raise ValueError(f\"Route must be a dictionary, got: {route}\")",
            "",
            "            mandatory_fields = {\"condition\", \"output\", \"output_type\", \"output_name\"}",
            "            has_all_mandatory_fields = mandatory_fields.issubset(keys)",
            "            if not has_all_mandatory_fields:",
            "                raise ValueError(",
            "                    f\"Route must contain 'condition', 'output', 'output_type' and 'output_name' fields: {route}\"",
            "                )",
            "            for field in [\"condition\", \"output\"]:",
            "                if not self._validate_template(env, route[field]):",
            "                    raise ValueError(f\"Invalid template for field '{field}': {route[field]}\")",
            "",
            "    def _extract_variables(self, env: SandboxedEnvironment, templates: List[str]) -> Set[str]:",
            "        \"\"\"",
            "        Extracts all variables from a list of Jinja template strings.",
            "",
            "        :param env: A Jinja environment.",
            "        :param templates: A list of Jinja template strings.",
            "        :returns: A set of variable names.",
            "        \"\"\"",
            "        variables = set()",
            "        for template in templates:",
            "            ast = env.parse(template)",
            "            variables.update(meta.find_undeclared_variables(ast))",
            "        return variables",
            "",
            "    def _validate_template(self, env: Environment, template_text: str):",
            "        \"\"\"",
            "        Validates a template string by parsing it with Jinja.",
            "",
            "        :param env: A Jinja environment.",
            "        :param template_text: A Jinja template string.",
            "        :returns: `True` if the template is valid, `False` otherwise.",
            "        \"\"\"",
            "        try:",
            "            env.parse(template_text)",
            "            return True",
            "        except TemplateSyntaxError:",
            "            return False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "128": [
                "ConditionalRouter",
                "__init__"
            ],
            "129": [
                "ConditionalRouter",
                "__init__"
            ],
            "137": [
                "ConditionalRouter",
                "__init__"
            ],
            "197": [
                "ConditionalRouter",
                "run"
            ],
            "198": [
                "ConditionalRouter",
                "run"
            ],
            "199": [
                "ConditionalRouter",
                "run"
            ],
            "202": [
                "ConditionalRouter",
                "run"
            ],
            "203": [
                "ConditionalRouter",
                "run"
            ],
            "205": [
                "ConditionalRouter",
                "run"
            ],
            "237": [
                "ConditionalRouter",
                "_extract_variables"
            ]
        },
        "addLocation": []
    },
    "haystack/core/pipeline/template.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from pathlib import Path"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from typing import Any, Dict, Optional, Union"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from jinja2 import Environment, PackageLoader, TemplateSyntaxError, meta"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from jinja2 import PackageLoader, TemplateSyntaxError, meta"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from jinja2.sandbox import SandboxedEnvironment"
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " TEMPLATE_FILE_EXTENSION = \".yaml.jinja2\""
            },
            "8": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " TEMPLATE_HOME_DIR = Path(__file__).resolve().parent / \"predefined\""
            },
            "9": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         :param template_content: The raw template source to use in the template."
            },
            "11": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         \"\"\""
            },
            "12": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        env = Environment("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        env = SandboxedEnvironment("
            },
            "14": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "             loader=PackageLoader(\"haystack.core.pipeline\", \"predefined\"), trim_blocks=True, lstrip_blocks=True"
            },
            "15": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         )"
            },
            "16": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         try:"
            }
        },
        "frontPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "from enum import Enum",
            "from pathlib import Path",
            "from typing import Any, Dict, Optional, Union",
            "",
            "from jinja2 import Environment, PackageLoader, TemplateSyntaxError, meta",
            "",
            "TEMPLATE_FILE_EXTENSION = \".yaml.jinja2\"",
            "TEMPLATE_HOME_DIR = Path(__file__).resolve().parent / \"predefined\"",
            "",
            "",
            "class PredefinedPipeline(Enum):",
            "    \"\"\"",
            "    Enumeration of predefined pipeline templates that can be used to create a `PipelineTemplate`.",
            "    \"\"\"",
            "",
            "    # Maintain 1-to-1 mapping between the enum name and the template file name in templates directory",
            "    GENERATIVE_QA = \"generative_qa\"",
            "    RAG = \"rag\"",
            "    INDEXING = \"indexing\"",
            "    CHAT_WITH_WEBSITE = \"chat_with_website\"",
            "",
            "",
            "class PipelineTemplate:",
            "    \"\"\"",
            "    The PipelineTemplate enables the creation of flexible and configurable pipelines.",
            "",
            "    The PipelineTemplate class enables the straightforward creation of flexible and configurable pipelines using",
            "    Jinja2 templated YAML files. Specifically designed to simplify the setup of complex data processing pipelines for",
            "    a range of NLP tasks\u2014including question answering, retriever augmented generation (RAG), document indexing, among",
            "    others - PipelineTemplate empowers users to dynamically generate pipeline configurations from templates and",
            "    customize components as necessary. Its design philosophy centers on providing an accessible, yet powerful, tool",
            "    for constructing pipelines that accommodate both common use cases and specialized requirements with ease.",
            "",
            "    Examples of usage:",
            "",
            "    - **Default Build**: Instantiating a pipeline with default settings for a \"question answering\" (qa) task.",
            "      ```python",
            "      from haystack.templates import PipelineTemplate, PredefinedPipeline",
            "",
            "      # Create a pipeline with default components for an extractive QA task",
            "      pipe = PipelineTemplate.from_predefined(PredefinedPipeline.GENERATIVE_QA).build()",
            "      print(pipe.run(data={\"question\": \"What's the capital of Bosnia and Herzegovina? Be brief\"}))",
            "      ```",
            "",
            "    - **Customizing for Specific Tasks**: Building a pipeline for document indexing with specific components tailored",
            "    to the task.",
            "      ```python",
            "      from haystack.components.embedders import SentenceTransformersDocumentEmbedder",
            "      from haystack.templates import PipelineTemplate, PredefinedPipeline",
            "",
            "      # Customize the pipeline for document indexing with specific components, include PDF file converter",
            "      pt = PipelineTemplate.from_predefined(PredefinedTemplate.INDEXING)",
            "      pipe = pt.build(template_params={\"use_pdf_file_converter\": True})",
            "",
            "      result = pipe.run(data={\"sources\": [\"some_text_file.txt\", \"another_pdf_file.pdf\"]})",
            "      print(result)",
            "      ```",
            "",
            "    The `PipelineTemplate` is designed to offer both ease of use for common pipeline configurations and the",
            "    flexibility to customize and extend pipelines as required by advanced users and specific use cases.",
            "    \"\"\"",
            "",
            "    def __init__(self, template_content: str):",
            "        \"\"\"",
            "        Initialize a PipelineTemplate.",
            "",
            "        Besides calling the constructor directly, a set of utility methods is provided to conveniently create an",
            "        instance of `PipelineTemplate` from different sources. See `from_string`, `from_file`, `from_predefined`",
            "        and `from_url`.",
            "",
            "        :param template_content: The raw template source to use in the template.",
            "        \"\"\"",
            "        env = Environment(",
            "            loader=PackageLoader(\"haystack.core.pipeline\", \"predefined\"), trim_blocks=True, lstrip_blocks=True",
            "        )",
            "        try:",
            "            self._template = env.from_string(template_content)",
            "        except TemplateSyntaxError as e:",
            "            raise ValueError(f\"Invalid pipeline template: {e.message}\") from e",
            "",
            "        # Store the list of undefined variables in the template. Components' names will be part of this list",
            "        self.template_variables = meta.find_undeclared_variables(env.parse(template_content))",
            "        self._template_content = template_content",
            "",
            "    def render(self, template_params: Optional[Dict[str, Any]] = None) -> str:",
            "        \"\"\"",
            "        Constructs a `Pipeline` instance based on the template.",
            "",
            "        :param template_params: An optional dictionary of parameters to use when rendering the pipeline template.",
            "",
            "        :returns: An instance of `Pipeline` constructed from the rendered template and custom component configurations.",
            "        \"\"\"",
            "        template_params = template_params or {}",
            "        return self._template.render(**template_params)",
            "",
            "    @classmethod",
            "    def from_file(cls, file_path: Union[Path, str]) -> \"PipelineTemplate\":",
            "        \"\"\"",
            "        Create a PipelineTemplate from a file.",
            "",
            "        :param file_path: The path to the file containing the template. Must contain valid Jinja2 syntax.",
            "        :returns: An instance of `PipelineTemplate`.",
            "        \"\"\"",
            "        with open(file_path, \"r\") as file:",
            "            return cls(file.read())",
            "",
            "    @classmethod",
            "    def from_predefined(cls, predefined_pipeline: PredefinedPipeline) -> \"PipelineTemplate\":",
            "        \"\"\"",
            "        Create a PipelineTemplate from a predefined template.",
            "",
            "        See `PredefinedPipeline` for available options.",
            "",
            "        :param predefined_pipeline: The predefined pipeline to use.",
            "        :returns: An instance of `PipelineTemplate `.",
            "        \"\"\"",
            "        template_path = f\"{TEMPLATE_HOME_DIR}/{predefined_pipeline.value}{TEMPLATE_FILE_EXTENSION}\"",
            "        return cls.from_file(template_path)",
            "",
            "    @property",
            "    def template_content(self) -> str:",
            "        \"\"\"",
            "        Returns the raw template string as a read-only property.",
            "        \"\"\"",
            "        return self._template_content"
        ],
        "afterPatchFile": [
            "# SPDX-FileCopyrightText: 2022-present deepset GmbH <info@deepset.ai>",
            "#",
            "# SPDX-License-Identifier: Apache-2.0",
            "",
            "from enum import Enum",
            "from pathlib import Path",
            "from typing import Any, Dict, Optional, Union",
            "",
            "from jinja2 import PackageLoader, TemplateSyntaxError, meta",
            "from jinja2.sandbox import SandboxedEnvironment",
            "",
            "TEMPLATE_FILE_EXTENSION = \".yaml.jinja2\"",
            "TEMPLATE_HOME_DIR = Path(__file__).resolve().parent / \"predefined\"",
            "",
            "",
            "class PredefinedPipeline(Enum):",
            "    \"\"\"",
            "    Enumeration of predefined pipeline templates that can be used to create a `PipelineTemplate`.",
            "    \"\"\"",
            "",
            "    # Maintain 1-to-1 mapping between the enum name and the template file name in templates directory",
            "    GENERATIVE_QA = \"generative_qa\"",
            "    RAG = \"rag\"",
            "    INDEXING = \"indexing\"",
            "    CHAT_WITH_WEBSITE = \"chat_with_website\"",
            "",
            "",
            "class PipelineTemplate:",
            "    \"\"\"",
            "    The PipelineTemplate enables the creation of flexible and configurable pipelines.",
            "",
            "    The PipelineTemplate class enables the straightforward creation of flexible and configurable pipelines using",
            "    Jinja2 templated YAML files. Specifically designed to simplify the setup of complex data processing pipelines for",
            "    a range of NLP tasks\u2014including question answering, retriever augmented generation (RAG), document indexing, among",
            "    others - PipelineTemplate empowers users to dynamically generate pipeline configurations from templates and",
            "    customize components as necessary. Its design philosophy centers on providing an accessible, yet powerful, tool",
            "    for constructing pipelines that accommodate both common use cases and specialized requirements with ease.",
            "",
            "    Examples of usage:",
            "",
            "    - **Default Build**: Instantiating a pipeline with default settings for a \"question answering\" (qa) task.",
            "      ```python",
            "      from haystack.templates import PipelineTemplate, PredefinedPipeline",
            "",
            "      # Create a pipeline with default components for an extractive QA task",
            "      pipe = PipelineTemplate.from_predefined(PredefinedPipeline.GENERATIVE_QA).build()",
            "      print(pipe.run(data={\"question\": \"What's the capital of Bosnia and Herzegovina? Be brief\"}))",
            "      ```",
            "",
            "    - **Customizing for Specific Tasks**: Building a pipeline for document indexing with specific components tailored",
            "    to the task.",
            "      ```python",
            "      from haystack.components.embedders import SentenceTransformersDocumentEmbedder",
            "      from haystack.templates import PipelineTemplate, PredefinedPipeline",
            "",
            "      # Customize the pipeline for document indexing with specific components, include PDF file converter",
            "      pt = PipelineTemplate.from_predefined(PredefinedTemplate.INDEXING)",
            "      pipe = pt.build(template_params={\"use_pdf_file_converter\": True})",
            "",
            "      result = pipe.run(data={\"sources\": [\"some_text_file.txt\", \"another_pdf_file.pdf\"]})",
            "      print(result)",
            "      ```",
            "",
            "    The `PipelineTemplate` is designed to offer both ease of use for common pipeline configurations and the",
            "    flexibility to customize and extend pipelines as required by advanced users and specific use cases.",
            "    \"\"\"",
            "",
            "    def __init__(self, template_content: str):",
            "        \"\"\"",
            "        Initialize a PipelineTemplate.",
            "",
            "        Besides calling the constructor directly, a set of utility methods is provided to conveniently create an",
            "        instance of `PipelineTemplate` from different sources. See `from_string`, `from_file`, `from_predefined`",
            "        and `from_url`.",
            "",
            "        :param template_content: The raw template source to use in the template.",
            "        \"\"\"",
            "        env = SandboxedEnvironment(",
            "            loader=PackageLoader(\"haystack.core.pipeline\", \"predefined\"), trim_blocks=True, lstrip_blocks=True",
            "        )",
            "        try:",
            "            self._template = env.from_string(template_content)",
            "        except TemplateSyntaxError as e:",
            "            raise ValueError(f\"Invalid pipeline template: {e.message}\") from e",
            "",
            "        # Store the list of undefined variables in the template. Components' names will be part of this list",
            "        self.template_variables = meta.find_undeclared_variables(env.parse(template_content))",
            "        self._template_content = template_content",
            "",
            "    def render(self, template_params: Optional[Dict[str, Any]] = None) -> str:",
            "        \"\"\"",
            "        Constructs a `Pipeline` instance based on the template.",
            "",
            "        :param template_params: An optional dictionary of parameters to use when rendering the pipeline template.",
            "",
            "        :returns: An instance of `Pipeline` constructed from the rendered template and custom component configurations.",
            "        \"\"\"",
            "        template_params = template_params or {}",
            "        return self._template.render(**template_params)",
            "",
            "    @classmethod",
            "    def from_file(cls, file_path: Union[Path, str]) -> \"PipelineTemplate\":",
            "        \"\"\"",
            "        Create a PipelineTemplate from a file.",
            "",
            "        :param file_path: The path to the file containing the template. Must contain valid Jinja2 syntax.",
            "        :returns: An instance of `PipelineTemplate`.",
            "        \"\"\"",
            "        with open(file_path, \"r\") as file:",
            "            return cls(file.read())",
            "",
            "    @classmethod",
            "    def from_predefined(cls, predefined_pipeline: PredefinedPipeline) -> \"PipelineTemplate\":",
            "        \"\"\"",
            "        Create a PipelineTemplate from a predefined template.",
            "",
            "        See `PredefinedPipeline` for available options.",
            "",
            "        :param predefined_pipeline: The predefined pipeline to use.",
            "        :returns: An instance of `PipelineTemplate `.",
            "        \"\"\"",
            "        template_path = f\"{TEMPLATE_HOME_DIR}/{predefined_pipeline.value}{TEMPLATE_FILE_EXTENSION}\"",
            "        return cls.from_file(template_path)",
            "",
            "    @property",
            "    def template_content(self) -> str:",
            "        \"\"\"",
            "        Returns the raw template string as a read-only property.",
            "        \"\"\"",
            "        return self._template_content"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "9": [],
            "77": [
                "PipelineTemplate",
                "__init__"
            ]
        },
        "addLocation": []
    }
}