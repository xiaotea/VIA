{
    "flask/json.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     :copyright: (c) 2015 by Armin Ronacher."
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "     :license: BSD, see LICENSE for more details."
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " \"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+import codecs"
            },
            "4": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import io"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import uuid"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from datetime import date"
            },
            "7": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         kwargs.setdefault('cls', JSONDecoder)"
            },
            "8": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 110,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+def detect_encoding(data):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    \"\"\"Detect which UTF codec was used to encode the given bytes."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+    The latest JSON standard (:rfc:`8259`) suggests that only UTF-8 is"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+    accepted. Older documents allowed 8, 16, or 32. 16 and 32 can be big"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    or little endian. Some editors or libraries may prepend a BOM."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    :param data: Bytes in unknown UTF encoding."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    :return: UTF encoding name"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    \"\"\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+    head = data[:4]"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    if head[:3] == codecs.BOM_UTF8:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        return 'utf-8-sig'"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+    if b'\\x00' not in head:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        return 'utf-8'"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    if head in (codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        return 'utf-32'"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    if head[:2] in (codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        return 'utf-16'"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    if len(head) == 4:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        if head[:3] == b'\\x00\\x00\\x00':"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            return 'utf-32-be'"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        if head[::2] == b'\\x00\\x00':"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+            return 'utf-16-be'"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        if head[1:] == b'\\x00\\x00\\x00':"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            return 'utf-32-le'"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        if head[1::2] == b'\\x00\\x00':"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            return 'utf-16-le'"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+    if len(head) == 2:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        return 'utf-16-be' if head.startswith(b'\\x00') else 'utf-16-le'"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+    return 'utf-8'"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 155,
                "PatchRowcode": " def dumps(obj, **kwargs):"
            },
            "54": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     \"\"\"Serialize ``obj`` to a JSON formatted ``str`` by using the application's"
            },
            "55": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "     configured encoder (:attr:`~flask.Flask.json_encoder`) if there is an"
            },
            "56": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "     \"\"\""
            },
            "57": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "     _load_arg_defaults(kwargs)"
            },
            "58": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "     if isinstance(s, bytes):"
            },
            "59": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        s = s.decode(kwargs.pop('encoding', None) or 'utf-8')"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+        encoding = kwargs.pop('encoding', None)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        if encoding is None:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+            encoding = detect_encoding(s)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        s = s.decode(encoding)"
            },
            "64": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "     return _json.loads(s, **kwargs)"
            },
            "65": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 194,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    flask.jsonimpl",
            "    ~~~~~~~~~~~~~~",
            "",
            "    Implementation helpers for the JSON support in Flask.",
            "",
            "    :copyright: (c) 2015 by Armin Ronacher.",
            "    :license: BSD, see LICENSE for more details.",
            "\"\"\"",
            "import io",
            "import uuid",
            "from datetime import date",
            "from .globals import current_app, request",
            "from ._compat import text_type, PY2",
            "",
            "from werkzeug.http import http_date",
            "from jinja2 import Markup",
            "",
            "# Use the same json implementation as itsdangerous on which we",
            "# depend anyways.",
            "from itsdangerous import json as _json",
            "",
            "",
            "# Figure out if simplejson escapes slashes.  This behavior was changed",
            "# from one version to another without reason.",
            "_slash_escape = '\\\\/' not in _json.dumps('/')",
            "",
            "",
            "__all__ = ['dump', 'dumps', 'load', 'loads', 'htmlsafe_dump',",
            "           'htmlsafe_dumps', 'JSONDecoder', 'JSONEncoder',",
            "           'jsonify']",
            "",
            "",
            "def _wrap_reader_for_text(fp, encoding):",
            "    if isinstance(fp.read(0), bytes):",
            "        fp = io.TextIOWrapper(io.BufferedReader(fp), encoding)",
            "    return fp",
            "",
            "",
            "def _wrap_writer_for_text(fp, encoding):",
            "    try:",
            "        fp.write('')",
            "    except TypeError:",
            "        fp = io.TextIOWrapper(fp, encoding)",
            "    return fp",
            "",
            "",
            "class JSONEncoder(_json.JSONEncoder):",
            "    \"\"\"The default Flask JSON encoder.  This one extends the default simplejson",
            "    encoder by also supporting ``datetime`` objects, ``UUID`` as well as",
            "    ``Markup`` objects which are serialized as RFC 822 datetime strings (same",
            "    as the HTTP date format).  In order to support more data types override the",
            "    :meth:`default` method.",
            "    \"\"\"",
            "",
            "    def default(self, o):",
            "        \"\"\"Implement this method in a subclass such that it returns a",
            "        serializable object for ``o``, or calls the base implementation (to",
            "        raise a :exc:`TypeError`).",
            "",
            "        For example, to support arbitrary iterators, you could implement",
            "        default like this::",
            "",
            "            def default(self, o):",
            "                try:",
            "                    iterable = iter(o)",
            "                except TypeError:",
            "                    pass",
            "                else:",
            "                    return list(iterable)",
            "                return JSONEncoder.default(self, o)",
            "        \"\"\"",
            "        if isinstance(o, date):",
            "            return http_date(o.timetuple())",
            "        if isinstance(o, uuid.UUID):",
            "            return str(o)",
            "        if hasattr(o, '__html__'):",
            "            return text_type(o.__html__())",
            "        return _json.JSONEncoder.default(self, o)",
            "",
            "",
            "class JSONDecoder(_json.JSONDecoder):",
            "    \"\"\"The default JSON decoder.  This one does not change the behavior from",
            "    the default simplejson decoder.  Consult the :mod:`json` documentation",
            "    for more information.  This decoder is not only used for the load",
            "    functions of this module but also :attr:`~flask.Request`.",
            "    \"\"\"",
            "",
            "",
            "def _dump_arg_defaults(kwargs):",
            "    \"\"\"Inject default arguments for dump functions.\"\"\"",
            "    if current_app:",
            "        kwargs.setdefault('cls', current_app.json_encoder)",
            "        if not current_app.config['JSON_AS_ASCII']:",
            "            kwargs.setdefault('ensure_ascii', False)",
            "        kwargs.setdefault('sort_keys', current_app.config['JSON_SORT_KEYS'])",
            "    else:",
            "        kwargs.setdefault('sort_keys', True)",
            "        kwargs.setdefault('cls', JSONEncoder)",
            "",
            "",
            "def _load_arg_defaults(kwargs):",
            "    \"\"\"Inject default arguments for load functions.\"\"\"",
            "    if current_app:",
            "        kwargs.setdefault('cls', current_app.json_decoder)",
            "    else:",
            "        kwargs.setdefault('cls', JSONDecoder)",
            "",
            "",
            "def dumps(obj, **kwargs):",
            "    \"\"\"Serialize ``obj`` to a JSON formatted ``str`` by using the application's",
            "    configured encoder (:attr:`~flask.Flask.json_encoder`) if there is an",
            "    application on the stack.",
            "",
            "    This function can return ``unicode`` strings or ascii-only bytestrings by",
            "    default which coerce into unicode strings automatically.  That behavior by",
            "    default is controlled by the ``JSON_AS_ASCII`` configuration variable",
            "    and can be overridden by the simplejson ``ensure_ascii`` parameter.",
            "    \"\"\"",
            "    _dump_arg_defaults(kwargs)",
            "    encoding = kwargs.pop('encoding', None)",
            "    rv = _json.dumps(obj, **kwargs)",
            "    if encoding is not None and isinstance(rv, text_type):",
            "        rv = rv.encode(encoding)",
            "    return rv",
            "",
            "",
            "def dump(obj, fp, **kwargs):",
            "    \"\"\"Like :func:`dumps` but writes into a file object.\"\"\"",
            "    _dump_arg_defaults(kwargs)",
            "    encoding = kwargs.pop('encoding', None)",
            "    if encoding is not None:",
            "        fp = _wrap_writer_for_text(fp, encoding)",
            "    _json.dump(obj, fp, **kwargs)",
            "",
            "",
            "def loads(s, **kwargs):",
            "    \"\"\"Unserialize a JSON object from a string ``s`` by using the application's",
            "    configured decoder (:attr:`~flask.Flask.json_decoder`) if there is an",
            "    application on the stack.",
            "    \"\"\"",
            "    _load_arg_defaults(kwargs)",
            "    if isinstance(s, bytes):",
            "        s = s.decode(kwargs.pop('encoding', None) or 'utf-8')",
            "    return _json.loads(s, **kwargs)",
            "",
            "",
            "def load(fp, **kwargs):",
            "    \"\"\"Like :func:`loads` but reads from a file object.",
            "    \"\"\"",
            "    _load_arg_defaults(kwargs)",
            "    if not PY2:",
            "        fp = _wrap_reader_for_text(fp, kwargs.pop('encoding', None) or 'utf-8')",
            "    return _json.load(fp, **kwargs)",
            "",
            "",
            "def htmlsafe_dumps(obj, **kwargs):",
            "    \"\"\"Works exactly like :func:`dumps` but is safe for use in ``<script>``",
            "    tags.  It accepts the same arguments and returns a JSON string.  Note that",
            "    this is available in templates through the ``|tojson`` filter which will",
            "    also mark the result as safe.  Due to how this function escapes certain",
            "    characters this is safe even if used outside of ``<script>`` tags.",
            "",
            "    The following characters are escaped in strings:",
            "",
            "    -   ``<``",
            "    -   ``>``",
            "    -   ``&``",
            "    -   ``'``",
            "",
            "    This makes it safe to embed such strings in any place in HTML with the",
            "    notable exception of double quoted attributes.  In that case single",
            "    quote your attributes or HTML escape it in addition.",
            "",
            "    .. versionchanged:: 0.10",
            "       This function's return value is now always safe for HTML usage, even",
            "       if outside of script tags or if used in XHTML.  This rule does not",
            "       hold true when using this function in HTML attributes that are double",
            "       quoted.  Always single quote attributes if you use the ``|tojson``",
            "       filter.  Alternatively use ``|tojson|forceescape``.",
            "    \"\"\"",
            "    rv = dumps(obj, **kwargs) \\",
            "        .replace(u'<', u'\\\\u003c') \\",
            "        .replace(u'>', u'\\\\u003e') \\",
            "        .replace(u'&', u'\\\\u0026') \\",
            "        .replace(u\"'\", u'\\\\u0027')",
            "    if not _slash_escape:",
            "        rv = rv.replace('\\\\/', '/')",
            "    return rv",
            "",
            "",
            "def htmlsafe_dump(obj, fp, **kwargs):",
            "    \"\"\"Like :func:`htmlsafe_dumps` but writes into a file object.\"\"\"",
            "    fp.write(text_type(htmlsafe_dumps(obj, **kwargs)))",
            "",
            "",
            "def jsonify(*args, **kwargs):",
            "    \"\"\"This function wraps :func:`dumps` to add a few enhancements that make",
            "    life easier.  It turns the JSON output into a :class:`~flask.Response`",
            "    object with the :mimetype:`application/json` mimetype.  For convenience, it",
            "    also converts multiple arguments into an array or multiple keyword arguments",
            "    into a dict.  This means that both ``jsonify(1,2,3)`` and",
            "    ``jsonify([1,2,3])`` serialize to ``[1,2,3]``.",
            "",
            "    For clarity, the JSON serialization behavior has the following differences",
            "    from :func:`dumps`:",
            "",
            "    1. Single argument: Passed straight through to :func:`dumps`.",
            "    2. Multiple arguments: Converted to an array before being passed to",
            "       :func:`dumps`.",
            "    3. Multiple keyword arguments: Converted to a dict before being passed to",
            "       :func:`dumps`.",
            "    4. Both args and kwargs: Behavior undefined and will throw an exception.",
            "",
            "    Example usage::",
            "",
            "        from flask import jsonify",
            "",
            "        @app.route('/_get_current_user')",
            "        def get_current_user():",
            "            return jsonify(username=g.user.username,",
            "                           email=g.user.email,",
            "                           id=g.user.id)",
            "",
            "    This will send a JSON response like this to the browser::",
            "",
            "        {",
            "            \"username\": \"admin\",",
            "            \"email\": \"admin@localhost\",",
            "            \"id\": 42",
            "        }",
            "",
            "",
            "    .. versionchanged:: 0.11",
            "       Added support for serializing top-level arrays. This introduces a",
            "       security risk in ancient browsers. See :ref:`json-security` for details.",
            "",
            "    This function's response will be pretty printed if it was not requested",
            "    with ``X-Requested-With: XMLHttpRequest`` to simplify debugging unless",
            "    the ``JSONIFY_PRETTYPRINT_REGULAR`` config parameter is set to false.",
            "    Compressed (not pretty) formatting currently means no indents and no",
            "    spaces after separators.",
            "",
            "    .. versionadded:: 0.2",
            "    \"\"\"",
            "",
            "    indent = None",
            "    separators = (',', ':')",
            "",
            "    if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] and not request.is_xhr:",
            "        indent = 2",
            "        separators = (', ', ': ')",
            "",
            "    if args and kwargs:",
            "        raise TypeError('jsonify() behavior undefined when passed both args and kwargs')",
            "    elif len(args) == 1:  # single args are passed directly to dumps()",
            "        data = args[0]",
            "    else:",
            "        data = args or kwargs",
            "",
            "    return current_app.response_class(",
            "        (dumps(data, indent=indent, separators=separators), '\\n'),",
            "        mimetype=current_app.config['JSONIFY_MIMETYPE']",
            "    )",
            "",
            "",
            "def tojson_filter(obj, **kwargs):",
            "    return Markup(htmlsafe_dumps(obj, **kwargs))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    flask.jsonimpl",
            "    ~~~~~~~~~~~~~~",
            "",
            "    Implementation helpers for the JSON support in Flask.",
            "",
            "    :copyright: (c) 2015 by Armin Ronacher.",
            "    :license: BSD, see LICENSE for more details.",
            "\"\"\"",
            "import codecs",
            "import io",
            "import uuid",
            "from datetime import date",
            "from .globals import current_app, request",
            "from ._compat import text_type, PY2",
            "",
            "from werkzeug.http import http_date",
            "from jinja2 import Markup",
            "",
            "# Use the same json implementation as itsdangerous on which we",
            "# depend anyways.",
            "from itsdangerous import json as _json",
            "",
            "",
            "# Figure out if simplejson escapes slashes.  This behavior was changed",
            "# from one version to another without reason.",
            "_slash_escape = '\\\\/' not in _json.dumps('/')",
            "",
            "",
            "__all__ = ['dump', 'dumps', 'load', 'loads', 'htmlsafe_dump',",
            "           'htmlsafe_dumps', 'JSONDecoder', 'JSONEncoder',",
            "           'jsonify']",
            "",
            "",
            "def _wrap_reader_for_text(fp, encoding):",
            "    if isinstance(fp.read(0), bytes):",
            "        fp = io.TextIOWrapper(io.BufferedReader(fp), encoding)",
            "    return fp",
            "",
            "",
            "def _wrap_writer_for_text(fp, encoding):",
            "    try:",
            "        fp.write('')",
            "    except TypeError:",
            "        fp = io.TextIOWrapper(fp, encoding)",
            "    return fp",
            "",
            "",
            "class JSONEncoder(_json.JSONEncoder):",
            "    \"\"\"The default Flask JSON encoder.  This one extends the default simplejson",
            "    encoder by also supporting ``datetime`` objects, ``UUID`` as well as",
            "    ``Markup`` objects which are serialized as RFC 822 datetime strings (same",
            "    as the HTTP date format).  In order to support more data types override the",
            "    :meth:`default` method.",
            "    \"\"\"",
            "",
            "    def default(self, o):",
            "        \"\"\"Implement this method in a subclass such that it returns a",
            "        serializable object for ``o``, or calls the base implementation (to",
            "        raise a :exc:`TypeError`).",
            "",
            "        For example, to support arbitrary iterators, you could implement",
            "        default like this::",
            "",
            "            def default(self, o):",
            "                try:",
            "                    iterable = iter(o)",
            "                except TypeError:",
            "                    pass",
            "                else:",
            "                    return list(iterable)",
            "                return JSONEncoder.default(self, o)",
            "        \"\"\"",
            "        if isinstance(o, date):",
            "            return http_date(o.timetuple())",
            "        if isinstance(o, uuid.UUID):",
            "            return str(o)",
            "        if hasattr(o, '__html__'):",
            "            return text_type(o.__html__())",
            "        return _json.JSONEncoder.default(self, o)",
            "",
            "",
            "class JSONDecoder(_json.JSONDecoder):",
            "    \"\"\"The default JSON decoder.  This one does not change the behavior from",
            "    the default simplejson decoder.  Consult the :mod:`json` documentation",
            "    for more information.  This decoder is not only used for the load",
            "    functions of this module but also :attr:`~flask.Request`.",
            "    \"\"\"",
            "",
            "",
            "def _dump_arg_defaults(kwargs):",
            "    \"\"\"Inject default arguments for dump functions.\"\"\"",
            "    if current_app:",
            "        kwargs.setdefault('cls', current_app.json_encoder)",
            "        if not current_app.config['JSON_AS_ASCII']:",
            "            kwargs.setdefault('ensure_ascii', False)",
            "        kwargs.setdefault('sort_keys', current_app.config['JSON_SORT_KEYS'])",
            "    else:",
            "        kwargs.setdefault('sort_keys', True)",
            "        kwargs.setdefault('cls', JSONEncoder)",
            "",
            "",
            "def _load_arg_defaults(kwargs):",
            "    \"\"\"Inject default arguments for load functions.\"\"\"",
            "    if current_app:",
            "        kwargs.setdefault('cls', current_app.json_decoder)",
            "    else:",
            "        kwargs.setdefault('cls', JSONDecoder)",
            "",
            "",
            "def detect_encoding(data):",
            "    \"\"\"Detect which UTF codec was used to encode the given bytes.",
            "",
            "    The latest JSON standard (:rfc:`8259`) suggests that only UTF-8 is",
            "    accepted. Older documents allowed 8, 16, or 32. 16 and 32 can be big",
            "    or little endian. Some editors or libraries may prepend a BOM.",
            "",
            "    :param data: Bytes in unknown UTF encoding.",
            "    :return: UTF encoding name",
            "    \"\"\"",
            "    head = data[:4]",
            "",
            "    if head[:3] == codecs.BOM_UTF8:",
            "        return 'utf-8-sig'",
            "",
            "    if b'\\x00' not in head:",
            "        return 'utf-8'",
            "",
            "    if head in (codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE):",
            "        return 'utf-32'",
            "",
            "    if head[:2] in (codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE):",
            "        return 'utf-16'",
            "",
            "    if len(head) == 4:",
            "        if head[:3] == b'\\x00\\x00\\x00':",
            "            return 'utf-32-be'",
            "",
            "        if head[::2] == b'\\x00\\x00':",
            "            return 'utf-16-be'",
            "",
            "        if head[1:] == b'\\x00\\x00\\x00':",
            "            return 'utf-32-le'",
            "",
            "        if head[1::2] == b'\\x00\\x00':",
            "            return 'utf-16-le'",
            "",
            "    if len(head) == 2:",
            "        return 'utf-16-be' if head.startswith(b'\\x00') else 'utf-16-le'",
            "",
            "    return 'utf-8'",
            "",
            "",
            "def dumps(obj, **kwargs):",
            "    \"\"\"Serialize ``obj`` to a JSON formatted ``str`` by using the application's",
            "    configured encoder (:attr:`~flask.Flask.json_encoder`) if there is an",
            "    application on the stack.",
            "",
            "    This function can return ``unicode`` strings or ascii-only bytestrings by",
            "    default which coerce into unicode strings automatically.  That behavior by",
            "    default is controlled by the ``JSON_AS_ASCII`` configuration variable",
            "    and can be overridden by the simplejson ``ensure_ascii`` parameter.",
            "    \"\"\"",
            "    _dump_arg_defaults(kwargs)",
            "    encoding = kwargs.pop('encoding', None)",
            "    rv = _json.dumps(obj, **kwargs)",
            "    if encoding is not None and isinstance(rv, text_type):",
            "        rv = rv.encode(encoding)",
            "    return rv",
            "",
            "",
            "def dump(obj, fp, **kwargs):",
            "    \"\"\"Like :func:`dumps` but writes into a file object.\"\"\"",
            "    _dump_arg_defaults(kwargs)",
            "    encoding = kwargs.pop('encoding', None)",
            "    if encoding is not None:",
            "        fp = _wrap_writer_for_text(fp, encoding)",
            "    _json.dump(obj, fp, **kwargs)",
            "",
            "",
            "def loads(s, **kwargs):",
            "    \"\"\"Unserialize a JSON object from a string ``s`` by using the application's",
            "    configured decoder (:attr:`~flask.Flask.json_decoder`) if there is an",
            "    application on the stack.",
            "    \"\"\"",
            "    _load_arg_defaults(kwargs)",
            "    if isinstance(s, bytes):",
            "        encoding = kwargs.pop('encoding', None)",
            "        if encoding is None:",
            "            encoding = detect_encoding(s)",
            "        s = s.decode(encoding)",
            "    return _json.loads(s, **kwargs)",
            "",
            "",
            "def load(fp, **kwargs):",
            "    \"\"\"Like :func:`loads` but reads from a file object.",
            "    \"\"\"",
            "    _load_arg_defaults(kwargs)",
            "    if not PY2:",
            "        fp = _wrap_reader_for_text(fp, kwargs.pop('encoding', None) or 'utf-8')",
            "    return _json.load(fp, **kwargs)",
            "",
            "",
            "def htmlsafe_dumps(obj, **kwargs):",
            "    \"\"\"Works exactly like :func:`dumps` but is safe for use in ``<script>``",
            "    tags.  It accepts the same arguments and returns a JSON string.  Note that",
            "    this is available in templates through the ``|tojson`` filter which will",
            "    also mark the result as safe.  Due to how this function escapes certain",
            "    characters this is safe even if used outside of ``<script>`` tags.",
            "",
            "    The following characters are escaped in strings:",
            "",
            "    -   ``<``",
            "    -   ``>``",
            "    -   ``&``",
            "    -   ``'``",
            "",
            "    This makes it safe to embed such strings in any place in HTML with the",
            "    notable exception of double quoted attributes.  In that case single",
            "    quote your attributes or HTML escape it in addition.",
            "",
            "    .. versionchanged:: 0.10",
            "       This function's return value is now always safe for HTML usage, even",
            "       if outside of script tags or if used in XHTML.  This rule does not",
            "       hold true when using this function in HTML attributes that are double",
            "       quoted.  Always single quote attributes if you use the ``|tojson``",
            "       filter.  Alternatively use ``|tojson|forceescape``.",
            "    \"\"\"",
            "    rv = dumps(obj, **kwargs) \\",
            "        .replace(u'<', u'\\\\u003c') \\",
            "        .replace(u'>', u'\\\\u003e') \\",
            "        .replace(u'&', u'\\\\u0026') \\",
            "        .replace(u\"'\", u'\\\\u0027')",
            "    if not _slash_escape:",
            "        rv = rv.replace('\\\\/', '/')",
            "    return rv",
            "",
            "",
            "def htmlsafe_dump(obj, fp, **kwargs):",
            "    \"\"\"Like :func:`htmlsafe_dumps` but writes into a file object.\"\"\"",
            "    fp.write(text_type(htmlsafe_dumps(obj, **kwargs)))",
            "",
            "",
            "def jsonify(*args, **kwargs):",
            "    \"\"\"This function wraps :func:`dumps` to add a few enhancements that make",
            "    life easier.  It turns the JSON output into a :class:`~flask.Response`",
            "    object with the :mimetype:`application/json` mimetype.  For convenience, it",
            "    also converts multiple arguments into an array or multiple keyword arguments",
            "    into a dict.  This means that both ``jsonify(1,2,3)`` and",
            "    ``jsonify([1,2,3])`` serialize to ``[1,2,3]``.",
            "",
            "    For clarity, the JSON serialization behavior has the following differences",
            "    from :func:`dumps`:",
            "",
            "    1. Single argument: Passed straight through to :func:`dumps`.",
            "    2. Multiple arguments: Converted to an array before being passed to",
            "       :func:`dumps`.",
            "    3. Multiple keyword arguments: Converted to a dict before being passed to",
            "       :func:`dumps`.",
            "    4. Both args and kwargs: Behavior undefined and will throw an exception.",
            "",
            "    Example usage::",
            "",
            "        from flask import jsonify",
            "",
            "        @app.route('/_get_current_user')",
            "        def get_current_user():",
            "            return jsonify(username=g.user.username,",
            "                           email=g.user.email,",
            "                           id=g.user.id)",
            "",
            "    This will send a JSON response like this to the browser::",
            "",
            "        {",
            "            \"username\": \"admin\",",
            "            \"email\": \"admin@localhost\",",
            "            \"id\": 42",
            "        }",
            "",
            "",
            "    .. versionchanged:: 0.11",
            "       Added support for serializing top-level arrays. This introduces a",
            "       security risk in ancient browsers. See :ref:`json-security` for details.",
            "",
            "    This function's response will be pretty printed if it was not requested",
            "    with ``X-Requested-With: XMLHttpRequest`` to simplify debugging unless",
            "    the ``JSONIFY_PRETTYPRINT_REGULAR`` config parameter is set to false.",
            "    Compressed (not pretty) formatting currently means no indents and no",
            "    spaces after separators.",
            "",
            "    .. versionadded:: 0.2",
            "    \"\"\"",
            "",
            "    indent = None",
            "    separators = (',', ':')",
            "",
            "    if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] and not request.is_xhr:",
            "        indent = 2",
            "        separators = (', ', ': ')",
            "",
            "    if args and kwargs:",
            "        raise TypeError('jsonify() behavior undefined when passed both args and kwargs')",
            "    elif len(args) == 1:  # single args are passed directly to dumps()",
            "        data = args[0]",
            "    else:",
            "        data = args or kwargs",
            "",
            "    return current_app.response_class(",
            "        (dumps(data, indent=indent, separators=separators), '\\n'),",
            "        mimetype=current_app.config['JSONIFY_MIMETYPE']",
            "    )",
            "",
            "",
            "def tojson_filter(obj, **kwargs):",
            "    return Markup(htmlsafe_dumps(obj, **kwargs))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "145": [
                "loads"
            ]
        },
        "addLocation": [
            "redbot.cogs.trivia.trivia",
            "flask.json.loads"
        ]
    },
    "flask/wrappers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         if not (force or self.is_json):"
            },
            "1": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "             return None"
            },
            "2": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # We accept a request charset against the specification as"
            },
            "4": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # certain clients have been using this in the past.  This"
            },
            "5": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # fits our general approach of being nice in what we accept"
            },
            "6": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # and strict in what we send out."
            },
            "7": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        request_charset = self.mimetype_params.get('charset')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        data = _get_data(self, cache)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         try:"
            },
            "11": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data = _get_data(self, cache)"
            },
            "12": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if request_charset is not None:"
            },
            "13": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                rv = json.loads(data, encoding=request_charset)"
            },
            "14": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "15": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                rv = json.loads(data)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            rv = json.loads(data)"
            },
            "17": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         except ValueError as e:"
            },
            "18": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "             if silent:"
            },
            "19": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "                 rv = None"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    flask.wrappers",
            "    ~~~~~~~~~~~~~~",
            "",
            "    Implements the WSGI wrappers (request and response).",
            "",
            "    :copyright: (c) 2015 by Armin Ronacher.",
            "    :license: BSD, see LICENSE for more details.",
            "\"\"\"",
            "",
            "from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase",
            "from werkzeug.exceptions import BadRequest",
            "",
            "from . import json",
            "from .globals import _request_ctx_stack",
            "",
            "_missing = object()",
            "",
            "",
            "def _get_data(req, cache):",
            "    getter = getattr(req, 'get_data', None)",
            "    if getter is not None:",
            "        return getter(cache=cache)",
            "    return req.data",
            "",
            "",
            "class Request(RequestBase):",
            "    \"\"\"The request object used by default in Flask.  Remembers the",
            "    matched endpoint and view arguments.",
            "",
            "    It is what ends up as :class:`~flask.request`.  If you want to replace",
            "    the request object used you can subclass this and set",
            "    :attr:`~flask.Flask.request_class` to your subclass.",
            "",
            "    The request object is a :class:`~werkzeug.wrappers.Request` subclass and",
            "    provides all of the attributes Werkzeug defines plus a few Flask",
            "    specific ones.",
            "    \"\"\"",
            "",
            "    #: The internal URL rule that matched the request.  This can be",
            "    #: useful to inspect which methods are allowed for the URL from",
            "    #: a before/after handler (``request.url_rule.methods``) etc.",
            "    #:",
            "    #: .. versionadded:: 0.6",
            "    url_rule = None",
            "",
            "    #: A dict of view arguments that matched the request.  If an exception",
            "    #: happened when matching, this will be ``None``.",
            "    view_args = None",
            "",
            "    #: If matching the URL failed, this is the exception that will be",
            "    #: raised / was raised as part of the request handling.  This is",
            "    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or",
            "    #: something similar.",
            "    routing_exception = None",
            "",
            "    # Switched by the request context until 1.0 to opt in deprecated",
            "    # module functionality.",
            "    _is_old_module = False",
            "",
            "    @property",
            "    def max_content_length(self):",
            "        \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"",
            "        ctx = _request_ctx_stack.top",
            "        if ctx is not None:",
            "            return ctx.app.config['MAX_CONTENT_LENGTH']",
            "",
            "    @property",
            "    def endpoint(self):",
            "        \"\"\"The endpoint that matched the request.  This in combination with",
            "        :attr:`view_args` can be used to reconstruct the same or a",
            "        modified URL.  If an exception happened when matching, this will",
            "        be ``None``.",
            "        \"\"\"",
            "        if self.url_rule is not None:",
            "            return self.url_rule.endpoint",
            "",
            "    @property",
            "    def module(self):",
            "        \"\"\"The name of the current module if the request was dispatched",
            "        to an actual module.  This is deprecated functionality, use blueprints",
            "        instead.",
            "        \"\"\"",
            "        from warnings import warn",
            "        warn(DeprecationWarning('modules were deprecated in favor of '",
            "                                'blueprints.  Use request.blueprint '",
            "                                'instead.'), stacklevel=2)",
            "        if self._is_old_module:",
            "            return self.blueprint",
            "",
            "    @property",
            "    def blueprint(self):",
            "        \"\"\"The name of the current blueprint\"\"\"",
            "        if self.url_rule and '.' in self.url_rule.endpoint:",
            "            return self.url_rule.endpoint.rsplit('.', 1)[0]",
            "",
            "    @property",
            "    def json(self):",
            "        \"\"\"If the mimetype is :mimetype:`application/json` this will contain the",
            "        parsed JSON data.  Otherwise this will be ``None``.",
            "",
            "        The :meth:`get_json` method should be used instead.",
            "        \"\"\"",
            "        from warnings import warn",
            "        warn(DeprecationWarning('json is deprecated.  '",
            "                                'Use get_json() instead.'), stacklevel=2)",
            "        return self.get_json()",
            "",
            "    @property",
            "    def is_json(self):",
            "        \"\"\"Indicates if this request is JSON or not.  By default a request",
            "        is considered to include JSON data if the mimetype is",
            "        :mimetype:`application/json` or :mimetype:`application/*+json`.",
            "",
            "        .. versionadded:: 0.11",
            "        \"\"\"",
            "        mt = self.mimetype",
            "        if mt == 'application/json':",
            "            return True",
            "        if mt.startswith('application/') and mt.endswith('+json'):",
            "            return True",
            "        return False",
            "",
            "    def get_json(self, force=False, silent=False, cache=True):",
            "        \"\"\"Parses the incoming JSON request data and returns it.  By default",
            "        this function will return ``None`` if the mimetype is not",
            "        :mimetype:`application/json` but this can be overridden by the",
            "        ``force`` parameter. If parsing fails the",
            "        :meth:`on_json_loading_failed` method on the request object will be",
            "        invoked.",
            "",
            "        :param force: if set to ``True`` the mimetype is ignored.",
            "        :param silent: if set to ``True`` this method will fail silently",
            "                       and return ``None``.",
            "        :param cache: if set to ``True`` the parsed JSON data is remembered",
            "                      on the request.",
            "        \"\"\"",
            "        rv = getattr(self, '_cached_json', _missing)",
            "        # We return cached JSON only when the cache is enabled.",
            "        if cache and rv is not _missing:",
            "            return rv",
            "",
            "        if not (force or self.is_json):",
            "            return None",
            "",
            "        # We accept a request charset against the specification as",
            "        # certain clients have been using this in the past.  This",
            "        # fits our general approach of being nice in what we accept",
            "        # and strict in what we send out.",
            "        request_charset = self.mimetype_params.get('charset')",
            "        try:",
            "            data = _get_data(self, cache)",
            "            if request_charset is not None:",
            "                rv = json.loads(data, encoding=request_charset)",
            "            else:",
            "                rv = json.loads(data)",
            "        except ValueError as e:",
            "            if silent:",
            "                rv = None",
            "            else:",
            "                rv = self.on_json_loading_failed(e)",
            "        if cache:",
            "            self._cached_json = rv",
            "        return rv",
            "",
            "    def on_json_loading_failed(self, e):",
            "        \"\"\"Called if decoding of the JSON data failed.  The return value of",
            "        this method is used by :meth:`get_json` when an error occurred.  The",
            "        default implementation just raises a :class:`BadRequest` exception.",
            "",
            "        .. versionchanged:: 0.10",
            "           Removed buggy previous behavior of generating a random JSON",
            "           response.  If you want that behavior back you can trivially",
            "           add it by subclassing.",
            "",
            "        .. versionadded:: 0.8",
            "        \"\"\"",
            "        ctx = _request_ctx_stack.top",
            "        if ctx is not None and ctx.app.config.get('DEBUG', False):",
            "            raise BadRequest('Failed to decode JSON object: {0}'.format(e))",
            "        raise BadRequest()",
            "",
            "    def _load_form_data(self):",
            "        RequestBase._load_form_data(self)",
            "",
            "        # In debug mode we're replacing the files multidict with an ad-hoc",
            "        # subclass that raises a different error for key errors.",
            "        ctx = _request_ctx_stack.top",
            "        if ctx is not None and ctx.app.debug and \\",
            "           self.mimetype != 'multipart/form-data' and not self.files:",
            "            from .debughelpers import attach_enctype_error_multidict",
            "            attach_enctype_error_multidict(self)",
            "",
            "",
            "class Response(ResponseBase):",
            "    \"\"\"The response object that is used by default in Flask.  Works like the",
            "    response object from Werkzeug but is set to have an HTML mimetype by",
            "    default.  Quite often you don't have to create this object yourself because",
            "    :meth:`~flask.Flask.make_response` will take care of that for you.",
            "",
            "    If you want to replace the response object used you can subclass this and",
            "    set :attr:`~flask.Flask.response_class` to your subclass.",
            "    \"\"\"",
            "    default_mimetype = 'text/html'"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    flask.wrappers",
            "    ~~~~~~~~~~~~~~",
            "",
            "    Implements the WSGI wrappers (request and response).",
            "",
            "    :copyright: (c) 2015 by Armin Ronacher.",
            "    :license: BSD, see LICENSE for more details.",
            "\"\"\"",
            "",
            "from werkzeug.wrappers import Request as RequestBase, Response as ResponseBase",
            "from werkzeug.exceptions import BadRequest",
            "",
            "from . import json",
            "from .globals import _request_ctx_stack",
            "",
            "_missing = object()",
            "",
            "",
            "def _get_data(req, cache):",
            "    getter = getattr(req, 'get_data', None)",
            "    if getter is not None:",
            "        return getter(cache=cache)",
            "    return req.data",
            "",
            "",
            "class Request(RequestBase):",
            "    \"\"\"The request object used by default in Flask.  Remembers the",
            "    matched endpoint and view arguments.",
            "",
            "    It is what ends up as :class:`~flask.request`.  If you want to replace",
            "    the request object used you can subclass this and set",
            "    :attr:`~flask.Flask.request_class` to your subclass.",
            "",
            "    The request object is a :class:`~werkzeug.wrappers.Request` subclass and",
            "    provides all of the attributes Werkzeug defines plus a few Flask",
            "    specific ones.",
            "    \"\"\"",
            "",
            "    #: The internal URL rule that matched the request.  This can be",
            "    #: useful to inspect which methods are allowed for the URL from",
            "    #: a before/after handler (``request.url_rule.methods``) etc.",
            "    #:",
            "    #: .. versionadded:: 0.6",
            "    url_rule = None",
            "",
            "    #: A dict of view arguments that matched the request.  If an exception",
            "    #: happened when matching, this will be ``None``.",
            "    view_args = None",
            "",
            "    #: If matching the URL failed, this is the exception that will be",
            "    #: raised / was raised as part of the request handling.  This is",
            "    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or",
            "    #: something similar.",
            "    routing_exception = None",
            "",
            "    # Switched by the request context until 1.0 to opt in deprecated",
            "    # module functionality.",
            "    _is_old_module = False",
            "",
            "    @property",
            "    def max_content_length(self):",
            "        \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"",
            "        ctx = _request_ctx_stack.top",
            "        if ctx is not None:",
            "            return ctx.app.config['MAX_CONTENT_LENGTH']",
            "",
            "    @property",
            "    def endpoint(self):",
            "        \"\"\"The endpoint that matched the request.  This in combination with",
            "        :attr:`view_args` can be used to reconstruct the same or a",
            "        modified URL.  If an exception happened when matching, this will",
            "        be ``None``.",
            "        \"\"\"",
            "        if self.url_rule is not None:",
            "            return self.url_rule.endpoint",
            "",
            "    @property",
            "    def module(self):",
            "        \"\"\"The name of the current module if the request was dispatched",
            "        to an actual module.  This is deprecated functionality, use blueprints",
            "        instead.",
            "        \"\"\"",
            "        from warnings import warn",
            "        warn(DeprecationWarning('modules were deprecated in favor of '",
            "                                'blueprints.  Use request.blueprint '",
            "                                'instead.'), stacklevel=2)",
            "        if self._is_old_module:",
            "            return self.blueprint",
            "",
            "    @property",
            "    def blueprint(self):",
            "        \"\"\"The name of the current blueprint\"\"\"",
            "        if self.url_rule and '.' in self.url_rule.endpoint:",
            "            return self.url_rule.endpoint.rsplit('.', 1)[0]",
            "",
            "    @property",
            "    def json(self):",
            "        \"\"\"If the mimetype is :mimetype:`application/json` this will contain the",
            "        parsed JSON data.  Otherwise this will be ``None``.",
            "",
            "        The :meth:`get_json` method should be used instead.",
            "        \"\"\"",
            "        from warnings import warn",
            "        warn(DeprecationWarning('json is deprecated.  '",
            "                                'Use get_json() instead.'), stacklevel=2)",
            "        return self.get_json()",
            "",
            "    @property",
            "    def is_json(self):",
            "        \"\"\"Indicates if this request is JSON or not.  By default a request",
            "        is considered to include JSON data if the mimetype is",
            "        :mimetype:`application/json` or :mimetype:`application/*+json`.",
            "",
            "        .. versionadded:: 0.11",
            "        \"\"\"",
            "        mt = self.mimetype",
            "        if mt == 'application/json':",
            "            return True",
            "        if mt.startswith('application/') and mt.endswith('+json'):",
            "            return True",
            "        return False",
            "",
            "    def get_json(self, force=False, silent=False, cache=True):",
            "        \"\"\"Parses the incoming JSON request data and returns it.  By default",
            "        this function will return ``None`` if the mimetype is not",
            "        :mimetype:`application/json` but this can be overridden by the",
            "        ``force`` parameter. If parsing fails the",
            "        :meth:`on_json_loading_failed` method on the request object will be",
            "        invoked.",
            "",
            "        :param force: if set to ``True`` the mimetype is ignored.",
            "        :param silent: if set to ``True`` this method will fail silently",
            "                       and return ``None``.",
            "        :param cache: if set to ``True`` the parsed JSON data is remembered",
            "                      on the request.",
            "        \"\"\"",
            "        rv = getattr(self, '_cached_json', _missing)",
            "        # We return cached JSON only when the cache is enabled.",
            "        if cache and rv is not _missing:",
            "            return rv",
            "",
            "        if not (force or self.is_json):",
            "            return None",
            "",
            "        data = _get_data(self, cache)",
            "",
            "        try:",
            "            rv = json.loads(data)",
            "        except ValueError as e:",
            "            if silent:",
            "                rv = None",
            "            else:",
            "                rv = self.on_json_loading_failed(e)",
            "        if cache:",
            "            self._cached_json = rv",
            "        return rv",
            "",
            "    def on_json_loading_failed(self, e):",
            "        \"\"\"Called if decoding of the JSON data failed.  The return value of",
            "        this method is used by :meth:`get_json` when an error occurred.  The",
            "        default implementation just raises a :class:`BadRequest` exception.",
            "",
            "        .. versionchanged:: 0.10",
            "           Removed buggy previous behavior of generating a random JSON",
            "           response.  If you want that behavior back you can trivially",
            "           add it by subclassing.",
            "",
            "        .. versionadded:: 0.8",
            "        \"\"\"",
            "        ctx = _request_ctx_stack.top",
            "        if ctx is not None and ctx.app.config.get('DEBUG', False):",
            "            raise BadRequest('Failed to decode JSON object: {0}'.format(e))",
            "        raise BadRequest()",
            "",
            "    def _load_form_data(self):",
            "        RequestBase._load_form_data(self)",
            "",
            "        # In debug mode we're replacing the files multidict with an ad-hoc",
            "        # subclass that raises a different error for key errors.",
            "        ctx = _request_ctx_stack.top",
            "        if ctx is not None and ctx.app.debug and \\",
            "           self.mimetype != 'multipart/form-data' and not self.files:",
            "            from .debughelpers import attach_enctype_error_multidict",
            "            attach_enctype_error_multidict(self)",
            "",
            "",
            "class Response(ResponseBase):",
            "    \"\"\"The response object that is used by default in Flask.  Works like the",
            "    response object from Werkzeug but is set to have an HTML mimetype by",
            "    default.  Quite often you don't have to create this object yourself because",
            "    :meth:`~flask.Flask.make_response` will take care of that for you.",
            "",
            "    If you want to replace the response object used you can subclass this and",
            "    set :attr:`~flask.Flask.response_class` to your subclass.",
            "    \"\"\"",
            "    default_mimetype = 'text/html'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "147": [
                "Request",
                "get_json"
            ],
            "148": [
                "Request",
                "get_json"
            ],
            "149": [
                "Request",
                "get_json"
            ],
            "150": [
                "Request",
                "get_json"
            ],
            "151": [
                "Request",
                "get_json"
            ],
            "153": [
                "Request",
                "get_json"
            ],
            "154": [
                "Request",
                "get_json"
            ],
            "155": [
                "Request",
                "get_json"
            ],
            "156": [
                "Request",
                "get_json"
            ],
            "157": [
                "Request",
                "get_json"
            ]
        },
        "addLocation": []
    }
}