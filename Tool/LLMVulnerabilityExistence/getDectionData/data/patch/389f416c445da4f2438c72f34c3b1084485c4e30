{
    "vantage6-server/vantage6/server/globals.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " # pagination settings"
            },
            "1": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " DEFAULT_PAGE = 1"
            },
            "2": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " DEFAULT_PAGE_SIZE = 10"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+# default password policies"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+DEFAULT_MAX_FAILED_ATTEMPTS = 5"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+DEFAULT_INACTIVATION_MINUTES = 15"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES = 60"
            }
        },
        "frontPatchFile": [
            "from pathlib import Path",
            "",
            "from vantage6.common.globals import APPNAME",
            "",
            "#",
            "#   INSTALLATION SETTINGS",
            "#",
            "PACKAGE_FOLDER = Path(__file__).parent.parent.parent",
            "",
            "DATA_FOLDER = PACKAGE_FOLDER / APPNAME / \"server\" / \"_data\"",
            "",
            "SERVER_MODULE_NAME = APPNAME + \"-server\"",
            "",
            "#",
            "#   RUNTIME SETTINGS",
            "#",
            "",
            "# Expiretime of JWT tokens",
            "ACCESS_TOKEN_EXPIRES_HOURS = 6",
            "",
            "# minimum validity of JWT Tokens in seconds",
            "MIN_TOKEN_VALIDITY_SECONDS = 1800",
            "",
            "# Expiration time of refresh tokens",
            "REFRESH_TOKENS_EXPIRE_HOURS = 48",
            "",
            "# Minimum time in seconds that a refresh token must be valid *longer than* the",
            "# access token. This is to prevent the access token from expiring before the",
            "# refresh token.",
            "MIN_REFRESH_TOKEN_EXPIRY_DELTA = 1",
            "",
            "# Which resources should be initialized. These names correspond to the",
            "# file-names in the resource directory",
            "RESOURCES = ['node', 'collaboration', 'organization', 'task', 'run',",
            "             'token', 'user', 'version', 'recover', 'role',",
            "             'rule', 'health', 'vpn', 'port', 'event', 'ui.column']",
            "",
            "# Super user information. This user is only created if it is not in the",
            "# database yet at startup time.",
            "SUPER_USER_INFO = {",
            "    \"username\": \"root\",",
            "    \"password\": \"root\"",
            "}",
            "",
            "# default support email address to make users aware of",
            "DEFAULT_SUPPORT_EMAIL_ADDRESS = 'support@vantage6.ai'",
            "",
            "# default email address used in 'from' header",
            "DEFAULT_EMAIL_FROM_ADDRESS = 'noreply@vantage6.ai'",
            "",
            "# default time that token is valid in minutes",
            "DEFAULT_EMAILED_TOKEN_VALIDITY_MINUTES = 60",
            "",
            "# pagination settings",
            "DEFAULT_PAGE = 1",
            "DEFAULT_PAGE_SIZE = 10"
        ],
        "afterPatchFile": [
            "from pathlib import Path",
            "",
            "from vantage6.common.globals import APPNAME",
            "",
            "#",
            "#   INSTALLATION SETTINGS",
            "#",
            "PACKAGE_FOLDER = Path(__file__).parent.parent.parent",
            "",
            "DATA_FOLDER = PACKAGE_FOLDER / APPNAME / \"server\" / \"_data\"",
            "",
            "SERVER_MODULE_NAME = APPNAME + \"-server\"",
            "",
            "#",
            "#   RUNTIME SETTINGS",
            "#",
            "",
            "# Expiretime of JWT tokens",
            "ACCESS_TOKEN_EXPIRES_HOURS = 6",
            "",
            "# minimum validity of JWT Tokens in seconds",
            "MIN_TOKEN_VALIDITY_SECONDS = 1800",
            "",
            "# Expiration time of refresh tokens",
            "REFRESH_TOKENS_EXPIRE_HOURS = 48",
            "",
            "# Minimum time in seconds that a refresh token must be valid *longer than* the",
            "# access token. This is to prevent the access token from expiring before the",
            "# refresh token.",
            "MIN_REFRESH_TOKEN_EXPIRY_DELTA = 1",
            "",
            "# Which resources should be initialized. These names correspond to the",
            "# file-names in the resource directory",
            "RESOURCES = ['node', 'collaboration', 'organization', 'task', 'run',",
            "             'token', 'user', 'version', 'recover', 'role',",
            "             'rule', 'health', 'vpn', 'port', 'event', 'ui.column']",
            "",
            "# Super user information. This user is only created if it is not in the",
            "# database yet at startup time.",
            "SUPER_USER_INFO = {",
            "    \"username\": \"root\",",
            "    \"password\": \"root\"",
            "}",
            "",
            "# default support email address to make users aware of",
            "DEFAULT_SUPPORT_EMAIL_ADDRESS = 'support@vantage6.ai'",
            "",
            "# default email address used in 'from' header",
            "DEFAULT_EMAIL_FROM_ADDRESS = 'noreply@vantage6.ai'",
            "",
            "# default time that token is valid in minutes",
            "DEFAULT_EMAILED_TOKEN_VALIDITY_MINUTES = 60",
            "",
            "# pagination settings",
            "DEFAULT_PAGE = 1",
            "DEFAULT_PAGE_SIZE = 10",
            "",
            "# default password policies",
            "DEFAULT_MAX_FAILED_ATTEMPTS = 5",
            "DEFAULT_INACTIVATION_MINUTES = 15",
            "DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES = 60"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "vantage6-server/vantage6/server/model/user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     failed_login_attempts = Column(Integer, default=0)"
            },
            "1": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "     last_login_attempt = Column(DateTime)"
            },
            "2": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     otp_secret = Column(String(32))"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    last_email_failed_login_sent = Column(DateTime)"
            },
            "4": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     # relationships"
            },
            "6": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     organization = relationship(\"Organization\", back_populates=\"users\")"
            },
            "7": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         return False"
            },
            "8": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     def is_blocked(self, max_failed_attempts: int,"
            },
            "10": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                   inactivation_in_minutes: int) -> tuple[bool, str | None]:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+                   inactivation_in_minutes: int) -> tuple[bool, int | None]:"
            },
            "12": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         Check if user can login or if they are temporarily blocked because they"
            },
            "14": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         entered a wrong password too often"
            },
            "15": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         ----------"
            },
            "16": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         max_failed_attempts: int"
            },
            "17": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "             Maximum number of attempts to login before temporary deactivation"
            },
            "18": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        inactivation_minutes: int"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        inactivation_in_minutes: int"
            },
            "20": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             How many minutes an account is deactivated"
            },
            "21": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         Returns"
            },
            "23": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         -------"
            },
            "24": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         bool"
            },
            "25": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "             Whether or not user is blocked temporarily"
            },
            "26": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        str | None"
            },
            "27": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            Message if user is blocked, else None"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        int | None"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            How many minutes user is still blocked for"
            },
            "30": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         \"\"\""
            },
            "31": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)"
            },
            "32": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         td_last_login = dt.datetime.now() - self.last_login_attempt \\"
            },
            "33": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         session.commit()"
            },
            "34": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "         return result"
            },
            "35": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 216,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+    @classmethod"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+    def get_first_user(cls) -> User:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        \"\"\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        Get a random user by their username."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        This function is used to prevent an attacker from finding out which"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        usernames exist."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+        Returns"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        -------"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        User"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+            A random user that is in the database"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+        \"\"\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        session = DatabaseSessionManager.get_session()"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        result = session.query(cls).order_by(cls.id).first()"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        session.commit()"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        return result"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "     @classmethod"
            },
            "55": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "     def get_by_email(cls, email: str) -> User:"
            },
            "56": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "import bcrypt",
            "import datetime as dt",
            "",
            "from sqlalchemy import Column, String, Integer, ForeignKey, DateTime",
            "from sqlalchemy.orm import relationship, validates",
            "",
            "from vantage6.server.model.base import DatabaseSessionManager",
            "from vantage6.server.model.authenticatable import Authenticatable",
            "from vantage6.server.model.rule import Operation, Rule, Scope",
            "from vantage6.server.model.common.utils import validate_password",
            "",
            "",
            "class User(Authenticatable):",
            "    \"\"\"",
            "    Table to keep track of Users (persons) that can access the system.",
            "",
            "    Users always belong to an organization and can have certain",
            "    rights within an organization.",
            "",
            "    Attributes",
            "    ----------",
            "    username : str",
            "        Username of the user",
            "    password : str",
            "        Password of the user",
            "    firstname : str",
            "        First name of the user",
            "    lastname : str",
            "        Last name of the user",
            "    email : str",
            "        Email address of the user",
            "    organization_id : int",
            "        Foreign key to the organization to which the user belongs",
            "    failed_login_attempts : int",
            "        Number of failed login attempts",
            "    last_login_attempt : datetime.datetime",
            "        Date and time of the last login attempt",
            "    otp_secret : str",
            "        Secret key for one time passwords",
            "    organization : :class:`~.model.organization.Organization`",
            "        Organization to which the user belongs",
            "    roles : list[:class:`~.model.role.Role`]",
            "        Roles that the user has",
            "    rules : list[:class:`~.model.rule.Rule`]",
            "        Rules that the user has",
            "    created_tasks : list[:class:`~.model.task.Task`]",
            "        Tasks that the user has created",
            "    \"\"\"",
            "    _hidden_attributes = ['password']",
            "",
            "    # overwrite id with linked id to the authenticatable",
            "    id = Column(Integer, ForeignKey('authenticatable.id'), primary_key=True)",
            "    __mapper_args__ = {",
            "        'polymorphic_identity': 'user',",
            "    }",
            "",
            "    # fields",
            "    username = Column(String, unique=True)",
            "    password = Column(String)",
            "    firstname = Column(String)",
            "    lastname = Column(String)",
            "    email = Column(String, unique=True)",
            "    organization_id = Column(Integer, ForeignKey(\"organization.id\"))",
            "    failed_login_attempts = Column(Integer, default=0)",
            "    last_login_attempt = Column(DateTime)",
            "    otp_secret = Column(String(32))",
            "",
            "    # relationships",
            "    organization = relationship(\"Organization\", back_populates=\"users\")",
            "    roles = relationship(\"Role\", back_populates=\"users\",",
            "                         secondary=\"Permission\")",
            "    rules = relationship(\"Rule\", back_populates=\"users\",",
            "                         secondary=\"UserPermission\")",
            "    created_tasks = relationship(\"Task\", back_populates=\"init_user\")",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        String representation of the user.",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            String representation of the user",
            "        \"\"\"",
            "        organization = self.organization.name if self.organization else \"None\"",
            "        return (",
            "            f\"<User \"",
            "            f\"id={self.id}, username='{self.username}', roles='{self.roles}', \"",
            "            f\"organization='{organization}'\"",
            "            f\">\"",
            "        )",
            "",
            "    @validates(\"password\")",
            "    def _validate_password(self, key: str, password: str) -> str:",
            "        \"\"\"",
            "        Validate the password of the user by hashing it, as it is also hashed",
            "        in the database.",
            "",
            "        Parameters",
            "        ----------",
            "        key: str",
            "            Name of the attribute (in this case 'password')",
            "        password: str",
            "            Password of the user",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            Hashed password",
            "        \"\"\"",
            "        return self.hash(password)",
            "",
            "    def set_password(self, pw: str) -> str | None:",
            "        \"\"\"",
            "        Set the password of the current user. This function doesn't save the",
            "        new password to the database",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            The new password",
            "",
            "        Returns",
            "        -------",
            "        str | None",
            "            If the new password fails to pass the checks, a message is",
            "            returned. Else, none is returned",
            "        \"\"\"",
            "        try:",
            "            validate_password(pw)",
            "        except ValueError as e:",
            "            return str(e)",
            "",
            "        self.password = pw",
            "        self.save()",
            "",
            "    def check_password(self, pw: str) -> bool:",
            "        \"\"\"",
            "        Check if the password is correct",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            Password to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not the password is correct",
            "        \"\"\"",
            "        if self.password is not None:",
            "            expected_hash = self.password.encode('utf8')",
            "            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)",
            "        return False",
            "",
            "    def is_blocked(self, max_failed_attempts: int,",
            "                   inactivation_in_minutes: int) -> tuple[bool, str | None]:",
            "        \"\"\"",
            "        Check if user can login or if they are temporarily blocked because they",
            "        entered a wrong password too often",
            "",
            "        Parameters",
            "        ----------",
            "        max_failed_attempts: int",
            "            Maximum number of attempts to login before temporary deactivation",
            "        inactivation_minutes: int",
            "            How many minutes an account is deactivated",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is blocked temporarily",
            "        str | None",
            "            Message if user is blocked, else None",
            "        \"\"\"",
            "        td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)",
            "        td_last_login = dt.datetime.now() - self.last_login_attempt \\",
            "            if self.last_login_attempt else None",
            "        has_max_attempts = (",
            "            self.failed_login_attempts >= max_failed_attempts",
            "            if self.failed_login_attempts else False",
            "        )",
            "        if has_max_attempts and td_last_login < td_max_blocked:",
            "            minutes_remaining = \\",
            "                (td_max_blocked - td_last_login).seconds // 60 + 1",
            "            return True, minutes_remaining",
            "        else:",
            "            return False, None",
            "",
            "    @classmethod",
            "    def get_by_username(cls, username: str) -> User:",
            "        \"\"\"",
            "        Get a user by their username",
            "",
            "        Parameters",
            "        ----------",
            "        username: str",
            "            Username of the user",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            User with the given username",
            "",
            "        Raises",
            "        ------",
            "        NoResultFound",
            "            If no user with the given username exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(username=username).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_by_email(cls, email: str) -> User:",
            "        \"\"\"",
            "        Get a user by their email",
            "",
            "        Parameters",
            "        ----------",
            "        email: str",
            "            Email of the user",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            User with the given email",
            "",
            "        Raises",
            "        ------",
            "        NoResultFound",
            "            If no user with the given email exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(email=email).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def username_exists(cls, username) -> bool:",
            "        \"\"\"",
            "        Check if a user with the given username exists",
            "",
            "        Parameters",
            "        ----------",
            "        username: str",
            "            Username to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not a user with the given username exists",
            "        \"\"\"",
            "        return cls.exists(field='username', value=username)",
            "",
            "    def can(self, resource: str, scope: Scope, operation: Operation) -> bool:",
            "        \"\"\"",
            "        Check if user is allowed to execute a certain action",
            "",
            "        Parameters",
            "        ---------",
            "        resource: str",
            "            The resource type on which the action is to be performed",
            "        scope: Scope",
            "            The scope within which the user wants to perform an action",
            "        operation: Operation",
            "            The operation a user wants to execute",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is allowed to execute the requested operation",
            "            on the resource",
            "        \"\"\"",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        return rule in self.rules or \\",
            "            any(rule in role.rules for role in self.roles)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "import bcrypt",
            "import datetime as dt",
            "",
            "from sqlalchemy import Column, String, Integer, ForeignKey, DateTime",
            "from sqlalchemy.orm import relationship, validates",
            "",
            "from vantage6.server.model.base import DatabaseSessionManager",
            "from vantage6.server.model.authenticatable import Authenticatable",
            "from vantage6.server.model.rule import Operation, Rule, Scope",
            "from vantage6.server.model.common.utils import validate_password",
            "",
            "",
            "class User(Authenticatable):",
            "    \"\"\"",
            "    Table to keep track of Users (persons) that can access the system.",
            "",
            "    Users always belong to an organization and can have certain",
            "    rights within an organization.",
            "",
            "    Attributes",
            "    ----------",
            "    username : str",
            "        Username of the user",
            "    password : str",
            "        Password of the user",
            "    firstname : str",
            "        First name of the user",
            "    lastname : str",
            "        Last name of the user",
            "    email : str",
            "        Email address of the user",
            "    organization_id : int",
            "        Foreign key to the organization to which the user belongs",
            "    failed_login_attempts : int",
            "        Number of failed login attempts",
            "    last_login_attempt : datetime.datetime",
            "        Date and time of the last login attempt",
            "    otp_secret : str",
            "        Secret key for one time passwords",
            "    organization : :class:`~.model.organization.Organization`",
            "        Organization to which the user belongs",
            "    roles : list[:class:`~.model.role.Role`]",
            "        Roles that the user has",
            "    rules : list[:class:`~.model.rule.Rule`]",
            "        Rules that the user has",
            "    created_tasks : list[:class:`~.model.task.Task`]",
            "        Tasks that the user has created",
            "    \"\"\"",
            "    _hidden_attributes = ['password']",
            "",
            "    # overwrite id with linked id to the authenticatable",
            "    id = Column(Integer, ForeignKey('authenticatable.id'), primary_key=True)",
            "    __mapper_args__ = {",
            "        'polymorphic_identity': 'user',",
            "    }",
            "",
            "    # fields",
            "    username = Column(String, unique=True)",
            "    password = Column(String)",
            "    firstname = Column(String)",
            "    lastname = Column(String)",
            "    email = Column(String, unique=True)",
            "    organization_id = Column(Integer, ForeignKey(\"organization.id\"))",
            "    failed_login_attempts = Column(Integer, default=0)",
            "    last_login_attempt = Column(DateTime)",
            "    otp_secret = Column(String(32))",
            "    last_email_failed_login_sent = Column(DateTime)",
            "",
            "    # relationships",
            "    organization = relationship(\"Organization\", back_populates=\"users\")",
            "    roles = relationship(\"Role\", back_populates=\"users\",",
            "                         secondary=\"Permission\")",
            "    rules = relationship(\"Rule\", back_populates=\"users\",",
            "                         secondary=\"UserPermission\")",
            "    created_tasks = relationship(\"Task\", back_populates=\"init_user\")",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"",
            "        String representation of the user.",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            String representation of the user",
            "        \"\"\"",
            "        organization = self.organization.name if self.organization else \"None\"",
            "        return (",
            "            f\"<User \"",
            "            f\"id={self.id}, username='{self.username}', roles='{self.roles}', \"",
            "            f\"organization='{organization}'\"",
            "            f\">\"",
            "        )",
            "",
            "    @validates(\"password\")",
            "    def _validate_password(self, key: str, password: str) -> str:",
            "        \"\"\"",
            "        Validate the password of the user by hashing it, as it is also hashed",
            "        in the database.",
            "",
            "        Parameters",
            "        ----------",
            "        key: str",
            "            Name of the attribute (in this case 'password')",
            "        password: str",
            "            Password of the user",
            "",
            "        Returns",
            "        -------",
            "        str",
            "            Hashed password",
            "        \"\"\"",
            "        return self.hash(password)",
            "",
            "    def set_password(self, pw: str) -> str | None:",
            "        \"\"\"",
            "        Set the password of the current user. This function doesn't save the",
            "        new password to the database",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            The new password",
            "",
            "        Returns",
            "        -------",
            "        str | None",
            "            If the new password fails to pass the checks, a message is",
            "            returned. Else, none is returned",
            "        \"\"\"",
            "        try:",
            "            validate_password(pw)",
            "        except ValueError as e:",
            "            return str(e)",
            "",
            "        self.password = pw",
            "        self.save()",
            "",
            "    def check_password(self, pw: str) -> bool:",
            "        \"\"\"",
            "        Check if the password is correct",
            "",
            "        Parameters",
            "        ----------",
            "        pw: str",
            "            Password to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not the password is correct",
            "        \"\"\"",
            "        if self.password is not None:",
            "            expected_hash = self.password.encode('utf8')",
            "            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)",
            "        return False",
            "",
            "    def is_blocked(self, max_failed_attempts: int,",
            "                   inactivation_in_minutes: int) -> tuple[bool, int | None]:",
            "        \"\"\"",
            "        Check if user can login or if they are temporarily blocked because they",
            "        entered a wrong password too often",
            "",
            "        Parameters",
            "        ----------",
            "        max_failed_attempts: int",
            "            Maximum number of attempts to login before temporary deactivation",
            "        inactivation_in_minutes: int",
            "            How many minutes an account is deactivated",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is blocked temporarily",
            "        int | None",
            "            How many minutes user is still blocked for",
            "        \"\"\"",
            "        td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)",
            "        td_last_login = dt.datetime.now() - self.last_login_attempt \\",
            "            if self.last_login_attempt else None",
            "        has_max_attempts = (",
            "            self.failed_login_attempts >= max_failed_attempts",
            "            if self.failed_login_attempts else False",
            "        )",
            "        if has_max_attempts and td_last_login < td_max_blocked:",
            "            minutes_remaining = \\",
            "                (td_max_blocked - td_last_login).seconds // 60 + 1",
            "            return True, minutes_remaining",
            "        else:",
            "            return False, None",
            "",
            "    @classmethod",
            "    def get_by_username(cls, username: str) -> User:",
            "        \"\"\"",
            "        Get a user by their username",
            "",
            "        Parameters",
            "        ----------",
            "        username: str",
            "            Username of the user",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            User with the given username",
            "",
            "        Raises",
            "        ------",
            "        NoResultFound",
            "            If no user with the given username exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(username=username).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_first_user(cls) -> User:",
            "        \"\"\"",
            "        Get a random user by their username.",
            "",
            "        This function is used to prevent an attacker from finding out which",
            "        usernames exist.",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            A random user that is in the database",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).order_by(cls.id).first()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def get_by_email(cls, email: str) -> User:",
            "        \"\"\"",
            "        Get a user by their email",
            "",
            "        Parameters",
            "        ----------",
            "        email: str",
            "            Email of the user",
            "",
            "        Returns",
            "        -------",
            "        User",
            "            User with the given email",
            "",
            "        Raises",
            "        ------",
            "        NoResultFound",
            "            If no user with the given email exists",
            "        \"\"\"",
            "        session = DatabaseSessionManager.get_session()",
            "        result = session.query(cls).filter_by(email=email).one()",
            "        session.commit()",
            "        return result",
            "",
            "    @classmethod",
            "    def username_exists(cls, username) -> bool:",
            "        \"\"\"",
            "        Check if a user with the given username exists",
            "",
            "        Parameters",
            "        ----------",
            "        username: str",
            "            Username to check",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not a user with the given username exists",
            "        \"\"\"",
            "        return cls.exists(field='username', value=username)",
            "",
            "    def can(self, resource: str, scope: Scope, operation: Operation) -> bool:",
            "        \"\"\"",
            "        Check if user is allowed to execute a certain action",
            "",
            "        Parameters",
            "        ---------",
            "        resource: str",
            "            The resource type on which the action is to be performed",
            "        scope: Scope",
            "            The scope within which the user wants to perform an action",
            "        operation: Operation",
            "            The operation a user wants to execute",
            "",
            "        Returns",
            "        -------",
            "        bool",
            "            Whether or not user is allowed to execute the requested operation",
            "            on the resource",
            "        \"\"\"",
            "        rule = Rule.get_by_(resource, scope, operation)",
            "        return rule in self.rules or \\",
            "            any(rule in role.rules for role in self.roles)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "158": [
                "User",
                "is_blocked"
            ],
            "167": [
                "User",
                "is_blocked"
            ],
            "174": [
                "User",
                "is_blocked"
            ],
            "175": [
                "User",
                "is_blocked"
            ]
        },
        "addLocation": [
            "vantage6-server.vantage6.server.model.user.User.__mapper_args__",
            "vantage6-server.vantage6.server.model.user.User.self",
            "vantage6-server.vantage6.server.model.user.User._hidden_attributes"
        ]
    },
    "vantage6-server/vantage6/server/resource/common/auth_helper.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import sys"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import logging"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import datetime as dt"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import pyotp"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from http import HTTPStatus"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask import request, render_template"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from flask import request, render_template, current_app, Flask"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from flask_mail import Mail"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from threading import Thread"
            },
            "10": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from vantage6.common.globals import APPNAME, MAIN_VERSION_NAME"
            },
            "12": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from vantage6.server.globals import ("
            },
            "13": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    DEFAULT_SUPPORT_EMAIL_ADDRESS, DEFAULT_EMAIL_FROM_ADDRESS"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    DEFAULT_SUPPORT_EMAIL_ADDRESS, DEFAULT_MAX_FAILED_ATTEMPTS,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    DEFAULT_INACTIVATION_MINUTES, DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    DEFAULT_EMAIL_FROM_ADDRESS"
            },
            "17": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " )"
            },
            "18": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from vantage6.server.model.user import User"
            },
            "19": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     HTTPStatus:"
            },
            "21": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         Status code that the current request should return"
            },
            "22": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    log.info(f\"Trying to login '{username}'\")"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    log.info(\"Trying to login '%s'\", username)"
            },
            "25": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     failed_login_msg = \"Failed to login\""
            },
            "26": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if User.username_exists(username):"
            },
            "27": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user = User.get_by_username(username)"
            },
            "28": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        password_policy = config.get(\"password_policy\", {})"
            },
            "29": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        max_failed_attempts = password_policy.get('max_failed_attempts', 5)"
            },
            "30": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        inactivation_time = password_policy.get('inactivation_minutes', 15)"
            },
            "31": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "32": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        is_blocked, min_rem = user.is_blocked(max_failed_attempts,"
            },
            "33": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                              inactivation_time)"
            },
            "34": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if is_blocked:"
            },
            "35": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            notify_user_blocked(user, max_failed_attempts, min_rem, mail,"
            },
            "36": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                config)"
            },
            "37": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED"
            },
            "38": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif user.check_password(password):"
            },
            "39": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user.failed_login_attempts = 0"
            },
            "40": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user.save()"
            },
            "41": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return user, HTTPStatus.OK"
            },
            "42": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "43": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # update the number of failed login attempts"
            },
            "44": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user.failed_login_attempts = 1 \\"
            },
            "45": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if ("
            },
            "46": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    not user.failed_login_attempts or"
            },
            "47": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    user.failed_login_attempts >= max_failed_attempts"
            },
            "48": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                ) else user.failed_login_attempts + 1"
            },
            "49": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user.last_login_attempt = dt.datetime.now()"
            },
            "50": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user.save()"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    # check if username exists. If it does not, we continue anyway, to prevent"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    # that an attacker can find out which usernames exist via a timing attack."
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    # In that case, we fetch the first user as random user."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    username_exists = User.username_exists(username)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    random_username = User.get_first_user().username"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    user = User.get_by_username(username) if username_exists \\"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        else User.get_by_username(random_username)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    password_policy = config.get(\"password_policy\", {})"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    max_failed_attempts = password_policy.get("
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    )"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    inactivation_time = password_policy.get("
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        'inactivation_minutes', DEFAULT_INACTIVATION_MINUTES"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    )"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    is_blocked, min_rem = user.is_blocked(max_failed_attempts,"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                                          inactivation_time)"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+    if user.check_password(password) and not is_blocked and username_exists:"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        # Note: above the username_exists is checked to prevent that an"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        # attacker happens to get the correct password for the random user"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        # that is returned when the username does not exist. Note also that"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        # the password is checked first to keep the timing equal for both."
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        user.failed_login_attempts = 0"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        user.save()"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        return user, HTTPStatus.OK"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    # Handle database updates required upon failed login in a separate thread"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    # to ensure similar response times"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+    # pylint: disable=W0212"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    t1 = Thread(target=__handle_failed_login, args=("
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        current_app._get_current_object(), username_exists, username,"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        password_policy, is_blocked, min_rem, mail, config,"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        request.access_route[-1]"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+    ))"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+    t1.start()"
            },
            "89": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " "
            },
            "90": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED"
            },
            "91": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "93": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def notify_user_blocked("
            },
            "94": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    user: User, max_n_attempts: int, min_rem: int, mail: Mail,"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+def __handle_failed_login("
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+    app: Flask, user_exists: bool, username: str, password_policy: dict,"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+    is_blocked: bool, min_rem: int, mail: Mail, config: dict, ip: str"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+) -> None:"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    \"\"\""
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    When a user login fails, this function is called to update the database"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    with the failed login attempt and send an email to the user if necessary."
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    Note that this function is called in a separate thread to keep response"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    times for login attempts similar in all cases. Therefore, this function"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    calls `sys.exit()` to terminate the thread."
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+    Parameters"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+    ----------"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    app: flask.Flask"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        The current Flask app"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    user_exists: bool"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        Whether user exists or not"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+    username: str"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        Username of the user that failed to login"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+    password_policy: dict"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        Dictionary with password policy settings."
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    min_rem: int"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        Number of minutes remaining before the account is unlocked"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+    mail: flask_mail.Mail"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        An instance of the Flask mail class. Used to send email to user in case"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        of too many failed login attempts."
            },
            "122": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "     config: dict"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        Dictionary with configuration settings"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    ip: str"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        IP address from where the login attempt was made"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+    \"\"\""
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    if not user_exists:"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        sys.exit()"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    # get user object again (required because we are in a new thread)"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+    user = User.get_by_username(username)"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    max_failed_attempts = password_policy.get("
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    )"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+    if is_blocked:"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        # alert the user via email that they are blocked"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        __notify_user_blocked(app, user, min_rem, mail, config, ip)"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        sys.exit()"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    elif ("
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        not user.failed_login_attempts or"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        user.failed_login_attempts >= max_failed_attempts"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    ):"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        # set failed login attempts to 1 if first failed login attempt or if"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        # user got unblocked after being blocked previously"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        user.failed_login_attempts = 1"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    else:"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        user.failed_login_attempts += 1"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    user.last_login_attempt = dt.datetime.now()"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    user.save()"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+    sys.exit()"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+def __notify_user_blocked("
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    app: Flask, user: User, min_rem: int, mail: Mail, config: dict, ip: str"
            },
            "156": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " ) -> None:"
            },
            "157": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "     \"\"\""
            },
            "158": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Sends an email to the user when his or her account is locked"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+    Sends an email to the user when their account is locked."
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+    This function also checks that emails are not sent too often to the same"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    user."
            },
            "163": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " "
            },
            "164": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "     Parameters"
            },
            "165": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "     ----------"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+    app: flask.Flask"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        The current Flask app"
            },
            "168": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     user: :class:`~vantage6.server.model.user.User`"
            },
            "169": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         User who is temporarily blocked"
            },
            "170": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    max_n_attempts: int"
            },
            "171": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Maximum number of failed login attempts before the account is locked"
            },
            "172": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "     min_rem: int"
            },
            "173": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         Number of minutes remaining before the account is unlocked"
            },
            "174": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     mail: flask_mail.Mail"
            },
            "175": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         An instance of the Flask mail class. Used to send email to user in case"
            },
            "176": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         of too many failed login attempts."
            },
            "177": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     config: dict"
            },
            "178": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         Dictionary with configuration settings"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    ip: str"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        IP address from where the login attempt was made"
            },
            "181": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     \"\"\""
            },
            "182": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not user.email:"
            },
            "183": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        log.warning(f'User {user.username} is locked, but does not have'"
            },
            "184": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    'an email registered. So no message has been sent.')"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+    log.info('User %s is locked. Sending them an email.', user.username)"
            },
            "186": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " "
            },
            "187": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    log.info(f'User {user.username} is locked. Sending them an email.')"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+    # check that email has not already been sent recently"
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+    password_policy = config.get(\"password_policy\", {})"
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+    minutes_between_blocked_emails = password_policy.get("
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        'between_email_blocked_login_minutes',"
            },
            "192": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES"
            },
            "193": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+    )"
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+    email_sent_recently = user.last_email_failed_login_sent and ("
            },
            "195": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        dt.datetime.now() < user.last_email_failed_login_sent +"
            },
            "196": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        dt.timedelta(minutes=minutes_between_blocked_emails)"
            },
            "197": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+    )"
            },
            "198": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+    if email_sent_recently:"
            },
            "199": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        return"
            },
            "200": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "201": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+    # send email"
            },
            "202": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "     smtp_settings = config.get(\"smtp\", {})"
            },
            "203": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "     email_from = smtp_settings.get(\"email_from\", DEFAULT_EMAIL_FROM_ADDRESS)"
            },
            "204": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "     support_email = config.get(\"support_email\", DEFAULT_SUPPORT_EMAIL_ADDRESS)"
            },
            "205": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 194,
                "PatchRowcode": " "
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+    max_failed_attempts = password_policy.get("
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS"
            },
            "208": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+    )"
            },
            "209": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "     template_vars = {"
            },
            "210": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'firstname': user.firstname,"
            },
            "211": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'number_of_allowed_attempts': max_n_attempts,"
            },
            "212": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'ip': request.access_route[-1],"
            },
            "213": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        'firstname': user.firstname if user.firstname else user.username,"
            },
            "214": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        'number_of_allowed_attempts': max_failed_attempts,"
            },
            "215": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        'ip': ip,"
            },
            "216": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         'time': dt.datetime.now(dt.timezone.utc),"
            },
            "217": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         'time_remaining': min_rem,"
            },
            "218": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         'support_email': support_email,"
            },
            "219": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "     }"
            },
            "220": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 206,
                "PatchRowcode": " "
            },
            "221": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    mail.send_email("
            },
            "222": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"Failed login attempts on your vantage6 account\","
            },
            "223": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sender=email_from,"
            },
            "224": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        recipients=[user.email],"
            },
            "225": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        text_body=render_template(\"mail/blocked_account.txt\", **template_vars),"
            },
            "226": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        html_body=render_template(\"mail/blocked_account.html\", **template_vars)"
            },
            "227": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    )"
            },
            "228": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+    with app.app_context():"
            },
            "229": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        mail.send_email("
            },
            "230": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+            \"Failed login attempts on your vantage6 account\","
            },
            "231": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+            sender=email_from,"
            },
            "232": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+            recipients=[user.email],"
            },
            "233": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+            text_body=render_template("
            },
            "234": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                \"mail/blocked_account.txt\", **template_vars"
            },
            "235": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+            ),"
            },
            "236": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            html_body=render_template("
            },
            "237": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+                \"mail/blocked_account.html\", **template_vars"
            },
            "238": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            )"
            },
            "239": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        )"
            },
            "240": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+"
            },
            "241": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+    # Update latest email sent timestamp"
            },
            "242": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+    user.last_email_failed_login_sent = dt.datetime.now()"
            },
            "243": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+    user.save()"
            },
            "244": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 223,
                "PatchRowcode": " "
            },
            "245": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 224,
                "PatchRowcode": " "
            },
            "246": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 225,
                "PatchRowcode": " def create_qr_uri(user: User) -> dict:"
            }
        },
        "frontPatchFile": [
            "import logging",
            "import datetime as dt",
            "import pyotp",
            "",
            "from http import HTTPStatus",
            "from flask import request, render_template",
            "from flask_mail import Mail",
            "",
            "from vantage6.common.globals import APPNAME, MAIN_VERSION_NAME",
            "from vantage6.server.globals import (",
            "    DEFAULT_SUPPORT_EMAIL_ADDRESS, DEFAULT_EMAIL_FROM_ADDRESS",
            ")",
            "from vantage6.server.model.user import User",
            "",
            "module_name = __name__.split('.')[-1]",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "def user_login(",
            "    config: dict, username: str, password: str, mail: Mail",
            ") -> tuple[dict | User, HTTPStatus]:",
            "    \"\"\"",
            "    Returns user a message in case of failed login attempt.",
            "",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    username: str",
            "        Username of user to be logged in",
            "    password: str",
            "        Password of user to be logged in",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "",
            "    Returns",
            "    -------",
            "    :class:`~vantage6.server.model.user.User` or dict:",
            "        User SQLAlchemy model if user is logged in, otherwise dictionary with",
            "        error message",
            "    HTTPStatus:",
            "        Status code that the current request should return",
            "    \"\"\"",
            "    log.info(f\"Trying to login '{username}'\")",
            "    failed_login_msg = \"Failed to login\"",
            "    if User.username_exists(username):",
            "        user = User.get_by_username(username)",
            "        password_policy = config.get(\"password_policy\", {})",
            "        max_failed_attempts = password_policy.get('max_failed_attempts', 5)",
            "        inactivation_time = password_policy.get('inactivation_minutes', 15)",
            "",
            "        is_blocked, min_rem = user.is_blocked(max_failed_attempts,",
            "                                              inactivation_time)",
            "        if is_blocked:",
            "            notify_user_blocked(user, max_failed_attempts, min_rem, mail,",
            "                                config)",
            "            return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED",
            "        elif user.check_password(password):",
            "            user.failed_login_attempts = 0",
            "            user.save()",
            "            return user, HTTPStatus.OK",
            "        else:",
            "            # update the number of failed login attempts",
            "            user.failed_login_attempts = 1 \\",
            "                if (",
            "                    not user.failed_login_attempts or",
            "                    user.failed_login_attempts >= max_failed_attempts",
            "                ) else user.failed_login_attempts + 1",
            "            user.last_login_attempt = dt.datetime.now()",
            "            user.save()",
            "",
            "    return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED",
            "",
            "",
            "def notify_user_blocked(",
            "    user: User, max_n_attempts: int, min_rem: int, mail: Mail,",
            "    config: dict",
            ") -> None:",
            "    \"\"\"",
            "    Sends an email to the user when his or her account is locked",
            "",
            "    Parameters",
            "    ----------",
            "    user: :class:`~vantage6.server.model.user.User`",
            "        User who is temporarily blocked",
            "    max_n_attempts: int",
            "        Maximum number of failed login attempts before the account is locked",
            "    min_rem: int",
            "        Number of minutes remaining before the account is unlocked",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    \"\"\"",
            "    if not user.email:",
            "        log.warning(f'User {user.username} is locked, but does not have'",
            "                    'an email registered. So no message has been sent.')",
            "",
            "    log.info(f'User {user.username} is locked. Sending them an email.')",
            "",
            "    smtp_settings = config.get(\"smtp\", {})",
            "    email_from = smtp_settings.get(\"email_from\", DEFAULT_EMAIL_FROM_ADDRESS)",
            "    support_email = config.get(\"support_email\", DEFAULT_SUPPORT_EMAIL_ADDRESS)",
            "",
            "    template_vars = {",
            "        'firstname': user.firstname,",
            "        'number_of_allowed_attempts': max_n_attempts,",
            "        'ip': request.access_route[-1],",
            "        'time': dt.datetime.now(dt.timezone.utc),",
            "        'time_remaining': min_rem,",
            "        'support_email': support_email,",
            "    }",
            "",
            "    mail.send_email(",
            "        \"Failed login attempts on your vantage6 account\",",
            "        sender=email_from,",
            "        recipients=[user.email],",
            "        text_body=render_template(\"mail/blocked_account.txt\", **template_vars),",
            "        html_body=render_template(\"mail/blocked_account.html\", **template_vars)",
            "    )",
            "",
            "",
            "def create_qr_uri(user: User) -> dict:",
            "    \"\"\"",
            "    Create the URI to generate a QR code for authenticator apps",
            "",
            "    Parameters",
            "    ----------",
            "    user: :class:`~vantage6.server.model.user.User`",
            "        User for whom two-factor authentication is to be set up",
            "",
            "    Returns",
            "    -------",
            "    dict",
            "        Dictionary with information on the TOTP secret required to generate",
            "        a QR code or to enter it manually in an authenticator app",
            "    \"\"\"",
            "    otp_secret = pyotp.random_base32()",
            "    qr_uri = pyotp.totp.TOTP(otp_secret).provisioning_uri(",
            "        name=user.username, issuer_name=f\"{APPNAME} ({MAIN_VERSION_NAME})\"",
            "    )",
            "    user.otp_secret = otp_secret",
            "    user.save()",
            "    return {",
            "        'qr_uri': qr_uri,",
            "        'otp_secret': otp_secret,",
            "        'msg': ('Two-factor authentication is obligatory on this server. '",
            "                'Please visualize the QR code to set up authentication.')",
            "    }"
        ],
        "afterPatchFile": [
            "import sys",
            "import logging",
            "import datetime as dt",
            "import pyotp",
            "",
            "from http import HTTPStatus",
            "from flask import request, render_template, current_app, Flask",
            "from flask_mail import Mail",
            "from threading import Thread",
            "",
            "from vantage6.common.globals import APPNAME, MAIN_VERSION_NAME",
            "from vantage6.server.globals import (",
            "    DEFAULT_SUPPORT_EMAIL_ADDRESS, DEFAULT_MAX_FAILED_ATTEMPTS,",
            "    DEFAULT_INACTIVATION_MINUTES, DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES,",
            "    DEFAULT_EMAIL_FROM_ADDRESS",
            ")",
            "from vantage6.server.model.user import User",
            "",
            "module_name = __name__.split('.')[-1]",
            "log = logging.getLogger(module_name)",
            "",
            "",
            "def user_login(",
            "    config: dict, username: str, password: str, mail: Mail",
            ") -> tuple[dict | User, HTTPStatus]:",
            "    \"\"\"",
            "    Returns user a message in case of failed login attempt.",
            "",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    username: str",
            "        Username of user to be logged in",
            "    password: str",
            "        Password of user to be logged in",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "",
            "    Returns",
            "    -------",
            "    :class:`~vantage6.server.model.user.User` or dict:",
            "        User SQLAlchemy model if user is logged in, otherwise dictionary with",
            "        error message",
            "    HTTPStatus:",
            "        Status code that the current request should return",
            "    \"\"\"",
            "    log.info(\"Trying to login '%s'\", username)",
            "    failed_login_msg = \"Failed to login\"",
            "",
            "    # check if username exists. If it does not, we continue anyway, to prevent",
            "    # that an attacker can find out which usernames exist via a timing attack.",
            "    # In that case, we fetch the first user as random user.",
            "    username_exists = User.username_exists(username)",
            "    random_username = User.get_first_user().username",
            "    user = User.get_by_username(username) if username_exists \\",
            "        else User.get_by_username(random_username)",
            "",
            "    password_policy = config.get(\"password_policy\", {})",
            "    max_failed_attempts = password_policy.get(",
            "        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "    inactivation_time = password_policy.get(",
            "        'inactivation_minutes', DEFAULT_INACTIVATION_MINUTES",
            "    )",
            "",
            "    is_blocked, min_rem = user.is_blocked(max_failed_attempts,",
            "                                          inactivation_time)",
            "",
            "    if user.check_password(password) and not is_blocked and username_exists:",
            "        # Note: above the username_exists is checked to prevent that an",
            "        # attacker happens to get the correct password for the random user",
            "        # that is returned when the username does not exist. Note also that",
            "        # the password is checked first to keep the timing equal for both.",
            "        user.failed_login_attempts = 0",
            "        user.save()",
            "        return user, HTTPStatus.OK",
            "",
            "    # Handle database updates required upon failed login in a separate thread",
            "    # to ensure similar response times",
            "    # pylint: disable=W0212",
            "    t1 = Thread(target=__handle_failed_login, args=(",
            "        current_app._get_current_object(), username_exists, username,",
            "        password_policy, is_blocked, min_rem, mail, config,",
            "        request.access_route[-1]",
            "    ))",
            "    t1.start()",
            "",
            "    return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED",
            "",
            "",
            "def __handle_failed_login(",
            "    app: Flask, user_exists: bool, username: str, password_policy: dict,",
            "    is_blocked: bool, min_rem: int, mail: Mail, config: dict, ip: str",
            ") -> None:",
            "    \"\"\"",
            "    When a user login fails, this function is called to update the database",
            "    with the failed login attempt and send an email to the user if necessary.",
            "",
            "    Note that this function is called in a separate thread to keep response",
            "    times for login attempts similar in all cases. Therefore, this function",
            "    calls `sys.exit()` to terminate the thread.",
            "",
            "    Parameters",
            "    ----------",
            "    app: flask.Flask",
            "        The current Flask app",
            "    user_exists: bool",
            "        Whether user exists or not",
            "    username: str",
            "        Username of the user that failed to login",
            "    password_policy: dict",
            "        Dictionary with password policy settings.",
            "    min_rem: int",
            "        Number of minutes remaining before the account is unlocked",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    ip: str",
            "        IP address from where the login attempt was made",
            "    \"\"\"",
            "    if not user_exists:",
            "        sys.exit()",
            "    # get user object again (required because we are in a new thread)",
            "    user = User.get_by_username(username)",
            "",
            "    max_failed_attempts = password_policy.get(",
            "        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "",
            "    if is_blocked:",
            "        # alert the user via email that they are blocked",
            "        __notify_user_blocked(app, user, min_rem, mail, config, ip)",
            "        sys.exit()",
            "    elif (",
            "        not user.failed_login_attempts or",
            "        user.failed_login_attempts >= max_failed_attempts",
            "    ):",
            "        # set failed login attempts to 1 if first failed login attempt or if",
            "        # user got unblocked after being blocked previously",
            "        user.failed_login_attempts = 1",
            "    else:",
            "        user.failed_login_attempts += 1",
            "    user.last_login_attempt = dt.datetime.now()",
            "    user.save()",
            "    sys.exit()",
            "",
            "",
            "def __notify_user_blocked(",
            "    app: Flask, user: User, min_rem: int, mail: Mail, config: dict, ip: str",
            ") -> None:",
            "    \"\"\"",
            "    Sends an email to the user when their account is locked.",
            "",
            "    This function also checks that emails are not sent too often to the same",
            "    user.",
            "",
            "    Parameters",
            "    ----------",
            "    app: flask.Flask",
            "        The current Flask app",
            "    user: :class:`~vantage6.server.model.user.User`",
            "        User who is temporarily blocked",
            "    min_rem: int",
            "        Number of minutes remaining before the account is unlocked",
            "    mail: flask_mail.Mail",
            "        An instance of the Flask mail class. Used to send email to user in case",
            "        of too many failed login attempts.",
            "    config: dict",
            "        Dictionary with configuration settings",
            "    ip: str",
            "        IP address from where the login attempt was made",
            "    \"\"\"",
            "    log.info('User %s is locked. Sending them an email.', user.username)",
            "",
            "    # check that email has not already been sent recently",
            "    password_policy = config.get(\"password_policy\", {})",
            "    minutes_between_blocked_emails = password_policy.get(",
            "        'between_email_blocked_login_minutes',",
            "        DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES",
            "    )",
            "    email_sent_recently = user.last_email_failed_login_sent and (",
            "        dt.datetime.now() < user.last_email_failed_login_sent +",
            "        dt.timedelta(minutes=minutes_between_blocked_emails)",
            "    )",
            "    if email_sent_recently:",
            "        return",
            "",
            "    # send email",
            "    smtp_settings = config.get(\"smtp\", {})",
            "    email_from = smtp_settings.get(\"email_from\", DEFAULT_EMAIL_FROM_ADDRESS)",
            "    support_email = config.get(\"support_email\", DEFAULT_SUPPORT_EMAIL_ADDRESS)",
            "",
            "    max_failed_attempts = password_policy.get(",
            "        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS",
            "    )",
            "    template_vars = {",
            "        'firstname': user.firstname if user.firstname else user.username,",
            "        'number_of_allowed_attempts': max_failed_attempts,",
            "        'ip': ip,",
            "        'time': dt.datetime.now(dt.timezone.utc),",
            "        'time_remaining': min_rem,",
            "        'support_email': support_email,",
            "    }",
            "",
            "    with app.app_context():",
            "        mail.send_email(",
            "            \"Failed login attempts on your vantage6 account\",",
            "            sender=email_from,",
            "            recipients=[user.email],",
            "            text_body=render_template(",
            "                \"mail/blocked_account.txt\", **template_vars",
            "            ),",
            "            html_body=render_template(",
            "                \"mail/blocked_account.html\", **template_vars",
            "            )",
            "        )",
            "",
            "    # Update latest email sent timestamp",
            "    user.last_email_failed_login_sent = dt.datetime.now()",
            "    user.save()",
            "",
            "",
            "def create_qr_uri(user: User) -> dict:",
            "    \"\"\"",
            "    Create the URI to generate a QR code for authenticator apps",
            "",
            "    Parameters",
            "    ----------",
            "    user: :class:`~vantage6.server.model.user.User`",
            "        User for whom two-factor authentication is to be set up",
            "",
            "    Returns",
            "    -------",
            "    dict",
            "        Dictionary with information on the TOTP secret required to generate",
            "        a QR code or to enter it manually in an authenticator app",
            "    \"\"\"",
            "    otp_secret = pyotp.random_base32()",
            "    qr_uri = pyotp.totp.TOTP(otp_secret).provisioning_uri(",
            "        name=user.username, issuer_name=f\"{APPNAME} ({MAIN_VERSION_NAME})\"",
            "    )",
            "    user.otp_secret = otp_secret",
            "    user.save()",
            "    return {",
            "        'qr_uri': qr_uri,",
            "        'otp_secret': otp_secret,",
            "        'msg': ('Two-factor authentication is obligatory on this server. '",
            "                'Please visualize the QR code to set up authentication.')",
            "    }"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "11": [],
            "43": [
                "user_login"
            ],
            "45": [
                "user_login"
            ],
            "46": [
                "user_login"
            ],
            "47": [
                "user_login"
            ],
            "48": [
                "user_login"
            ],
            "49": [
                "user_login"
            ],
            "50": [
                "user_login"
            ],
            "51": [
                "user_login"
            ],
            "52": [
                "user_login"
            ],
            "53": [
                "user_login"
            ],
            "54": [
                "user_login"
            ],
            "55": [
                "user_login"
            ],
            "56": [
                "user_login"
            ],
            "57": [
                "user_login"
            ],
            "58": [
                "user_login"
            ],
            "59": [
                "user_login"
            ],
            "60": [
                "user_login"
            ],
            "61": [
                "user_login"
            ],
            "62": [
                "user_login"
            ],
            "63": [
                "user_login"
            ],
            "64": [
                "user_login"
            ],
            "65": [
                "user_login"
            ],
            "66": [
                "user_login"
            ],
            "67": [
                "user_login"
            ],
            "68": [
                "user_login"
            ],
            "69": [
                "user_login"
            ],
            "74": [
                "notify_user_blocked"
            ],
            "75": [
                "notify_user_blocked"
            ],
            "79": [
                "notify_user_blocked"
            ],
            "85": [
                "notify_user_blocked"
            ],
            "86": [
                "notify_user_blocked"
            ],
            "95": [
                "notify_user_blocked"
            ],
            "96": [
                "notify_user_blocked"
            ],
            "97": [
                "notify_user_blocked"
            ],
            "99": [
                "notify_user_blocked"
            ],
            "106": [
                "notify_user_blocked"
            ],
            "107": [
                "notify_user_blocked"
            ],
            "108": [
                "notify_user_blocked"
            ],
            "114": [
                "notify_user_blocked"
            ],
            "115": [
                "notify_user_blocked"
            ],
            "116": [
                "notify_user_blocked"
            ],
            "117": [
                "notify_user_blocked"
            ],
            "118": [
                "notify_user_blocked"
            ],
            "119": [
                "notify_user_blocked"
            ],
            "120": [
                "notify_user_blocked"
            ]
        },
        "addLocation": []
    }
}