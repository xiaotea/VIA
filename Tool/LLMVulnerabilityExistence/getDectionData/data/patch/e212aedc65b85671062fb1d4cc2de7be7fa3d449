{
    "airflow/api_connexion/endpoints/dag_warning_endpoint.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from airflow.models.dagwarning import DagWarning as DagWarningModel"
            },
            "1": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from airflow.security import permissions"
            },
            "2": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from airflow.utils.airflow_flask_app import get_airflow_app"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+from airflow.utils.db import get_query_count"
            },
            "4": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from airflow.utils.session import NEW_SESSION, provide_session"
            },
            "5": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " if TYPE_CHECKING:"
            },
            "7": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         if not get_airflow_app().appbuilder.sm.can_read_dag(dag_id, g.user):"
            },
            "8": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "             raise PermissionDenied(detail=f\"User not allowed to access this DAG: {dag_id}\")"
            },
            "9": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         query = query.where(DagWarningModel.dag_id == dag_id)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    else:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        readable_dags = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        query = query.where(DagWarningModel.dag_id.in_(readable_dags))"
            },
            "13": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     if warning_type:"
            },
            "14": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         query = query.where(DagWarningModel.warning_type == warning_type)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    total_entries = get_query_count(query, session=session)"
            },
            "16": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     query = apply_sorting(query=query, order_by=order_by, allowed_attrs=allowed_filter_attrs)"
            },
            "17": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     dag_warnings = session.scalars(query.offset(offset).limit(limit)).all()"
            },
            "18": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not dag_id:"
            },
            "19": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        dag_warnings = ["
            },
            "20": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dag_warning"
            },
            "21": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for dag_warning in dag_warnings"
            },
            "22": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if get_airflow_app().appbuilder.sm.can_read_dag(dag_warning.dag_id, g.user)"
            },
            "23": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ]"
            },
            "24": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    total_entries = len(dag_warnings)"
            },
            "25": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     return dag_warning_collection_schema.dump("
            },
            "26": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         DagWarningCollection(dag_warnings=dag_warnings, total_entries=total_entries)"
            },
            "27": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     )"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from typing import TYPE_CHECKING",
            "",
            "from flask import g",
            "from sqlalchemy import select",
            "",
            "from airflow.api_connexion import security",
            "from airflow.api_connexion.exceptions import PermissionDenied",
            "from airflow.api_connexion.parameters import apply_sorting, check_limit, format_parameters",
            "from airflow.api_connexion.schemas.dag_warning_schema import (",
            "    DagWarningCollection,",
            "    dag_warning_collection_schema,",
            ")",
            "from airflow.models.dagwarning import DagWarning as DagWarningModel",
            "from airflow.security import permissions",
            "from airflow.utils.airflow_flask_app import get_airflow_app",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "",
            "if TYPE_CHECKING:",
            "    from sqlalchemy.orm import Session",
            "",
            "    from airflow.api_connexion.types import APIResponse",
            "",
            "",
            "@security.requires_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_WARNING)])",
            "@format_parameters({\"limit\": check_limit})",
            "@provide_session",
            "def get_dag_warnings(",
            "    *,",
            "    limit: int,",
            "    dag_id: str | None = None,",
            "    warning_type: str | None = None,",
            "    offset: int | None = None,",
            "    order_by: str = \"timestamp\",",
            "    session: Session = NEW_SESSION,",
            ") -> APIResponse:",
            "    \"\"\"Get DAG warnings.",
            "",
            "    :param dag_id: the dag_id to optionally filter by",
            "    :param warning_type: the warning type to optionally filter by",
            "    \"\"\"",
            "    allowed_filter_attrs = [\"dag_id\", \"warning_type\", \"message\", \"timestamp\"]",
            "    query = select(DagWarningModel)",
            "    if dag_id:",
            "        if not get_airflow_app().appbuilder.sm.can_read_dag(dag_id, g.user):",
            "            raise PermissionDenied(detail=f\"User not allowed to access this DAG: {dag_id}\")",
            "        query = query.where(DagWarningModel.dag_id == dag_id)",
            "    if warning_type:",
            "        query = query.where(DagWarningModel.warning_type == warning_type)",
            "    query = apply_sorting(query=query, order_by=order_by, allowed_attrs=allowed_filter_attrs)",
            "    dag_warnings = session.scalars(query.offset(offset).limit(limit)).all()",
            "    if not dag_id:",
            "        dag_warnings = [",
            "            dag_warning",
            "            for dag_warning in dag_warnings",
            "            if get_airflow_app().appbuilder.sm.can_read_dag(dag_warning.dag_id, g.user)",
            "        ]",
            "    total_entries = len(dag_warnings)",
            "    return dag_warning_collection_schema.dump(",
            "        DagWarningCollection(dag_warnings=dag_warnings, total_entries=total_entries)",
            "    )"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from typing import TYPE_CHECKING",
            "",
            "from flask import g",
            "from sqlalchemy import select",
            "",
            "from airflow.api_connexion import security",
            "from airflow.api_connexion.exceptions import PermissionDenied",
            "from airflow.api_connexion.parameters import apply_sorting, check_limit, format_parameters",
            "from airflow.api_connexion.schemas.dag_warning_schema import (",
            "    DagWarningCollection,",
            "    dag_warning_collection_schema,",
            ")",
            "from airflow.models.dagwarning import DagWarning as DagWarningModel",
            "from airflow.security import permissions",
            "from airflow.utils.airflow_flask_app import get_airflow_app",
            "from airflow.utils.db import get_query_count",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "",
            "if TYPE_CHECKING:",
            "    from sqlalchemy.orm import Session",
            "",
            "    from airflow.api_connexion.types import APIResponse",
            "",
            "",
            "@security.requires_access([(permissions.ACTION_CAN_READ, permissions.RESOURCE_DAG_WARNING)])",
            "@format_parameters({\"limit\": check_limit})",
            "@provide_session",
            "def get_dag_warnings(",
            "    *,",
            "    limit: int,",
            "    dag_id: str | None = None,",
            "    warning_type: str | None = None,",
            "    offset: int | None = None,",
            "    order_by: str = \"timestamp\",",
            "    session: Session = NEW_SESSION,",
            ") -> APIResponse:",
            "    \"\"\"Get DAG warnings.",
            "",
            "    :param dag_id: the dag_id to optionally filter by",
            "    :param warning_type: the warning type to optionally filter by",
            "    \"\"\"",
            "    allowed_filter_attrs = [\"dag_id\", \"warning_type\", \"message\", \"timestamp\"]",
            "    query = select(DagWarningModel)",
            "    if dag_id:",
            "        if not get_airflow_app().appbuilder.sm.can_read_dag(dag_id, g.user):",
            "            raise PermissionDenied(detail=f\"User not allowed to access this DAG: {dag_id}\")",
            "        query = query.where(DagWarningModel.dag_id == dag_id)",
            "    else:",
            "        readable_dags = get_airflow_app().appbuilder.sm.get_accessible_dag_ids(g.user)",
            "        query = query.where(DagWarningModel.dag_id.in_(readable_dags))",
            "    if warning_type:",
            "        query = query.where(DagWarningModel.warning_type == warning_type)",
            "    total_entries = get_query_count(query, session=session)",
            "    query = apply_sorting(query=query, order_by=order_by, allowed_attrs=allowed_filter_attrs)",
            "    dag_warnings = session.scalars(query.offset(offset).limit(limit)).all()",
            "    return dag_warning_collection_schema.dump(",
            "        DagWarningCollection(dag_warnings=dag_warnings, total_entries=total_entries)",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "69": [
                "get_dag_warnings"
            ],
            "70": [
                "get_dag_warnings"
            ],
            "71": [
                "get_dag_warnings"
            ],
            "72": [
                "get_dag_warnings"
            ],
            "73": [
                "get_dag_warnings"
            ],
            "74": [
                "get_dag_warnings"
            ],
            "75": [
                "get_dag_warnings"
            ]
        },
        "addLocation": [
            "applications.admin.controllers.default.git_pull",
            "airflow.api_connexion.endpoints.dag_warning_endpoint.get_dag_warnings.allowed_filter_attrs"
        ]
    }
}