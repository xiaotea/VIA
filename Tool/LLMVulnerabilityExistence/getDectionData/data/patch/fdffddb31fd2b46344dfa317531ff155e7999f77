{
    "cookiecutter/vcs.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "                 stderr=subprocess.STDOUT,"
            },
            "1": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "             )"
            },
            "2": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "             if checkout is not None:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+                checkout_params = [checkout]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+                # Avoid Mercurial \"--config\" and \"--debugger\" injection vulnerability"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+                if repo_type == \"hg\":"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+                    checkout_params.insert(0, \"--\")"
            },
            "7": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "                 subprocess.check_output(  # nosec"
            },
            "8": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    [repo_type, 'checkout', checkout],"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+                    [repo_type, 'checkout', *checkout_params],"
            },
            "10": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "                     cwd=repo_dir,"
            },
            "11": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "                     stderr=subprocess.STDOUT,"
            },
            "12": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "                 )"
            },
            "13": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         except subprocess.CalledProcessError as clone_error:"
            },
            "14": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "             output = clone_error.output.decode('utf-8')"
            },
            "15": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "             if 'not found' in output.lower():"
            },
            "16": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "                 raise RepositoryNotFound("
            },
            "17": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    'The repository {} could not be found, '"
            },
            "18": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    'have you made a typo?'.format(repo_url)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+                    f'The repository {repo_url} could not be found, '"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+                    'have you made a typo?'"
            },
            "21": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "                 )"
            },
            "22": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "             if any(error in output for error in BRANCH_ERRORS):"
            },
            "23": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "                 raise RepositoryCloneFailed("
            },
            "24": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    'The {} branch of repository {} could not found, '"
            },
            "25": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    'have you made a typo?'.format(checkout, repo_url)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                    f'The {checkout} branch of repository '"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                    f'{repo_url} could not found, have you made a typo?'"
            },
            "28": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "                 )"
            },
            "29": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "             logger.error('git clone failed with error: %s', output)"
            },
            "30": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "             raise"
            }
        },
        "frontPatchFile": [
            "\"\"\"Helper functions for working with version control systems.\"\"\"",
            "import logging",
            "import os",
            "import subprocess  # nosec",
            "from shutil import which",
            "",
            "from cookiecutter.exceptions import (",
            "    RepositoryCloneFailed,",
            "    RepositoryNotFound,",
            "    UnknownRepoType,",
            "    VCSNotInstalled,",
            ")",
            "from cookiecutter.utils import make_sure_path_exists, prompt_and_delete",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "BRANCH_ERRORS = [",
            "    'error: pathspec',",
            "    'unknown revision',",
            "]",
            "",
            "",
            "def identify_repo(repo_url):",
            "    \"\"\"Determine if `repo_url` should be treated as a URL to a git or hg repo.",
            "",
            "    Repos can be identified by prepending \"hg+\" or \"git+\" to the repo URL.",
            "",
            "    :param repo_url: Repo URL of unknown type.",
            "    :returns: ('git', repo_url), ('hg', repo_url), or None.",
            "    \"\"\"",
            "    repo_url_values = repo_url.split('+')",
            "    if len(repo_url_values) == 2:",
            "        repo_type = repo_url_values[0]",
            "        if repo_type in [\"git\", \"hg\"]:",
            "            return repo_type, repo_url_values[1]",
            "        else:",
            "            raise UnknownRepoType",
            "    else:",
            "        if 'git' in repo_url:",
            "            return 'git', repo_url",
            "        elif 'bitbucket' in repo_url:",
            "            return 'hg', repo_url",
            "        else:",
            "            raise UnknownRepoType",
            "",
            "",
            "def is_vcs_installed(repo_type):",
            "    \"\"\"",
            "    Check if the version control system for a repo type is installed.",
            "",
            "    :param repo_type:",
            "    \"\"\"",
            "    return bool(which(repo_type))",
            "",
            "",
            "def clone(repo_url, checkout=None, clone_to_dir='.', no_input=False):",
            "    \"\"\"Clone a repo to the current directory.",
            "",
            "    :param repo_url: Repo URL of unknown type.",
            "    :param checkout: The branch, tag or commit ID to checkout after clone.",
            "    :param clone_to_dir: The directory to clone to.",
            "                         Defaults to the current directory.",
            "    :param no_input: Suppress all user prompts when calling via API.",
            "    :returns: str with path to the new directory of the repository.",
            "    \"\"\"",
            "    # Ensure that clone_to_dir exists",
            "    clone_to_dir = os.path.expanduser(clone_to_dir)",
            "    make_sure_path_exists(clone_to_dir)",
            "",
            "    # identify the repo_type",
            "    repo_type, repo_url = identify_repo(repo_url)",
            "",
            "    # check that the appropriate VCS for the repo_type is installed",
            "    if not is_vcs_installed(repo_type):",
            "        msg = f\"'{repo_type}' is not installed.\"",
            "        raise VCSNotInstalled(msg)",
            "",
            "    repo_url = repo_url.rstrip('/')",
            "    repo_name = os.path.split(repo_url)[1]",
            "    if repo_type == 'git':",
            "        repo_name = repo_name.split(':')[-1].rsplit('.git')[0]",
            "        repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))",
            "    if repo_type == 'hg':",
            "        repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))",
            "    logger.debug(f'repo_dir is {repo_dir}')",
            "",
            "    if os.path.isdir(repo_dir):",
            "        clone = prompt_and_delete(repo_dir, no_input=no_input)",
            "    else:",
            "        clone = True",
            "",
            "    if clone:",
            "        try:",
            "            subprocess.check_output(  # nosec",
            "                [repo_type, 'clone', repo_url],",
            "                cwd=clone_to_dir,",
            "                stderr=subprocess.STDOUT,",
            "            )",
            "            if checkout is not None:",
            "                subprocess.check_output(  # nosec",
            "                    [repo_type, 'checkout', checkout],",
            "                    cwd=repo_dir,",
            "                    stderr=subprocess.STDOUT,",
            "                )",
            "        except subprocess.CalledProcessError as clone_error:",
            "            output = clone_error.output.decode('utf-8')",
            "            if 'not found' in output.lower():",
            "                raise RepositoryNotFound(",
            "                    'The repository {} could not be found, '",
            "                    'have you made a typo?'.format(repo_url)",
            "                )",
            "            if any(error in output for error in BRANCH_ERRORS):",
            "                raise RepositoryCloneFailed(",
            "                    'The {} branch of repository {} could not found, '",
            "                    'have you made a typo?'.format(checkout, repo_url)",
            "                )",
            "            logger.error('git clone failed with error: %s', output)",
            "            raise",
            "",
            "    return repo_dir"
        ],
        "afterPatchFile": [
            "\"\"\"Helper functions for working with version control systems.\"\"\"",
            "import logging",
            "import os",
            "import subprocess  # nosec",
            "from shutil import which",
            "",
            "from cookiecutter.exceptions import (",
            "    RepositoryCloneFailed,",
            "    RepositoryNotFound,",
            "    UnknownRepoType,",
            "    VCSNotInstalled,",
            ")",
            "from cookiecutter.utils import make_sure_path_exists, prompt_and_delete",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "BRANCH_ERRORS = [",
            "    'error: pathspec',",
            "    'unknown revision',",
            "]",
            "",
            "",
            "def identify_repo(repo_url):",
            "    \"\"\"Determine if `repo_url` should be treated as a URL to a git or hg repo.",
            "",
            "    Repos can be identified by prepending \"hg+\" or \"git+\" to the repo URL.",
            "",
            "    :param repo_url: Repo URL of unknown type.",
            "    :returns: ('git', repo_url), ('hg', repo_url), or None.",
            "    \"\"\"",
            "    repo_url_values = repo_url.split('+')",
            "    if len(repo_url_values) == 2:",
            "        repo_type = repo_url_values[0]",
            "        if repo_type in [\"git\", \"hg\"]:",
            "            return repo_type, repo_url_values[1]",
            "        else:",
            "            raise UnknownRepoType",
            "    else:",
            "        if 'git' in repo_url:",
            "            return 'git', repo_url",
            "        elif 'bitbucket' in repo_url:",
            "            return 'hg', repo_url",
            "        else:",
            "            raise UnknownRepoType",
            "",
            "",
            "def is_vcs_installed(repo_type):",
            "    \"\"\"",
            "    Check if the version control system for a repo type is installed.",
            "",
            "    :param repo_type:",
            "    \"\"\"",
            "    return bool(which(repo_type))",
            "",
            "",
            "def clone(repo_url, checkout=None, clone_to_dir='.', no_input=False):",
            "    \"\"\"Clone a repo to the current directory.",
            "",
            "    :param repo_url: Repo URL of unknown type.",
            "    :param checkout: The branch, tag or commit ID to checkout after clone.",
            "    :param clone_to_dir: The directory to clone to.",
            "                         Defaults to the current directory.",
            "    :param no_input: Suppress all user prompts when calling via API.",
            "    :returns: str with path to the new directory of the repository.",
            "    \"\"\"",
            "    # Ensure that clone_to_dir exists",
            "    clone_to_dir = os.path.expanduser(clone_to_dir)",
            "    make_sure_path_exists(clone_to_dir)",
            "",
            "    # identify the repo_type",
            "    repo_type, repo_url = identify_repo(repo_url)",
            "",
            "    # check that the appropriate VCS for the repo_type is installed",
            "    if not is_vcs_installed(repo_type):",
            "        msg = f\"'{repo_type}' is not installed.\"",
            "        raise VCSNotInstalled(msg)",
            "",
            "    repo_url = repo_url.rstrip('/')",
            "    repo_name = os.path.split(repo_url)[1]",
            "    if repo_type == 'git':",
            "        repo_name = repo_name.split(':')[-1].rsplit('.git')[0]",
            "        repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))",
            "    if repo_type == 'hg':",
            "        repo_dir = os.path.normpath(os.path.join(clone_to_dir, repo_name))",
            "    logger.debug(f'repo_dir is {repo_dir}')",
            "",
            "    if os.path.isdir(repo_dir):",
            "        clone = prompt_and_delete(repo_dir, no_input=no_input)",
            "    else:",
            "        clone = True",
            "",
            "    if clone:",
            "        try:",
            "            subprocess.check_output(  # nosec",
            "                [repo_type, 'clone', repo_url],",
            "                cwd=clone_to_dir,",
            "                stderr=subprocess.STDOUT,",
            "            )",
            "            if checkout is not None:",
            "                checkout_params = [checkout]",
            "                # Avoid Mercurial \"--config\" and \"--debugger\" injection vulnerability",
            "                if repo_type == \"hg\":",
            "                    checkout_params.insert(0, \"--\")",
            "                subprocess.check_output(  # nosec",
            "                    [repo_type, 'checkout', *checkout_params],",
            "                    cwd=repo_dir,",
            "                    stderr=subprocess.STDOUT,",
            "                )",
            "        except subprocess.CalledProcessError as clone_error:",
            "            output = clone_error.output.decode('utf-8')",
            "            if 'not found' in output.lower():",
            "                raise RepositoryNotFound(",
            "                    f'The repository {repo_url} could not be found, '",
            "                    'have you made a typo?'",
            "                )",
            "            if any(error in output for error in BRANCH_ERRORS):",
            "                raise RepositoryCloneFailed(",
            "                    f'The {checkout} branch of repository '",
            "                    f'{repo_url} could not found, have you made a typo?'",
            "                )",
            "            logger.error('git clone failed with error: %s', output)",
            "            raise",
            "",
            "    return repo_dir"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "102": [
                "clone"
            ],
            "110": [
                "clone"
            ],
            "111": [
                "clone"
            ],
            "115": [
                "clone"
            ],
            "116": [
                "clone"
            ]
        },
        "addLocation": [
            "jupyterhub.services.auth.HubOAuth"
        ]
    }
}