{
    "django/contrib/sessions/backends/cache.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "             session_data = None"
            },
            "1": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         if session_data is not None:"
            },
            "2": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             return session_data"
            },
            "3": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         return {}"
            },
            "6": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     def create(self):"
            },
            "8": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             \"It is likely that the cache is unavailable.\")"
            },
            "9": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     def save(self, must_create=False):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        if self.session_key is None:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            return self.create()"
            },
            "13": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         if must_create:"
            },
            "14": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             func = self._cache.add"
            },
            "15": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         else:"
            },
            "16": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             raise CreateError"
            },
            "17": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     def exists(self, session_key):"
            },
            "19": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return (KEY_PREFIX + session_key) in self._cache"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        return session_key and (KEY_PREFIX + session_key) in self._cache"
            },
            "21": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     def delete(self, session_key=None):"
            },
            "23": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         if session_key is None:"
            }
        },
        "frontPatchFile": [
            "from django.conf import settings",
            "from django.contrib.sessions.backends.base import SessionBase, CreateError",
            "from django.core.cache import caches",
            "from django.utils.six.moves import xrange",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cache\"",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    A cache-based session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            session_data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            session_data = None",
            "        if session_data is not None:",
            "            return session_data",
            "        self.create()",
            "        return {}",
            "",
            "    def create(self):",
            "        # Because a cache can fail silently (e.g. memcache), we don't know if",
            "        # we are failing to create a new session because of a key collision or",
            "        # because the cache is missing. So we try for a (large) number of times",
            "        # and then raise an exception. That's the risk you shoulder if using",
            "        # cache backing.",
            "        for i in xrange(10000):",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                continue",
            "            self.modified = True",
            "            return",
            "        raise RuntimeError(",
            "            \"Unable to create a new session key. \"",
            "            \"It is likely that the cache is unavailable.\")",
            "",
            "    def save(self, must_create=False):",
            "        if must_create:",
            "            func = self._cache.add",
            "        else:",
            "            func = self._cache.set",
            "        result = func(self.cache_key,",
            "                      self._get_session(no_load=must_create),",
            "                      self.get_expiry_age())",
            "        if must_create and not result:",
            "            raise CreateError",
            "",
            "    def exists(self, session_key):",
            "        return (KEY_PREFIX + session_key) in self._cache",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        pass"
        ],
        "afterPatchFile": [
            "from django.conf import settings",
            "from django.contrib.sessions.backends.base import SessionBase, CreateError",
            "from django.core.cache import caches",
            "from django.utils.six.moves import xrange",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cache\"",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    A cache-based session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            session_data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            session_data = None",
            "        if session_data is not None:",
            "            return session_data",
            "        self._session_key = None",
            "        return {}",
            "",
            "    def create(self):",
            "        # Because a cache can fail silently (e.g. memcache), we don't know if",
            "        # we are failing to create a new session because of a key collision or",
            "        # because the cache is missing. So we try for a (large) number of times",
            "        # and then raise an exception. That's the risk you shoulder if using",
            "        # cache backing.",
            "        for i in xrange(10000):",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                continue",
            "            self.modified = True",
            "            return",
            "        raise RuntimeError(",
            "            \"Unable to create a new session key. \"",
            "            \"It is likely that the cache is unavailable.\")",
            "",
            "    def save(self, must_create=False):",
            "        if self.session_key is None:",
            "            return self.create()",
            "        if must_create:",
            "            func = self._cache.add",
            "        else:",
            "            func = self._cache.set",
            "        result = func(self.cache_key,",
            "                      self._get_session(no_load=must_create),",
            "                      self.get_expiry_age())",
            "        if must_create and not result:",
            "            raise CreateError",
            "",
            "    def exists(self, session_key):",
            "        return session_key and (KEY_PREFIX + session_key) in self._cache",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "30": [
                "SessionStore",
                "load"
            ],
            "63": [
                "SessionStore",
                "exists"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/backends/cached_db.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                     logger = logging.getLogger('django.security.%s' %"
            },
            "1": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                             e.__class__.__name__)"
            },
            "2": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "                     logger.warning(force_text(e))"
            },
            "3": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "                 data = {}"
            },
            "6": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         return data"
            },
            "7": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     def exists(self, session_key):"
            },
            "9": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if (KEY_PREFIX + session_key) in self._cache:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        if session_key and (KEY_PREFIX + session_key) in self._cache:"
            },
            "11": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "             return True"
            },
            "12": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         return super(SessionStore, self).exists(session_key)"
            },
            "13": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Cached, database-backed sessions.",
            "\"\"\"",
            "",
            "import logging",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DBStore",
            "from django.core.cache import caches",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cached_db\"",
            "",
            "",
            "class SessionStore(DBStore):",
            "    \"\"\"",
            "    Implements cached, database backed sessions.",
            "    \"\"\"",
            "",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            data = None",
            "",
            "        if data is None:",
            "            # Duplicate DBStore.load, because we need to keep track",
            "            # of the expiry date to set it properly in the cache.",
            "            try:",
            "                s = Session.objects.get(",
            "                    session_key=self.session_key,",
            "                    expire_date__gt=timezone.now()",
            "                )",
            "                data = self.decode(s.session_data)",
            "                self._cache.set(self.cache_key, data,",
            "                    self.get_expiry_age(expiry=s.expire_date))",
            "            except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "                if isinstance(e, SuspiciousOperation):",
            "                    logger = logging.getLogger('django.security.%s' %",
            "                            e.__class__.__name__)",
            "                    logger.warning(force_text(e))",
            "                self.create()",
            "                data = {}",
            "        return data",
            "",
            "    def exists(self, session_key):",
            "        if (KEY_PREFIX + session_key) in self._cache:",
            "            return True",
            "        return super(SessionStore, self).exists(session_key)",
            "",
            "    def save(self, must_create=False):",
            "        super(SessionStore, self).save(must_create)",
            "        self._cache.set(self.cache_key, self._session, self.get_expiry_age())",
            "",
            "    def delete(self, session_key=None):",
            "        super(SessionStore, self).delete(session_key)",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete(self.session_key)",
            "        self.create()",
            "",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Cached, database-backed sessions.",
            "\"\"\"",
            "",
            "import logging",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DBStore",
            "from django.core.cache import caches",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cached_db\"",
            "",
            "",
            "class SessionStore(DBStore):",
            "    \"\"\"",
            "    Implements cached, database backed sessions.",
            "    \"\"\"",
            "",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            data = None",
            "",
            "        if data is None:",
            "            # Duplicate DBStore.load, because we need to keep track",
            "            # of the expiry date to set it properly in the cache.",
            "            try:",
            "                s = Session.objects.get(",
            "                    session_key=self.session_key,",
            "                    expire_date__gt=timezone.now()",
            "                )",
            "                data = self.decode(s.session_data)",
            "                self._cache.set(self.cache_key, data,",
            "                    self.get_expiry_age(expiry=s.expire_date))",
            "            except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "                if isinstance(e, SuspiciousOperation):",
            "                    logger = logging.getLogger('django.security.%s' %",
            "                            e.__class__.__name__)",
            "                    logger.warning(force_text(e))",
            "                self._session_key = None",
            "                data = {}",
            "        return data",
            "",
            "    def exists(self, session_key):",
            "        if session_key and (KEY_PREFIX + session_key) in self._cache:",
            "            return True",
            "        return super(SessionStore, self).exists(session_key)",
            "",
            "    def save(self, must_create=False):",
            "        super(SessionStore, self).save(must_create)",
            "        self._cache.set(self.cache_key, self._session, self.get_expiry_age())",
            "",
            "    def delete(self, session_key=None):",
            "        super(SessionStore, self).delete(session_key)",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete(self.session_key)",
            "        self.create()",
            "",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "54": [
                "SessionStore",
                "load"
            ],
            "59": [
                "SessionStore",
                "exists"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/backends/db.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "                 logger = logging.getLogger('django.security.%s' %"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "                         e.__class__.__name__)"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "                 logger.warning(force_text(e))"
            },
            "3": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "             return {}"
            },
            "6": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     def exists(self, session_key):"
            },
            "8": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "                 # Key wasn't unique. Try again."
            },
            "9": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "                 continue"
            },
            "10": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             self.modified = True"
            },
            "11": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._session_cache = {}"
            },
            "12": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "             return"
            },
            "13": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     def save(self, must_create=False):"
            },
            "15": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         create a *new* entry (as opposed to possibly updating an existing"
            },
            "16": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         entry)."
            },
            "17": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         \"\"\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        if self.session_key is None:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            return self.create()"
            },
            "20": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         obj = Session("
            },
            "21": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             session_key=self._get_or_create_session_key(),"
            },
            "22": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             session_data=self.encode(self._get_session(no_load=must_create)),"
            }
        },
        "frontPatchFile": [
            "import logging",
            "",
            "from django.contrib.sessions.backends.base import SessionBase, CreateError",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.db import IntegrityError, transaction, router",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    Implements database session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    def load(self):",
            "        try:",
            "            s = Session.objects.get(",
            "                session_key=self.session_key,",
            "                expire_date__gt=timezone.now()",
            "            )",
            "            return self.decode(s.session_data)",
            "        except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "            if isinstance(e, SuspiciousOperation):",
            "                logger = logging.getLogger('django.security.%s' %",
            "                        e.__class__.__name__)",
            "                logger.warning(force_text(e))",
            "            self.create()",
            "            return {}",
            "",
            "    def exists(self, session_key):",
            "        return Session.objects.filter(session_key=session_key).exists()",
            "",
            "    def create(self):",
            "        while True:",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                # Save immediately to ensure we have a unique entry in the",
            "                # database.",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                # Key wasn't unique. Try again.",
            "                continue",
            "            self.modified = True",
            "            self._session_cache = {}",
            "            return",
            "",
            "    def save(self, must_create=False):",
            "        \"\"\"",
            "        Saves the current session data to the database. If 'must_create' is",
            "        True, a database error will be raised if the saving operation doesn't",
            "        create a *new* entry (as opposed to possibly updating an existing",
            "        entry).",
            "        \"\"\"",
            "        obj = Session(",
            "            session_key=self._get_or_create_session_key(),",
            "            session_data=self.encode(self._get_session(no_load=must_create)),",
            "            expire_date=self.get_expiry_date()",
            "        )",
            "        using = router.db_for_write(Session, instance=obj)",
            "        try:",
            "            with transaction.atomic(using=using):",
            "                obj.save(force_insert=must_create, using=using)",
            "        except IntegrityError:",
            "            if must_create:",
            "                raise CreateError",
            "            raise",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        try:",
            "            Session.objects.get(session_key=session_key).delete()",
            "        except Session.DoesNotExist:",
            "            pass",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        Session.objects.filter(expire_date__lt=timezone.now()).delete()",
            "",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session"
        ],
        "afterPatchFile": [
            "import logging",
            "",
            "from django.contrib.sessions.backends.base import SessionBase, CreateError",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.db import IntegrityError, transaction, router",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    Implements database session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    def load(self):",
            "        try:",
            "            s = Session.objects.get(",
            "                session_key=self.session_key,",
            "                expire_date__gt=timezone.now()",
            "            )",
            "            return self.decode(s.session_data)",
            "        except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "            if isinstance(e, SuspiciousOperation):",
            "                logger = logging.getLogger('django.security.%s' %",
            "                        e.__class__.__name__)",
            "                logger.warning(force_text(e))",
            "            self._session_key = None",
            "            return {}",
            "",
            "    def exists(self, session_key):",
            "        return Session.objects.filter(session_key=session_key).exists()",
            "",
            "    def create(self):",
            "        while True:",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                # Save immediately to ensure we have a unique entry in the",
            "                # database.",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                # Key wasn't unique. Try again.",
            "                continue",
            "            self.modified = True",
            "            return",
            "",
            "    def save(self, must_create=False):",
            "        \"\"\"",
            "        Saves the current session data to the database. If 'must_create' is",
            "        True, a database error will be raised if the saving operation doesn't",
            "        create a *new* entry (as opposed to possibly updating an existing",
            "        entry).",
            "        \"\"\"",
            "        if self.session_key is None:",
            "            return self.create()",
            "        obj = Session(",
            "            session_key=self._get_or_create_session_key(),",
            "            session_data=self.encode(self._get_session(no_load=must_create)),",
            "            expire_date=self.get_expiry_date()",
            "        )",
            "        using = router.db_for_write(Session, instance=obj)",
            "        try:",
            "            with transaction.atomic(using=using):",
            "                obj.save(force_insert=must_create, using=using)",
            "        except IntegrityError:",
            "            if must_create:",
            "                raise CreateError",
            "            raise",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        try:",
            "            Session.objects.get(session_key=session_key).delete()",
            "        except Session.DoesNotExist:",
            "            pass",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        Session.objects.filter(expire_date__lt=timezone.now()).delete()",
            "",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "29": [
                "SessionStore",
                "load"
            ],
            "46": [
                "SessionStore",
                "create"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/backends/file.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "                     self.delete()"
            },
            "1": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "                     self.create()"
            },
            "2": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         except (IOError, SuspiciousOperation):"
            },
            "3": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         return session_data"
            },
            "6": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def create(self):"
            },
            "8": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "             except CreateError:"
            },
            "9": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "                 continue"
            },
            "10": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             self.modified = True"
            },
            "11": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._session_cache = {}"
            },
            "12": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             return"
            },
            "13": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "     def save(self, must_create=False):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        if self.session_key is None:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+            return self.create()"
            },
            "17": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         # Get the session data now, before we start messing"
            },
            "18": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         # with the file it is stored within."
            },
            "19": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         session_data = self._get_session(no_load=must_create)"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "import errno",
            "import logging",
            "import os",
            "import shutil",
            "import tempfile",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.base import SessionBase, CreateError, VALID_KEY_CHARS",
            "from django.core.exceptions import SuspiciousOperation, ImproperlyConfigured",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "from django.contrib.sessions.exceptions import InvalidSessionKey",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    Implements a file based session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        self.storage_path = type(self)._get_storage_path()",
            "        self.file_prefix = settings.SESSION_COOKIE_NAME",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @classmethod",
            "    def _get_storage_path(cls):",
            "        try:",
            "            return cls._storage_path",
            "        except AttributeError:",
            "            storage_path = getattr(settings, \"SESSION_FILE_PATH\", None)",
            "            if not storage_path:",
            "                storage_path = tempfile.gettempdir()",
            "",
            "            # Make sure the storage path is valid.",
            "            if not os.path.isdir(storage_path):",
            "                raise ImproperlyConfigured(",
            "                    \"The session storage path %r doesn't exist. Please set your\"",
            "                    \" SESSION_FILE_PATH setting to an existing directory in which\"",
            "                    \" Django can store session data.\" % storage_path)",
            "",
            "            cls._storage_path = storage_path",
            "            return storage_path",
            "",
            "    def _key_to_file(self, session_key=None):",
            "        \"\"\"",
            "        Get the file associated with this session key.",
            "        \"\"\"",
            "        if session_key is None:",
            "            session_key = self._get_or_create_session_key()",
            "",
            "        # Make sure we're not vulnerable to directory traversal. Session keys",
            "        # should always be md5s, so they should never contain directory",
            "        # components.",
            "        if not set(session_key).issubset(set(VALID_KEY_CHARS)):",
            "            raise InvalidSessionKey(",
            "                \"Invalid characters in session key\")",
            "",
            "        return os.path.join(self.storage_path, self.file_prefix + session_key)",
            "",
            "    def _last_modification(self):",
            "        \"\"\"",
            "        Return the modification time of the file storing the session's content.",
            "        \"\"\"",
            "        modification = os.stat(self._key_to_file()).st_mtime",
            "        if settings.USE_TZ:",
            "            modification = datetime.datetime.utcfromtimestamp(modification)",
            "            modification = modification.replace(tzinfo=timezone.utc)",
            "        else:",
            "            modification = datetime.datetime.fromtimestamp(modification)",
            "        return modification",
            "",
            "    def load(self):",
            "        session_data = {}",
            "        try:",
            "            with open(self._key_to_file(), \"rb\") as session_file:",
            "                file_data = session_file.read()",
            "            # Don't fail if there is no data in the session file.",
            "            # We may have opened the empty placeholder file.",
            "            if file_data:",
            "                try:",
            "                    session_data = self.decode(file_data)",
            "                except (EOFError, SuspiciousOperation) as e:",
            "                    if isinstance(e, SuspiciousOperation):",
            "                        logger = logging.getLogger('django.security.%s' %",
            "                                e.__class__.__name__)",
            "                        logger.warning(force_text(e))",
            "                    self.create()",
            "",
            "                # Remove expired sessions.",
            "                expiry_age = self.get_expiry_age(",
            "                    modification=self._last_modification(),",
            "                    expiry=session_data.get('_session_expiry'))",
            "                if expiry_age < 0:",
            "                    session_data = {}",
            "                    self.delete()",
            "                    self.create()",
            "        except (IOError, SuspiciousOperation):",
            "            self.create()",
            "        return session_data",
            "",
            "    def create(self):",
            "        while True:",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                continue",
            "            self.modified = True",
            "            self._session_cache = {}",
            "            return",
            "",
            "    def save(self, must_create=False):",
            "        # Get the session data now, before we start messing",
            "        # with the file it is stored within.",
            "        session_data = self._get_session(no_load=must_create)",
            "",
            "        session_file_name = self._key_to_file()",
            "",
            "        try:",
            "            # Make sure the file exists.  If it does not already exist, an",
            "            # empty placeholder file is created.",
            "            flags = os.O_WRONLY | os.O_CREAT | getattr(os, 'O_BINARY', 0)",
            "            if must_create:",
            "                flags |= os.O_EXCL",
            "            fd = os.open(session_file_name, flags)",
            "            os.close(fd)",
            "",
            "        except OSError as e:",
            "            if must_create and e.errno == errno.EEXIST:",
            "                raise CreateError",
            "            raise",
            "",
            "        # Write the session file without interfering with other threads",
            "        # or processes.  By writing to an atomically generated temporary",
            "        # file and then using the atomic os.rename() to make the complete",
            "        # file visible, we avoid having to lock the session file, while",
            "        # still maintaining its integrity.",
            "        #",
            "        # Note: Locking the session file was explored, but rejected in part",
            "        # because in order to be atomic and cross-platform, it required a",
            "        # long-lived lock file for each session, doubling the number of",
            "        # files in the session storage directory at any given time.  This",
            "        # rename solution is cleaner and avoids any additional overhead",
            "        # when reading the session data, which is the more common case",
            "        # unless SESSION_SAVE_EVERY_REQUEST = True.",
            "        #",
            "        # See ticket #8616.",
            "        dir, prefix = os.path.split(session_file_name)",
            "",
            "        try:",
            "            output_file_fd, output_file_name = tempfile.mkstemp(dir=dir,",
            "                prefix=prefix + '_out_')",
            "            renamed = False",
            "            try:",
            "                try:",
            "                    os.write(output_file_fd, self.encode(session_data).encode())",
            "                finally:",
            "                    os.close(output_file_fd)",
            "",
            "                # This will atomically rename the file (os.rename) if the OS",
            "                # supports it. Otherwise this will result in a shutil.copy2",
            "                # and os.unlink (for example on Windows). See #9084.",
            "                shutil.move(output_file_name, session_file_name)",
            "                renamed = True",
            "            finally:",
            "                if not renamed:",
            "                    os.unlink(output_file_name)",
            "",
            "        except (OSError, IOError, EOFError):",
            "            pass",
            "",
            "    def exists(self, session_key):",
            "        return os.path.exists(self._key_to_file(session_key))",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        try:",
            "            os.unlink(self._key_to_file(session_key))",
            "        except OSError:",
            "            pass",
            "",
            "    def clean(self):",
            "        pass",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        storage_path = cls._get_storage_path()",
            "        file_prefix = settings.SESSION_COOKIE_NAME",
            "",
            "        for session_file in os.listdir(storage_path):",
            "            if not session_file.startswith(file_prefix):",
            "                continue",
            "            session_key = session_file[len(file_prefix):]",
            "            session = cls(session_key)",
            "            # When an expired session is loaded, its file is removed, and a",
            "            # new file is immediately created. Prevent this by disabling",
            "            # the create() method.",
            "            session.create = lambda: None",
            "            session.load()"
        ],
        "afterPatchFile": [
            "import datetime",
            "import errno",
            "import logging",
            "import os",
            "import shutil",
            "import tempfile",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.base import SessionBase, CreateError, VALID_KEY_CHARS",
            "from django.core.exceptions import SuspiciousOperation, ImproperlyConfigured",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "from django.contrib.sessions.exceptions import InvalidSessionKey",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    Implements a file based session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        self.storage_path = type(self)._get_storage_path()",
            "        self.file_prefix = settings.SESSION_COOKIE_NAME",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @classmethod",
            "    def _get_storage_path(cls):",
            "        try:",
            "            return cls._storage_path",
            "        except AttributeError:",
            "            storage_path = getattr(settings, \"SESSION_FILE_PATH\", None)",
            "            if not storage_path:",
            "                storage_path = tempfile.gettempdir()",
            "",
            "            # Make sure the storage path is valid.",
            "            if not os.path.isdir(storage_path):",
            "                raise ImproperlyConfigured(",
            "                    \"The session storage path %r doesn't exist. Please set your\"",
            "                    \" SESSION_FILE_PATH setting to an existing directory in which\"",
            "                    \" Django can store session data.\" % storage_path)",
            "",
            "            cls._storage_path = storage_path",
            "            return storage_path",
            "",
            "    def _key_to_file(self, session_key=None):",
            "        \"\"\"",
            "        Get the file associated with this session key.",
            "        \"\"\"",
            "        if session_key is None:",
            "            session_key = self._get_or_create_session_key()",
            "",
            "        # Make sure we're not vulnerable to directory traversal. Session keys",
            "        # should always be md5s, so they should never contain directory",
            "        # components.",
            "        if not set(session_key).issubset(set(VALID_KEY_CHARS)):",
            "            raise InvalidSessionKey(",
            "                \"Invalid characters in session key\")",
            "",
            "        return os.path.join(self.storage_path, self.file_prefix + session_key)",
            "",
            "    def _last_modification(self):",
            "        \"\"\"",
            "        Return the modification time of the file storing the session's content.",
            "        \"\"\"",
            "        modification = os.stat(self._key_to_file()).st_mtime",
            "        if settings.USE_TZ:",
            "            modification = datetime.datetime.utcfromtimestamp(modification)",
            "            modification = modification.replace(tzinfo=timezone.utc)",
            "        else:",
            "            modification = datetime.datetime.fromtimestamp(modification)",
            "        return modification",
            "",
            "    def load(self):",
            "        session_data = {}",
            "        try:",
            "            with open(self._key_to_file(), \"rb\") as session_file:",
            "                file_data = session_file.read()",
            "            # Don't fail if there is no data in the session file.",
            "            # We may have opened the empty placeholder file.",
            "            if file_data:",
            "                try:",
            "                    session_data = self.decode(file_data)",
            "                except (EOFError, SuspiciousOperation) as e:",
            "                    if isinstance(e, SuspiciousOperation):",
            "                        logger = logging.getLogger('django.security.%s' %",
            "                                e.__class__.__name__)",
            "                        logger.warning(force_text(e))",
            "                    self.create()",
            "",
            "                # Remove expired sessions.",
            "                expiry_age = self.get_expiry_age(",
            "                    modification=self._last_modification(),",
            "                    expiry=session_data.get('_session_expiry'))",
            "                if expiry_age < 0:",
            "                    session_data = {}",
            "                    self.delete()",
            "                    self.create()",
            "        except (IOError, SuspiciousOperation):",
            "            self._session_key = None",
            "        return session_data",
            "",
            "    def create(self):",
            "        while True:",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                continue",
            "            self.modified = True",
            "            return",
            "",
            "    def save(self, must_create=False):",
            "        if self.session_key is None:",
            "            return self.create()",
            "        # Get the session data now, before we start messing",
            "        # with the file it is stored within.",
            "        session_data = self._get_session(no_load=must_create)",
            "",
            "        session_file_name = self._key_to_file()",
            "",
            "        try:",
            "            # Make sure the file exists.  If it does not already exist, an",
            "            # empty placeholder file is created.",
            "            flags = os.O_WRONLY | os.O_CREAT | getattr(os, 'O_BINARY', 0)",
            "            if must_create:",
            "                flags |= os.O_EXCL",
            "            fd = os.open(session_file_name, flags)",
            "            os.close(fd)",
            "",
            "        except OSError as e:",
            "            if must_create and e.errno == errno.EEXIST:",
            "                raise CreateError",
            "            raise",
            "",
            "        # Write the session file without interfering with other threads",
            "        # or processes.  By writing to an atomically generated temporary",
            "        # file and then using the atomic os.rename() to make the complete",
            "        # file visible, we avoid having to lock the session file, while",
            "        # still maintaining its integrity.",
            "        #",
            "        # Note: Locking the session file was explored, but rejected in part",
            "        # because in order to be atomic and cross-platform, it required a",
            "        # long-lived lock file for each session, doubling the number of",
            "        # files in the session storage directory at any given time.  This",
            "        # rename solution is cleaner and avoids any additional overhead",
            "        # when reading the session data, which is the more common case",
            "        # unless SESSION_SAVE_EVERY_REQUEST = True.",
            "        #",
            "        # See ticket #8616.",
            "        dir, prefix = os.path.split(session_file_name)",
            "",
            "        try:",
            "            output_file_fd, output_file_name = tempfile.mkstemp(dir=dir,",
            "                prefix=prefix + '_out_')",
            "            renamed = False",
            "            try:",
            "                try:",
            "                    os.write(output_file_fd, self.encode(session_data).encode())",
            "                finally:",
            "                    os.close(output_file_fd)",
            "",
            "                # This will atomically rename the file (os.rename) if the OS",
            "                # supports it. Otherwise this will result in a shutil.copy2",
            "                # and os.unlink (for example on Windows). See #9084.",
            "                shutil.move(output_file_name, session_file_name)",
            "                renamed = True",
            "            finally:",
            "                if not renamed:",
            "                    os.unlink(output_file_name)",
            "",
            "        except (OSError, IOError, EOFError):",
            "            pass",
            "",
            "    def exists(self, session_key):",
            "        return os.path.exists(self._key_to_file(session_key))",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        try:",
            "            os.unlink(self._key_to_file(session_key))",
            "        except OSError:",
            "            pass",
            "",
            "    def clean(self):",
            "        pass",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        storage_path = cls._get_storage_path()",
            "        file_prefix = settings.SESSION_COOKIE_NAME",
            "",
            "        for session_file in os.listdir(storage_path):",
            "            if not session_file.startswith(file_prefix):",
            "                continue",
            "            session_key = session_file[len(file_prefix):]",
            "            session = cls(session_key)",
            "            # When an expired session is loaded, its file is removed, and a",
            "            # new file is immediately created. Prevent this by disabling",
            "            # the create() method.",
            "            session.create = lambda: None",
            "            session.load()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "99": [
                "SessionStore",
                "load"
            ],
            "110": [
                "SessionStore",
                "create"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/tests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         self.assertNotEqual(self.session.session_key, prev_key)"
            },
            "1": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         self.assertEqual(list(self.session.items()), prev_data)"
            },
            "2": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+    def test_save_doesnt_clear_data(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        self.session['a'] = 'b'"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        self.session.save()"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        self.assertEqual(self.session['a'], 'b')"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     def test_invalid_key(self):"
            },
            "9": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         # Submitting an invalid session key (either by guessing, or if the db has"
            },
            "10": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         # removed the key) results in a new key being generated."
            },
            "11": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "                 self.session.delete(old_session_key)"
            },
            "12": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "                 self.session.delete(new_session_key)"
            },
            "13": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 313,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+    def test_session_load_does_not_create_record(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+        \"\"\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+        Loading an unknown session key does not create a session record."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+        Creating session records on load is a DOS vulnerability."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+        \"\"\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+        if self.backend is CookieSession:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+            raise unittest.SkipTest(\"Cookie backend doesn't have an external store to create records in.\")"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+        session = self.backend('someunknownkey')"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+        session.load()"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+        self.assertFalse(session.exists(session.session_key))"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+        # provided unknown key was cycled, not reused"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+        self.assertNotEqual(session.session_key, 'someunknownkey')"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 329,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 330,
                "PatchRowcode": " class DatabaseSessionTests(SessionTestsMixin, TestCase):"
            },
            "31": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 331,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import base64",
            "from datetime import timedelta",
            "import os",
            "import shutil",
            "import string",
            "import tempfile",
            "import unittest",
            "import warnings",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DatabaseSession",
            "from django.contrib.sessions.backends.cache import SessionStore as CacheSession",
            "from django.contrib.sessions.backends.cached_db import SessionStore as CacheDBSession",
            "from django.contrib.sessions.backends.file import SessionStore as FileSession",
            "from django.contrib.sessions.backends.signed_cookies import SessionStore as CookieSession",
            "from django.contrib.sessions.models import Session",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "from django.core.cache import caches",
            "from django.core.cache.backends.base import InvalidCacheBackendError",
            "from django.core import management",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.http import HttpResponse",
            "from django.test import TestCase, RequestFactory, override_settings",
            "from django.test.utils import patch_logger",
            "from django.utils import six",
            "from django.utils import timezone",
            "from django.utils.six.moves import http_cookies",
            "",
            "from django.contrib.sessions.exceptions import InvalidSessionKey",
            "",
            "",
            "class SessionTestsMixin(object):",
            "    # This does not inherit from TestCase to avoid any tests being run with this",
            "    # class, which wouldn't work, and to allow different TestCase subclasses to",
            "    # be used.",
            "",
            "    backend = None  # subclasses must specify",
            "",
            "    def setUp(self):",
            "        self.session = self.backend()",
            "",
            "    def tearDown(self):",
            "        # NB: be careful to delete any sessions created; stale sessions fill up",
            "        # the /tmp (with some backends) and eventually overwhelm it after lots",
            "        # of runs (think buildbots)",
            "        self.session.delete()",
            "",
            "    def test_new_session(self):",
            "        self.assertFalse(self.session.modified)",
            "        self.assertFalse(self.session.accessed)",
            "",
            "    def test_get_empty(self):",
            "        self.assertEqual(self.session.get('cat'), None)",
            "",
            "    def test_store(self):",
            "        self.session['cat'] = \"dog\"",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.pop('cat'), 'dog')",
            "",
            "    def test_pop(self):",
            "        self.session['some key'] = 'exists'",
            "        # Need to reset these to pretend we haven't accessed it:",
            "        self.accessed = False",
            "        self.modified = False",
            "",
            "        self.assertEqual(self.session.pop('some key'), 'exists')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('some key'), None)",
            "",
            "    def test_pop_default(self):",
            "        self.assertEqual(self.session.pop('some key', 'does not exist'),",
            "                         'does not exist')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_setdefault(self):",
            "        self.assertEqual(self.session.setdefault('foo', 'bar'), 'bar')",
            "        self.assertEqual(self.session.setdefault('foo', 'baz'), 'bar')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_update(self):",
            "        self.session.update({'update key': 1})",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('update key', None), 1)",
            "",
            "    def test_has_key(self):",
            "        self.session['some key'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertIn('some key', self.session)",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_values(self):",
            "        self.assertEqual(list(self.session.values()), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.session['some key'] = 1",
            "        self.assertEqual(list(self.session.values()), [1])",
            "",
            "    def test_iterkeys(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.iterkeys(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), ['x'])",
            "",
            "    def test_itervalues(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.itervalues(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [1])",
            "",
            "    def test_iteritems(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.iteritems(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [('x', 1)])",
            "",
            "    def test_clear(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertEqual(list(self.session.items()), [('x', 1)])",
            "        self.session.clear()",
            "        self.assertEqual(list(self.session.items()), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_save(self):",
            "        if (hasattr(self.session, '_cache') and 'DummyCache' in",
            "                settings.CACHES[settings.SESSION_CACHE_ALIAS]['BACKEND']):",
            "            raise unittest.SkipTest(\"Session saving tests require a real cache backend\")",
            "        self.session.save()",
            "        self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_delete(self):",
            "        self.session.save()",
            "        self.session.delete(self.session.session_key)",
            "        self.assertFalse(self.session.exists(self.session.session_key))",
            "",
            "    def test_flush(self):",
            "        self.session['foo'] = 'bar'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        self.session.flush()",
            "        self.assertFalse(self.session.exists(prev_key))",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertTrue(self.session.accessed)",
            "",
            "    def test_cycle(self):",
            "        self.session['a'], self.session['b'] = 'c', 'd'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        prev_data = list(self.session.items())",
            "        self.session.cycle_key()",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertEqual(list(self.session.items()), prev_data)",
            "",
            "    def test_invalid_key(self):",
            "        # Submitting an invalid session key (either by guessing, or if the db has",
            "        # removed the key) results in a new key being generated.",
            "        try:",
            "            session = self.backend('1')",
            "            try:",
            "                session.save()",
            "            except AttributeError:",
            "                self.fail(\"The session object did not save properly.  Middleware may be saving cache items without namespaces.\")",
            "            self.assertNotEqual(session.session_key, '1')",
            "            self.assertEqual(session.get('cat'), None)",
            "            session.delete()",
            "        finally:",
            "            # Some backends leave a stale cache entry for the invalid",
            "            # session key; make sure that entry is manually deleted",
            "            session.delete('1')",
            "",
            "    def test_session_key_is_read_only(self):",
            "        def set_session_key(session):",
            "            session.session_key = session._get_new_session_key()",
            "        self.assertRaises(AttributeError, set_session_key, self.session)",
            "",
            "    # Custom session expiry",
            "    def test_default_expiry(self):",
            "        # A normal session has a max age equal to settings",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "        # So does a custom session with an idle expiration time of 0 (but it'll",
            "        # expire at browser close)",
            "        self.session.set_expiry(0)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_custom_expiry_seconds(self):",
            "        modification = timezone.now()",
            "",
            "        self.session.set_expiry(10)",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_timedelta(self):",
            "        modification = timezone.now()",
            "",
            "        # Mock timezone.now, because set_expiry calls it on this code path.",
            "        original_now = timezone.now",
            "        try:",
            "            timezone.now = lambda: modification",
            "            self.session.set_expiry(timedelta(seconds=10))",
            "        finally:",
            "            timezone.now = original_now",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_datetime(self):",
            "        modification = timezone.now()",
            "",
            "        self.session.set_expiry(modification + timedelta(seconds=10))",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_reset(self):",
            "        self.session.set_expiry(None)",
            "        self.session.set_expiry(10)",
            "        self.session.set_expiry(None)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_get_expire_at_browser_close(self):",
            "        # Tests get_expire_at_browser_close with different settings and different",
            "        # set_expiry calls",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=False):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=True):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "    def test_decode(self):",
            "        # Ensure we can decode what we encode",
            "        data = {'a test key': 'a test value'}",
            "        encoded = self.session.encode(data)",
            "        self.assertEqual(self.session.decode(encoded), data)",
            "",
            "    def test_decode_failure_logged_to_security(self):",
            "        bad_encode = base64.b64encode(b'flaskdj:alkdjf')",
            "        with patch_logger('django.security.SuspiciousSession', 'warning') as calls:",
            "            self.assertEqual({}, self.session.decode(bad_encode))",
            "            # check that the failed decode is logged",
            "            self.assertEqual(len(calls), 1)",
            "            self.assertTrue('corrupted' in calls[0])",
            "",
            "    def test_actual_expiry(self):",
            "        # this doesn't work with JSONSerializer (serializing timedelta)",
            "        with override_settings(SESSION_SERIALIZER='django.contrib.sessions.serializers.PickleSerializer'):",
            "            self.session = self.backend()  # reinitialize after overriding settings",
            "",
            "            # Regression test for #19200",
            "            old_session_key = None",
            "            new_session_key = None",
            "            try:",
            "                self.session['foo'] = 'bar'",
            "                self.session.set_expiry(-timedelta(seconds=10))",
            "                self.session.save()",
            "                old_session_key = self.session.session_key",
            "                # With an expiry date in the past, the session expires instantly.",
            "                new_session = self.backend(self.session.session_key)",
            "                new_session_key = new_session.session_key",
            "                self.assertNotIn('foo', new_session)",
            "            finally:",
            "                self.session.delete(old_session_key)",
            "                self.session.delete(new_session_key)",
            "",
            "",
            "class DatabaseSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = DatabaseSession",
            "",
            "    def test_session_get_decoded(self):",
            "        \"\"\"",
            "        Test we can use Session.get_decoded to retrieve data stored",
            "        in normal way",
            "        \"\"\"",
            "        self.session['x'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "",
            "        self.assertEqual(s.get_decoded(), {'x': 1})",
            "",
            "    def test_sessionmanager_save(self):",
            "        \"\"\"",
            "        Test SessionManager.save method",
            "        \"\"\"",
            "        # Create a session",
            "        self.session['y'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "        # Change it",
            "        Session.objects.save(s.session_key, {'y': 2}, s.expire_date)",
            "        # Clear cache, so that it will be retrieved from DB",
            "        del self.session._session_cache",
            "        self.assertEqual(self.session['y'], 2)",
            "",
            "    @override_settings(SESSION_ENGINE=\"django.contrib.sessions.backends.db\")",
            "    def test_clearsessions_command(self):",
            "        \"\"\"",
            "        Test clearsessions command for clearing expired sessions.",
            "        \"\"\"",
            "        self.assertEqual(0, Session.objects.count())",
            "",
            "        # One object in the future",
            "        self.session['foo'] = 'bar'",
            "        self.session.set_expiry(3600)",
            "        self.session.save()",
            "",
            "        # One object in the past",
            "        other_session = self.backend()",
            "        other_session['foo'] = 'bar'",
            "        other_session.set_expiry(-3600)",
            "        other_session.save()",
            "",
            "        # Two sessions are in the database before clearsessions...",
            "        self.assertEqual(2, Session.objects.count())",
            "        management.call_command('clearsessions')",
            "        # ... and one is deleted.",
            "        self.assertEqual(1, Session.objects.count())",
            "",
            "",
            "@override_settings(USE_TZ=True)",
            "class DatabaseSessionWithTimeZoneTests(DatabaseSessionTests):",
            "    pass",
            "",
            "",
            "class CacheDBSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CacheDBSession",
            "",
            "    @unittest.skipIf('DummyCache' in",
            "        settings.CACHES[settings.SESSION_CACHE_ALIAS]['BACKEND'],",
            "        \"Session saving tests require a real cache backend\")",
            "    def test_exists_searches_cache_first(self):",
            "        self.session.save()",
            "        with self.assertNumQueries(0):",
            "            self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_load_overlong_key(self):",
            "        # Some backends might issue a warning",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\")",
            "            self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "            self.assertEqual(self.session.load(), {})",
            "",
            "    @override_settings(SESSION_CACHE_ALIAS='sessions')",
            "    def test_non_default_cache(self):",
            "        # 21000 - CacheDB backend should respect SESSION_CACHE_ALIAS.",
            "        self.assertRaises(InvalidCacheBackendError, self.backend)",
            "",
            "",
            "@override_settings(USE_TZ=True)",
            "class CacheDBSessionWithTimeZoneTests(CacheDBSessionTests):",
            "    pass",
            "",
            "",
            "# Don't need DB flushing for these tests, so can use unittest.TestCase as base class",
            "class FileSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = FileSession",
            "",
            "    def setUp(self):",
            "        # Do file session tests in an isolated directory, and kill it after we're done.",
            "        self.original_session_file_path = settings.SESSION_FILE_PATH",
            "        self.temp_session_store = settings.SESSION_FILE_PATH = tempfile.mkdtemp()",
            "        # Reset the file session backend's internal caches",
            "        if hasattr(self.backend, '_storage_path'):",
            "            del self.backend._storage_path",
            "        super(FileSessionTests, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(FileSessionTests, self).tearDown()",
            "        settings.SESSION_FILE_PATH = self.original_session_file_path",
            "        shutil.rmtree(self.temp_session_store)",
            "",
            "    @override_settings(",
            "        SESSION_FILE_PATH=\"/if/this/directory/exists/you/have/a/weird/computer\")",
            "    def test_configuration_check(self):",
            "        del self.backend._storage_path",
            "        # Make sure the file backend checks for a good storage dir",
            "        self.assertRaises(ImproperlyConfigured, self.backend)",
            "",
            "    def test_invalid_key_backslash(self):",
            "        # Ensure we don't allow directory-traversal.",
            "        # This is tested directly on _key_to_file, as load() will swallow",
            "        # a SuspiciousOperation in the same way as an IOError - by creating",
            "        # a new session, making it unclear whether the slashes were detected.",
            "        self.assertRaises(InvalidSessionKey,",
            "                          self.backend()._key_to_file, \"a\\\\b\\\\c\")",
            "",
            "    def test_invalid_key_forwardslash(self):",
            "        # Ensure we don't allow directory-traversal",
            "        self.assertRaises(InvalidSessionKey,",
            "                          self.backend()._key_to_file, \"a/b/c\")",
            "",
            "    @override_settings(SESSION_ENGINE=\"django.contrib.sessions.backends.file\")",
            "    def test_clearsessions_command(self):",
            "        \"\"\"",
            "        Test clearsessions command for clearing expired sessions.",
            "        \"\"\"",
            "        storage_path = self.backend._get_storage_path()",
            "        file_prefix = settings.SESSION_COOKIE_NAME",
            "",
            "        def count_sessions():",
            "            return len([session_file for session_file in os.listdir(storage_path)",
            "                if session_file.startswith(file_prefix)])",
            "",
            "        self.assertEqual(0, count_sessions())",
            "",
            "        # One object in the future",
            "        self.session['foo'] = 'bar'",
            "        self.session.set_expiry(3600)",
            "        self.session.save()",
            "",
            "        # One object in the past",
            "        other_session = self.backend()",
            "        other_session['foo'] = 'bar'",
            "        other_session.set_expiry(-3600)",
            "        other_session.save()",
            "",
            "        # Two sessions are in the filesystem before clearsessions...",
            "        self.assertEqual(2, count_sessions())",
            "        management.call_command('clearsessions')",
            "        # ... and one is deleted.",
            "        self.assertEqual(1, count_sessions())",
            "",
            "",
            "class CacheSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = CacheSession",
            "",
            "    def test_load_overlong_key(self):",
            "        # Some backends might issue a warning",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\")",
            "            self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "            self.assertEqual(self.session.load(), {})",
            "",
            "    def test_default_cache(self):",
            "        self.session.save()",
            "        self.assertNotEqual(caches['default'].get(self.session.cache_key), None)",
            "",
            "    @override_settings(CACHES={",
            "        'default': {",
            "            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',",
            "        },",
            "        'sessions': {",
            "            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',",
            "            'LOCATION': 'session',",
            "        },",
            "    }, SESSION_CACHE_ALIAS='sessions')",
            "    def test_non_default_cache(self):",
            "        # Re-initialize the session backend to make use of overridden settings.",
            "        self.session = self.backend()",
            "",
            "        self.session.save()",
            "        self.assertEqual(caches['default'].get(self.session.cache_key), None)",
            "        self.assertNotEqual(caches['sessions'].get(self.session.cache_key), None)",
            "",
            "",
            "class SessionMiddlewareTests(unittest.TestCase):",
            "",
            "    @override_settings(SESSION_COOKIE_SECURE=True)",
            "    def test_secure_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['secure'])",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=True)",
            "    def test_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "        self.assertIn(http_cookies.Morsel._reserved['httponly'],",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=False)",
            "    def test_no_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertFalse(response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "",
            "        self.assertNotIn(http_cookies.Morsel._reserved['httponly'],",
            "                         str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    def test_session_save_on_500(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Horrible error')",
            "        response.status_code = 500",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # Check that the value wasn't saved above.",
            "        self.assertNotIn('hello', request.session.load())",
            "",
            "",
            "class CookieSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CookieSession",
            "",
            "    def test_save(self):",
            "        \"\"\"",
            "        This test tested exists() in the other session backends, but that",
            "        doesn't make sense for us.",
            "        \"\"\"",
            "        pass",
            "",
            "    def test_cycle(self):",
            "        \"\"\"",
            "        This test tested cycle_key() which would create a new session",
            "        key for the same session data. But we can't invalidate previously",
            "        signed cookies (other than letting them expire naturally) so",
            "        testing for this behavior is meaningless.",
            "        \"\"\"",
            "        pass",
            "",
            "    @unittest.expectedFailure",
            "    def test_actual_expiry(self):",
            "        # The cookie backend doesn't handle non-default expiry dates, see #19201",
            "        super(CookieSessionTests, self).test_actual_expiry()"
        ],
        "afterPatchFile": [
            "import base64",
            "from datetime import timedelta",
            "import os",
            "import shutil",
            "import string",
            "import tempfile",
            "import unittest",
            "import warnings",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DatabaseSession",
            "from django.contrib.sessions.backends.cache import SessionStore as CacheSession",
            "from django.contrib.sessions.backends.cached_db import SessionStore as CacheDBSession",
            "from django.contrib.sessions.backends.file import SessionStore as FileSession",
            "from django.contrib.sessions.backends.signed_cookies import SessionStore as CookieSession",
            "from django.contrib.sessions.models import Session",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "from django.core.cache import caches",
            "from django.core.cache.backends.base import InvalidCacheBackendError",
            "from django.core import management",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.http import HttpResponse",
            "from django.test import TestCase, RequestFactory, override_settings",
            "from django.test.utils import patch_logger",
            "from django.utils import six",
            "from django.utils import timezone",
            "from django.utils.six.moves import http_cookies",
            "",
            "from django.contrib.sessions.exceptions import InvalidSessionKey",
            "",
            "",
            "class SessionTestsMixin(object):",
            "    # This does not inherit from TestCase to avoid any tests being run with this",
            "    # class, which wouldn't work, and to allow different TestCase subclasses to",
            "    # be used.",
            "",
            "    backend = None  # subclasses must specify",
            "",
            "    def setUp(self):",
            "        self.session = self.backend()",
            "",
            "    def tearDown(self):",
            "        # NB: be careful to delete any sessions created; stale sessions fill up",
            "        # the /tmp (with some backends) and eventually overwhelm it after lots",
            "        # of runs (think buildbots)",
            "        self.session.delete()",
            "",
            "    def test_new_session(self):",
            "        self.assertFalse(self.session.modified)",
            "        self.assertFalse(self.session.accessed)",
            "",
            "    def test_get_empty(self):",
            "        self.assertEqual(self.session.get('cat'), None)",
            "",
            "    def test_store(self):",
            "        self.session['cat'] = \"dog\"",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.pop('cat'), 'dog')",
            "",
            "    def test_pop(self):",
            "        self.session['some key'] = 'exists'",
            "        # Need to reset these to pretend we haven't accessed it:",
            "        self.accessed = False",
            "        self.modified = False",
            "",
            "        self.assertEqual(self.session.pop('some key'), 'exists')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('some key'), None)",
            "",
            "    def test_pop_default(self):",
            "        self.assertEqual(self.session.pop('some key', 'does not exist'),",
            "                         'does not exist')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_setdefault(self):",
            "        self.assertEqual(self.session.setdefault('foo', 'bar'), 'bar')",
            "        self.assertEqual(self.session.setdefault('foo', 'baz'), 'bar')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_update(self):",
            "        self.session.update({'update key': 1})",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('update key', None), 1)",
            "",
            "    def test_has_key(self):",
            "        self.session['some key'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertIn('some key', self.session)",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_values(self):",
            "        self.assertEqual(list(self.session.values()), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.session['some key'] = 1",
            "        self.assertEqual(list(self.session.values()), [1])",
            "",
            "    def test_iterkeys(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.iterkeys(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), ['x'])",
            "",
            "    def test_itervalues(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.itervalues(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [1])",
            "",
            "    def test_iteritems(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.iteritems(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [('x', 1)])",
            "",
            "    def test_clear(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertEqual(list(self.session.items()), [('x', 1)])",
            "        self.session.clear()",
            "        self.assertEqual(list(self.session.items()), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_save(self):",
            "        if (hasattr(self.session, '_cache') and 'DummyCache' in",
            "                settings.CACHES[settings.SESSION_CACHE_ALIAS]['BACKEND']):",
            "            raise unittest.SkipTest(\"Session saving tests require a real cache backend\")",
            "        self.session.save()",
            "        self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_delete(self):",
            "        self.session.save()",
            "        self.session.delete(self.session.session_key)",
            "        self.assertFalse(self.session.exists(self.session.session_key))",
            "",
            "    def test_flush(self):",
            "        self.session['foo'] = 'bar'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        self.session.flush()",
            "        self.assertFalse(self.session.exists(prev_key))",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertTrue(self.session.accessed)",
            "",
            "    def test_cycle(self):",
            "        self.session['a'], self.session['b'] = 'c', 'd'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        prev_data = list(self.session.items())",
            "        self.session.cycle_key()",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertEqual(list(self.session.items()), prev_data)",
            "",
            "    def test_save_doesnt_clear_data(self):",
            "        self.session['a'] = 'b'",
            "        self.session.save()",
            "        self.assertEqual(self.session['a'], 'b')",
            "",
            "    def test_invalid_key(self):",
            "        # Submitting an invalid session key (either by guessing, or if the db has",
            "        # removed the key) results in a new key being generated.",
            "        try:",
            "            session = self.backend('1')",
            "            try:",
            "                session.save()",
            "            except AttributeError:",
            "                self.fail(\"The session object did not save properly.  Middleware may be saving cache items without namespaces.\")",
            "            self.assertNotEqual(session.session_key, '1')",
            "            self.assertEqual(session.get('cat'), None)",
            "            session.delete()",
            "        finally:",
            "            # Some backends leave a stale cache entry for the invalid",
            "            # session key; make sure that entry is manually deleted",
            "            session.delete('1')",
            "",
            "    def test_session_key_is_read_only(self):",
            "        def set_session_key(session):",
            "            session.session_key = session._get_new_session_key()",
            "        self.assertRaises(AttributeError, set_session_key, self.session)",
            "",
            "    # Custom session expiry",
            "    def test_default_expiry(self):",
            "        # A normal session has a max age equal to settings",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "        # So does a custom session with an idle expiration time of 0 (but it'll",
            "        # expire at browser close)",
            "        self.session.set_expiry(0)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_custom_expiry_seconds(self):",
            "        modification = timezone.now()",
            "",
            "        self.session.set_expiry(10)",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_timedelta(self):",
            "        modification = timezone.now()",
            "",
            "        # Mock timezone.now, because set_expiry calls it on this code path.",
            "        original_now = timezone.now",
            "        try:",
            "            timezone.now = lambda: modification",
            "            self.session.set_expiry(timedelta(seconds=10))",
            "        finally:",
            "            timezone.now = original_now",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_datetime(self):",
            "        modification = timezone.now()",
            "",
            "        self.session.set_expiry(modification + timedelta(seconds=10))",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_reset(self):",
            "        self.session.set_expiry(None)",
            "        self.session.set_expiry(10)",
            "        self.session.set_expiry(None)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_get_expire_at_browser_close(self):",
            "        # Tests get_expire_at_browser_close with different settings and different",
            "        # set_expiry calls",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=False):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=True):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "    def test_decode(self):",
            "        # Ensure we can decode what we encode",
            "        data = {'a test key': 'a test value'}",
            "        encoded = self.session.encode(data)",
            "        self.assertEqual(self.session.decode(encoded), data)",
            "",
            "    def test_decode_failure_logged_to_security(self):",
            "        bad_encode = base64.b64encode(b'flaskdj:alkdjf')",
            "        with patch_logger('django.security.SuspiciousSession', 'warning') as calls:",
            "            self.assertEqual({}, self.session.decode(bad_encode))",
            "            # check that the failed decode is logged",
            "            self.assertEqual(len(calls), 1)",
            "            self.assertTrue('corrupted' in calls[0])",
            "",
            "    def test_actual_expiry(self):",
            "        # this doesn't work with JSONSerializer (serializing timedelta)",
            "        with override_settings(SESSION_SERIALIZER='django.contrib.sessions.serializers.PickleSerializer'):",
            "            self.session = self.backend()  # reinitialize after overriding settings",
            "",
            "            # Regression test for #19200",
            "            old_session_key = None",
            "            new_session_key = None",
            "            try:",
            "                self.session['foo'] = 'bar'",
            "                self.session.set_expiry(-timedelta(seconds=10))",
            "                self.session.save()",
            "                old_session_key = self.session.session_key",
            "                # With an expiry date in the past, the session expires instantly.",
            "                new_session = self.backend(self.session.session_key)",
            "                new_session_key = new_session.session_key",
            "                self.assertNotIn('foo', new_session)",
            "            finally:",
            "                self.session.delete(old_session_key)",
            "                self.session.delete(new_session_key)",
            "",
            "    def test_session_load_does_not_create_record(self):",
            "        \"\"\"",
            "        Loading an unknown session key does not create a session record.",
            "",
            "        Creating session records on load is a DOS vulnerability.",
            "        \"\"\"",
            "        if self.backend is CookieSession:",
            "            raise unittest.SkipTest(\"Cookie backend doesn't have an external store to create records in.\")",
            "        session = self.backend('someunknownkey')",
            "        session.load()",
            "",
            "        self.assertFalse(session.exists(session.session_key))",
            "        # provided unknown key was cycled, not reused",
            "        self.assertNotEqual(session.session_key, 'someunknownkey')",
            "",
            "",
            "class DatabaseSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = DatabaseSession",
            "",
            "    def test_session_get_decoded(self):",
            "        \"\"\"",
            "        Test we can use Session.get_decoded to retrieve data stored",
            "        in normal way",
            "        \"\"\"",
            "        self.session['x'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "",
            "        self.assertEqual(s.get_decoded(), {'x': 1})",
            "",
            "    def test_sessionmanager_save(self):",
            "        \"\"\"",
            "        Test SessionManager.save method",
            "        \"\"\"",
            "        # Create a session",
            "        self.session['y'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "        # Change it",
            "        Session.objects.save(s.session_key, {'y': 2}, s.expire_date)",
            "        # Clear cache, so that it will be retrieved from DB",
            "        del self.session._session_cache",
            "        self.assertEqual(self.session['y'], 2)",
            "",
            "    @override_settings(SESSION_ENGINE=\"django.contrib.sessions.backends.db\")",
            "    def test_clearsessions_command(self):",
            "        \"\"\"",
            "        Test clearsessions command for clearing expired sessions.",
            "        \"\"\"",
            "        self.assertEqual(0, Session.objects.count())",
            "",
            "        # One object in the future",
            "        self.session['foo'] = 'bar'",
            "        self.session.set_expiry(3600)",
            "        self.session.save()",
            "",
            "        # One object in the past",
            "        other_session = self.backend()",
            "        other_session['foo'] = 'bar'",
            "        other_session.set_expiry(-3600)",
            "        other_session.save()",
            "",
            "        # Two sessions are in the database before clearsessions...",
            "        self.assertEqual(2, Session.objects.count())",
            "        management.call_command('clearsessions')",
            "        # ... and one is deleted.",
            "        self.assertEqual(1, Session.objects.count())",
            "",
            "",
            "@override_settings(USE_TZ=True)",
            "class DatabaseSessionWithTimeZoneTests(DatabaseSessionTests):",
            "    pass",
            "",
            "",
            "class CacheDBSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CacheDBSession",
            "",
            "    @unittest.skipIf('DummyCache' in",
            "        settings.CACHES[settings.SESSION_CACHE_ALIAS]['BACKEND'],",
            "        \"Session saving tests require a real cache backend\")",
            "    def test_exists_searches_cache_first(self):",
            "        self.session.save()",
            "        with self.assertNumQueries(0):",
            "            self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_load_overlong_key(self):",
            "        # Some backends might issue a warning",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\")",
            "            self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "            self.assertEqual(self.session.load(), {})",
            "",
            "    @override_settings(SESSION_CACHE_ALIAS='sessions')",
            "    def test_non_default_cache(self):",
            "        # 21000 - CacheDB backend should respect SESSION_CACHE_ALIAS.",
            "        self.assertRaises(InvalidCacheBackendError, self.backend)",
            "",
            "",
            "@override_settings(USE_TZ=True)",
            "class CacheDBSessionWithTimeZoneTests(CacheDBSessionTests):",
            "    pass",
            "",
            "",
            "# Don't need DB flushing for these tests, so can use unittest.TestCase as base class",
            "class FileSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = FileSession",
            "",
            "    def setUp(self):",
            "        # Do file session tests in an isolated directory, and kill it after we're done.",
            "        self.original_session_file_path = settings.SESSION_FILE_PATH",
            "        self.temp_session_store = settings.SESSION_FILE_PATH = tempfile.mkdtemp()",
            "        # Reset the file session backend's internal caches",
            "        if hasattr(self.backend, '_storage_path'):",
            "            del self.backend._storage_path",
            "        super(FileSessionTests, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(FileSessionTests, self).tearDown()",
            "        settings.SESSION_FILE_PATH = self.original_session_file_path",
            "        shutil.rmtree(self.temp_session_store)",
            "",
            "    @override_settings(",
            "        SESSION_FILE_PATH=\"/if/this/directory/exists/you/have/a/weird/computer\")",
            "    def test_configuration_check(self):",
            "        del self.backend._storage_path",
            "        # Make sure the file backend checks for a good storage dir",
            "        self.assertRaises(ImproperlyConfigured, self.backend)",
            "",
            "    def test_invalid_key_backslash(self):",
            "        # Ensure we don't allow directory-traversal.",
            "        # This is tested directly on _key_to_file, as load() will swallow",
            "        # a SuspiciousOperation in the same way as an IOError - by creating",
            "        # a new session, making it unclear whether the slashes were detected.",
            "        self.assertRaises(InvalidSessionKey,",
            "                          self.backend()._key_to_file, \"a\\\\b\\\\c\")",
            "",
            "    def test_invalid_key_forwardslash(self):",
            "        # Ensure we don't allow directory-traversal",
            "        self.assertRaises(InvalidSessionKey,",
            "                          self.backend()._key_to_file, \"a/b/c\")",
            "",
            "    @override_settings(SESSION_ENGINE=\"django.contrib.sessions.backends.file\")",
            "    def test_clearsessions_command(self):",
            "        \"\"\"",
            "        Test clearsessions command for clearing expired sessions.",
            "        \"\"\"",
            "        storage_path = self.backend._get_storage_path()",
            "        file_prefix = settings.SESSION_COOKIE_NAME",
            "",
            "        def count_sessions():",
            "            return len([session_file for session_file in os.listdir(storage_path)",
            "                if session_file.startswith(file_prefix)])",
            "",
            "        self.assertEqual(0, count_sessions())",
            "",
            "        # One object in the future",
            "        self.session['foo'] = 'bar'",
            "        self.session.set_expiry(3600)",
            "        self.session.save()",
            "",
            "        # One object in the past",
            "        other_session = self.backend()",
            "        other_session['foo'] = 'bar'",
            "        other_session.set_expiry(-3600)",
            "        other_session.save()",
            "",
            "        # Two sessions are in the filesystem before clearsessions...",
            "        self.assertEqual(2, count_sessions())",
            "        management.call_command('clearsessions')",
            "        # ... and one is deleted.",
            "        self.assertEqual(1, count_sessions())",
            "",
            "",
            "class CacheSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = CacheSession",
            "",
            "    def test_load_overlong_key(self):",
            "        # Some backends might issue a warning",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\")",
            "            self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "            self.assertEqual(self.session.load(), {})",
            "",
            "    def test_default_cache(self):",
            "        self.session.save()",
            "        self.assertNotEqual(caches['default'].get(self.session.cache_key), None)",
            "",
            "    @override_settings(CACHES={",
            "        'default': {",
            "            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',",
            "        },",
            "        'sessions': {",
            "            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',",
            "            'LOCATION': 'session',",
            "        },",
            "    }, SESSION_CACHE_ALIAS='sessions')",
            "    def test_non_default_cache(self):",
            "        # Re-initialize the session backend to make use of overridden settings.",
            "        self.session = self.backend()",
            "",
            "        self.session.save()",
            "        self.assertEqual(caches['default'].get(self.session.cache_key), None)",
            "        self.assertNotEqual(caches['sessions'].get(self.session.cache_key), None)",
            "",
            "",
            "class SessionMiddlewareTests(unittest.TestCase):",
            "",
            "    @override_settings(SESSION_COOKIE_SECURE=True)",
            "    def test_secure_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['secure'])",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=True)",
            "    def test_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "        self.assertIn(http_cookies.Morsel._reserved['httponly'],",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=False)",
            "    def test_no_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertFalse(response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "",
            "        self.assertNotIn(http_cookies.Morsel._reserved['httponly'],",
            "                         str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    def test_session_save_on_500(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Horrible error')",
            "        response.status_code = 500",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # Check that the value wasn't saved above.",
            "        self.assertNotIn('hello', request.session.load())",
            "",
            "",
            "class CookieSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CookieSession",
            "",
            "    def test_save(self):",
            "        \"\"\"",
            "        This test tested exists() in the other session backends, but that",
            "        doesn't make sense for us.",
            "        \"\"\"",
            "        pass",
            "",
            "    def test_cycle(self):",
            "        \"\"\"",
            "        This test tested cycle_key() which would create a new session",
            "        key for the same session data. But we can't invalidate previously",
            "        signed cookies (other than letting them expire naturally) so",
            "        testing for this behavior is meaningless.",
            "        \"\"\"",
            "        pass",
            "",
            "    @unittest.expectedFailure",
            "    def test_actual_expiry(self):",
            "        # The cookie backend doesn't handle non-default expiry dates, see #19201",
            "        super(CookieSessionTests, self).test_actual_expiry()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "django.contrib.sessions.tests.SessionTestsMixin.self",
            "litestar.connection.request"
        ]
    }
}