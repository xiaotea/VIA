{
    "tcms/core/history.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from simple_history.admin import SimpleHistoryAdmin"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from simple_history.models import HistoricalRecords"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from tcms.core.templatetags.extra_filters import bleach_input"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " def diff_objects(old_instance, new_instance, fields):"
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "         field_diff = []"
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         old_value = getattr(old_instance, field.attname)"
            },
            "10": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         new_value = getattr(new_instance, field.attname)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+        # clean stored XSS"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        if isinstance(old_value, str):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+            old_value = bleach_input(old_value)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        if isinstance(new_value, str):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+            new_value = bleach_input(new_value)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         for line in difflib.unified_diff("
            },
            "19": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "             str(old_value).split(\"\\n\"),"
            },
            "20": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "             str(new_value).split(\"\\n\"),"
            }
        },
        "frontPatchFile": [
            "# pylint: disable=unused-argument, no-self-use, avoid-list-comprehension",
            "import difflib",
            "",
            "from django.db.models import signals",
            "from django.http import HttpResponseRedirect",
            "from django.template.defaultfilters import safe",
            "from django.utils.translation import gettext_lazy as _",
            "from simple_history.admin import SimpleHistoryAdmin",
            "from simple_history.models import HistoricalRecords",
            "",
            "",
            "def diff_objects(old_instance, new_instance, fields):",
            "    \"\"\"",
            "    Diff two objects by examining the given fields and",
            "    return a string.",
            "    \"\"\"",
            "    full_diff = []",
            "",
            "    for field in fields:",
            "        field_diff = []",
            "        old_value = getattr(old_instance, field.attname)",
            "        new_value = getattr(new_instance, field.attname)",
            "        for line in difflib.unified_diff(",
            "            str(old_value).split(\"\\n\"),",
            "            str(new_value).split(\"\\n\"),",
            "            fromfile=field.attname,",
            "            tofile=field.attname,",
            "            lineterm=\"\",",
            "        ):",
            "            field_diff.append(line)",
            "        full_diff.extend(field_diff)",
            "",
            "    return \"\\n\".join(full_diff)",
            "",
            "",
            "def history_email_for(instance, title):",
            "    \"\"\"",
            "    Generate the subject and email body that is sent via",
            "    email notifications post update!",
            "    \"\"\"",
            "    history = instance.history.latest()",
            "",
            "    subject = _(\"UPDATE: %(model_name)s #%(pk)d - %(title)s\") % {",
            "        \"model_name\": instance.__class__.__name__,",
            "        \"pk\": instance.pk,",
            "        \"title\": title,",
            "    }",
            "",
            "    body = (",
            "        _(",
            "            \"\"\"Updated on %(history_date)s",
            "Updated by %(username)s",
            "",
            "%(diff)s",
            "",
            "For more information:",
            "%(instance_url)s\"\"\"",
            "        )",
            "        % {",
            "            \"history_date\": history.history_date.strftime(\"%c\"),",
            "            \"username\": getattr(history.history_user, \"username\", \"\"),",
            "            \"diff\": history.history_change_reason,",
            "            \"instance_url\": instance.get_full_url(),",
            "        }",
            "    )",
            "    return subject, body",
            "",
            "",
            "class KiwiHistoricalRecords(HistoricalRecords):",
            "    \"\"\"",
            "    This class will keep track of what fields were changed",
            "    inside of the ``history_change_reason`` field. This gives us",
            "    a crude changelog until upstream introduces their new interface.",
            "    \"\"\"",
            "",
            "    def pre_save(self, instance, **kwargs):",
            "        \"\"\"",
            "        Signal handlers don't have access to the previous version of",
            "        an object so we have to load it from the database!",
            "        \"\"\"",
            "        if kwargs.get(\"raw\", False):",
            "            return",
            "",
            "        if instance.pk and hasattr(instance, \"history\"):",
            "            instance.previous = instance.__class__.objects.filter(",
            "                pk=instance.pk",
            "            ).first()",
            "",
            "    def post_save(self, instance, created, using=None, **kwargs):",
            "        \"\"\"",
            "        Calculate the changelog and call the inherited method to",
            "        write the data into the database.",
            "        \"\"\"",
            "        if kwargs.get(\"raw\", False):",
            "            return",
            "",
            "        if hasattr(instance, \"previous\") and instance.previous:",
            "            # note: simple_history.utils.update_change_reason() performs an extra",
            "            # DB query so it is better to use the private field instead!",
            "            # In older simple_history version this field wasn't private but was renamed",
            "            # in 2.10.0 hence the pylint disable!",
            "            instance._change_reason = diff_objects(  # pylint: disable=protected-access",
            "                instance.previous, instance, self.fields_included(instance)",
            "            )",
            "        super().post_save(instance, created, using, **kwargs)",
            "",
            "    def finalize(self, sender, **kwargs):",
            "        \"\"\"",
            "        Connect the pre_save signal handler after calling the inherited method.",
            "        \"\"\"",
            "        super().finalize(sender, **kwargs)",
            "        signals.pre_save.connect(self.pre_save, sender=sender, weak=False)",
            "",
            "",
            "class ReadOnlyHistoryAdmin(SimpleHistoryAdmin):",
            "    \"\"\"",
            "    Custom history admin which shows all fields",
            "    as read-only.",
            "    \"\"\"",
            "",
            "    history_list_display = [\"Diff\"]",
            "",
            "    def Diff(self, obj):  # pylint: disable=invalid-name",
            "        return safe(f\"<pre>{obj.history_change_reason}</pre>\")",
            "",
            "    def get_readonly_fields(self, request, obj=None):",
            "        # make all fields readonly",
            "        readonly_fields = list(",
            "            set(",
            "                [field.name for field in self.opts.local_fields]",
            "                + [field.name for field in self.opts.local_many_to_many]",
            "            )",
            "        )",
            "        return readonly_fields",
            "",
            "    def response_change(self, request, obj):",
            "        super().response_change(request, obj)",
            "        return HttpResponseRedirect(obj.get_absolute_url())"
        ],
        "afterPatchFile": [
            "# pylint: disable=unused-argument, no-self-use, avoid-list-comprehension",
            "import difflib",
            "",
            "from django.db.models import signals",
            "from django.http import HttpResponseRedirect",
            "from django.template.defaultfilters import safe",
            "from django.utils.translation import gettext_lazy as _",
            "from simple_history.admin import SimpleHistoryAdmin",
            "from simple_history.models import HistoricalRecords",
            "",
            "from tcms.core.templatetags.extra_filters import bleach_input",
            "",
            "",
            "def diff_objects(old_instance, new_instance, fields):",
            "    \"\"\"",
            "    Diff two objects by examining the given fields and",
            "    return a string.",
            "    \"\"\"",
            "    full_diff = []",
            "",
            "    for field in fields:",
            "        field_diff = []",
            "        old_value = getattr(old_instance, field.attname)",
            "        new_value = getattr(new_instance, field.attname)",
            "",
            "        # clean stored XSS",
            "        if isinstance(old_value, str):",
            "            old_value = bleach_input(old_value)",
            "        if isinstance(new_value, str):",
            "            new_value = bleach_input(new_value)",
            "",
            "        for line in difflib.unified_diff(",
            "            str(old_value).split(\"\\n\"),",
            "            str(new_value).split(\"\\n\"),",
            "            fromfile=field.attname,",
            "            tofile=field.attname,",
            "            lineterm=\"\",",
            "        ):",
            "            field_diff.append(line)",
            "        full_diff.extend(field_diff)",
            "",
            "    return \"\\n\".join(full_diff)",
            "",
            "",
            "def history_email_for(instance, title):",
            "    \"\"\"",
            "    Generate the subject and email body that is sent via",
            "    email notifications post update!",
            "    \"\"\"",
            "    history = instance.history.latest()",
            "",
            "    subject = _(\"UPDATE: %(model_name)s #%(pk)d - %(title)s\") % {",
            "        \"model_name\": instance.__class__.__name__,",
            "        \"pk\": instance.pk,",
            "        \"title\": title,",
            "    }",
            "",
            "    body = (",
            "        _(",
            "            \"\"\"Updated on %(history_date)s",
            "Updated by %(username)s",
            "",
            "%(diff)s",
            "",
            "For more information:",
            "%(instance_url)s\"\"\"",
            "        )",
            "        % {",
            "            \"history_date\": history.history_date.strftime(\"%c\"),",
            "            \"username\": getattr(history.history_user, \"username\", \"\"),",
            "            \"diff\": history.history_change_reason,",
            "            \"instance_url\": instance.get_full_url(),",
            "        }",
            "    )",
            "    return subject, body",
            "",
            "",
            "class KiwiHistoricalRecords(HistoricalRecords):",
            "    \"\"\"",
            "    This class will keep track of what fields were changed",
            "    inside of the ``history_change_reason`` field. This gives us",
            "    a crude changelog until upstream introduces their new interface.",
            "    \"\"\"",
            "",
            "    def pre_save(self, instance, **kwargs):",
            "        \"\"\"",
            "        Signal handlers don't have access to the previous version of",
            "        an object so we have to load it from the database!",
            "        \"\"\"",
            "        if kwargs.get(\"raw\", False):",
            "            return",
            "",
            "        if instance.pk and hasattr(instance, \"history\"):",
            "            instance.previous = instance.__class__.objects.filter(",
            "                pk=instance.pk",
            "            ).first()",
            "",
            "    def post_save(self, instance, created, using=None, **kwargs):",
            "        \"\"\"",
            "        Calculate the changelog and call the inherited method to",
            "        write the data into the database.",
            "        \"\"\"",
            "        if kwargs.get(\"raw\", False):",
            "            return",
            "",
            "        if hasattr(instance, \"previous\") and instance.previous:",
            "            # note: simple_history.utils.update_change_reason() performs an extra",
            "            # DB query so it is better to use the private field instead!",
            "            # In older simple_history version this field wasn't private but was renamed",
            "            # in 2.10.0 hence the pylint disable!",
            "            instance._change_reason = diff_objects(  # pylint: disable=protected-access",
            "                instance.previous, instance, self.fields_included(instance)",
            "            )",
            "        super().post_save(instance, created, using, **kwargs)",
            "",
            "    def finalize(self, sender, **kwargs):",
            "        \"\"\"",
            "        Connect the pre_save signal handler after calling the inherited method.",
            "        \"\"\"",
            "        super().finalize(sender, **kwargs)",
            "        signals.pre_save.connect(self.pre_save, sender=sender, weak=False)",
            "",
            "",
            "class ReadOnlyHistoryAdmin(SimpleHistoryAdmin):",
            "    \"\"\"",
            "    Custom history admin which shows all fields",
            "    as read-only.",
            "    \"\"\"",
            "",
            "    history_list_display = [\"Diff\"]",
            "",
            "    def Diff(self, obj):  # pylint: disable=invalid-name",
            "        return safe(f\"<pre>{obj.history_change_reason}</pre>\")",
            "",
            "    def get_readonly_fields(self, request, obj=None):",
            "        # make all fields readonly",
            "        readonly_fields = list(",
            "            set(",
            "                [field.name for field in self.opts.local_fields]",
            "                + [field.name for field in self.opts.local_many_to_many]",
            "            )",
            "        )",
            "        return readonly_fields",
            "",
            "    def response_change(self, request, obj):",
            "        super().response_change(request, obj)",
            "        return HttpResponseRedirect(obj.get_absolute_url())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.pyload.webui.app",
            "tcms.core.history.diff_objects.full_diff",
            "tcms.core.history.diff_objects.field_diff",
            "tcms.core.history.KiwiHistoricalRecords.post_save"
        ]
    }
}