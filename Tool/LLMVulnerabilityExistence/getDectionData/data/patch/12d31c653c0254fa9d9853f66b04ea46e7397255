{
    "cairosvg/__main__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         help='replace every raster pixel with its complementary color')"
            },
            "1": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     parser.add_argument("
            },
            "2": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         '-u', '--unsafe', action='store_true',"
            },
            "3": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help='resolve XML entities and allow very large files '"
            },
            "4": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-             '(WARNING: vulnerable to XXE attacks and various DoS)')"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        help='fetch external files, resolve XML entities and allow very large '"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+             'files (WARNING: vulnerable to XXE attacks and various DoS)')"
            },
            "7": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     parser.add_argument("
            },
            "8": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         '--output-width', default=None, type=float,"
            },
            "9": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         help='desired output width in pixels')"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Command-line interface to CairoSVG.",
            "",
            "\"\"\"",
            "",
            "import argparse",
            "import os",
            "import sys",
            "",
            "from . import SURFACES, VERSION",
            "",
            "",
            "def main(argv=None, stdout=None, stdin=None):",
            "    \"\"\"Entry-point of the executable.\"\"\"",
            "    # Get command-line options",
            "    parser = argparse.ArgumentParser(",
            "        description='Convert SVG files to other formats')",
            "    parser.add_argument('input', default='-', help='input filename or URL')",
            "    parser.add_argument(",
            "        '-v', '--version', action='version', version=VERSION)",
            "    parser.add_argument(",
            "        '-f', '--format', help='output format',",
            "        choices=sorted([surface.lower() for surface in SURFACES]))",
            "    parser.add_argument(",
            "        '-d', '--dpi', default=96, type=float,",
            "        help='ratio between 1 inch and 1 pixel')",
            "    parser.add_argument(",
            "        '-W', '--width', default=None, type=float,",
            "        help='width of the parent container in pixels')",
            "    parser.add_argument(",
            "        '-H', '--height', default=None, type=float,",
            "        help='height of the parent container in pixels')",
            "    parser.add_argument(",
            "        '-s', '--scale', default=1, type=float, help='output scaling factor')",
            "    parser.add_argument(",
            "        '-b', '--background', metavar='COLOR', help='output background color')",
            "    parser.add_argument(",
            "        '-n', '--negate-colors', action='store_true',",
            "        help='replace every vector color with its complement')",
            "    parser.add_argument(",
            "        '-i', '--invert-images', action='store_true',",
            "        help='replace every raster pixel with its complementary color')",
            "    parser.add_argument(",
            "        '-u', '--unsafe', action='store_true',",
            "        help='resolve XML entities and allow very large files '",
            "             '(WARNING: vulnerable to XXE attacks and various DoS)')",
            "    parser.add_argument(",
            "        '--output-width', default=None, type=float,",
            "        help='desired output width in pixels')",
            "    parser.add_argument(",
            "        '--output-height', default=None, type=float,",
            "        help='desired output height in pixels')",
            "",
            "    parser.add_argument('-o', '--output', default='-', help='output filename')",
            "",
            "    options = parser.parse_args(argv)",
            "    kwargs = {",
            "        'parent_width': options.width, 'parent_height': options.height,",
            "        'dpi': options.dpi, 'scale': options.scale, 'unsafe': options.unsafe,",
            "        'background_color': options.background,",
            "        'negate_colors': options.negate_colors,",
            "        'invert_images': options.invert_images,",
            "        'output_width': options.output_width,",
            "        'output_height': options.output_height}",
            "    stdin = stdin or sys.stdin",
            "    stdout = stdout or sys.stdout",
            "    kwargs['write_to'] = (",
            "        stdout.buffer if options.output == '-' else options.output)",
            "    if options.input == '-':",
            "        kwargs['file_obj'] = stdin.buffer",
            "    else:",
            "        kwargs['url'] = options.input",
            "    output_format = (",
            "        options.format or",
            "        os.path.splitext(options.output)[1].lstrip('.') or",
            "        'pdf').upper()",
            "",
            "    SURFACES[output_format.upper()].convert(**kwargs)",
            "",
            "",
            "if __name__ == '__main__':  # pragma: no cover",
            "    main()"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Command-line interface to CairoSVG.",
            "",
            "\"\"\"",
            "",
            "import argparse",
            "import os",
            "import sys",
            "",
            "from . import SURFACES, VERSION",
            "",
            "",
            "def main(argv=None, stdout=None, stdin=None):",
            "    \"\"\"Entry-point of the executable.\"\"\"",
            "    # Get command-line options",
            "    parser = argparse.ArgumentParser(",
            "        description='Convert SVG files to other formats')",
            "    parser.add_argument('input', default='-', help='input filename or URL')",
            "    parser.add_argument(",
            "        '-v', '--version', action='version', version=VERSION)",
            "    parser.add_argument(",
            "        '-f', '--format', help='output format',",
            "        choices=sorted([surface.lower() for surface in SURFACES]))",
            "    parser.add_argument(",
            "        '-d', '--dpi', default=96, type=float,",
            "        help='ratio between 1 inch and 1 pixel')",
            "    parser.add_argument(",
            "        '-W', '--width', default=None, type=float,",
            "        help='width of the parent container in pixels')",
            "    parser.add_argument(",
            "        '-H', '--height', default=None, type=float,",
            "        help='height of the parent container in pixels')",
            "    parser.add_argument(",
            "        '-s', '--scale', default=1, type=float, help='output scaling factor')",
            "    parser.add_argument(",
            "        '-b', '--background', metavar='COLOR', help='output background color')",
            "    parser.add_argument(",
            "        '-n', '--negate-colors', action='store_true',",
            "        help='replace every vector color with its complement')",
            "    parser.add_argument(",
            "        '-i', '--invert-images', action='store_true',",
            "        help='replace every raster pixel with its complementary color')",
            "    parser.add_argument(",
            "        '-u', '--unsafe', action='store_true',",
            "        help='fetch external files, resolve XML entities and allow very large '",
            "             'files (WARNING: vulnerable to XXE attacks and various DoS)')",
            "    parser.add_argument(",
            "        '--output-width', default=None, type=float,",
            "        help='desired output width in pixels')",
            "    parser.add_argument(",
            "        '--output-height', default=None, type=float,",
            "        help='desired output height in pixels')",
            "",
            "    parser.add_argument('-o', '--output', default='-', help='output filename')",
            "",
            "    options = parser.parse_args(argv)",
            "    kwargs = {",
            "        'parent_width': options.width, 'parent_height': options.height,",
            "        'dpi': options.dpi, 'scale': options.scale, 'unsafe': options.unsafe,",
            "        'background_color': options.background,",
            "        'negate_colors': options.negate_colors,",
            "        'invert_images': options.invert_images,",
            "        'output_width': options.output_width,",
            "        'output_height': options.output_height}",
            "    stdin = stdin or sys.stdin",
            "    stdout = stdout or sys.stdout",
            "    kwargs['write_to'] = (",
            "        stdout.buffer if options.output == '-' else options.output)",
            "    if options.input == '-':",
            "        kwargs['file_obj'] = stdin.buffer",
            "    else:",
            "        kwargs['url'] = options.input",
            "    output_format = (",
            "        options.format or",
            "        os.path.splitext(options.output)[1].lstrip('.') or",
            "        'pdf').upper()",
            "",
            "    SURFACES[output_format.upper()].convert(**kwargs)",
            "",
            "",
            "if __name__ == '__main__':  # pragma: no cover",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "45": [
                "main"
            ],
            "46": [
                "main"
            ]
        },
        "addLocation": []
    },
    "cairosvg/parser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "             tree = ElementTree.fromstring("
            },
            "1": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "                 bytestring, forbid_entities=not unsafe,"
            },
            "2": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 392,
                "PatchRowcode": "                 forbid_external=not unsafe)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+        # Don\u2019t allow fetching external files unless explicitly asked for"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+        if 'url_fetcher' not in kwargs and not unsafe:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+            self.url_fetcher = ("
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+                lambda *args, **kwargs: b'<svg width=\"1\" height=\"1\"></svg>')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "         self.xml_tree = tree"
            },
            "10": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "         root = cssselect2.ElementWrapper.from_xml_root(tree)"
            },
            "11": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         style = parent.style if parent else css.parse_stylesheets(self, url)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "SVG Parser.",
            "",
            "\"\"\"",
            "",
            "import gzip",
            "import re",
            "from urllib.parse import urlunparse",
            "from xml.etree.ElementTree import Element",
            "",
            "import cssselect2",
            "from defusedxml import ElementTree",
            "",
            "from . import css",
            "from .features import match_features",
            "from .helpers import flatten, pop_rotation, rotations",
            "from .url import fetch, parse_url, read_url",
            "",
            "# 'display' is actually inherited but handled differently because some markers",
            "# are part of a none-displaying group (see test painting-marker-07-f.svg)",
            "NOT_INHERITED_ATTRIBUTES = frozenset((",
            "    'clip',",
            "    'clip-path',",
            "    'display',",
            "    'filter',",
            "    'height',",
            "    'id',",
            "    'mask',",
            "    'opacity',",
            "    'overflow',",
            "    'rotate',",
            "    'stop-color',",
            "    'stop-opacity',",
            "    'style',",
            "    'transform',",
            "    'transform-origin',",
            "    'viewBox',",
            "    'width',",
            "    'x',",
            "    'y',",
            "    'dx',",
            "    'dy',",
            "    '{http://www.w3.org/1999/xlink}href',",
            "    'href',",
            "))",
            "",
            "COLOR_ATTRIBUTES = frozenset((",
            "    'fill',",
            "    'flood-color',",
            "    'lighting-color',",
            "    'stop-color',",
            "    'stroke',",
            "))",
            "",
            "",
            "def handle_white_spaces(string, preserve):",
            "    \"\"\"Handle white spaces in text nodes.",
            "",
            "    See http://www.w3.org/TR/SVG/text.html#WhiteSpace",
            "",
            "    \"\"\"",
            "    if not string:",
            "        return ''",
            "    if preserve:",
            "        return re.sub('[\\n\\r\\t]', ' ', string)",
            "    else:",
            "        string = re.sub('[\\n\\r]', '', string)",
            "        string = re.sub('\\t', ' ', string)",
            "        return re.sub(' +', ' ', string)",
            "",
            "",
            "def normalize_style_declaration(name, value):",
            "    \"\"\"Normalize style declaration consisting of name/value pair.",
            "",
            "    Names are always case insensitive, make all lowercase.",
            "    Values are case insensitive in most cases. Adapt for 'specials':",
            "        id - case sensitive identifier",
            "        class - case sensitive identifier(s)",
            "        font-family - case sensitive name(s)",
            "        font - shorthand in which font-family is case sensitive",
            "        any declaration with url in value - url is case sensitive",
            "",
            "    \"\"\"",
            "    name = name.strip().lower()",
            "    value = value.strip()",
            "    if name in CASE_SENSITIVE_STYLE_METHODS:",
            "        value = CASE_SENSITIVE_STYLE_METHODS[name](value)",
            "    else:",
            "        value = value.lower()",
            "",
            "    return name, value",
            "",
            "",
            "def normalize_noop_style_declaration(value):",
            "    \"\"\"No-operation for normalization where value is case sensitive.",
            "",
            "    This is actually the exception to the rule. Normally value will be made",
            "    lowercase (see normalize_style_declaration above).",
            "",
            "    \"\"\"",
            "    return value",
            "",
            "",
            "def normalize_url_style_declaration(value):",
            "    \"\"\"Normalize style declaration, but keep URL's as-is.",
            "",
            "    Lowercase everything except for the URL.",
            "",
            "    \"\"\"",
            "    regex_style = re.compile(r\"\"\"",
            "        (.*?)                               # non-URL part (will be normalized)",
            "        (?:",
            "            url\\(\\s*                        # url(<whitespace>",
            "                (?:",
            "                      \"(?:\\\\.|[^\"])*\"       # \"<url>\"",
            "                    | \\'(?:\\\\.|[^\\'])*\\'    # '<url>'",
            "                    | (?:\\\\.|[^\\)])*        # <url>",
            "                )",
            "            \\s*\\)                           # <whitespace>)",
            "            |$",
            "        )",
            "    \"\"\", re.IGNORECASE | re.VERBOSE)",
            "    for match in regex_style.finditer(value):",
            "        value_start = value[:match.start()] if match.start() > 0 else ''",
            "        normalized_value = match.group(1).lower()",
            "        value_end = value[match.start() + len(normalized_value):]",
            "        value = value_start + normalized_value + value_end",
            "    return value",
            "",
            "",
            "def normalize_font_style_declaration(value):",
            "    \"\"\"Make first part of font style declaration lowercase (case insensitive).",
            "",
            "    Lowercase first part of declaration. Only the font name is case sensitive.",
            "    The font name is at the end of the declaration and can be 'recognized'",
            "    by being preceded by a size or line height. There can actually be multiple",
            "    names. So the first part is 'calculated' by selecting everything up to and",
            "    including the last valid token followed by a size or line height (both",
            "    starting with a number). A valid token is either a size/length or an",
            "    identifier.",
            "",
            "    See http://www.w3.org/TR/css-fonts-3/#font-prop",
            "",
            "    \"\"\"",
            "    return re.sub(r\"\"\"",
            "        ^(",
            "            (\\d[^\\s,]*|\\w[^\\s,]*)   # <size>, <length> or <identifier>",
            "            (\\s+|\\s*,\\s*)           # <whitespace> and/or comma",
            "        )*                          # Repeat until last",
            "        \\d[^\\s,]*                   # <size> or <line-height>",
            "    \"\"\", lambda match: match.group().lower(), value, 0, re.VERBOSE)",
            "",
            "",
            "class Node(dict):",
            "    \"\"\"SVG node with dict-like properties and children.\"\"\"",
            "",
            "    def __init__(self, element, style, url_fetcher, parent=None,",
            "                 parent_children=False, url=None, unsafe=False):",
            "        \"\"\"Create the Node from ElementTree ``node``, with ``parent`` Node.\"\"\"",
            "        super().__init__()",
            "        self.children = ()",
            "",
            "        self.root = False",
            "",
            "        node = element.etree_element",
            "        self.element = element",
            "        self.style = style",
            "        self.tag = (",
            "            element.local_name",
            "            if element.namespace_url in ('', 'http://www.w3.org/2000/svg') else",
            "            '{%s}%s' % (element.namespace_url, element.local_name))",
            "        self.text = node.text",
            "        self.url_fetcher = url_fetcher",
            "        self.unsafe = unsafe",
            "",
            "        # Only set xml_tree if it's not been set before (ie. if node is a tree)",
            "        self.xml_tree = getattr(self, 'xml_tree', node)",
            "",
            "        # Inherits from parent properties",
            "        if parent is not None:",
            "            self.update([",
            "                (attribute, parent[attribute]) for attribute in parent",
            "                if attribute not in NOT_INHERITED_ATTRIBUTES])",
            "            self.url = url or parent.url",
            "            self.parent = parent",
            "        else:",
            "            self.url = getattr(self, 'url', None)",
            "            self.parent = getattr(self, 'parent', None)",
            "",
            "        self.update(self.xml_tree.attrib)",
            "",
            "        # Apply CSS rules",
            "        style_attr = node.get('style')",
            "        if style_attr:",
            "            normal_attr, important_attr = css.parse_declarations(style_attr)",
            "        else:",
            "            normal_attr = []",
            "            important_attr = []",
            "        normal_matcher, important_matcher = style",
            "        normal = [rule[-1] for rule in normal_matcher.match(element)]",
            "        important = [rule[-1] for rule in important_matcher.match(element)]",
            "        for declaration_lists in (",
            "                normal, [normal_attr], important, [important_attr]):",
            "            for declarations in declaration_lists:",
            "                for name, value in declarations:",
            "                    self[name] = value.strip()",
            "",
            "        # Replace currentColor by a real color value",
            "        for attribute in COLOR_ATTRIBUTES:",
            "            if self.get(attribute) == 'currentColor':",
            "                self[attribute] = self.get('color', 'black')",
            "",
            "        # Replace inherit by the parent value",
            "        for attribute in [",
            "                attribute for attribute in self",
            "                if self[attribute] == 'inherit']:",
            "            if parent is not None and attribute in parent:",
            "                self[attribute] = parent.get(attribute)",
            "            else:",
            "                del self[attribute]",
            "",
            "        # Manage text by creating children",
            "        if self.tag in ('text', 'textPath', 'a'):",
            "            self.children, _ = self.text_children(",
            "                element, trailing_space=True, text_root=True)",
            "",
            "        if parent_children:",
            "            self.children = [",
            "                Node(child.element, style, self.url_fetcher, parent=self,",
            "                     unsafe=self.unsafe)",
            "                for child in parent.children]",
            "        elif not self.children:",
            "            self.children = []",
            "            for child in element.iter_children():",
            "                if match_features(child.etree_element):",
            "                    self.children.append(",
            "                        Node(child, style, self.url_fetcher, parent=self,",
            "                             unsafe=self.unsafe))",
            "                    if self.tag == 'switch':",
            "                        break",
            "",
            "    def fetch_url(self, url, resource_type):",
            "        return read_url(url, self.url_fetcher, resource_type)",
            "",
            "    def text_children(self, element, trailing_space, text_root=False):",
            "        \"\"\"Create children and return them.\"\"\"",
            "        children = []",
            "        space = '{http://www.w3.org/XML/1998/namespace}space'",
            "        preserve = self.get(space) == 'preserve'",
            "        self.text = handle_white_spaces(element.etree_element.text, preserve)",
            "        if trailing_space and not preserve:",
            "            self.text = self.text.lstrip(' ')",
            "        original_rotate = rotations(self)",
            "        rotate = list(original_rotate)",
            "        if original_rotate:",
            "            pop_rotation(self, original_rotate, rotate)",
            "        if self.text:",
            "            trailing_space = self.text.endswith(' ')",
            "        for child_element in element.iter_children():",
            "            child = child_element.etree_element",
            "            if child.tag in ('{http://www.w3.org/2000/svg}tref', 'tref'):",
            "                href = child.get(",
            "                    '{http://www.w3.org/1999/xlink}href', child.get('href'))",
            "                url = parse_url(href).geturl()",
            "                child_tree = Tree(",
            "                    url=url, url_fetcher=self.url_fetcher, parent=self,",
            "                    unsafe=self.unsafe)",
            "                child_tree.clear()",
            "                child_tree.update(self)",
            "                child_node = Node(",
            "                    child_element, self.style, self.url_fetcher,",
            "                    parent=child_tree, parent_children=True,",
            "                    unsafe=self.unsafe)",
            "                child_node.tag = 'tspan'",
            "                # Retrieve the referenced node and get its flattened text",
            "                # and remove the node children.",
            "                child = child_tree.xml_tree",
            "                child.text = flatten(child)",
            "                child_element = cssselect2.ElementWrapper.from_xml_root(child)",
            "            else:",
            "                child_node = Node(",
            "                    child_element, self.style, self.url_fetcher, parent=self,",
            "                    unsafe=self.unsafe)",
            "            child_preserve = child_node.get(space) == 'preserve'",
            "            child_node.text = handle_white_spaces(child.text, child_preserve)",
            "            child_node.children, trailing_space = child_node.text_children(",
            "                child_element, trailing_space)",
            "            trailing_space = child_node.text.endswith(' ')",
            "            if original_rotate and 'rotate' not in child_node:",
            "                pop_rotation(child_node, original_rotate, rotate)",
            "            children.append(child_node)",
            "            if child.tail:",
            "                anonymous_etree = Element('{http://www.w3.org/2000/svg}tspan')",
            "                anonymous = Node(",
            "                    cssselect2.ElementWrapper.from_xml_root(anonymous_etree),",
            "                    self.style, self.url_fetcher, parent=self,",
            "                    unsafe=self.unsafe)",
            "                anonymous.text = handle_white_spaces(child.tail, preserve)",
            "                if original_rotate:",
            "                    pop_rotation(anonymous, original_rotate, rotate)",
            "                if trailing_space and not preserve:",
            "                    anonymous.text = anonymous.text.lstrip(' ')",
            "                if anonymous.text:",
            "                    trailing_space = anonymous.text.endswith(' ')",
            "                children.append(anonymous)",
            "",
            "        if text_root and not children and not preserve:",
            "            self.text = self.text.rstrip(' ')",
            "",
            "        return children, trailing_space",
            "",
            "    def get_href(self):",
            "        return self.get('{http://www.w3.org/1999/xlink}href', self.get('href'))",
            "",
            "",
            "class Tree(Node):",
            "    \"\"\"SVG tree.\"\"\"",
            "    def __new__(cls, **kwargs):",
            "        tree_cache = kwargs.get('tree_cache')",
            "        if tree_cache and kwargs.get('url'):",
            "            parsed_url = parse_url(kwargs['url'])",
            "            element_id = parsed_url.fragment",
            "            parent = kwargs.get('parent')",
            "            unsafe = kwargs.get('unsafe')",
            "            if any(parsed_url[:-1]):",
            "                url = urlunparse(parsed_url[:-1] + ('',))",
            "            elif parent:",
            "                url = parent.url",
            "            else:",
            "                url = None",
            "            if url and (url, element_id) in tree_cache:",
            "                cached_tree = tree_cache[(url, element_id)]",
            "                new_tree = Node(",
            "                    cached_tree.element, cached_tree.style,",
            "                    cached_tree.url_fetcher, parent, unsafe=unsafe)",
            "                new_tree.xml_tree = cached_tree.xml_tree",
            "                new_tree.url = url",
            "                new_tree.tag = cached_tree.tag",
            "                new_tree.root = True",
            "                return new_tree",
            "        return super().__new__(cls)",
            "",
            "    def __init__(self, **kwargs):",
            "        \"\"\"Create the Tree from SVG ``text``.\"\"\"",
            "        bytestring = kwargs.get('bytestring')",
            "        file_obj = kwargs.get('file_obj')",
            "        url = kwargs.get('url')",
            "        unsafe = kwargs.get('unsafe')",
            "        parent = kwargs.get('parent')",
            "        parent_children = kwargs.get('parent_children')",
            "        tree_cache = kwargs.get('tree_cache')",
            "        element_id = None",
            "",
            "        self.url_fetcher = kwargs.get('url_fetcher', fetch)",
            "",
            "        if bytestring is not None:",
            "            self.url = url",
            "        elif file_obj is not None:",
            "            bytestring = file_obj.read()",
            "            self.url = getattr(file_obj, 'name', None)",
            "            if self.url == '<stdin>':",
            "                self.url = None",
            "        elif url is not None:",
            "            parent_url = parent.url if parent else None",
            "            parsed_url = parse_url(url, parent_url)",
            "            if parsed_url.fragment:",
            "                self.url = urlunparse(parsed_url[:-1] + ('',))",
            "                element_id = parsed_url.fragment",
            "            else:",
            "                self.url = parsed_url.geturl()",
            "                element_id = None",
            "            self.url = self.url or None",
            "        else:",
            "            raise TypeError(",
            "                'No input. Use one of bytestring, file_obj or url.')",
            "        self_is_parent = (",
            "            (parent and self.url == parent.url) or",
            "            (url and url.startswith('#') and not self.url))",
            "        if self_is_parent:",
            "            root_parent = parent",
            "            while root_parent.parent is not None:",
            "                root_parent = root_parent.parent",
            "            tree = root_parent.xml_tree",
            "        else:",
            "            if not bytestring:",
            "                bytestring = self.fetch_url(",
            "                    parse_url(self.url), 'image/svg+xml')",
            "            if len(bytestring) >= 2 and bytestring[:2] == b'\\x1f\\x8b':",
            "                bytestring = gzip.decompress(bytestring)",
            "            tree = ElementTree.fromstring(",
            "                bytestring, forbid_entities=not unsafe,",
            "                forbid_external=not unsafe)",
            "        self.xml_tree = tree",
            "        root = cssselect2.ElementWrapper.from_xml_root(tree)",
            "        style = parent.style if parent else css.parse_stylesheets(self, url)",
            "        if element_id:",
            "            for element in root.iter_subtree():",
            "                if element.id == element_id:",
            "                    root = element",
            "                    self.xml_tree = element.etree_element",
            "                    break",
            "            else:",
            "                raise TypeError(",
            "                    'No tag with id=\"{}\" found.'.format(element_id))",
            "        super().__init__(",
            "            root, style, self.url_fetcher, parent, parent_children, self.url,",
            "            unsafe)",
            "        self.root = True",
            "        if tree_cache is not None and self.url:",
            "            tree_cache[(self.url, self.get('id'))] = self",
            "",
            "",
            "CASE_SENSITIVE_STYLE_METHODS = {",
            "    'id': normalize_noop_style_declaration,",
            "    'class': normalize_noop_style_declaration,",
            "    'font-family': normalize_noop_style_declaration,",
            "    'font': normalize_font_style_declaration,",
            "    'clip-path': normalize_url_style_declaration,",
            "    'color-profile': normalize_url_style_declaration,",
            "    'cursor': normalize_url_style_declaration,",
            "    'fill': normalize_url_style_declaration,",
            "    'filter': normalize_url_style_declaration,",
            "    'marker-start': normalize_url_style_declaration,",
            "    'marker-mid': normalize_url_style_declaration,",
            "    'marker-end': normalize_url_style_declaration,",
            "    'mask': normalize_url_style_declaration,",
            "    'stroke': normalize_url_style_declaration,",
            "}"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "SVG Parser.",
            "",
            "\"\"\"",
            "",
            "import gzip",
            "import re",
            "from urllib.parse import urlunparse",
            "from xml.etree.ElementTree import Element",
            "",
            "import cssselect2",
            "from defusedxml import ElementTree",
            "",
            "from . import css",
            "from .features import match_features",
            "from .helpers import flatten, pop_rotation, rotations",
            "from .url import fetch, parse_url, read_url",
            "",
            "# 'display' is actually inherited but handled differently because some markers",
            "# are part of a none-displaying group (see test painting-marker-07-f.svg)",
            "NOT_INHERITED_ATTRIBUTES = frozenset((",
            "    'clip',",
            "    'clip-path',",
            "    'display',",
            "    'filter',",
            "    'height',",
            "    'id',",
            "    'mask',",
            "    'opacity',",
            "    'overflow',",
            "    'rotate',",
            "    'stop-color',",
            "    'stop-opacity',",
            "    'style',",
            "    'transform',",
            "    'transform-origin',",
            "    'viewBox',",
            "    'width',",
            "    'x',",
            "    'y',",
            "    'dx',",
            "    'dy',",
            "    '{http://www.w3.org/1999/xlink}href',",
            "    'href',",
            "))",
            "",
            "COLOR_ATTRIBUTES = frozenset((",
            "    'fill',",
            "    'flood-color',",
            "    'lighting-color',",
            "    'stop-color',",
            "    'stroke',",
            "))",
            "",
            "",
            "def handle_white_spaces(string, preserve):",
            "    \"\"\"Handle white spaces in text nodes.",
            "",
            "    See http://www.w3.org/TR/SVG/text.html#WhiteSpace",
            "",
            "    \"\"\"",
            "    if not string:",
            "        return ''",
            "    if preserve:",
            "        return re.sub('[\\n\\r\\t]', ' ', string)",
            "    else:",
            "        string = re.sub('[\\n\\r]', '', string)",
            "        string = re.sub('\\t', ' ', string)",
            "        return re.sub(' +', ' ', string)",
            "",
            "",
            "def normalize_style_declaration(name, value):",
            "    \"\"\"Normalize style declaration consisting of name/value pair.",
            "",
            "    Names are always case insensitive, make all lowercase.",
            "    Values are case insensitive in most cases. Adapt for 'specials':",
            "        id - case sensitive identifier",
            "        class - case sensitive identifier(s)",
            "        font-family - case sensitive name(s)",
            "        font - shorthand in which font-family is case sensitive",
            "        any declaration with url in value - url is case sensitive",
            "",
            "    \"\"\"",
            "    name = name.strip().lower()",
            "    value = value.strip()",
            "    if name in CASE_SENSITIVE_STYLE_METHODS:",
            "        value = CASE_SENSITIVE_STYLE_METHODS[name](value)",
            "    else:",
            "        value = value.lower()",
            "",
            "    return name, value",
            "",
            "",
            "def normalize_noop_style_declaration(value):",
            "    \"\"\"No-operation for normalization where value is case sensitive.",
            "",
            "    This is actually the exception to the rule. Normally value will be made",
            "    lowercase (see normalize_style_declaration above).",
            "",
            "    \"\"\"",
            "    return value",
            "",
            "",
            "def normalize_url_style_declaration(value):",
            "    \"\"\"Normalize style declaration, but keep URL's as-is.",
            "",
            "    Lowercase everything except for the URL.",
            "",
            "    \"\"\"",
            "    regex_style = re.compile(r\"\"\"",
            "        (.*?)                               # non-URL part (will be normalized)",
            "        (?:",
            "            url\\(\\s*                        # url(<whitespace>",
            "                (?:",
            "                      \"(?:\\\\.|[^\"])*\"       # \"<url>\"",
            "                    | \\'(?:\\\\.|[^\\'])*\\'    # '<url>'",
            "                    | (?:\\\\.|[^\\)])*        # <url>",
            "                )",
            "            \\s*\\)                           # <whitespace>)",
            "            |$",
            "        )",
            "    \"\"\", re.IGNORECASE | re.VERBOSE)",
            "    for match in regex_style.finditer(value):",
            "        value_start = value[:match.start()] if match.start() > 0 else ''",
            "        normalized_value = match.group(1).lower()",
            "        value_end = value[match.start() + len(normalized_value):]",
            "        value = value_start + normalized_value + value_end",
            "    return value",
            "",
            "",
            "def normalize_font_style_declaration(value):",
            "    \"\"\"Make first part of font style declaration lowercase (case insensitive).",
            "",
            "    Lowercase first part of declaration. Only the font name is case sensitive.",
            "    The font name is at the end of the declaration and can be 'recognized'",
            "    by being preceded by a size or line height. There can actually be multiple",
            "    names. So the first part is 'calculated' by selecting everything up to and",
            "    including the last valid token followed by a size or line height (both",
            "    starting with a number). A valid token is either a size/length or an",
            "    identifier.",
            "",
            "    See http://www.w3.org/TR/css-fonts-3/#font-prop",
            "",
            "    \"\"\"",
            "    return re.sub(r\"\"\"",
            "        ^(",
            "            (\\d[^\\s,]*|\\w[^\\s,]*)   # <size>, <length> or <identifier>",
            "            (\\s+|\\s*,\\s*)           # <whitespace> and/or comma",
            "        )*                          # Repeat until last",
            "        \\d[^\\s,]*                   # <size> or <line-height>",
            "    \"\"\", lambda match: match.group().lower(), value, 0, re.VERBOSE)",
            "",
            "",
            "class Node(dict):",
            "    \"\"\"SVG node with dict-like properties and children.\"\"\"",
            "",
            "    def __init__(self, element, style, url_fetcher, parent=None,",
            "                 parent_children=False, url=None, unsafe=False):",
            "        \"\"\"Create the Node from ElementTree ``node``, with ``parent`` Node.\"\"\"",
            "        super().__init__()",
            "        self.children = ()",
            "",
            "        self.root = False",
            "",
            "        node = element.etree_element",
            "        self.element = element",
            "        self.style = style",
            "        self.tag = (",
            "            element.local_name",
            "            if element.namespace_url in ('', 'http://www.w3.org/2000/svg') else",
            "            '{%s}%s' % (element.namespace_url, element.local_name))",
            "        self.text = node.text",
            "        self.url_fetcher = url_fetcher",
            "        self.unsafe = unsafe",
            "",
            "        # Only set xml_tree if it's not been set before (ie. if node is a tree)",
            "        self.xml_tree = getattr(self, 'xml_tree', node)",
            "",
            "        # Inherits from parent properties",
            "        if parent is not None:",
            "            self.update([",
            "                (attribute, parent[attribute]) for attribute in parent",
            "                if attribute not in NOT_INHERITED_ATTRIBUTES])",
            "            self.url = url or parent.url",
            "            self.parent = parent",
            "        else:",
            "            self.url = getattr(self, 'url', None)",
            "            self.parent = getattr(self, 'parent', None)",
            "",
            "        self.update(self.xml_tree.attrib)",
            "",
            "        # Apply CSS rules",
            "        style_attr = node.get('style')",
            "        if style_attr:",
            "            normal_attr, important_attr = css.parse_declarations(style_attr)",
            "        else:",
            "            normal_attr = []",
            "            important_attr = []",
            "        normal_matcher, important_matcher = style",
            "        normal = [rule[-1] for rule in normal_matcher.match(element)]",
            "        important = [rule[-1] for rule in important_matcher.match(element)]",
            "        for declaration_lists in (",
            "                normal, [normal_attr], important, [important_attr]):",
            "            for declarations in declaration_lists:",
            "                for name, value in declarations:",
            "                    self[name] = value.strip()",
            "",
            "        # Replace currentColor by a real color value",
            "        for attribute in COLOR_ATTRIBUTES:",
            "            if self.get(attribute) == 'currentColor':",
            "                self[attribute] = self.get('color', 'black')",
            "",
            "        # Replace inherit by the parent value",
            "        for attribute in [",
            "                attribute for attribute in self",
            "                if self[attribute] == 'inherit']:",
            "            if parent is not None and attribute in parent:",
            "                self[attribute] = parent.get(attribute)",
            "            else:",
            "                del self[attribute]",
            "",
            "        # Manage text by creating children",
            "        if self.tag in ('text', 'textPath', 'a'):",
            "            self.children, _ = self.text_children(",
            "                element, trailing_space=True, text_root=True)",
            "",
            "        if parent_children:",
            "            self.children = [",
            "                Node(child.element, style, self.url_fetcher, parent=self,",
            "                     unsafe=self.unsafe)",
            "                for child in parent.children]",
            "        elif not self.children:",
            "            self.children = []",
            "            for child in element.iter_children():",
            "                if match_features(child.etree_element):",
            "                    self.children.append(",
            "                        Node(child, style, self.url_fetcher, parent=self,",
            "                             unsafe=self.unsafe))",
            "                    if self.tag == 'switch':",
            "                        break",
            "",
            "    def fetch_url(self, url, resource_type):",
            "        return read_url(url, self.url_fetcher, resource_type)",
            "",
            "    def text_children(self, element, trailing_space, text_root=False):",
            "        \"\"\"Create children and return them.\"\"\"",
            "        children = []",
            "        space = '{http://www.w3.org/XML/1998/namespace}space'",
            "        preserve = self.get(space) == 'preserve'",
            "        self.text = handle_white_spaces(element.etree_element.text, preserve)",
            "        if trailing_space and not preserve:",
            "            self.text = self.text.lstrip(' ')",
            "        original_rotate = rotations(self)",
            "        rotate = list(original_rotate)",
            "        if original_rotate:",
            "            pop_rotation(self, original_rotate, rotate)",
            "        if self.text:",
            "            trailing_space = self.text.endswith(' ')",
            "        for child_element in element.iter_children():",
            "            child = child_element.etree_element",
            "            if child.tag in ('{http://www.w3.org/2000/svg}tref', 'tref'):",
            "                href = child.get(",
            "                    '{http://www.w3.org/1999/xlink}href', child.get('href'))",
            "                url = parse_url(href).geturl()",
            "                child_tree = Tree(",
            "                    url=url, url_fetcher=self.url_fetcher, parent=self,",
            "                    unsafe=self.unsafe)",
            "                child_tree.clear()",
            "                child_tree.update(self)",
            "                child_node = Node(",
            "                    child_element, self.style, self.url_fetcher,",
            "                    parent=child_tree, parent_children=True,",
            "                    unsafe=self.unsafe)",
            "                child_node.tag = 'tspan'",
            "                # Retrieve the referenced node and get its flattened text",
            "                # and remove the node children.",
            "                child = child_tree.xml_tree",
            "                child.text = flatten(child)",
            "                child_element = cssselect2.ElementWrapper.from_xml_root(child)",
            "            else:",
            "                child_node = Node(",
            "                    child_element, self.style, self.url_fetcher, parent=self,",
            "                    unsafe=self.unsafe)",
            "            child_preserve = child_node.get(space) == 'preserve'",
            "            child_node.text = handle_white_spaces(child.text, child_preserve)",
            "            child_node.children, trailing_space = child_node.text_children(",
            "                child_element, trailing_space)",
            "            trailing_space = child_node.text.endswith(' ')",
            "            if original_rotate and 'rotate' not in child_node:",
            "                pop_rotation(child_node, original_rotate, rotate)",
            "            children.append(child_node)",
            "            if child.tail:",
            "                anonymous_etree = Element('{http://www.w3.org/2000/svg}tspan')",
            "                anonymous = Node(",
            "                    cssselect2.ElementWrapper.from_xml_root(anonymous_etree),",
            "                    self.style, self.url_fetcher, parent=self,",
            "                    unsafe=self.unsafe)",
            "                anonymous.text = handle_white_spaces(child.tail, preserve)",
            "                if original_rotate:",
            "                    pop_rotation(anonymous, original_rotate, rotate)",
            "                if trailing_space and not preserve:",
            "                    anonymous.text = anonymous.text.lstrip(' ')",
            "                if anonymous.text:",
            "                    trailing_space = anonymous.text.endswith(' ')",
            "                children.append(anonymous)",
            "",
            "        if text_root and not children and not preserve:",
            "            self.text = self.text.rstrip(' ')",
            "",
            "        return children, trailing_space",
            "",
            "    def get_href(self):",
            "        return self.get('{http://www.w3.org/1999/xlink}href', self.get('href'))",
            "",
            "",
            "class Tree(Node):",
            "    \"\"\"SVG tree.\"\"\"",
            "    def __new__(cls, **kwargs):",
            "        tree_cache = kwargs.get('tree_cache')",
            "        if tree_cache and kwargs.get('url'):",
            "            parsed_url = parse_url(kwargs['url'])",
            "            element_id = parsed_url.fragment",
            "            parent = kwargs.get('parent')",
            "            unsafe = kwargs.get('unsafe')",
            "            if any(parsed_url[:-1]):",
            "                url = urlunparse(parsed_url[:-1] + ('',))",
            "            elif parent:",
            "                url = parent.url",
            "            else:",
            "                url = None",
            "            if url and (url, element_id) in tree_cache:",
            "                cached_tree = tree_cache[(url, element_id)]",
            "                new_tree = Node(",
            "                    cached_tree.element, cached_tree.style,",
            "                    cached_tree.url_fetcher, parent, unsafe=unsafe)",
            "                new_tree.xml_tree = cached_tree.xml_tree",
            "                new_tree.url = url",
            "                new_tree.tag = cached_tree.tag",
            "                new_tree.root = True",
            "                return new_tree",
            "        return super().__new__(cls)",
            "",
            "    def __init__(self, **kwargs):",
            "        \"\"\"Create the Tree from SVG ``text``.\"\"\"",
            "        bytestring = kwargs.get('bytestring')",
            "        file_obj = kwargs.get('file_obj')",
            "        url = kwargs.get('url')",
            "        unsafe = kwargs.get('unsafe')",
            "        parent = kwargs.get('parent')",
            "        parent_children = kwargs.get('parent_children')",
            "        tree_cache = kwargs.get('tree_cache')",
            "        element_id = None",
            "",
            "        self.url_fetcher = kwargs.get('url_fetcher', fetch)",
            "",
            "        if bytestring is not None:",
            "            self.url = url",
            "        elif file_obj is not None:",
            "            bytestring = file_obj.read()",
            "            self.url = getattr(file_obj, 'name', None)",
            "            if self.url == '<stdin>':",
            "                self.url = None",
            "        elif url is not None:",
            "            parent_url = parent.url if parent else None",
            "            parsed_url = parse_url(url, parent_url)",
            "            if parsed_url.fragment:",
            "                self.url = urlunparse(parsed_url[:-1] + ('',))",
            "                element_id = parsed_url.fragment",
            "            else:",
            "                self.url = parsed_url.geturl()",
            "                element_id = None",
            "            self.url = self.url or None",
            "        else:",
            "            raise TypeError(",
            "                'No input. Use one of bytestring, file_obj or url.')",
            "        self_is_parent = (",
            "            (parent and self.url == parent.url) or",
            "            (url and url.startswith('#') and not self.url))",
            "        if self_is_parent:",
            "            root_parent = parent",
            "            while root_parent.parent is not None:",
            "                root_parent = root_parent.parent",
            "            tree = root_parent.xml_tree",
            "        else:",
            "            if not bytestring:",
            "                bytestring = self.fetch_url(",
            "                    parse_url(self.url), 'image/svg+xml')",
            "            if len(bytestring) >= 2 and bytestring[:2] == b'\\x1f\\x8b':",
            "                bytestring = gzip.decompress(bytestring)",
            "            tree = ElementTree.fromstring(",
            "                bytestring, forbid_entities=not unsafe,",
            "                forbid_external=not unsafe)",
            "",
            "        # Don\u2019t allow fetching external files unless explicitly asked for",
            "        if 'url_fetcher' not in kwargs and not unsafe:",
            "            self.url_fetcher = (",
            "                lambda *args, **kwargs: b'<svg width=\"1\" height=\"1\"></svg>')",
            "",
            "        self.xml_tree = tree",
            "        root = cssselect2.ElementWrapper.from_xml_root(tree)",
            "        style = parent.style if parent else css.parse_stylesheets(self, url)",
            "        if element_id:",
            "            for element in root.iter_subtree():",
            "                if element.id == element_id:",
            "                    root = element",
            "                    self.xml_tree = element.etree_element",
            "                    break",
            "            else:",
            "                raise TypeError(",
            "                    'No tag with id=\"{}\" found.'.format(element_id))",
            "        super().__init__(",
            "            root, style, self.url_fetcher, parent, parent_children, self.url,",
            "            unsafe)",
            "        self.root = True",
            "        if tree_cache is not None and self.url:",
            "            tree_cache[(self.url, self.get('id'))] = self",
            "",
            "",
            "CASE_SENSITIVE_STYLE_METHODS = {",
            "    'id': normalize_noop_style_declaration,",
            "    'class': normalize_noop_style_declaration,",
            "    'font-family': normalize_noop_style_declaration,",
            "    'font': normalize_font_style_declaration,",
            "    'clip-path': normalize_url_style_declaration,",
            "    'color-profile': normalize_url_style_declaration,",
            "    'cursor': normalize_url_style_declaration,",
            "    'fill': normalize_url_style_declaration,",
            "    'filter': normalize_url_style_declaration,",
            "    'marker-start': normalize_url_style_declaration,",
            "    'marker-mid': normalize_url_style_declaration,",
            "    'marker-end': normalize_url_style_declaration,",
            "    'mask': normalize_url_style_declaration,",
            "    'stroke': normalize_url_style_declaration,",
            "}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "cairosvg.parser.Tree",
            "src.pyload.core.database.user_database",
            "cairosvg.parser.Tree.url_fetcher",
            "cairosvg.parser.Node.text_children"
        ]
    },
    "cairosvg/surface.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         :param parent_width: The width of the parent container in pixels."
            },
            "1": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         :param parent_height: The height of the parent container in pixels."
            },
            "2": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         :param scale: The ouptut scaling factor."
            },
            "3": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param unsafe: A boolean allowing XML entities and very large files"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        :param unsafe: A boolean allowing external file access, XML entities"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+                       and very large files"
            },
            "6": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "                        (WARNING: vulnerable to XXE attacks and various DoS)."
            },
            "7": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         Specifiy the output with:"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Cairo surface creators.",
            "",
            "\"\"\"",
            "",
            "import copy",
            "import io",
            "",
            "import cairocffi as cairo",
            "",
            "from .colors import color, negate_color",
            "from .defs import (",
            "    apply_filter_after_painting, apply_filter_before_painting, clip_path,",
            "    filter_, gradient_or_pattern, linear_gradient, marker, mask, paint_mask,",
            "    parse_all_defs, pattern, prepare_filter, radial_gradient, use)",
            "from .helpers import (",
            "    UNITS, PointError, clip_rect, node_format, normalize, paint,",
            "    preserve_ratio, size, transform)",
            "from .image import image, invert_image",
            "from .parser import Tree",
            "from .path import draw_markers, path",
            "from .shapes import circle, ellipse, line, polygon, polyline, rect",
            "from .svg import svg",
            "from .text import text",
            "from .url import parse_url",
            "",
            "SHAPE_ANTIALIAS = {",
            "    'optimizeSpeed': cairo.ANTIALIAS_FAST,",
            "    'crispEdges': cairo.ANTIALIAS_NONE,",
            "    'geometricPrecision': cairo.ANTIALIAS_BEST,",
            "}",
            "",
            "TEXT_ANTIALIAS = {",
            "    'crispEdges': cairo.ANTIALIAS_NONE,",
            "    'optimizeSpeed': cairo.ANTIALIAS_FAST,",
            "    'optimizeLegibility': cairo.ANTIALIAS_GOOD,",
            "    'geometricPrecision': cairo.ANTIALIAS_BEST,",
            "}",
            "",
            "TEXT_HINT_STYLE = {",
            "    'geometricPrecision': cairo.HINT_STYLE_NONE,",
            "    'optimizeLegibility': cairo.HINT_STYLE_FULL,",
            "}",
            "",
            "TEXT_HINT_METRICS = {",
            "    'geometricPrecision': cairo.HINT_METRICS_OFF,",
            "    'optimizeLegibility': cairo.HINT_METRICS_ON,",
            "}",
            "",
            "TAGS = {",
            "    'a': text,",
            "    'circle': circle,",
            "    'clipPath': clip_path,",
            "    'ellipse': ellipse,",
            "    'filter': filter_,",
            "    'image': image,",
            "    'line': line,",
            "    'linearGradient': linear_gradient,",
            "    'marker': marker,",
            "    'mask': mask,",
            "    'path': path,",
            "    'pattern': pattern,",
            "    'polyline': polyline,",
            "    'polygon': polygon,",
            "    'radialGradient': radial_gradient,",
            "    'rect': rect,",
            "    'svg': svg,",
            "    'text': text,",
            "    'textPath': text,",
            "    'tspan': text,",
            "    'use': use,",
            "}",
            "",
            "PATH_TAGS = frozenset((",
            "    'circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'))",
            "",
            "INVISIBLE_TAGS = frozenset((",
            "    'clipPath', 'filter', 'linearGradient', 'marker', 'mask', 'pattern',",
            "    'radialGradient', 'symbol'))",
            "",
            "",
            "class Surface(object):",
            "    \"\"\"Abstract base class for CairoSVG surfaces.",
            "",
            "    The ``width`` and ``height`` attributes are in device units (pixels for",
            "    PNG, else points).",
            "",
            "    The ``context_width`` and ``context_height`` attributes are in user units",
            "    (i.e. in pixels), they represent the size of the active viewport.",
            "",
            "    \"\"\"",
            "",
            "    # Subclasses must either define this or override _create_surface()",
            "    surface_class = None",
            "",
            "    @classmethod",
            "    def convert(cls, bytestring=None, *, file_obj=None, url=None, dpi=96,",
            "                parent_width=None, parent_height=None, scale=1, unsafe=False,",
            "                background_color=None, negate_colors=False,",
            "                invert_images=False, write_to=None, output_width=None,",
            "                output_height=None, **kwargs):",
            "        \"\"\"Convert an SVG document to the format for this class.",
            "",
            "        Specify the input by passing one of these:",
            "",
            "        :param bytestring: The SVG source as a byte-string.",
            "        :param file_obj: A file-like object.",
            "        :param url: A filename.",
            "",
            "        Give some options:",
            "",
            "        :param dpi: The ratio between 1 inch and 1 pixel.",
            "        :param parent_width: The width of the parent container in pixels.",
            "        :param parent_height: The height of the parent container in pixels.",
            "        :param scale: The ouptut scaling factor.",
            "        :param unsafe: A boolean allowing XML entities and very large files",
            "                       (WARNING: vulnerable to XXE attacks and various DoS).",
            "",
            "        Specifiy the output with:",
            "",
            "        :param write_to: The filename of file-like object where to write the",
            "                         output. If None or not provided, return a byte string.",
            "",
            "        Only ``bytestring`` can be passed as a positional argument, other",
            "        parameters are keyword-only.",
            "",
            "        \"\"\"",
            "        tree = Tree(",
            "            bytestring=bytestring, file_obj=file_obj, url=url, unsafe=unsafe,",
            "            **kwargs)",
            "        output = write_to or io.BytesIO()",
            "        instance = cls(",
            "            tree, output, dpi, None, parent_width, parent_height, scale,",
            "            output_width, output_height, background_color,",
            "            map_rgba=negate_color if negate_colors else None,",
            "            map_image=invert_image if invert_images else None)",
            "        instance.finish()",
            "        if write_to is None:",
            "            return output.getvalue()",
            "",
            "    def __init__(self, tree, output, dpi, parent_surface=None,",
            "                 parent_width=None, parent_height=None,",
            "                 scale=1, output_width=None, output_height=None,",
            "                 background_color=None, map_rgba=None, map_image=None):",
            "        \"\"\"Create the surface from a filename or a file-like object.",
            "",
            "        The rendered content is written to ``output`` which can be a filename,",
            "        a file-like object, ``None`` (render in memory but do not write",
            "        anything) or the built-in ``bytes`` as a marker.",
            "",
            "        Call the ``.finish()`` method to make sure that the output is",
            "        actually written.",
            "",
            "        \"\"\"",
            "        self.cairo = None",
            "        self.context_width, self.context_height = parent_width, parent_height",
            "        self.cursor_position = [0, 0]",
            "        self.cursor_d_position = [0, 0]",
            "        self.text_path_width = 0",
            "        self.tree_cache = {(tree.url, tree.get('id')): tree}",
            "        if parent_surface:",
            "            self.markers = parent_surface.markers",
            "            self.gradients = parent_surface.gradients",
            "            self.patterns = parent_surface.patterns",
            "            self.masks = parent_surface.masks",
            "            self.paths = parent_surface.paths",
            "            self.filters = parent_surface.filters",
            "            self.images = parent_surface.images",
            "        else:",
            "            self.markers = {}",
            "            self.gradients = {}",
            "            self.patterns = {}",
            "            self.masks = {}",
            "            self.paths = {}",
            "            self.filters = {}",
            "            self.images = {}",
            "        self._old_parent_node = self.parent_node = None",
            "        self.output = output",
            "        self.dpi = dpi",
            "        self.font_size = size(self, '12pt')",
            "        self.stroke_and_fill = True",
            "        width, height, viewbox = node_format(self, tree)",
            "        if viewbox is None:",
            "            viewbox = (0, 0, width, height)",
            "",
            "        if output_width and output_height:",
            "            width, height = output_width, output_height",
            "        elif output_width:",
            "            if width:",
            "                # Keep the aspect ratio",
            "                height *= output_width / width",
            "            width = output_width",
            "        elif output_height:",
            "            if height:",
            "                # Keep the aspect ratio",
            "                width *= output_height / height",
            "            height = output_height",
            "        else:",
            "            width *= scale",
            "            height *= scale",
            "",
            "        # Actual surface dimensions: may be rounded on raster surfaces types",
            "        self.cairo, self.width, self.height = self._create_surface(",
            "            width * self.device_units_per_user_units,",
            "            height * self.device_units_per_user_units)",
            "",
            "        if 0 in (self.width, self.height):",
            "            raise ValueError('The SVG size is undefined')",
            "",
            "        self.context = cairo.Context(self.cairo)",
            "        # We must scale the context as the surface size is using physical units",
            "        self.context.scale(",
            "            self.device_units_per_user_units, self.device_units_per_user_units)",
            "        # Initial, non-rounded dimensions",
            "        self.set_context_size(width, height, viewbox, tree)",
            "        self.context.move_to(0, 0)",
            "",
            "        if background_color:",
            "            self.context.set_source_rgba(*color(background_color))",
            "            self.context.paint()",
            "",
            "        self.map_rgba = map_rgba",
            "        self.map_image = map_image",
            "        self.draw(tree)",
            "",
            "    @property",
            "    def points_per_pixel(self):",
            "        \"\"\"Surface resolution.\"\"\"",
            "        return 1 / (self.dpi * UNITS['pt'])",
            "",
            "    @property",
            "    def device_units_per_user_units(self):",
            "        \"\"\"Ratio between Cairo device units and user units.",
            "",
            "        Device units are points for everything but PNG, and pixels for",
            "        PNG. User units are pixels.",
            "",
            "        \"\"\"",
            "        return self.points_per_pixel",
            "",
            "    def _create_surface(self, width, height):",
            "        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"",
            "        cairo_surface = self.surface_class(self.output, width, height)",
            "        return cairo_surface, width, height",
            "",
            "    def set_context_size(self, width, height, viewbox, tree):",
            "        \"\"\"Set the Cairo context size, set the SVG viewport size.\"\"\"",
            "        if viewbox:",
            "            rect_x, rect_y = viewbox[0:2]",
            "            tree.image_width = viewbox[2]",
            "            tree.image_height = viewbox[3]",
            "        else:",
            "            rect_x, rect_y = 0, 0",
            "            tree.image_width = width",
            "            tree.image_height = height",
            "",
            "        scale_x, scale_y, translate_x, translate_y = preserve_ratio(",
            "            self, tree, width, height)",
            "        rect_x, rect_y = rect_x * scale_x, rect_y * scale_y",
            "        rect_width, rect_height = width, height",
            "        self.context.translate(*self.context.get_current_point())",
            "        self.context.translate(-rect_x, -rect_y)",
            "        if tree.get('overflow', 'hidden') != 'visible':",
            "            self.context.rectangle(rect_x, rect_y, rect_width, rect_height)",
            "            self.context.clip()",
            "        self.context.scale(scale_x, scale_y)",
            "        self.context.translate(translate_x, translate_y)",
            "        self.context_width = rect_width / scale_x",
            "        self.context_height = rect_height / scale_y",
            "",
            "    def finish(self):",
            "        \"\"\"Read the surface content.\"\"\"",
            "        self.cairo.finish()",
            "",
            "    def map_color(self, string, opacity=1):",
            "        \"\"\"Parse a color ``string`` and apply ``map_rgba`` function to it.\"\"\"",
            "        rgba = color(string, opacity)",
            "        return self.map_rgba(rgba) if self.map_rgba else rgba",
            "",
            "    def draw(self, node):",
            "        \"\"\"Draw ``node`` and its children.\"\"\"",
            "",
            "        # Parse definitions first",
            "        if node.tag == 'svg':",
            "            parse_all_defs(self, node)",
            "",
            "        # Do not draw defs",
            "        if node.tag == 'defs':",
            "            return",
            "",
            "        # Do not draw elements with width or height of 0",
            "        if (('width' in node and size(self, node['width']) == 0) or",
            "                ('height' in node and size(self, node['height']) == 0)):",
            "            return",
            "",
            "        # Save context and related attributes",
            "        old_parent_node = self.parent_node",
            "        old_font_size = self.font_size",
            "        old_context_size = self.context_width, self.context_height",
            "        self.parent_node = node",
            "",
            "        if \"font\" in node:",
            "            font = parse_font(node[\"font\"])",
            "            for att in font:",
            "                if att not in node:",
            "                    node[att] = font[att]",
            "",
            "        self.font_size = size(self, node.get('font-size', '12pt'))",
            "        self.context.save()",
            "",
            "        # Apply transformations",
            "        transform(",
            "            self, node.get('transform'),",
            "            transform_origin=node.get('transform-origin'))",
            "",
            "        # Find and prepare opacity, masks and filters",
            "        mask = parse_url(node.get('mask')).fragment",
            "        filter_ = parse_url(node.get('filter')).fragment",
            "        opacity = float(node.get('opacity', 1))",
            "",
            "        if filter_:",
            "            prepare_filter(self, node, filter_)",
            "",
            "        if filter_ or mask or (opacity < 1 and node.children):",
            "            self.context.push_group()",
            "",
            "        # Move to (node.x, node.y)",
            "        self.context.move_to(",
            "            size(self, node.get('x'), 'x'),",
            "            size(self, node.get('y'), 'y'))",
            "",
            "        # Set node's drawing informations if the ``node.tag`` method exists",
            "        line_cap = node.get('stroke-linecap')",
            "        if line_cap == 'square':",
            "            self.context.set_line_cap(cairo.LINE_CAP_SQUARE)",
            "        if line_cap == 'round':",
            "            self.context.set_line_cap(cairo.LINE_CAP_ROUND)",
            "",
            "        join_cap = node.get('stroke-linejoin')",
            "        if join_cap == 'round':",
            "            self.context.set_line_join(cairo.LINE_JOIN_ROUND)",
            "        if join_cap == 'bevel':",
            "            self.context.set_line_join(cairo.LINE_JOIN_BEVEL)",
            "",
            "        dash_array = normalize(node.get('stroke-dasharray', '')).split()",
            "        if dash_array:",
            "            dashes = [size(self, dash) for dash in dash_array]",
            "            if sum(dashes):",
            "                offset = size(self, node.get('stroke-dashoffset'))",
            "                self.context.set_dash(dashes, offset)",
            "",
            "        miter_limit = float(node.get('stroke-miterlimit', 4))",
            "        self.context.set_miter_limit(miter_limit)",
            "",
            "        # Clip",
            "        rect_values = clip_rect(node.get('clip'))",
            "        if len(rect_values) == 4:",
            "            top = size(self, rect_values[0], 'y')",
            "            right = size(self, rect_values[1], 'x')",
            "            bottom = size(self, rect_values[2], 'y')",
            "            left = size(self, rect_values[3], 'x')",
            "            x = size(self, node.get('x'), 'x')",
            "            y = size(self, node.get('y'), 'y')",
            "            width = size(self, node.get('width'), 'x')",
            "            height = size(self, node.get('height'), 'y')",
            "            self.context.save()",
            "            self.context.translate(x, y)",
            "            self.context.rectangle(",
            "                left, top, width - left - right, height - top - bottom)",
            "            self.context.restore()",
            "            self.context.clip()",
            "        clip_path = parse_url(node.get('clip-path')).fragment",
            "        if clip_path:",
            "            path = self.paths.get(clip_path)",
            "            if path:",
            "                self.context.save()",
            "                if path.get('clipPathUnits') == 'objectBoundingBox':",
            "                    x = size(self, node.get('x'), 'x')",
            "                    y = size(self, node.get('y'), 'y')",
            "                    width = size(self, node.get('width'), 'x')",
            "                    height = size(self, node.get('height'), 'y')",
            "                    self.context.translate(x, y)",
            "                    self.context.scale(width, height)",
            "                path.tag = 'g'",
            "                self.stroke_and_fill = False",
            "                self.draw(path)",
            "                self.stroke_and_fill = True",
            "                self.context.restore()",
            "                # TODO: fill rules are not handled by cairo for clips",
            "                # if node.get('clip-rule') == 'evenodd':",
            "                #     self.context.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)",
            "                self.context.clip()",
            "                self.context.set_fill_rule(cairo.FILL_RULE_WINDING)",
            "",
            "        save_cursor = copy.deepcopy(",
            "            (self.cursor_position, self.cursor_d_position,",
            "             self.text_path_width))",
            "",
            "        # Only draw known tags",
            "        if node.tag in TAGS:",
            "            try:",
            "                TAGS[node.tag](self, node)",
            "            except PointError:",
            "                # Error in point parsing, do nothing",
            "                pass",
            "",
            "        # Get stroke and fill opacity",
            "        stroke_opacity = float(node.get('stroke-opacity', 1))",
            "        fill_opacity = float(node.get('fill-opacity', 1))",
            "        if opacity < 1 and not node.children:",
            "            stroke_opacity *= opacity",
            "            fill_opacity *= opacity",
            "",
            "        # Manage display and visibility",
            "        display = node.get('display', 'inline') != 'none'",
            "        visible = display and (node.get('visibility', 'visible') != 'hidden')",
            "",
            "        # Set font rendering properties",
            "        self.context.set_antialias(SHAPE_ANTIALIAS.get(",
            "            node.get('shape-rendering'), cairo.ANTIALIAS_DEFAULT))",
            "",
            "        font_options = self.context.get_font_options()",
            "        font_options.set_antialias(TEXT_ANTIALIAS.get(",
            "            node.get('text-rendering'), cairo.ANTIALIAS_DEFAULT))",
            "        font_options.set_hint_style(TEXT_HINT_STYLE.get(",
            "            node.get('text-rendering'), cairo.HINT_STYLE_DEFAULT))",
            "        font_options.set_hint_metrics(TEXT_HINT_METRICS.get(",
            "            node.get('text-rendering'), cairo.HINT_METRICS_DEFAULT))",
            "        self.context.set_font_options(font_options)",
            "",
            "        # Fill and stroke",
            "        if self.stroke_and_fill and visible and node.tag in TAGS:",
            "            # Fill",
            "            self.context.save()",
            "            paint_source, paint_color = paint(node.get('fill', 'black'))",
            "            if not gradient_or_pattern(self, node, paint_source, fill_opacity):",
            "                if node.get('fill-rule') == 'evenodd':",
            "                    self.context.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)",
            "                self.context.set_source_rgba(",
            "                    *self.map_color(paint_color, fill_opacity))",
            "            if TAGS[node.tag] == text:",
            "                self.cursor_position = save_cursor[0]",
            "                self.cursor_d_position = save_cursor[1]",
            "                self.text_path_width = save_cursor[2]",
            "                text(self, node, draw_as_text=True)",
            "            else:",
            "                self.context.fill_preserve()",
            "            self.context.restore()",
            "",
            "            # Stroke",
            "            self.context.save()",
            "            self.context.set_line_width(",
            "                size(self, node.get('stroke-width', '1')))",
            "            paint_source, paint_color = paint(node.get('stroke'))",
            "            if not gradient_or_pattern(",
            "                    self, node, paint_source, stroke_opacity):",
            "                self.context.set_source_rgba(",
            "                    *self.map_color(paint_color, stroke_opacity))",
            "            self.context.stroke()",
            "            self.context.restore()",
            "        elif not visible:",
            "            self.context.new_path()",
            "",
            "        # Draw path markers",
            "        draw_markers(self, node)",
            "",
            "        # Draw children",
            "        if display and node.tag not in INVISIBLE_TAGS:",
            "            for child in node.children:",
            "                self.draw(child)",
            "",
            "        # Apply filter, mask and opacity",
            "        if filter_ or mask or (opacity < 1 and node.children):",
            "            self.context.pop_group_to_source()",
            "            if filter_:",
            "                apply_filter_before_painting(self, node, filter_)",
            "            if mask in self.masks:",
            "                paint_mask(self, node, mask, opacity)",
            "            else:",
            "                self.context.paint_with_alpha(opacity)",
            "            if filter_:",
            "                apply_filter_after_painting(self, node, filter_)",
            "",
            "        # Clean cursor's position after 'text' tags",
            "        if node.tag == 'text':",
            "            self.cursor_position = [0, 0]",
            "            self.cursor_d_position = [0, 0]",
            "            self.text_path_width = 0",
            "",
            "        self.context.restore()",
            "        self.parent_node = old_parent_node",
            "        self.font_size = old_font_size",
            "        self.context_width, self.context_height = old_context_size",
            "",
            "",
            "class PDFSurface(Surface):",
            "    \"\"\"A surface that writes in PDF format.\"\"\"",
            "    surface_class = cairo.PDFSurface",
            "",
            "",
            "class PSSurface(Surface):",
            "    \"\"\"A surface that writes in PostScript format.\"\"\"",
            "    surface_class = cairo.PSSurface",
            "",
            "",
            "class EPSSurface(Surface):",
            "    \"\"\"A surface that writes in Encapsulated PostScript format.\"\"\"",
            "",
            "    def _create_surface(self, width, height):",
            "        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"",
            "        cairo_surface = cairo.PSSurface(self.output, width, height)",
            "        cairo_surface.set_eps(True)",
            "        return cairo_surface, width, height",
            "",
            "",
            "class PNGSurface(Surface):",
            "    \"\"\"A surface that writes in PNG format.\"\"\"",
            "    device_units_per_user_units = 1",
            "",
            "    def _create_surface(self, width, height):",
            "        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"",
            "        width = int(width)",
            "        height = int(height)",
            "        cairo_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)",
            "        return cairo_surface, width, height",
            "",
            "    def finish(self):",
            "        \"\"\"Read the PNG surface content.\"\"\"",
            "        if self.output is not None:",
            "            self.cairo.write_to_png(self.output)",
            "        return super().finish()",
            "",
            "",
            "class SVGSurface(Surface):",
            "    \"\"\"A surface that writes in SVG format.",
            "",
            "    It may seem pointless to render SVG to SVG, but this can be used",
            "    with ``output=None`` to get a vector-based single page cairo surface.",
            "",
            "    \"\"\"",
            "    surface_class = cairo.SVGSurface",
            "",
            "",
            "def parse_font(value):",
            "    ret = {\"font-family\": \"\", \"font-size\": \"\", \"font-style\": \"normal\",",
            "           \"font-variant\": \"normal\", \"font-weight\": \"normal\",",
            "           \"line-height\": \"normal\"}",
            "",
            "    font_styles = [\"italic\", \"oblique\"]",
            "    font_variants = [\"small-caps\"]",
            "    font_weights = [\"bold\", \"bolder\", \"lighter\", \"100\", \"200\", \"300\", \"400\",",
            "                    \"500\", \"600\", \"700\", \"800\", \"900\"]",
            "",
            "    for element in value.split():",
            "        if element == \"normal\":",
            "            continue",
            "        elif ret[\"font-family\"]:",
            "            ret[\"font-family\"] += \" \" + element",
            "        elif element in font_styles:",
            "            ret[\"font-style\"] = element",
            "        elif element in font_variants:",
            "            ret[\"font-variant\"] = element",
            "        elif element in font_weights:",
            "            ret[\"font-weight\"] = element",
            "        else:",
            "            if not ret[\"font-size\"]:",
            "                parts = element.split(\"/\")",
            "                ret[\"font-size\"] = parts[0]",
            "                if len(parts) > 1:",
            "                    ret[\"line-height\"] = parts[1]",
            "                continue",
            "            else:",
            "                ret[\"font-family\"] = element",
            "",
            "    return ret"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Cairo surface creators.",
            "",
            "\"\"\"",
            "",
            "import copy",
            "import io",
            "",
            "import cairocffi as cairo",
            "",
            "from .colors import color, negate_color",
            "from .defs import (",
            "    apply_filter_after_painting, apply_filter_before_painting, clip_path,",
            "    filter_, gradient_or_pattern, linear_gradient, marker, mask, paint_mask,",
            "    parse_all_defs, pattern, prepare_filter, radial_gradient, use)",
            "from .helpers import (",
            "    UNITS, PointError, clip_rect, node_format, normalize, paint,",
            "    preserve_ratio, size, transform)",
            "from .image import image, invert_image",
            "from .parser import Tree",
            "from .path import draw_markers, path",
            "from .shapes import circle, ellipse, line, polygon, polyline, rect",
            "from .svg import svg",
            "from .text import text",
            "from .url import parse_url",
            "",
            "SHAPE_ANTIALIAS = {",
            "    'optimizeSpeed': cairo.ANTIALIAS_FAST,",
            "    'crispEdges': cairo.ANTIALIAS_NONE,",
            "    'geometricPrecision': cairo.ANTIALIAS_BEST,",
            "}",
            "",
            "TEXT_ANTIALIAS = {",
            "    'crispEdges': cairo.ANTIALIAS_NONE,",
            "    'optimizeSpeed': cairo.ANTIALIAS_FAST,",
            "    'optimizeLegibility': cairo.ANTIALIAS_GOOD,",
            "    'geometricPrecision': cairo.ANTIALIAS_BEST,",
            "}",
            "",
            "TEXT_HINT_STYLE = {",
            "    'geometricPrecision': cairo.HINT_STYLE_NONE,",
            "    'optimizeLegibility': cairo.HINT_STYLE_FULL,",
            "}",
            "",
            "TEXT_HINT_METRICS = {",
            "    'geometricPrecision': cairo.HINT_METRICS_OFF,",
            "    'optimizeLegibility': cairo.HINT_METRICS_ON,",
            "}",
            "",
            "TAGS = {",
            "    'a': text,",
            "    'circle': circle,",
            "    'clipPath': clip_path,",
            "    'ellipse': ellipse,",
            "    'filter': filter_,",
            "    'image': image,",
            "    'line': line,",
            "    'linearGradient': linear_gradient,",
            "    'marker': marker,",
            "    'mask': mask,",
            "    'path': path,",
            "    'pattern': pattern,",
            "    'polyline': polyline,",
            "    'polygon': polygon,",
            "    'radialGradient': radial_gradient,",
            "    'rect': rect,",
            "    'svg': svg,",
            "    'text': text,",
            "    'textPath': text,",
            "    'tspan': text,",
            "    'use': use,",
            "}",
            "",
            "PATH_TAGS = frozenset((",
            "    'circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'))",
            "",
            "INVISIBLE_TAGS = frozenset((",
            "    'clipPath', 'filter', 'linearGradient', 'marker', 'mask', 'pattern',",
            "    'radialGradient', 'symbol'))",
            "",
            "",
            "class Surface(object):",
            "    \"\"\"Abstract base class for CairoSVG surfaces.",
            "",
            "    The ``width`` and ``height`` attributes are in device units (pixels for",
            "    PNG, else points).",
            "",
            "    The ``context_width`` and ``context_height`` attributes are in user units",
            "    (i.e. in pixels), they represent the size of the active viewport.",
            "",
            "    \"\"\"",
            "",
            "    # Subclasses must either define this or override _create_surface()",
            "    surface_class = None",
            "",
            "    @classmethod",
            "    def convert(cls, bytestring=None, *, file_obj=None, url=None, dpi=96,",
            "                parent_width=None, parent_height=None, scale=1, unsafe=False,",
            "                background_color=None, negate_colors=False,",
            "                invert_images=False, write_to=None, output_width=None,",
            "                output_height=None, **kwargs):",
            "        \"\"\"Convert an SVG document to the format for this class.",
            "",
            "        Specify the input by passing one of these:",
            "",
            "        :param bytestring: The SVG source as a byte-string.",
            "        :param file_obj: A file-like object.",
            "        :param url: A filename.",
            "",
            "        Give some options:",
            "",
            "        :param dpi: The ratio between 1 inch and 1 pixel.",
            "        :param parent_width: The width of the parent container in pixels.",
            "        :param parent_height: The height of the parent container in pixels.",
            "        :param scale: The ouptut scaling factor.",
            "        :param unsafe: A boolean allowing external file access, XML entities",
            "                       and very large files",
            "                       (WARNING: vulnerable to XXE attacks and various DoS).",
            "",
            "        Specifiy the output with:",
            "",
            "        :param write_to: The filename of file-like object where to write the",
            "                         output. If None or not provided, return a byte string.",
            "",
            "        Only ``bytestring`` can be passed as a positional argument, other",
            "        parameters are keyword-only.",
            "",
            "        \"\"\"",
            "        tree = Tree(",
            "            bytestring=bytestring, file_obj=file_obj, url=url, unsafe=unsafe,",
            "            **kwargs)",
            "        output = write_to or io.BytesIO()",
            "        instance = cls(",
            "            tree, output, dpi, None, parent_width, parent_height, scale,",
            "            output_width, output_height, background_color,",
            "            map_rgba=negate_color if negate_colors else None,",
            "            map_image=invert_image if invert_images else None)",
            "        instance.finish()",
            "        if write_to is None:",
            "            return output.getvalue()",
            "",
            "    def __init__(self, tree, output, dpi, parent_surface=None,",
            "                 parent_width=None, parent_height=None,",
            "                 scale=1, output_width=None, output_height=None,",
            "                 background_color=None, map_rgba=None, map_image=None):",
            "        \"\"\"Create the surface from a filename or a file-like object.",
            "",
            "        The rendered content is written to ``output`` which can be a filename,",
            "        a file-like object, ``None`` (render in memory but do not write",
            "        anything) or the built-in ``bytes`` as a marker.",
            "",
            "        Call the ``.finish()`` method to make sure that the output is",
            "        actually written.",
            "",
            "        \"\"\"",
            "        self.cairo = None",
            "        self.context_width, self.context_height = parent_width, parent_height",
            "        self.cursor_position = [0, 0]",
            "        self.cursor_d_position = [0, 0]",
            "        self.text_path_width = 0",
            "        self.tree_cache = {(tree.url, tree.get('id')): tree}",
            "        if parent_surface:",
            "            self.markers = parent_surface.markers",
            "            self.gradients = parent_surface.gradients",
            "            self.patterns = parent_surface.patterns",
            "            self.masks = parent_surface.masks",
            "            self.paths = parent_surface.paths",
            "            self.filters = parent_surface.filters",
            "            self.images = parent_surface.images",
            "        else:",
            "            self.markers = {}",
            "            self.gradients = {}",
            "            self.patterns = {}",
            "            self.masks = {}",
            "            self.paths = {}",
            "            self.filters = {}",
            "            self.images = {}",
            "        self._old_parent_node = self.parent_node = None",
            "        self.output = output",
            "        self.dpi = dpi",
            "        self.font_size = size(self, '12pt')",
            "        self.stroke_and_fill = True",
            "        width, height, viewbox = node_format(self, tree)",
            "        if viewbox is None:",
            "            viewbox = (0, 0, width, height)",
            "",
            "        if output_width and output_height:",
            "            width, height = output_width, output_height",
            "        elif output_width:",
            "            if width:",
            "                # Keep the aspect ratio",
            "                height *= output_width / width",
            "            width = output_width",
            "        elif output_height:",
            "            if height:",
            "                # Keep the aspect ratio",
            "                width *= output_height / height",
            "            height = output_height",
            "        else:",
            "            width *= scale",
            "            height *= scale",
            "",
            "        # Actual surface dimensions: may be rounded on raster surfaces types",
            "        self.cairo, self.width, self.height = self._create_surface(",
            "            width * self.device_units_per_user_units,",
            "            height * self.device_units_per_user_units)",
            "",
            "        if 0 in (self.width, self.height):",
            "            raise ValueError('The SVG size is undefined')",
            "",
            "        self.context = cairo.Context(self.cairo)",
            "        # We must scale the context as the surface size is using physical units",
            "        self.context.scale(",
            "            self.device_units_per_user_units, self.device_units_per_user_units)",
            "        # Initial, non-rounded dimensions",
            "        self.set_context_size(width, height, viewbox, tree)",
            "        self.context.move_to(0, 0)",
            "",
            "        if background_color:",
            "            self.context.set_source_rgba(*color(background_color))",
            "            self.context.paint()",
            "",
            "        self.map_rgba = map_rgba",
            "        self.map_image = map_image",
            "        self.draw(tree)",
            "",
            "    @property",
            "    def points_per_pixel(self):",
            "        \"\"\"Surface resolution.\"\"\"",
            "        return 1 / (self.dpi * UNITS['pt'])",
            "",
            "    @property",
            "    def device_units_per_user_units(self):",
            "        \"\"\"Ratio between Cairo device units and user units.",
            "",
            "        Device units are points for everything but PNG, and pixels for",
            "        PNG. User units are pixels.",
            "",
            "        \"\"\"",
            "        return self.points_per_pixel",
            "",
            "    def _create_surface(self, width, height):",
            "        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"",
            "        cairo_surface = self.surface_class(self.output, width, height)",
            "        return cairo_surface, width, height",
            "",
            "    def set_context_size(self, width, height, viewbox, tree):",
            "        \"\"\"Set the Cairo context size, set the SVG viewport size.\"\"\"",
            "        if viewbox:",
            "            rect_x, rect_y = viewbox[0:2]",
            "            tree.image_width = viewbox[2]",
            "            tree.image_height = viewbox[3]",
            "        else:",
            "            rect_x, rect_y = 0, 0",
            "            tree.image_width = width",
            "            tree.image_height = height",
            "",
            "        scale_x, scale_y, translate_x, translate_y = preserve_ratio(",
            "            self, tree, width, height)",
            "        rect_x, rect_y = rect_x * scale_x, rect_y * scale_y",
            "        rect_width, rect_height = width, height",
            "        self.context.translate(*self.context.get_current_point())",
            "        self.context.translate(-rect_x, -rect_y)",
            "        if tree.get('overflow', 'hidden') != 'visible':",
            "            self.context.rectangle(rect_x, rect_y, rect_width, rect_height)",
            "            self.context.clip()",
            "        self.context.scale(scale_x, scale_y)",
            "        self.context.translate(translate_x, translate_y)",
            "        self.context_width = rect_width / scale_x",
            "        self.context_height = rect_height / scale_y",
            "",
            "    def finish(self):",
            "        \"\"\"Read the surface content.\"\"\"",
            "        self.cairo.finish()",
            "",
            "    def map_color(self, string, opacity=1):",
            "        \"\"\"Parse a color ``string`` and apply ``map_rgba`` function to it.\"\"\"",
            "        rgba = color(string, opacity)",
            "        return self.map_rgba(rgba) if self.map_rgba else rgba",
            "",
            "    def draw(self, node):",
            "        \"\"\"Draw ``node`` and its children.\"\"\"",
            "",
            "        # Parse definitions first",
            "        if node.tag == 'svg':",
            "            parse_all_defs(self, node)",
            "",
            "        # Do not draw defs",
            "        if node.tag == 'defs':",
            "            return",
            "",
            "        # Do not draw elements with width or height of 0",
            "        if (('width' in node and size(self, node['width']) == 0) or",
            "                ('height' in node and size(self, node['height']) == 0)):",
            "            return",
            "",
            "        # Save context and related attributes",
            "        old_parent_node = self.parent_node",
            "        old_font_size = self.font_size",
            "        old_context_size = self.context_width, self.context_height",
            "        self.parent_node = node",
            "",
            "        if \"font\" in node:",
            "            font = parse_font(node[\"font\"])",
            "            for att in font:",
            "                if att not in node:",
            "                    node[att] = font[att]",
            "",
            "        self.font_size = size(self, node.get('font-size', '12pt'))",
            "        self.context.save()",
            "",
            "        # Apply transformations",
            "        transform(",
            "            self, node.get('transform'),",
            "            transform_origin=node.get('transform-origin'))",
            "",
            "        # Find and prepare opacity, masks and filters",
            "        mask = parse_url(node.get('mask')).fragment",
            "        filter_ = parse_url(node.get('filter')).fragment",
            "        opacity = float(node.get('opacity', 1))",
            "",
            "        if filter_:",
            "            prepare_filter(self, node, filter_)",
            "",
            "        if filter_ or mask or (opacity < 1 and node.children):",
            "            self.context.push_group()",
            "",
            "        # Move to (node.x, node.y)",
            "        self.context.move_to(",
            "            size(self, node.get('x'), 'x'),",
            "            size(self, node.get('y'), 'y'))",
            "",
            "        # Set node's drawing informations if the ``node.tag`` method exists",
            "        line_cap = node.get('stroke-linecap')",
            "        if line_cap == 'square':",
            "            self.context.set_line_cap(cairo.LINE_CAP_SQUARE)",
            "        if line_cap == 'round':",
            "            self.context.set_line_cap(cairo.LINE_CAP_ROUND)",
            "",
            "        join_cap = node.get('stroke-linejoin')",
            "        if join_cap == 'round':",
            "            self.context.set_line_join(cairo.LINE_JOIN_ROUND)",
            "        if join_cap == 'bevel':",
            "            self.context.set_line_join(cairo.LINE_JOIN_BEVEL)",
            "",
            "        dash_array = normalize(node.get('stroke-dasharray', '')).split()",
            "        if dash_array:",
            "            dashes = [size(self, dash) for dash in dash_array]",
            "            if sum(dashes):",
            "                offset = size(self, node.get('stroke-dashoffset'))",
            "                self.context.set_dash(dashes, offset)",
            "",
            "        miter_limit = float(node.get('stroke-miterlimit', 4))",
            "        self.context.set_miter_limit(miter_limit)",
            "",
            "        # Clip",
            "        rect_values = clip_rect(node.get('clip'))",
            "        if len(rect_values) == 4:",
            "            top = size(self, rect_values[0], 'y')",
            "            right = size(self, rect_values[1], 'x')",
            "            bottom = size(self, rect_values[2], 'y')",
            "            left = size(self, rect_values[3], 'x')",
            "            x = size(self, node.get('x'), 'x')",
            "            y = size(self, node.get('y'), 'y')",
            "            width = size(self, node.get('width'), 'x')",
            "            height = size(self, node.get('height'), 'y')",
            "            self.context.save()",
            "            self.context.translate(x, y)",
            "            self.context.rectangle(",
            "                left, top, width - left - right, height - top - bottom)",
            "            self.context.restore()",
            "            self.context.clip()",
            "        clip_path = parse_url(node.get('clip-path')).fragment",
            "        if clip_path:",
            "            path = self.paths.get(clip_path)",
            "            if path:",
            "                self.context.save()",
            "                if path.get('clipPathUnits') == 'objectBoundingBox':",
            "                    x = size(self, node.get('x'), 'x')",
            "                    y = size(self, node.get('y'), 'y')",
            "                    width = size(self, node.get('width'), 'x')",
            "                    height = size(self, node.get('height'), 'y')",
            "                    self.context.translate(x, y)",
            "                    self.context.scale(width, height)",
            "                path.tag = 'g'",
            "                self.stroke_and_fill = False",
            "                self.draw(path)",
            "                self.stroke_and_fill = True",
            "                self.context.restore()",
            "                # TODO: fill rules are not handled by cairo for clips",
            "                # if node.get('clip-rule') == 'evenodd':",
            "                #     self.context.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)",
            "                self.context.clip()",
            "                self.context.set_fill_rule(cairo.FILL_RULE_WINDING)",
            "",
            "        save_cursor = copy.deepcopy(",
            "            (self.cursor_position, self.cursor_d_position,",
            "             self.text_path_width))",
            "",
            "        # Only draw known tags",
            "        if node.tag in TAGS:",
            "            try:",
            "                TAGS[node.tag](self, node)",
            "            except PointError:",
            "                # Error in point parsing, do nothing",
            "                pass",
            "",
            "        # Get stroke and fill opacity",
            "        stroke_opacity = float(node.get('stroke-opacity', 1))",
            "        fill_opacity = float(node.get('fill-opacity', 1))",
            "        if opacity < 1 and not node.children:",
            "            stroke_opacity *= opacity",
            "            fill_opacity *= opacity",
            "",
            "        # Manage display and visibility",
            "        display = node.get('display', 'inline') != 'none'",
            "        visible = display and (node.get('visibility', 'visible') != 'hidden')",
            "",
            "        # Set font rendering properties",
            "        self.context.set_antialias(SHAPE_ANTIALIAS.get(",
            "            node.get('shape-rendering'), cairo.ANTIALIAS_DEFAULT))",
            "",
            "        font_options = self.context.get_font_options()",
            "        font_options.set_antialias(TEXT_ANTIALIAS.get(",
            "            node.get('text-rendering'), cairo.ANTIALIAS_DEFAULT))",
            "        font_options.set_hint_style(TEXT_HINT_STYLE.get(",
            "            node.get('text-rendering'), cairo.HINT_STYLE_DEFAULT))",
            "        font_options.set_hint_metrics(TEXT_HINT_METRICS.get(",
            "            node.get('text-rendering'), cairo.HINT_METRICS_DEFAULT))",
            "        self.context.set_font_options(font_options)",
            "",
            "        # Fill and stroke",
            "        if self.stroke_and_fill and visible and node.tag in TAGS:",
            "            # Fill",
            "            self.context.save()",
            "            paint_source, paint_color = paint(node.get('fill', 'black'))",
            "            if not gradient_or_pattern(self, node, paint_source, fill_opacity):",
            "                if node.get('fill-rule') == 'evenodd':",
            "                    self.context.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)",
            "                self.context.set_source_rgba(",
            "                    *self.map_color(paint_color, fill_opacity))",
            "            if TAGS[node.tag] == text:",
            "                self.cursor_position = save_cursor[0]",
            "                self.cursor_d_position = save_cursor[1]",
            "                self.text_path_width = save_cursor[2]",
            "                text(self, node, draw_as_text=True)",
            "            else:",
            "                self.context.fill_preserve()",
            "            self.context.restore()",
            "",
            "            # Stroke",
            "            self.context.save()",
            "            self.context.set_line_width(",
            "                size(self, node.get('stroke-width', '1')))",
            "            paint_source, paint_color = paint(node.get('stroke'))",
            "            if not gradient_or_pattern(",
            "                    self, node, paint_source, stroke_opacity):",
            "                self.context.set_source_rgba(",
            "                    *self.map_color(paint_color, stroke_opacity))",
            "            self.context.stroke()",
            "            self.context.restore()",
            "        elif not visible:",
            "            self.context.new_path()",
            "",
            "        # Draw path markers",
            "        draw_markers(self, node)",
            "",
            "        # Draw children",
            "        if display and node.tag not in INVISIBLE_TAGS:",
            "            for child in node.children:",
            "                self.draw(child)",
            "",
            "        # Apply filter, mask and opacity",
            "        if filter_ or mask or (opacity < 1 and node.children):",
            "            self.context.pop_group_to_source()",
            "            if filter_:",
            "                apply_filter_before_painting(self, node, filter_)",
            "            if mask in self.masks:",
            "                paint_mask(self, node, mask, opacity)",
            "            else:",
            "                self.context.paint_with_alpha(opacity)",
            "            if filter_:",
            "                apply_filter_after_painting(self, node, filter_)",
            "",
            "        # Clean cursor's position after 'text' tags",
            "        if node.tag == 'text':",
            "            self.cursor_position = [0, 0]",
            "            self.cursor_d_position = [0, 0]",
            "            self.text_path_width = 0",
            "",
            "        self.context.restore()",
            "        self.parent_node = old_parent_node",
            "        self.font_size = old_font_size",
            "        self.context_width, self.context_height = old_context_size",
            "",
            "",
            "class PDFSurface(Surface):",
            "    \"\"\"A surface that writes in PDF format.\"\"\"",
            "    surface_class = cairo.PDFSurface",
            "",
            "",
            "class PSSurface(Surface):",
            "    \"\"\"A surface that writes in PostScript format.\"\"\"",
            "    surface_class = cairo.PSSurface",
            "",
            "",
            "class EPSSurface(Surface):",
            "    \"\"\"A surface that writes in Encapsulated PostScript format.\"\"\"",
            "",
            "    def _create_surface(self, width, height):",
            "        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"",
            "        cairo_surface = cairo.PSSurface(self.output, width, height)",
            "        cairo_surface.set_eps(True)",
            "        return cairo_surface, width, height",
            "",
            "",
            "class PNGSurface(Surface):",
            "    \"\"\"A surface that writes in PNG format.\"\"\"",
            "    device_units_per_user_units = 1",
            "",
            "    def _create_surface(self, width, height):",
            "        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"",
            "        width = int(width)",
            "        height = int(height)",
            "        cairo_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)",
            "        return cairo_surface, width, height",
            "",
            "    def finish(self):",
            "        \"\"\"Read the PNG surface content.\"\"\"",
            "        if self.output is not None:",
            "            self.cairo.write_to_png(self.output)",
            "        return super().finish()",
            "",
            "",
            "class SVGSurface(Surface):",
            "    \"\"\"A surface that writes in SVG format.",
            "",
            "    It may seem pointless to render SVG to SVG, but this can be used",
            "    with ``output=None`` to get a vector-based single page cairo surface.",
            "",
            "    \"\"\"",
            "    surface_class = cairo.SVGSurface",
            "",
            "",
            "def parse_font(value):",
            "    ret = {\"font-family\": \"\", \"font-size\": \"\", \"font-style\": \"normal\",",
            "           \"font-variant\": \"normal\", \"font-weight\": \"normal\",",
            "           \"line-height\": \"normal\"}",
            "",
            "    font_styles = [\"italic\", \"oblique\"]",
            "    font_variants = [\"small-caps\"]",
            "    font_weights = [\"bold\", \"bolder\", \"lighter\", \"100\", \"200\", \"300\", \"400\",",
            "                    \"500\", \"600\", \"700\", \"800\", \"900\"]",
            "",
            "    for element in value.split():",
            "        if element == \"normal\":",
            "            continue",
            "        elif ret[\"font-family\"]:",
            "            ret[\"font-family\"] += \" \" + element",
            "        elif element in font_styles:",
            "            ret[\"font-style\"] = element",
            "        elif element in font_variants:",
            "            ret[\"font-variant\"] = element",
            "        elif element in font_weights:",
            "            ret[\"font-weight\"] = element",
            "        else:",
            "            if not ret[\"font-size\"]:",
            "                parts = element.split(\"/\")",
            "                ret[\"font-size\"] = parts[0]",
            "                if len(parts) > 1:",
            "                    ret[\"line-height\"] = parts[1]",
            "                continue",
            "            else:",
            "                ret[\"font-family\"] = element",
            "",
            "    return ret"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "116": [
                "Surface",
                "convert"
            ]
        },
        "addLocation": []
    }
}