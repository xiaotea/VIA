{
    "PIL/EpsImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     import tempfile, os, subprocess"
            },
            "2": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    file = tempfile.mktemp()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    out_fd, file = tempfile.mkstemp()"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    os.close(out_fd)"
            },
            "6": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     # Build ghostscript command"
            },
            "8": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     command = [\"gs\","
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# EPS file handling",
            "#",
            "# History:",
            "# 1995-09-01 fl   Created (0.1)",
            "# 1996-05-18 fl   Don't choke on \"atend\" fields, Ghostscript interface (0.2)",
            "# 1996-08-22 fl   Don't choke on floating point BoundingBox values",
            "# 1996-08-23 fl   Handle files from Macintosh (0.3)",
            "# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)",
            "# 2003-09-07 fl   Check gs.close status (from Federico Di Gregorio) (0.5)",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB.",
            "# Copyright (c) 1995-2003 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "__version__ = \"0.5\"",
            "",
            "import re",
            "import io",
            "from PIL import Image, ImageFile, _binary",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "i32 = _binary.i32le",
            "o32 = _binary.o32le",
            "",
            "split = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")",
            "field = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")",
            "",
            "gs_windows_binary = None",
            "import sys",
            "if sys.platform.startswith('win'):",
            "    import shutil",
            "    if hasattr(shutil, 'which'):",
            "        which = shutil.which",
            "    else:",
            "        # Python < 3.3",
            "        import distutils.spawn",
            "        which = distutils.spawn.find_executable",
            "    for binary in ('gswin32c', 'gswin64c', 'gs'):",
            "        if which(binary) is not None:",
            "            gs_windows_binary = binary",
            "            break",
            "    else:",
            "        gs_windows_binary = False",
            "",
            "def Ghostscript(tile, size, fp, scale=1):",
            "    \"\"\"Render an image using Ghostscript\"\"\"",
            "",
            "    # Unpack decoder tile",
            "    decoder, tile, offset, data = tile[0]",
            "    length, bbox = data",
            "",
            "    #Hack to support hi-res rendering",
            "    scale = int(scale) or 1",
            "    orig_size = size",
            "    orig_bbox = bbox",
            "    size = (size[0] * scale, size[1] * scale)",
            "    bbox = [bbox[0], bbox[1], bbox[2] * scale, bbox[3] * scale]",
            "    #print(\"Ghostscript\", scale, size, orig_size, bbox, orig_bbox)",
            "",
            "    import tempfile, os, subprocess",
            "",
            "    file = tempfile.mktemp()",
            "",
            "    # Build ghostscript command",
            "    command = [\"gs\",",
            "               \"-q\",                    # quite mode",
            "               \"-g%dx%d\" % size,        # set output geometry (pixels)",
            "               \"-r%d\" % (72*scale),     # set input DPI (dots per inch)",
            "               \"-dNOPAUSE -dSAFER\",     # don't pause between pages, safe mode",
            "               \"-sDEVICE=ppmraw\",       # ppm driver",
            "               \"-sOutputFile=%s\" % file,# output file",
            "            ]",
            "",
            "    if gs_windows_binary is not None:",
            "        if gs_windows_binary is False:",
            "            raise WindowsError('Unable to locate Ghostscript on paths')",
            "        command[0] = gs_windows_binary",
            "",
            "    # push data through ghostscript",
            "    try:",
            "        gs = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)",
            "        # adjust for image origin",
            "        if bbox[0] != 0 or bbox[1] != 0:",
            "            gs.stdin.write((\"%d %d translate\\n\" % (-bbox[0], -bbox[1])).encode('ascii'))",
            "        fp.seek(offset)",
            "        while length > 0:",
            "            s = fp.read(8192)",
            "            if not s:",
            "                break",
            "            length = length - len(s)",
            "            gs.stdin.write(s)",
            "        gs.stdin.close()",
            "        status = gs.wait()",
            "        if status:",
            "            raise IOError(\"gs failed (status %d)\" % status)",
            "        im = Image.core.open_ppm(file)",
            "    finally:",
            "        try: os.unlink(file)",
            "        except: pass",
            "",
            "    return im",
            "",
            "",
            "class PSFile:",
            "    \"\"\"Wrapper that treats either CR or LF as end of line.\"\"\"",
            "    def __init__(self, fp):",
            "        self.fp = fp",
            "        self.char = None",
            "    def __getattr__(self, id):",
            "        v = getattr(self.fp, id)",
            "        setattr(self, id, v)",
            "        return v",
            "    def seek(self, offset, whence=0):",
            "        self.char = None",
            "        self.fp.seek(offset, whence)",
            "    def read(self, count):",
            "        return self.fp.read(count).decode('latin-1')",
            "    def tell(self):",
            "        pos = self.fp.tell()",
            "        if self.char:",
            "            pos = pos - 1",
            "        return pos",
            "    def readline(self):",
            "        s = b\"\"",
            "        if self.char:",
            "            c = self.char",
            "            self.char = None",
            "        else:",
            "            c = self.fp.read(1)",
            "        while c not in b\"\\r\\n\":",
            "            s = s + c",
            "            c = self.fp.read(1)",
            "        if c == b\"\\r\":",
            "            self.char = self.fp.read(1)",
            "            if self.char == b\"\\n\":",
            "                self.char = None",
            "        return s.decode('latin-1') + \"\\n\"",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:4] == b\"%!PS\" or i32(prefix) == 0xC6D3D0C5",
            "",
            "##",
            "# Image plugin for Encapsulated Postscript.  This plugin supports only",
            "# a few variants of this format.",
            "",
            "class EpsImageFile(ImageFile.ImageFile):",
            "    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"",
            "",
            "    format = \"EPS\"",
            "    format_description = \"Encapsulated Postscript\"",
            "",
            "    def _open(self):",
            "",
            "        # FIXME: should check the first 512 bytes to see if this",
            "        # really is necessary (platform-dependent, though...)",
            "",
            "        fp = PSFile(self.fp)",
            "",
            "        # HEAD",
            "        s = fp.read(512)",
            "        if s[:4] == \"%!PS\":",
            "            offset = 0",
            "            fp.seek(0, 2)",
            "            length = fp.tell()",
            "        elif i32(s) == 0xC6D3D0C5:",
            "            offset = i32(s[4:])",
            "            length = i32(s[8:])",
            "            fp.seek(offset)",
            "        else:",
            "            raise SyntaxError(\"not an EPS file\")",
            "",
            "        fp.seek(offset)",
            "",
            "        box = None",
            "",
            "        self.mode = \"RGB\"",
            "        self.size = 1, 1 # FIXME: huh?",
            "",
            "        #",
            "        # Load EPS header",
            "",
            "        s = fp.readline()",
            "",
            "        while s:",
            "",
            "            if len(s) > 255:",
            "                raise SyntaxError(\"not an EPS file\")",
            "",
            "            if s[-2:] == '\\r\\n':",
            "                s = s[:-2]",
            "            elif s[-1:] == '\\n':",
            "                s = s[:-1]",
            "",
            "            try:",
            "                m = split.match(s)",
            "            except re.error as v:",
            "                raise SyntaxError(\"not an EPS file\")",
            "",
            "            if m:",
            "                k, v = m.group(1, 2)",
            "                self.info[k] = v",
            "                if k == \"BoundingBox\":",
            "                    try:",
            "                        # Note: The DSC spec says that BoundingBox",
            "                        # fields should be integers, but some drivers",
            "                        # put floating point values there anyway.",
            "                        box = [int(float(s)) for s in v.split()]",
            "                        self.size = box[2] - box[0], box[3] - box[1]",
            "                        self.tile = [(\"eps\", (0,0) + self.size, offset,",
            "                                      (length, box))]",
            "                    except:",
            "                        pass",
            "",
            "            else:",
            "",
            "                m = field.match(s)",
            "",
            "                if m:",
            "                    k = m.group(1)",
            "",
            "                    if k == \"EndComments\":",
            "                        break",
            "                    if k[:8] == \"PS-Adobe\":",
            "                        self.info[k[:8]] = k[9:]",
            "                    else:",
            "                        self.info[k] = \"\"",
            "                elif s[0:1] == '%':",
            "                    # handle non-DSC Postscript comments that some",
            "                    # tools mistakenly put in the Comments section",
            "                    pass",
            "                else:",
            "                    raise IOError(\"bad EPS header\")",
            "",
            "            s = fp.readline()",
            "",
            "            if s[:1] != \"%\":",
            "                break",
            "",
            "",
            "        #",
            "        # Scan for an \"ImageData\" descriptor",
            "",
            "        while s[0] == \"%\":",
            "",
            "            if len(s) > 255:",
            "                raise SyntaxError(\"not an EPS file\")",
            "",
            "            if s[-2:] == '\\r\\n':",
            "                s = s[:-2]",
            "            elif s[-1:] == '\\n':",
            "                s = s[:-1]",
            "",
            "            if s[:11] == \"%ImageData:\":",
            "",
            "                [x, y, bi, mo, z3, z4, en, id] =\\",
            "                    s[11:].split(None, 7)",
            "",
            "                x = int(x); y = int(y)",
            "",
            "                bi = int(bi)",
            "                mo = int(mo)",
            "",
            "                en = int(en)",
            "",
            "                if en == 1:",
            "                    decoder = \"eps_binary\"",
            "                elif en == 2:",
            "                    decoder = \"eps_hex\"",
            "                else:",
            "                    break",
            "                if bi != 8:",
            "                    break",
            "                if mo == 1:",
            "                    self.mode = \"L\"",
            "                elif mo == 2:",
            "                    self.mode = \"LAB\"",
            "                elif mo == 3:",
            "                    self.mode = \"RGB\"",
            "                else:",
            "                    break",
            "",
            "                if id[:1] == id[-1:] == '\"':",
            "                    id = id[1:-1]",
            "",
            "                # Scan forward to the actual image data",
            "                while True:",
            "                    s = fp.readline()",
            "                    if not s:",
            "                        break",
            "                    if s[:len(id)] == id:",
            "                        self.size = x, y",
            "                        self.tile2 = [(decoder,",
            "                                       (0, 0, x, y),",
            "                                       fp.tell(),",
            "                                       0)]",
            "                        return",
            "",
            "            s = fp.readline()",
            "            if not s:",
            "                break",
            "",
            "        if not box:",
            "            raise IOError(\"cannot determine EPS bounding box\")",
            "",
            "    def load(self, scale=1):",
            "        # Load EPS via Ghostscript",
            "        if not self.tile:",
            "            return",
            "        self.im = Ghostscript(self.tile, self.size, self.fp, scale)",
            "        self.mode = self.im.mode",
            "        self.size = self.im.size",
            "        self.tile = []",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "def _save(im, fp, filename, eps=1):",
            "    \"\"\"EPS Writer for the Python Imaging Library.\"\"\"",
            "",
            "    #",
            "    # make sure image data is available",
            "    im.load()",
            "",
            "    #",
            "    # determine postscript image mode",
            "    if im.mode == \"L\":",
            "        operator = (8, 1, \"image\")",
            "    elif im.mode == \"RGB\":",
            "        operator = (8, 3, \"false 3 colorimage\")",
            "    elif im.mode == \"CMYK\":",
            "        operator = (8, 4, \"false 4 colorimage\")",
            "    else:",
            "        raise ValueError(\"image mode is not supported\")",
            "",
            "    class NoCloseStream:",
            "        def __init__(self, fp):",
            "            self.fp = fp",
            "        def __getattr__(self, name):",
            "            return getattr(self.fp, name)",
            "        def close(self):",
            "            pass",
            "",
            "    base_fp = fp",
            "    fp = io.TextIOWrapper(NoCloseStream(fp), encoding='latin-1')",
            "",
            "    if eps:",
            "        #",
            "        # write EPS header",
            "        fp.write(\"%!PS-Adobe-3.0 EPSF-3.0\\n\")",
            "        fp.write(\"%%Creator: PIL 0.1 EpsEncode\\n\")",
            "        #fp.write(\"%%CreationDate: %s\"...)",
            "        fp.write(\"%%%%BoundingBox: 0 0 %d %d\\n\" % im.size)",
            "        fp.write(\"%%Pages: 1\\n\")",
            "        fp.write(\"%%EndComments\\n\")",
            "        fp.write(\"%%Page: 1 1\\n\")",
            "        fp.write(\"%%ImageData: %d %d \" % im.size)",
            "        fp.write(\"%d %d 0 1 1 \\\"%s\\\"\\n\" % operator)",
            "",
            "    #",
            "    # image header",
            "    fp.write(\"gsave\\n\")",
            "    fp.write(\"10 dict begin\\n\")",
            "    fp.write(\"/buf %d string def\\n\" % (im.size[0] * operator[1]))",
            "    fp.write(\"%d %d scale\\n\" % im.size)",
            "    fp.write(\"%d %d 8\\n\" % im.size) # <= bits",
            "    fp.write(\"[%d 0 0 -%d 0 %d]\\n\" % (im.size[0], im.size[1], im.size[1]))",
            "    fp.write(\"{ currentfile buf readhexstring pop } bind\\n\")",
            "    fp.write(operator[2] + \"\\n\")",
            "    fp.flush()",
            "",
            "    ImageFile._save(im, base_fp, [(\"eps\", (0,0)+im.size, 0, None)])",
            "",
            "    fp.write(\"\\n%%%%EndBinary\\n\")",
            "    fp.write(\"grestore end\\n\")",
            "    fp.flush()",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "Image.register_open(EpsImageFile.format, EpsImageFile, _accept)",
            "",
            "Image.register_save(EpsImageFile.format, _save)",
            "",
            "Image.register_extension(EpsImageFile.format, \".ps\")",
            "Image.register_extension(EpsImageFile.format, \".eps\")",
            "",
            "Image.register_mime(EpsImageFile.format, \"application/postscript\")"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# EPS file handling",
            "#",
            "# History:",
            "# 1995-09-01 fl   Created (0.1)",
            "# 1996-05-18 fl   Don't choke on \"atend\" fields, Ghostscript interface (0.2)",
            "# 1996-08-22 fl   Don't choke on floating point BoundingBox values",
            "# 1996-08-23 fl   Handle files from Macintosh (0.3)",
            "# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)",
            "# 2003-09-07 fl   Check gs.close status (from Federico Di Gregorio) (0.5)",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB.",
            "# Copyright (c) 1995-2003 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "__version__ = \"0.5\"",
            "",
            "import re",
            "import io",
            "from PIL import Image, ImageFile, _binary",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "i32 = _binary.i32le",
            "o32 = _binary.o32le",
            "",
            "split = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")",
            "field = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")",
            "",
            "gs_windows_binary = None",
            "import sys",
            "if sys.platform.startswith('win'):",
            "    import shutil",
            "    if hasattr(shutil, 'which'):",
            "        which = shutil.which",
            "    else:",
            "        # Python < 3.3",
            "        import distutils.spawn",
            "        which = distutils.spawn.find_executable",
            "    for binary in ('gswin32c', 'gswin64c', 'gs'):",
            "        if which(binary) is not None:",
            "            gs_windows_binary = binary",
            "            break",
            "    else:",
            "        gs_windows_binary = False",
            "",
            "def Ghostscript(tile, size, fp, scale=1):",
            "    \"\"\"Render an image using Ghostscript\"\"\"",
            "",
            "    # Unpack decoder tile",
            "    decoder, tile, offset, data = tile[0]",
            "    length, bbox = data",
            "",
            "    #Hack to support hi-res rendering",
            "    scale = int(scale) or 1",
            "    orig_size = size",
            "    orig_bbox = bbox",
            "    size = (size[0] * scale, size[1] * scale)",
            "    bbox = [bbox[0], bbox[1], bbox[2] * scale, bbox[3] * scale]",
            "    #print(\"Ghostscript\", scale, size, orig_size, bbox, orig_bbox)",
            "",
            "    import tempfile, os, subprocess",
            "",
            "    out_fd, file = tempfile.mkstemp()",
            "    os.close(out_fd)",
            "",
            "    # Build ghostscript command",
            "    command = [\"gs\",",
            "               \"-q\",                    # quite mode",
            "               \"-g%dx%d\" % size,        # set output geometry (pixels)",
            "               \"-r%d\" % (72*scale),     # set input DPI (dots per inch)",
            "               \"-dNOPAUSE -dSAFER\",     # don't pause between pages, safe mode",
            "               \"-sDEVICE=ppmraw\",       # ppm driver",
            "               \"-sOutputFile=%s\" % file,# output file",
            "            ]",
            "",
            "    if gs_windows_binary is not None:",
            "        if gs_windows_binary is False:",
            "            raise WindowsError('Unable to locate Ghostscript on paths')",
            "        command[0] = gs_windows_binary",
            "",
            "    # push data through ghostscript",
            "    try:",
            "        gs = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)",
            "        # adjust for image origin",
            "        if bbox[0] != 0 or bbox[1] != 0:",
            "            gs.stdin.write((\"%d %d translate\\n\" % (-bbox[0], -bbox[1])).encode('ascii'))",
            "        fp.seek(offset)",
            "        while length > 0:",
            "            s = fp.read(8192)",
            "            if not s:",
            "                break",
            "            length = length - len(s)",
            "            gs.stdin.write(s)",
            "        gs.stdin.close()",
            "        status = gs.wait()",
            "        if status:",
            "            raise IOError(\"gs failed (status %d)\" % status)",
            "        im = Image.core.open_ppm(file)",
            "    finally:",
            "        try: os.unlink(file)",
            "        except: pass",
            "",
            "    return im",
            "",
            "",
            "class PSFile:",
            "    \"\"\"Wrapper that treats either CR or LF as end of line.\"\"\"",
            "    def __init__(self, fp):",
            "        self.fp = fp",
            "        self.char = None",
            "    def __getattr__(self, id):",
            "        v = getattr(self.fp, id)",
            "        setattr(self, id, v)",
            "        return v",
            "    def seek(self, offset, whence=0):",
            "        self.char = None",
            "        self.fp.seek(offset, whence)",
            "    def read(self, count):",
            "        return self.fp.read(count).decode('latin-1')",
            "    def tell(self):",
            "        pos = self.fp.tell()",
            "        if self.char:",
            "            pos = pos - 1",
            "        return pos",
            "    def readline(self):",
            "        s = b\"\"",
            "        if self.char:",
            "            c = self.char",
            "            self.char = None",
            "        else:",
            "            c = self.fp.read(1)",
            "        while c not in b\"\\r\\n\":",
            "            s = s + c",
            "            c = self.fp.read(1)",
            "        if c == b\"\\r\":",
            "            self.char = self.fp.read(1)",
            "            if self.char == b\"\\n\":",
            "                self.char = None",
            "        return s.decode('latin-1') + \"\\n\"",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:4] == b\"%!PS\" or i32(prefix) == 0xC6D3D0C5",
            "",
            "##",
            "# Image plugin for Encapsulated Postscript.  This plugin supports only",
            "# a few variants of this format.",
            "",
            "class EpsImageFile(ImageFile.ImageFile):",
            "    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"",
            "",
            "    format = \"EPS\"",
            "    format_description = \"Encapsulated Postscript\"",
            "",
            "    def _open(self):",
            "",
            "        # FIXME: should check the first 512 bytes to see if this",
            "        # really is necessary (platform-dependent, though...)",
            "",
            "        fp = PSFile(self.fp)",
            "",
            "        # HEAD",
            "        s = fp.read(512)",
            "        if s[:4] == \"%!PS\":",
            "            offset = 0",
            "            fp.seek(0, 2)",
            "            length = fp.tell()",
            "        elif i32(s) == 0xC6D3D0C5:",
            "            offset = i32(s[4:])",
            "            length = i32(s[8:])",
            "            fp.seek(offset)",
            "        else:",
            "            raise SyntaxError(\"not an EPS file\")",
            "",
            "        fp.seek(offset)",
            "",
            "        box = None",
            "",
            "        self.mode = \"RGB\"",
            "        self.size = 1, 1 # FIXME: huh?",
            "",
            "        #",
            "        # Load EPS header",
            "",
            "        s = fp.readline()",
            "",
            "        while s:",
            "",
            "            if len(s) > 255:",
            "                raise SyntaxError(\"not an EPS file\")",
            "",
            "            if s[-2:] == '\\r\\n':",
            "                s = s[:-2]",
            "            elif s[-1:] == '\\n':",
            "                s = s[:-1]",
            "",
            "            try:",
            "                m = split.match(s)",
            "            except re.error as v:",
            "                raise SyntaxError(\"not an EPS file\")",
            "",
            "            if m:",
            "                k, v = m.group(1, 2)",
            "                self.info[k] = v",
            "                if k == \"BoundingBox\":",
            "                    try:",
            "                        # Note: The DSC spec says that BoundingBox",
            "                        # fields should be integers, but some drivers",
            "                        # put floating point values there anyway.",
            "                        box = [int(float(s)) for s in v.split()]",
            "                        self.size = box[2] - box[0], box[3] - box[1]",
            "                        self.tile = [(\"eps\", (0,0) + self.size, offset,",
            "                                      (length, box))]",
            "                    except:",
            "                        pass",
            "",
            "            else:",
            "",
            "                m = field.match(s)",
            "",
            "                if m:",
            "                    k = m.group(1)",
            "",
            "                    if k == \"EndComments\":",
            "                        break",
            "                    if k[:8] == \"PS-Adobe\":",
            "                        self.info[k[:8]] = k[9:]",
            "                    else:",
            "                        self.info[k] = \"\"",
            "                elif s[0:1] == '%':",
            "                    # handle non-DSC Postscript comments that some",
            "                    # tools mistakenly put in the Comments section",
            "                    pass",
            "                else:",
            "                    raise IOError(\"bad EPS header\")",
            "",
            "            s = fp.readline()",
            "",
            "            if s[:1] != \"%\":",
            "                break",
            "",
            "",
            "        #",
            "        # Scan for an \"ImageData\" descriptor",
            "",
            "        while s[0] == \"%\":",
            "",
            "            if len(s) > 255:",
            "                raise SyntaxError(\"not an EPS file\")",
            "",
            "            if s[-2:] == '\\r\\n':",
            "                s = s[:-2]",
            "            elif s[-1:] == '\\n':",
            "                s = s[:-1]",
            "",
            "            if s[:11] == \"%ImageData:\":",
            "",
            "                [x, y, bi, mo, z3, z4, en, id] =\\",
            "                    s[11:].split(None, 7)",
            "",
            "                x = int(x); y = int(y)",
            "",
            "                bi = int(bi)",
            "                mo = int(mo)",
            "",
            "                en = int(en)",
            "",
            "                if en == 1:",
            "                    decoder = \"eps_binary\"",
            "                elif en == 2:",
            "                    decoder = \"eps_hex\"",
            "                else:",
            "                    break",
            "                if bi != 8:",
            "                    break",
            "                if mo == 1:",
            "                    self.mode = \"L\"",
            "                elif mo == 2:",
            "                    self.mode = \"LAB\"",
            "                elif mo == 3:",
            "                    self.mode = \"RGB\"",
            "                else:",
            "                    break",
            "",
            "                if id[:1] == id[-1:] == '\"':",
            "                    id = id[1:-1]",
            "",
            "                # Scan forward to the actual image data",
            "                while True:",
            "                    s = fp.readline()",
            "                    if not s:",
            "                        break",
            "                    if s[:len(id)] == id:",
            "                        self.size = x, y",
            "                        self.tile2 = [(decoder,",
            "                                       (0, 0, x, y),",
            "                                       fp.tell(),",
            "                                       0)]",
            "                        return",
            "",
            "            s = fp.readline()",
            "            if not s:",
            "                break",
            "",
            "        if not box:",
            "            raise IOError(\"cannot determine EPS bounding box\")",
            "",
            "    def load(self, scale=1):",
            "        # Load EPS via Ghostscript",
            "        if not self.tile:",
            "            return",
            "        self.im = Ghostscript(self.tile, self.size, self.fp, scale)",
            "        self.mode = self.im.mode",
            "        self.size = self.im.size",
            "        self.tile = []",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "def _save(im, fp, filename, eps=1):",
            "    \"\"\"EPS Writer for the Python Imaging Library.\"\"\"",
            "",
            "    #",
            "    # make sure image data is available",
            "    im.load()",
            "",
            "    #",
            "    # determine postscript image mode",
            "    if im.mode == \"L\":",
            "        operator = (8, 1, \"image\")",
            "    elif im.mode == \"RGB\":",
            "        operator = (8, 3, \"false 3 colorimage\")",
            "    elif im.mode == \"CMYK\":",
            "        operator = (8, 4, \"false 4 colorimage\")",
            "    else:",
            "        raise ValueError(\"image mode is not supported\")",
            "",
            "    class NoCloseStream:",
            "        def __init__(self, fp):",
            "            self.fp = fp",
            "        def __getattr__(self, name):",
            "            return getattr(self.fp, name)",
            "        def close(self):",
            "            pass",
            "",
            "    base_fp = fp",
            "    fp = io.TextIOWrapper(NoCloseStream(fp), encoding='latin-1')",
            "",
            "    if eps:",
            "        #",
            "        # write EPS header",
            "        fp.write(\"%!PS-Adobe-3.0 EPSF-3.0\\n\")",
            "        fp.write(\"%%Creator: PIL 0.1 EpsEncode\\n\")",
            "        #fp.write(\"%%CreationDate: %s\"...)",
            "        fp.write(\"%%%%BoundingBox: 0 0 %d %d\\n\" % im.size)",
            "        fp.write(\"%%Pages: 1\\n\")",
            "        fp.write(\"%%EndComments\\n\")",
            "        fp.write(\"%%Page: 1 1\\n\")",
            "        fp.write(\"%%ImageData: %d %d \" % im.size)",
            "        fp.write(\"%d %d 0 1 1 \\\"%s\\\"\\n\" % operator)",
            "",
            "    #",
            "    # image header",
            "    fp.write(\"gsave\\n\")",
            "    fp.write(\"10 dict begin\\n\")",
            "    fp.write(\"/buf %d string def\\n\" % (im.size[0] * operator[1]))",
            "    fp.write(\"%d %d scale\\n\" % im.size)",
            "    fp.write(\"%d %d 8\\n\" % im.size) # <= bits",
            "    fp.write(\"[%d 0 0 -%d 0 %d]\\n\" % (im.size[0], im.size[1], im.size[1]))",
            "    fp.write(\"{ currentfile buf readhexstring pop } bind\\n\")",
            "    fp.write(operator[2] + \"\\n\")",
            "    fp.flush()",
            "",
            "    ImageFile._save(im, base_fp, [(\"eps\", (0,0)+im.size, 0, None)])",
            "",
            "    fp.write(\"\\n%%%%EndBinary\\n\")",
            "    fp.write(\"grestore end\\n\")",
            "    fp.flush()",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "Image.register_open(EpsImageFile.format, EpsImageFile, _accept)",
            "",
            "Image.register_save(EpsImageFile.format, _save)",
            "",
            "Image.register_extension(EpsImageFile.format, \".ps\")",
            "Image.register_extension(EpsImageFile.format, \".eps\")",
            "",
            "Image.register_mime(EpsImageFile.format, \"application/postscript\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "70": [
                "Ghostscript"
            ]
        },
        "addLocation": []
    },
    "PIL/Image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 495,
                "afterPatchRowNumber": 495,
                "PatchRowcode": "         self.readonly = 0"
            },
            "1": {
                "beforePatchRowNumber": 496,
                "afterPatchRowNumber": 496,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 497,
                "afterPatchRowNumber": 497,
                "PatchRowcode": "     def _dump(self, file=None, format=None):"
            },
            "3": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        import tempfile"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+        import tempfile, os"
            },
            "5": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": 499,
                "PatchRowcode": "         if not file:"
            },
            "6": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file = tempfile.mktemp()"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+            f, file = tempfile.mkstemp(format or '')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+            os.close(f)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 502,
                "PatchRowcode": "+            "
            },
            "10": {
                "beforePatchRowNumber": 501,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "         self.load()"
            },
            "11": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "         if not format or format == \"PPM\":"
            },
            "12": {
                "beforePatchRowNumber": 503,
                "afterPatchRowNumber": 505,
                "PatchRowcode": "             self.im.save_ppm(file)"
            },
            "13": {
                "beforePatchRowNumber": 504,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "         else:"
            },
            "14": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file = file + \".\" + format"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+            if file.endswith(format):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 508,
                "PatchRowcode": "+                file = file + \".\" + format"
            },
            "17": {
                "beforePatchRowNumber": 506,
                "afterPatchRowNumber": 509,
                "PatchRowcode": "             self.save(file, format)"
            },
            "18": {
                "beforePatchRowNumber": 507,
                "afterPatchRowNumber": 510,
                "PatchRowcode": "         return file"
            },
            "19": {
                "beforePatchRowNumber": 508,
                "afterPatchRowNumber": 511,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# the Image class wrapper",
            "#",
            "# partial release history:",
            "# 1995-09-09 fl   Created",
            "# 1996-03-11 fl   PIL release 0.0 (proof of concept)",
            "# 1996-04-30 fl   PIL release 0.1b1",
            "# 1999-07-28 fl   PIL release 1.0 final",
            "# 2000-06-07 fl   PIL release 1.1",
            "# 2000-10-20 fl   PIL release 1.1.1",
            "# 2001-05-07 fl   PIL release 1.1.2",
            "# 2002-03-15 fl   PIL release 1.1.3",
            "# 2003-05-10 fl   PIL release 1.1.4",
            "# 2005-03-28 fl   PIL release 1.1.5",
            "# 2006-12-02 fl   PIL release 1.1.6",
            "# 2009-11-15 fl   PIL release 1.1.7",
            "#",
            "# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.",
            "# Copyright (c) 1995-2009 by Fredrik Lundh.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "from __future__ import print_function",
            "",
            "from PIL import VERSION, PILLOW_VERSION, _plugins",
            "",
            "import warnings",
            "",
            "class _imaging_not_installed:",
            "    # module placeholder",
            "    def __getattr__(self, id):",
            "        raise ImportError(\"The _imaging C module is not installed\")",
            "",
            "try:",
            "    # give Tk a chance to set up the environment, in case we're",
            "    # using an _imaging module linked against libtcl/libtk (use",
            "    # __import__ to hide this from naive packagers; we don't really",
            "    # depend on Tk unless ImageTk is used, and that module already",
            "    # imports Tkinter)",
            "    __import__(\"FixTk\")",
            "except ImportError:",
            "    pass",
            "",
            "try:",
            "    # If the _imaging C module is not present, you can still use",
            "    # the \"open\" function to identify files, but you cannot load",
            "    # them.  Note that other modules should not refer to _imaging",
            "    # directly; import Image and use the Image.core variable instead.",
            "    from PIL import _imaging as core",
            "    if PILLOW_VERSION != getattr(core, 'PILLOW_VERSION', None):",
            "         raise ImportError(\"The _imaging extension was built for another \"",
            "                            \" version of Pillow or PIL\")",
            "",
            "except ImportError as v:",
            "    core = _imaging_not_installed()",
            "    # Explanations for ways that we know we might have an import error",
            "    if str(v).startswith(\"Module use of python\"):",
            "        # The _imaging C module is present, but not compiled for",
            "        # the right version (windows only).  Print a warning, if",
            "        # possible.",
            "        warnings.warn(",
            "            \"The _imaging extension was built for another version \"",
            "            \"of Python.\",",
            "            RuntimeWarning",
            "            )",
            "    elif str(v).startswith(\"The _imaging extension\"):",
            "        warnings.warn(str(v), RuntimeWarning)",
            "    elif \"Symbol not found: _PyUnicodeUCS2_FromString\" in str(v):",
            "        warnings.warn(",
            "            \"The _imaging extension was built for Python with UCS2 support; \"",
            "            \"recompile PIL or build Python --without-wide-unicode. \",",
            "            RuntimeWarning",
            "            )",
            "    elif \"Symbol not found: _PyUnicodeUCS4_FromString\" in str(v):",
            "        warnings.warn(",
            "            \"The _imaging extension was built for Python with UCS4 support; \"",
            "            \"recompile PIL or build Python --with-wide-unicode. \",",
            "            RuntimeWarning",
            "            )",
            "    # Fail here anyway. Don't let people run with a mostly broken Pillow.",
            "    raise",
            "",
            "try:",
            "    import builtins",
            "except ImportError:",
            "    import __builtin__",
            "    builtins = __builtin__",
            "",
            "from PIL import ImageMode",
            "from PIL._binary import i8, o8",
            "from PIL._util import isPath, isStringType",
            "",
            "import os, sys",
            "",
            "# type stuff",
            "import collections",
            "import numbers",
            "",
            "",
            "def isImageType(t):",
            "    \"\"\"",
            "    Checks if an object is an image object.",
            "",
            "    .. warning::",
            "",
            "       This function is for internal use only.",
            "",
            "    :param t: object to check if it's an image",
            "    :returns: True if the object is an image",
            "    \"\"\"",
            "    return hasattr(t, \"im\")",
            "",
            "#",
            "# Debug level",
            "",
            "DEBUG = 0",
            "",
            "#",
            "# Constants (also defined in _imagingmodule.c!)",
            "",
            "NONE = 0",
            "",
            "# transpose",
            "FLIP_LEFT_RIGHT = 0",
            "FLIP_TOP_BOTTOM = 1",
            "ROTATE_90 = 2",
            "ROTATE_180 = 3",
            "ROTATE_270 = 4",
            "",
            "# transforms",
            "AFFINE = 0",
            "EXTENT = 1",
            "PERSPECTIVE = 2",
            "QUAD = 3",
            "MESH = 4",
            "",
            "# resampling filters",
            "NONE = 0",
            "NEAREST = 0",
            "ANTIALIAS = 1 # 3-lobed lanczos",
            "LINEAR = BILINEAR = 2",
            "CUBIC = BICUBIC = 3",
            "",
            "# dithers",
            "NONE = 0",
            "NEAREST = 0",
            "ORDERED = 1 # Not yet implemented",
            "RASTERIZE = 2 # Not yet implemented",
            "FLOYDSTEINBERG = 3 # default",
            "",
            "# palettes/quantizers",
            "WEB = 0",
            "ADAPTIVE = 1",
            "",
            "MEDIANCUT = 0",
            "MAXCOVERAGE = 1",
            "FASTOCTREE = 2",
            "",
            "# categories",
            "NORMAL = 0",
            "SEQUENCE = 1",
            "CONTAINER = 2",
            "",
            "if hasattr(core, 'DEFAULT_STRATEGY'):",
            "    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY",
            "    FILTERED = core.FILTERED",
            "    HUFFMAN_ONLY = core.HUFFMAN_ONLY",
            "    RLE = core.RLE",
            "    FIXED = core.FIXED",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# Registries",
            "",
            "ID = []",
            "OPEN = {}",
            "MIME = {}",
            "SAVE = {}",
            "EXTENSION = {}",
            "",
            "# --------------------------------------------------------------------",
            "# Modes supported by this version",
            "",
            "_MODEINFO = {",
            "    # NOTE: this table will be removed in future versions.  use",
            "    # getmode* functions or ImageMode descriptors instead.",
            "",
            "    # official modes",
            "    \"1\": (\"L\", \"L\", (\"1\",)),",
            "    \"L\": (\"L\", \"L\", (\"L\",)),",
            "    \"I\": (\"L\", \"I\", (\"I\",)),",
            "    \"F\": (\"L\", \"F\", (\"F\",)),",
            "    \"P\": (\"RGB\", \"L\", (\"P\",)),",
            "    \"RGB\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\")),",
            "    \"RGBX\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"X\")),",
            "    \"RGBA\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"A\")),",
            "    \"CMYK\": (\"RGB\", \"L\", (\"C\", \"M\", \"Y\", \"K\")),",
            "    \"YCbCr\": (\"RGB\", \"L\", (\"Y\", \"Cb\", \"Cr\")),",
            "    \"LAB\": (\"RGB\", \"L\", (\"L\", \"A\", \"B\")),",
            "",
            "    # Experimental modes include I;16, I;16L, I;16B, RGBa, BGR;15, and",
            "    # BGR;24.  Use these modes only if you know exactly what you're",
            "    # doing...",
            "",
            "}",
            "",
            "if sys.byteorder == 'little':",
            "    _ENDIAN = '<'",
            "else:",
            "    _ENDIAN = '>'",
            "",
            "_MODE_CONV = {",
            "    # official modes",
            "    \"1\": ('|b1', None), # broken",
            "    \"L\": ('|u1', None),",
            "    \"I\": (_ENDIAN + 'i4', None),",
            "    \"F\": (_ENDIAN + 'f4', None),",
            "    \"P\": ('|u1', None),",
            "    \"RGB\": ('|u1', 3),",
            "    \"RGBX\": ('|u1', 4),",
            "    \"RGBA\": ('|u1', 4),",
            "    \"CMYK\": ('|u1', 4),",
            "    \"YCbCr\": ('|u1', 3),",
            "    \"LAB\": ('|u1', 3), # UNDONE - unsigned |u1i1i1",
            "\t# I;16 == I;16L, and I;32 == I;32L  ",
            "    \"I;16\": ('<u2', None),",
            "    \"I;16B\": ('>u2', None),",
            "    \"I;16L\": ('<u2', None),",
            "    \"I;16S\": ('<i2', None),",
            "    \"I;16BS\": ('>i2', None),",
            "    \"I;16LS\": ('<i2', None),",
            "    \"I;32\": ('<u4', None),",
            "    \"I;32B\": ('>u4', None),",
            "    \"I;32L\": ('<u4', None),",
            "    \"I;32S\": ('<i4', None),",
            "    \"I;32BS\": ('>i4', None),",
            "    \"I;32LS\": ('<i4', None),",
            "}",
            "",
            "def _conv_type_shape(im):",
            "    shape = im.size[1], im.size[0]",
            "    typ, extra = _MODE_CONV[im.mode]",
            "    if extra is None:",
            "        return shape, typ",
            "    else:",
            "        return shape+(extra,), typ",
            "",
            "",
            "MODES = sorted(_MODEINFO.keys())",
            "",
            "# raw modes that may be memory mapped.  NOTE: if you change this, you",
            "# may have to modify the stride calculation in map.c too!",
            "_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")",
            "",
            "",
            "def getmodebase(mode):",
            "    \"\"\"",
            "    Gets the \"base\" mode for given mode.  This function returns \"L\" for",
            "    images that contain grayscale data, and \"RGB\" for images that",
            "    contain color data.",
            "",
            "    :param mode: Input mode.",
            "    :returns: \"L\" or \"RGB\".",
            "    :exception KeyError: If the input mode was not a standard mode.",
            "    \"\"\"",
            "    return ImageMode.getmode(mode).basemode",
            "",
            "",
            "def getmodetype(mode):",
            "    \"\"\"",
            "    Gets the storage type mode.  Given a mode, this function returns a",
            "    single-layer mode suitable for storing individual bands.",
            "",
            "    :param mode: Input mode.",
            "    :returns: \"L\", \"I\", or \"F\".",
            "    :exception KeyError: If the input mode was not a standard mode.",
            "    \"\"\"",
            "    return ImageMode.getmode(mode).basetype",
            "",
            "",
            "def getmodebandnames(mode):",
            "    \"\"\"",
            "    Gets a list of individual band names.  Given a mode, this function returns",
            "    a tuple containing the names of individual bands (use",
            "    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each",
            "    individual band.",
            "",
            "    :param mode: Input mode.",
            "    :returns: A tuple containing band names.  The length of the tuple",
            "        gives the number of bands in an image of the given mode.",
            "    :exception KeyError: If the input mode was not a standard mode.",
            "    \"\"\"",
            "    return ImageMode.getmode(mode).bands",
            "",
            "",
            "def getmodebands(mode):",
            "    \"\"\"",
            "    Gets the number of individual bands for this mode.",
            "",
            "    :param mode: Input mode.",
            "    :returns: The number of bands in this mode.",
            "    :exception KeyError: If the input mode was not a standard mode.",
            "    \"\"\"",
            "    return len(ImageMode.getmode(mode).bands)",
            "",
            "# --------------------------------------------------------------------",
            "# Helpers",
            "",
            "_initialized = 0",
            "",
            "",
            "def preinit():",
            "    \"Explicitly load standard file format drivers.\"",
            "",
            "    global _initialized",
            "    if _initialized >= 1:",
            "        return",
            "",
            "    try:",
            "        from PIL import BmpImagePlugin",
            "    except ImportError:",
            "        pass",
            "    try:",
            "        from PIL import GifImagePlugin",
            "    except ImportError:",
            "        pass",
            "    try:",
            "        from PIL import JpegImagePlugin",
            "    except ImportError:",
            "        pass",
            "    try:",
            "        from PIL import PpmImagePlugin",
            "    except ImportError:",
            "        pass",
            "    try:",
            "        from PIL import PngImagePlugin",
            "    except ImportError:",
            "        pass",
            "#   try:",
            "#       import TiffImagePlugin",
            "#   except ImportError:",
            "#       pass",
            "",
            "    _initialized = 1",
            "",
            "",
            "def init():",
            "    \"\"\"",
            "    Explicitly initializes the Python Imaging Library. This function",
            "    loads all available file format drivers.",
            "    \"\"\"",
            "",
            "    global _initialized",
            "    if _initialized >= 2:",
            "        return 0",
            "",
            "    for plugin in _plugins:",
            "        try:",
            "            if DEBUG:",
            "                print (\"Importing %s\"%plugin)",
            "            __import__(\"PIL.%s\"%plugin, globals(), locals(), [])",
            "        except ImportError:",
            "            if DEBUG:",
            "                print(\"Image: failed to import\", end=' ')",
            "                print(plugin, \":\", sys.exc_info()[1])",
            "",
            "    if OPEN or SAVE:",
            "        _initialized = 2",
            "        return 1",
            "",
            "# --------------------------------------------------------------------",
            "# Codec factories (used by tobytes/frombytes and ImageFile.load)",
            "",
            "def _getdecoder(mode, decoder_name, args, extra=()):",
            "",
            "    # tweak arguments",
            "    if args is None:",
            "        args = ()",
            "    elif not isinstance(args, tuple):",
            "        args = (args,)",
            "",
            "    try:",
            "        # get decoder",
            "        decoder = getattr(core, decoder_name + \"_decoder\")",
            "        # print(decoder, mode, args + extra)",
            "        return decoder(mode, *args + extra)",
            "    except AttributeError:",
            "        raise IOError(\"decoder %s not available\" % decoder_name)",
            "",
            "def _getencoder(mode, encoder_name, args, extra=()):",
            "",
            "    # tweak arguments",
            "    if args is None:",
            "        args = ()",
            "    elif not isinstance(args, tuple):",
            "        args = (args,)",
            "",
            "    try:",
            "        # get encoder",
            "        encoder = getattr(core, encoder_name + \"_encoder\")",
            "        # print(encoder, mode, args + extra)",
            "        return encoder(mode, *args + extra)",
            "    except AttributeError:",
            "        raise IOError(\"encoder %s not available\" % encoder_name)",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# Simple expression analyzer",
            "",
            "def coerce_e(value):",
            "    return value if isinstance(value, _E) else _E(value)",
            "",
            "class _E:",
            "    def __init__(self, data):",
            "        self.data = data",
            "    def __add__(self, other):",
            "        return _E((self.data, \"__add__\", coerce_e(other).data))",
            "    def __mul__(self, other):",
            "        return _E((self.data, \"__mul__\", coerce_e(other).data))",
            "",
            "def _getscaleoffset(expr):",
            "    stub = [\"stub\"]",
            "    data = expr(_E(stub)).data",
            "    try:",
            "        (a, b, c) = data # simplified syntax",
            "        if (a is stub and b == \"__mul__\" and isinstance(c, numbers.Number)):",
            "            return c, 0.0",
            "        if (a is stub and b == \"__add__\" and isinstance(c, numbers.Number)):",
            "            return 1.0, c",
            "    except TypeError: pass",
            "    try:",
            "        ((a, b, c), d, e) = data # full syntax",
            "        if (a is stub and b == \"__mul__\" and isinstance(c, numbers.Number) and",
            "            d == \"__add__\" and isinstance(e, numbers.Number)):",
            "            return c, e",
            "    except TypeError: pass",
            "    raise ValueError(\"illegal expression\")",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# Implementation wrapper",
            "",
            "class Image:",
            "    \"\"\"",
            "    This class represents an image object.  To create",
            "    :py:class:`~PIL.Image.Image` objects, use the appropriate factory",
            "    functions.  There's hardly ever any reason to call the Image constructor",
            "    directly.",
            "",
            "    * :py:func:`~PIL.Image.open`",
            "    * :py:func:`~PIL.Image.new`",
            "    * :py:func:`~PIL.Image.frombytes`",
            "    \"\"\"",
            "    format = None",
            "    format_description = None",
            "",
            "    def __init__(self):",
            "        # FIXME: take \"new\" parameters / other image?",
            "        # FIXME: turn mode and size into delegating properties?",
            "        self.im = None",
            "        self.mode = \"\"",
            "        self.size = (0, 0)",
            "        self.palette = None",
            "        self.info = {}",
            "        self.category = NORMAL",
            "        self.readonly = 0",
            "",
            "    def _new(self, im):",
            "        new = Image()",
            "        new.im = im",
            "        new.mode = im.mode",
            "        new.size = im.size",
            "        new.palette = self.palette",
            "        if im.mode == \"P\" and not new.palette:",
            "            from PIL import ImagePalette",
            "            new.palette = ImagePalette.ImagePalette()",
            "        try:",
            "            new.info = self.info.copy()",
            "        except AttributeError:",
            "            # fallback (pre-1.5.2)",
            "            new.info = {}",
            "            for k, v in self.info:",
            "                new.info[k] = v",
            "        return new",
            "",
            "    _makeself = _new # compatibility",
            "",
            "    def _copy(self):",
            "        self.load()",
            "        self.im = self.im.copy()",
            "        self.readonly = 0",
            "",
            "    def _dump(self, file=None, format=None):",
            "        import tempfile",
            "        if not file:",
            "            file = tempfile.mktemp()",
            "        self.load()",
            "        if not format or format == \"PPM\":",
            "            self.im.save_ppm(file)",
            "        else:",
            "            file = file + \".\" + format",
            "            self.save(file, format)",
            "        return file",
            "",
            "    def __repr__(self):",
            "        return \"<%s.%s image mode=%s size=%dx%d at 0x%X>\" % (",
            "            self.__class__.__module__, self.__class__.__name__,",
            "            self.mode, self.size[0], self.size[1],",
            "            id(self)",
            "            )",
            "",
            "    def __getattr__(self, name):",
            "        if name == \"__array_interface__\":",
            "            # numpy array interface support",
            "            new = {}",
            "            shape, typestr = _conv_type_shape(self)",
            "            new['shape'] = shape",
            "            new['typestr'] = typestr",
            "            new['data'] = self.tobytes()",
            "            return new",
            "        raise AttributeError(name)",
            "",
            "    def tobytes(self, encoder_name=\"raw\", *args):",
            "        \"\"\"",
            "        Return image as a bytes object",
            "",
            "        :param encoder_name: What encoder to use.  The default is to",
            "                             use the standard \"raw\" encoder.",
            "        :param args: Extra arguments to the encoder.",
            "        :rtype: A bytes object.",
            "        \"\"\"",
            "",
            "        # may pass tuple instead of argument list",
            "        if len(args) == 1 and isinstance(args[0], tuple):",
            "            args = args[0]",
            "",
            "        if encoder_name == \"raw\" and args == ():",
            "            args = self.mode",
            "",
            "        self.load()",
            "",
            "        # unpack data",
            "        e = _getencoder(self.mode, encoder_name, args)",
            "        e.setimage(self.im)",
            "",
            "        bufsize = max(65536, self.size[0] * 4) # see RawEncode.c",
            "",
            "        data = []",
            "        while True:",
            "            l, s, d = e.encode(bufsize)",
            "            data.append(d)",
            "            if s:",
            "                break",
            "        if s < 0:",
            "            raise RuntimeError(\"encoder error %d in tobytes\" % s)",
            "",
            "        return b\"\".join(data)",
            "",
            "    # Declare tostring as alias to tobytes",
            "    def tostring(self, *args, **kw):",
            "        warnings.warn(",
            "            'tostring() is deprecated. Please call tobytes() instead.',",
            "            DeprecationWarning,",
            "            stacklevel=2,",
            "        )",
            "        return self.tobytes(*args, **kw)",
            "",
            "    def tobitmap(self, name=\"image\"):",
            "        \"\"\"",
            "        Returns the image converted to an X11 bitmap.",
            "",
            "        .. note:: This method only works for mode \"1\" images.",
            "",
            "        :param name: The name prefix to use for the bitmap variables.",
            "        :returns: A string containing an X11 bitmap.",
            "        :raises ValueError: If the mode is not \"1\"",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.mode != \"1\":",
            "            raise ValueError(\"not a bitmap\")",
            "        data = self.tobytes(\"xbm\")",
            "        return b\"\".join([(\"#define %s_width %d\\n\" % (name, self.size[0])).encode('ascii'),",
            "                (\"#define %s_height %d\\n\"% (name, self.size[1])).encode('ascii'),",
            "                (\"static char %s_bits[] = {\\n\" % name).encode('ascii'), data, b\"};\"])",
            "",
            "    def frombytes(self, data, decoder_name=\"raw\", *args):",
            "        \"\"\"",
            "        Loads this image with pixel data from a bytes object.",
            "",
            "        This method is similar to the :py:func:`~PIL.Image.frombytes` function,",
            "        but loads data into this image instead of creating a new image object.",
            "        \"\"\"",
            "",
            "        # may pass tuple instead of argument list",
            "        if len(args) == 1 and isinstance(args[0], tuple):",
            "            args = args[0]",
            "",
            "        # default format",
            "        if decoder_name == \"raw\" and args == ():",
            "            args = self.mode",
            "",
            "        # unpack data",
            "        d = _getdecoder(self.mode, decoder_name, args)",
            "        d.setimage(self.im)",
            "        s = d.decode(data)",
            "",
            "        if s[0] >= 0:",
            "            raise ValueError(\"not enough image data\")",
            "        if s[1] != 0:",
            "            raise ValueError(\"cannot decode image data\")",
            "",
            "    def fromstring(self, *args, **kw):",
            "        \"\"\"Deprecated alias to frombytes.",
            "",
            "        .. deprecated:: 2.0",
            "        \"\"\"",
            "        warnings.warn('fromstring() is deprecated. Please call frombytes() instead.', DeprecationWarning)",
            "        return self.frombytes(*args, **kw)",
            "",
            "    def load(self):",
            "        \"\"\"",
            "        Allocates storage for the image and loads the pixel data.  In",
            "        normal cases, you don't need to call this method, since the",
            "        Image class automatically loads an opened image when it is",
            "        accessed for the first time.",
            "",
            "        :returns: An image access object.",
            "        \"\"\"",
            "        if self.im and self.palette and self.palette.dirty:",
            "            # realize palette",
            "            self.im.putpalette(*self.palette.getdata())",
            "            self.palette.dirty = 0",
            "            self.palette.mode = \"RGB\"",
            "            self.palette.rawmode = None",
            "            if \"transparency\" in self.info:",
            "                if isinstance(self.info[\"transparency\"], int):",
            "                    self.im.putpalettealpha(self.info[\"transparency\"], 0)",
            "                else:",
            "                    self.im.putpalettealphas(self.info[\"transparency\"])",
            "                self.palette.mode = \"RGBA\"",
            "",
            "        if self.im:",
            "            return self.im.pixel_access(self.readonly)",
            "",
            "    def verify(self):",
            "        \"\"\"",
            "        Verifies the contents of a file. For data read from a file, this",
            "        method attempts to determine if the file is broken, without",
            "        actually decoding the image data.  If this method finds any",
            "        problems, it raises suitable exceptions.  If you need to load",
            "        the image after using this method, you must reopen the image",
            "        file.",
            "        \"\"\"",
            "        pass",
            "",
            "    def convert(self, mode=None, matrix=None, dither=None,",
            "                palette=WEB, colors=256):",
            "        \"\"\"",
            "        Returns a converted copy of this image. For the \"P\" mode, this",
            "        method translates pixels through the palette.  If mode is",
            "        omitted, a mode is chosen so that all information in the image",
            "        and the palette can be represented without a palette.",
            "",
            "        The current version supports all possible conversions between",
            "        \"L\", \"RGB\" and \"CMYK.\" The **matrix** argument only supports \"L\"",
            "        and \"RGB\".",
            "",
            "        When translating a color image to black and white (mode \"L\"),",
            "        the library uses the ITU-R 601-2 luma transform::",
            "",
            "            L = R * 299/1000 + G * 587/1000 + B * 114/1000",
            "",
            "        The default method of converting a greyscale (\"L\") or \"RGB\"",
            "        image into a bilevel (mode \"1\") image uses Floyd-Steinberg",
            "        dither to approximate the original image luminosity levels. If",
            "        dither is NONE, all non-zero values are set to 255 (white). To",
            "        use other thresholds, use the :py:meth:`~PIL.Image.Image.point`",
            "        method.",
            "",
            "        :param mode: The requested mode.",
            "        :param matrix: An optional conversion matrix.  If given, this",
            "           should be 4- or 16-tuple containing floating point values.",
            "        :param dither: Dithering method, used when converting from",
            "           mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".",
            "           Available methods are NONE or FLOYDSTEINBERG (default).",
            "        :param palette: Palette to use when converting from mode \"RGB\"",
            "           to \"P\".  Available palettes are WEB or ADAPTIVE.",
            "        :param colors: Number of colors to use for the ADAPTIVE palette.",
            "           Defaults to 256.",
            "        :rtype: :py:class:`~PIL.Image.Image`",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if not mode:",
            "            # determine default mode",
            "            if self.mode == \"P\":",
            "                self.load()",
            "                if self.palette:",
            "                    mode = self.palette.mode",
            "                else:",
            "                    mode = \"RGB\"",
            "            else:",
            "                return self.copy()",
            "",
            "        self.load()",
            "",
            "        if matrix:",
            "            # matrix conversion",
            "            if mode not in (\"L\", \"RGB\"):",
            "                raise ValueError(\"illegal conversion\")",
            "            im = self.im.convert_matrix(mode, matrix)",
            "            return self._new(im)",
            "",
            "        if mode == \"P\" and palette == ADAPTIVE:",
            "            im = self.im.quantize(colors)",
            "            return self._new(im)",
            "",
            "        # colorspace conversion",
            "        if dither is None:",
            "            dither = FLOYDSTEINBERG",
            "",
            "        # Use transparent conversion to promote from transparent color to an alpha channel.",
            "        if self.mode in (\"L\", \"RGB\") and mode == \"RGBA\" and \"transparency\" in self.info:",
            "            return self._new(self.im.convert_transparent(mode, self.info['transparency']))",
            "            ",
            "        try:",
            "            im = self.im.convert(mode, dither)",
            "        except ValueError:",
            "            try:",
            "                # normalize source image and try again",
            "                im = self.im.convert(getmodebase(self.mode))",
            "                im = im.convert(mode, dither)",
            "            except KeyError:",
            "                raise ValueError(\"illegal conversion\")",
            "",
            "        return self._new(im)",
            "",
            "    def quantize(self, colors=256, method=0, kmeans=0, palette=None):",
            "",
            "        # methods:",
            "        #    0 = median cut",
            "        #    1 = maximum coverage",
            "        #    2 = fast octree",
            "",
            "        # NOTE: this functionality will be moved to the extended",
            "        # quantizer interface in a later version of PIL.",
            "",
            "        self.load()",
            "",
            "        if palette:",
            "            # use palette from reference image",
            "            palette.load()",
            "            if palette.mode != \"P\":",
            "                raise ValueError(\"bad mode for palette image\")",
            "            if self.mode != \"RGB\" and self.mode != \"L\":",
            "                raise ValueError(",
            "                    \"only RGB or L mode images can be quantized to a palette\"",
            "                    )",
            "            im = self.im.convert(\"P\", 1, palette.im)",
            "            return self._makeself(im)",
            "",
            "        im = self.im.quantize(colors, method, kmeans)",
            "        return self._new(im)",
            "",
            "    def copy(self):",
            "        \"\"\"",
            "        Copies this image. Use this method if you wish to paste things",
            "        into an image, but still retain the original.",
            "",
            "        :rtype: :py:class:`~PIL.Image.Image`",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "        self.load()",
            "        im = self.im.copy()",
            "        return self._new(im)",
            "",
            "    def crop(self, box=None):",
            "        \"\"\"",
            "        Returns a rectangular region from this image. The box is a",
            "        4-tuple defining the left, upper, right, and lower pixel",
            "        coordinate.",
            "",
            "        This is a lazy operation.  Changes to the source image may or",
            "        may not be reflected in the cropped image.  To break the",
            "        connection, call the :py:meth:`~PIL.Image.Image.load` method on",
            "        the cropped copy.",
            "",
            "        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple.",
            "        :rtype: :py:class:`~PIL.Image.Image`",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if box is None:",
            "            return self.copy()",
            "",
            "        # lazy operation",
            "        return _ImageCrop(self, box)",
            "",
            "    def draft(self, mode, size):",
            "        \"\"\"",
            "        Configures the image file loader so it returns a version of the",
            "        image that as closely as possible matches the given mode and",
            "        size.  For example, you can use this method to convert a color",
            "        JPEG to greyscale while loading it, or to extract a 128x192",
            "        version from a PCD file.",
            "",
            "        Note that this method modifies the :py:class:`~PIL.Image.Image` object",
            "        in place.  If the image has already been loaded, this method has no",
            "        effect.",
            "",
            "        :param mode: The requested mode.",
            "        :param size: The requested size.",
            "        \"\"\"",
            "        pass",
            "",
            "    def _expand(self, xmargin, ymargin=None):",
            "        if ymargin is None:",
            "            ymargin = xmargin",
            "        self.load()",
            "        return self._new(self.im.expand(xmargin, ymargin, 0))",
            "",
            "    def filter(self, filter):",
            "        \"\"\"",
            "        Filters this image using the given filter.  For a list of",
            "        available filters, see the :py:mod:`~PIL.ImageFilter` module.",
            "",
            "        :param filter: Filter kernel.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.  \"\"\"",
            "",
            "        self.load()",
            "",
            "        if isinstance(filter, collections.Callable):",
            "            filter = filter()",
            "        if not hasattr(filter, \"filter\"):",
            "            raise TypeError(\"filter argument should be ImageFilter.Filter instance or class\")",
            "",
            "        if self.im.bands == 1:",
            "            return self._new(filter.filter(self.im))",
            "        # fix to handle multiband images since _imaging doesn't",
            "        ims = []",
            "        for c in range(self.im.bands):",
            "            ims.append(self._new(filter.filter(self.im.getband(c))))",
            "        return merge(self.mode, ims)",
            "",
            "    def getbands(self):",
            "        \"\"\"",
            "        Returns a tuple containing the name of each band in this image.",
            "        For example, **getbands** on an RGB image returns (\"R\", \"G\", \"B\").",
            "",
            "        :returns: A tuple containing band names.",
            "        :rtype: tuple",
            "        \"\"\"",
            "        return ImageMode.getmode(self.mode).bands",
            "",
            "    def getbbox(self):",
            "        \"\"\"",
            "        Calculates the bounding box of the non-zero regions in the",
            "        image.",
            "",
            "        :returns: The bounding box is returned as a 4-tuple defining the",
            "           left, upper, right, and lower pixel coordinate. If the image",
            "           is completely empty, this method returns None.",
            "",
            "        \"\"\"",
            "",
            "        self.load()",
            "        return self.im.getbbox()",
            "",
            "    def getcolors(self, maxcolors=256):",
            "        \"\"\"",
            "        Returns a list of colors used in this image.",
            "",
            "        :param maxcolors: Maximum number of colors.  If this number is",
            "           exceeded, this method returns None.  The default limit is",
            "           256 colors.",
            "        :returns: An unsorted list of (count, pixel) values.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.mode in (\"1\", \"L\", \"P\"):",
            "            h = self.im.histogram()",
            "            out = []",
            "            for i in range(256):",
            "                if h[i]:",
            "                    out.append((h[i], i))",
            "            if len(out) > maxcolors:",
            "                return None",
            "            return out",
            "        return self.im.getcolors(maxcolors)",
            "",
            "    def getdata(self, band = None):",
            "        \"\"\"",
            "        Returns the contents of this image as a sequence object",
            "        containing pixel values.  The sequence object is flattened, so",
            "        that values for line one follow directly after the values of",
            "        line zero, and so on.",
            "",
            "        Note that the sequence object returned by this method is an",
            "        internal PIL data type, which only supports certain sequence",
            "        operations.  To convert it to an ordinary sequence (e.g. for",
            "        printing), use **list(im.getdata())**.",
            "",
            "        :param band: What band to return.  The default is to return",
            "           all bands.  To return a single band, pass in the index",
            "           value (e.g. 0 to get the \"R\" band from an \"RGB\" image).",
            "        :returns: A sequence-like object.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if band is not None:",
            "            return self.im.getband(band)",
            "        return self.im # could be abused",
            "",
            "    def getextrema(self):",
            "        \"\"\"",
            "        Gets the the minimum and maximum pixel values for each band in",
            "        the image.",
            "",
            "        :returns: For a single-band image, a 2-tuple containing the",
            "           minimum and maximum pixel value.  For a multi-band image,",
            "           a tuple containing one 2-tuple for each band.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.im.bands > 1:",
            "            extrema = []",
            "            for i in range(self.im.bands):",
            "                extrema.append(self.im.getband(i).getextrema())",
            "            return tuple(extrema)",
            "        return self.im.getextrema()",
            "",
            "    def getim(self):",
            "        \"\"\"",
            "        Returns a capsule that points to the internal image memory.",
            "",
            "        :returns: A capsule object.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        return self.im.ptr",
            "",
            "",
            "    def getpalette(self):",
            "        \"\"\"",
            "        Returns the image palette as a list.",
            "",
            "        :returns: A list of color values [r, g, b, ...], or None if the",
            "           image has no palette.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        try:",
            "            if bytes is str:",
            "                return [i8(c) for c in self.im.getpalette()]",
            "            else:",
            "                return list(self.im.getpalette())",
            "        except ValueError:",
            "            return None # no palette",
            "",
            "",
            "    def getpixel(self, xy):",
            "        \"\"\"",
            "        Returns the pixel value at a given position.",
            "",
            "        :param xy: The coordinate, given as (x, y).",
            "        :returns: The pixel value.  If the image is a multi-layer image,",
            "           this method returns a tuple.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        return self.im.getpixel(xy)",
            "",
            "    def getprojection(self):",
            "        \"\"\"",
            "        Get projection to x and y axes",
            "",
            "        :returns: Two sequences, indicating where there are non-zero",
            "            pixels along the X-axis and the Y-axis, respectively.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        x, y = self.im.getprojection()",
            "        return [i8(c) for c in x], [i8(c) for c in y]",
            "",
            "    def histogram(self, mask=None, extrema=None):",
            "        \"\"\"",
            "        Returns a histogram for the image. The histogram is returned as",
            "        a list of pixel counts, one for each pixel value in the source",
            "        image. If the image has more than one band, the histograms for",
            "        all bands are concatenated (for example, the histogram for an",
            "        \"RGB\" image contains 768 values).",
            "",
            "        A bilevel image (mode \"1\") is treated as a greyscale (\"L\") image",
            "        by this method.",
            "",
            "        If a mask is provided, the method returns a histogram for those",
            "        parts of the image where the mask image is non-zero. The mask",
            "        image must have the same size as the image, and be either a",
            "        bi-level image (mode \"1\") or a greyscale image (\"L\").",
            "",
            "        :param mask: An optional mask.",
            "        :returns: A list containing pixel counts.",
            "        \"\"\"",
            "        self.load()",
            "        if mask:",
            "            mask.load()",
            "            return self.im.histogram((0, 0), mask.im)",
            "        if self.mode in (\"I\", \"F\"):",
            "            if extrema is None:",
            "                extrema = self.getextrema()",
            "            return self.im.histogram(extrema)",
            "        return self.im.histogram()",
            "",
            "    def offset(self, xoffset, yoffset=None):",
            "        \"\"\"",
            "        .. deprecated:: 2.0",
            "",
            "        .. note:: New code should use :py:func:`PIL.ImageChops.offset`.",
            "",
            "        Returns a copy of the image where the data has been offset by the given",
            "        distances. Data wraps around the edges. If **yoffset** is omitted, it",
            "        is assumed to be equal to **xoffset**.",
            "",
            "        :param xoffset: The horizontal distance.",
            "        :param yoffset: The vertical distance.  If omitted, both",
            "           distances are set to the same value.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "        if warnings:",
            "            warnings.warn(",
            "                \"'offset' is deprecated; use 'ImageChops.offset' instead\",",
            "                DeprecationWarning, stacklevel=2",
            "                )",
            "        from PIL import ImageChops",
            "        return ImageChops.offset(self, xoffset, yoffset)",
            "",
            "    def paste(self, im, box=None, mask=None):",
            "        \"\"\"",
            "        Pastes another image into this image. The box argument is either",
            "        a 2-tuple giving the upper left corner, a 4-tuple defining the",
            "        left, upper, right, and lower pixel coordinate, or None (same as",
            "        (0, 0)).  If a 4-tuple is given, the size of the pasted image",
            "        must match the size of the region.",
            "",
            "        If the modes don't match, the pasted image is converted to the mode of",
            "        this image (see the :py:meth:`~PIL.Image.Image.convert` method for",
            "        details).",
            "",
            "        Instead of an image, the source can be a integer or tuple",
            "        containing pixel values.  The method then fills the region",
            "        with the given color.  When creating RGB images, you can",
            "        also use color strings as supported by the ImageColor module.",
            "",
            "        If a mask is given, this method updates only the regions",
            "        indicated by the mask.  You can use either \"1\", \"L\" or \"RGBA\"",
            "        images (in the latter case, the alpha band is used as mask).",
            "        Where the mask is 255, the given image is copied as is.  Where",
            "        the mask is 0, the current value is preserved.  Intermediate",
            "        values can be used for transparency effects.",
            "",
            "        Note that if you paste an \"RGBA\" image, the alpha band is",
            "        ignored.  You can work around this by using the same image as",
            "        both source image and mask.",
            "",
            "        :param im: Source image or pixel value (integer or tuple).",
            "        :param box: An optional 4-tuple giving the region to paste into.",
            "           If a 2-tuple is used instead, it's treated as the upper left",
            "           corner.  If omitted or None, the source is pasted into the",
            "           upper left corner.",
            "",
            "           If an image is given as the second argument and there is no",
            "           third, the box defaults to (0, 0), and the second argument",
            "           is interpreted as a mask image.",
            "        :param mask: An optional mask image.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if isImageType(box) and mask is None:",
            "            # abbreviated paste(im, mask) syntax",
            "            mask = box; box = None",
            "",
            "        if box is None:",
            "            # cover all of self",
            "            box = (0, 0) + self.size",
            "",
            "        if len(box) == 2:",
            "            # lower left corner given; get size from image or mask",
            "            if isImageType(im):",
            "                size = im.size",
            "            elif isImageType(mask):",
            "                size = mask.size",
            "            else:",
            "                # FIXME: use self.size here?",
            "                raise ValueError(",
            "                    \"cannot determine region size; use 4-item box\"",
            "                    )",
            "            box = box + (box[0]+size[0], box[1]+size[1])",
            "",
            "        if isStringType(im):",
            "            from PIL import ImageColor",
            "            im = ImageColor.getcolor(im, self.mode)",
            "",
            "        elif isImageType(im):",
            "            im.load()",
            "            if self.mode != im.mode:",
            "                if self.mode != \"RGB\" or im.mode not in (\"RGBA\", \"RGBa\"):",
            "                    # should use an adapter for this!",
            "                    im = im.convert(self.mode)",
            "            im = im.im",
            "",
            "        self.load()",
            "        if self.readonly:",
            "            self._copy()",
            "",
            "        if mask:",
            "            mask.load()",
            "            self.im.paste(im, box, mask.im)",
            "        else:",
            "            self.im.paste(im, box)",
            "",
            "    def point(self, lut, mode=None):",
            "        \"\"\"",
            "        Maps this image through a lookup table or function.",
            "",
            "        :param lut: A lookup table, containing 256 (or 65336 if",
            "           self.mode==\"I\" and mode == \"L\") values per band in the",
            "           image.  A function can be used instead, it should take a",
            "           single argument. The function is called once for each",
            "           possible pixel value, and the resulting table is applied to",
            "           all bands of the image.",
            "        :param mode: Output mode (default is same as input).  In the",
            "           current version, this can only be used if the source image",
            "           has mode \"L\" or \"P\", and the output has mode \"1\" or the",
            "           source image mode is \"I\" and the output mode is \"L\".",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        self.load()",
            "",
            "        if isinstance(lut, ImagePointHandler):",
            "            return lut.point(self)",
            "",
            "        if callable(lut):",
            "            # if it isn't a list, it should be a function",
            "            if self.mode in (\"I\", \"I;16\", \"F\"):",
            "                # check if the function can be used with point_transform",
            "                # UNDONE wiredfool -- I think this prevents us from ever doing",
            "                # a gamma function point transform on > 8bit images. ",
            "                scale, offset = _getscaleoffset(lut)",
            "                return self._new(self.im.point_transform(scale, offset))",
            "            # for other modes, convert the function to a table",
            "            lut = [lut(i) for i in range(256)] * self.im.bands",
            "",
            "        if self.mode == \"F\":",
            "            # FIXME: _imaging returns a confusing error message for this case",
            "            raise ValueError(\"point operation not supported for this mode\")",
            "",
            "        return self._new(self.im.point(lut, mode))",
            "",
            "    def putalpha(self, alpha):",
            "        \"\"\"",
            "        Adds or replaces the alpha layer in this image.  If the image",
            "        does not have an alpha layer, it's converted to \"LA\" or \"RGBA\".",
            "        The new layer must be either \"L\" or \"1\".",
            "",
            "        :param alpha: The new alpha layer.  This can either be an \"L\" or \"1\"",
            "           image having the same size as this image, or an integer or",
            "           other color value.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.readonly:",
            "            self._copy()",
            "",
            "        if self.mode not in (\"LA\", \"RGBA\"):",
            "            # attempt to promote self to a matching alpha mode",
            "            try:",
            "                mode = getmodebase(self.mode) + \"A\"",
            "                try:",
            "                    self.im.setmode(mode)",
            "                except (AttributeError, ValueError):",
            "                    # do things the hard way",
            "                    im = self.im.convert(mode)",
            "                    if im.mode not in (\"LA\", \"RGBA\"):",
            "                        raise ValueError # sanity check",
            "                    self.im = im",
            "                self.mode = self.im.mode",
            "            except (KeyError, ValueError):",
            "                raise ValueError(\"illegal image mode\")",
            "",
            "        if self.mode == \"LA\":",
            "            band = 1",
            "        else:",
            "            band = 3",
            "",
            "        if isImageType(alpha):",
            "            # alpha layer",
            "            if alpha.mode not in (\"1\", \"L\"):",
            "                raise ValueError(\"illegal image mode\")",
            "            alpha.load()",
            "            if alpha.mode == \"1\":",
            "                alpha = alpha.convert(\"L\")",
            "        else:",
            "            # constant alpha",
            "            try:",
            "                self.im.fillband(band, alpha)",
            "            except (AttributeError, ValueError):",
            "                # do things the hard way",
            "                alpha = new(\"L\", self.size, alpha)",
            "            else:",
            "                return",
            "",
            "        self.im.putband(alpha.im, band)",
            "",
            "    def putdata(self, data, scale=1.0, offset=0.0):",
            "        \"\"\"",
            "        Copies pixel data to this image.  This method copies data from a",
            "        sequence object into the image, starting at the upper left",
            "        corner (0, 0), and continuing until either the image or the",
            "        sequence ends.  The scale and offset values are used to adjust",
            "        the sequence values: **pixel = value*scale + offset**.",
            "",
            "        :param data: A sequence object.",
            "        :param scale: An optional scale value.  The default is 1.0.",
            "        :param offset: An optional offset value.  The default is 0.0.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.readonly:",
            "            self._copy()",
            "",
            "        self.im.putdata(data, scale, offset)",
            "",
            "    def putpalette(self, data, rawmode=\"RGB\"):",
            "        \"\"\"",
            "        Attaches a palette to this image.  The image must be a \"P\" or",
            "        \"L\" image, and the palette sequence must contain 768 integer",
            "        values, where each group of three values represent the red,",
            "        green, and blue values for the corresponding pixel",
            "        index. Instead of an integer sequence, you can use an 8-bit",
            "        string.",
            "",
            "        :param data: A palette sequence (either a list or a string).",
            "        \"\"\"",
            "        from PIL import ImagePalette",
            "",
            "        if self.mode not in (\"L\", \"P\"):",
            "            raise ValueError(\"illegal image mode\")",
            "        self.load()",
            "        if isinstance(data, ImagePalette.ImagePalette):",
            "            palette = ImagePalette.raw(data.rawmode, data.palette)",
            "        else:",
            "            if not isinstance(data, bytes):",
            "                if bytes is str:",
            "                    data = \"\".join(chr(x) for x in data)",
            "                else:",
            "                    data = bytes(data)",
            "            palette = ImagePalette.raw(rawmode, data)",
            "        self.mode = \"P\"",
            "        self.palette = palette",
            "        self.palette.mode = \"RGB\"",
            "        self.load() # install new palette",
            "",
            "    def putpixel(self, xy, value):",
            "        \"\"\"",
            "        Modifies the pixel at the given position. The color is given as",
            "        a single numerical value for single-band images, and a tuple for",
            "        multi-band images.",
            "",
            "        Note that this method is relatively slow.  For more extensive changes,",
            "        use :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw`",
            "        module instead.",
            "",
            "        See:",
            "",
            "        * :py:meth:`~PIL.Image.Image.paste`",
            "        * :py:meth:`~PIL.Image.Image.putdata`",
            "        * :py:mod:`~PIL.ImageDraw`",
            "",
            "        :param xy: The pixel coordinate, given as (x, y).",
            "        :param value: The pixel value.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.readonly:",
            "            self._copy()",
            "",
            "        return self.im.putpixel(xy, value)",
            "",
            "    def resize(self, size, resample=NEAREST):",
            "        \"\"\"",
            "        Returns a resized copy of this image.",
            "",
            "        :param size: The requested size in pixels, as a 2-tuple:",
            "           (width, height).",
            "        :param filter: An optional resampling filter.  This can be",
            "           one of :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),",
            "           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2",
            "           environment), :py:attr:`PIL.Image.BICUBIC` (cubic spline",
            "           interpolation in a 4x4 environment), or",
            "           :py:attr:`PIL.Image.ANTIALIAS` (a high-quality downsampling filter).",
            "           If omitted, or if the image has mode \"1\" or \"P\", it is",
            "           set :py:attr:`PIL.Image.NEAREST`.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if resample not in (NEAREST, BILINEAR, BICUBIC, ANTIALIAS):",
            "            raise ValueError(\"unknown resampling filter\")",
            "",
            "        self.load()",
            "",
            "        if self.mode in (\"1\", \"P\"):",
            "            resample = NEAREST",
            "",
            "        if self.mode == 'RGBA':",
            "            return self.convert('RGBa').resize(size, resample).convert('RGBA')",
            "",
            "        if resample == ANTIALIAS:",
            "            # requires stretch support (imToolkit & PIL 1.1.3)",
            "            try:",
            "                im = self.im.stretch(size, resample)",
            "            except AttributeError:",
            "                raise ValueError(\"unsupported resampling filter\")",
            "        else:",
            "            im = self.im.resize(size, resample)",
            "",
            "        return self._new(im)",
            "",
            "    def rotate(self, angle, resample=NEAREST, expand=0):",
            "        \"\"\"",
            "        Returns a rotated copy of this image.  This method returns a",
            "        copy of this image, rotated the given number of degrees counter",
            "        clockwise around its centre.",
            "",
            "        :param angle: In degrees counter clockwise.",
            "        :param filter: An optional resampling filter.  This can be",
            "           one of :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),",
            "           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2",
            "           environment), or :py:attr:`PIL.Image.BICUBIC`",
            "           (cubic spline interpolation in a 4x4 environment).",
            "           If omitted, or if the image has mode \"1\" or \"P\", it is",
            "           set :py:attr:`PIL.Image.NEAREST`.",
            "        :param expand: Optional expansion flag.  If true, expands the output",
            "           image to make it large enough to hold the entire rotated image.",
            "           If false or omitted, make the output image the same size as the",
            "           input image.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if expand:",
            "            import math",
            "            angle = -angle * math.pi / 180",
            "            matrix = [",
            "                 math.cos(angle), math.sin(angle), 0.0,",
            "                -math.sin(angle), math.cos(angle), 0.0",
            "                 ]",
            "            def transform(x, y, matrix=matrix):",
            "                (a, b, c, d, e, f) = matrix",
            "                return a*x + b*y + c, d*x + e*y + f",
            "",
            "            # calculate output size",
            "            w, h = self.size",
            "            xx = []",
            "            yy = []",
            "            for x, y in ((0, 0), (w, 0), (w, h), (0, h)):",
            "                x, y = transform(x, y)",
            "                xx.append(x)",
            "                yy.append(y)",
            "            w = int(math.ceil(max(xx)) - math.floor(min(xx)))",
            "            h = int(math.ceil(max(yy)) - math.floor(min(yy)))",
            "",
            "            # adjust center",
            "            x, y = transform(w / 2.0, h / 2.0)",
            "            matrix[2] = self.size[0] / 2.0 - x",
            "            matrix[5] = self.size[1] / 2.0 - y",
            "",
            "            return self.transform((w, h), AFFINE, matrix, resample)",
            "",
            "        if resample not in (NEAREST, BILINEAR, BICUBIC):",
            "            raise ValueError(\"unknown resampling filter\")",
            "",
            "        self.load()",
            "",
            "        if self.mode in (\"1\", \"P\"):",
            "            resample = NEAREST",
            "",
            "        return self._new(self.im.rotate(angle, resample))",
            "",
            "    def save(self, fp, format=None, **params):",
            "        \"\"\"",
            "        Saves this image under the given filename.  If no format is",
            "        specified, the format to use is determined from the filename",
            "        extension, if possible.",
            "",
            "        Keyword options can be used to provide additional instructions",
            "        to the writer. If a writer doesn't recognise an option, it is",
            "        silently ignored. The available options are described later in",
            "        this handbook.",
            "",
            "        You can use a file object instead of a filename. In this case,",
            "        you must always specify the format. The file object must",
            "        implement the **seek**, **tell**, and **write**",
            "        methods, and be opened in binary mode.",
            "",
            "        :param file: File name or file object.",
            "        :param format: Optional format override.  If omitted, the",
            "           format to use is determined from the filename extension.",
            "           If a file object was used instead of a filename, this",
            "           parameter should always be used.",
            "        :param options: Extra parameters to the image writer.",
            "        :returns: None",
            "        :exception KeyError: If the output format could not be determined",
            "           from the file name.  Use the format option to solve this.",
            "        :exception IOError: If the file could not be written.  The file",
            "           may have been created, and may contain partial data.",
            "        \"\"\"",
            "",
            "        if isPath(fp):",
            "            filename = fp",
            "        else:",
            "            if hasattr(fp, \"name\") and isPath(fp.name):",
            "                filename = fp.name",
            "            else:",
            "                filename = \"\"",
            "",
            "        # may mutate self!",
            "        self.load()",
            "",
            "        self.encoderinfo = params",
            "        self.encoderconfig = ()",
            "",
            "        preinit()",
            "",
            "        ext = os.path.splitext(filename)[1].lower()",
            "",
            "        if not format:",
            "            try:",
            "                format = EXTENSION[ext]",
            "            except KeyError:",
            "                init()",
            "                try:",
            "                    format = EXTENSION[ext]",
            "                except KeyError:",
            "                    raise KeyError(ext) # unknown extension",
            "",
            "        try:",
            "            save_handler = SAVE[format.upper()]",
            "        except KeyError:",
            "            init()",
            "            save_handler = SAVE[format.upper()] # unknown format",
            "",
            "        if isPath(fp):",
            "            fp = builtins.open(fp, \"wb\")",
            "            close = 1",
            "        else:",
            "            close = 0",
            "",
            "        try:",
            "            save_handler(self, fp, filename)",
            "        finally:",
            "            # do what we can to clean up",
            "            if close:",
            "                fp.close()",
            "",
            "    def seek(self, frame):",
            "        \"\"\"",
            "        Seeks to the given frame in this sequence file. If you seek",
            "        beyond the end of the sequence, the method raises an",
            "        **EOFError** exception. When a sequence file is opened, the",
            "        library automatically seeks to frame 0.",
            "",
            "        Note that in the current version of the library, most sequence",
            "        formats only allows you to seek to the next frame.",
            "",
            "        See :py:meth:`~PIL.Image.Image.tell`.",
            "",
            "        :param frame: Frame number, starting at 0.",
            "        :exception EOFError: If the call attempts to seek beyond the end",
            "            of the sequence.",
            "        \"\"\"",
            "",
            "        # overridden by file handlers",
            "        if frame != 0:",
            "            raise EOFError",
            "",
            "    def show(self, title=None, command=None):",
            "        \"\"\"",
            "        Displays this image. This method is mainly intended for",
            "        debugging purposes.",
            "",
            "        On Unix platforms, this method saves the image to a temporary",
            "        PPM file, and calls the **xv** utility.",
            "",
            "        On Windows, it saves the image to a temporary BMP file, and uses",
            "        the standard BMP display utility to show it (usually Paint).",
            "",
            "        :param title: Optional title to use for the image window,",
            "           where possible.",
            "        :param command: command used to show the image",
            "        \"\"\"",
            "",
            "        _show(self, title=title, command=command)",
            "",
            "    def split(self):",
            "        \"\"\"",
            "        Split this image into individual bands. This method returns a",
            "        tuple of individual image bands from an image. For example,",
            "        splitting an \"RGB\" image creates three new images each",
            "        containing a copy of one of the original bands (red, green,",
            "        blue).",
            "",
            "        :returns: A tuple containing bands.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.im.bands == 1:",
            "            ims = [self.copy()]",
            "        else:",
            "            ims = []",
            "            for i in range(self.im.bands):",
            "                ims.append(self._new(self.im.getband(i)))",
            "        return tuple(ims)",
            "",
            "    def tell(self):",
            "        \"\"\"",
            "        Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`.",
            "",
            "        :returns: Frame number, starting with 0.",
            "        \"\"\"",
            "        return 0",
            "",
            "    def thumbnail(self, size, resample=NEAREST):",
            "        \"\"\"",
            "        Make this image into a thumbnail.  This method modifies the",
            "        image to contain a thumbnail version of itself, no larger than",
            "        the given size.  This method calculates an appropriate thumbnail",
            "        size to preserve the aspect of the image, calls the",
            "        :py:meth:`~PIL.Image.Image.draft` method to configure the file reader",
            "        (where applicable), and finally resizes the image.",
            "",
            "        Note that the bilinear and bicubic filters in the current",
            "        version of PIL are not well-suited for thumbnail generation.",
            "        You should use :py:attr:`PIL.Image.ANTIALIAS` unless speed is much more",
            "        important than quality.",
            "",
            "        Also note that this function modifies the :py:class:`~PIL.Image.Image`",
            "        object in place.  If you need to use the full resolution image as well, apply",
            "        this method to a :py:meth:`~PIL.Image.Image.copy` of the original image.",
            "",
            "        :param size: Requested size.",
            "        :param resample: Optional resampling filter.  This can be one",
            "           of :py:attr:`PIL.Image.NEAREST`, :py:attr:`PIL.Image.BILINEAR`,",
            "           :py:attr:`PIL.Image.BICUBIC`, or :py:attr:`PIL.Image.ANTIALIAS`",
            "           (best quality).  If omitted, it defaults to",
            "           :py:attr:`PIL.Image.NEAREST` (this will be changed to ANTIALIAS in a",
            "           future version).",
            "        :returns: None",
            "        \"\"\"",
            "",
            "        # FIXME: the default resampling filter will be changed",
            "        # to ANTIALIAS in future versions",
            "",
            "        # preserve aspect ratio",
            "        x, y = self.size",
            "        if x > size[0]: y = int(max(y * size[0] / x, 1)); x = int(size[0])",
            "        if y > size[1]: x = int(max(x * size[1] / y, 1)); y = int(size[1])",
            "        size = x, y",
            "",
            "        if size == self.size:",
            "            return",
            "",
            "        self.draft(None, size)",
            "",
            "        self.load()",
            "",
            "        try:",
            "            im = self.resize(size, resample)",
            "        except ValueError:",
            "            if resample != ANTIALIAS:",
            "                raise",
            "            im = self.resize(size, NEAREST) # fallback",
            "",
            "        self.im = im.im",
            "        self.mode = im.mode",
            "        self.size = size",
            "",
            "        self.readonly = 0",
            "",
            "    # FIXME: the different tranform methods need further explanation",
            "    # instead of bloating the method docs, add a separate chapter.",
            "    def transform(self, size, method, data=None, resample=NEAREST, fill=1):",
            "        \"\"\"",
            "        Transforms this image.  This method creates a new image with the",
            "        given size, and the same mode as the original, and copies data",
            "        to the new image using the given transform.",
            "",
            "        :param size: The output size.",
            "        :param method: The transformation method.  This is one of",
            "          :py:attr:`PIL.Image.EXTENT` (cut out a rectangular subregion),",
            "          :py:attr:`PIL.Image.AFFINE` (affine transform),",
            "          :py:attr:`PIL.Image.PERSPECTIVE` (perspective transform),",
            "          :py:attr:`PIL.Image.QUAD` (map a quadrilateral to a rectangle), or",
            "          :py:attr:`PIL.Image.MESH` (map a number of source quadrilaterals",
            "          in one operation).",
            "        :param data: Extra data to the transformation method.",
            "        :param resample: Optional resampling filter.  It can be one of",
            "           :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),",
            "           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2",
            "           environment), or :py:attr:`PIL.Image.BICUBIC` (cubic spline",
            "           interpolation in a 4x4 environment). If omitted, or if the image",
            "           has mode \"1\" or \"P\", it is set to :py:attr:`PIL.Image.NEAREST`.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if self.mode == 'RGBA':",
            "            return self.convert('RGBa').transform(size, method, data, resample, fill).convert('RGBA')",
            "",
            "        if isinstance(method, ImageTransformHandler):",
            "            return method.transform(size, self, resample=resample, fill=fill)",
            "        if hasattr(method, \"getdata\"):",
            "            # compatibility w. old-style transform objects",
            "            method, data = method.getdata()",
            "        if data is None:",
            "            raise ValueError(\"missing method data\")",
            "",
            "        im = new(self.mode, size, None)",
            "        if method == MESH:",
            "            # list of quads",
            "            for box, quad in data:",
            "                im.__transformer(box, self, QUAD, quad, resample, fill)",
            "        else:",
            "            im.__transformer((0, 0)+size, self, method, data, resample, fill)",
            "",
            "        return im",
            "",
            "    def __transformer(self, box, image, method, data,",
            "                      resample=NEAREST, fill=1):",
            "",
            "        # FIXME: this should be turned into a lazy operation (?)",
            "",
            "        w = box[2]-box[0]",
            "        h = box[3]-box[1]",
            "",
            "        if method == AFFINE:",
            "            # change argument order to match implementation",
            "            data = (data[2], data[0], data[1],",
            "                    data[5], data[3], data[4])",
            "        elif method == EXTENT:",
            "            # convert extent to an affine transform",
            "            x0, y0, x1, y1 = data",
            "            xs = float(x1 - x0) / w",
            "            ys = float(y1 - y0) / h",
            "            method = AFFINE",
            "            data = (x0 + xs/2, xs, 0, y0 + ys/2, 0, ys)",
            "        elif method == PERSPECTIVE:",
            "            # change argument order to match implementation",
            "            data = (data[2], data[0], data[1],",
            "                    data[5], data[3], data[4],",
            "                    data[6], data[7])",
            "        elif method == QUAD:",
            "            # quadrilateral warp.  data specifies the four corners",
            "            # given as NW, SW, SE, and NE.",
            "            nw = data[0:2]; sw = data[2:4]; se = data[4:6]; ne = data[6:8]",
            "            x0, y0 = nw; As = 1.0 / w; At = 1.0 / h",
            "            data = (x0, (ne[0]-x0)*As, (sw[0]-x0)*At,",
            "                    (se[0]-sw[0]-ne[0]+x0)*As*At,",
            "                    y0, (ne[1]-y0)*As, (sw[1]-y0)*At,",
            "                    (se[1]-sw[1]-ne[1]+y0)*As*At)",
            "        else:",
            "            raise ValueError(\"unknown transformation method\")",
            "",
            "        if resample not in (NEAREST, BILINEAR, BICUBIC):",
            "            raise ValueError(\"unknown resampling filter\")",
            "",
            "        image.load()",
            "",
            "        self.load()",
            "",
            "        if image.mode in (\"1\", \"P\"):",
            "            resample = NEAREST",
            "",
            "        self.im.transform2(box, image.im, method, data, resample, fill)",
            "",
            "    def transpose(self, method):",
            "        \"\"\"",
            "        Transpose image (flip or rotate in 90 degree steps)",
            "",
            "        :param method: One of :py:attr:`PIL.Image.FLIP_LEFT_RIGHT`,",
            "          :py:attr:`PIL.Image.FLIP_TOP_BOTTOM`, :py:attr:`PIL.Image.ROTATE_90`,",
            "          :py:attr:`PIL.Image.ROTATE_180`, or :py:attr:`PIL.Image.ROTATE_270`.",
            "        :returns: Returns a flipped or rotated copy of this image.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        im = self.im.transpose(method)",
            "        return self._new(im)",
            "",
            "# --------------------------------------------------------------------",
            "# Lazy operations",
            "",
            "class _ImageCrop(Image):",
            "",
            "    def __init__(self, im, box):",
            "",
            "        Image.__init__(self)",
            "",
            "        x0, y0, x1, y1 = box",
            "        if x1 < x0:",
            "            x1 = x0",
            "        if y1 < y0:",
            "            y1 = y0",
            "",
            "        self.mode = im.mode",
            "        self.size = x1-x0, y1-y0",
            "",
            "        self.__crop = x0, y0, x1, y1",
            "",
            "        self.im = im.im",
            "",
            "    def load(self):",
            "",
            "        # lazy evaluation!",
            "        if self.__crop:",
            "            self.im = self.im.crop(self.__crop)",
            "            self.__crop = None",
            "",
            "        if self.im:",
            "            return self.im.pixel_access(self.readonly)",
            "",
            "        # FIXME: future versions should optimize crop/paste",
            "        # sequences!",
            "",
            "# --------------------------------------------------------------------",
            "# Abstract handlers.",
            "",
            "class ImagePointHandler:",
            "    # used as a mixin by point transforms (for use with im.point)",
            "    pass",
            "",
            "class ImageTransformHandler:",
            "    # used as a mixin by geometry transforms (for use with im.transform)",
            "    pass",
            "",
            "# --------------------------------------------------------------------",
            "# Factories",
            "",
            "#",
            "# Debugging",
            "",
            "def _wedge():",
            "    \"Create greyscale wedge (for debugging only)\"",
            "",
            "    return Image()._new(core.wedge(\"L\"))",
            "",
            "",
            "def new(mode, size, color=0):",
            "    \"\"\"",
            "    Creates a new image with the given mode and size.",
            "",
            "    :param mode: The mode to use for the new image.",
            "    :param size: A 2-tuple, containing (width, height) in pixels.",
            "    :param color: What color to use for the image.  Default is black.",
            "       If given, this should be a single integer or floating point value",
            "       for single-band modes, and a tuple for multi-band modes (one value",
            "       per band).  When creating RGB images, you can also use color",
            "       strings as supported by the ImageColor module.  If the color is",
            "       None, the image is not initialised.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    if color is None:",
            "        # don't initialize",
            "        return Image()._new(core.new(mode, size))",
            "",
            "    if isStringType(color):",
            "        # css3-style specifier",
            "",
            "        from PIL import ImageColor",
            "        color = ImageColor.getcolor(color, mode)",
            "",
            "    return Image()._new(core.fill(mode, size, color))",
            "",
            "",
            "def frombytes(mode, size, data, decoder_name=\"raw\", *args):",
            "    \"\"\"",
            "    Creates a copy of an image memory from pixel data in a buffer.",
            "",
            "    In its simplest form, this function takes three arguments",
            "    (mode, size, and unpacked pixel data).",
            "",
            "    You can also use any pixel decoder supported by PIL.  For more",
            "    information on available decoders, see the section",
            "    **Writing Your Own File Decoder**.",
            "",
            "    Note that this function decodes pixel data only, not entire images.",
            "    If you have an entire image in a string, wrap it in a",
            "    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load",
            "    it.",
            "",
            "    :param mode: The image mode.",
            "    :param size: The image size.",
            "    :param data: A byte buffer containing raw data for the given mode.",
            "    :param decoder_name: What decoder to use.",
            "    :param args: Additional parameters for the given decoder.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    # may pass tuple instead of argument list",
            "    if len(args) == 1 and isinstance(args[0], tuple):",
            "        args = args[0]",
            "",
            "    if decoder_name == \"raw\" and args == ():",
            "        args = mode",
            "",
            "    im = new(mode, size)",
            "    im.frombytes(data, decoder_name, args)",
            "    return im",
            "",
            "def fromstring(*args, **kw):",
            "    \"\"\"Deprecated alias to frombytes.",
            "",
            "    .. deprecated:: 2.0",
            "    \"\"\"",
            "    warnings.warn(",
            "        'fromstring() is deprecated. Please call frombytes() instead.',",
            "        DeprecationWarning,",
            "        stacklevel=2",
            "    )",
            "    return frombytes(*args, **kw)",
            "",
            "",
            "def frombuffer(mode, size, data, decoder_name=\"raw\", *args):",
            "    \"\"\"",
            "    Creates an image memory referencing pixel data in a byte buffer.",
            "",
            "    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data",
            "    in the byte buffer, where possible.  This means that changes to the",
            "    original buffer object are reflected in this image).  Not all modes can",
            "    share memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".",
            "",
            "    Note that this function decodes pixel data only, not entire images.",
            "    If you have an entire image file in a string, wrap it in a",
            "    **BytesIO** object, and use :py:func:`~PIL.Image.open` to load it.",
            "",
            "    In the current version, the default parameters used for the \"raw\" decoder",
            "    differs from that used for :py:func:`~PIL.Image.fromstring`.  This is a",
            "    bug, and will probably be fixed in a future release.  The current release",
            "    issues a warning if you do this; to disable the warning, you should provide",
            "    the full set of parameters.  See below for details.",
            "",
            "    :param mode: The image mode.",
            "    :param size: The image size.",
            "    :param data: A bytes or other buffer object containing raw",
            "        data for the given mode.",
            "    :param decoder_name: What decoder to use.",
            "    :param args: Additional parameters for the given decoder.  For the",
            "        default encoder (\"raw\"), it's recommended that you provide the",
            "        full set of parameters::",
            "",
            "            frombuffer(mode, size, data, \"raw\", mode, 0, 1)",
            "",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "",
            "    .. versionadded:: 1.1.4",
            "    \"\"\"",
            "    \"Load image from bytes or buffer\"",
            "",
            "    # may pass tuple instead of argument list",
            "    if len(args) == 1 and isinstance(args[0], tuple):",
            "        args = args[0]",
            "",
            "    if decoder_name == \"raw\":",
            "        if args == ():",
            "            if warnings:",
            "                warnings.warn(",
            "                    \"the frombuffer defaults may change in a future release; \"",
            "                    \"for portability, change the call to read:\\n\"",
            "                    \"  frombuffer(mode, size, data, 'raw', mode, 0, 1)\",",
            "                    RuntimeWarning, stacklevel=2",
            "                )",
            "            args = mode, 0, -1 # may change to (mode, 0, 1) post-1.1.6",
            "        if args[0] in _MAPMODES:",
            "            im = new(mode, (1,1))",
            "            im = im._new(",
            "                core.map_buffer(data, size, decoder_name, None, 0, args)",
            "                )",
            "            im.readonly = 1",
            "            return im",
            "",
            "    return frombytes(mode, size, data, decoder_name, args)",
            "",
            "",
            "def fromarray(obj, mode=None):",
            "    \"\"\"",
            "    Creates an image memory from an object exporting the array interface",
            "    (using the buffer protocol).",
            "",
            "    If obj is not contiguous, then the tobytes method is called",
            "    and :py:func:`~PIL.Image.frombuffer` is used.",
            "",
            "    :param obj: Object with array interface",
            "    :param mode: Mode to use (will be determined from type if None)",
            "    :returns: An image memory.",
            "",
            "    .. versionadded:: 1.1.6",
            "    \"\"\"",
            "    arr = obj.__array_interface__",
            "    shape = arr['shape']",
            "    ndim = len(shape)",
            "    try:",
            "        strides = arr['strides']",
            "    except KeyError:",
            "        strides = None",
            "    if mode is None:",
            "        try:",
            "            typekey = (1, 1) + shape[2:], arr['typestr']",
            "            mode, rawmode = _fromarray_typemap[typekey]",
            "        except KeyError:",
            "            # print typekey",
            "            raise TypeError(\"Cannot handle this data type\")",
            "    else:",
            "        rawmode = mode",
            "    if mode in [\"1\", \"L\", \"I\", \"P\", \"F\"]:",
            "        ndmax = 2",
            "    elif mode == \"RGB\":",
            "        ndmax = 3",
            "    else:",
            "        ndmax = 4",
            "    if ndim > ndmax:",
            "        raise ValueError(\"Too many dimensions.\")",
            "",
            "    size = shape[1], shape[0]",
            "    if strides is not None:",
            "        if hasattr(obj, 'tobytes'):",
            "            obj = obj.tobytes()",
            "        else:",
            "            obj = obj.tostring()",
            "",
            "    return frombuffer(mode, size, obj, \"raw\", rawmode, 0, 1)",
            "",
            "_fromarray_typemap = {",
            "    # (shape, typestr) => mode, rawmode",
            "    # first two members of shape are set to one",
            "    # ((1, 1), \"|b1\"): (\"1\", \"1\"), # broken",
            "    ((1, 1), \"|u1\"): (\"L\", \"L\"),",
            "    ((1, 1), \"|i1\"): (\"I\", \"I;8\"),",
            "    ((1, 1), \"<i2\"): (\"I\", \"I;16\"),",
            "    ((1, 1), \">i2\"): (\"I\", \"I;16B\"),",
            "    ((1, 1), \"<i4\"): (\"I\", \"I;32\"),",
            "    ((1, 1), \">i4\"): (\"I\", \"I;32B\"),",
            "    ((1, 1), \"<f4\"): (\"F\", \"F;32F\"),",
            "    ((1, 1), \">f4\"): (\"F\", \"F;32BF\"),",
            "    ((1, 1), \"<f8\"): (\"F\", \"F;64F\"),",
            "    ((1, 1), \">f8\"): (\"F\", \"F;64BF\"),",
            "    ((1, 1, 3), \"|u1\"): (\"RGB\", \"RGB\"),",
            "    ((1, 1, 4), \"|u1\"): (\"RGBA\", \"RGBA\"),",
            "    }",
            "",
            "# shortcuts",
            "_fromarray_typemap[((1, 1), _ENDIAN + \"i4\")] = (\"I\", \"I\")",
            "_fromarray_typemap[((1, 1), _ENDIAN + \"f4\")] = (\"F\", \"F\")",
            "",
            "",
            "def open(fp, mode=\"r\"):",
            "    \"\"\"",
            "    Opens and identifies the given image file.",
            "",
            "    This is a lazy operation; this function identifies the file, but the",
            "    actual image data is not read from the file until you try to process",
            "    the data (or call the :py:meth:`~PIL.Image.Image.load` method).",
            "    See :py:func:`~PIL.Image.new`.",
            "",
            "    :param file: A filename (string) or a file object.  The file object",
            "       must implement :py:meth:`~file.read`, :py:meth:`~file.seek`, and",
            "       :py:meth:`~file.tell` methods, and be opened in binary mode.",
            "    :param mode: The mode.  If given, this argument must be \"r\".",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    :exception IOError: If the file cannot be found, or the image cannot be",
            "       opened and identified.",
            "    \"\"\"",
            "",
            "    if mode != \"r\":",
            "        raise ValueError(\"bad mode\")",
            "",
            "    if isPath(fp):",
            "        filename = fp",
            "        fp = builtins.open(fp, \"rb\")",
            "    else:",
            "        filename = \"\"",
            "",
            "    prefix = fp.read(16)",
            "",
            "    preinit()",
            "",
            "    for i in ID:",
            "        try:",
            "            factory, accept = OPEN[i]",
            "            if not accept or accept(prefix):",
            "                fp.seek(0)",
            "                return factory(fp, filename)",
            "        except (SyntaxError, IndexError, TypeError):",
            "            #import traceback",
            "            #traceback.print_exc()",
            "            pass",
            "",
            "    if init():",
            "",
            "        for i in ID:",
            "            try:",
            "                factory, accept = OPEN[i]",
            "                if not accept or accept(prefix):",
            "                    fp.seek(0)",
            "                    return factory(fp, filename)",
            "            except (SyntaxError, IndexError, TypeError):",
            "                #import traceback",
            "                #traceback.print_exc()",
            "                pass",
            "",
            "    raise IOError(\"cannot identify image file\")",
            "",
            "#",
            "# Image processing.",
            "",
            "def alpha_composite(im1, im2):",
            "    \"\"\"",
            "    Alpha composite im2 over im1.",
            "",
            "    :param im1: The first image.",
            "    :param im2: The second image.  Must have the same mode and size as",
            "       the first image.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    im1.load()",
            "    im2.load()",
            "    return im1._new(core.alpha_composite(im1.im, im2.im))",
            "",
            "",
            "def blend(im1, im2, alpha):",
            "    \"\"\"",
            "    Creates a new image by interpolating between two input images, using",
            "    a constant alpha.::",
            "",
            "        out = image1 * (1.0 - alpha) + image2 * alpha",
            "",
            "    :param im1: The first image.",
            "    :param im2: The second image.  Must have the same mode and size as",
            "       the first image.",
            "    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a",
            "       copy of the first image is returned. If alpha is 1.0, a copy of",
            "       the second image is returned. There are no restrictions on the",
            "       alpha value. If necessary, the result is clipped to fit into",
            "       the allowed output range.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    im1.load()",
            "    im2.load()",
            "    return im1._new(core.blend(im1.im, im2.im, alpha))",
            "",
            "",
            "def composite(image1, image2, mask):",
            "    \"\"\"",
            "    Create composite image by blending images using a transparency mask.",
            "",
            "    :param image1: The first image.",
            "    :param image2: The second image.  Must have the same mode and",
            "       size as the first image.",
            "    :param mask: A mask image.  This image can can have mode",
            "       \"1\", \"L\", or \"RGBA\", and must have the same size as the",
            "       other two images.",
            "    \"\"\"",
            "",
            "    image = image2.copy()",
            "    image.paste(image1, None, mask)",
            "    return image",
            "",
            "",
            "def eval(image, *args):",
            "    \"\"\"",
            "    Applies the function (which should take one argument) to each pixel",
            "    in the given image. If the image has more than one band, the same",
            "    function is applied to each band. Note that the function is",
            "    evaluated once for each possible pixel value, so you cannot use",
            "    random components or other generators.",
            "",
            "    :param image: The input image.",
            "    :param function: A function object, taking one integer argument.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    return image.point(args[0])",
            "",
            "",
            "def merge(mode, bands):",
            "    \"\"\"",
            "    Merge a set of single band images into a new multiband image.",
            "",
            "    :param mode: The mode to use for the output image.",
            "    :param bands: A sequence containing one single-band image for",
            "        each band in the output image.  All bands must have the",
            "        same size.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    if getmodebands(mode) != len(bands) or \"*\" in mode:",
            "        raise ValueError(\"wrong number of bands\")",
            "    for im in bands[1:]:",
            "        if im.mode != getmodetype(mode):",
            "            raise ValueError(\"mode mismatch\")",
            "        if im.size != bands[0].size:",
            "            raise ValueError(\"size mismatch\")",
            "    im = core.new(mode, bands[0].size)",
            "    for i in range(getmodebands(mode)):",
            "        bands[i].load()",
            "        im.putband(bands[i].im, i)",
            "    return bands[0]._new(im)",
            "",
            "# --------------------------------------------------------------------",
            "# Plugin registry",
            "",
            "def register_open(id, factory, accept=None):",
            "    \"\"\"",
            "    Register an image file plugin.  This function should not be used",
            "    in application code.",
            "",
            "    :param id: An image format identifier.",
            "    :param factory: An image file factory method.",
            "    :param accept: An optional function that can be used to quickly",
            "       reject images having another format.",
            "    \"\"\"",
            "    id = id.upper()",
            "    ID.append(id)",
            "    OPEN[id] = factory, accept",
            "",
            "",
            "def register_mime(id, mimetype):",
            "    \"\"\"",
            "    Registers an image MIME type.  This function should not be used",
            "    in application code.",
            "",
            "    :param id: An image format identifier.",
            "    :param mimetype: The image MIME type for this format.",
            "    \"\"\"",
            "    MIME[id.upper()] = mimetype",
            "",
            "",
            "def register_save(id, driver):",
            "    \"\"\"",
            "    Registers an image save function.  This function should not be",
            "    used in application code.",
            "",
            "    :param id: An image format identifier.",
            "    :param driver: A function to save images in this format.",
            "    \"\"\"",
            "    SAVE[id.upper()] = driver",
            "",
            "",
            "def register_extension(id, extension):",
            "    \"\"\"",
            "    Registers an image extension.  This function should not be",
            "    used in application code.",
            "",
            "    :param id: An image format identifier.",
            "    :param extension: An extension used for this format.",
            "    \"\"\"",
            "    EXTENSION[extension.lower()] = id.upper()",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# Simple display support.  User code may override this.",
            "",
            "def _show(image, **options):",
            "    # override me, as necessary",
            "    _showxv(image, **options)",
            "",
            "def _showxv(image, title=None, **options):",
            "    from PIL import ImageShow",
            "    ImageShow.show(image, title, **options)"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# the Image class wrapper",
            "#",
            "# partial release history:",
            "# 1995-09-09 fl   Created",
            "# 1996-03-11 fl   PIL release 0.0 (proof of concept)",
            "# 1996-04-30 fl   PIL release 0.1b1",
            "# 1999-07-28 fl   PIL release 1.0 final",
            "# 2000-06-07 fl   PIL release 1.1",
            "# 2000-10-20 fl   PIL release 1.1.1",
            "# 2001-05-07 fl   PIL release 1.1.2",
            "# 2002-03-15 fl   PIL release 1.1.3",
            "# 2003-05-10 fl   PIL release 1.1.4",
            "# 2005-03-28 fl   PIL release 1.1.5",
            "# 2006-12-02 fl   PIL release 1.1.6",
            "# 2009-11-15 fl   PIL release 1.1.7",
            "#",
            "# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.",
            "# Copyright (c) 1995-2009 by Fredrik Lundh.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "from __future__ import print_function",
            "",
            "from PIL import VERSION, PILLOW_VERSION, _plugins",
            "",
            "import warnings",
            "",
            "class _imaging_not_installed:",
            "    # module placeholder",
            "    def __getattr__(self, id):",
            "        raise ImportError(\"The _imaging C module is not installed\")",
            "",
            "try:",
            "    # give Tk a chance to set up the environment, in case we're",
            "    # using an _imaging module linked against libtcl/libtk (use",
            "    # __import__ to hide this from naive packagers; we don't really",
            "    # depend on Tk unless ImageTk is used, and that module already",
            "    # imports Tkinter)",
            "    __import__(\"FixTk\")",
            "except ImportError:",
            "    pass",
            "",
            "try:",
            "    # If the _imaging C module is not present, you can still use",
            "    # the \"open\" function to identify files, but you cannot load",
            "    # them.  Note that other modules should not refer to _imaging",
            "    # directly; import Image and use the Image.core variable instead.",
            "    from PIL import _imaging as core",
            "    if PILLOW_VERSION != getattr(core, 'PILLOW_VERSION', None):",
            "         raise ImportError(\"The _imaging extension was built for another \"",
            "                            \" version of Pillow or PIL\")",
            "",
            "except ImportError as v:",
            "    core = _imaging_not_installed()",
            "    # Explanations for ways that we know we might have an import error",
            "    if str(v).startswith(\"Module use of python\"):",
            "        # The _imaging C module is present, but not compiled for",
            "        # the right version (windows only).  Print a warning, if",
            "        # possible.",
            "        warnings.warn(",
            "            \"The _imaging extension was built for another version \"",
            "            \"of Python.\",",
            "            RuntimeWarning",
            "            )",
            "    elif str(v).startswith(\"The _imaging extension\"):",
            "        warnings.warn(str(v), RuntimeWarning)",
            "    elif \"Symbol not found: _PyUnicodeUCS2_FromString\" in str(v):",
            "        warnings.warn(",
            "            \"The _imaging extension was built for Python with UCS2 support; \"",
            "            \"recompile PIL or build Python --without-wide-unicode. \",",
            "            RuntimeWarning",
            "            )",
            "    elif \"Symbol not found: _PyUnicodeUCS4_FromString\" in str(v):",
            "        warnings.warn(",
            "            \"The _imaging extension was built for Python with UCS4 support; \"",
            "            \"recompile PIL or build Python --with-wide-unicode. \",",
            "            RuntimeWarning",
            "            )",
            "    # Fail here anyway. Don't let people run with a mostly broken Pillow.",
            "    raise",
            "",
            "try:",
            "    import builtins",
            "except ImportError:",
            "    import __builtin__",
            "    builtins = __builtin__",
            "",
            "from PIL import ImageMode",
            "from PIL._binary import i8, o8",
            "from PIL._util import isPath, isStringType",
            "",
            "import os, sys",
            "",
            "# type stuff",
            "import collections",
            "import numbers",
            "",
            "",
            "def isImageType(t):",
            "    \"\"\"",
            "    Checks if an object is an image object.",
            "",
            "    .. warning::",
            "",
            "       This function is for internal use only.",
            "",
            "    :param t: object to check if it's an image",
            "    :returns: True if the object is an image",
            "    \"\"\"",
            "    return hasattr(t, \"im\")",
            "",
            "#",
            "# Debug level",
            "",
            "DEBUG = 0",
            "",
            "#",
            "# Constants (also defined in _imagingmodule.c!)",
            "",
            "NONE = 0",
            "",
            "# transpose",
            "FLIP_LEFT_RIGHT = 0",
            "FLIP_TOP_BOTTOM = 1",
            "ROTATE_90 = 2",
            "ROTATE_180 = 3",
            "ROTATE_270 = 4",
            "",
            "# transforms",
            "AFFINE = 0",
            "EXTENT = 1",
            "PERSPECTIVE = 2",
            "QUAD = 3",
            "MESH = 4",
            "",
            "# resampling filters",
            "NONE = 0",
            "NEAREST = 0",
            "ANTIALIAS = 1 # 3-lobed lanczos",
            "LINEAR = BILINEAR = 2",
            "CUBIC = BICUBIC = 3",
            "",
            "# dithers",
            "NONE = 0",
            "NEAREST = 0",
            "ORDERED = 1 # Not yet implemented",
            "RASTERIZE = 2 # Not yet implemented",
            "FLOYDSTEINBERG = 3 # default",
            "",
            "# palettes/quantizers",
            "WEB = 0",
            "ADAPTIVE = 1",
            "",
            "MEDIANCUT = 0",
            "MAXCOVERAGE = 1",
            "FASTOCTREE = 2",
            "",
            "# categories",
            "NORMAL = 0",
            "SEQUENCE = 1",
            "CONTAINER = 2",
            "",
            "if hasattr(core, 'DEFAULT_STRATEGY'):",
            "    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY",
            "    FILTERED = core.FILTERED",
            "    HUFFMAN_ONLY = core.HUFFMAN_ONLY",
            "    RLE = core.RLE",
            "    FIXED = core.FIXED",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# Registries",
            "",
            "ID = []",
            "OPEN = {}",
            "MIME = {}",
            "SAVE = {}",
            "EXTENSION = {}",
            "",
            "# --------------------------------------------------------------------",
            "# Modes supported by this version",
            "",
            "_MODEINFO = {",
            "    # NOTE: this table will be removed in future versions.  use",
            "    # getmode* functions or ImageMode descriptors instead.",
            "",
            "    # official modes",
            "    \"1\": (\"L\", \"L\", (\"1\",)),",
            "    \"L\": (\"L\", \"L\", (\"L\",)),",
            "    \"I\": (\"L\", \"I\", (\"I\",)),",
            "    \"F\": (\"L\", \"F\", (\"F\",)),",
            "    \"P\": (\"RGB\", \"L\", (\"P\",)),",
            "    \"RGB\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\")),",
            "    \"RGBX\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"X\")),",
            "    \"RGBA\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"A\")),",
            "    \"CMYK\": (\"RGB\", \"L\", (\"C\", \"M\", \"Y\", \"K\")),",
            "    \"YCbCr\": (\"RGB\", \"L\", (\"Y\", \"Cb\", \"Cr\")),",
            "    \"LAB\": (\"RGB\", \"L\", (\"L\", \"A\", \"B\")),",
            "",
            "    # Experimental modes include I;16, I;16L, I;16B, RGBa, BGR;15, and",
            "    # BGR;24.  Use these modes only if you know exactly what you're",
            "    # doing...",
            "",
            "}",
            "",
            "if sys.byteorder == 'little':",
            "    _ENDIAN = '<'",
            "else:",
            "    _ENDIAN = '>'",
            "",
            "_MODE_CONV = {",
            "    # official modes",
            "    \"1\": ('|b1', None), # broken",
            "    \"L\": ('|u1', None),",
            "    \"I\": (_ENDIAN + 'i4', None),",
            "    \"F\": (_ENDIAN + 'f4', None),",
            "    \"P\": ('|u1', None),",
            "    \"RGB\": ('|u1', 3),",
            "    \"RGBX\": ('|u1', 4),",
            "    \"RGBA\": ('|u1', 4),",
            "    \"CMYK\": ('|u1', 4),",
            "    \"YCbCr\": ('|u1', 3),",
            "    \"LAB\": ('|u1', 3), # UNDONE - unsigned |u1i1i1",
            "\t# I;16 == I;16L, and I;32 == I;32L  ",
            "    \"I;16\": ('<u2', None),",
            "    \"I;16B\": ('>u2', None),",
            "    \"I;16L\": ('<u2', None),",
            "    \"I;16S\": ('<i2', None),",
            "    \"I;16BS\": ('>i2', None),",
            "    \"I;16LS\": ('<i2', None),",
            "    \"I;32\": ('<u4', None),",
            "    \"I;32B\": ('>u4', None),",
            "    \"I;32L\": ('<u4', None),",
            "    \"I;32S\": ('<i4', None),",
            "    \"I;32BS\": ('>i4', None),",
            "    \"I;32LS\": ('<i4', None),",
            "}",
            "",
            "def _conv_type_shape(im):",
            "    shape = im.size[1], im.size[0]",
            "    typ, extra = _MODE_CONV[im.mode]",
            "    if extra is None:",
            "        return shape, typ",
            "    else:",
            "        return shape+(extra,), typ",
            "",
            "",
            "MODES = sorted(_MODEINFO.keys())",
            "",
            "# raw modes that may be memory mapped.  NOTE: if you change this, you",
            "# may have to modify the stride calculation in map.c too!",
            "_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")",
            "",
            "",
            "def getmodebase(mode):",
            "    \"\"\"",
            "    Gets the \"base\" mode for given mode.  This function returns \"L\" for",
            "    images that contain grayscale data, and \"RGB\" for images that",
            "    contain color data.",
            "",
            "    :param mode: Input mode.",
            "    :returns: \"L\" or \"RGB\".",
            "    :exception KeyError: If the input mode was not a standard mode.",
            "    \"\"\"",
            "    return ImageMode.getmode(mode).basemode",
            "",
            "",
            "def getmodetype(mode):",
            "    \"\"\"",
            "    Gets the storage type mode.  Given a mode, this function returns a",
            "    single-layer mode suitable for storing individual bands.",
            "",
            "    :param mode: Input mode.",
            "    :returns: \"L\", \"I\", or \"F\".",
            "    :exception KeyError: If the input mode was not a standard mode.",
            "    \"\"\"",
            "    return ImageMode.getmode(mode).basetype",
            "",
            "",
            "def getmodebandnames(mode):",
            "    \"\"\"",
            "    Gets a list of individual band names.  Given a mode, this function returns",
            "    a tuple containing the names of individual bands (use",
            "    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each",
            "    individual band.",
            "",
            "    :param mode: Input mode.",
            "    :returns: A tuple containing band names.  The length of the tuple",
            "        gives the number of bands in an image of the given mode.",
            "    :exception KeyError: If the input mode was not a standard mode.",
            "    \"\"\"",
            "    return ImageMode.getmode(mode).bands",
            "",
            "",
            "def getmodebands(mode):",
            "    \"\"\"",
            "    Gets the number of individual bands for this mode.",
            "",
            "    :param mode: Input mode.",
            "    :returns: The number of bands in this mode.",
            "    :exception KeyError: If the input mode was not a standard mode.",
            "    \"\"\"",
            "    return len(ImageMode.getmode(mode).bands)",
            "",
            "# --------------------------------------------------------------------",
            "# Helpers",
            "",
            "_initialized = 0",
            "",
            "",
            "def preinit():",
            "    \"Explicitly load standard file format drivers.\"",
            "",
            "    global _initialized",
            "    if _initialized >= 1:",
            "        return",
            "",
            "    try:",
            "        from PIL import BmpImagePlugin",
            "    except ImportError:",
            "        pass",
            "    try:",
            "        from PIL import GifImagePlugin",
            "    except ImportError:",
            "        pass",
            "    try:",
            "        from PIL import JpegImagePlugin",
            "    except ImportError:",
            "        pass",
            "    try:",
            "        from PIL import PpmImagePlugin",
            "    except ImportError:",
            "        pass",
            "    try:",
            "        from PIL import PngImagePlugin",
            "    except ImportError:",
            "        pass",
            "#   try:",
            "#       import TiffImagePlugin",
            "#   except ImportError:",
            "#       pass",
            "",
            "    _initialized = 1",
            "",
            "",
            "def init():",
            "    \"\"\"",
            "    Explicitly initializes the Python Imaging Library. This function",
            "    loads all available file format drivers.",
            "    \"\"\"",
            "",
            "    global _initialized",
            "    if _initialized >= 2:",
            "        return 0",
            "",
            "    for plugin in _plugins:",
            "        try:",
            "            if DEBUG:",
            "                print (\"Importing %s\"%plugin)",
            "            __import__(\"PIL.%s\"%plugin, globals(), locals(), [])",
            "        except ImportError:",
            "            if DEBUG:",
            "                print(\"Image: failed to import\", end=' ')",
            "                print(plugin, \":\", sys.exc_info()[1])",
            "",
            "    if OPEN or SAVE:",
            "        _initialized = 2",
            "        return 1",
            "",
            "# --------------------------------------------------------------------",
            "# Codec factories (used by tobytes/frombytes and ImageFile.load)",
            "",
            "def _getdecoder(mode, decoder_name, args, extra=()):",
            "",
            "    # tweak arguments",
            "    if args is None:",
            "        args = ()",
            "    elif not isinstance(args, tuple):",
            "        args = (args,)",
            "",
            "    try:",
            "        # get decoder",
            "        decoder = getattr(core, decoder_name + \"_decoder\")",
            "        # print(decoder, mode, args + extra)",
            "        return decoder(mode, *args + extra)",
            "    except AttributeError:",
            "        raise IOError(\"decoder %s not available\" % decoder_name)",
            "",
            "def _getencoder(mode, encoder_name, args, extra=()):",
            "",
            "    # tweak arguments",
            "    if args is None:",
            "        args = ()",
            "    elif not isinstance(args, tuple):",
            "        args = (args,)",
            "",
            "    try:",
            "        # get encoder",
            "        encoder = getattr(core, encoder_name + \"_encoder\")",
            "        # print(encoder, mode, args + extra)",
            "        return encoder(mode, *args + extra)",
            "    except AttributeError:",
            "        raise IOError(\"encoder %s not available\" % encoder_name)",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# Simple expression analyzer",
            "",
            "def coerce_e(value):",
            "    return value if isinstance(value, _E) else _E(value)",
            "",
            "class _E:",
            "    def __init__(self, data):",
            "        self.data = data",
            "    def __add__(self, other):",
            "        return _E((self.data, \"__add__\", coerce_e(other).data))",
            "    def __mul__(self, other):",
            "        return _E((self.data, \"__mul__\", coerce_e(other).data))",
            "",
            "def _getscaleoffset(expr):",
            "    stub = [\"stub\"]",
            "    data = expr(_E(stub)).data",
            "    try:",
            "        (a, b, c) = data # simplified syntax",
            "        if (a is stub and b == \"__mul__\" and isinstance(c, numbers.Number)):",
            "            return c, 0.0",
            "        if (a is stub and b == \"__add__\" and isinstance(c, numbers.Number)):",
            "            return 1.0, c",
            "    except TypeError: pass",
            "    try:",
            "        ((a, b, c), d, e) = data # full syntax",
            "        if (a is stub and b == \"__mul__\" and isinstance(c, numbers.Number) and",
            "            d == \"__add__\" and isinstance(e, numbers.Number)):",
            "            return c, e",
            "    except TypeError: pass",
            "    raise ValueError(\"illegal expression\")",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# Implementation wrapper",
            "",
            "class Image:",
            "    \"\"\"",
            "    This class represents an image object.  To create",
            "    :py:class:`~PIL.Image.Image` objects, use the appropriate factory",
            "    functions.  There's hardly ever any reason to call the Image constructor",
            "    directly.",
            "",
            "    * :py:func:`~PIL.Image.open`",
            "    * :py:func:`~PIL.Image.new`",
            "    * :py:func:`~PIL.Image.frombytes`",
            "    \"\"\"",
            "    format = None",
            "    format_description = None",
            "",
            "    def __init__(self):",
            "        # FIXME: take \"new\" parameters / other image?",
            "        # FIXME: turn mode and size into delegating properties?",
            "        self.im = None",
            "        self.mode = \"\"",
            "        self.size = (0, 0)",
            "        self.palette = None",
            "        self.info = {}",
            "        self.category = NORMAL",
            "        self.readonly = 0",
            "",
            "    def _new(self, im):",
            "        new = Image()",
            "        new.im = im",
            "        new.mode = im.mode",
            "        new.size = im.size",
            "        new.palette = self.palette",
            "        if im.mode == \"P\" and not new.palette:",
            "            from PIL import ImagePalette",
            "            new.palette = ImagePalette.ImagePalette()",
            "        try:",
            "            new.info = self.info.copy()",
            "        except AttributeError:",
            "            # fallback (pre-1.5.2)",
            "            new.info = {}",
            "            for k, v in self.info:",
            "                new.info[k] = v",
            "        return new",
            "",
            "    _makeself = _new # compatibility",
            "",
            "    def _copy(self):",
            "        self.load()",
            "        self.im = self.im.copy()",
            "        self.readonly = 0",
            "",
            "    def _dump(self, file=None, format=None):",
            "        import tempfile, os",
            "        if not file:",
            "            f, file = tempfile.mkstemp(format or '')",
            "            os.close(f)",
            "            ",
            "        self.load()",
            "        if not format or format == \"PPM\":",
            "            self.im.save_ppm(file)",
            "        else:",
            "            if file.endswith(format):",
            "                file = file + \".\" + format",
            "            self.save(file, format)",
            "        return file",
            "",
            "    def __repr__(self):",
            "        return \"<%s.%s image mode=%s size=%dx%d at 0x%X>\" % (",
            "            self.__class__.__module__, self.__class__.__name__,",
            "            self.mode, self.size[0], self.size[1],",
            "            id(self)",
            "            )",
            "",
            "    def __getattr__(self, name):",
            "        if name == \"__array_interface__\":",
            "            # numpy array interface support",
            "            new = {}",
            "            shape, typestr = _conv_type_shape(self)",
            "            new['shape'] = shape",
            "            new['typestr'] = typestr",
            "            new['data'] = self.tobytes()",
            "            return new",
            "        raise AttributeError(name)",
            "",
            "    def tobytes(self, encoder_name=\"raw\", *args):",
            "        \"\"\"",
            "        Return image as a bytes object",
            "",
            "        :param encoder_name: What encoder to use.  The default is to",
            "                             use the standard \"raw\" encoder.",
            "        :param args: Extra arguments to the encoder.",
            "        :rtype: A bytes object.",
            "        \"\"\"",
            "",
            "        # may pass tuple instead of argument list",
            "        if len(args) == 1 and isinstance(args[0], tuple):",
            "            args = args[0]",
            "",
            "        if encoder_name == \"raw\" and args == ():",
            "            args = self.mode",
            "",
            "        self.load()",
            "",
            "        # unpack data",
            "        e = _getencoder(self.mode, encoder_name, args)",
            "        e.setimage(self.im)",
            "",
            "        bufsize = max(65536, self.size[0] * 4) # see RawEncode.c",
            "",
            "        data = []",
            "        while True:",
            "            l, s, d = e.encode(bufsize)",
            "            data.append(d)",
            "            if s:",
            "                break",
            "        if s < 0:",
            "            raise RuntimeError(\"encoder error %d in tobytes\" % s)",
            "",
            "        return b\"\".join(data)",
            "",
            "    # Declare tostring as alias to tobytes",
            "    def tostring(self, *args, **kw):",
            "        warnings.warn(",
            "            'tostring() is deprecated. Please call tobytes() instead.',",
            "            DeprecationWarning,",
            "            stacklevel=2,",
            "        )",
            "        return self.tobytes(*args, **kw)",
            "",
            "    def tobitmap(self, name=\"image\"):",
            "        \"\"\"",
            "        Returns the image converted to an X11 bitmap.",
            "",
            "        .. note:: This method only works for mode \"1\" images.",
            "",
            "        :param name: The name prefix to use for the bitmap variables.",
            "        :returns: A string containing an X11 bitmap.",
            "        :raises ValueError: If the mode is not \"1\"",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.mode != \"1\":",
            "            raise ValueError(\"not a bitmap\")",
            "        data = self.tobytes(\"xbm\")",
            "        return b\"\".join([(\"#define %s_width %d\\n\" % (name, self.size[0])).encode('ascii'),",
            "                (\"#define %s_height %d\\n\"% (name, self.size[1])).encode('ascii'),",
            "                (\"static char %s_bits[] = {\\n\" % name).encode('ascii'), data, b\"};\"])",
            "",
            "    def frombytes(self, data, decoder_name=\"raw\", *args):",
            "        \"\"\"",
            "        Loads this image with pixel data from a bytes object.",
            "",
            "        This method is similar to the :py:func:`~PIL.Image.frombytes` function,",
            "        but loads data into this image instead of creating a new image object.",
            "        \"\"\"",
            "",
            "        # may pass tuple instead of argument list",
            "        if len(args) == 1 and isinstance(args[0], tuple):",
            "            args = args[0]",
            "",
            "        # default format",
            "        if decoder_name == \"raw\" and args == ():",
            "            args = self.mode",
            "",
            "        # unpack data",
            "        d = _getdecoder(self.mode, decoder_name, args)",
            "        d.setimage(self.im)",
            "        s = d.decode(data)",
            "",
            "        if s[0] >= 0:",
            "            raise ValueError(\"not enough image data\")",
            "        if s[1] != 0:",
            "            raise ValueError(\"cannot decode image data\")",
            "",
            "    def fromstring(self, *args, **kw):",
            "        \"\"\"Deprecated alias to frombytes.",
            "",
            "        .. deprecated:: 2.0",
            "        \"\"\"",
            "        warnings.warn('fromstring() is deprecated. Please call frombytes() instead.', DeprecationWarning)",
            "        return self.frombytes(*args, **kw)",
            "",
            "    def load(self):",
            "        \"\"\"",
            "        Allocates storage for the image and loads the pixel data.  In",
            "        normal cases, you don't need to call this method, since the",
            "        Image class automatically loads an opened image when it is",
            "        accessed for the first time.",
            "",
            "        :returns: An image access object.",
            "        \"\"\"",
            "        if self.im and self.palette and self.palette.dirty:",
            "            # realize palette",
            "            self.im.putpalette(*self.palette.getdata())",
            "            self.palette.dirty = 0",
            "            self.palette.mode = \"RGB\"",
            "            self.palette.rawmode = None",
            "            if \"transparency\" in self.info:",
            "                if isinstance(self.info[\"transparency\"], int):",
            "                    self.im.putpalettealpha(self.info[\"transparency\"], 0)",
            "                else:",
            "                    self.im.putpalettealphas(self.info[\"transparency\"])",
            "                self.palette.mode = \"RGBA\"",
            "",
            "        if self.im:",
            "            return self.im.pixel_access(self.readonly)",
            "",
            "    def verify(self):",
            "        \"\"\"",
            "        Verifies the contents of a file. For data read from a file, this",
            "        method attempts to determine if the file is broken, without",
            "        actually decoding the image data.  If this method finds any",
            "        problems, it raises suitable exceptions.  If you need to load",
            "        the image after using this method, you must reopen the image",
            "        file.",
            "        \"\"\"",
            "        pass",
            "",
            "    def convert(self, mode=None, matrix=None, dither=None,",
            "                palette=WEB, colors=256):",
            "        \"\"\"",
            "        Returns a converted copy of this image. For the \"P\" mode, this",
            "        method translates pixels through the palette.  If mode is",
            "        omitted, a mode is chosen so that all information in the image",
            "        and the palette can be represented without a palette.",
            "",
            "        The current version supports all possible conversions between",
            "        \"L\", \"RGB\" and \"CMYK.\" The **matrix** argument only supports \"L\"",
            "        and \"RGB\".",
            "",
            "        When translating a color image to black and white (mode \"L\"),",
            "        the library uses the ITU-R 601-2 luma transform::",
            "",
            "            L = R * 299/1000 + G * 587/1000 + B * 114/1000",
            "",
            "        The default method of converting a greyscale (\"L\") or \"RGB\"",
            "        image into a bilevel (mode \"1\") image uses Floyd-Steinberg",
            "        dither to approximate the original image luminosity levels. If",
            "        dither is NONE, all non-zero values are set to 255 (white). To",
            "        use other thresholds, use the :py:meth:`~PIL.Image.Image.point`",
            "        method.",
            "",
            "        :param mode: The requested mode.",
            "        :param matrix: An optional conversion matrix.  If given, this",
            "           should be 4- or 16-tuple containing floating point values.",
            "        :param dither: Dithering method, used when converting from",
            "           mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".",
            "           Available methods are NONE or FLOYDSTEINBERG (default).",
            "        :param palette: Palette to use when converting from mode \"RGB\"",
            "           to \"P\".  Available palettes are WEB or ADAPTIVE.",
            "        :param colors: Number of colors to use for the ADAPTIVE palette.",
            "           Defaults to 256.",
            "        :rtype: :py:class:`~PIL.Image.Image`",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if not mode:",
            "            # determine default mode",
            "            if self.mode == \"P\":",
            "                self.load()",
            "                if self.palette:",
            "                    mode = self.palette.mode",
            "                else:",
            "                    mode = \"RGB\"",
            "            else:",
            "                return self.copy()",
            "",
            "        self.load()",
            "",
            "        if matrix:",
            "            # matrix conversion",
            "            if mode not in (\"L\", \"RGB\"):",
            "                raise ValueError(\"illegal conversion\")",
            "            im = self.im.convert_matrix(mode, matrix)",
            "            return self._new(im)",
            "",
            "        if mode == \"P\" and palette == ADAPTIVE:",
            "            im = self.im.quantize(colors)",
            "            return self._new(im)",
            "",
            "        # colorspace conversion",
            "        if dither is None:",
            "            dither = FLOYDSTEINBERG",
            "",
            "        # Use transparent conversion to promote from transparent color to an alpha channel.",
            "        if self.mode in (\"L\", \"RGB\") and mode == \"RGBA\" and \"transparency\" in self.info:",
            "            return self._new(self.im.convert_transparent(mode, self.info['transparency']))",
            "            ",
            "        try:",
            "            im = self.im.convert(mode, dither)",
            "        except ValueError:",
            "            try:",
            "                # normalize source image and try again",
            "                im = self.im.convert(getmodebase(self.mode))",
            "                im = im.convert(mode, dither)",
            "            except KeyError:",
            "                raise ValueError(\"illegal conversion\")",
            "",
            "        return self._new(im)",
            "",
            "    def quantize(self, colors=256, method=0, kmeans=0, palette=None):",
            "",
            "        # methods:",
            "        #    0 = median cut",
            "        #    1 = maximum coverage",
            "        #    2 = fast octree",
            "",
            "        # NOTE: this functionality will be moved to the extended",
            "        # quantizer interface in a later version of PIL.",
            "",
            "        self.load()",
            "",
            "        if palette:",
            "            # use palette from reference image",
            "            palette.load()",
            "            if palette.mode != \"P\":",
            "                raise ValueError(\"bad mode for palette image\")",
            "            if self.mode != \"RGB\" and self.mode != \"L\":",
            "                raise ValueError(",
            "                    \"only RGB or L mode images can be quantized to a palette\"",
            "                    )",
            "            im = self.im.convert(\"P\", 1, palette.im)",
            "            return self._makeself(im)",
            "",
            "        im = self.im.quantize(colors, method, kmeans)",
            "        return self._new(im)",
            "",
            "    def copy(self):",
            "        \"\"\"",
            "        Copies this image. Use this method if you wish to paste things",
            "        into an image, but still retain the original.",
            "",
            "        :rtype: :py:class:`~PIL.Image.Image`",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "        self.load()",
            "        im = self.im.copy()",
            "        return self._new(im)",
            "",
            "    def crop(self, box=None):",
            "        \"\"\"",
            "        Returns a rectangular region from this image. The box is a",
            "        4-tuple defining the left, upper, right, and lower pixel",
            "        coordinate.",
            "",
            "        This is a lazy operation.  Changes to the source image may or",
            "        may not be reflected in the cropped image.  To break the",
            "        connection, call the :py:meth:`~PIL.Image.Image.load` method on",
            "        the cropped copy.",
            "",
            "        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple.",
            "        :rtype: :py:class:`~PIL.Image.Image`",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if box is None:",
            "            return self.copy()",
            "",
            "        # lazy operation",
            "        return _ImageCrop(self, box)",
            "",
            "    def draft(self, mode, size):",
            "        \"\"\"",
            "        Configures the image file loader so it returns a version of the",
            "        image that as closely as possible matches the given mode and",
            "        size.  For example, you can use this method to convert a color",
            "        JPEG to greyscale while loading it, or to extract a 128x192",
            "        version from a PCD file.",
            "",
            "        Note that this method modifies the :py:class:`~PIL.Image.Image` object",
            "        in place.  If the image has already been loaded, this method has no",
            "        effect.",
            "",
            "        :param mode: The requested mode.",
            "        :param size: The requested size.",
            "        \"\"\"",
            "        pass",
            "",
            "    def _expand(self, xmargin, ymargin=None):",
            "        if ymargin is None:",
            "            ymargin = xmargin",
            "        self.load()",
            "        return self._new(self.im.expand(xmargin, ymargin, 0))",
            "",
            "    def filter(self, filter):",
            "        \"\"\"",
            "        Filters this image using the given filter.  For a list of",
            "        available filters, see the :py:mod:`~PIL.ImageFilter` module.",
            "",
            "        :param filter: Filter kernel.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.  \"\"\"",
            "",
            "        self.load()",
            "",
            "        if isinstance(filter, collections.Callable):",
            "            filter = filter()",
            "        if not hasattr(filter, \"filter\"):",
            "            raise TypeError(\"filter argument should be ImageFilter.Filter instance or class\")",
            "",
            "        if self.im.bands == 1:",
            "            return self._new(filter.filter(self.im))",
            "        # fix to handle multiband images since _imaging doesn't",
            "        ims = []",
            "        for c in range(self.im.bands):",
            "            ims.append(self._new(filter.filter(self.im.getband(c))))",
            "        return merge(self.mode, ims)",
            "",
            "    def getbands(self):",
            "        \"\"\"",
            "        Returns a tuple containing the name of each band in this image.",
            "        For example, **getbands** on an RGB image returns (\"R\", \"G\", \"B\").",
            "",
            "        :returns: A tuple containing band names.",
            "        :rtype: tuple",
            "        \"\"\"",
            "        return ImageMode.getmode(self.mode).bands",
            "",
            "    def getbbox(self):",
            "        \"\"\"",
            "        Calculates the bounding box of the non-zero regions in the",
            "        image.",
            "",
            "        :returns: The bounding box is returned as a 4-tuple defining the",
            "           left, upper, right, and lower pixel coordinate. If the image",
            "           is completely empty, this method returns None.",
            "",
            "        \"\"\"",
            "",
            "        self.load()",
            "        return self.im.getbbox()",
            "",
            "    def getcolors(self, maxcolors=256):",
            "        \"\"\"",
            "        Returns a list of colors used in this image.",
            "",
            "        :param maxcolors: Maximum number of colors.  If this number is",
            "           exceeded, this method returns None.  The default limit is",
            "           256 colors.",
            "        :returns: An unsorted list of (count, pixel) values.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.mode in (\"1\", \"L\", \"P\"):",
            "            h = self.im.histogram()",
            "            out = []",
            "            for i in range(256):",
            "                if h[i]:",
            "                    out.append((h[i], i))",
            "            if len(out) > maxcolors:",
            "                return None",
            "            return out",
            "        return self.im.getcolors(maxcolors)",
            "",
            "    def getdata(self, band = None):",
            "        \"\"\"",
            "        Returns the contents of this image as a sequence object",
            "        containing pixel values.  The sequence object is flattened, so",
            "        that values for line one follow directly after the values of",
            "        line zero, and so on.",
            "",
            "        Note that the sequence object returned by this method is an",
            "        internal PIL data type, which only supports certain sequence",
            "        operations.  To convert it to an ordinary sequence (e.g. for",
            "        printing), use **list(im.getdata())**.",
            "",
            "        :param band: What band to return.  The default is to return",
            "           all bands.  To return a single band, pass in the index",
            "           value (e.g. 0 to get the \"R\" band from an \"RGB\" image).",
            "        :returns: A sequence-like object.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if band is not None:",
            "            return self.im.getband(band)",
            "        return self.im # could be abused",
            "",
            "    def getextrema(self):",
            "        \"\"\"",
            "        Gets the the minimum and maximum pixel values for each band in",
            "        the image.",
            "",
            "        :returns: For a single-band image, a 2-tuple containing the",
            "           minimum and maximum pixel value.  For a multi-band image,",
            "           a tuple containing one 2-tuple for each band.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.im.bands > 1:",
            "            extrema = []",
            "            for i in range(self.im.bands):",
            "                extrema.append(self.im.getband(i).getextrema())",
            "            return tuple(extrema)",
            "        return self.im.getextrema()",
            "",
            "    def getim(self):",
            "        \"\"\"",
            "        Returns a capsule that points to the internal image memory.",
            "",
            "        :returns: A capsule object.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        return self.im.ptr",
            "",
            "",
            "    def getpalette(self):",
            "        \"\"\"",
            "        Returns the image palette as a list.",
            "",
            "        :returns: A list of color values [r, g, b, ...], or None if the",
            "           image has no palette.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        try:",
            "            if bytes is str:",
            "                return [i8(c) for c in self.im.getpalette()]",
            "            else:",
            "                return list(self.im.getpalette())",
            "        except ValueError:",
            "            return None # no palette",
            "",
            "",
            "    def getpixel(self, xy):",
            "        \"\"\"",
            "        Returns the pixel value at a given position.",
            "",
            "        :param xy: The coordinate, given as (x, y).",
            "        :returns: The pixel value.  If the image is a multi-layer image,",
            "           this method returns a tuple.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        return self.im.getpixel(xy)",
            "",
            "    def getprojection(self):",
            "        \"\"\"",
            "        Get projection to x and y axes",
            "",
            "        :returns: Two sequences, indicating where there are non-zero",
            "            pixels along the X-axis and the Y-axis, respectively.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        x, y = self.im.getprojection()",
            "        return [i8(c) for c in x], [i8(c) for c in y]",
            "",
            "    def histogram(self, mask=None, extrema=None):",
            "        \"\"\"",
            "        Returns a histogram for the image. The histogram is returned as",
            "        a list of pixel counts, one for each pixel value in the source",
            "        image. If the image has more than one band, the histograms for",
            "        all bands are concatenated (for example, the histogram for an",
            "        \"RGB\" image contains 768 values).",
            "",
            "        A bilevel image (mode \"1\") is treated as a greyscale (\"L\") image",
            "        by this method.",
            "",
            "        If a mask is provided, the method returns a histogram for those",
            "        parts of the image where the mask image is non-zero. The mask",
            "        image must have the same size as the image, and be either a",
            "        bi-level image (mode \"1\") or a greyscale image (\"L\").",
            "",
            "        :param mask: An optional mask.",
            "        :returns: A list containing pixel counts.",
            "        \"\"\"",
            "        self.load()",
            "        if mask:",
            "            mask.load()",
            "            return self.im.histogram((0, 0), mask.im)",
            "        if self.mode in (\"I\", \"F\"):",
            "            if extrema is None:",
            "                extrema = self.getextrema()",
            "            return self.im.histogram(extrema)",
            "        return self.im.histogram()",
            "",
            "    def offset(self, xoffset, yoffset=None):",
            "        \"\"\"",
            "        .. deprecated:: 2.0",
            "",
            "        .. note:: New code should use :py:func:`PIL.ImageChops.offset`.",
            "",
            "        Returns a copy of the image where the data has been offset by the given",
            "        distances. Data wraps around the edges. If **yoffset** is omitted, it",
            "        is assumed to be equal to **xoffset**.",
            "",
            "        :param xoffset: The horizontal distance.",
            "        :param yoffset: The vertical distance.  If omitted, both",
            "           distances are set to the same value.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "        if warnings:",
            "            warnings.warn(",
            "                \"'offset' is deprecated; use 'ImageChops.offset' instead\",",
            "                DeprecationWarning, stacklevel=2",
            "                )",
            "        from PIL import ImageChops",
            "        return ImageChops.offset(self, xoffset, yoffset)",
            "",
            "    def paste(self, im, box=None, mask=None):",
            "        \"\"\"",
            "        Pastes another image into this image. The box argument is either",
            "        a 2-tuple giving the upper left corner, a 4-tuple defining the",
            "        left, upper, right, and lower pixel coordinate, or None (same as",
            "        (0, 0)).  If a 4-tuple is given, the size of the pasted image",
            "        must match the size of the region.",
            "",
            "        If the modes don't match, the pasted image is converted to the mode of",
            "        this image (see the :py:meth:`~PIL.Image.Image.convert` method for",
            "        details).",
            "",
            "        Instead of an image, the source can be a integer or tuple",
            "        containing pixel values.  The method then fills the region",
            "        with the given color.  When creating RGB images, you can",
            "        also use color strings as supported by the ImageColor module.",
            "",
            "        If a mask is given, this method updates only the regions",
            "        indicated by the mask.  You can use either \"1\", \"L\" or \"RGBA\"",
            "        images (in the latter case, the alpha band is used as mask).",
            "        Where the mask is 255, the given image is copied as is.  Where",
            "        the mask is 0, the current value is preserved.  Intermediate",
            "        values can be used for transparency effects.",
            "",
            "        Note that if you paste an \"RGBA\" image, the alpha band is",
            "        ignored.  You can work around this by using the same image as",
            "        both source image and mask.",
            "",
            "        :param im: Source image or pixel value (integer or tuple).",
            "        :param box: An optional 4-tuple giving the region to paste into.",
            "           If a 2-tuple is used instead, it's treated as the upper left",
            "           corner.  If omitted or None, the source is pasted into the",
            "           upper left corner.",
            "",
            "           If an image is given as the second argument and there is no",
            "           third, the box defaults to (0, 0), and the second argument",
            "           is interpreted as a mask image.",
            "        :param mask: An optional mask image.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if isImageType(box) and mask is None:",
            "            # abbreviated paste(im, mask) syntax",
            "            mask = box; box = None",
            "",
            "        if box is None:",
            "            # cover all of self",
            "            box = (0, 0) + self.size",
            "",
            "        if len(box) == 2:",
            "            # lower left corner given; get size from image or mask",
            "            if isImageType(im):",
            "                size = im.size",
            "            elif isImageType(mask):",
            "                size = mask.size",
            "            else:",
            "                # FIXME: use self.size here?",
            "                raise ValueError(",
            "                    \"cannot determine region size; use 4-item box\"",
            "                    )",
            "            box = box + (box[0]+size[0], box[1]+size[1])",
            "",
            "        if isStringType(im):",
            "            from PIL import ImageColor",
            "            im = ImageColor.getcolor(im, self.mode)",
            "",
            "        elif isImageType(im):",
            "            im.load()",
            "            if self.mode != im.mode:",
            "                if self.mode != \"RGB\" or im.mode not in (\"RGBA\", \"RGBa\"):",
            "                    # should use an adapter for this!",
            "                    im = im.convert(self.mode)",
            "            im = im.im",
            "",
            "        self.load()",
            "        if self.readonly:",
            "            self._copy()",
            "",
            "        if mask:",
            "            mask.load()",
            "            self.im.paste(im, box, mask.im)",
            "        else:",
            "            self.im.paste(im, box)",
            "",
            "    def point(self, lut, mode=None):",
            "        \"\"\"",
            "        Maps this image through a lookup table or function.",
            "",
            "        :param lut: A lookup table, containing 256 (or 65336 if",
            "           self.mode==\"I\" and mode == \"L\") values per band in the",
            "           image.  A function can be used instead, it should take a",
            "           single argument. The function is called once for each",
            "           possible pixel value, and the resulting table is applied to",
            "           all bands of the image.",
            "        :param mode: Output mode (default is same as input).  In the",
            "           current version, this can only be used if the source image",
            "           has mode \"L\" or \"P\", and the output has mode \"1\" or the",
            "           source image mode is \"I\" and the output mode is \"L\".",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        self.load()",
            "",
            "        if isinstance(lut, ImagePointHandler):",
            "            return lut.point(self)",
            "",
            "        if callable(lut):",
            "            # if it isn't a list, it should be a function",
            "            if self.mode in (\"I\", \"I;16\", \"F\"):",
            "                # check if the function can be used with point_transform",
            "                # UNDONE wiredfool -- I think this prevents us from ever doing",
            "                # a gamma function point transform on > 8bit images. ",
            "                scale, offset = _getscaleoffset(lut)",
            "                return self._new(self.im.point_transform(scale, offset))",
            "            # for other modes, convert the function to a table",
            "            lut = [lut(i) for i in range(256)] * self.im.bands",
            "",
            "        if self.mode == \"F\":",
            "            # FIXME: _imaging returns a confusing error message for this case",
            "            raise ValueError(\"point operation not supported for this mode\")",
            "",
            "        return self._new(self.im.point(lut, mode))",
            "",
            "    def putalpha(self, alpha):",
            "        \"\"\"",
            "        Adds or replaces the alpha layer in this image.  If the image",
            "        does not have an alpha layer, it's converted to \"LA\" or \"RGBA\".",
            "        The new layer must be either \"L\" or \"1\".",
            "",
            "        :param alpha: The new alpha layer.  This can either be an \"L\" or \"1\"",
            "           image having the same size as this image, or an integer or",
            "           other color value.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.readonly:",
            "            self._copy()",
            "",
            "        if self.mode not in (\"LA\", \"RGBA\"):",
            "            # attempt to promote self to a matching alpha mode",
            "            try:",
            "                mode = getmodebase(self.mode) + \"A\"",
            "                try:",
            "                    self.im.setmode(mode)",
            "                except (AttributeError, ValueError):",
            "                    # do things the hard way",
            "                    im = self.im.convert(mode)",
            "                    if im.mode not in (\"LA\", \"RGBA\"):",
            "                        raise ValueError # sanity check",
            "                    self.im = im",
            "                self.mode = self.im.mode",
            "            except (KeyError, ValueError):",
            "                raise ValueError(\"illegal image mode\")",
            "",
            "        if self.mode == \"LA\":",
            "            band = 1",
            "        else:",
            "            band = 3",
            "",
            "        if isImageType(alpha):",
            "            # alpha layer",
            "            if alpha.mode not in (\"1\", \"L\"):",
            "                raise ValueError(\"illegal image mode\")",
            "            alpha.load()",
            "            if alpha.mode == \"1\":",
            "                alpha = alpha.convert(\"L\")",
            "        else:",
            "            # constant alpha",
            "            try:",
            "                self.im.fillband(band, alpha)",
            "            except (AttributeError, ValueError):",
            "                # do things the hard way",
            "                alpha = new(\"L\", self.size, alpha)",
            "            else:",
            "                return",
            "",
            "        self.im.putband(alpha.im, band)",
            "",
            "    def putdata(self, data, scale=1.0, offset=0.0):",
            "        \"\"\"",
            "        Copies pixel data to this image.  This method copies data from a",
            "        sequence object into the image, starting at the upper left",
            "        corner (0, 0), and continuing until either the image or the",
            "        sequence ends.  The scale and offset values are used to adjust",
            "        the sequence values: **pixel = value*scale + offset**.",
            "",
            "        :param data: A sequence object.",
            "        :param scale: An optional scale value.  The default is 1.0.",
            "        :param offset: An optional offset value.  The default is 0.0.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.readonly:",
            "            self._copy()",
            "",
            "        self.im.putdata(data, scale, offset)",
            "",
            "    def putpalette(self, data, rawmode=\"RGB\"):",
            "        \"\"\"",
            "        Attaches a palette to this image.  The image must be a \"P\" or",
            "        \"L\" image, and the palette sequence must contain 768 integer",
            "        values, where each group of three values represent the red,",
            "        green, and blue values for the corresponding pixel",
            "        index. Instead of an integer sequence, you can use an 8-bit",
            "        string.",
            "",
            "        :param data: A palette sequence (either a list or a string).",
            "        \"\"\"",
            "        from PIL import ImagePalette",
            "",
            "        if self.mode not in (\"L\", \"P\"):",
            "            raise ValueError(\"illegal image mode\")",
            "        self.load()",
            "        if isinstance(data, ImagePalette.ImagePalette):",
            "            palette = ImagePalette.raw(data.rawmode, data.palette)",
            "        else:",
            "            if not isinstance(data, bytes):",
            "                if bytes is str:",
            "                    data = \"\".join(chr(x) for x in data)",
            "                else:",
            "                    data = bytes(data)",
            "            palette = ImagePalette.raw(rawmode, data)",
            "        self.mode = \"P\"",
            "        self.palette = palette",
            "        self.palette.mode = \"RGB\"",
            "        self.load() # install new palette",
            "",
            "    def putpixel(self, xy, value):",
            "        \"\"\"",
            "        Modifies the pixel at the given position. The color is given as",
            "        a single numerical value for single-band images, and a tuple for",
            "        multi-band images.",
            "",
            "        Note that this method is relatively slow.  For more extensive changes,",
            "        use :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw`",
            "        module instead.",
            "",
            "        See:",
            "",
            "        * :py:meth:`~PIL.Image.Image.paste`",
            "        * :py:meth:`~PIL.Image.Image.putdata`",
            "        * :py:mod:`~PIL.ImageDraw`",
            "",
            "        :param xy: The pixel coordinate, given as (x, y).",
            "        :param value: The pixel value.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.readonly:",
            "            self._copy()",
            "",
            "        return self.im.putpixel(xy, value)",
            "",
            "    def resize(self, size, resample=NEAREST):",
            "        \"\"\"",
            "        Returns a resized copy of this image.",
            "",
            "        :param size: The requested size in pixels, as a 2-tuple:",
            "           (width, height).",
            "        :param filter: An optional resampling filter.  This can be",
            "           one of :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),",
            "           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2",
            "           environment), :py:attr:`PIL.Image.BICUBIC` (cubic spline",
            "           interpolation in a 4x4 environment), or",
            "           :py:attr:`PIL.Image.ANTIALIAS` (a high-quality downsampling filter).",
            "           If omitted, or if the image has mode \"1\" or \"P\", it is",
            "           set :py:attr:`PIL.Image.NEAREST`.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if resample not in (NEAREST, BILINEAR, BICUBIC, ANTIALIAS):",
            "            raise ValueError(\"unknown resampling filter\")",
            "",
            "        self.load()",
            "",
            "        if self.mode in (\"1\", \"P\"):",
            "            resample = NEAREST",
            "",
            "        if self.mode == 'RGBA':",
            "            return self.convert('RGBa').resize(size, resample).convert('RGBA')",
            "",
            "        if resample == ANTIALIAS:",
            "            # requires stretch support (imToolkit & PIL 1.1.3)",
            "            try:",
            "                im = self.im.stretch(size, resample)",
            "            except AttributeError:",
            "                raise ValueError(\"unsupported resampling filter\")",
            "        else:",
            "            im = self.im.resize(size, resample)",
            "",
            "        return self._new(im)",
            "",
            "    def rotate(self, angle, resample=NEAREST, expand=0):",
            "        \"\"\"",
            "        Returns a rotated copy of this image.  This method returns a",
            "        copy of this image, rotated the given number of degrees counter",
            "        clockwise around its centre.",
            "",
            "        :param angle: In degrees counter clockwise.",
            "        :param filter: An optional resampling filter.  This can be",
            "           one of :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),",
            "           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2",
            "           environment), or :py:attr:`PIL.Image.BICUBIC`",
            "           (cubic spline interpolation in a 4x4 environment).",
            "           If omitted, or if the image has mode \"1\" or \"P\", it is",
            "           set :py:attr:`PIL.Image.NEAREST`.",
            "        :param expand: Optional expansion flag.  If true, expands the output",
            "           image to make it large enough to hold the entire rotated image.",
            "           If false or omitted, make the output image the same size as the",
            "           input image.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if expand:",
            "            import math",
            "            angle = -angle * math.pi / 180",
            "            matrix = [",
            "                 math.cos(angle), math.sin(angle), 0.0,",
            "                -math.sin(angle), math.cos(angle), 0.0",
            "                 ]",
            "            def transform(x, y, matrix=matrix):",
            "                (a, b, c, d, e, f) = matrix",
            "                return a*x + b*y + c, d*x + e*y + f",
            "",
            "            # calculate output size",
            "            w, h = self.size",
            "            xx = []",
            "            yy = []",
            "            for x, y in ((0, 0), (w, 0), (w, h), (0, h)):",
            "                x, y = transform(x, y)",
            "                xx.append(x)",
            "                yy.append(y)",
            "            w = int(math.ceil(max(xx)) - math.floor(min(xx)))",
            "            h = int(math.ceil(max(yy)) - math.floor(min(yy)))",
            "",
            "            # adjust center",
            "            x, y = transform(w / 2.0, h / 2.0)",
            "            matrix[2] = self.size[0] / 2.0 - x",
            "            matrix[5] = self.size[1] / 2.0 - y",
            "",
            "            return self.transform((w, h), AFFINE, matrix, resample)",
            "",
            "        if resample not in (NEAREST, BILINEAR, BICUBIC):",
            "            raise ValueError(\"unknown resampling filter\")",
            "",
            "        self.load()",
            "",
            "        if self.mode in (\"1\", \"P\"):",
            "            resample = NEAREST",
            "",
            "        return self._new(self.im.rotate(angle, resample))",
            "",
            "    def save(self, fp, format=None, **params):",
            "        \"\"\"",
            "        Saves this image under the given filename.  If no format is",
            "        specified, the format to use is determined from the filename",
            "        extension, if possible.",
            "",
            "        Keyword options can be used to provide additional instructions",
            "        to the writer. If a writer doesn't recognise an option, it is",
            "        silently ignored. The available options are described later in",
            "        this handbook.",
            "",
            "        You can use a file object instead of a filename. In this case,",
            "        you must always specify the format. The file object must",
            "        implement the **seek**, **tell**, and **write**",
            "        methods, and be opened in binary mode.",
            "",
            "        :param file: File name or file object.",
            "        :param format: Optional format override.  If omitted, the",
            "           format to use is determined from the filename extension.",
            "           If a file object was used instead of a filename, this",
            "           parameter should always be used.",
            "        :param options: Extra parameters to the image writer.",
            "        :returns: None",
            "        :exception KeyError: If the output format could not be determined",
            "           from the file name.  Use the format option to solve this.",
            "        :exception IOError: If the file could not be written.  The file",
            "           may have been created, and may contain partial data.",
            "        \"\"\"",
            "",
            "        if isPath(fp):",
            "            filename = fp",
            "        else:",
            "            if hasattr(fp, \"name\") and isPath(fp.name):",
            "                filename = fp.name",
            "            else:",
            "                filename = \"\"",
            "",
            "        # may mutate self!",
            "        self.load()",
            "",
            "        self.encoderinfo = params",
            "        self.encoderconfig = ()",
            "",
            "        preinit()",
            "",
            "        ext = os.path.splitext(filename)[1].lower()",
            "",
            "        if not format:",
            "            try:",
            "                format = EXTENSION[ext]",
            "            except KeyError:",
            "                init()",
            "                try:",
            "                    format = EXTENSION[ext]",
            "                except KeyError:",
            "                    raise KeyError(ext) # unknown extension",
            "",
            "        try:",
            "            save_handler = SAVE[format.upper()]",
            "        except KeyError:",
            "            init()",
            "            save_handler = SAVE[format.upper()] # unknown format",
            "",
            "        if isPath(fp):",
            "            fp = builtins.open(fp, \"wb\")",
            "            close = 1",
            "        else:",
            "            close = 0",
            "",
            "        try:",
            "            save_handler(self, fp, filename)",
            "        finally:",
            "            # do what we can to clean up",
            "            if close:",
            "                fp.close()",
            "",
            "    def seek(self, frame):",
            "        \"\"\"",
            "        Seeks to the given frame in this sequence file. If you seek",
            "        beyond the end of the sequence, the method raises an",
            "        **EOFError** exception. When a sequence file is opened, the",
            "        library automatically seeks to frame 0.",
            "",
            "        Note that in the current version of the library, most sequence",
            "        formats only allows you to seek to the next frame.",
            "",
            "        See :py:meth:`~PIL.Image.Image.tell`.",
            "",
            "        :param frame: Frame number, starting at 0.",
            "        :exception EOFError: If the call attempts to seek beyond the end",
            "            of the sequence.",
            "        \"\"\"",
            "",
            "        # overridden by file handlers",
            "        if frame != 0:",
            "            raise EOFError",
            "",
            "    def show(self, title=None, command=None):",
            "        \"\"\"",
            "        Displays this image. This method is mainly intended for",
            "        debugging purposes.",
            "",
            "        On Unix platforms, this method saves the image to a temporary",
            "        PPM file, and calls the **xv** utility.",
            "",
            "        On Windows, it saves the image to a temporary BMP file, and uses",
            "        the standard BMP display utility to show it (usually Paint).",
            "",
            "        :param title: Optional title to use for the image window,",
            "           where possible.",
            "        :param command: command used to show the image",
            "        \"\"\"",
            "",
            "        _show(self, title=title, command=command)",
            "",
            "    def split(self):",
            "        \"\"\"",
            "        Split this image into individual bands. This method returns a",
            "        tuple of individual image bands from an image. For example,",
            "        splitting an \"RGB\" image creates three new images each",
            "        containing a copy of one of the original bands (red, green,",
            "        blue).",
            "",
            "        :returns: A tuple containing bands.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        if self.im.bands == 1:",
            "            ims = [self.copy()]",
            "        else:",
            "            ims = []",
            "            for i in range(self.im.bands):",
            "                ims.append(self._new(self.im.getband(i)))",
            "        return tuple(ims)",
            "",
            "    def tell(self):",
            "        \"\"\"",
            "        Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`.",
            "",
            "        :returns: Frame number, starting with 0.",
            "        \"\"\"",
            "        return 0",
            "",
            "    def thumbnail(self, size, resample=NEAREST):",
            "        \"\"\"",
            "        Make this image into a thumbnail.  This method modifies the",
            "        image to contain a thumbnail version of itself, no larger than",
            "        the given size.  This method calculates an appropriate thumbnail",
            "        size to preserve the aspect of the image, calls the",
            "        :py:meth:`~PIL.Image.Image.draft` method to configure the file reader",
            "        (where applicable), and finally resizes the image.",
            "",
            "        Note that the bilinear and bicubic filters in the current",
            "        version of PIL are not well-suited for thumbnail generation.",
            "        You should use :py:attr:`PIL.Image.ANTIALIAS` unless speed is much more",
            "        important than quality.",
            "",
            "        Also note that this function modifies the :py:class:`~PIL.Image.Image`",
            "        object in place.  If you need to use the full resolution image as well, apply",
            "        this method to a :py:meth:`~PIL.Image.Image.copy` of the original image.",
            "",
            "        :param size: Requested size.",
            "        :param resample: Optional resampling filter.  This can be one",
            "           of :py:attr:`PIL.Image.NEAREST`, :py:attr:`PIL.Image.BILINEAR`,",
            "           :py:attr:`PIL.Image.BICUBIC`, or :py:attr:`PIL.Image.ANTIALIAS`",
            "           (best quality).  If omitted, it defaults to",
            "           :py:attr:`PIL.Image.NEAREST` (this will be changed to ANTIALIAS in a",
            "           future version).",
            "        :returns: None",
            "        \"\"\"",
            "",
            "        # FIXME: the default resampling filter will be changed",
            "        # to ANTIALIAS in future versions",
            "",
            "        # preserve aspect ratio",
            "        x, y = self.size",
            "        if x > size[0]: y = int(max(y * size[0] / x, 1)); x = int(size[0])",
            "        if y > size[1]: x = int(max(x * size[1] / y, 1)); y = int(size[1])",
            "        size = x, y",
            "",
            "        if size == self.size:",
            "            return",
            "",
            "        self.draft(None, size)",
            "",
            "        self.load()",
            "",
            "        try:",
            "            im = self.resize(size, resample)",
            "        except ValueError:",
            "            if resample != ANTIALIAS:",
            "                raise",
            "            im = self.resize(size, NEAREST) # fallback",
            "",
            "        self.im = im.im",
            "        self.mode = im.mode",
            "        self.size = size",
            "",
            "        self.readonly = 0",
            "",
            "    # FIXME: the different tranform methods need further explanation",
            "    # instead of bloating the method docs, add a separate chapter.",
            "    def transform(self, size, method, data=None, resample=NEAREST, fill=1):",
            "        \"\"\"",
            "        Transforms this image.  This method creates a new image with the",
            "        given size, and the same mode as the original, and copies data",
            "        to the new image using the given transform.",
            "",
            "        :param size: The output size.",
            "        :param method: The transformation method.  This is one of",
            "          :py:attr:`PIL.Image.EXTENT` (cut out a rectangular subregion),",
            "          :py:attr:`PIL.Image.AFFINE` (affine transform),",
            "          :py:attr:`PIL.Image.PERSPECTIVE` (perspective transform),",
            "          :py:attr:`PIL.Image.QUAD` (map a quadrilateral to a rectangle), or",
            "          :py:attr:`PIL.Image.MESH` (map a number of source quadrilaterals",
            "          in one operation).",
            "        :param data: Extra data to the transformation method.",
            "        :param resample: Optional resampling filter.  It can be one of",
            "           :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),",
            "           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2",
            "           environment), or :py:attr:`PIL.Image.BICUBIC` (cubic spline",
            "           interpolation in a 4x4 environment). If omitted, or if the image",
            "           has mode \"1\" or \"P\", it is set to :py:attr:`PIL.Image.NEAREST`.",
            "        :returns: An :py:class:`~PIL.Image.Image` object.",
            "        \"\"\"",
            "",
            "        if self.mode == 'RGBA':",
            "            return self.convert('RGBa').transform(size, method, data, resample, fill).convert('RGBA')",
            "",
            "        if isinstance(method, ImageTransformHandler):",
            "            return method.transform(size, self, resample=resample, fill=fill)",
            "        if hasattr(method, \"getdata\"):",
            "            # compatibility w. old-style transform objects",
            "            method, data = method.getdata()",
            "        if data is None:",
            "            raise ValueError(\"missing method data\")",
            "",
            "        im = new(self.mode, size, None)",
            "        if method == MESH:",
            "            # list of quads",
            "            for box, quad in data:",
            "                im.__transformer(box, self, QUAD, quad, resample, fill)",
            "        else:",
            "            im.__transformer((0, 0)+size, self, method, data, resample, fill)",
            "",
            "        return im",
            "",
            "    def __transformer(self, box, image, method, data,",
            "                      resample=NEAREST, fill=1):",
            "",
            "        # FIXME: this should be turned into a lazy operation (?)",
            "",
            "        w = box[2]-box[0]",
            "        h = box[3]-box[1]",
            "",
            "        if method == AFFINE:",
            "            # change argument order to match implementation",
            "            data = (data[2], data[0], data[1],",
            "                    data[5], data[3], data[4])",
            "        elif method == EXTENT:",
            "            # convert extent to an affine transform",
            "            x0, y0, x1, y1 = data",
            "            xs = float(x1 - x0) / w",
            "            ys = float(y1 - y0) / h",
            "            method = AFFINE",
            "            data = (x0 + xs/2, xs, 0, y0 + ys/2, 0, ys)",
            "        elif method == PERSPECTIVE:",
            "            # change argument order to match implementation",
            "            data = (data[2], data[0], data[1],",
            "                    data[5], data[3], data[4],",
            "                    data[6], data[7])",
            "        elif method == QUAD:",
            "            # quadrilateral warp.  data specifies the four corners",
            "            # given as NW, SW, SE, and NE.",
            "            nw = data[0:2]; sw = data[2:4]; se = data[4:6]; ne = data[6:8]",
            "            x0, y0 = nw; As = 1.0 / w; At = 1.0 / h",
            "            data = (x0, (ne[0]-x0)*As, (sw[0]-x0)*At,",
            "                    (se[0]-sw[0]-ne[0]+x0)*As*At,",
            "                    y0, (ne[1]-y0)*As, (sw[1]-y0)*At,",
            "                    (se[1]-sw[1]-ne[1]+y0)*As*At)",
            "        else:",
            "            raise ValueError(\"unknown transformation method\")",
            "",
            "        if resample not in (NEAREST, BILINEAR, BICUBIC):",
            "            raise ValueError(\"unknown resampling filter\")",
            "",
            "        image.load()",
            "",
            "        self.load()",
            "",
            "        if image.mode in (\"1\", \"P\"):",
            "            resample = NEAREST",
            "",
            "        self.im.transform2(box, image.im, method, data, resample, fill)",
            "",
            "    def transpose(self, method):",
            "        \"\"\"",
            "        Transpose image (flip or rotate in 90 degree steps)",
            "",
            "        :param method: One of :py:attr:`PIL.Image.FLIP_LEFT_RIGHT`,",
            "          :py:attr:`PIL.Image.FLIP_TOP_BOTTOM`, :py:attr:`PIL.Image.ROTATE_90`,",
            "          :py:attr:`PIL.Image.ROTATE_180`, or :py:attr:`PIL.Image.ROTATE_270`.",
            "        :returns: Returns a flipped or rotated copy of this image.",
            "        \"\"\"",
            "",
            "        self.load()",
            "        im = self.im.transpose(method)",
            "        return self._new(im)",
            "",
            "# --------------------------------------------------------------------",
            "# Lazy operations",
            "",
            "class _ImageCrop(Image):",
            "",
            "    def __init__(self, im, box):",
            "",
            "        Image.__init__(self)",
            "",
            "        x0, y0, x1, y1 = box",
            "        if x1 < x0:",
            "            x1 = x0",
            "        if y1 < y0:",
            "            y1 = y0",
            "",
            "        self.mode = im.mode",
            "        self.size = x1-x0, y1-y0",
            "",
            "        self.__crop = x0, y0, x1, y1",
            "",
            "        self.im = im.im",
            "",
            "    def load(self):",
            "",
            "        # lazy evaluation!",
            "        if self.__crop:",
            "            self.im = self.im.crop(self.__crop)",
            "            self.__crop = None",
            "",
            "        if self.im:",
            "            return self.im.pixel_access(self.readonly)",
            "",
            "        # FIXME: future versions should optimize crop/paste",
            "        # sequences!",
            "",
            "# --------------------------------------------------------------------",
            "# Abstract handlers.",
            "",
            "class ImagePointHandler:",
            "    # used as a mixin by point transforms (for use with im.point)",
            "    pass",
            "",
            "class ImageTransformHandler:",
            "    # used as a mixin by geometry transforms (for use with im.transform)",
            "    pass",
            "",
            "# --------------------------------------------------------------------",
            "# Factories",
            "",
            "#",
            "# Debugging",
            "",
            "def _wedge():",
            "    \"Create greyscale wedge (for debugging only)\"",
            "",
            "    return Image()._new(core.wedge(\"L\"))",
            "",
            "",
            "def new(mode, size, color=0):",
            "    \"\"\"",
            "    Creates a new image with the given mode and size.",
            "",
            "    :param mode: The mode to use for the new image.",
            "    :param size: A 2-tuple, containing (width, height) in pixels.",
            "    :param color: What color to use for the image.  Default is black.",
            "       If given, this should be a single integer or floating point value",
            "       for single-band modes, and a tuple for multi-band modes (one value",
            "       per band).  When creating RGB images, you can also use color",
            "       strings as supported by the ImageColor module.  If the color is",
            "       None, the image is not initialised.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    if color is None:",
            "        # don't initialize",
            "        return Image()._new(core.new(mode, size))",
            "",
            "    if isStringType(color):",
            "        # css3-style specifier",
            "",
            "        from PIL import ImageColor",
            "        color = ImageColor.getcolor(color, mode)",
            "",
            "    return Image()._new(core.fill(mode, size, color))",
            "",
            "",
            "def frombytes(mode, size, data, decoder_name=\"raw\", *args):",
            "    \"\"\"",
            "    Creates a copy of an image memory from pixel data in a buffer.",
            "",
            "    In its simplest form, this function takes three arguments",
            "    (mode, size, and unpacked pixel data).",
            "",
            "    You can also use any pixel decoder supported by PIL.  For more",
            "    information on available decoders, see the section",
            "    **Writing Your Own File Decoder**.",
            "",
            "    Note that this function decodes pixel data only, not entire images.",
            "    If you have an entire image in a string, wrap it in a",
            "    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load",
            "    it.",
            "",
            "    :param mode: The image mode.",
            "    :param size: The image size.",
            "    :param data: A byte buffer containing raw data for the given mode.",
            "    :param decoder_name: What decoder to use.",
            "    :param args: Additional parameters for the given decoder.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    # may pass tuple instead of argument list",
            "    if len(args) == 1 and isinstance(args[0], tuple):",
            "        args = args[0]",
            "",
            "    if decoder_name == \"raw\" and args == ():",
            "        args = mode",
            "",
            "    im = new(mode, size)",
            "    im.frombytes(data, decoder_name, args)",
            "    return im",
            "",
            "def fromstring(*args, **kw):",
            "    \"\"\"Deprecated alias to frombytes.",
            "",
            "    .. deprecated:: 2.0",
            "    \"\"\"",
            "    warnings.warn(",
            "        'fromstring() is deprecated. Please call frombytes() instead.',",
            "        DeprecationWarning,",
            "        stacklevel=2",
            "    )",
            "    return frombytes(*args, **kw)",
            "",
            "",
            "def frombuffer(mode, size, data, decoder_name=\"raw\", *args):",
            "    \"\"\"",
            "    Creates an image memory referencing pixel data in a byte buffer.",
            "",
            "    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data",
            "    in the byte buffer, where possible.  This means that changes to the",
            "    original buffer object are reflected in this image).  Not all modes can",
            "    share memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".",
            "",
            "    Note that this function decodes pixel data only, not entire images.",
            "    If you have an entire image file in a string, wrap it in a",
            "    **BytesIO** object, and use :py:func:`~PIL.Image.open` to load it.",
            "",
            "    In the current version, the default parameters used for the \"raw\" decoder",
            "    differs from that used for :py:func:`~PIL.Image.fromstring`.  This is a",
            "    bug, and will probably be fixed in a future release.  The current release",
            "    issues a warning if you do this; to disable the warning, you should provide",
            "    the full set of parameters.  See below for details.",
            "",
            "    :param mode: The image mode.",
            "    :param size: The image size.",
            "    :param data: A bytes or other buffer object containing raw",
            "        data for the given mode.",
            "    :param decoder_name: What decoder to use.",
            "    :param args: Additional parameters for the given decoder.  For the",
            "        default encoder (\"raw\"), it's recommended that you provide the",
            "        full set of parameters::",
            "",
            "            frombuffer(mode, size, data, \"raw\", mode, 0, 1)",
            "",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "",
            "    .. versionadded:: 1.1.4",
            "    \"\"\"",
            "    \"Load image from bytes or buffer\"",
            "",
            "    # may pass tuple instead of argument list",
            "    if len(args) == 1 and isinstance(args[0], tuple):",
            "        args = args[0]",
            "",
            "    if decoder_name == \"raw\":",
            "        if args == ():",
            "            if warnings:",
            "                warnings.warn(",
            "                    \"the frombuffer defaults may change in a future release; \"",
            "                    \"for portability, change the call to read:\\n\"",
            "                    \"  frombuffer(mode, size, data, 'raw', mode, 0, 1)\",",
            "                    RuntimeWarning, stacklevel=2",
            "                )",
            "            args = mode, 0, -1 # may change to (mode, 0, 1) post-1.1.6",
            "        if args[0] in _MAPMODES:",
            "            im = new(mode, (1,1))",
            "            im = im._new(",
            "                core.map_buffer(data, size, decoder_name, None, 0, args)",
            "                )",
            "            im.readonly = 1",
            "            return im",
            "",
            "    return frombytes(mode, size, data, decoder_name, args)",
            "",
            "",
            "def fromarray(obj, mode=None):",
            "    \"\"\"",
            "    Creates an image memory from an object exporting the array interface",
            "    (using the buffer protocol).",
            "",
            "    If obj is not contiguous, then the tobytes method is called",
            "    and :py:func:`~PIL.Image.frombuffer` is used.",
            "",
            "    :param obj: Object with array interface",
            "    :param mode: Mode to use (will be determined from type if None)",
            "    :returns: An image memory.",
            "",
            "    .. versionadded:: 1.1.6",
            "    \"\"\"",
            "    arr = obj.__array_interface__",
            "    shape = arr['shape']",
            "    ndim = len(shape)",
            "    try:",
            "        strides = arr['strides']",
            "    except KeyError:",
            "        strides = None",
            "    if mode is None:",
            "        try:",
            "            typekey = (1, 1) + shape[2:], arr['typestr']",
            "            mode, rawmode = _fromarray_typemap[typekey]",
            "        except KeyError:",
            "            # print typekey",
            "            raise TypeError(\"Cannot handle this data type\")",
            "    else:",
            "        rawmode = mode",
            "    if mode in [\"1\", \"L\", \"I\", \"P\", \"F\"]:",
            "        ndmax = 2",
            "    elif mode == \"RGB\":",
            "        ndmax = 3",
            "    else:",
            "        ndmax = 4",
            "    if ndim > ndmax:",
            "        raise ValueError(\"Too many dimensions.\")",
            "",
            "    size = shape[1], shape[0]",
            "    if strides is not None:",
            "        if hasattr(obj, 'tobytes'):",
            "            obj = obj.tobytes()",
            "        else:",
            "            obj = obj.tostring()",
            "",
            "    return frombuffer(mode, size, obj, \"raw\", rawmode, 0, 1)",
            "",
            "_fromarray_typemap = {",
            "    # (shape, typestr) => mode, rawmode",
            "    # first two members of shape are set to one",
            "    # ((1, 1), \"|b1\"): (\"1\", \"1\"), # broken",
            "    ((1, 1), \"|u1\"): (\"L\", \"L\"),",
            "    ((1, 1), \"|i1\"): (\"I\", \"I;8\"),",
            "    ((1, 1), \"<i2\"): (\"I\", \"I;16\"),",
            "    ((1, 1), \">i2\"): (\"I\", \"I;16B\"),",
            "    ((1, 1), \"<i4\"): (\"I\", \"I;32\"),",
            "    ((1, 1), \">i4\"): (\"I\", \"I;32B\"),",
            "    ((1, 1), \"<f4\"): (\"F\", \"F;32F\"),",
            "    ((1, 1), \">f4\"): (\"F\", \"F;32BF\"),",
            "    ((1, 1), \"<f8\"): (\"F\", \"F;64F\"),",
            "    ((1, 1), \">f8\"): (\"F\", \"F;64BF\"),",
            "    ((1, 1, 3), \"|u1\"): (\"RGB\", \"RGB\"),",
            "    ((1, 1, 4), \"|u1\"): (\"RGBA\", \"RGBA\"),",
            "    }",
            "",
            "# shortcuts",
            "_fromarray_typemap[((1, 1), _ENDIAN + \"i4\")] = (\"I\", \"I\")",
            "_fromarray_typemap[((1, 1), _ENDIAN + \"f4\")] = (\"F\", \"F\")",
            "",
            "",
            "def open(fp, mode=\"r\"):",
            "    \"\"\"",
            "    Opens and identifies the given image file.",
            "",
            "    This is a lazy operation; this function identifies the file, but the",
            "    actual image data is not read from the file until you try to process",
            "    the data (or call the :py:meth:`~PIL.Image.Image.load` method).",
            "    See :py:func:`~PIL.Image.new`.",
            "",
            "    :param file: A filename (string) or a file object.  The file object",
            "       must implement :py:meth:`~file.read`, :py:meth:`~file.seek`, and",
            "       :py:meth:`~file.tell` methods, and be opened in binary mode.",
            "    :param mode: The mode.  If given, this argument must be \"r\".",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    :exception IOError: If the file cannot be found, or the image cannot be",
            "       opened and identified.",
            "    \"\"\"",
            "",
            "    if mode != \"r\":",
            "        raise ValueError(\"bad mode\")",
            "",
            "    if isPath(fp):",
            "        filename = fp",
            "        fp = builtins.open(fp, \"rb\")",
            "    else:",
            "        filename = \"\"",
            "",
            "    prefix = fp.read(16)",
            "",
            "    preinit()",
            "",
            "    for i in ID:",
            "        try:",
            "            factory, accept = OPEN[i]",
            "            if not accept or accept(prefix):",
            "                fp.seek(0)",
            "                return factory(fp, filename)",
            "        except (SyntaxError, IndexError, TypeError):",
            "            #import traceback",
            "            #traceback.print_exc()",
            "            pass",
            "",
            "    if init():",
            "",
            "        for i in ID:",
            "            try:",
            "                factory, accept = OPEN[i]",
            "                if not accept or accept(prefix):",
            "                    fp.seek(0)",
            "                    return factory(fp, filename)",
            "            except (SyntaxError, IndexError, TypeError):",
            "                #import traceback",
            "                #traceback.print_exc()",
            "                pass",
            "",
            "    raise IOError(\"cannot identify image file\")",
            "",
            "#",
            "# Image processing.",
            "",
            "def alpha_composite(im1, im2):",
            "    \"\"\"",
            "    Alpha composite im2 over im1.",
            "",
            "    :param im1: The first image.",
            "    :param im2: The second image.  Must have the same mode and size as",
            "       the first image.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    im1.load()",
            "    im2.load()",
            "    return im1._new(core.alpha_composite(im1.im, im2.im))",
            "",
            "",
            "def blend(im1, im2, alpha):",
            "    \"\"\"",
            "    Creates a new image by interpolating between two input images, using",
            "    a constant alpha.::",
            "",
            "        out = image1 * (1.0 - alpha) + image2 * alpha",
            "",
            "    :param im1: The first image.",
            "    :param im2: The second image.  Must have the same mode and size as",
            "       the first image.",
            "    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a",
            "       copy of the first image is returned. If alpha is 1.0, a copy of",
            "       the second image is returned. There are no restrictions on the",
            "       alpha value. If necessary, the result is clipped to fit into",
            "       the allowed output range.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    im1.load()",
            "    im2.load()",
            "    return im1._new(core.blend(im1.im, im2.im, alpha))",
            "",
            "",
            "def composite(image1, image2, mask):",
            "    \"\"\"",
            "    Create composite image by blending images using a transparency mask.",
            "",
            "    :param image1: The first image.",
            "    :param image2: The second image.  Must have the same mode and",
            "       size as the first image.",
            "    :param mask: A mask image.  This image can can have mode",
            "       \"1\", \"L\", or \"RGBA\", and must have the same size as the",
            "       other two images.",
            "    \"\"\"",
            "",
            "    image = image2.copy()",
            "    image.paste(image1, None, mask)",
            "    return image",
            "",
            "",
            "def eval(image, *args):",
            "    \"\"\"",
            "    Applies the function (which should take one argument) to each pixel",
            "    in the given image. If the image has more than one band, the same",
            "    function is applied to each band. Note that the function is",
            "    evaluated once for each possible pixel value, so you cannot use",
            "    random components or other generators.",
            "",
            "    :param image: The input image.",
            "    :param function: A function object, taking one integer argument.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    return image.point(args[0])",
            "",
            "",
            "def merge(mode, bands):",
            "    \"\"\"",
            "    Merge a set of single band images into a new multiband image.",
            "",
            "    :param mode: The mode to use for the output image.",
            "    :param bands: A sequence containing one single-band image for",
            "        each band in the output image.  All bands must have the",
            "        same size.",
            "    :returns: An :py:class:`~PIL.Image.Image` object.",
            "    \"\"\"",
            "",
            "    if getmodebands(mode) != len(bands) or \"*\" in mode:",
            "        raise ValueError(\"wrong number of bands\")",
            "    for im in bands[1:]:",
            "        if im.mode != getmodetype(mode):",
            "            raise ValueError(\"mode mismatch\")",
            "        if im.size != bands[0].size:",
            "            raise ValueError(\"size mismatch\")",
            "    im = core.new(mode, bands[0].size)",
            "    for i in range(getmodebands(mode)):",
            "        bands[i].load()",
            "        im.putband(bands[i].im, i)",
            "    return bands[0]._new(im)",
            "",
            "# --------------------------------------------------------------------",
            "# Plugin registry",
            "",
            "def register_open(id, factory, accept=None):",
            "    \"\"\"",
            "    Register an image file plugin.  This function should not be used",
            "    in application code.",
            "",
            "    :param id: An image format identifier.",
            "    :param factory: An image file factory method.",
            "    :param accept: An optional function that can be used to quickly",
            "       reject images having another format.",
            "    \"\"\"",
            "    id = id.upper()",
            "    ID.append(id)",
            "    OPEN[id] = factory, accept",
            "",
            "",
            "def register_mime(id, mimetype):",
            "    \"\"\"",
            "    Registers an image MIME type.  This function should not be used",
            "    in application code.",
            "",
            "    :param id: An image format identifier.",
            "    :param mimetype: The image MIME type for this format.",
            "    \"\"\"",
            "    MIME[id.upper()] = mimetype",
            "",
            "",
            "def register_save(id, driver):",
            "    \"\"\"",
            "    Registers an image save function.  This function should not be",
            "    used in application code.",
            "",
            "    :param id: An image format identifier.",
            "    :param driver: A function to save images in this format.",
            "    \"\"\"",
            "    SAVE[id.upper()] = driver",
            "",
            "",
            "def register_extension(id, extension):",
            "    \"\"\"",
            "    Registers an image extension.  This function should not be",
            "    used in application code.",
            "",
            "    :param id: An image format identifier.",
            "    :param extension: An extension used for this format.",
            "    \"\"\"",
            "    EXTENSION[extension.lower()] = id.upper()",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# Simple display support.  User code may override this.",
            "",
            "def _show(image, **options):",
            "    # override me, as necessary",
            "    _showxv(image, **options)",
            "",
            "def _showxv(image, title=None, **options):",
            "    from PIL import ImageShow",
            "    ImageShow.show(image, title, **options)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "498": [
                "Image",
                "_dump"
            ],
            "500": [
                "Image",
                "_dump"
            ],
            "505": [
                "Image",
                "_dump"
            ]
        },
        "addLocation": []
    },
    "PIL/IptcImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         self.fp.seek(offset)"
            },
            "1": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         # Copy image data to temporary file"
            },
            "3": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        outfile = tempfile.mktemp()"
            },
            "4": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        o = open(outfile, \"wb\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        o_fd, outfile = tempfile.mkstemp(text=False)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        o = os.fdopen(o_fd)"
            },
            "7": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         if encoding == \"raw\":"
            },
            "8": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "             # To simplify access to the extracted file,"
            },
            "9": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "             # prepend a PPM header"
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# IPTC/NAA file handling",
            "#",
            "# history:",
            "# 1995-10-01 fl   Created",
            "# 1998-03-09 fl   Cleaned up and added to PIL",
            "# 2002-06-18 fl   Added getiptcinfo helper",
            "#",
            "# Copyright (c) Secret Labs AB 1997-2002.",
            "# Copyright (c) Fredrik Lundh 1995.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "from __future__ import print_function",
            "",
            "__version__ = \"0.3\"",
            "",
            "",
            "from PIL import Image, ImageFile, _binary",
            "import os, tempfile",
            "",
            "i8 = _binary.i8",
            "i16 = _binary.i16be",
            "i32 = _binary.i32be",
            "o8 = _binary.o8",
            "",
            "COMPRESSION = {",
            "    1: \"raw\",",
            "    5: \"jpeg\"",
            "}",
            "",
            "PAD = o8(0) * 4",
            "",
            "#",
            "# Helpers",
            "",
            "def i(c):",
            "    return i32((PAD + c)[-4:])",
            "",
            "def dump(c):",
            "    for i in c:",
            "        print(\"%02x\" % i8(i), end=' ')",
            "    print()",
            "",
            "##",
            "# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields",
            "# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.",
            "",
            "class IptcImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"IPTC\"",
            "    format_description = \"IPTC/NAA\"",
            "",
            "    def getint(self, key):",
            "        return i(self.info[key])",
            "",
            "    def field(self):",
            "        #",
            "        # get a IPTC field header",
            "        s = self.fp.read(5)",
            "        if not len(s):",
            "            return None, 0",
            "",
            "        tag = i8(s[1]), i8(s[2])",
            "",
            "        # syntax",
            "        if i8(s[0]) != 0x1C or tag[0] < 1 or tag[0] > 9:",
            "            raise SyntaxError(\"invalid IPTC/NAA file\")",
            "",
            "        # field size",
            "        size = i8(s[3])",
            "        if size > 132:",
            "            raise IOError(\"illegal field length in IPTC/NAA file\")",
            "        elif size == 128:",
            "            size = 0",
            "        elif size > 128:",
            "            size = i(self.fp.read(size-128))",
            "        else:",
            "            size = i16(s[3:])",
            "",
            "        return tag, size",
            "",
            "    def _is_raw(self, offset, size):",
            "        #",
            "        # check if the file can be mapped",
            "",
            "        # DISABLED: the following only slows things down...",
            "        return 0",
            "",
            "        self.fp.seek(offset)",
            "        t, sz = self.field()",
            "        if sz != size[0]:",
            "            return 0",
            "        y = 1",
            "        while True:",
            "            self.fp.seek(sz, 1)",
            "            t, s = self.field()",
            "            if t != (8, 10):",
            "                break",
            "            if s != sz:",
            "                return 0",
            "            y = y + 1",
            "        return y == size[1]",
            "",
            "    def _open(self):",
            "",
            "        # load descriptive fields",
            "        while True:",
            "            offset = self.fp.tell()",
            "            tag, size = self.field()",
            "            if not tag or tag == (8,10):",
            "                break",
            "            if size:",
            "                tagdata = self.fp.read(size)",
            "            else:",
            "                tagdata = None",
            "            if tag in list(self.info.keys()):",
            "                if isinstance(self.info[tag], list):",
            "                    self.info[tag].append(tagdata)",
            "                else:",
            "                    self.info[tag] = [self.info[tag], tagdata]",
            "            else:",
            "                self.info[tag] = tagdata",
            "",
            "            # print tag, self.info[tag]",
            "",
            "        # mode",
            "        layers = i8(self.info[(3,60)][0])",
            "        component = i8(self.info[(3,60)][1])",
            "        if (3,65) in self.info:",
            "            id = i8(self.info[(3,65)][0])-1",
            "        else:",
            "            id = 0",
            "        if layers == 1 and not component:",
            "            self.mode = \"L\"",
            "        elif layers == 3 and component:",
            "            self.mode = \"RGB\"[id]",
            "        elif layers == 4 and component:",
            "            self.mode = \"CMYK\"[id]",
            "",
            "        # size",
            "        self.size = self.getint((3,20)), self.getint((3,30))",
            "",
            "        # compression",
            "        try:",
            "            compression = COMPRESSION[self.getint((3,120))]",
            "        except KeyError:",
            "            raise IOError(\"Unknown IPTC image compression\")",
            "",
            "        # tile",
            "        if tag == (8,10):",
            "            if compression == \"raw\" and self._is_raw(offset, self.size):",
            "                self.tile = [(compression, (offset, size + 5, -1),",
            "                             (0, 0, self.size[0], self.size[1]))]",
            "            else:",
            "                self.tile = [(\"iptc\", (compression, offset),",
            "                             (0, 0, self.size[0], self.size[1]))]",
            "",
            "    def load(self):",
            "",
            "        if len(self.tile) != 1 or self.tile[0][0] != \"iptc\":",
            "            return ImageFile.ImageFile.load(self)",
            "",
            "        type, tile, box = self.tile[0]",
            "",
            "        encoding, offset = tile",
            "",
            "        self.fp.seek(offset)",
            "",
            "        # Copy image data to temporary file",
            "        outfile = tempfile.mktemp()",
            "        o = open(outfile, \"wb\")",
            "        if encoding == \"raw\":",
            "            # To simplify access to the extracted file,",
            "            # prepend a PPM header",
            "            o.write(\"P5\\n%d %d\\n255\\n\" % self.size)",
            "        while True:",
            "            type, size = self.field()",
            "            if type != (8, 10):",
            "                break",
            "            while size > 0:",
            "                s = self.fp.read(min(size, 8192))",
            "                if not s:",
            "                    break",
            "                o.write(s)",
            "                size = size - len(s)",
            "        o.close()",
            "",
            "        try:",
            "            try:",
            "                # fast",
            "                self.im = Image.core.open_ppm(outfile)",
            "            except:",
            "                # slightly slower",
            "                im = Image.open(outfile)",
            "                im.load()",
            "                self.im = im.im",
            "        finally:",
            "            try: os.unlink(outfile)",
            "            except: pass",
            "",
            "",
            "Image.register_open(\"IPTC\", IptcImageFile)",
            "",
            "Image.register_extension(\"IPTC\", \".iim\")",
            "",
            "##",
            "# Get IPTC information from TIFF, JPEG, or IPTC file.",
            "#",
            "# @param im An image containing IPTC data.",
            "# @return A dictionary containing IPTC information, or None if",
            "#     no IPTC information block was found.",
            "",
            "def getiptcinfo(im):",
            "",
            "    from PIL import TiffImagePlugin, JpegImagePlugin",
            "    import io",
            "",
            "    data = None",
            "",
            "    if isinstance(im, IptcImageFile):",
            "        # return info dictionary right away",
            "        return im.info",
            "",
            "    elif isinstance(im, JpegImagePlugin.JpegImageFile):",
            "        # extract the IPTC/NAA resource",
            "        try:",
            "            app = im.app[\"APP13\"]",
            "            if app[:14] == \"Photoshop 3.0\\x00\":",
            "                app = app[14:]",
            "                # parse the image resource block",
            "                offset = 0",
            "                while app[offset:offset+4] == \"8BIM\":",
            "                    offset = offset + 4",
            "                    # resource code",
            "                    code = JpegImagePlugin.i16(app, offset)",
            "                    offset = offset + 2",
            "                    # resource name (usually empty)",
            "                    name_len = i8(app[offset])",
            "                    name = app[offset+1:offset+1+name_len]",
            "                    offset = 1 + offset + name_len",
            "                    if offset & 1:",
            "                        offset = offset + 1",
            "                    # resource data block",
            "                    size = JpegImagePlugin.i32(app, offset)",
            "                    offset = offset + 4",
            "                    if code == 0x0404:",
            "                        # 0x0404 contains IPTC/NAA data",
            "                        data = app[offset:offset+size]",
            "                        break",
            "                    offset = offset + size",
            "                    if offset & 1:",
            "                        offset = offset + 1",
            "        except (AttributeError, KeyError):",
            "            pass",
            "",
            "    elif isinstance(im, TiffImagePlugin.TiffImageFile):",
            "        # get raw data from the IPTC/NAA tag (PhotoShop tags the data",
            "        # as 4-byte integers, so we cannot use the get method...)",
            "        try:",
            "            data = im.tag.tagdata[TiffImagePlugin.IPTC_NAA_CHUNK]",
            "        except (AttributeError, KeyError):",
            "            pass",
            "",
            "    if data is None:",
            "        return None # no properties",
            "",
            "    # create an IptcImagePlugin object without initializing it",
            "    class FakeImage:",
            "        pass",
            "    im = FakeImage()",
            "    im.__class__ = IptcImageFile",
            "",
            "    # parse the IPTC information chunk",
            "    im.info = {}",
            "    im.fp = io.BytesIO(data)",
            "",
            "    try:",
            "        im._open()",
            "    except (IndexError, KeyError):",
            "        pass # expected failure",
            "",
            "    return im.info"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# IPTC/NAA file handling",
            "#",
            "# history:",
            "# 1995-10-01 fl   Created",
            "# 1998-03-09 fl   Cleaned up and added to PIL",
            "# 2002-06-18 fl   Added getiptcinfo helper",
            "#",
            "# Copyright (c) Secret Labs AB 1997-2002.",
            "# Copyright (c) Fredrik Lundh 1995.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "from __future__ import print_function",
            "",
            "__version__ = \"0.3\"",
            "",
            "",
            "from PIL import Image, ImageFile, _binary",
            "import os, tempfile",
            "",
            "i8 = _binary.i8",
            "i16 = _binary.i16be",
            "i32 = _binary.i32be",
            "o8 = _binary.o8",
            "",
            "COMPRESSION = {",
            "    1: \"raw\",",
            "    5: \"jpeg\"",
            "}",
            "",
            "PAD = o8(0) * 4",
            "",
            "#",
            "# Helpers",
            "",
            "def i(c):",
            "    return i32((PAD + c)[-4:])",
            "",
            "def dump(c):",
            "    for i in c:",
            "        print(\"%02x\" % i8(i), end=' ')",
            "    print()",
            "",
            "##",
            "# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields",
            "# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.",
            "",
            "class IptcImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"IPTC\"",
            "    format_description = \"IPTC/NAA\"",
            "",
            "    def getint(self, key):",
            "        return i(self.info[key])",
            "",
            "    def field(self):",
            "        #",
            "        # get a IPTC field header",
            "        s = self.fp.read(5)",
            "        if not len(s):",
            "            return None, 0",
            "",
            "        tag = i8(s[1]), i8(s[2])",
            "",
            "        # syntax",
            "        if i8(s[0]) != 0x1C or tag[0] < 1 or tag[0] > 9:",
            "            raise SyntaxError(\"invalid IPTC/NAA file\")",
            "",
            "        # field size",
            "        size = i8(s[3])",
            "        if size > 132:",
            "            raise IOError(\"illegal field length in IPTC/NAA file\")",
            "        elif size == 128:",
            "            size = 0",
            "        elif size > 128:",
            "            size = i(self.fp.read(size-128))",
            "        else:",
            "            size = i16(s[3:])",
            "",
            "        return tag, size",
            "",
            "    def _is_raw(self, offset, size):",
            "        #",
            "        # check if the file can be mapped",
            "",
            "        # DISABLED: the following only slows things down...",
            "        return 0",
            "",
            "        self.fp.seek(offset)",
            "        t, sz = self.field()",
            "        if sz != size[0]:",
            "            return 0",
            "        y = 1",
            "        while True:",
            "            self.fp.seek(sz, 1)",
            "            t, s = self.field()",
            "            if t != (8, 10):",
            "                break",
            "            if s != sz:",
            "                return 0",
            "            y = y + 1",
            "        return y == size[1]",
            "",
            "    def _open(self):",
            "",
            "        # load descriptive fields",
            "        while True:",
            "            offset = self.fp.tell()",
            "            tag, size = self.field()",
            "            if not tag or tag == (8,10):",
            "                break",
            "            if size:",
            "                tagdata = self.fp.read(size)",
            "            else:",
            "                tagdata = None",
            "            if tag in list(self.info.keys()):",
            "                if isinstance(self.info[tag], list):",
            "                    self.info[tag].append(tagdata)",
            "                else:",
            "                    self.info[tag] = [self.info[tag], tagdata]",
            "            else:",
            "                self.info[tag] = tagdata",
            "",
            "            # print tag, self.info[tag]",
            "",
            "        # mode",
            "        layers = i8(self.info[(3,60)][0])",
            "        component = i8(self.info[(3,60)][1])",
            "        if (3,65) in self.info:",
            "            id = i8(self.info[(3,65)][0])-1",
            "        else:",
            "            id = 0",
            "        if layers == 1 and not component:",
            "            self.mode = \"L\"",
            "        elif layers == 3 and component:",
            "            self.mode = \"RGB\"[id]",
            "        elif layers == 4 and component:",
            "            self.mode = \"CMYK\"[id]",
            "",
            "        # size",
            "        self.size = self.getint((3,20)), self.getint((3,30))",
            "",
            "        # compression",
            "        try:",
            "            compression = COMPRESSION[self.getint((3,120))]",
            "        except KeyError:",
            "            raise IOError(\"Unknown IPTC image compression\")",
            "",
            "        # tile",
            "        if tag == (8,10):",
            "            if compression == \"raw\" and self._is_raw(offset, self.size):",
            "                self.tile = [(compression, (offset, size + 5, -1),",
            "                             (0, 0, self.size[0], self.size[1]))]",
            "            else:",
            "                self.tile = [(\"iptc\", (compression, offset),",
            "                             (0, 0, self.size[0], self.size[1]))]",
            "",
            "    def load(self):",
            "",
            "        if len(self.tile) != 1 or self.tile[0][0] != \"iptc\":",
            "            return ImageFile.ImageFile.load(self)",
            "",
            "        type, tile, box = self.tile[0]",
            "",
            "        encoding, offset = tile",
            "",
            "        self.fp.seek(offset)",
            "",
            "        # Copy image data to temporary file",
            "        o_fd, outfile = tempfile.mkstemp(text=False)",
            "        o = os.fdopen(o_fd)",
            "        if encoding == \"raw\":",
            "            # To simplify access to the extracted file,",
            "            # prepend a PPM header",
            "            o.write(\"P5\\n%d %d\\n255\\n\" % self.size)",
            "        while True:",
            "            type, size = self.field()",
            "            if type != (8, 10):",
            "                break",
            "            while size > 0:",
            "                s = self.fp.read(min(size, 8192))",
            "                if not s:",
            "                    break",
            "                o.write(s)",
            "                size = size - len(s)",
            "        o.close()",
            "",
            "        try:",
            "            try:",
            "                # fast",
            "                self.im = Image.core.open_ppm(outfile)",
            "            except:",
            "                # slightly slower",
            "                im = Image.open(outfile)",
            "                im.load()",
            "                self.im = im.im",
            "        finally:",
            "            try: os.unlink(outfile)",
            "            except: pass",
            "",
            "",
            "Image.register_open(\"IPTC\", IptcImageFile)",
            "",
            "Image.register_extension(\"IPTC\", \".iim\")",
            "",
            "##",
            "# Get IPTC information from TIFF, JPEG, or IPTC file.",
            "#",
            "# @param im An image containing IPTC data.",
            "# @return A dictionary containing IPTC information, or None if",
            "#     no IPTC information block was found.",
            "",
            "def getiptcinfo(im):",
            "",
            "    from PIL import TiffImagePlugin, JpegImagePlugin",
            "    import io",
            "",
            "    data = None",
            "",
            "    if isinstance(im, IptcImageFile):",
            "        # return info dictionary right away",
            "        return im.info",
            "",
            "    elif isinstance(im, JpegImagePlugin.JpegImageFile):",
            "        # extract the IPTC/NAA resource",
            "        try:",
            "            app = im.app[\"APP13\"]",
            "            if app[:14] == \"Photoshop 3.0\\x00\":",
            "                app = app[14:]",
            "                # parse the image resource block",
            "                offset = 0",
            "                while app[offset:offset+4] == \"8BIM\":",
            "                    offset = offset + 4",
            "                    # resource code",
            "                    code = JpegImagePlugin.i16(app, offset)",
            "                    offset = offset + 2",
            "                    # resource name (usually empty)",
            "                    name_len = i8(app[offset])",
            "                    name = app[offset+1:offset+1+name_len]",
            "                    offset = 1 + offset + name_len",
            "                    if offset & 1:",
            "                        offset = offset + 1",
            "                    # resource data block",
            "                    size = JpegImagePlugin.i32(app, offset)",
            "                    offset = offset + 4",
            "                    if code == 0x0404:",
            "                        # 0x0404 contains IPTC/NAA data",
            "                        data = app[offset:offset+size]",
            "                        break",
            "                    offset = offset + size",
            "                    if offset & 1:",
            "                        offset = offset + 1",
            "        except (AttributeError, KeyError):",
            "            pass",
            "",
            "    elif isinstance(im, TiffImagePlugin.TiffImageFile):",
            "        # get raw data from the IPTC/NAA tag (PhotoShop tags the data",
            "        # as 4-byte integers, so we cannot use the get method...)",
            "        try:",
            "            data = im.tag.tagdata[TiffImagePlugin.IPTC_NAA_CHUNK]",
            "        except (AttributeError, KeyError):",
            "            pass",
            "",
            "    if data is None:",
            "        return None # no properties",
            "",
            "    # create an IptcImagePlugin object without initializing it",
            "    class FakeImage:",
            "        pass",
            "    im = FakeImage()",
            "    im.__class__ = IptcImageFile",
            "",
            "    # parse the IPTC information chunk",
            "    im.info = {}",
            "    im.fp = io.BytesIO(data)",
            "",
            "    try:",
            "        im._open()",
            "    except (IndexError, KeyError):",
            "        pass # expected failure",
            "",
            "    return im.info"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "175": [
                "IptcImageFile",
                "load"
            ],
            "176": [
                "IptcImageFile",
                "load"
            ]
        },
        "addLocation": []
    },
    "PIL/JpegImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "         # ALTERNATIVE: handle JPEGs via the IJG command line utilities"
            },
            "1": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 345,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "         import tempfile, os"
            },
            "3": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        file = tempfile.mktemp()"
            },
            "4": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os.system(\"djpeg %s >%s\" % (self.filename, file))"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+        f, path = tempfile.mkstemp()"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+        os.close(f)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+        if os.path.exists(self.filename):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+            os.system(\"djpeg '%s' >'%s'\" % (self.filename, path))"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+        else:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+            raise ValueError(\"Invalid Filename\")"
            },
            "11": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 353,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "         try:"
            },
            "13": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.im = Image.core.open_ppm(file)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+            self.im = Image.core.open_ppm(path)"
            },
            "15": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         finally:"
            },
            "16": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            try: os.unlink(file)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+            try: os.unlink(path)"
            },
            "18": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "             except: pass"
            },
            "19": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 359,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "         self.mode = self.im.mode"
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# JPEG (JFIF) file handling",
            "#",
            "# See \"Digital Compression and Coding of Continous-Tone Still Images,",
            "# Part 1, Requirements and Guidelines\" (CCITT T.81 / ISO 10918-1)",
            "#",
            "# History:",
            "# 1995-09-09 fl   Created",
            "# 1995-09-13 fl   Added full parser",
            "# 1996-03-25 fl   Added hack to use the IJG command line utilities",
            "# 1996-05-05 fl   Workaround Photoshop 2.5 CMYK polarity bug",
            "# 1996-05-28 fl   Added draft support, JFIF version (0.1)",
            "# 1996-12-30 fl   Added encoder options, added progression property (0.2)",
            "# 1997-08-27 fl   Save mode 1 images as BW (0.3)",
            "# 1998-07-12 fl   Added YCbCr to draft and save methods (0.4)",
            "# 1998-10-19 fl   Don't hang on files using 16-bit DQT's (0.4.1)",
            "# 2001-04-16 fl   Extract DPI settings from JFIF files (0.4.2)",
            "# 2002-07-01 fl   Skip pad bytes before markers; identify Exif files (0.4.3)",
            "# 2003-04-25 fl   Added experimental EXIF decoder (0.5)",
            "# 2003-06-06 fl   Added experimental EXIF GPSinfo decoder",
            "# 2003-09-13 fl   Extract COM markers",
            "# 2009-09-06 fl   Added icc_profile support (from Florian Hoech)",
            "# 2009-03-06 fl   Changed CMYK handling; always use Adobe polarity (0.6)",
            "# 2009-03-08 fl   Added subsampling support (from Justin Huff).",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB.",
            "# Copyright (c) 1995-1996 by Fredrik Lundh.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "__version__ = \"0.6\"",
            "",
            "import array, struct",
            "from PIL import Image, ImageFile, _binary",
            "from PIL.JpegPresets import presets",
            "from PIL._util import isStringType",
            "",
            "i8 = _binary.i8",
            "o8 = _binary.o8",
            "i16 = _binary.i16be",
            "i32 = _binary.i32be",
            "",
            "#",
            "# Parser",
            "",
            "def Skip(self, marker):",
            "    n = i16(self.fp.read(2))-2",
            "    ImageFile._safe_read(self.fp, n)",
            "",
            "def APP(self, marker):",
            "    #",
            "    # Application marker.  Store these in the APP dictionary.",
            "    # Also look for well-known application markers.",
            "",
            "    n = i16(self.fp.read(2))-2",
            "    s = ImageFile._safe_read(self.fp, n)",
            "",
            "    app = \"APP%d\" % (marker&15)",
            "",
            "    self.app[app] = s # compatibility",
            "    self.applist.append((app, s))",
            "",
            "    if marker == 0xFFE0 and s[:4] == b\"JFIF\":",
            "        # extract JFIF information",
            "        self.info[\"jfif\"] = version = i16(s, 5) # version",
            "        self.info[\"jfif_version\"] = divmod(version, 256)",
            "        # extract JFIF properties",
            "        try:",
            "            jfif_unit = i8(s[7])",
            "            jfif_density = i16(s, 8), i16(s, 10)",
            "        except:",
            "            pass",
            "        else:",
            "            if jfif_unit == 1:",
            "                self.info[\"dpi\"] = jfif_density",
            "            self.info[\"jfif_unit\"] = jfif_unit",
            "            self.info[\"jfif_density\"] = jfif_density",
            "    elif marker == 0xFFE1 and s[:5] == b\"Exif\\0\":",
            "        # extract Exif information (incomplete)",
            "        self.info[\"exif\"] = s # FIXME: value will change",
            "    elif marker == 0xFFE2 and s[:5] == b\"FPXR\\0\":",
            "        # extract FlashPix information (incomplete)",
            "        self.info[\"flashpix\"] = s # FIXME: value will change",
            "    elif marker == 0xFFE2 and s[:12] == b\"ICC_PROFILE\\0\":",
            "        # Since an ICC profile can be larger than the maximum size of",
            "        # a JPEG marker (64K), we need provisions to split it into",
            "        # multiple markers. The format defined by the ICC specifies",
            "        # one or more APP2 markers containing the following data:",
            "        #   Identifying string      ASCII \"ICC_PROFILE\\0\"  (12 bytes)",
            "        #   Marker sequence number  1, 2, etc (1 byte)",
            "        #   Number of markers       Total of APP2's used (1 byte)",
            "        #   Profile data            (remainder of APP2 data)",
            "        # Decoders should use the marker sequence numbers to",
            "        # reassemble the profile, rather than assuming that the APP2",
            "        # markers appear in the correct sequence.",
            "        self.icclist.append(s)",
            "    elif marker == 0xFFEE and s[:5] == b\"Adobe\":",
            "        self.info[\"adobe\"] = i16(s, 5)",
            "        # extract Adobe custom properties",
            "        try:",
            "            adobe_transform = i8(s[1])",
            "        except:",
            "            pass",
            "        else:",
            "            self.info[\"adobe_transform\"] = adobe_transform",
            "",
            "def COM(self, marker):",
            "    #",
            "    # Comment marker.  Store these in the APP dictionary.",
            "",
            "    n = i16(self.fp.read(2))-2",
            "    s = ImageFile._safe_read(self.fp, n)",
            "",
            "    self.app[\"COM\"] = s # compatibility",
            "    self.applist.append((\"COM\", s))",
            "",
            "def SOF(self, marker):",
            "    #",
            "    # Start of frame marker.  Defines the size and mode of the",
            "    # image.  JPEG is colour blind, so we use some simple",
            "    # heuristics to map the number of layers to an appropriate",
            "    # mode.  Note that this could be made a bit brighter, by",
            "    # looking for JFIF and Adobe APP markers.",
            "",
            "    n = i16(self.fp.read(2))-2",
            "    s = ImageFile._safe_read(self.fp, n)",
            "    self.size = i16(s[3:]), i16(s[1:])",
            "",
            "    self.bits = i8(s[0])",
            "    if self.bits != 8:",
            "        raise SyntaxError(\"cannot handle %d-bit layers\" % self.bits)",
            "",
            "    self.layers = i8(s[5])",
            "    if self.layers == 1:",
            "        self.mode = \"L\"",
            "    elif self.layers == 3:",
            "        self.mode = \"RGB\"",
            "    elif self.layers == 4:",
            "        self.mode = \"CMYK\"",
            "    else:",
            "        raise SyntaxError(\"cannot handle %d-layer images\" % self.layers)",
            "",
            "    if marker in [0xFFC2, 0xFFC6, 0xFFCA, 0xFFCE]:",
            "        self.info[\"progressive\"] = self.info[\"progression\"] = 1",
            "",
            "    if self.icclist:",
            "        # fixup icc profile",
            "        self.icclist.sort() # sort by sequence number",
            "        if i8(self.icclist[0][13]) == len(self.icclist):",
            "            profile = []",
            "            for p in self.icclist:",
            "                profile.append(p[14:])",
            "            icc_profile = b\"\".join(profile)",
            "        else:",
            "            icc_profile = None # wrong number of fragments",
            "        self.info[\"icc_profile\"] = icc_profile",
            "        self.icclist = None",
            "",
            "    for i in range(6, len(s), 3):",
            "        t = s[i:i+3]",
            "        # 4-tuples: id, vsamp, hsamp, qtable",
            "        self.layer.append((t[0], i8(t[1])//16, i8(t[1])&15, i8(t[2])))",
            "",
            "def DQT(self, marker):",
            "    #",
            "    # Define quantization table.  Support baseline 8-bit tables",
            "    # only.  Note that there might be more than one table in",
            "    # each marker.",
            "",
            "    # FIXME: The quantization tables can be used to estimate the",
            "    # compression quality.",
            "",
            "    n = i16(self.fp.read(2))-2",
            "    s = ImageFile._safe_read(self.fp, n)",
            "    while len(s):",
            "        if len(s) < 65:",
            "            raise SyntaxError(\"bad quantization table marker\")",
            "        v = i8(s[0])",
            "        if v//16 == 0:",
            "            self.quantization[v&15] = array.array(\"b\", s[1:65])",
            "            s = s[65:]",
            "        else:",
            "            return # FIXME: add code to read 16-bit tables!",
            "            # raise SyntaxError, \"bad quantization table element size\"",
            "",
            "",
            "#",
            "# JPEG marker table",
            "",
            "MARKER = {",
            "    0xFFC0: (\"SOF0\", \"Baseline DCT\", SOF),",
            "    0xFFC1: (\"SOF1\", \"Extended Sequential DCT\", SOF),",
            "    0xFFC2: (\"SOF2\", \"Progressive DCT\", SOF),",
            "    0xFFC3: (\"SOF3\", \"Spatial lossless\", SOF),",
            "    0xFFC4: (\"DHT\", \"Define Huffman table\", Skip),",
            "    0xFFC5: (\"SOF5\", \"Differential sequential DCT\", SOF),",
            "    0xFFC6: (\"SOF6\", \"Differential progressive DCT\", SOF),",
            "    0xFFC7: (\"SOF7\", \"Differential spatial\", SOF),",
            "    0xFFC8: (\"JPG\", \"Extension\", None),",
            "    0xFFC9: (\"SOF9\", \"Extended sequential DCT (AC)\", SOF),",
            "    0xFFCA: (\"SOF10\", \"Progressive DCT (AC)\", SOF),",
            "    0xFFCB: (\"SOF11\", \"Spatial lossless DCT (AC)\", SOF),",
            "    0xFFCC: (\"DAC\", \"Define arithmetic coding conditioning\", Skip),",
            "    0xFFCD: (\"SOF13\", \"Differential sequential DCT (AC)\", SOF),",
            "    0xFFCE: (\"SOF14\", \"Differential progressive DCT (AC)\", SOF),",
            "    0xFFCF: (\"SOF15\", \"Differential spatial (AC)\", SOF),",
            "    0xFFD0: (\"RST0\", \"Restart 0\", None),",
            "    0xFFD1: (\"RST1\", \"Restart 1\", None),",
            "    0xFFD2: (\"RST2\", \"Restart 2\", None),",
            "    0xFFD3: (\"RST3\", \"Restart 3\", None),",
            "    0xFFD4: (\"RST4\", \"Restart 4\", None),",
            "    0xFFD5: (\"RST5\", \"Restart 5\", None),",
            "    0xFFD6: (\"RST6\", \"Restart 6\", None),",
            "    0xFFD7: (\"RST7\", \"Restart 7\", None),",
            "    0xFFD8: (\"SOI\", \"Start of image\", None),",
            "    0xFFD9: (\"EOI\", \"End of image\", None),",
            "    0xFFDA: (\"SOS\", \"Start of scan\", Skip),",
            "    0xFFDB: (\"DQT\", \"Define quantization table\", DQT),",
            "    0xFFDC: (\"DNL\", \"Define number of lines\", Skip),",
            "    0xFFDD: (\"DRI\", \"Define restart interval\", Skip),",
            "    0xFFDE: (\"DHP\", \"Define hierarchical progression\", SOF),",
            "    0xFFDF: (\"EXP\", \"Expand reference component\", Skip),",
            "    0xFFE0: (\"APP0\", \"Application segment 0\", APP),",
            "    0xFFE1: (\"APP1\", \"Application segment 1\", APP),",
            "    0xFFE2: (\"APP2\", \"Application segment 2\", APP),",
            "    0xFFE3: (\"APP3\", \"Application segment 3\", APP),",
            "    0xFFE4: (\"APP4\", \"Application segment 4\", APP),",
            "    0xFFE5: (\"APP5\", \"Application segment 5\", APP),",
            "    0xFFE6: (\"APP6\", \"Application segment 6\", APP),",
            "    0xFFE7: (\"APP7\", \"Application segment 7\", APP),",
            "    0xFFE8: (\"APP8\", \"Application segment 8\", APP),",
            "    0xFFE9: (\"APP9\", \"Application segment 9\", APP),",
            "    0xFFEA: (\"APP10\", \"Application segment 10\", APP),",
            "    0xFFEB: (\"APP11\", \"Application segment 11\", APP),",
            "    0xFFEC: (\"APP12\", \"Application segment 12\", APP),",
            "    0xFFED: (\"APP13\", \"Application segment 13\", APP),",
            "    0xFFEE: (\"APP14\", \"Application segment 14\", APP),",
            "    0xFFEF: (\"APP15\", \"Application segment 15\", APP),",
            "    0xFFF0: (\"JPG0\", \"Extension 0\", None),",
            "    0xFFF1: (\"JPG1\", \"Extension 1\", None),",
            "    0xFFF2: (\"JPG2\", \"Extension 2\", None),",
            "    0xFFF3: (\"JPG3\", \"Extension 3\", None),",
            "    0xFFF4: (\"JPG4\", \"Extension 4\", None),",
            "    0xFFF5: (\"JPG5\", \"Extension 5\", None),",
            "    0xFFF6: (\"JPG6\", \"Extension 6\", None),",
            "    0xFFF7: (\"JPG7\", \"Extension 7\", None),",
            "    0xFFF8: (\"JPG8\", \"Extension 8\", None),",
            "    0xFFF9: (\"JPG9\", \"Extension 9\", None),",
            "    0xFFFA: (\"JPG10\", \"Extension 10\", None),",
            "    0xFFFB: (\"JPG11\", \"Extension 11\", None),",
            "    0xFFFC: (\"JPG12\", \"Extension 12\", None),",
            "    0xFFFD: (\"JPG13\", \"Extension 13\", None),",
            "    0xFFFE: (\"COM\", \"Comment\", COM)",
            "}",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[0:1] == b\"\\377\"",
            "",
            "##",
            "# Image plugin for JPEG and JFIF images.",
            "",
            "class JpegImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"JPEG\"",
            "    format_description = \"JPEG (ISO 10918)\"",
            "",
            "    def _open(self):",
            "",
            "        s = self.fp.read(1)",
            "",
            "        if i8(s[0]) != 255:",
            "            raise SyntaxError(\"not a JPEG file\")",
            "",
            "        # Create attributes",
            "        self.bits = self.layers = 0",
            "",
            "        # JPEG specifics (internal)",
            "        self.layer = []",
            "        self.huffman_dc = {}",
            "        self.huffman_ac = {}",
            "        self.quantization = {}",
            "        self.app = {} # compatibility",
            "        self.applist = []",
            "        self.icclist = []",
            "",
            "        while True:",
            "",
            "            s = s + self.fp.read(1)",
            "",
            "            i = i16(s)",
            "",
            "            if i in MARKER:",
            "                name, description, handler = MARKER[i]",
            "                # print hex(i), name, description",
            "                if handler is not None:",
            "                    handler(self, i)",
            "                if i == 0xFFDA: # start of scan",
            "                    rawmode = self.mode",
            "                    if self.mode == \"CMYK\":",
            "                        rawmode = \"CMYK;I\" # assume adobe conventions",
            "                    self.tile = [(\"jpeg\", (0,0) + self.size, 0, (rawmode, \"\"))]",
            "                    # self.__offset = self.fp.tell()",
            "                    break",
            "                s = self.fp.read(1)",
            "            elif i == 0 or i == 65535:",
            "                # padded marker or junk; move on",
            "                s = \"\\xff\"",
            "            else:",
            "                raise SyntaxError(\"no marker found\")",
            "",
            "    def draft(self, mode, size):",
            "",
            "        if len(self.tile) != 1:",
            "            return",
            "",
            "        d, e, o, a = self.tile[0]",
            "        scale = 0",
            "",
            "        if a[0] == \"RGB\" and mode in [\"L\", \"YCbCr\"]:",
            "            self.mode = mode",
            "            a = mode, \"\"",
            "",
            "        if size:",
            "            scale = max(self.size[0] // size[0], self.size[1] // size[1])",
            "            for s in [8, 4, 2, 1]:",
            "                if scale >= s:",
            "                    break",
            "            e = e[0], e[1], (e[2]-e[0]+s-1)//s+e[0], (e[3]-e[1]+s-1)//s+e[1]",
            "            self.size = ((self.size[0]+s-1)//s, (self.size[1]+s-1)//s)",
            "            scale = s",
            "",
            "        self.tile = [(d, e, o, a)]",
            "        self.decoderconfig = (scale, 1)",
            "",
            "        return self",
            "",
            "    def load_djpeg(self):",
            "",
            "        # ALTERNATIVE: handle JPEGs via the IJG command line utilities",
            "",
            "        import tempfile, os",
            "        file = tempfile.mktemp()",
            "        os.system(\"djpeg %s >%s\" % (self.filename, file))",
            "",
            "        try:",
            "            self.im = Image.core.open_ppm(file)",
            "        finally:",
            "            try: os.unlink(file)",
            "            except: pass",
            "",
            "        self.mode = self.im.mode",
            "        self.size = self.im.size",
            "",
            "        self.tile = []",
            "",
            "    def _getexif(self):",
            "        return _getexif(self)",
            "",
            "",
            "def _getexif(self):",
            "    # Extract EXIF information.  This method is highly experimental,",
            "    # and is likely to be replaced with something better in a future",
            "    # version.",
            "    from PIL import TiffImagePlugin",
            "    import io",
            "    def fixup(value):",
            "        if len(value) == 1:",
            "            return value[0]",
            "        return value",
            "    # The EXIF record consists of a TIFF file embedded in a JPEG",
            "    # application marker (!).",
            "    try:",
            "        data = self.info[\"exif\"]",
            "    except KeyError:",
            "        return None",
            "    file = io.BytesIO(data[6:])",
            "    head = file.read(8)",
            "    exif = {}",
            "    # process dictionary",
            "    info = TiffImagePlugin.ImageFileDirectory(head)",
            "    info.load(file)",
            "    for key, value in info.items():",
            "        exif[key] = fixup(value)",
            "    # get exif extension",
            "    try:",
            "        file.seek(exif[0x8769])",
            "    except KeyError:",
            "        pass",
            "    else:",
            "        info = TiffImagePlugin.ImageFileDirectory(head)",
            "        info.load(file)",
            "        for key, value in info.items():",
            "            exif[key] = fixup(value)",
            "    # get gpsinfo extension",
            "    try:",
            "        file.seek(exif[0x8825])",
            "    except KeyError:",
            "        pass",
            "    else:",
            "        info = TiffImagePlugin.ImageFileDirectory(head)",
            "        info.load(file)",
            "        exif[0x8825] = gps = {}",
            "        for key, value in info.items():",
            "            gps[key] = fixup(value)",
            "    return exif",
            "",
            "# --------------------------------------------------------------------",
            "# stuff to save JPEG files",
            "",
            "RAWMODE = {",
            "    \"1\": \"L\",",
            "    \"L\": \"L\",",
            "    \"RGB\": \"RGB\",",
            "    \"RGBA\": \"RGB\",",
            "    \"RGBX\": \"RGB\",",
            "    \"CMYK\": \"CMYK;I\", # assume adobe conventions",
            "    \"YCbCr\": \"YCbCr\",",
            "}",
            "",
            "zigzag_index = ( 0,  1,  5,  6, 14, 15, 27, 28,",
            "                 2,  4,  7, 13, 16, 26, 29, 42,",
            "                 3,  8, 12, 17, 25, 30, 41, 43,",
            "                 9, 11, 18, 24, 31, 40, 44, 53,",
            "                10, 19, 23, 32, 39, 45, 52, 54,",
            "                20, 22, 33, 38, 46, 51, 55, 60,",
            "                21, 34, 37, 47, 50, 56, 59, 61,",
            "                35, 36, 48, 49, 57, 58, 62, 63)",
            "",
            "samplings = {",
            "             (1, 1, 1, 1, 1, 1): 0,",
            "             (2, 1, 1, 1, 1, 1): 1,",
            "             (2, 2, 1, 1, 1, 1): 2,",
            "            }",
            "",
            "def convert_dict_qtables(qtables):",
            "    qtables = [qtables[key] for key in xrange(len(qtables)) if qtables.has_key(key)]",
            "    for idx, table in enumerate(qtables):",
            "        qtables[idx] = [table[i] for i in zigzag_index]",
            "    return qtables",
            "",
            "def get_sampling(im):",
            "    sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]",
            "    return samplings.get(sampling, -1)",
            "",
            "def _save(im, fp, filename):",
            "",
            "    try:",
            "        rawmode = RAWMODE[im.mode]",
            "    except KeyError:",
            "        raise IOError(\"cannot write mode %s as JPEG\" % im.mode)",
            "",
            "    info = im.encoderinfo",
            "",
            "    dpi = info.get(\"dpi\", (0, 0))",
            "",
            "    quality = info.get(\"quality\", 0)",
            "    subsampling = info.get(\"subsampling\", -1)",
            "    qtables = info.get(\"qtables\")",
            "",
            "    if quality == \"keep\":",
            "        quality = 0",
            "        subsampling = \"keep\"",
            "        qtables = \"keep\"",
            "    elif quality in presets:",
            "        preset = presets[quality]",
            "        quality = 0",
            "        subsampling = preset.get('subsampling', -1)",
            "        qtables = preset.get('quantization')",
            "    elif not isinstance(quality, int):",
            "        raise ValueError(\"Invalid quality setting\")",
            "    else:",
            "        if subsampling in presets:",
            "            subsampling = presets[subsampling].get('subsampling', -1)",
            "        if qtables in presets:",
            "            qtables = presets[qtables].get('quantization')",
            "",
            "    if subsampling == \"4:4:4\":",
            "        subsampling = 0",
            "    elif subsampling == \"4:2:2\":",
            "        subsampling = 1",
            "    elif subsampling == \"4:1:1\":",
            "        subsampling = 2",
            "    elif subsampling == \"keep\":",
            "        if im.format != \"JPEG\":",
            "            raise ValueError(\"Cannot use 'keep' when original image is not a JPEG\")",
            "        subsampling = get_sampling(im)",
            "",
            "    def validate_qtables(qtables):",
            "        if qtables is None:",
            "            return qtables",
            "        if isStringType(qtables):",
            "            try:",
            "                lines = [int(num) for line in qtables.splitlines()",
            "                         for num in line.split('#', 1)[0].split()]",
            "            except ValueError:",
            "                raise ValueError(\"Invalid quantization table\")",
            "            else:",
            "                qtables = [lines[s:s+64] for s in xrange(0, len(lines), 64)]",
            "        if isinstance(qtables, (tuple, list, dict)):",
            "            if isinstance(qtables, dict):",
            "                qtables = convert_dict_qtables(qtables)",
            "            elif isinstance(qtables, tuple):",
            "                qtables = list(qtables)",
            "            if not (0 < len(qtables) < 5):",
            "                raise ValueError(\"None or too many quantization tables\")",
            "            for idx, table in enumerate(qtables):",
            "                try:",
            "                    if len(table) != 64:",
            "                        raise",
            "                    table = array.array('b', table)",
            "                except TypeError:",
            "                    raise ValueError(\"Invalid quantization table\")",
            "                else:",
            "                    qtables[idx] = list(table)",
            "            return qtables",
            "",
            "    if qtables == \"keep\":",
            "        if im.format != \"JPEG\":",
            "            raise ValueError(\"Cannot use 'keep' when original image is not a JPEG\")",
            "        qtables = getattr(im, \"quantization\", None)",
            "    qtables = validate_qtables(qtables)",
            "",
            "    extra = b\"\"",
            "",
            "    icc_profile = info.get(\"icc_profile\")",
            "    if icc_profile:",
            "        ICC_OVERHEAD_LEN = 14",
            "        MAX_BYTES_IN_MARKER = 65533",
            "        MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN",
            "        markers = []",
            "        while icc_profile:",
            "            markers.append(icc_profile[:MAX_DATA_BYTES_IN_MARKER])",
            "            icc_profile = icc_profile[MAX_DATA_BYTES_IN_MARKER:]",
            "        i = 1",
            "        for marker in markers:",
            "            size = struct.pack(\">H\", 2 + ICC_OVERHEAD_LEN + len(marker))",
            "            extra = extra + (b\"\\xFF\\xE2\" + size + b\"ICC_PROFILE\\0\" + o8(i) + o8(len(markers)) + marker)",
            "            i = i + 1",
            "",
            "    # get keyword arguments",
            "    im.encoderconfig = (",
            "        quality,",
            "        # \"progressive\" is the official name, but older documentation",
            "        # says \"progression\"",
            "        # FIXME: issue a warning if the wrong form is used (post-1.1.7)",
            "        \"progressive\" in info or \"progression\" in info,",
            "        info.get(\"smooth\", 0),",
            "        \"optimize\" in info,",
            "        info.get(\"streamtype\", 0),",
            "        dpi[0], dpi[1],",
            "        subsampling,",
            "        qtables,",
            "        extra,",
            "        info.get(\"exif\", b\"\")",
            "        )",
            "",
            "",
            "    # if we optimize, libjpeg needs a buffer big enough to hold the whole image in a shot.",
            "    # Guessing on the size, at im.size bytes. (raw pizel size is channels*size, this",
            "    # is a value that's been used in a django patch.",
            "    # https://github.com/jdriscoll/django-imagekit/issues/50",
            "    bufsize=0",
            "    if \"optimize\" in info or \"progressive\" in info or \"progression\" in info:",
            "        bufsize = im.size[0]*im.size[1]",
            "",
            "    # The exif info needs to be written as one block, + APP1, + one spare byte.",
            "    # Ensure that our buffer is big enough",
            "    bufsize = max(ImageFile.MAXBLOCK, bufsize, len(info.get(\"exif\",b\"\")) + 5 )",
            "",
            "    ImageFile._save(im, fp, [(\"jpeg\", (0,0)+im.size, 0, rawmode)], bufsize)",
            "",
            "def _save_cjpeg(im, fp, filename):",
            "    # ALTERNATIVE: handle JPEGs via the IJG command line utilities.",
            "    import os",
            "    file = im._dump()",
            "    os.system(\"cjpeg %s >%s\" % (file, filename))",
            "    try: os.unlink(file)",
            "    except: pass",
            "",
            "# -------------------------------------------------------------------q-",
            "# Registry stuff",
            "",
            "Image.register_open(\"JPEG\", JpegImageFile, _accept)",
            "Image.register_save(\"JPEG\", _save)",
            "",
            "Image.register_extension(\"JPEG\", \".jfif\")",
            "Image.register_extension(\"JPEG\", \".jpe\")",
            "Image.register_extension(\"JPEG\", \".jpg\")",
            "Image.register_extension(\"JPEG\", \".jpeg\")",
            "",
            "Image.register_mime(\"JPEG\", \"image/jpeg\")"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# JPEG (JFIF) file handling",
            "#",
            "# See \"Digital Compression and Coding of Continous-Tone Still Images,",
            "# Part 1, Requirements and Guidelines\" (CCITT T.81 / ISO 10918-1)",
            "#",
            "# History:",
            "# 1995-09-09 fl   Created",
            "# 1995-09-13 fl   Added full parser",
            "# 1996-03-25 fl   Added hack to use the IJG command line utilities",
            "# 1996-05-05 fl   Workaround Photoshop 2.5 CMYK polarity bug",
            "# 1996-05-28 fl   Added draft support, JFIF version (0.1)",
            "# 1996-12-30 fl   Added encoder options, added progression property (0.2)",
            "# 1997-08-27 fl   Save mode 1 images as BW (0.3)",
            "# 1998-07-12 fl   Added YCbCr to draft and save methods (0.4)",
            "# 1998-10-19 fl   Don't hang on files using 16-bit DQT's (0.4.1)",
            "# 2001-04-16 fl   Extract DPI settings from JFIF files (0.4.2)",
            "# 2002-07-01 fl   Skip pad bytes before markers; identify Exif files (0.4.3)",
            "# 2003-04-25 fl   Added experimental EXIF decoder (0.5)",
            "# 2003-06-06 fl   Added experimental EXIF GPSinfo decoder",
            "# 2003-09-13 fl   Extract COM markers",
            "# 2009-09-06 fl   Added icc_profile support (from Florian Hoech)",
            "# 2009-03-06 fl   Changed CMYK handling; always use Adobe polarity (0.6)",
            "# 2009-03-08 fl   Added subsampling support (from Justin Huff).",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB.",
            "# Copyright (c) 1995-1996 by Fredrik Lundh.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "__version__ = \"0.6\"",
            "",
            "import array, struct",
            "from PIL import Image, ImageFile, _binary",
            "from PIL.JpegPresets import presets",
            "from PIL._util import isStringType",
            "",
            "i8 = _binary.i8",
            "o8 = _binary.o8",
            "i16 = _binary.i16be",
            "i32 = _binary.i32be",
            "",
            "#",
            "# Parser",
            "",
            "def Skip(self, marker):",
            "    n = i16(self.fp.read(2))-2",
            "    ImageFile._safe_read(self.fp, n)",
            "",
            "def APP(self, marker):",
            "    #",
            "    # Application marker.  Store these in the APP dictionary.",
            "    # Also look for well-known application markers.",
            "",
            "    n = i16(self.fp.read(2))-2",
            "    s = ImageFile._safe_read(self.fp, n)",
            "",
            "    app = \"APP%d\" % (marker&15)",
            "",
            "    self.app[app] = s # compatibility",
            "    self.applist.append((app, s))",
            "",
            "    if marker == 0xFFE0 and s[:4] == b\"JFIF\":",
            "        # extract JFIF information",
            "        self.info[\"jfif\"] = version = i16(s, 5) # version",
            "        self.info[\"jfif_version\"] = divmod(version, 256)",
            "        # extract JFIF properties",
            "        try:",
            "            jfif_unit = i8(s[7])",
            "            jfif_density = i16(s, 8), i16(s, 10)",
            "        except:",
            "            pass",
            "        else:",
            "            if jfif_unit == 1:",
            "                self.info[\"dpi\"] = jfif_density",
            "            self.info[\"jfif_unit\"] = jfif_unit",
            "            self.info[\"jfif_density\"] = jfif_density",
            "    elif marker == 0xFFE1 and s[:5] == b\"Exif\\0\":",
            "        # extract Exif information (incomplete)",
            "        self.info[\"exif\"] = s # FIXME: value will change",
            "    elif marker == 0xFFE2 and s[:5] == b\"FPXR\\0\":",
            "        # extract FlashPix information (incomplete)",
            "        self.info[\"flashpix\"] = s # FIXME: value will change",
            "    elif marker == 0xFFE2 and s[:12] == b\"ICC_PROFILE\\0\":",
            "        # Since an ICC profile can be larger than the maximum size of",
            "        # a JPEG marker (64K), we need provisions to split it into",
            "        # multiple markers. The format defined by the ICC specifies",
            "        # one or more APP2 markers containing the following data:",
            "        #   Identifying string      ASCII \"ICC_PROFILE\\0\"  (12 bytes)",
            "        #   Marker sequence number  1, 2, etc (1 byte)",
            "        #   Number of markers       Total of APP2's used (1 byte)",
            "        #   Profile data            (remainder of APP2 data)",
            "        # Decoders should use the marker sequence numbers to",
            "        # reassemble the profile, rather than assuming that the APP2",
            "        # markers appear in the correct sequence.",
            "        self.icclist.append(s)",
            "    elif marker == 0xFFEE and s[:5] == b\"Adobe\":",
            "        self.info[\"adobe\"] = i16(s, 5)",
            "        # extract Adobe custom properties",
            "        try:",
            "            adobe_transform = i8(s[1])",
            "        except:",
            "            pass",
            "        else:",
            "            self.info[\"adobe_transform\"] = adobe_transform",
            "",
            "def COM(self, marker):",
            "    #",
            "    # Comment marker.  Store these in the APP dictionary.",
            "",
            "    n = i16(self.fp.read(2))-2",
            "    s = ImageFile._safe_read(self.fp, n)",
            "",
            "    self.app[\"COM\"] = s # compatibility",
            "    self.applist.append((\"COM\", s))",
            "",
            "def SOF(self, marker):",
            "    #",
            "    # Start of frame marker.  Defines the size and mode of the",
            "    # image.  JPEG is colour blind, so we use some simple",
            "    # heuristics to map the number of layers to an appropriate",
            "    # mode.  Note that this could be made a bit brighter, by",
            "    # looking for JFIF and Adobe APP markers.",
            "",
            "    n = i16(self.fp.read(2))-2",
            "    s = ImageFile._safe_read(self.fp, n)",
            "    self.size = i16(s[3:]), i16(s[1:])",
            "",
            "    self.bits = i8(s[0])",
            "    if self.bits != 8:",
            "        raise SyntaxError(\"cannot handle %d-bit layers\" % self.bits)",
            "",
            "    self.layers = i8(s[5])",
            "    if self.layers == 1:",
            "        self.mode = \"L\"",
            "    elif self.layers == 3:",
            "        self.mode = \"RGB\"",
            "    elif self.layers == 4:",
            "        self.mode = \"CMYK\"",
            "    else:",
            "        raise SyntaxError(\"cannot handle %d-layer images\" % self.layers)",
            "",
            "    if marker in [0xFFC2, 0xFFC6, 0xFFCA, 0xFFCE]:",
            "        self.info[\"progressive\"] = self.info[\"progression\"] = 1",
            "",
            "    if self.icclist:",
            "        # fixup icc profile",
            "        self.icclist.sort() # sort by sequence number",
            "        if i8(self.icclist[0][13]) == len(self.icclist):",
            "            profile = []",
            "            for p in self.icclist:",
            "                profile.append(p[14:])",
            "            icc_profile = b\"\".join(profile)",
            "        else:",
            "            icc_profile = None # wrong number of fragments",
            "        self.info[\"icc_profile\"] = icc_profile",
            "        self.icclist = None",
            "",
            "    for i in range(6, len(s), 3):",
            "        t = s[i:i+3]",
            "        # 4-tuples: id, vsamp, hsamp, qtable",
            "        self.layer.append((t[0], i8(t[1])//16, i8(t[1])&15, i8(t[2])))",
            "",
            "def DQT(self, marker):",
            "    #",
            "    # Define quantization table.  Support baseline 8-bit tables",
            "    # only.  Note that there might be more than one table in",
            "    # each marker.",
            "",
            "    # FIXME: The quantization tables can be used to estimate the",
            "    # compression quality.",
            "",
            "    n = i16(self.fp.read(2))-2",
            "    s = ImageFile._safe_read(self.fp, n)",
            "    while len(s):",
            "        if len(s) < 65:",
            "            raise SyntaxError(\"bad quantization table marker\")",
            "        v = i8(s[0])",
            "        if v//16 == 0:",
            "            self.quantization[v&15] = array.array(\"b\", s[1:65])",
            "            s = s[65:]",
            "        else:",
            "            return # FIXME: add code to read 16-bit tables!",
            "            # raise SyntaxError, \"bad quantization table element size\"",
            "",
            "",
            "#",
            "# JPEG marker table",
            "",
            "MARKER = {",
            "    0xFFC0: (\"SOF0\", \"Baseline DCT\", SOF),",
            "    0xFFC1: (\"SOF1\", \"Extended Sequential DCT\", SOF),",
            "    0xFFC2: (\"SOF2\", \"Progressive DCT\", SOF),",
            "    0xFFC3: (\"SOF3\", \"Spatial lossless\", SOF),",
            "    0xFFC4: (\"DHT\", \"Define Huffman table\", Skip),",
            "    0xFFC5: (\"SOF5\", \"Differential sequential DCT\", SOF),",
            "    0xFFC6: (\"SOF6\", \"Differential progressive DCT\", SOF),",
            "    0xFFC7: (\"SOF7\", \"Differential spatial\", SOF),",
            "    0xFFC8: (\"JPG\", \"Extension\", None),",
            "    0xFFC9: (\"SOF9\", \"Extended sequential DCT (AC)\", SOF),",
            "    0xFFCA: (\"SOF10\", \"Progressive DCT (AC)\", SOF),",
            "    0xFFCB: (\"SOF11\", \"Spatial lossless DCT (AC)\", SOF),",
            "    0xFFCC: (\"DAC\", \"Define arithmetic coding conditioning\", Skip),",
            "    0xFFCD: (\"SOF13\", \"Differential sequential DCT (AC)\", SOF),",
            "    0xFFCE: (\"SOF14\", \"Differential progressive DCT (AC)\", SOF),",
            "    0xFFCF: (\"SOF15\", \"Differential spatial (AC)\", SOF),",
            "    0xFFD0: (\"RST0\", \"Restart 0\", None),",
            "    0xFFD1: (\"RST1\", \"Restart 1\", None),",
            "    0xFFD2: (\"RST2\", \"Restart 2\", None),",
            "    0xFFD3: (\"RST3\", \"Restart 3\", None),",
            "    0xFFD4: (\"RST4\", \"Restart 4\", None),",
            "    0xFFD5: (\"RST5\", \"Restart 5\", None),",
            "    0xFFD6: (\"RST6\", \"Restart 6\", None),",
            "    0xFFD7: (\"RST7\", \"Restart 7\", None),",
            "    0xFFD8: (\"SOI\", \"Start of image\", None),",
            "    0xFFD9: (\"EOI\", \"End of image\", None),",
            "    0xFFDA: (\"SOS\", \"Start of scan\", Skip),",
            "    0xFFDB: (\"DQT\", \"Define quantization table\", DQT),",
            "    0xFFDC: (\"DNL\", \"Define number of lines\", Skip),",
            "    0xFFDD: (\"DRI\", \"Define restart interval\", Skip),",
            "    0xFFDE: (\"DHP\", \"Define hierarchical progression\", SOF),",
            "    0xFFDF: (\"EXP\", \"Expand reference component\", Skip),",
            "    0xFFE0: (\"APP0\", \"Application segment 0\", APP),",
            "    0xFFE1: (\"APP1\", \"Application segment 1\", APP),",
            "    0xFFE2: (\"APP2\", \"Application segment 2\", APP),",
            "    0xFFE3: (\"APP3\", \"Application segment 3\", APP),",
            "    0xFFE4: (\"APP4\", \"Application segment 4\", APP),",
            "    0xFFE5: (\"APP5\", \"Application segment 5\", APP),",
            "    0xFFE6: (\"APP6\", \"Application segment 6\", APP),",
            "    0xFFE7: (\"APP7\", \"Application segment 7\", APP),",
            "    0xFFE8: (\"APP8\", \"Application segment 8\", APP),",
            "    0xFFE9: (\"APP9\", \"Application segment 9\", APP),",
            "    0xFFEA: (\"APP10\", \"Application segment 10\", APP),",
            "    0xFFEB: (\"APP11\", \"Application segment 11\", APP),",
            "    0xFFEC: (\"APP12\", \"Application segment 12\", APP),",
            "    0xFFED: (\"APP13\", \"Application segment 13\", APP),",
            "    0xFFEE: (\"APP14\", \"Application segment 14\", APP),",
            "    0xFFEF: (\"APP15\", \"Application segment 15\", APP),",
            "    0xFFF0: (\"JPG0\", \"Extension 0\", None),",
            "    0xFFF1: (\"JPG1\", \"Extension 1\", None),",
            "    0xFFF2: (\"JPG2\", \"Extension 2\", None),",
            "    0xFFF3: (\"JPG3\", \"Extension 3\", None),",
            "    0xFFF4: (\"JPG4\", \"Extension 4\", None),",
            "    0xFFF5: (\"JPG5\", \"Extension 5\", None),",
            "    0xFFF6: (\"JPG6\", \"Extension 6\", None),",
            "    0xFFF7: (\"JPG7\", \"Extension 7\", None),",
            "    0xFFF8: (\"JPG8\", \"Extension 8\", None),",
            "    0xFFF9: (\"JPG9\", \"Extension 9\", None),",
            "    0xFFFA: (\"JPG10\", \"Extension 10\", None),",
            "    0xFFFB: (\"JPG11\", \"Extension 11\", None),",
            "    0xFFFC: (\"JPG12\", \"Extension 12\", None),",
            "    0xFFFD: (\"JPG13\", \"Extension 13\", None),",
            "    0xFFFE: (\"COM\", \"Comment\", COM)",
            "}",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[0:1] == b\"\\377\"",
            "",
            "##",
            "# Image plugin for JPEG and JFIF images.",
            "",
            "class JpegImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"JPEG\"",
            "    format_description = \"JPEG (ISO 10918)\"",
            "",
            "    def _open(self):",
            "",
            "        s = self.fp.read(1)",
            "",
            "        if i8(s[0]) != 255:",
            "            raise SyntaxError(\"not a JPEG file\")",
            "",
            "        # Create attributes",
            "        self.bits = self.layers = 0",
            "",
            "        # JPEG specifics (internal)",
            "        self.layer = []",
            "        self.huffman_dc = {}",
            "        self.huffman_ac = {}",
            "        self.quantization = {}",
            "        self.app = {} # compatibility",
            "        self.applist = []",
            "        self.icclist = []",
            "",
            "        while True:",
            "",
            "            s = s + self.fp.read(1)",
            "",
            "            i = i16(s)",
            "",
            "            if i in MARKER:",
            "                name, description, handler = MARKER[i]",
            "                # print hex(i), name, description",
            "                if handler is not None:",
            "                    handler(self, i)",
            "                if i == 0xFFDA: # start of scan",
            "                    rawmode = self.mode",
            "                    if self.mode == \"CMYK\":",
            "                        rawmode = \"CMYK;I\" # assume adobe conventions",
            "                    self.tile = [(\"jpeg\", (0,0) + self.size, 0, (rawmode, \"\"))]",
            "                    # self.__offset = self.fp.tell()",
            "                    break",
            "                s = self.fp.read(1)",
            "            elif i == 0 or i == 65535:",
            "                # padded marker or junk; move on",
            "                s = \"\\xff\"",
            "            else:",
            "                raise SyntaxError(\"no marker found\")",
            "",
            "    def draft(self, mode, size):",
            "",
            "        if len(self.tile) != 1:",
            "            return",
            "",
            "        d, e, o, a = self.tile[0]",
            "        scale = 0",
            "",
            "        if a[0] == \"RGB\" and mode in [\"L\", \"YCbCr\"]:",
            "            self.mode = mode",
            "            a = mode, \"\"",
            "",
            "        if size:",
            "            scale = max(self.size[0] // size[0], self.size[1] // size[1])",
            "            for s in [8, 4, 2, 1]:",
            "                if scale >= s:",
            "                    break",
            "            e = e[0], e[1], (e[2]-e[0]+s-1)//s+e[0], (e[3]-e[1]+s-1)//s+e[1]",
            "            self.size = ((self.size[0]+s-1)//s, (self.size[1]+s-1)//s)",
            "            scale = s",
            "",
            "        self.tile = [(d, e, o, a)]",
            "        self.decoderconfig = (scale, 1)",
            "",
            "        return self",
            "",
            "    def load_djpeg(self):",
            "",
            "        # ALTERNATIVE: handle JPEGs via the IJG command line utilities",
            "",
            "        import tempfile, os",
            "        f, path = tempfile.mkstemp()",
            "        os.close(f)",
            "        if os.path.exists(self.filename):",
            "            os.system(\"djpeg '%s' >'%s'\" % (self.filename, path))",
            "        else:",
            "            raise ValueError(\"Invalid Filename\")",
            "",
            "        try:",
            "            self.im = Image.core.open_ppm(path)",
            "        finally:",
            "            try: os.unlink(path)",
            "            except: pass",
            "",
            "        self.mode = self.im.mode",
            "        self.size = self.im.size",
            "",
            "        self.tile = []",
            "",
            "    def _getexif(self):",
            "        return _getexif(self)",
            "",
            "",
            "def _getexif(self):",
            "    # Extract EXIF information.  This method is highly experimental,",
            "    # and is likely to be replaced with something better in a future",
            "    # version.",
            "    from PIL import TiffImagePlugin",
            "    import io",
            "    def fixup(value):",
            "        if len(value) == 1:",
            "            return value[0]",
            "        return value",
            "    # The EXIF record consists of a TIFF file embedded in a JPEG",
            "    # application marker (!).",
            "    try:",
            "        data = self.info[\"exif\"]",
            "    except KeyError:",
            "        return None",
            "    file = io.BytesIO(data[6:])",
            "    head = file.read(8)",
            "    exif = {}",
            "    # process dictionary",
            "    info = TiffImagePlugin.ImageFileDirectory(head)",
            "    info.load(file)",
            "    for key, value in info.items():",
            "        exif[key] = fixup(value)",
            "    # get exif extension",
            "    try:",
            "        file.seek(exif[0x8769])",
            "    except KeyError:",
            "        pass",
            "    else:",
            "        info = TiffImagePlugin.ImageFileDirectory(head)",
            "        info.load(file)",
            "        for key, value in info.items():",
            "            exif[key] = fixup(value)",
            "    # get gpsinfo extension",
            "    try:",
            "        file.seek(exif[0x8825])",
            "    except KeyError:",
            "        pass",
            "    else:",
            "        info = TiffImagePlugin.ImageFileDirectory(head)",
            "        info.load(file)",
            "        exif[0x8825] = gps = {}",
            "        for key, value in info.items():",
            "            gps[key] = fixup(value)",
            "    return exif",
            "",
            "# --------------------------------------------------------------------",
            "# stuff to save JPEG files",
            "",
            "RAWMODE = {",
            "    \"1\": \"L\",",
            "    \"L\": \"L\",",
            "    \"RGB\": \"RGB\",",
            "    \"RGBA\": \"RGB\",",
            "    \"RGBX\": \"RGB\",",
            "    \"CMYK\": \"CMYK;I\", # assume adobe conventions",
            "    \"YCbCr\": \"YCbCr\",",
            "}",
            "",
            "zigzag_index = ( 0,  1,  5,  6, 14, 15, 27, 28,",
            "                 2,  4,  7, 13, 16, 26, 29, 42,",
            "                 3,  8, 12, 17, 25, 30, 41, 43,",
            "                 9, 11, 18, 24, 31, 40, 44, 53,",
            "                10, 19, 23, 32, 39, 45, 52, 54,",
            "                20, 22, 33, 38, 46, 51, 55, 60,",
            "                21, 34, 37, 47, 50, 56, 59, 61,",
            "                35, 36, 48, 49, 57, 58, 62, 63)",
            "",
            "samplings = {",
            "             (1, 1, 1, 1, 1, 1): 0,",
            "             (2, 1, 1, 1, 1, 1): 1,",
            "             (2, 2, 1, 1, 1, 1): 2,",
            "            }",
            "",
            "def convert_dict_qtables(qtables):",
            "    qtables = [qtables[key] for key in xrange(len(qtables)) if qtables.has_key(key)]",
            "    for idx, table in enumerate(qtables):",
            "        qtables[idx] = [table[i] for i in zigzag_index]",
            "    return qtables",
            "",
            "def get_sampling(im):",
            "    sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]",
            "    return samplings.get(sampling, -1)",
            "",
            "def _save(im, fp, filename):",
            "",
            "    try:",
            "        rawmode = RAWMODE[im.mode]",
            "    except KeyError:",
            "        raise IOError(\"cannot write mode %s as JPEG\" % im.mode)",
            "",
            "    info = im.encoderinfo",
            "",
            "    dpi = info.get(\"dpi\", (0, 0))",
            "",
            "    quality = info.get(\"quality\", 0)",
            "    subsampling = info.get(\"subsampling\", -1)",
            "    qtables = info.get(\"qtables\")",
            "",
            "    if quality == \"keep\":",
            "        quality = 0",
            "        subsampling = \"keep\"",
            "        qtables = \"keep\"",
            "    elif quality in presets:",
            "        preset = presets[quality]",
            "        quality = 0",
            "        subsampling = preset.get('subsampling', -1)",
            "        qtables = preset.get('quantization')",
            "    elif not isinstance(quality, int):",
            "        raise ValueError(\"Invalid quality setting\")",
            "    else:",
            "        if subsampling in presets:",
            "            subsampling = presets[subsampling].get('subsampling', -1)",
            "        if qtables in presets:",
            "            qtables = presets[qtables].get('quantization')",
            "",
            "    if subsampling == \"4:4:4\":",
            "        subsampling = 0",
            "    elif subsampling == \"4:2:2\":",
            "        subsampling = 1",
            "    elif subsampling == \"4:1:1\":",
            "        subsampling = 2",
            "    elif subsampling == \"keep\":",
            "        if im.format != \"JPEG\":",
            "            raise ValueError(\"Cannot use 'keep' when original image is not a JPEG\")",
            "        subsampling = get_sampling(im)",
            "",
            "    def validate_qtables(qtables):",
            "        if qtables is None:",
            "            return qtables",
            "        if isStringType(qtables):",
            "            try:",
            "                lines = [int(num) for line in qtables.splitlines()",
            "                         for num in line.split('#', 1)[0].split()]",
            "            except ValueError:",
            "                raise ValueError(\"Invalid quantization table\")",
            "            else:",
            "                qtables = [lines[s:s+64] for s in xrange(0, len(lines), 64)]",
            "        if isinstance(qtables, (tuple, list, dict)):",
            "            if isinstance(qtables, dict):",
            "                qtables = convert_dict_qtables(qtables)",
            "            elif isinstance(qtables, tuple):",
            "                qtables = list(qtables)",
            "            if not (0 < len(qtables) < 5):",
            "                raise ValueError(\"None or too many quantization tables\")",
            "            for idx, table in enumerate(qtables):",
            "                try:",
            "                    if len(table) != 64:",
            "                        raise",
            "                    table = array.array('b', table)",
            "                except TypeError:",
            "                    raise ValueError(\"Invalid quantization table\")",
            "                else:",
            "                    qtables[idx] = list(table)",
            "            return qtables",
            "",
            "    if qtables == \"keep\":",
            "        if im.format != \"JPEG\":",
            "            raise ValueError(\"Cannot use 'keep' when original image is not a JPEG\")",
            "        qtables = getattr(im, \"quantization\", None)",
            "    qtables = validate_qtables(qtables)",
            "",
            "    extra = b\"\"",
            "",
            "    icc_profile = info.get(\"icc_profile\")",
            "    if icc_profile:",
            "        ICC_OVERHEAD_LEN = 14",
            "        MAX_BYTES_IN_MARKER = 65533",
            "        MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN",
            "        markers = []",
            "        while icc_profile:",
            "            markers.append(icc_profile[:MAX_DATA_BYTES_IN_MARKER])",
            "            icc_profile = icc_profile[MAX_DATA_BYTES_IN_MARKER:]",
            "        i = 1",
            "        for marker in markers:",
            "            size = struct.pack(\">H\", 2 + ICC_OVERHEAD_LEN + len(marker))",
            "            extra = extra + (b\"\\xFF\\xE2\" + size + b\"ICC_PROFILE\\0\" + o8(i) + o8(len(markers)) + marker)",
            "            i = i + 1",
            "",
            "    # get keyword arguments",
            "    im.encoderconfig = (",
            "        quality,",
            "        # \"progressive\" is the official name, but older documentation",
            "        # says \"progression\"",
            "        # FIXME: issue a warning if the wrong form is used (post-1.1.7)",
            "        \"progressive\" in info or \"progression\" in info,",
            "        info.get(\"smooth\", 0),",
            "        \"optimize\" in info,",
            "        info.get(\"streamtype\", 0),",
            "        dpi[0], dpi[1],",
            "        subsampling,",
            "        qtables,",
            "        extra,",
            "        info.get(\"exif\", b\"\")",
            "        )",
            "",
            "",
            "    # if we optimize, libjpeg needs a buffer big enough to hold the whole image in a shot.",
            "    # Guessing on the size, at im.size bytes. (raw pizel size is channels*size, this",
            "    # is a value that's been used in a django patch.",
            "    # https://github.com/jdriscoll/django-imagekit/issues/50",
            "    bufsize=0",
            "    if \"optimize\" in info or \"progressive\" in info or \"progression\" in info:",
            "        bufsize = im.size[0]*im.size[1]",
            "",
            "    # The exif info needs to be written as one block, + APP1, + one spare byte.",
            "    # Ensure that our buffer is big enough",
            "    bufsize = max(ImageFile.MAXBLOCK, bufsize, len(info.get(\"exif\",b\"\")) + 5 )",
            "",
            "    ImageFile._save(im, fp, [(\"jpeg\", (0,0)+im.size, 0, rawmode)], bufsize)",
            "",
            "def _save_cjpeg(im, fp, filename):",
            "    # ALTERNATIVE: handle JPEGs via the IJG command line utilities.",
            "    import os",
            "    file = im._dump()",
            "    os.system(\"cjpeg %s >%s\" % (file, filename))",
            "    try: os.unlink(file)",
            "    except: pass",
            "",
            "# -------------------------------------------------------------------q-",
            "# Registry stuff",
            "",
            "Image.register_open(\"JPEG\", JpegImageFile, _accept)",
            "Image.register_save(\"JPEG\", _save)",
            "",
            "Image.register_extension(\"JPEG\", \".jfif\")",
            "Image.register_extension(\"JPEG\", \".jpe\")",
            "Image.register_extension(\"JPEG\", \".jpg\")",
            "Image.register_extension(\"JPEG\", \".jpeg\")",
            "",
            "Image.register_mime(\"JPEG\", \"image/jpeg\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "347": [
                "JpegImageFile",
                "load_djpeg"
            ],
            "348": [
                "JpegImageFile",
                "load_djpeg"
            ],
            "351": [
                "JpegImageFile",
                "load_djpeg"
            ],
            "353": [
                "JpegImageFile",
                "load_djpeg"
            ]
        },
        "addLocation": []
    }
}