{
    "Tests/test_file_icns.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     with io.BytesIO(b\"invalid\\n\") as fp:"
            },
            "1": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         with pytest.raises(SyntaxError):"
            },
            "2": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             IcnsImagePlugin.IcnsFile(fp)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+def test_icns_decompression_bomb():"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    with pytest.raises(Image.DecompressionBombError):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        im = Image.open('Tests/images/oom-8ed3316a4109213ca96fb8a256a0bfefdece1461.icns')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        im.load()"
            }
        },
        "frontPatchFile": [
            "import io",
            "import sys",
            "",
            "import pytest",
            "",
            "from PIL import IcnsImagePlugin, Image, features",
            "",
            "from .helper import assert_image_equal, assert_image_similar_tofile",
            "",
            "# sample icon file",
            "TEST_FILE = \"Tests/images/pillow.icns\"",
            "",
            "ENABLE_JPEG2K = features.check_codec(\"jpg_2000\")",
            "",
            "",
            "def test_sanity():",
            "    # Loading this icon by default should result in the largest size",
            "    # (512x512@2x) being loaded",
            "    with Image.open(TEST_FILE) as im:",
            "",
            "        # Assert that there is no unclosed file warning",
            "        with pytest.warns(None) as record:",
            "            im.load()",
            "        assert not record",
            "",
            "        assert im.mode == \"RGBA\"",
            "        assert im.size == (1024, 1024)",
            "        assert im.format == \"ICNS\"",
            "",
            "",
            "@pytest.mark.skipif(sys.platform != \"darwin\", reason=\"Requires macOS\")",
            "def test_save(tmp_path):",
            "    temp_file = str(tmp_path / \"temp.icns\")",
            "",
            "    with Image.open(TEST_FILE) as im:",
            "        im.save(temp_file)",
            "",
            "    with Image.open(temp_file) as reread:",
            "        assert reread.mode == \"RGBA\"",
            "        assert reread.size == (1024, 1024)",
            "        assert reread.format == \"ICNS\"",
            "",
            "",
            "@pytest.mark.skipif(sys.platform != \"darwin\", reason=\"Requires macOS\")",
            "def test_save_append_images(tmp_path):",
            "    temp_file = str(tmp_path / \"temp.icns\")",
            "    provided_im = Image.new(\"RGBA\", (32, 32), (255, 0, 0, 128))",
            "",
            "    with Image.open(TEST_FILE) as im:",
            "        im.save(temp_file, append_images=[provided_im])",
            "",
            "        assert_image_similar_tofile(im, temp_file, 1)",
            "",
            "        with Image.open(temp_file) as reread:",
            "            reread.size = (16, 16, 2)",
            "            reread.load()",
            "            assert_image_equal(reread, provided_im)",
            "",
            "",
            "@pytest.mark.skipif(sys.platform != \"darwin\", reason=\"Requires macOS\")",
            "def test_save_fp():",
            "    fp = io.BytesIO()",
            "",
            "    with Image.open(TEST_FILE) as im:",
            "        im.save(fp, format=\"ICNS\")",
            "",
            "    with Image.open(fp) as reread:",
            "        assert reread.mode == \"RGBA\"",
            "        assert reread.size == (1024, 1024)",
            "        assert reread.format == \"ICNS\"",
            "",
            "",
            "def test_sizes():",
            "    # Check that we can load all of the sizes, and that the final pixel",
            "    # dimensions are as expected",
            "    with Image.open(TEST_FILE) as im:",
            "        for w, h, r in im.info[\"sizes\"]:",
            "            wr = w * r",
            "            hr = h * r",
            "            im.size = (w, h, r)",
            "            im.load()",
            "            assert im.mode == \"RGBA\"",
            "            assert im.size == (wr, hr)",
            "",
            "        # Check that we cannot load an incorrect size",
            "        with pytest.raises(ValueError):",
            "            im.size = (1, 1)",
            "",
            "",
            "def test_older_icon():",
            "    # This icon was made with Icon Composer rather than iconutil; it still",
            "    # uses PNG rather than JP2, however (since it was made on 10.9).",
            "    with Image.open(\"Tests/images/pillow2.icns\") as im:",
            "        for w, h, r in im.info[\"sizes\"]:",
            "            wr = w * r",
            "            hr = h * r",
            "            with Image.open(\"Tests/images/pillow2.icns\") as im2:",
            "                im2.size = (w, h, r)",
            "                im2.load()",
            "                assert im2.mode == \"RGBA\"",
            "                assert im2.size == (wr, hr)",
            "",
            "",
            "def test_jp2_icon():",
            "    # This icon was made by using Uli Kusterer's oldiconutil to replace",
            "    # the PNG images with JPEG 2000 ones.  The advantage of doing this is",
            "    # that OS X 10.5 supports JPEG 2000 but not PNG; some commercial",
            "    # software therefore does just this.",
            "",
            "    # (oldiconutil is here: https://github.com/uliwitness/oldiconutil)",
            "",
            "    if not ENABLE_JPEG2K:",
            "        return",
            "",
            "    with Image.open(\"Tests/images/pillow3.icns\") as im:",
            "        for w, h, r in im.info[\"sizes\"]:",
            "            wr = w * r",
            "            hr = h * r",
            "            with Image.open(\"Tests/images/pillow3.icns\") as im2:",
            "                im2.size = (w, h, r)",
            "                im2.load()",
            "                assert im2.mode == \"RGBA\"",
            "                assert im2.size == (wr, hr)",
            "",
            "",
            "def test_getimage():",
            "    with open(TEST_FILE, \"rb\") as fp:",
            "        icns_file = IcnsImagePlugin.IcnsFile(fp)",
            "",
            "        im = icns_file.getimage()",
            "        assert im.mode == \"RGBA\"",
            "        assert im.size == (1024, 1024)",
            "",
            "        im = icns_file.getimage((512, 512))",
            "        assert im.mode == \"RGBA\"",
            "        assert im.size == (512, 512)",
            "",
            "",
            "def test_not_an_icns_file():",
            "    with io.BytesIO(b\"invalid\\n\") as fp:",
            "        with pytest.raises(SyntaxError):",
            "            IcnsImagePlugin.IcnsFile(fp)"
        ],
        "afterPatchFile": [
            "import io",
            "import sys",
            "",
            "import pytest",
            "",
            "from PIL import IcnsImagePlugin, Image, features",
            "",
            "from .helper import assert_image_equal, assert_image_similar_tofile",
            "",
            "# sample icon file",
            "TEST_FILE = \"Tests/images/pillow.icns\"",
            "",
            "ENABLE_JPEG2K = features.check_codec(\"jpg_2000\")",
            "",
            "",
            "def test_sanity():",
            "    # Loading this icon by default should result in the largest size",
            "    # (512x512@2x) being loaded",
            "    with Image.open(TEST_FILE) as im:",
            "",
            "        # Assert that there is no unclosed file warning",
            "        with pytest.warns(None) as record:",
            "            im.load()",
            "        assert not record",
            "",
            "        assert im.mode == \"RGBA\"",
            "        assert im.size == (1024, 1024)",
            "        assert im.format == \"ICNS\"",
            "",
            "",
            "@pytest.mark.skipif(sys.platform != \"darwin\", reason=\"Requires macOS\")",
            "def test_save(tmp_path):",
            "    temp_file = str(tmp_path / \"temp.icns\")",
            "",
            "    with Image.open(TEST_FILE) as im:",
            "        im.save(temp_file)",
            "",
            "    with Image.open(temp_file) as reread:",
            "        assert reread.mode == \"RGBA\"",
            "        assert reread.size == (1024, 1024)",
            "        assert reread.format == \"ICNS\"",
            "",
            "",
            "@pytest.mark.skipif(sys.platform != \"darwin\", reason=\"Requires macOS\")",
            "def test_save_append_images(tmp_path):",
            "    temp_file = str(tmp_path / \"temp.icns\")",
            "    provided_im = Image.new(\"RGBA\", (32, 32), (255, 0, 0, 128))",
            "",
            "    with Image.open(TEST_FILE) as im:",
            "        im.save(temp_file, append_images=[provided_im])",
            "",
            "        assert_image_similar_tofile(im, temp_file, 1)",
            "",
            "        with Image.open(temp_file) as reread:",
            "            reread.size = (16, 16, 2)",
            "            reread.load()",
            "            assert_image_equal(reread, provided_im)",
            "",
            "",
            "@pytest.mark.skipif(sys.platform != \"darwin\", reason=\"Requires macOS\")",
            "def test_save_fp():",
            "    fp = io.BytesIO()",
            "",
            "    with Image.open(TEST_FILE) as im:",
            "        im.save(fp, format=\"ICNS\")",
            "",
            "    with Image.open(fp) as reread:",
            "        assert reread.mode == \"RGBA\"",
            "        assert reread.size == (1024, 1024)",
            "        assert reread.format == \"ICNS\"",
            "",
            "",
            "def test_sizes():",
            "    # Check that we can load all of the sizes, and that the final pixel",
            "    # dimensions are as expected",
            "    with Image.open(TEST_FILE) as im:",
            "        for w, h, r in im.info[\"sizes\"]:",
            "            wr = w * r",
            "            hr = h * r",
            "            im.size = (w, h, r)",
            "            im.load()",
            "            assert im.mode == \"RGBA\"",
            "            assert im.size == (wr, hr)",
            "",
            "        # Check that we cannot load an incorrect size",
            "        with pytest.raises(ValueError):",
            "            im.size = (1, 1)",
            "",
            "",
            "def test_older_icon():",
            "    # This icon was made with Icon Composer rather than iconutil; it still",
            "    # uses PNG rather than JP2, however (since it was made on 10.9).",
            "    with Image.open(\"Tests/images/pillow2.icns\") as im:",
            "        for w, h, r in im.info[\"sizes\"]:",
            "            wr = w * r",
            "            hr = h * r",
            "            with Image.open(\"Tests/images/pillow2.icns\") as im2:",
            "                im2.size = (w, h, r)",
            "                im2.load()",
            "                assert im2.mode == \"RGBA\"",
            "                assert im2.size == (wr, hr)",
            "",
            "",
            "def test_jp2_icon():",
            "    # This icon was made by using Uli Kusterer's oldiconutil to replace",
            "    # the PNG images with JPEG 2000 ones.  The advantage of doing this is",
            "    # that OS X 10.5 supports JPEG 2000 but not PNG; some commercial",
            "    # software therefore does just this.",
            "",
            "    # (oldiconutil is here: https://github.com/uliwitness/oldiconutil)",
            "",
            "    if not ENABLE_JPEG2K:",
            "        return",
            "",
            "    with Image.open(\"Tests/images/pillow3.icns\") as im:",
            "        for w, h, r in im.info[\"sizes\"]:",
            "            wr = w * r",
            "            hr = h * r",
            "            with Image.open(\"Tests/images/pillow3.icns\") as im2:",
            "                im2.size = (w, h, r)",
            "                im2.load()",
            "                assert im2.mode == \"RGBA\"",
            "                assert im2.size == (wr, hr)",
            "",
            "",
            "def test_getimage():",
            "    with open(TEST_FILE, \"rb\") as fp:",
            "        icns_file = IcnsImagePlugin.IcnsFile(fp)",
            "",
            "        im = icns_file.getimage()",
            "        assert im.mode == \"RGBA\"",
            "        assert im.size == (1024, 1024)",
            "",
            "        im = icns_file.getimage((512, 512))",
            "        assert im.mode == \"RGBA\"",
            "        assert im.size == (512, 512)",
            "",
            "",
            "def test_not_an_icns_file():",
            "    with io.BytesIO(b\"invalid\\n\") as fp:",
            "        with pytest.raises(SyntaxError):",
            "            IcnsImagePlugin.IcnsFile(fp)",
            "",
            "",
            "def test_icns_decompression_bomb():",
            "    with pytest.raises(Image.DecompressionBombError):",
            "        im = Image.open('Tests/images/oom-8ed3316a4109213ca96fb8a256a0bfefdece1461.icns')",
            "        im.load()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "src/PIL/BlpImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "         data = jpeg_header + data"
            },
            "1": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "         data = BytesIO(data)"
            },
            "2": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "         image = JpegImageFile(data)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+        Image._decompression_bomb_check(image.size)"
            },
            "4": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "         self.tile = image.tile  # :/"
            },
            "5": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "         self.fd = image.fp"
            },
            "6": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "         self.mode = image.mode"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Blizzard Mipmap Format (.blp)",
            "Jerome Leclanche <jerome@leclan.ch>",
            "",
            "The contents of this file are hereby released in the public domain (CC0)",
            "Full text of the CC0 license:",
            "  https://creativecommons.org/publicdomain/zero/1.0/",
            "",
            "BLP1 files, used mostly in Warcraft III, are not fully supported.",
            "All types of BLP2 files used in World of Warcraft are supported.",
            "",
            "The BLP file structure consists of a header, up to 16 mipmaps of the",
            "texture",
            "",
            "Texture sizes must be powers of two, though the two dimensions do",
            "not have to be equal; 512x256 is valid, but 512x200 is not.",
            "The first mipmap (mipmap #0) is the full size image; each subsequent",
            "mipmap halves both dimensions. The final mipmap should be 1x1.",
            "",
            "BLP files come in many different flavours:",
            "* JPEG-compressed (type == 0) - only supported for BLP1.",
            "* RAW images (type == 1, encoding == 1). Each mipmap is stored as an",
            "  array of 8-bit values, one per pixel, left to right, top to bottom.",
            "  Each value is an index to the palette.",
            "* DXT-compressed (type == 1, encoding == 2):",
            "- DXT1 compression is used if alpha_encoding == 0.",
            "  - An additional alpha bit is used if alpha_depth == 1.",
            "  - DXT3 compression is used if alpha_encoding == 1.",
            "  - DXT5 compression is used if alpha_encoding == 7.",
            "\"\"\"",
            "",
            "import struct",
            "from io import BytesIO",
            "",
            "from . import Image, ImageFile",
            "",
            "BLP_FORMAT_JPEG = 0",
            "",
            "BLP_ENCODING_UNCOMPRESSED = 1",
            "BLP_ENCODING_DXT = 2",
            "BLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3",
            "",
            "BLP_ALPHA_ENCODING_DXT1 = 0",
            "BLP_ALPHA_ENCODING_DXT3 = 1",
            "BLP_ALPHA_ENCODING_DXT5 = 7",
            "",
            "",
            "def unpack_565(i):",
            "    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)",
            "",
            "",
            "def decode_dxt1(data, alpha=False):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4*width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 8  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        # Decode next 8-byte block.",
            "        idx = block * 8",
            "        color0, color1, bits = struct.unpack_from(\"<HHI\", data, idx)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        # Decode this block into 4x4 pixels",
            "        # Accumulate the results onto our 4 row accumulators",
            "        for j in range(4):",
            "            for i in range(4):",
            "                # get next control op and generate a pixel",
            "",
            "                control = bits & 3",
            "                bits = bits >> 2",
            "",
            "                a = 0xFF",
            "                if control == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif control == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif control == 2:",
            "                    if color0 > color1:",
            "                        r = (2 * r0 + r1) // 3",
            "                        g = (2 * g0 + g1) // 3",
            "                        b = (2 * b0 + b1) // 3",
            "                    else:",
            "                        r = (r0 + r1) // 2",
            "                        g = (g0 + g1) // 2",
            "                        b = (b0 + b1) // 2",
            "                elif control == 3:",
            "                    if color0 > color1:",
            "                        r = (2 * r1 + r0) // 3",
            "                        g = (2 * g1 + g0) // 3",
            "                        b = (2 * b1 + b0) // 3",
            "                    else:",
            "                        r, g, b, a = 0, 0, 0, 0",
            "",
            "                if alpha:",
            "                    ret[j].extend([r, g, b, a])",
            "                else:",
            "                    ret[j].extend([r, g, b])",
            "",
            "    return ret",
            "",
            "",
            "def decode_dxt3(data):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4*width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 16  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        idx = block * 16",
            "        block = data[idx : idx + 16]",
            "        # Decode next 16-byte block.",
            "        bits = struct.unpack_from(\"<8B\", block)",
            "        color0, color1 = struct.unpack_from(\"<HH\", block, 8)",
            "",
            "        (code,) = struct.unpack_from(\"<I\", block, 12)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        for j in range(4):",
            "            high = False  # Do we want the higher bits?",
            "            for i in range(4):",
            "                alphacode_index = (4 * j + i) // 2",
            "                a = bits[alphacode_index]",
            "                if high:",
            "                    high = False",
            "                    a >>= 4",
            "                else:",
            "                    high = True",
            "                    a &= 0xF",
            "                a *= 17  # We get a value between 0 and 15",
            "",
            "                color_code = (code >> 2 * (4 * j + i)) & 0x03",
            "",
            "                if color_code == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif color_code == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif color_code == 2:",
            "                    r = (2 * r0 + r1) // 3",
            "                    g = (2 * g0 + g1) // 3",
            "                    b = (2 * b0 + b1) // 3",
            "                elif color_code == 3:",
            "                    r = (2 * r1 + r0) // 3",
            "                    g = (2 * g1 + g0) // 3",
            "                    b = (2 * b1 + b0) // 3",
            "",
            "                ret[j].extend([r, g, b, a])",
            "",
            "    return ret",
            "",
            "",
            "def decode_dxt5(data):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4 * width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 16  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        idx = block * 16",
            "        block = data[idx : idx + 16]",
            "        # Decode next 16-byte block.",
            "        a0, a1 = struct.unpack_from(\"<BB\", block)",
            "",
            "        bits = struct.unpack_from(\"<6B\", block, 2)",
            "        alphacode1 = bits[2] | (bits[3] << 8) | (bits[4] << 16) | (bits[5] << 24)",
            "        alphacode2 = bits[0] | (bits[1] << 8)",
            "",
            "        color0, color1 = struct.unpack_from(\"<HH\", block, 8)",
            "",
            "        (code,) = struct.unpack_from(\"<I\", block, 12)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        for j in range(4):",
            "            for i in range(4):",
            "                # get next control op and generate a pixel",
            "                alphacode_index = 3 * (4 * j + i)",
            "",
            "                if alphacode_index <= 12:",
            "                    alphacode = (alphacode2 >> alphacode_index) & 0x07",
            "                elif alphacode_index == 15:",
            "                    alphacode = (alphacode2 >> 15) | ((alphacode1 << 1) & 0x06)",
            "                else:  # alphacode_index >= 18 and alphacode_index <= 45",
            "                    alphacode = (alphacode1 >> (alphacode_index - 16)) & 0x07",
            "",
            "                if alphacode == 0:",
            "                    a = a0",
            "                elif alphacode == 1:",
            "                    a = a1",
            "                elif a0 > a1:",
            "                    a = ((8 - alphacode) * a0 + (alphacode - 1) * a1) // 7",
            "                elif alphacode == 6:",
            "                    a = 0",
            "                elif alphacode == 7:",
            "                    a = 255",
            "                else:",
            "                    a = ((6 - alphacode) * a0 + (alphacode - 1) * a1) // 5",
            "",
            "                color_code = (code >> 2 * (4 * j + i)) & 0x03",
            "",
            "                if color_code == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif color_code == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif color_code == 2:",
            "                    r = (2 * r0 + r1) // 3",
            "                    g = (2 * g0 + g1) // 3",
            "                    b = (2 * b0 + b1) // 3",
            "                elif color_code == 3:",
            "                    r = (2 * r1 + r0) // 3",
            "                    g = (2 * g1 + g0) // 3",
            "                    b = (2 * b1 + b0) // 3",
            "",
            "                ret[j].extend([r, g, b, a])",
            "",
            "    return ret",
            "",
            "",
            "class BLPFormatError(NotImplementedError):",
            "    pass",
            "",
            "",
            "class BlpImageFile(ImageFile.ImageFile):",
            "    \"\"\"",
            "    Blizzard Mipmap Format",
            "    \"\"\"",
            "",
            "    format = \"BLP\"",
            "    format_description = \"Blizzard Mipmap Format\"",
            "",
            "    def _open(self):",
            "        self.magic = self.fp.read(4)",
            "        self._read_blp_header()",
            "",
            "        if self.magic == b\"BLP1\":",
            "            decoder = \"BLP1\"",
            "            self.mode = \"RGB\"",
            "        elif self.magic == b\"BLP2\":",
            "            decoder = \"BLP2\"",
            "            self.mode = \"RGBA\" if self._blp_alpha_depth else \"RGB\"",
            "        else:",
            "            raise BLPFormatError(f\"Bad BLP magic {repr(self.magic)}\")",
            "",
            "        self.tile = [(decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]",
            "",
            "    def _read_blp_header(self):",
            "        (self._blp_compression,) = struct.unpack(\"<i\", self.fp.read(4))",
            "",
            "        (self._blp_encoding,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_mips,) = struct.unpack(\"<b\", self.fp.read(1))",
            "",
            "        self._size = struct.unpack(\"<II\", self.fp.read(8))",
            "",
            "        if self.magic == b\"BLP1\":",
            "            # Only present for BLP1",
            "            (self._blp_encoding,) = struct.unpack(\"<i\", self.fp.read(4))",
            "            (self._blp_subtype,) = struct.unpack(\"<i\", self.fp.read(4))",
            "",
            "        self._blp_offsets = struct.unpack(\"<16I\", self.fp.read(16 * 4))",
            "        self._blp_lengths = struct.unpack(\"<16I\", self.fp.read(16 * 4))",
            "",
            "",
            "class _BLPBaseDecoder(ImageFile.PyDecoder):",
            "    _pulls_fd = True",
            "",
            "    def decode(self, buffer):",
            "        try:",
            "            self.fd.seek(0)",
            "            self.magic = self.fd.read(4)",
            "            self._read_blp_header()",
            "            self._load()",
            "        except struct.error as e:",
            "            raise OSError(\"Truncated Blp file\") from e",
            "        return 0, 0",
            "",
            "    def _read_palette(self):",
            "        ret = []",
            "        for i in range(256):",
            "            try:",
            "                b, g, r, a = struct.unpack(\"<4B\", self.fd.read(4))",
            "            except struct.error:",
            "                break",
            "            ret.append((b, g, r, a))",
            "        return ret",
            "",
            "    def _read_blp_header(self):",
            "        (self._blp_compression,) = struct.unpack(\"<i\", self.fd.read(4))",
            "",
            "        (self._blp_encoding,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_mips,) = struct.unpack(\"<b\", self.fd.read(1))",
            "",
            "        self.size = struct.unpack(\"<II\", self.fd.read(8))",
            "",
            "        if self.magic == b\"BLP1\":",
            "            # Only present for BLP1",
            "            (self._blp_encoding,) = struct.unpack(\"<i\", self.fd.read(4))",
            "            (self._blp_subtype,) = struct.unpack(\"<i\", self.fd.read(4))",
            "",
            "        self._blp_offsets = struct.unpack(\"<16I\", self.fd.read(16 * 4))",
            "        self._blp_lengths = struct.unpack(\"<16I\", self.fd.read(16 * 4))",
            "",
            "",
            "class BLP1Decoder(_BLPBaseDecoder):",
            "    def _load(self):",
            "        if self._blp_compression == BLP_FORMAT_JPEG:",
            "            self._decode_jpeg_stream()",
            "",
            "        elif self._blp_compression == 1:",
            "            if self._blp_encoding in (4, 5):",
            "                data = bytearray()",
            "                palette = self._read_palette()",
            "                _data = BytesIO(self.fd.read(self._blp_lengths[0]))",
            "                while True:",
            "                    try:",
            "                        (offset,) = struct.unpack(\"<B\", _data.read(1))",
            "                    except struct.error:",
            "                        break",
            "                    b, g, r, a = palette[offset]",
            "                    data.extend([r, g, b])",
            "",
            "                self.set_as_raw(bytes(data))",
            "            else:",
            "                raise BLPFormatError(",
            "                    f\"Unsupported BLP encoding {repr(self._blp_encoding)}\"",
            "                )",
            "        else:",
            "            raise BLPFormatError(",
            "                f\"Unsupported BLP compression {repr(self._blp_encoding)}\"",
            "            )",
            "",
            "    def _decode_jpeg_stream(self):",
            "        from PIL.JpegImagePlugin import JpegImageFile",
            "",
            "        (jpeg_header_size,) = struct.unpack(\"<I\", self.fd.read(4))",
            "        jpeg_header = self.fd.read(jpeg_header_size)",
            "        self.fd.read(self._blp_offsets[0] - self.fd.tell())  # What IS this?",
            "        data = self.fd.read(self._blp_lengths[0])",
            "        data = jpeg_header + data",
            "        data = BytesIO(data)",
            "        image = JpegImageFile(data)",
            "        self.tile = image.tile  # :/",
            "        self.fd = image.fp",
            "        self.mode = image.mode",
            "",
            "",
            "class BLP2Decoder(_BLPBaseDecoder):",
            "    def _load(self):",
            "        palette = self._read_palette()",
            "",
            "        data = bytearray()",
            "        self.fd.seek(self._blp_offsets[0])",
            "",
            "        if self._blp_compression == 1:",
            "            # Uncompressed or DirectX compression",
            "",
            "            if self._blp_encoding == BLP_ENCODING_UNCOMPRESSED:",
            "                _data = BytesIO(self.fd.read(self._blp_lengths[0]))",
            "                while True:",
            "                    try:",
            "                        (offset,) = struct.unpack(\"<B\", _data.read(1))",
            "                    except struct.error:",
            "                        break",
            "                    b, g, r, a = palette[offset]",
            "                    data.extend((r, g, b))",
            "",
            "            elif self._blp_encoding == BLP_ENCODING_DXT:",
            "                if self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT1:",
            "                    linesize = (self.size[0] + 3) // 4 * 8",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt1(",
            "                            self.fd.read(linesize), alpha=bool(self._blp_alpha_depth)",
            "                        ):",
            "                            data += d",
            "",
            "                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT3:",
            "                    linesize = (self.size[0] + 3) // 4 * 16",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt3(self.fd.read(linesize)):",
            "                            data += d",
            "",
            "                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT5:",
            "                    linesize = (self.size[0] + 3) // 4 * 16",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt5(self.fd.read(linesize)):",
            "                            data += d",
            "                else:",
            "                    raise BLPFormatError(",
            "                        f\"Unsupported alpha encoding {repr(self._blp_alpha_encoding)}\"",
            "                    )",
            "            else:",
            "                raise BLPFormatError(f\"Unknown BLP encoding {repr(self._blp_encoding)}\")",
            "",
            "        else:",
            "            raise BLPFormatError(",
            "                f\"Unknown BLP compression {repr(self._blp_compression)}\"",
            "            )",
            "",
            "        self.set_as_raw(bytes(data))",
            "",
            "",
            "Image.register_open(",
            "    BlpImageFile.format, BlpImageFile, lambda p: p[:4] in (b\"BLP1\", b\"BLP2\")",
            ")",
            "Image.register_extension(BlpImageFile.format, \".blp\")",
            "",
            "Image.register_decoder(\"BLP1\", BLP1Decoder)",
            "Image.register_decoder(\"BLP2\", BLP2Decoder)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Blizzard Mipmap Format (.blp)",
            "Jerome Leclanche <jerome@leclan.ch>",
            "",
            "The contents of this file are hereby released in the public domain (CC0)",
            "Full text of the CC0 license:",
            "  https://creativecommons.org/publicdomain/zero/1.0/",
            "",
            "BLP1 files, used mostly in Warcraft III, are not fully supported.",
            "All types of BLP2 files used in World of Warcraft are supported.",
            "",
            "The BLP file structure consists of a header, up to 16 mipmaps of the",
            "texture",
            "",
            "Texture sizes must be powers of two, though the two dimensions do",
            "not have to be equal; 512x256 is valid, but 512x200 is not.",
            "The first mipmap (mipmap #0) is the full size image; each subsequent",
            "mipmap halves both dimensions. The final mipmap should be 1x1.",
            "",
            "BLP files come in many different flavours:",
            "* JPEG-compressed (type == 0) - only supported for BLP1.",
            "* RAW images (type == 1, encoding == 1). Each mipmap is stored as an",
            "  array of 8-bit values, one per pixel, left to right, top to bottom.",
            "  Each value is an index to the palette.",
            "* DXT-compressed (type == 1, encoding == 2):",
            "- DXT1 compression is used if alpha_encoding == 0.",
            "  - An additional alpha bit is used if alpha_depth == 1.",
            "  - DXT3 compression is used if alpha_encoding == 1.",
            "  - DXT5 compression is used if alpha_encoding == 7.",
            "\"\"\"",
            "",
            "import struct",
            "from io import BytesIO",
            "",
            "from . import Image, ImageFile",
            "",
            "BLP_FORMAT_JPEG = 0",
            "",
            "BLP_ENCODING_UNCOMPRESSED = 1",
            "BLP_ENCODING_DXT = 2",
            "BLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3",
            "",
            "BLP_ALPHA_ENCODING_DXT1 = 0",
            "BLP_ALPHA_ENCODING_DXT3 = 1",
            "BLP_ALPHA_ENCODING_DXT5 = 7",
            "",
            "",
            "def unpack_565(i):",
            "    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)",
            "",
            "",
            "def decode_dxt1(data, alpha=False):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4*width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 8  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        # Decode next 8-byte block.",
            "        idx = block * 8",
            "        color0, color1, bits = struct.unpack_from(\"<HHI\", data, idx)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        # Decode this block into 4x4 pixels",
            "        # Accumulate the results onto our 4 row accumulators",
            "        for j in range(4):",
            "            for i in range(4):",
            "                # get next control op and generate a pixel",
            "",
            "                control = bits & 3",
            "                bits = bits >> 2",
            "",
            "                a = 0xFF",
            "                if control == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif control == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif control == 2:",
            "                    if color0 > color1:",
            "                        r = (2 * r0 + r1) // 3",
            "                        g = (2 * g0 + g1) // 3",
            "                        b = (2 * b0 + b1) // 3",
            "                    else:",
            "                        r = (r0 + r1) // 2",
            "                        g = (g0 + g1) // 2",
            "                        b = (b0 + b1) // 2",
            "                elif control == 3:",
            "                    if color0 > color1:",
            "                        r = (2 * r1 + r0) // 3",
            "                        g = (2 * g1 + g0) // 3",
            "                        b = (2 * b1 + b0) // 3",
            "                    else:",
            "                        r, g, b, a = 0, 0, 0, 0",
            "",
            "                if alpha:",
            "                    ret[j].extend([r, g, b, a])",
            "                else:",
            "                    ret[j].extend([r, g, b])",
            "",
            "    return ret",
            "",
            "",
            "def decode_dxt3(data):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4*width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 16  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        idx = block * 16",
            "        block = data[idx : idx + 16]",
            "        # Decode next 16-byte block.",
            "        bits = struct.unpack_from(\"<8B\", block)",
            "        color0, color1 = struct.unpack_from(\"<HH\", block, 8)",
            "",
            "        (code,) = struct.unpack_from(\"<I\", block, 12)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        for j in range(4):",
            "            high = False  # Do we want the higher bits?",
            "            for i in range(4):",
            "                alphacode_index = (4 * j + i) // 2",
            "                a = bits[alphacode_index]",
            "                if high:",
            "                    high = False",
            "                    a >>= 4",
            "                else:",
            "                    high = True",
            "                    a &= 0xF",
            "                a *= 17  # We get a value between 0 and 15",
            "",
            "                color_code = (code >> 2 * (4 * j + i)) & 0x03",
            "",
            "                if color_code == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif color_code == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif color_code == 2:",
            "                    r = (2 * r0 + r1) // 3",
            "                    g = (2 * g0 + g1) // 3",
            "                    b = (2 * b0 + b1) // 3",
            "                elif color_code == 3:",
            "                    r = (2 * r1 + r0) // 3",
            "                    g = (2 * g1 + g0) // 3",
            "                    b = (2 * b1 + b0) // 3",
            "",
            "                ret[j].extend([r, g, b, a])",
            "",
            "    return ret",
            "",
            "",
            "def decode_dxt5(data):",
            "    \"\"\"",
            "    input: one \"row\" of data (i.e. will produce 4 * width pixels)",
            "    \"\"\"",
            "",
            "    blocks = len(data) // 16  # number of blocks in row",
            "    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
            "",
            "    for block in range(blocks):",
            "        idx = block * 16",
            "        block = data[idx : idx + 16]",
            "        # Decode next 16-byte block.",
            "        a0, a1 = struct.unpack_from(\"<BB\", block)",
            "",
            "        bits = struct.unpack_from(\"<6B\", block, 2)",
            "        alphacode1 = bits[2] | (bits[3] << 8) | (bits[4] << 16) | (bits[5] << 24)",
            "        alphacode2 = bits[0] | (bits[1] << 8)",
            "",
            "        color0, color1 = struct.unpack_from(\"<HH\", block, 8)",
            "",
            "        (code,) = struct.unpack_from(\"<I\", block, 12)",
            "",
            "        r0, g0, b0 = unpack_565(color0)",
            "        r1, g1, b1 = unpack_565(color1)",
            "",
            "        for j in range(4):",
            "            for i in range(4):",
            "                # get next control op and generate a pixel",
            "                alphacode_index = 3 * (4 * j + i)",
            "",
            "                if alphacode_index <= 12:",
            "                    alphacode = (alphacode2 >> alphacode_index) & 0x07",
            "                elif alphacode_index == 15:",
            "                    alphacode = (alphacode2 >> 15) | ((alphacode1 << 1) & 0x06)",
            "                else:  # alphacode_index >= 18 and alphacode_index <= 45",
            "                    alphacode = (alphacode1 >> (alphacode_index - 16)) & 0x07",
            "",
            "                if alphacode == 0:",
            "                    a = a0",
            "                elif alphacode == 1:",
            "                    a = a1",
            "                elif a0 > a1:",
            "                    a = ((8 - alphacode) * a0 + (alphacode - 1) * a1) // 7",
            "                elif alphacode == 6:",
            "                    a = 0",
            "                elif alphacode == 7:",
            "                    a = 255",
            "                else:",
            "                    a = ((6 - alphacode) * a0 + (alphacode - 1) * a1) // 5",
            "",
            "                color_code = (code >> 2 * (4 * j + i)) & 0x03",
            "",
            "                if color_code == 0:",
            "                    r, g, b = r0, g0, b0",
            "                elif color_code == 1:",
            "                    r, g, b = r1, g1, b1",
            "                elif color_code == 2:",
            "                    r = (2 * r0 + r1) // 3",
            "                    g = (2 * g0 + g1) // 3",
            "                    b = (2 * b0 + b1) // 3",
            "                elif color_code == 3:",
            "                    r = (2 * r1 + r0) // 3",
            "                    g = (2 * g1 + g0) // 3",
            "                    b = (2 * b1 + b0) // 3",
            "",
            "                ret[j].extend([r, g, b, a])",
            "",
            "    return ret",
            "",
            "",
            "class BLPFormatError(NotImplementedError):",
            "    pass",
            "",
            "",
            "class BlpImageFile(ImageFile.ImageFile):",
            "    \"\"\"",
            "    Blizzard Mipmap Format",
            "    \"\"\"",
            "",
            "    format = \"BLP\"",
            "    format_description = \"Blizzard Mipmap Format\"",
            "",
            "    def _open(self):",
            "        self.magic = self.fp.read(4)",
            "        self._read_blp_header()",
            "",
            "        if self.magic == b\"BLP1\":",
            "            decoder = \"BLP1\"",
            "            self.mode = \"RGB\"",
            "        elif self.magic == b\"BLP2\":",
            "            decoder = \"BLP2\"",
            "            self.mode = \"RGBA\" if self._blp_alpha_depth else \"RGB\"",
            "        else:",
            "            raise BLPFormatError(f\"Bad BLP magic {repr(self.magic)}\")",
            "",
            "        self.tile = [(decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]",
            "",
            "    def _read_blp_header(self):",
            "        (self._blp_compression,) = struct.unpack(\"<i\", self.fp.read(4))",
            "",
            "        (self._blp_encoding,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self.fp.read(1))",
            "        (self._blp_mips,) = struct.unpack(\"<b\", self.fp.read(1))",
            "",
            "        self._size = struct.unpack(\"<II\", self.fp.read(8))",
            "",
            "        if self.magic == b\"BLP1\":",
            "            # Only present for BLP1",
            "            (self._blp_encoding,) = struct.unpack(\"<i\", self.fp.read(4))",
            "            (self._blp_subtype,) = struct.unpack(\"<i\", self.fp.read(4))",
            "",
            "        self._blp_offsets = struct.unpack(\"<16I\", self.fp.read(16 * 4))",
            "        self._blp_lengths = struct.unpack(\"<16I\", self.fp.read(16 * 4))",
            "",
            "",
            "class _BLPBaseDecoder(ImageFile.PyDecoder):",
            "    _pulls_fd = True",
            "",
            "    def decode(self, buffer):",
            "        try:",
            "            self.fd.seek(0)",
            "            self.magic = self.fd.read(4)",
            "            self._read_blp_header()",
            "            self._load()",
            "        except struct.error as e:",
            "            raise OSError(\"Truncated Blp file\") from e",
            "        return 0, 0",
            "",
            "    def _read_palette(self):",
            "        ret = []",
            "        for i in range(256):",
            "            try:",
            "                b, g, r, a = struct.unpack(\"<4B\", self.fd.read(4))",
            "            except struct.error:",
            "                break",
            "            ret.append((b, g, r, a))",
            "        return ret",
            "",
            "    def _read_blp_header(self):",
            "        (self._blp_compression,) = struct.unpack(\"<i\", self.fd.read(4))",
            "",
            "        (self._blp_encoding,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self.fd.read(1))",
            "        (self._blp_mips,) = struct.unpack(\"<b\", self.fd.read(1))",
            "",
            "        self.size = struct.unpack(\"<II\", self.fd.read(8))",
            "",
            "        if self.magic == b\"BLP1\":",
            "            # Only present for BLP1",
            "            (self._blp_encoding,) = struct.unpack(\"<i\", self.fd.read(4))",
            "            (self._blp_subtype,) = struct.unpack(\"<i\", self.fd.read(4))",
            "",
            "        self._blp_offsets = struct.unpack(\"<16I\", self.fd.read(16 * 4))",
            "        self._blp_lengths = struct.unpack(\"<16I\", self.fd.read(16 * 4))",
            "",
            "",
            "class BLP1Decoder(_BLPBaseDecoder):",
            "    def _load(self):",
            "        if self._blp_compression == BLP_FORMAT_JPEG:",
            "            self._decode_jpeg_stream()",
            "",
            "        elif self._blp_compression == 1:",
            "            if self._blp_encoding in (4, 5):",
            "                data = bytearray()",
            "                palette = self._read_palette()",
            "                _data = BytesIO(self.fd.read(self._blp_lengths[0]))",
            "                while True:",
            "                    try:",
            "                        (offset,) = struct.unpack(\"<B\", _data.read(1))",
            "                    except struct.error:",
            "                        break",
            "                    b, g, r, a = palette[offset]",
            "                    data.extend([r, g, b])",
            "",
            "                self.set_as_raw(bytes(data))",
            "            else:",
            "                raise BLPFormatError(",
            "                    f\"Unsupported BLP encoding {repr(self._blp_encoding)}\"",
            "                )",
            "        else:",
            "            raise BLPFormatError(",
            "                f\"Unsupported BLP compression {repr(self._blp_encoding)}\"",
            "            )",
            "",
            "    def _decode_jpeg_stream(self):",
            "        from PIL.JpegImagePlugin import JpegImageFile",
            "",
            "        (jpeg_header_size,) = struct.unpack(\"<I\", self.fd.read(4))",
            "        jpeg_header = self.fd.read(jpeg_header_size)",
            "        self.fd.read(self._blp_offsets[0] - self.fd.tell())  # What IS this?",
            "        data = self.fd.read(self._blp_lengths[0])",
            "        data = jpeg_header + data",
            "        data = BytesIO(data)",
            "        image = JpegImageFile(data)",
            "        Image._decompression_bomb_check(image.size)",
            "        self.tile = image.tile  # :/",
            "        self.fd = image.fp",
            "        self.mode = image.mode",
            "",
            "",
            "class BLP2Decoder(_BLPBaseDecoder):",
            "    def _load(self):",
            "        palette = self._read_palette()",
            "",
            "        data = bytearray()",
            "        self.fd.seek(self._blp_offsets[0])",
            "",
            "        if self._blp_compression == 1:",
            "            # Uncompressed or DirectX compression",
            "",
            "            if self._blp_encoding == BLP_ENCODING_UNCOMPRESSED:",
            "                _data = BytesIO(self.fd.read(self._blp_lengths[0]))",
            "                while True:",
            "                    try:",
            "                        (offset,) = struct.unpack(\"<B\", _data.read(1))",
            "                    except struct.error:",
            "                        break",
            "                    b, g, r, a = palette[offset]",
            "                    data.extend((r, g, b))",
            "",
            "            elif self._blp_encoding == BLP_ENCODING_DXT:",
            "                if self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT1:",
            "                    linesize = (self.size[0] + 3) // 4 * 8",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt1(",
            "                            self.fd.read(linesize), alpha=bool(self._blp_alpha_depth)",
            "                        ):",
            "                            data += d",
            "",
            "                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT3:",
            "                    linesize = (self.size[0] + 3) // 4 * 16",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt3(self.fd.read(linesize)):",
            "                            data += d",
            "",
            "                elif self._blp_alpha_encoding == BLP_ALPHA_ENCODING_DXT5:",
            "                    linesize = (self.size[0] + 3) // 4 * 16",
            "                    for yb in range((self.size[1] + 3) // 4):",
            "                        for d in decode_dxt5(self.fd.read(linesize)):",
            "                            data += d",
            "                else:",
            "                    raise BLPFormatError(",
            "                        f\"Unsupported alpha encoding {repr(self._blp_alpha_encoding)}\"",
            "                    )",
            "            else:",
            "                raise BLPFormatError(f\"Unknown BLP encoding {repr(self._blp_encoding)}\")",
            "",
            "        else:",
            "            raise BLPFormatError(",
            "                f\"Unknown BLP compression {repr(self._blp_compression)}\"",
            "            )",
            "",
            "        self.set_as_raw(bytes(data))",
            "",
            "",
            "Image.register_open(",
            "    BlpImageFile.format, BlpImageFile, lambda p: p[:4] in (b\"BLP1\", b\"BLP2\")",
            ")",
            "Image.register_extension(BlpImageFile.format, \".blp\")",
            "",
            "Image.register_decoder(\"BLP1\", BLP1Decoder)",
            "Image.register_decoder(\"BLP2\", BLP2Decoder)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.PIL.BlpImagePlugin.BLP1Decoder._load",
            "src.PIL.PcxImagePlugin"
        ]
    },
    "src/PIL/IcnsImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "     if sig[:8] == b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\":"
            },
            "1": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "         fobj.seek(start)"
            },
            "2": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         im = PngImagePlugin.PngImageFile(fobj)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        Image._decompression_bomb_check(im.size)"
            },
            "4": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         return {\"RGBA\": im}"
            },
            "5": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "     elif ("
            },
            "6": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         sig[:4] == b\"\\xff\\x4f\\xff\\x51\""
            },
            "7": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         jp2kstream = fobj.read(length)"
            },
            "8": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         f = io.BytesIO(jp2kstream)"
            },
            "9": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         im = Jpeg2KImagePlugin.Jpeg2KImageFile(f)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        Image._decompression_bomb_check(im.size)"
            },
            "11": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         if im.mode != \"RGBA\":"
            },
            "12": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "             im = im.convert(\"RGBA\")"
            },
            "13": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         return {\"RGBA\": im}"
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# macOS icns file decoder, based on icns.py by Bob Ippolito.",
            "#",
            "# history:",
            "# 2004-10-09 fl   Turned into a PIL plugin; removed 2.3 dependencies.",
            "#",
            "# Copyright (c) 2004 by Bob Ippolito.",
            "# Copyright (c) 2004 by Secret Labs.",
            "# Copyright (c) 2004 by Fredrik Lundh.",
            "# Copyright (c) 2014 by Alastair Houghton.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "import os",
            "import shutil",
            "import struct",
            "import subprocess",
            "import sys",
            "import tempfile",
            "",
            "from PIL import Image, ImageFile, PngImagePlugin, features",
            "",
            "enable_jpeg2k = features.check_codec(\"jpg_2000\")",
            "if enable_jpeg2k:",
            "    from PIL import Jpeg2KImagePlugin",
            "",
            "HEADERSIZE = 8",
            "",
            "",
            "def nextheader(fobj):",
            "    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))",
            "",
            "",
            "def read_32t(fobj, start_length, size):",
            "    # The 128x128 icon seems to have an extra header for some reason.",
            "    (start, length) = start_length",
            "    fobj.seek(start)",
            "    sig = fobj.read(4)",
            "    if sig != b\"\\x00\\x00\\x00\\x00\":",
            "        raise SyntaxError(\"Unknown signature, expecting 0x00000000\")",
            "    return read_32(fobj, (start + 4, length - 4), size)",
            "",
            "",
            "def read_32(fobj, start_length, size):",
            "    \"\"\"",
            "    Read a 32bit RGB icon resource.  Seems to be either uncompressed or",
            "    an RLE packbits-like scheme.",
            "    \"\"\"",
            "    (start, length) = start_length",
            "    fobj.seek(start)",
            "    pixel_size = (size[0] * size[2], size[1] * size[2])",
            "    sizesq = pixel_size[0] * pixel_size[1]",
            "    if length == sizesq * 3:",
            "        # uncompressed (\"RGBRGBGB\")",
            "        indata = fobj.read(length)",
            "        im = Image.frombuffer(\"RGB\", pixel_size, indata, \"raw\", \"RGB\", 0, 1)",
            "    else:",
            "        # decode image",
            "        im = Image.new(\"RGB\", pixel_size, None)",
            "        for band_ix in range(3):",
            "            data = []",
            "            bytesleft = sizesq",
            "            while bytesleft > 0:",
            "                byte = fobj.read(1)",
            "                if not byte:",
            "                    break",
            "                byte = byte[0]",
            "                if byte & 0x80:",
            "                    blocksize = byte - 125",
            "                    byte = fobj.read(1)",
            "                    for i in range(blocksize):",
            "                        data.append(byte)",
            "                else:",
            "                    blocksize = byte + 1",
            "                    data.append(fobj.read(blocksize))",
            "                bytesleft -= blocksize",
            "                if bytesleft <= 0:",
            "                    break",
            "            if bytesleft != 0:",
            "                raise SyntaxError(f\"Error reading channel [{repr(bytesleft)} left]\")",
            "            band = Image.frombuffer(\"L\", pixel_size, b\"\".join(data), \"raw\", \"L\", 0, 1)",
            "            im.im.putband(band.im, band_ix)",
            "    return {\"RGB\": im}",
            "",
            "",
            "def read_mk(fobj, start_length, size):",
            "    # Alpha masks seem to be uncompressed",
            "    start = start_length[0]",
            "    fobj.seek(start)",
            "    pixel_size = (size[0] * size[2], size[1] * size[2])",
            "    sizesq = pixel_size[0] * pixel_size[1]",
            "    band = Image.frombuffer(\"L\", pixel_size, fobj.read(sizesq), \"raw\", \"L\", 0, 1)",
            "    return {\"A\": band}",
            "",
            "",
            "def read_png_or_jpeg2000(fobj, start_length, size):",
            "    (start, length) = start_length",
            "    fobj.seek(start)",
            "    sig = fobj.read(12)",
            "    if sig[:8] == b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\":",
            "        fobj.seek(start)",
            "        im = PngImagePlugin.PngImageFile(fobj)",
            "        return {\"RGBA\": im}",
            "    elif (",
            "        sig[:4] == b\"\\xff\\x4f\\xff\\x51\"",
            "        or sig[:4] == b\"\\x0d\\x0a\\x87\\x0a\"",
            "        or sig == b\"\\x00\\x00\\x00\\x0cjP  \\x0d\\x0a\\x87\\x0a\"",
            "    ):",
            "        if not enable_jpeg2k:",
            "            raise ValueError(",
            "                \"Unsupported icon subimage format (rebuild PIL \"",
            "                \"with JPEG 2000 support to fix this)\"",
            "            )",
            "        # j2k, jpc or j2c",
            "        fobj.seek(start)",
            "        jp2kstream = fobj.read(length)",
            "        f = io.BytesIO(jp2kstream)",
            "        im = Jpeg2KImagePlugin.Jpeg2KImageFile(f)",
            "        if im.mode != \"RGBA\":",
            "            im = im.convert(\"RGBA\")",
            "        return {\"RGBA\": im}",
            "    else:",
            "        raise ValueError(\"Unsupported icon subimage format\")",
            "",
            "",
            "class IcnsFile:",
            "",
            "    SIZES = {",
            "        (512, 512, 2): [(b\"ic10\", read_png_or_jpeg2000)],",
            "        (512, 512, 1): [(b\"ic09\", read_png_or_jpeg2000)],",
            "        (256, 256, 2): [(b\"ic14\", read_png_or_jpeg2000)],",
            "        (256, 256, 1): [(b\"ic08\", read_png_or_jpeg2000)],",
            "        (128, 128, 2): [(b\"ic13\", read_png_or_jpeg2000)],",
            "        (128, 128, 1): [",
            "            (b\"ic07\", read_png_or_jpeg2000),",
            "            (b\"it32\", read_32t),",
            "            (b\"t8mk\", read_mk),",
            "        ],",
            "        (64, 64, 1): [(b\"icp6\", read_png_or_jpeg2000)],",
            "        (32, 32, 2): [(b\"ic12\", read_png_or_jpeg2000)],",
            "        (48, 48, 1): [(b\"ih32\", read_32), (b\"h8mk\", read_mk)],",
            "        (32, 32, 1): [",
            "            (b\"icp5\", read_png_or_jpeg2000),",
            "            (b\"il32\", read_32),",
            "            (b\"l8mk\", read_mk),",
            "        ],",
            "        (16, 16, 2): [(b\"ic11\", read_png_or_jpeg2000)],",
            "        (16, 16, 1): [",
            "            (b\"icp4\", read_png_or_jpeg2000),",
            "            (b\"is32\", read_32),",
            "            (b\"s8mk\", read_mk),",
            "        ],",
            "    }",
            "",
            "    def __init__(self, fobj):",
            "        \"\"\"",
            "        fobj is a file-like object as an icns resource",
            "        \"\"\"",
            "        # signature : (start, length)",
            "        self.dct = dct = {}",
            "        self.fobj = fobj",
            "        sig, filesize = nextheader(fobj)",
            "        if sig != b\"icns\":",
            "            raise SyntaxError(\"not an icns file\")",
            "        i = HEADERSIZE",
            "        while i < filesize:",
            "            sig, blocksize = nextheader(fobj)",
            "            if blocksize <= 0:",
            "                raise SyntaxError(\"invalid block header\")",
            "            i += HEADERSIZE",
            "            blocksize -= HEADERSIZE",
            "            dct[sig] = (i, blocksize)",
            "            fobj.seek(blocksize, io.SEEK_CUR)",
            "            i += blocksize",
            "",
            "    def itersizes(self):",
            "        sizes = []",
            "        for size, fmts in self.SIZES.items():",
            "            for (fmt, reader) in fmts:",
            "                if fmt in self.dct:",
            "                    sizes.append(size)",
            "                    break",
            "        return sizes",
            "",
            "    def bestsize(self):",
            "        sizes = self.itersizes()",
            "        if not sizes:",
            "            raise SyntaxError(\"No 32bit icon resources found\")",
            "        return max(sizes)",
            "",
            "    def dataforsize(self, size):",
            "        \"\"\"",
            "        Get an icon resource as {channel: array}.  Note that",
            "        the arrays are bottom-up like windows bitmaps and will likely",
            "        need to be flipped or transposed in some way.",
            "        \"\"\"",
            "        dct = {}",
            "        for code, reader in self.SIZES[size]:",
            "            desc = self.dct.get(code)",
            "            if desc is not None:",
            "                dct.update(reader(self.fobj, desc, size))",
            "        return dct",
            "",
            "    def getimage(self, size=None):",
            "        if size is None:",
            "            size = self.bestsize()",
            "        if len(size) == 2:",
            "            size = (size[0], size[1], 1)",
            "        channels = self.dataforsize(size)",
            "",
            "        im = channels.get(\"RGBA\", None)",
            "        if im:",
            "            return im",
            "",
            "        im = channels.get(\"RGB\").copy()",
            "        try:",
            "            im.putalpha(channels[\"A\"])",
            "        except KeyError:",
            "            pass",
            "        return im",
            "",
            "",
            "##",
            "# Image plugin for Mac OS icons.",
            "",
            "",
            "class IcnsImageFile(ImageFile.ImageFile):",
            "    \"\"\"",
            "    PIL image support for Mac OS .icns files.",
            "    Chooses the best resolution, but will possibly load",
            "    a different size image if you mutate the size attribute",
            "    before calling 'load'.",
            "",
            "    The info dictionary has a key 'sizes' that is a list",
            "    of sizes that the icns file has.",
            "    \"\"\"",
            "",
            "    format = \"ICNS\"",
            "    format_description = \"Mac OS icns resource\"",
            "",
            "    def _open(self):",
            "        self.icns = IcnsFile(self.fp)",
            "        self.mode = \"RGBA\"",
            "        self.info[\"sizes\"] = self.icns.itersizes()",
            "        self.best_size = self.icns.bestsize()",
            "        self.size = (",
            "            self.best_size[0] * self.best_size[2],",
            "            self.best_size[1] * self.best_size[2],",
            "        )",
            "",
            "    @property",
            "    def size(self):",
            "        return self._size",
            "",
            "    @size.setter",
            "    def size(self, value):",
            "        info_size = value",
            "        if info_size not in self.info[\"sizes\"] and len(info_size) == 2:",
            "            info_size = (info_size[0], info_size[1], 1)",
            "        if (",
            "            info_size not in self.info[\"sizes\"]",
            "            and len(info_size) == 3",
            "            and info_size[2] == 1",
            "        ):",
            "            simple_sizes = [",
            "                (size[0] * size[2], size[1] * size[2]) for size in self.info[\"sizes\"]",
            "            ]",
            "            if value in simple_sizes:",
            "                info_size = self.info[\"sizes\"][simple_sizes.index(value)]",
            "        if info_size not in self.info[\"sizes\"]:",
            "            raise ValueError(\"This is not one of the allowed sizes of this image\")",
            "        self._size = value",
            "",
            "    def load(self):",
            "        if len(self.size) == 3:",
            "            self.best_size = self.size",
            "            self.size = (",
            "                self.best_size[0] * self.best_size[2],",
            "                self.best_size[1] * self.best_size[2],",
            "            )",
            "",
            "        Image.Image.load(self)",
            "        if self.im and self.im.size == self.size:",
            "            # Already loaded",
            "            return",
            "        self.load_prepare()",
            "        # This is likely NOT the best way to do it, but whatever.",
            "        im = self.icns.getimage(self.best_size)",
            "",
            "        # If this is a PNG or JPEG 2000, it won't be loaded yet",
            "        im.load()",
            "",
            "        self.im = im.im",
            "        self.mode = im.mode",
            "        self.size = im.size",
            "        self.load_end()",
            "",
            "",
            "def _save(im, fp, filename):",
            "    \"\"\"",
            "    Saves the image as a series of PNG files,",
            "    that are then converted to a .icns file",
            "    using the macOS command line utility 'iconutil'.",
            "",
            "    macOS only.",
            "    \"\"\"",
            "    if hasattr(fp, \"flush\"):",
            "        fp.flush()",
            "",
            "    # create the temporary set of pngs",
            "    with tempfile.TemporaryDirectory(\".iconset\") as iconset:",
            "        provided_images = {",
            "            im.width: im for im in im.encoderinfo.get(\"append_images\", [])",
            "        }",
            "        last_w = None",
            "        second_path = None",
            "        for w in [16, 32, 128, 256, 512]:",
            "            prefix = f\"icon_{w}x{w}\"",
            "",
            "            first_path = os.path.join(iconset, prefix + \".png\")",
            "            if last_w == w:",
            "                shutil.copyfile(second_path, first_path)",
            "            else:",
            "                im_w = provided_images.get(w, im.resize((w, w), Image.LANCZOS))",
            "                im_w.save(first_path)",
            "",
            "            second_path = os.path.join(iconset, prefix + \"@2x.png\")",
            "            im_w2 = provided_images.get(w * 2, im.resize((w * 2, w * 2), Image.LANCZOS))",
            "            im_w2.save(second_path)",
            "            last_w = w * 2",
            "",
            "        # iconutil -c icns -o {} {}",
            "",
            "        fp_only = not filename",
            "        if fp_only:",
            "            f, filename = tempfile.mkstemp(\".icns\")",
            "            os.close(f)",
            "        convert_cmd = [\"iconutil\", \"-c\", \"icns\", \"-o\", filename, iconset]",
            "        convert_proc = subprocess.Popen(",
            "            convert_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL",
            "        )",
            "",
            "        convert_proc.stdout.close()",
            "",
            "        retcode = convert_proc.wait()",
            "",
            "        if retcode:",
            "            raise subprocess.CalledProcessError(retcode, convert_cmd)",
            "",
            "        if fp_only:",
            "            with open(filename, \"rb\") as f:",
            "                fp.write(f.read())",
            "",
            "",
            "Image.register_open(IcnsImageFile.format, IcnsImageFile, lambda x: x[:4] == b\"icns\")",
            "Image.register_extension(IcnsImageFile.format, \".icns\")",
            "",
            "if sys.platform == \"darwin\":",
            "    Image.register_save(IcnsImageFile.format, _save)",
            "",
            "    Image.register_mime(IcnsImageFile.format, \"image/icns\")",
            "",
            "",
            "if __name__ == \"__main__\":",
            "",
            "    if len(sys.argv) < 2:",
            "        print(\"Syntax: python IcnsImagePlugin.py [file]\")",
            "        sys.exit()",
            "",
            "    with open(sys.argv[1], \"rb\") as fp:",
            "        imf = IcnsImageFile(fp)",
            "        for size in imf.info[\"sizes\"]:",
            "            imf.size = size",
            "            imf.save(\"out-%s-%s-%s.png\" % size)",
            "        with Image.open(sys.argv[1]) as im:",
            "            im.save(\"out.png\")",
            "        if sys.platform == \"windows\":",
            "            os.startfile(\"out.png\")"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# macOS icns file decoder, based on icns.py by Bob Ippolito.",
            "#",
            "# history:",
            "# 2004-10-09 fl   Turned into a PIL plugin; removed 2.3 dependencies.",
            "#",
            "# Copyright (c) 2004 by Bob Ippolito.",
            "# Copyright (c) 2004 by Secret Labs.",
            "# Copyright (c) 2004 by Fredrik Lundh.",
            "# Copyright (c) 2014 by Alastair Houghton.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "import os",
            "import shutil",
            "import struct",
            "import subprocess",
            "import sys",
            "import tempfile",
            "",
            "from PIL import Image, ImageFile, PngImagePlugin, features",
            "",
            "enable_jpeg2k = features.check_codec(\"jpg_2000\")",
            "if enable_jpeg2k:",
            "    from PIL import Jpeg2KImagePlugin",
            "",
            "HEADERSIZE = 8",
            "",
            "",
            "def nextheader(fobj):",
            "    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))",
            "",
            "",
            "def read_32t(fobj, start_length, size):",
            "    # The 128x128 icon seems to have an extra header for some reason.",
            "    (start, length) = start_length",
            "    fobj.seek(start)",
            "    sig = fobj.read(4)",
            "    if sig != b\"\\x00\\x00\\x00\\x00\":",
            "        raise SyntaxError(\"Unknown signature, expecting 0x00000000\")",
            "    return read_32(fobj, (start + 4, length - 4), size)",
            "",
            "",
            "def read_32(fobj, start_length, size):",
            "    \"\"\"",
            "    Read a 32bit RGB icon resource.  Seems to be either uncompressed or",
            "    an RLE packbits-like scheme.",
            "    \"\"\"",
            "    (start, length) = start_length",
            "    fobj.seek(start)",
            "    pixel_size = (size[0] * size[2], size[1] * size[2])",
            "    sizesq = pixel_size[0] * pixel_size[1]",
            "    if length == sizesq * 3:",
            "        # uncompressed (\"RGBRGBGB\")",
            "        indata = fobj.read(length)",
            "        im = Image.frombuffer(\"RGB\", pixel_size, indata, \"raw\", \"RGB\", 0, 1)",
            "    else:",
            "        # decode image",
            "        im = Image.new(\"RGB\", pixel_size, None)",
            "        for band_ix in range(3):",
            "            data = []",
            "            bytesleft = sizesq",
            "            while bytesleft > 0:",
            "                byte = fobj.read(1)",
            "                if not byte:",
            "                    break",
            "                byte = byte[0]",
            "                if byte & 0x80:",
            "                    blocksize = byte - 125",
            "                    byte = fobj.read(1)",
            "                    for i in range(blocksize):",
            "                        data.append(byte)",
            "                else:",
            "                    blocksize = byte + 1",
            "                    data.append(fobj.read(blocksize))",
            "                bytesleft -= blocksize",
            "                if bytesleft <= 0:",
            "                    break",
            "            if bytesleft != 0:",
            "                raise SyntaxError(f\"Error reading channel [{repr(bytesleft)} left]\")",
            "            band = Image.frombuffer(\"L\", pixel_size, b\"\".join(data), \"raw\", \"L\", 0, 1)",
            "            im.im.putband(band.im, band_ix)",
            "    return {\"RGB\": im}",
            "",
            "",
            "def read_mk(fobj, start_length, size):",
            "    # Alpha masks seem to be uncompressed",
            "    start = start_length[0]",
            "    fobj.seek(start)",
            "    pixel_size = (size[0] * size[2], size[1] * size[2])",
            "    sizesq = pixel_size[0] * pixel_size[1]",
            "    band = Image.frombuffer(\"L\", pixel_size, fobj.read(sizesq), \"raw\", \"L\", 0, 1)",
            "    return {\"A\": band}",
            "",
            "",
            "def read_png_or_jpeg2000(fobj, start_length, size):",
            "    (start, length) = start_length",
            "    fobj.seek(start)",
            "    sig = fobj.read(12)",
            "    if sig[:8] == b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\":",
            "        fobj.seek(start)",
            "        im = PngImagePlugin.PngImageFile(fobj)",
            "        Image._decompression_bomb_check(im.size)",
            "        return {\"RGBA\": im}",
            "    elif (",
            "        sig[:4] == b\"\\xff\\x4f\\xff\\x51\"",
            "        or sig[:4] == b\"\\x0d\\x0a\\x87\\x0a\"",
            "        or sig == b\"\\x00\\x00\\x00\\x0cjP  \\x0d\\x0a\\x87\\x0a\"",
            "    ):",
            "        if not enable_jpeg2k:",
            "            raise ValueError(",
            "                \"Unsupported icon subimage format (rebuild PIL \"",
            "                \"with JPEG 2000 support to fix this)\"",
            "            )",
            "        # j2k, jpc or j2c",
            "        fobj.seek(start)",
            "        jp2kstream = fobj.read(length)",
            "        f = io.BytesIO(jp2kstream)",
            "        im = Jpeg2KImagePlugin.Jpeg2KImageFile(f)",
            "        Image._decompression_bomb_check(im.size)",
            "        if im.mode != \"RGBA\":",
            "            im = im.convert(\"RGBA\")",
            "        return {\"RGBA\": im}",
            "    else:",
            "        raise ValueError(\"Unsupported icon subimage format\")",
            "",
            "",
            "class IcnsFile:",
            "",
            "    SIZES = {",
            "        (512, 512, 2): [(b\"ic10\", read_png_or_jpeg2000)],",
            "        (512, 512, 1): [(b\"ic09\", read_png_or_jpeg2000)],",
            "        (256, 256, 2): [(b\"ic14\", read_png_or_jpeg2000)],",
            "        (256, 256, 1): [(b\"ic08\", read_png_or_jpeg2000)],",
            "        (128, 128, 2): [(b\"ic13\", read_png_or_jpeg2000)],",
            "        (128, 128, 1): [",
            "            (b\"ic07\", read_png_or_jpeg2000),",
            "            (b\"it32\", read_32t),",
            "            (b\"t8mk\", read_mk),",
            "        ],",
            "        (64, 64, 1): [(b\"icp6\", read_png_or_jpeg2000)],",
            "        (32, 32, 2): [(b\"ic12\", read_png_or_jpeg2000)],",
            "        (48, 48, 1): [(b\"ih32\", read_32), (b\"h8mk\", read_mk)],",
            "        (32, 32, 1): [",
            "            (b\"icp5\", read_png_or_jpeg2000),",
            "            (b\"il32\", read_32),",
            "            (b\"l8mk\", read_mk),",
            "        ],",
            "        (16, 16, 2): [(b\"ic11\", read_png_or_jpeg2000)],",
            "        (16, 16, 1): [",
            "            (b\"icp4\", read_png_or_jpeg2000),",
            "            (b\"is32\", read_32),",
            "            (b\"s8mk\", read_mk),",
            "        ],",
            "    }",
            "",
            "    def __init__(self, fobj):",
            "        \"\"\"",
            "        fobj is a file-like object as an icns resource",
            "        \"\"\"",
            "        # signature : (start, length)",
            "        self.dct = dct = {}",
            "        self.fobj = fobj",
            "        sig, filesize = nextheader(fobj)",
            "        if sig != b\"icns\":",
            "            raise SyntaxError(\"not an icns file\")",
            "        i = HEADERSIZE",
            "        while i < filesize:",
            "            sig, blocksize = nextheader(fobj)",
            "            if blocksize <= 0:",
            "                raise SyntaxError(\"invalid block header\")",
            "            i += HEADERSIZE",
            "            blocksize -= HEADERSIZE",
            "            dct[sig] = (i, blocksize)",
            "            fobj.seek(blocksize, io.SEEK_CUR)",
            "            i += blocksize",
            "",
            "    def itersizes(self):",
            "        sizes = []",
            "        for size, fmts in self.SIZES.items():",
            "            for (fmt, reader) in fmts:",
            "                if fmt in self.dct:",
            "                    sizes.append(size)",
            "                    break",
            "        return sizes",
            "",
            "    def bestsize(self):",
            "        sizes = self.itersizes()",
            "        if not sizes:",
            "            raise SyntaxError(\"No 32bit icon resources found\")",
            "        return max(sizes)",
            "",
            "    def dataforsize(self, size):",
            "        \"\"\"",
            "        Get an icon resource as {channel: array}.  Note that",
            "        the arrays are bottom-up like windows bitmaps and will likely",
            "        need to be flipped or transposed in some way.",
            "        \"\"\"",
            "        dct = {}",
            "        for code, reader in self.SIZES[size]:",
            "            desc = self.dct.get(code)",
            "            if desc is not None:",
            "                dct.update(reader(self.fobj, desc, size))",
            "        return dct",
            "",
            "    def getimage(self, size=None):",
            "        if size is None:",
            "            size = self.bestsize()",
            "        if len(size) == 2:",
            "            size = (size[0], size[1], 1)",
            "        channels = self.dataforsize(size)",
            "",
            "        im = channels.get(\"RGBA\", None)",
            "        if im:",
            "            return im",
            "",
            "        im = channels.get(\"RGB\").copy()",
            "        try:",
            "            im.putalpha(channels[\"A\"])",
            "        except KeyError:",
            "            pass",
            "        return im",
            "",
            "",
            "##",
            "# Image plugin for Mac OS icons.",
            "",
            "",
            "class IcnsImageFile(ImageFile.ImageFile):",
            "    \"\"\"",
            "    PIL image support for Mac OS .icns files.",
            "    Chooses the best resolution, but will possibly load",
            "    a different size image if you mutate the size attribute",
            "    before calling 'load'.",
            "",
            "    The info dictionary has a key 'sizes' that is a list",
            "    of sizes that the icns file has.",
            "    \"\"\"",
            "",
            "    format = \"ICNS\"",
            "    format_description = \"Mac OS icns resource\"",
            "",
            "    def _open(self):",
            "        self.icns = IcnsFile(self.fp)",
            "        self.mode = \"RGBA\"",
            "        self.info[\"sizes\"] = self.icns.itersizes()",
            "        self.best_size = self.icns.bestsize()",
            "        self.size = (",
            "            self.best_size[0] * self.best_size[2],",
            "            self.best_size[1] * self.best_size[2],",
            "        )",
            "",
            "    @property",
            "    def size(self):",
            "        return self._size",
            "",
            "    @size.setter",
            "    def size(self, value):",
            "        info_size = value",
            "        if info_size not in self.info[\"sizes\"] and len(info_size) == 2:",
            "            info_size = (info_size[0], info_size[1], 1)",
            "        if (",
            "            info_size not in self.info[\"sizes\"]",
            "            and len(info_size) == 3",
            "            and info_size[2] == 1",
            "        ):",
            "            simple_sizes = [",
            "                (size[0] * size[2], size[1] * size[2]) for size in self.info[\"sizes\"]",
            "            ]",
            "            if value in simple_sizes:",
            "                info_size = self.info[\"sizes\"][simple_sizes.index(value)]",
            "        if info_size not in self.info[\"sizes\"]:",
            "            raise ValueError(\"This is not one of the allowed sizes of this image\")",
            "        self._size = value",
            "",
            "    def load(self):",
            "        if len(self.size) == 3:",
            "            self.best_size = self.size",
            "            self.size = (",
            "                self.best_size[0] * self.best_size[2],",
            "                self.best_size[1] * self.best_size[2],",
            "            )",
            "",
            "        Image.Image.load(self)",
            "        if self.im and self.im.size == self.size:",
            "            # Already loaded",
            "            return",
            "        self.load_prepare()",
            "        # This is likely NOT the best way to do it, but whatever.",
            "        im = self.icns.getimage(self.best_size)",
            "",
            "        # If this is a PNG or JPEG 2000, it won't be loaded yet",
            "        im.load()",
            "",
            "        self.im = im.im",
            "        self.mode = im.mode",
            "        self.size = im.size",
            "        self.load_end()",
            "",
            "",
            "def _save(im, fp, filename):",
            "    \"\"\"",
            "    Saves the image as a series of PNG files,",
            "    that are then converted to a .icns file",
            "    using the macOS command line utility 'iconutil'.",
            "",
            "    macOS only.",
            "    \"\"\"",
            "    if hasattr(fp, \"flush\"):",
            "        fp.flush()",
            "",
            "    # create the temporary set of pngs",
            "    with tempfile.TemporaryDirectory(\".iconset\") as iconset:",
            "        provided_images = {",
            "            im.width: im for im in im.encoderinfo.get(\"append_images\", [])",
            "        }",
            "        last_w = None",
            "        second_path = None",
            "        for w in [16, 32, 128, 256, 512]:",
            "            prefix = f\"icon_{w}x{w}\"",
            "",
            "            first_path = os.path.join(iconset, prefix + \".png\")",
            "            if last_w == w:",
            "                shutil.copyfile(second_path, first_path)",
            "            else:",
            "                im_w = provided_images.get(w, im.resize((w, w), Image.LANCZOS))",
            "                im_w.save(first_path)",
            "",
            "            second_path = os.path.join(iconset, prefix + \"@2x.png\")",
            "            im_w2 = provided_images.get(w * 2, im.resize((w * 2, w * 2), Image.LANCZOS))",
            "            im_w2.save(second_path)",
            "            last_w = w * 2",
            "",
            "        # iconutil -c icns -o {} {}",
            "",
            "        fp_only = not filename",
            "        if fp_only:",
            "            f, filename = tempfile.mkstemp(\".icns\")",
            "            os.close(f)",
            "        convert_cmd = [\"iconutil\", \"-c\", \"icns\", \"-o\", filename, iconset]",
            "        convert_proc = subprocess.Popen(",
            "            convert_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL",
            "        )",
            "",
            "        convert_proc.stdout.close()",
            "",
            "        retcode = convert_proc.wait()",
            "",
            "        if retcode:",
            "            raise subprocess.CalledProcessError(retcode, convert_cmd)",
            "",
            "        if fp_only:",
            "            with open(filename, \"rb\") as f:",
            "                fp.write(f.read())",
            "",
            "",
            "Image.register_open(IcnsImageFile.format, IcnsImageFile, lambda x: x[:4] == b\"icns\")",
            "Image.register_extension(IcnsImageFile.format, \".icns\")",
            "",
            "if sys.platform == \"darwin\":",
            "    Image.register_save(IcnsImageFile.format, _save)",
            "",
            "    Image.register_mime(IcnsImageFile.format, \"image/icns\")",
            "",
            "",
            "if __name__ == \"__main__\":",
            "",
            "    if len(sys.argv) < 2:",
            "        print(\"Syntax: python IcnsImagePlugin.py [file]\")",
            "        sys.exit()",
            "",
            "    with open(sys.argv[1], \"rb\") as fp:",
            "        imf = IcnsImageFile(fp)",
            "        for size in imf.info[\"sizes\"]:",
            "            imf.size = size",
            "            imf.save(\"out-%s-%s-%s.png\" % size)",
            "        with Image.open(sys.argv[1]) as im:",
            "            im.save(\"out.png\")",
            "        if sys.platform == \"windows\":",
            "            os.startfile(\"out.png\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.PIL.PcxImagePlugin"
        ]
    },
    "src/PIL/IcoImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         if data[:8] == PngImagePlugin._MAGIC:"
            },
            "1": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "             # png frame"
            },
            "2": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "             im = PngImagePlugin.PngImageFile(self.buf)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+            Image._decompression_bomb_check(im.size)"
            },
            "4": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         else:"
            },
            "5": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "             # XOR + AND mask bmp frame"
            },
            "6": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "             im = BmpImagePlugin.DibImageFile(self.buf)"
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# Windows Icon support for PIL",
            "#",
            "# History:",
            "#       96-05-27 fl     Created",
            "#",
            "# Copyright (c) Secret Labs AB 1997.",
            "# Copyright (c) Fredrik Lundh 1996.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "# This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis",
            "# <casadebender@gmail.com>.",
            "# https://code.google.com/archive/p/casadebender/wikis/Win32IconImagePlugin.wiki",
            "#",
            "# Icon format references:",
            "#   * https://en.wikipedia.org/wiki/ICO_(file_format)",
            "#   * https://msdn.microsoft.com/en-us/library/ms997538.aspx",
            "",
            "",
            "import struct",
            "import warnings",
            "from io import BytesIO",
            "from math import ceil, log",
            "",
            "from . import BmpImagePlugin, Image, ImageFile, PngImagePlugin",
            "from ._binary import i16le as i16",
            "from ._binary import i32le as i32",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "_MAGIC = b\"\\0\\0\\1\\0\"",
            "",
            "",
            "def _save(im, fp, filename):",
            "    fp.write(_MAGIC)  # (2+2)",
            "    sizes = im.encoderinfo.get(",
            "        \"sizes\",",
            "        [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],",
            "    )",
            "    width, height = im.size",
            "    sizes = filter(",
            "        lambda x: False",
            "        if (x[0] > width or x[1] > height or x[0] > 256 or x[1] > 256)",
            "        else True,",
            "        sizes,",
            "    )",
            "    sizes = list(sizes)",
            "    fp.write(struct.pack(\"<H\", len(sizes)))  # idCount(2)",
            "    offset = fp.tell() + len(sizes) * 16",
            "    provided_images = {im.size: im for im in im.encoderinfo.get(\"append_images\", [])}",
            "    for size in sizes:",
            "        width, height = size",
            "        # 0 means 256",
            "        fp.write(struct.pack(\"B\", width if width < 256 else 0))  # bWidth(1)",
            "        fp.write(struct.pack(\"B\", height if height < 256 else 0))  # bHeight(1)",
            "        fp.write(b\"\\0\")  # bColorCount(1)",
            "        fp.write(b\"\\0\")  # bReserved(1)",
            "        fp.write(b\"\\0\\0\")  # wPlanes(2)",
            "        fp.write(struct.pack(\"<H\", 32))  # wBitCount(2)",
            "",
            "        image_io = BytesIO()",
            "        tmp = provided_images.get(size)",
            "        if not tmp:",
            "            # TODO: invent a more convenient method for proportional scalings",
            "            tmp = im.copy()",
            "            tmp.thumbnail(size, Image.LANCZOS, reducing_gap=None)",
            "        tmp.save(image_io, \"png\")",
            "        image_io.seek(0)",
            "        image_bytes = image_io.read()",
            "        bytes_len = len(image_bytes)",
            "        fp.write(struct.pack(\"<I\", bytes_len))  # dwBytesInRes(4)",
            "        fp.write(struct.pack(\"<I\", offset))  # dwImageOffset(4)",
            "        current = fp.tell()",
            "        fp.seek(offset)",
            "        fp.write(image_bytes)",
            "        offset = offset + bytes_len",
            "        fp.seek(current)",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:4] == _MAGIC",
            "",
            "",
            "class IcoFile:",
            "    def __init__(self, buf):",
            "        \"\"\"",
            "        Parse image from file-like object containing ico file data",
            "        \"\"\"",
            "",
            "        # check magic",
            "        s = buf.read(6)",
            "        if not _accept(s):",
            "            raise SyntaxError(\"not an ICO file\")",
            "",
            "        self.buf = buf",
            "        self.entry = []",
            "",
            "        # Number of items in file",
            "        self.nb_items = i16(s, 4)",
            "",
            "        # Get headers for each item",
            "        for i in range(self.nb_items):",
            "            s = buf.read(16)",
            "",
            "            icon_header = {",
            "                \"width\": s[0],",
            "                \"height\": s[1],",
            "                \"nb_color\": s[2],  # No. of colors in image (0 if >=8bpp)",
            "                \"reserved\": s[3],",
            "                \"planes\": i16(s, 4),",
            "                \"bpp\": i16(s, 6),",
            "                \"size\": i32(s, 8),",
            "                \"offset\": i32(s, 12),",
            "            }",
            "",
            "            # See Wikipedia",
            "            for j in (\"width\", \"height\"):",
            "                if not icon_header[j]:",
            "                    icon_header[j] = 256",
            "",
            "            # See Wikipedia notes about color depth.",
            "            # We need this just to differ images with equal sizes",
            "            icon_header[\"color_depth\"] = (",
            "                icon_header[\"bpp\"]",
            "                or (",
            "                    icon_header[\"nb_color\"] != 0",
            "                    and ceil(log(icon_header[\"nb_color\"], 2))",
            "                )",
            "                or 256",
            "            )",
            "",
            "            icon_header[\"dim\"] = (icon_header[\"width\"], icon_header[\"height\"])",
            "            icon_header[\"square\"] = icon_header[\"width\"] * icon_header[\"height\"]",
            "",
            "            self.entry.append(icon_header)",
            "",
            "        self.entry = sorted(self.entry, key=lambda x: x[\"color_depth\"])",
            "        # ICO images are usually squares",
            "        # self.entry = sorted(self.entry, key=lambda x: x['width'])",
            "        self.entry = sorted(self.entry, key=lambda x: x[\"square\"])",
            "        self.entry.reverse()",
            "",
            "    def sizes(self):",
            "        \"\"\"",
            "        Get a list of all available icon sizes and color depths.",
            "        \"\"\"",
            "        return {(h[\"width\"], h[\"height\"]) for h in self.entry}",
            "",
            "    def getentryindex(self, size, bpp=False):",
            "        for (i, h) in enumerate(self.entry):",
            "            if size == h[\"dim\"] and (bpp is False or bpp == h[\"color_depth\"]):",
            "                return i",
            "        return 0",
            "",
            "    def getimage(self, size, bpp=False):",
            "        \"\"\"",
            "        Get an image from the icon",
            "        \"\"\"",
            "        return self.frame(self.getentryindex(size, bpp))",
            "",
            "    def frame(self, idx):",
            "        \"\"\"",
            "        Get an image from frame idx",
            "        \"\"\"",
            "",
            "        header = self.entry[idx]",
            "",
            "        self.buf.seek(header[\"offset\"])",
            "        data = self.buf.read(8)",
            "        self.buf.seek(header[\"offset\"])",
            "",
            "        if data[:8] == PngImagePlugin._MAGIC:",
            "            # png frame",
            "            im = PngImagePlugin.PngImageFile(self.buf)",
            "        else:",
            "            # XOR + AND mask bmp frame",
            "            im = BmpImagePlugin.DibImageFile(self.buf)",
            "            Image._decompression_bomb_check(im.size)",
            "",
            "            # change tile dimension to only encompass XOR image",
            "            im._size = (im.size[0], int(im.size[1] / 2))",
            "            d, e, o, a = im.tile[0]",
            "            im.tile[0] = d, (0, 0) + im.size, o, a",
            "",
            "            # figure out where AND mask image starts",
            "            mode = a[0]",
            "            bpp = 8",
            "            for k, v in BmpImagePlugin.BIT2MODE.items():",
            "                if mode == v[1]:",
            "                    bpp = k",
            "                    break",
            "",
            "            if 32 == bpp:",
            "                # 32-bit color depth icon image allows semitransparent areas",
            "                # PIL's DIB format ignores transparency bits, recover them.",
            "                # The DIB is packed in BGRX byte order where X is the alpha",
            "                # channel.",
            "",
            "                # Back up to start of bmp data",
            "                self.buf.seek(o)",
            "                # extract every 4th byte (eg. 3,7,11,15,...)",
            "                alpha_bytes = self.buf.read(im.size[0] * im.size[1] * 4)[3::4]",
            "",
            "                # convert to an 8bpp grayscale image",
            "                mask = Image.frombuffer(",
            "                    \"L\",  # 8bpp",
            "                    im.size,  # (w, h)",
            "                    alpha_bytes,  # source chars",
            "                    \"raw\",  # raw decoder",
            "                    (\"L\", 0, -1),  # 8bpp inverted, unpadded, reversed",
            "                )",
            "            else:",
            "                # get AND image from end of bitmap",
            "                w = im.size[0]",
            "                if (w % 32) > 0:",
            "                    # bitmap row data is aligned to word boundaries",
            "                    w += 32 - (im.size[0] % 32)",
            "",
            "                # the total mask data is",
            "                # padded row size * height / bits per char",
            "",
            "                and_mask_offset = o + int(im.size[0] * im.size[1] * (bpp / 8.0))",
            "                total_bytes = int((w * im.size[1]) / 8)",
            "",
            "                self.buf.seek(and_mask_offset)",
            "                mask_data = self.buf.read(total_bytes)",
            "",
            "                # convert raw data to image",
            "                mask = Image.frombuffer(",
            "                    \"1\",  # 1 bpp",
            "                    im.size,  # (w, h)",
            "                    mask_data,  # source chars",
            "                    \"raw\",  # raw decoder",
            "                    (\"1;I\", int(w / 8), -1),  # 1bpp inverted, padded, reversed",
            "                )",
            "",
            "                # now we have two images, im is XOR image and mask is AND image",
            "",
            "            # apply mask image as alpha channel",
            "            im = im.convert(\"RGBA\")",
            "            im.putalpha(mask)",
            "",
            "        return im",
            "",
            "",
            "##",
            "# Image plugin for Windows Icon files.",
            "",
            "",
            "class IcoImageFile(ImageFile.ImageFile):",
            "    \"\"\"",
            "    PIL read-only image support for Microsoft Windows .ico files.",
            "",
            "    By default the largest resolution image in the file will be loaded. This",
            "    can be changed by altering the 'size' attribute before calling 'load'.",
            "",
            "    The info dictionary has a key 'sizes' that is a list of the sizes available",
            "    in the icon file.",
            "",
            "    Handles classic, XP and Vista icon formats.",
            "",
            "    When saving, PNG compression is used. Support for this was only added in",
            "    Windows Vista.",
            "",
            "    This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis",
            "    <casadebender@gmail.com>.",
            "    https://code.google.com/archive/p/casadebender/wikis/Win32IconImagePlugin.wiki",
            "    \"\"\"",
            "",
            "    format = \"ICO\"",
            "    format_description = \"Windows Icon\"",
            "",
            "    def _open(self):",
            "        self.ico = IcoFile(self.fp)",
            "        self.info[\"sizes\"] = self.ico.sizes()",
            "        self.size = self.ico.entry[0][\"dim\"]",
            "        self.load()",
            "",
            "    @property",
            "    def size(self):",
            "        return self._size",
            "",
            "    @size.setter",
            "    def size(self, value):",
            "        if value not in self.info[\"sizes\"]:",
            "            raise ValueError(\"This is not one of the allowed sizes of this image\")",
            "        self._size = value",
            "",
            "    def load(self):",
            "        if self.im and self.im.size == self.size:",
            "            # Already loaded",
            "            return",
            "        im = self.ico.getimage(self.size)",
            "        # if tile is PNG, it won't really be loaded yet",
            "        im.load()",
            "        self.im = im.im",
            "        self.mode = im.mode",
            "        if im.size != self.size:",
            "            warnings.warn(\"Image was not the expected size\")",
            "",
            "            index = self.ico.getentryindex(self.size)",
            "            sizes = list(self.info[\"sizes\"])",
            "            sizes[index] = im.size",
            "            self.info[\"sizes\"] = set(sizes)",
            "",
            "            self.size = im.size",
            "",
            "    def load_seek(self):",
            "        # Flag the ImageFile.Parser so that it",
            "        # just does all the decode at the end.",
            "        pass",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "Image.register_open(IcoImageFile.format, IcoImageFile, _accept)",
            "Image.register_save(IcoImageFile.format, _save)",
            "Image.register_extension(IcoImageFile.format, \".ico\")",
            "",
            "Image.register_mime(IcoImageFile.format, \"image/x-icon\")"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# Windows Icon support for PIL",
            "#",
            "# History:",
            "#       96-05-27 fl     Created",
            "#",
            "# Copyright (c) Secret Labs AB 1997.",
            "# Copyright (c) Fredrik Lundh 1996.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "# This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis",
            "# <casadebender@gmail.com>.",
            "# https://code.google.com/archive/p/casadebender/wikis/Win32IconImagePlugin.wiki",
            "#",
            "# Icon format references:",
            "#   * https://en.wikipedia.org/wiki/ICO_(file_format)",
            "#   * https://msdn.microsoft.com/en-us/library/ms997538.aspx",
            "",
            "",
            "import struct",
            "import warnings",
            "from io import BytesIO",
            "from math import ceil, log",
            "",
            "from . import BmpImagePlugin, Image, ImageFile, PngImagePlugin",
            "from ._binary import i16le as i16",
            "from ._binary import i32le as i32",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "_MAGIC = b\"\\0\\0\\1\\0\"",
            "",
            "",
            "def _save(im, fp, filename):",
            "    fp.write(_MAGIC)  # (2+2)",
            "    sizes = im.encoderinfo.get(",
            "        \"sizes\",",
            "        [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],",
            "    )",
            "    width, height = im.size",
            "    sizes = filter(",
            "        lambda x: False",
            "        if (x[0] > width or x[1] > height or x[0] > 256 or x[1] > 256)",
            "        else True,",
            "        sizes,",
            "    )",
            "    sizes = list(sizes)",
            "    fp.write(struct.pack(\"<H\", len(sizes)))  # idCount(2)",
            "    offset = fp.tell() + len(sizes) * 16",
            "    provided_images = {im.size: im for im in im.encoderinfo.get(\"append_images\", [])}",
            "    for size in sizes:",
            "        width, height = size",
            "        # 0 means 256",
            "        fp.write(struct.pack(\"B\", width if width < 256 else 0))  # bWidth(1)",
            "        fp.write(struct.pack(\"B\", height if height < 256 else 0))  # bHeight(1)",
            "        fp.write(b\"\\0\")  # bColorCount(1)",
            "        fp.write(b\"\\0\")  # bReserved(1)",
            "        fp.write(b\"\\0\\0\")  # wPlanes(2)",
            "        fp.write(struct.pack(\"<H\", 32))  # wBitCount(2)",
            "",
            "        image_io = BytesIO()",
            "        tmp = provided_images.get(size)",
            "        if not tmp:",
            "            # TODO: invent a more convenient method for proportional scalings",
            "            tmp = im.copy()",
            "            tmp.thumbnail(size, Image.LANCZOS, reducing_gap=None)",
            "        tmp.save(image_io, \"png\")",
            "        image_io.seek(0)",
            "        image_bytes = image_io.read()",
            "        bytes_len = len(image_bytes)",
            "        fp.write(struct.pack(\"<I\", bytes_len))  # dwBytesInRes(4)",
            "        fp.write(struct.pack(\"<I\", offset))  # dwImageOffset(4)",
            "        current = fp.tell()",
            "        fp.seek(offset)",
            "        fp.write(image_bytes)",
            "        offset = offset + bytes_len",
            "        fp.seek(current)",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:4] == _MAGIC",
            "",
            "",
            "class IcoFile:",
            "    def __init__(self, buf):",
            "        \"\"\"",
            "        Parse image from file-like object containing ico file data",
            "        \"\"\"",
            "",
            "        # check magic",
            "        s = buf.read(6)",
            "        if not _accept(s):",
            "            raise SyntaxError(\"not an ICO file\")",
            "",
            "        self.buf = buf",
            "        self.entry = []",
            "",
            "        # Number of items in file",
            "        self.nb_items = i16(s, 4)",
            "",
            "        # Get headers for each item",
            "        for i in range(self.nb_items):",
            "            s = buf.read(16)",
            "",
            "            icon_header = {",
            "                \"width\": s[0],",
            "                \"height\": s[1],",
            "                \"nb_color\": s[2],  # No. of colors in image (0 if >=8bpp)",
            "                \"reserved\": s[3],",
            "                \"planes\": i16(s, 4),",
            "                \"bpp\": i16(s, 6),",
            "                \"size\": i32(s, 8),",
            "                \"offset\": i32(s, 12),",
            "            }",
            "",
            "            # See Wikipedia",
            "            for j in (\"width\", \"height\"):",
            "                if not icon_header[j]:",
            "                    icon_header[j] = 256",
            "",
            "            # See Wikipedia notes about color depth.",
            "            # We need this just to differ images with equal sizes",
            "            icon_header[\"color_depth\"] = (",
            "                icon_header[\"bpp\"]",
            "                or (",
            "                    icon_header[\"nb_color\"] != 0",
            "                    and ceil(log(icon_header[\"nb_color\"], 2))",
            "                )",
            "                or 256",
            "            )",
            "",
            "            icon_header[\"dim\"] = (icon_header[\"width\"], icon_header[\"height\"])",
            "            icon_header[\"square\"] = icon_header[\"width\"] * icon_header[\"height\"]",
            "",
            "            self.entry.append(icon_header)",
            "",
            "        self.entry = sorted(self.entry, key=lambda x: x[\"color_depth\"])",
            "        # ICO images are usually squares",
            "        # self.entry = sorted(self.entry, key=lambda x: x['width'])",
            "        self.entry = sorted(self.entry, key=lambda x: x[\"square\"])",
            "        self.entry.reverse()",
            "",
            "    def sizes(self):",
            "        \"\"\"",
            "        Get a list of all available icon sizes and color depths.",
            "        \"\"\"",
            "        return {(h[\"width\"], h[\"height\"]) for h in self.entry}",
            "",
            "    def getentryindex(self, size, bpp=False):",
            "        for (i, h) in enumerate(self.entry):",
            "            if size == h[\"dim\"] and (bpp is False or bpp == h[\"color_depth\"]):",
            "                return i",
            "        return 0",
            "",
            "    def getimage(self, size, bpp=False):",
            "        \"\"\"",
            "        Get an image from the icon",
            "        \"\"\"",
            "        return self.frame(self.getentryindex(size, bpp))",
            "",
            "    def frame(self, idx):",
            "        \"\"\"",
            "        Get an image from frame idx",
            "        \"\"\"",
            "",
            "        header = self.entry[idx]",
            "",
            "        self.buf.seek(header[\"offset\"])",
            "        data = self.buf.read(8)",
            "        self.buf.seek(header[\"offset\"])",
            "",
            "        if data[:8] == PngImagePlugin._MAGIC:",
            "            # png frame",
            "            im = PngImagePlugin.PngImageFile(self.buf)",
            "            Image._decompression_bomb_check(im.size)",
            "        else:",
            "            # XOR + AND mask bmp frame",
            "            im = BmpImagePlugin.DibImageFile(self.buf)",
            "            Image._decompression_bomb_check(im.size)",
            "",
            "            # change tile dimension to only encompass XOR image",
            "            im._size = (im.size[0], int(im.size[1] / 2))",
            "            d, e, o, a = im.tile[0]",
            "            im.tile[0] = d, (0, 0) + im.size, o, a",
            "",
            "            # figure out where AND mask image starts",
            "            mode = a[0]",
            "            bpp = 8",
            "            for k, v in BmpImagePlugin.BIT2MODE.items():",
            "                if mode == v[1]:",
            "                    bpp = k",
            "                    break",
            "",
            "            if 32 == bpp:",
            "                # 32-bit color depth icon image allows semitransparent areas",
            "                # PIL's DIB format ignores transparency bits, recover them.",
            "                # The DIB is packed in BGRX byte order where X is the alpha",
            "                # channel.",
            "",
            "                # Back up to start of bmp data",
            "                self.buf.seek(o)",
            "                # extract every 4th byte (eg. 3,7,11,15,...)",
            "                alpha_bytes = self.buf.read(im.size[0] * im.size[1] * 4)[3::4]",
            "",
            "                # convert to an 8bpp grayscale image",
            "                mask = Image.frombuffer(",
            "                    \"L\",  # 8bpp",
            "                    im.size,  # (w, h)",
            "                    alpha_bytes,  # source chars",
            "                    \"raw\",  # raw decoder",
            "                    (\"L\", 0, -1),  # 8bpp inverted, unpadded, reversed",
            "                )",
            "            else:",
            "                # get AND image from end of bitmap",
            "                w = im.size[0]",
            "                if (w % 32) > 0:",
            "                    # bitmap row data is aligned to word boundaries",
            "                    w += 32 - (im.size[0] % 32)",
            "",
            "                # the total mask data is",
            "                # padded row size * height / bits per char",
            "",
            "                and_mask_offset = o + int(im.size[0] * im.size[1] * (bpp / 8.0))",
            "                total_bytes = int((w * im.size[1]) / 8)",
            "",
            "                self.buf.seek(and_mask_offset)",
            "                mask_data = self.buf.read(total_bytes)",
            "",
            "                # convert raw data to image",
            "                mask = Image.frombuffer(",
            "                    \"1\",  # 1 bpp",
            "                    im.size,  # (w, h)",
            "                    mask_data,  # source chars",
            "                    \"raw\",  # raw decoder",
            "                    (\"1;I\", int(w / 8), -1),  # 1bpp inverted, padded, reversed",
            "                )",
            "",
            "                # now we have two images, im is XOR image and mask is AND image",
            "",
            "            # apply mask image as alpha channel",
            "            im = im.convert(\"RGBA\")",
            "            im.putalpha(mask)",
            "",
            "        return im",
            "",
            "",
            "##",
            "# Image plugin for Windows Icon files.",
            "",
            "",
            "class IcoImageFile(ImageFile.ImageFile):",
            "    \"\"\"",
            "    PIL read-only image support for Microsoft Windows .ico files.",
            "",
            "    By default the largest resolution image in the file will be loaded. This",
            "    can be changed by altering the 'size' attribute before calling 'load'.",
            "",
            "    The info dictionary has a key 'sizes' that is a list of the sizes available",
            "    in the icon file.",
            "",
            "    Handles classic, XP and Vista icon formats.",
            "",
            "    When saving, PNG compression is used. Support for this was only added in",
            "    Windows Vista.",
            "",
            "    This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis",
            "    <casadebender@gmail.com>.",
            "    https://code.google.com/archive/p/casadebender/wikis/Win32IconImagePlugin.wiki",
            "    \"\"\"",
            "",
            "    format = \"ICO\"",
            "    format_description = \"Windows Icon\"",
            "",
            "    def _open(self):",
            "        self.ico = IcoFile(self.fp)",
            "        self.info[\"sizes\"] = self.ico.sizes()",
            "        self.size = self.ico.entry[0][\"dim\"]",
            "        self.load()",
            "",
            "    @property",
            "    def size(self):",
            "        return self._size",
            "",
            "    @size.setter",
            "    def size(self, value):",
            "        if value not in self.info[\"sizes\"]:",
            "            raise ValueError(\"This is not one of the allowed sizes of this image\")",
            "        self._size = value",
            "",
            "    def load(self):",
            "        if self.im and self.im.size == self.size:",
            "            # Already loaded",
            "            return",
            "        im = self.ico.getimage(self.size)",
            "        # if tile is PNG, it won't really be loaded yet",
            "        im.load()",
            "        self.im = im.im",
            "        self.mode = im.mode",
            "        if im.size != self.size:",
            "            warnings.warn(\"Image was not the expected size\")",
            "",
            "            index = self.ico.getentryindex(self.size)",
            "            sizes = list(self.info[\"sizes\"])",
            "            sizes[index] = im.size",
            "            self.info[\"sizes\"] = set(sizes)",
            "",
            "            self.size = im.size",
            "",
            "    def load_seek(self):",
            "        # Flag the ImageFile.Parser so that it",
            "        # just does all the decode at the end.",
            "        pass",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "Image.register_open(IcoImageFile.format, IcoImageFile, _accept)",
            "Image.register_save(IcoImageFile.format, _save)",
            "Image.register_extension(IcoImageFile.format, \".ico\")",
            "",
            "Image.register_mime(IcoImageFile.format, \"image/x-icon\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    }
}