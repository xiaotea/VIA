{
    "langchain/tools/jira/prompt.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     This tool is a wrapper around atlassian-python-api's Jira API."
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     There are other dedicated tools for fetching all projects, and creating and searching for issues, "
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     use this tool if you need to perform any other actions allowed by the atlassian-python-api Jira API."
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    The input to this tool is line of python code that calls a function from atlassian-python-api's Jira API"
            },
            "4": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    For example, to update the summary field of an issue, you would pass in the following string:"
            },
            "5": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    self.jira.update_issue_field(key, {{\"summary\": \"New summary\"}})"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    The input to this tool is a dictionary specifying a function from atlassian-python-api's Jira API, "
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    as well as a list of arguments and dictionary of keyword arguments to pass into the function."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    For example, to get all the users in a group, while increasing the max number of results to 100, you would"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    pass in the following dictionary: {{\"function\": \"get_all_users_from_group\", \"args\": [\"group\"], \"kwargs\": {{\"limit\":100}} }}"
            },
            "10": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     or to find out how many projects are in the Jira instance, you would pass in the following string:"
            },
            "11": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    self.jira.projects()"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    {{\"function\": \"projects\"}}"
            },
            "13": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     For more information on the Jira API, refer to https://atlassian-python-api.readthedocs.io/jira.html"
            },
            "14": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     \"\"\""
            },
            "15": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# flake8: noqa",
            "JIRA_ISSUE_CREATE_PROMPT = \"\"\"",
            "    This tool is a wrapper around atlassian-python-api's Jira issue_create API, useful when you need to create a Jira issue. ",
            "    The input to this tool is a dictionary specifying the fields of the Jira issue, and will be passed into atlassian-python-api's Jira `issue_create` function.",
            "    For example, to create a low priority task called \"test issue\" with description \"test description\", you would pass in the following dictionary: ",
            "    {{\"summary\": \"test issue\", \"description\": \"test description\", \"issuetype\": {{\"name\": \"Task\"}}, \"priority\": {{\"name\": \"Low\"}}}}",
            "    \"\"\"",
            "",
            "JIRA_GET_ALL_PROJECTS_PROMPT = \"\"\"",
            "    This tool is a wrapper around atlassian-python-api's Jira project API, ",
            "    useful when you need to fetch all the projects the user has access to, find out how many projects there are, or as an intermediary step that involv searching by projects. ",
            "    there is no input to this tool.",
            "    \"\"\"",
            "",
            "JIRA_JQL_PROMPT = \"\"\"",
            "    This tool is a wrapper around atlassian-python-api's Jira jql API, useful when you need to search for Jira issues.",
            "    The input to this tool is a JQL query string, and will be passed into atlassian-python-api's Jira `jql` function,",
            "    For example, to find all the issues in project \"Test\" assigned to the me, you would pass in the following string:",
            "    project = Test AND assignee = currentUser()",
            "    or to find issues with summaries that contain the word \"test\", you would pass in the following string:",
            "    summary ~ 'test'",
            "    \"\"\"",
            "",
            "JIRA_CATCH_ALL_PROMPT = \"\"\"",
            "    This tool is a wrapper around atlassian-python-api's Jira API.",
            "    There are other dedicated tools for fetching all projects, and creating and searching for issues, ",
            "    use this tool if you need to perform any other actions allowed by the atlassian-python-api Jira API.",
            "    The input to this tool is line of python code that calls a function from atlassian-python-api's Jira API",
            "    For example, to update the summary field of an issue, you would pass in the following string:",
            "    self.jira.update_issue_field(key, {{\"summary\": \"New summary\"}})",
            "    or to find out how many projects are in the Jira instance, you would pass in the following string:",
            "    self.jira.projects()",
            "    For more information on the Jira API, refer to https://atlassian-python-api.readthedocs.io/jira.html",
            "    \"\"\"",
            "",
            "JIRA_CONFLUENCE_PAGE_CREATE_PROMPT = \"\"\"This tool is a wrapper around atlassian-python-api's Confluence ",
            "atlassian-python-api API, useful when you need to create a Confluence page. The input to this tool is a dictionary ",
            "specifying the fields of the Confluence page, and will be passed into atlassian-python-api's Confluence `create_page` ",
            "function. For example, to create a page in the DEMO space titled \"This is the title\" with body \"This is the body. You can use ",
            "<strong>HTML tags</strong>!\", you would pass in the following dictionary: {{\"space\": \"DEMO\", \"title\":\"This is the ",
            "title\",\"body\":\"This is the body. You can use <strong>HTML tags</strong>!\"}} \"\"\""
        ],
        "afterPatchFile": [
            "# flake8: noqa",
            "JIRA_ISSUE_CREATE_PROMPT = \"\"\"",
            "    This tool is a wrapper around atlassian-python-api's Jira issue_create API, useful when you need to create a Jira issue. ",
            "    The input to this tool is a dictionary specifying the fields of the Jira issue, and will be passed into atlassian-python-api's Jira `issue_create` function.",
            "    For example, to create a low priority task called \"test issue\" with description \"test description\", you would pass in the following dictionary: ",
            "    {{\"summary\": \"test issue\", \"description\": \"test description\", \"issuetype\": {{\"name\": \"Task\"}}, \"priority\": {{\"name\": \"Low\"}}}}",
            "    \"\"\"",
            "",
            "JIRA_GET_ALL_PROJECTS_PROMPT = \"\"\"",
            "    This tool is a wrapper around atlassian-python-api's Jira project API, ",
            "    useful when you need to fetch all the projects the user has access to, find out how many projects there are, or as an intermediary step that involv searching by projects. ",
            "    there is no input to this tool.",
            "    \"\"\"",
            "",
            "JIRA_JQL_PROMPT = \"\"\"",
            "    This tool is a wrapper around atlassian-python-api's Jira jql API, useful when you need to search for Jira issues.",
            "    The input to this tool is a JQL query string, and will be passed into atlassian-python-api's Jira `jql` function,",
            "    For example, to find all the issues in project \"Test\" assigned to the me, you would pass in the following string:",
            "    project = Test AND assignee = currentUser()",
            "    or to find issues with summaries that contain the word \"test\", you would pass in the following string:",
            "    summary ~ 'test'",
            "    \"\"\"",
            "",
            "JIRA_CATCH_ALL_PROMPT = \"\"\"",
            "    This tool is a wrapper around atlassian-python-api's Jira API.",
            "    There are other dedicated tools for fetching all projects, and creating and searching for issues, ",
            "    use this tool if you need to perform any other actions allowed by the atlassian-python-api Jira API.",
            "    The input to this tool is a dictionary specifying a function from atlassian-python-api's Jira API, ",
            "    as well as a list of arguments and dictionary of keyword arguments to pass into the function.",
            "    For example, to get all the users in a group, while increasing the max number of results to 100, you would",
            "    pass in the following dictionary: {{\"function\": \"get_all_users_from_group\", \"args\": [\"group\"], \"kwargs\": {{\"limit\":100}} }}",
            "    or to find out how many projects are in the Jira instance, you would pass in the following string:",
            "    {{\"function\": \"projects\"}}",
            "    For more information on the Jira API, refer to https://atlassian-python-api.readthedocs.io/jira.html",
            "    \"\"\"",
            "",
            "JIRA_CONFLUENCE_PAGE_CREATE_PROMPT = \"\"\"This tool is a wrapper around atlassian-python-api's Confluence ",
            "atlassian-python-api API, useful when you need to create a Confluence page. The input to this tool is a dictionary ",
            "specifying the fields of the Confluence page, and will be passed into atlassian-python-api's Confluence `create_page` ",
            "function. For example, to create a page in the DEMO space titled \"This is the title\" with body \"This is the body. You can use ",
            "<strong>HTML tags</strong>!\", you would pass in the following dictionary: {{\"space\": \"DEMO\", \"title\":\"This is the ",
            "title\",\"body\":\"This is the body. You can use <strong>HTML tags</strong>!\"}} \"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [],
            "29": [],
            "30": [],
            "32": []
        },
        "addLocation": []
    },
    "langchain/utilities/jira.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         return self.confluence.create_page(**dict(params))"
            },
            "1": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "     def other(self, query: str) -> str:"
            },
            "3": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        context = {\"self\": self}"
            },
            "4": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        exec(f\"result = {query}\", context)"
            },
            "5": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        result = context[\"result\"]"
            },
            "6": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return str(result)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        try:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+            import json"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        except ImportError:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+            raise ImportError("
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+                \"json is not installed. Please install it with `pip install json`\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            )"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+        params = json.loads(query)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+        jira_function = getattr(self.jira, params[\"function\"])"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        return jira_function(*params.get(\"args\", []), **params.get(\"kwargs\", {}))"
            },
            "16": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 200,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "     def run(self, mode: str, query: str) -> str:"
            },
            "18": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         if mode == \"jql\":"
            }
        },
        "frontPatchFile": [
            "\"\"\"Util that calls Jira.\"\"\"",
            "from typing import Any, Dict, List, Optional",
            "",
            "from pydantic import BaseModel, Extra, root_validator",
            "",
            "from langchain.tools.jira.prompt import (",
            "    JIRA_CATCH_ALL_PROMPT,",
            "    JIRA_CONFLUENCE_PAGE_CREATE_PROMPT,",
            "    JIRA_GET_ALL_PROJECTS_PROMPT,",
            "    JIRA_ISSUE_CREATE_PROMPT,",
            "    JIRA_JQL_PROMPT,",
            ")",
            "from langchain.utils import get_from_dict_or_env",
            "",
            "",
            "# TODO: think about error handling, more specific api specs, and jql/project limits",
            "class JiraAPIWrapper(BaseModel):",
            "    \"\"\"Wrapper for Jira API.\"\"\"",
            "",
            "    jira: Any  #: :meta private:",
            "    confluence: Any",
            "    jira_username: Optional[str] = None",
            "    jira_api_token: Optional[str] = None",
            "    jira_instance_url: Optional[str] = None",
            "",
            "    operations: List[Dict] = [",
            "        {",
            "            \"mode\": \"jql\",",
            "            \"name\": \"JQL Query\",",
            "            \"description\": JIRA_JQL_PROMPT,",
            "        },",
            "        {",
            "            \"mode\": \"get_projects\",",
            "            \"name\": \"Get Projects\",",
            "            \"description\": JIRA_GET_ALL_PROJECTS_PROMPT,",
            "        },",
            "        {",
            "            \"mode\": \"create_issue\",",
            "            \"name\": \"Create Issue\",",
            "            \"description\": JIRA_ISSUE_CREATE_PROMPT,",
            "        },",
            "        {",
            "            \"mode\": \"other\",",
            "            \"name\": \"Catch all Jira API call\",",
            "            \"description\": JIRA_CATCH_ALL_PROMPT,",
            "        },",
            "        {",
            "            \"mode\": \"create_page\",",
            "            \"name\": \"Create confluence page\",",
            "            \"description\": JIRA_CONFLUENCE_PAGE_CREATE_PROMPT,",
            "        },",
            "    ]",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "",
            "    def list(self) -> List[Dict]:",
            "        return self.operations",
            "",
            "    @root_validator()",
            "    def validate_environment(cls, values: Dict) -> Dict:",
            "        \"\"\"Validate that api key and python package exists in environment.\"\"\"",
            "        jira_username = get_from_dict_or_env(values, \"jira_username\", \"JIRA_USERNAME\")",
            "        values[\"jira_username\"] = jira_username",
            "",
            "        jira_api_token = get_from_dict_or_env(",
            "            values, \"jira_api_token\", \"JIRA_API_TOKEN\"",
            "        )",
            "        values[\"jira_api_token\"] = jira_api_token",
            "",
            "        jira_instance_url = get_from_dict_or_env(",
            "            values, \"jira_instance_url\", \"JIRA_INSTANCE_URL\"",
            "        )",
            "        values[\"jira_instance_url\"] = jira_instance_url",
            "",
            "        try:",
            "            from atlassian import Confluence, Jira",
            "        except ImportError:",
            "            raise ImportError(",
            "                \"atlassian-python-api is not installed. \"",
            "                \"Please install it with `pip install atlassian-python-api`\"",
            "            )",
            "",
            "        jira = Jira(",
            "            url=jira_instance_url,",
            "            username=jira_username,",
            "            password=jira_api_token,",
            "            cloud=True,",
            "        )",
            "",
            "        confluence = Confluence(",
            "            url=jira_instance_url,",
            "            username=jira_username,",
            "            password=jira_api_token,",
            "            cloud=True,",
            "        )",
            "",
            "        values[\"jira\"] = jira",
            "        values[\"confluence\"] = confluence",
            "",
            "        return values",
            "",
            "    def parse_issues(self, issues: Dict) -> List[dict]:",
            "        parsed = []",
            "        for issue in issues[\"issues\"]:",
            "            key = issue[\"key\"]",
            "            summary = issue[\"fields\"][\"summary\"]",
            "            created = issue[\"fields\"][\"created\"][0:10]",
            "            priority = issue[\"fields\"][\"priority\"][\"name\"]",
            "            status = issue[\"fields\"][\"status\"][\"name\"]",
            "            try:",
            "                assignee = issue[\"fields\"][\"assignee\"][\"displayName\"]",
            "            except Exception:",
            "                assignee = \"None\"",
            "            rel_issues = {}",
            "            for related_issue in issue[\"fields\"][\"issuelinks\"]:",
            "                if \"inwardIssue\" in related_issue.keys():",
            "                    rel_type = related_issue[\"type\"][\"inward\"]",
            "                    rel_key = related_issue[\"inwardIssue\"][\"key\"]",
            "                    rel_summary = related_issue[\"inwardIssue\"][\"fields\"][\"summary\"]",
            "                if \"outwardIssue\" in related_issue.keys():",
            "                    rel_type = related_issue[\"type\"][\"outward\"]",
            "                    rel_key = related_issue[\"outwardIssue\"][\"key\"]",
            "                    rel_summary = related_issue[\"outwardIssue\"][\"fields\"][\"summary\"]",
            "                rel_issues = {\"type\": rel_type, \"key\": rel_key, \"summary\": rel_summary}",
            "            parsed.append(",
            "                {",
            "                    \"key\": key,",
            "                    \"summary\": summary,",
            "                    \"created\": created,",
            "                    \"assignee\": assignee,",
            "                    \"priority\": priority,",
            "                    \"status\": status,",
            "                    \"related_issues\": rel_issues,",
            "                }",
            "            )",
            "        return parsed",
            "",
            "    def parse_projects(self, projects: List[dict]) -> List[dict]:",
            "        parsed = []",
            "        for project in projects:",
            "            id = project[\"id\"]",
            "            key = project[\"key\"]",
            "            name = project[\"name\"]",
            "            type = project[\"projectTypeKey\"]",
            "            style = project[\"style\"]",
            "            parsed.append(",
            "                {\"id\": id, \"key\": key, \"name\": name, \"type\": type, \"style\": style}",
            "            )",
            "        return parsed",
            "",
            "    def search(self, query: str) -> str:",
            "        issues = self.jira.jql(query)",
            "        parsed_issues = self.parse_issues(issues)",
            "        parsed_issues_str = (",
            "            \"Found \" + str(len(parsed_issues)) + \" issues:\\n\" + str(parsed_issues)",
            "        )",
            "        return parsed_issues_str",
            "",
            "    def project(self) -> str:",
            "        projects = self.jira.projects()",
            "        parsed_projects = self.parse_projects(projects)",
            "        parsed_projects_str = (",
            "            \"Found \" + str(len(parsed_projects)) + \" projects:\\n\" + str(parsed_projects)",
            "        )",
            "        return parsed_projects_str",
            "",
            "    def issue_create(self, query: str) -> str:",
            "        try:",
            "            import json",
            "        except ImportError:",
            "            raise ImportError(",
            "                \"json is not installed. Please install it with `pip install json`\"",
            "            )",
            "        params = json.loads(query)",
            "        return self.jira.issue_create(fields=dict(params))",
            "",
            "    def page_create(self, query: str) -> str:",
            "        try:",
            "            import json",
            "        except ImportError:",
            "            raise ImportError(",
            "                \"json is not installed. Please install it with `pip install json`\"",
            "            )",
            "        params = json.loads(query)",
            "        return self.confluence.create_page(**dict(params))",
            "",
            "    def other(self, query: str) -> str:",
            "        context = {\"self\": self}",
            "        exec(f\"result = {query}\", context)",
            "        result = context[\"result\"]",
            "        return str(result)",
            "",
            "    def run(self, mode: str, query: str) -> str:",
            "        if mode == \"jql\":",
            "            return self.search(query)",
            "        elif mode == \"get_projects\":",
            "            return self.project()",
            "        elif mode == \"create_issue\":",
            "            return self.issue_create(query)",
            "        elif mode == \"other\":",
            "            return self.other(query)",
            "        elif mode == \"create_page\":",
            "            return self.page_create(query)",
            "        else:",
            "            raise ValueError(f\"Got unexpected mode {mode}\")"
        ],
        "afterPatchFile": [
            "\"\"\"Util that calls Jira.\"\"\"",
            "from typing import Any, Dict, List, Optional",
            "",
            "from pydantic import BaseModel, Extra, root_validator",
            "",
            "from langchain.tools.jira.prompt import (",
            "    JIRA_CATCH_ALL_PROMPT,",
            "    JIRA_CONFLUENCE_PAGE_CREATE_PROMPT,",
            "    JIRA_GET_ALL_PROJECTS_PROMPT,",
            "    JIRA_ISSUE_CREATE_PROMPT,",
            "    JIRA_JQL_PROMPT,",
            ")",
            "from langchain.utils import get_from_dict_or_env",
            "",
            "",
            "# TODO: think about error handling, more specific api specs, and jql/project limits",
            "class JiraAPIWrapper(BaseModel):",
            "    \"\"\"Wrapper for Jira API.\"\"\"",
            "",
            "    jira: Any  #: :meta private:",
            "    confluence: Any",
            "    jira_username: Optional[str] = None",
            "    jira_api_token: Optional[str] = None",
            "    jira_instance_url: Optional[str] = None",
            "",
            "    operations: List[Dict] = [",
            "        {",
            "            \"mode\": \"jql\",",
            "            \"name\": \"JQL Query\",",
            "            \"description\": JIRA_JQL_PROMPT,",
            "        },",
            "        {",
            "            \"mode\": \"get_projects\",",
            "            \"name\": \"Get Projects\",",
            "            \"description\": JIRA_GET_ALL_PROJECTS_PROMPT,",
            "        },",
            "        {",
            "            \"mode\": \"create_issue\",",
            "            \"name\": \"Create Issue\",",
            "            \"description\": JIRA_ISSUE_CREATE_PROMPT,",
            "        },",
            "        {",
            "            \"mode\": \"other\",",
            "            \"name\": \"Catch all Jira API call\",",
            "            \"description\": JIRA_CATCH_ALL_PROMPT,",
            "        },",
            "        {",
            "            \"mode\": \"create_page\",",
            "            \"name\": \"Create confluence page\",",
            "            \"description\": JIRA_CONFLUENCE_PAGE_CREATE_PROMPT,",
            "        },",
            "    ]",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "",
            "    def list(self) -> List[Dict]:",
            "        return self.operations",
            "",
            "    @root_validator()",
            "    def validate_environment(cls, values: Dict) -> Dict:",
            "        \"\"\"Validate that api key and python package exists in environment.\"\"\"",
            "        jira_username = get_from_dict_or_env(values, \"jira_username\", \"JIRA_USERNAME\")",
            "        values[\"jira_username\"] = jira_username",
            "",
            "        jira_api_token = get_from_dict_or_env(",
            "            values, \"jira_api_token\", \"JIRA_API_TOKEN\"",
            "        )",
            "        values[\"jira_api_token\"] = jira_api_token",
            "",
            "        jira_instance_url = get_from_dict_or_env(",
            "            values, \"jira_instance_url\", \"JIRA_INSTANCE_URL\"",
            "        )",
            "        values[\"jira_instance_url\"] = jira_instance_url",
            "",
            "        try:",
            "            from atlassian import Confluence, Jira",
            "        except ImportError:",
            "            raise ImportError(",
            "                \"atlassian-python-api is not installed. \"",
            "                \"Please install it with `pip install atlassian-python-api`\"",
            "            )",
            "",
            "        jira = Jira(",
            "            url=jira_instance_url,",
            "            username=jira_username,",
            "            password=jira_api_token,",
            "            cloud=True,",
            "        )",
            "",
            "        confluence = Confluence(",
            "            url=jira_instance_url,",
            "            username=jira_username,",
            "            password=jira_api_token,",
            "            cloud=True,",
            "        )",
            "",
            "        values[\"jira\"] = jira",
            "        values[\"confluence\"] = confluence",
            "",
            "        return values",
            "",
            "    def parse_issues(self, issues: Dict) -> List[dict]:",
            "        parsed = []",
            "        for issue in issues[\"issues\"]:",
            "            key = issue[\"key\"]",
            "            summary = issue[\"fields\"][\"summary\"]",
            "            created = issue[\"fields\"][\"created\"][0:10]",
            "            priority = issue[\"fields\"][\"priority\"][\"name\"]",
            "            status = issue[\"fields\"][\"status\"][\"name\"]",
            "            try:",
            "                assignee = issue[\"fields\"][\"assignee\"][\"displayName\"]",
            "            except Exception:",
            "                assignee = \"None\"",
            "            rel_issues = {}",
            "            for related_issue in issue[\"fields\"][\"issuelinks\"]:",
            "                if \"inwardIssue\" in related_issue.keys():",
            "                    rel_type = related_issue[\"type\"][\"inward\"]",
            "                    rel_key = related_issue[\"inwardIssue\"][\"key\"]",
            "                    rel_summary = related_issue[\"inwardIssue\"][\"fields\"][\"summary\"]",
            "                if \"outwardIssue\" in related_issue.keys():",
            "                    rel_type = related_issue[\"type\"][\"outward\"]",
            "                    rel_key = related_issue[\"outwardIssue\"][\"key\"]",
            "                    rel_summary = related_issue[\"outwardIssue\"][\"fields\"][\"summary\"]",
            "                rel_issues = {\"type\": rel_type, \"key\": rel_key, \"summary\": rel_summary}",
            "            parsed.append(",
            "                {",
            "                    \"key\": key,",
            "                    \"summary\": summary,",
            "                    \"created\": created,",
            "                    \"assignee\": assignee,",
            "                    \"priority\": priority,",
            "                    \"status\": status,",
            "                    \"related_issues\": rel_issues,",
            "                }",
            "            )",
            "        return parsed",
            "",
            "    def parse_projects(self, projects: List[dict]) -> List[dict]:",
            "        parsed = []",
            "        for project in projects:",
            "            id = project[\"id\"]",
            "            key = project[\"key\"]",
            "            name = project[\"name\"]",
            "            type = project[\"projectTypeKey\"]",
            "            style = project[\"style\"]",
            "            parsed.append(",
            "                {\"id\": id, \"key\": key, \"name\": name, \"type\": type, \"style\": style}",
            "            )",
            "        return parsed",
            "",
            "    def search(self, query: str) -> str:",
            "        issues = self.jira.jql(query)",
            "        parsed_issues = self.parse_issues(issues)",
            "        parsed_issues_str = (",
            "            \"Found \" + str(len(parsed_issues)) + \" issues:\\n\" + str(parsed_issues)",
            "        )",
            "        return parsed_issues_str",
            "",
            "    def project(self) -> str:",
            "        projects = self.jira.projects()",
            "        parsed_projects = self.parse_projects(projects)",
            "        parsed_projects_str = (",
            "            \"Found \" + str(len(parsed_projects)) + \" projects:\\n\" + str(parsed_projects)",
            "        )",
            "        return parsed_projects_str",
            "",
            "    def issue_create(self, query: str) -> str:",
            "        try:",
            "            import json",
            "        except ImportError:",
            "            raise ImportError(",
            "                \"json is not installed. Please install it with `pip install json`\"",
            "            )",
            "        params = json.loads(query)",
            "        return self.jira.issue_create(fields=dict(params))",
            "",
            "    def page_create(self, query: str) -> str:",
            "        try:",
            "            import json",
            "        except ImportError:",
            "            raise ImportError(",
            "                \"json is not installed. Please install it with `pip install json`\"",
            "            )",
            "        params = json.loads(query)",
            "        return self.confluence.create_page(**dict(params))",
            "",
            "    def other(self, query: str) -> str:",
            "        try:",
            "            import json",
            "        except ImportError:",
            "            raise ImportError(",
            "                \"json is not installed. Please install it with `pip install json`\"",
            "            )",
            "        params = json.loads(query)",
            "        jira_function = getattr(self.jira, params[\"function\"])",
            "        return jira_function(*params.get(\"args\", []), **params.get(\"kwargs\", {}))",
            "",
            "    def run(self, mode: str, query: str) -> str:",
            "        if mode == \"jql\":",
            "            return self.search(query)",
            "        elif mode == \"get_projects\":",
            "            return self.project()",
            "        elif mode == \"create_issue\":",
            "            return self.issue_create(query)",
            "        elif mode == \"other\":",
            "            return self.other(query)",
            "        elif mode == \"create_page\":",
            "            return self.page_create(query)",
            "        else:",
            "            raise ValueError(f\"Got unexpected mode {mode}\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "191": [
                "JiraAPIWrapper",
                "other"
            ],
            "192": [
                "JiraAPIWrapper",
                "other"
            ],
            "193": [
                "JiraAPIWrapper",
                "other"
            ],
            "194": [
                "JiraAPIWrapper",
                "other"
            ]
        },
        "addLocation": []
    }
}