{
    "src/fides/api/schemas/saas/connector_template.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " class ConnectorTemplate(BaseModel):"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     A collection of artifacts that make up a complete"
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    SaaS connector (SaaS config, dataset, icon, functions, etc.)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    SaaS connector (SaaS config, dataset, icon, etc.)"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     \"\"\""
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     config: str"
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     dataset: str"
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     icon: Optional[str]"
            },
            "10": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    functions: Optional[str]"
            },
            "11": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     human_readable: str"
            },
            "12": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     @validator(\"config\")"
            }
        },
        "frontPatchFile": [
            "from typing import Optional",
            "",
            "from fideslang.models import Dataset",
            "from pydantic import BaseModel, validator",
            "",
            "from fides.api.schemas.saas.saas_config import SaaSConfig",
            "from fides.api.service.authentication.authentication_strategy_oauth2_authorization_code import (",
            "    OAuth2AuthorizationCodeAuthenticationStrategy,",
            ")",
            "from fides.api.util.saas_util import load_config_from_string, load_dataset_from_string",
            "",
            "",
            "class ConnectorTemplate(BaseModel):",
            "    \"\"\"",
            "    A collection of artifacts that make up a complete",
            "    SaaS connector (SaaS config, dataset, icon, functions, etc.)",
            "    \"\"\"",
            "",
            "    config: str",
            "    dataset: str",
            "    icon: Optional[str]",
            "    functions: Optional[str]",
            "    human_readable: str",
            "",
            "    @validator(\"config\")",
            "    def validate_config(cls, config: str) -> str:",
            "        \"\"\"Validates the config at the given path\"\"\"",
            "        saas_config = SaaSConfig(**load_config_from_string(config))",
            "        if saas_config.fides_key != \"<instance_fides_key>\":",
            "            raise ValueError(",
            "                \"Hard-coded fides_key detected in the config, replace all instances of it with <instance_fides_key>\"",
            "            )",
            "        return config",
            "",
            "    @validator(\"dataset\")",
            "    def validate_dataset(cls, dataset: str) -> str:",
            "        \"\"\"Validates the dataset at the given path\"\"\"",
            "        saas_dataset = Dataset(**load_dataset_from_string(dataset))",
            "        if saas_dataset.fides_key != \"<instance_fides_key>\":",
            "            raise ValueError(",
            "                \"Hard-coded fides_key detected in the dataset, replace all instances of it with <instance_fides_key>\"",
            "            )",
            "        return dataset",
            "",
            "    @property",
            "    def authorization_required(self) -> bool:",
            "        \"\"\"Determines if the auth strategy for the given connector template requires authorization.\"\"\"",
            "",
            "        config = SaaSConfig(**load_config_from_string(self.config))",
            "        authentication = config.client_config.authentication",
            "        return (",
            "            authentication.strategy",
            "            == OAuth2AuthorizationCodeAuthenticationStrategy.name",
            "            if authentication",
            "            else False",
            "        )",
            "",
            "    @property",
            "    def user_guide(self) -> Optional[str]:",
            "        config = SaaSConfig(**load_config_from_string(self.config))",
            "        return config.user_guide"
        ],
        "afterPatchFile": [
            "from typing import Optional",
            "",
            "from fideslang.models import Dataset",
            "from pydantic import BaseModel, validator",
            "",
            "from fides.api.schemas.saas.saas_config import SaaSConfig",
            "from fides.api.service.authentication.authentication_strategy_oauth2_authorization_code import (",
            "    OAuth2AuthorizationCodeAuthenticationStrategy,",
            ")",
            "from fides.api.util.saas_util import load_config_from_string, load_dataset_from_string",
            "",
            "",
            "class ConnectorTemplate(BaseModel):",
            "    \"\"\"",
            "    A collection of artifacts that make up a complete",
            "    SaaS connector (SaaS config, dataset, icon, etc.)",
            "    \"\"\"",
            "",
            "    config: str",
            "    dataset: str",
            "    icon: Optional[str]",
            "    human_readable: str",
            "",
            "    @validator(\"config\")",
            "    def validate_config(cls, config: str) -> str:",
            "        \"\"\"Validates the config at the given path\"\"\"",
            "        saas_config = SaaSConfig(**load_config_from_string(config))",
            "        if saas_config.fides_key != \"<instance_fides_key>\":",
            "            raise ValueError(",
            "                \"Hard-coded fides_key detected in the config, replace all instances of it with <instance_fides_key>\"",
            "            )",
            "        return config",
            "",
            "    @validator(\"dataset\")",
            "    def validate_dataset(cls, dataset: str) -> str:",
            "        \"\"\"Validates the dataset at the given path\"\"\"",
            "        saas_dataset = Dataset(**load_dataset_from_string(dataset))",
            "        if saas_dataset.fides_key != \"<instance_fides_key>\":",
            "            raise ValueError(",
            "                \"Hard-coded fides_key detected in the dataset, replace all instances of it with <instance_fides_key>\"",
            "            )",
            "        return dataset",
            "",
            "    @property",
            "    def authorization_required(self) -> bool:",
            "        \"\"\"Determines if the auth strategy for the given connector template requires authorization.\"\"\"",
            "",
            "        config = SaaSConfig(**load_config_from_string(self.config))",
            "        authentication = config.client_config.authentication",
            "        return (",
            "            authentication.strategy",
            "            == OAuth2AuthorizationCodeAuthenticationStrategy.name",
            "            if authentication",
            "            else False",
            "        )",
            "",
            "    @property",
            "    def user_guide(self) -> Optional[str]:",
            "        config = SaaSConfig(**load_config_from_string(self.config))",
            "        return config.user_guide"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": [
                "ConnectorTemplate"
            ],
            "22": [
                "ConnectorTemplate"
            ]
        },
        "addLocation": []
    },
    "src/fides/api/service/connectors/saas/connector_registry_service.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " # pylint: disable=protected-access"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from abc import ABC, abstractmethod"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ast import AST, AnnAssign"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from operator import getitem"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Any, Dict, Iterable, List, Optional, Tuple, Type"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from typing import Dict, Iterable, List, Optional, Type"
            },
            "7": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from zipfile import ZipFile"
            },
            "8": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from AccessControl.ZopeGuards import safe_builtins"
            },
            "10": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from fideslang.models import Dataset"
            },
            "11": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from loguru import logger"
            },
            "12": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from packaging.version import Version"
            },
            "13": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from packaging.version import parse as parse_version"
            },
            "14": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from RestrictedPython import compile_restricted"
            },
            "15": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from RestrictedPython.transformer import RestrictingNodeTransformer"
            },
            "16": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from sqlalchemy.orm import Session"
            },
            "17": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from fides.api.api.deps import get_api_session"
            },
            "19": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from fides.api.common_exceptions import FidesopsException, ValidationError"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from fides.api.common_exceptions import ValidationError"
            },
            "21": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from fides.api.cryptography.cryptographic_util import str_to_b64_str"
            },
            "22": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from fides.api.models.connectionconfig import ("
            },
            "23": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     AccessLevel,"
            },
            "24": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     replace_version,"
            },
            "25": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " )"
            },
            "26": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " from fides.api.util.unsafe_file_util import verify_svg, verify_zip"
            },
            "27": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from fides.config import CONFIG"
            },
            "28": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " class ConnectorTemplateLoader(ABC):"
            },
            "31": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "                             f\"data/saas/dataset/{connector_type}_dataset.yml\""
            },
            "32": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "                         ),"
            },
            "33": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "                         icon=icon,"
            },
            "34": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        functions=None,"
            },
            "35": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "                         human_readable=human_readable,"
            },
            "36": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "                     )"
            },
            "37": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "                 except Exception:"
            },
            "38": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         template: CustomConnectorTemplate,"
            },
            "39": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     ) -> None:"
            },
            "40": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         \"\"\""
            },
            "41": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Registers a custom connector template by converting it to a ConnectorTemplate,"
            },
            "42": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        registering any custom functions, and adding it to the loader's template dictionary."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        Registers a custom connector template by converting it to a ConnectorTemplate"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        and adding it to the loader's template dictionary."
            },
            "45": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         \"\"\""
            },
            "46": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         connector_template = ConnectorTemplate("
            },
            "47": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "             config=template.config,"
            },
            "48": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "             dataset=template.dataset,"
            },
            "49": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "             icon=template.icon,"
            },
            "50": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            functions=template.functions,"
            },
            "51": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "             human_readable=template.name,"
            },
            "52": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         )"
            },
            "53": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # register custom functions if available"
            },
            "55": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if template.functions:"
            },
            "56": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            register_custom_functions(template.functions)"
            },
            "57": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logger.info("
            },
            "58": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Loaded functions from the custom connector template '{template.key}'\""
            },
            "59": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "60": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "61": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         # register the template in the loader's template dictionary"
            },
            "62": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         CustomConnectorTemplateLoader.get_connector_templates()["
            },
            "63": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "             template.key"
            },
            "64": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "                     raise ValidationError("
            },
            "65": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "                         \"Multiple svg files found, only one is allowed.\""
            },
            "66": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "                     )"
            },
            "67": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif info.filename.endswith(\".py\"):"
            },
            "68": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if not function_contents:"
            },
            "69": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    function_contents = file_contents"
            },
            "70": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                else:"
            },
            "71": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise ValidationError("
            },
            "72": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        \"Multiple Python (.py) files found, only one is allowed.\""
            },
            "73": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    )"
            },
            "74": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 208,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         if not config_contents:"
            },
            "76": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "             raise ValidationError(\"Zip file does not contain a config.yml file.\")"
            },
            "77": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             config=config_contents,"
            },
            "78": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             dataset=dataset_contents,"
            },
            "79": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "             icon=icon_contents,"
            },
            "80": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            functions=function_contents,"
            },
            "81": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "             replaceable=replaceable,"
            },
            "82": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         )"
            },
            "83": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 249,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 424,
                "PatchRowcode": "     connection_config.update_saas_config(db, SaaSConfig(**config_from_template))"
            },
            "85": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 425,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 426,
                "PatchRowcode": "     upsert_dataset_config_from_template(db, connection_config, template, template_vals)"
            },
            "87": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "88": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "89": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def register_custom_functions(script: str) -> None:"
            },
            "90": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "91": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Registers custom functions by executing the given script in a restricted environment."
            },
            "92": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "93": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    The script is compiled and executed with RestrictedPython, which is designed to reduce"
            },
            "94": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    the risk of executing untrusted code. It provides a set of safe builtins to prevent"
            },
            "95": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    malicious or unintended behavior."
            },
            "96": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "97": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Args:"
            },
            "98": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        script (str): The Python script containing the custom functions to be registered."
            },
            "99": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "100": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Raises:"
            },
            "101": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        FidesopsException: If allow_custom_connector_functions is disabled."
            },
            "102": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        SyntaxError: If the script contains a syntax error or uses restricted language features."
            },
            "103": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Exception: If an exception occurs during the execution of the script."
            },
            "104": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "105": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "106": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if CONFIG.security.allow_custom_connector_functions:"
            },
            "107": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        restricted_code = compile_restricted("
            },
            "108": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            script, \"<string>\", \"exec\", policy=CustomRestrictingNodeTransformer"
            },
            "109": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "110": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        safe_builtins[\"__import__\"] = custom_guarded_import"
            },
            "111": {
                "beforePatchRowNumber": 474,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        safe_builtins[\"_getitem_\"] = getitem"
            },
            "112": {
                "beforePatchRowNumber": 475,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        safe_builtins[\"staticmethod\"] = staticmethod"
            },
            "113": {
                "beforePatchRowNumber": 476,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "114": {
                "beforePatchRowNumber": 477,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # pylint: disable=exec-used"
            },
            "115": {
                "beforePatchRowNumber": 478,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        exec("
            },
            "116": {
                "beforePatchRowNumber": 479,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            restricted_code,"
            },
            "117": {
                "beforePatchRowNumber": 480,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            {"
            },
            "118": {
                "beforePatchRowNumber": 481,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"__metaclass__\": type,"
            },
            "119": {
                "beforePatchRowNumber": 482,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"__name__\": \"restricted_module\","
            },
            "120": {
                "beforePatchRowNumber": 483,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"__builtins__\": safe_builtins,"
            },
            "121": {
                "beforePatchRowNumber": 484,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            },"
            },
            "122": {
                "beforePatchRowNumber": 485,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "123": {
                "beforePatchRowNumber": 486,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "124": {
                "beforePatchRowNumber": 487,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise FidesopsException("
            },
            "125": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            message=\"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\""
            },
            "126": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "127": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "128": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "129": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class CustomRestrictingNodeTransformer(RestrictingNodeTransformer):"
            },
            "130": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "131": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Custom node transformer class that extends RestrictedPython's RestrictingNodeTransformer"
            },
            "132": {
                "beforePatchRowNumber": 495,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    to allow the use of type annotations (AnnAssign) in restricted code."
            },
            "133": {
                "beforePatchRowNumber": 496,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "134": {
                "beforePatchRowNumber": 497,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "135": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def visit_AnnAssign(self, node: AnnAssign) -> AST:"
            },
            "136": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self.node_contents_visit(node)"
            },
            "137": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "138": {
                "beforePatchRowNumber": 501,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "139": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def custom_guarded_import("
            },
            "140": {
                "beforePatchRowNumber": 503,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    name: str,"
            },
            "141": {
                "beforePatchRowNumber": 504,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _globals: Optional[dict] = None,"
            },
            "142": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _locals: Optional[dict] = None,"
            },
            "143": {
                "beforePatchRowNumber": 506,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fromlist: Optional[Tuple[str, ...]] = None,"
            },
            "144": {
                "beforePatchRowNumber": 507,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    level: int = 0,"
            },
            "145": {
                "beforePatchRowNumber": 508,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-) -> Any:"
            },
            "146": {
                "beforePatchRowNumber": 509,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "147": {
                "beforePatchRowNumber": 510,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    A custom import function that prevents the import of certain potentially unsafe modules."
            },
            "148": {
                "beforePatchRowNumber": 511,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "149": {
                "beforePatchRowNumber": 512,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if name in ["
            },
            "150": {
                "beforePatchRowNumber": 513,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"os\","
            },
            "151": {
                "beforePatchRowNumber": 514,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"sys\","
            },
            "152": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"subprocess\","
            },
            "153": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"shutil\","
            },
            "154": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"socket\","
            },
            "155": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"importlib\","
            },
            "156": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"tempfile\","
            },
            "157": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"glob\","
            },
            "158": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ]:"
            },
            "159": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # raising SyntaxError to be consistent with exceptions thrown from other guarded functions"
            },
            "160": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise SyntaxError(f\"Import of '{name}' module is not allowed.\")"
            },
            "161": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if fromlist is None:"
            },
            "162": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        fromlist = ()"
            },
            "163": {
                "beforePatchRowNumber": 526,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return __import__(name, _globals, _locals, fromlist, level)"
            }
        },
        "frontPatchFile": [
            "# pylint: disable=protected-access",
            "import os",
            "from abc import ABC, abstractmethod",
            "from ast import AST, AnnAssign",
            "from operator import getitem",
            "from typing import Any, Dict, Iterable, List, Optional, Tuple, Type",
            "from zipfile import ZipFile",
            "",
            "from AccessControl.ZopeGuards import safe_builtins",
            "from fideslang.models import Dataset",
            "from loguru import logger",
            "from packaging.version import Version",
            "from packaging.version import parse as parse_version",
            "from RestrictedPython import compile_restricted",
            "from RestrictedPython.transformer import RestrictingNodeTransformer",
            "from sqlalchemy.orm import Session",
            "",
            "from fides.api.api.deps import get_api_session",
            "from fides.api.common_exceptions import FidesopsException, ValidationError",
            "from fides.api.cryptography.cryptographic_util import str_to_b64_str",
            "from fides.api.models.connectionconfig import (",
            "    AccessLevel,",
            "    ConnectionConfig,",
            "    ConnectionType,",
            ")",
            "from fides.api.models.custom_connector_template import CustomConnectorTemplate",
            "from fides.api.models.datasetconfig import DatasetConfig",
            "from fides.api.schemas.connection_configuration.saas_config_template_values import (",
            "    SaasConnectionTemplateValues,",
            ")",
            "from fides.api.schemas.saas.connector_template import ConnectorTemplate",
            "from fides.api.schemas.saas.saas_config import SaaSConfig",
            "from fides.api.util.saas_util import (",
            "    encode_file_contents,",
            "    load_config,",
            "    load_config_from_string,",
            "    load_dataset_from_string,",
            "    load_yaml_as_string,",
            "    replace_config_placeholders,",
            "    replace_dataset_placeholders,",
            "    replace_version,",
            ")",
            "from fides.api.util.unsafe_file_util import verify_svg, verify_zip",
            "from fides.config import CONFIG",
            "",
            "",
            "class ConnectorTemplateLoader(ABC):",
            "    _instance: Optional[\"ConnectorTemplateLoader\"] = None",
            "",
            "    def __new__(cls: Type[\"ConnectorTemplateLoader\"]) -> \"ConnectorTemplateLoader\":",
            "        if cls._instance is None:",
            "            cls._instance = super().__new__(cls)",
            "            cls._instance._templates = {}  # type: ignore[attr-defined]",
            "            cls._instance._load_connector_templates()",
            "        return cls._instance",
            "",
            "    @classmethod",
            "    def get_connector_templates(cls) -> Dict[str, ConnectorTemplate]:",
            "        \"\"\"Returns a map of connection templates.\"\"\"",
            "        return cls()._instance._templates  # type: ignore[attr-defined, union-attr]",
            "",
            "    @abstractmethod",
            "    def _load_connector_templates(self) -> None:",
            "        \"\"\"Load connector templates into the _templates dictionary\"\"\"",
            "",
            "",
            "class FileConnectorTemplateLoader(ConnectorTemplateLoader):",
            "    \"\"\"",
            "    Loads SaaS connector templates from the data/saas directory.",
            "    \"\"\"",
            "",
            "    def _load_connector_templates(self) -> None:",
            "        logger.info(\"Loading connectors templates from the data/saas directory\")",
            "        for file in os.listdir(\"data/saas/config\"):",
            "            if file.endswith(\".yml\"):",
            "                config_file = os.path.join(\"data/saas/config\", file)",
            "                config_dict = load_config(config_file)",
            "                connector_type = config_dict[\"type\"]",
            "                human_readable = config_dict[\"name\"]",
            "",
            "                try:",
            "                    icon = encode_file_contents(f\"data/saas/icon/{connector_type}.svg\")",
            "                except FileNotFoundError:",
            "                    logger.debug(",
            "                        f\"Could not find the expected {connector_type}.svg in the data/saas/icon/ directory, using default icon\"",
            "                    )",
            "                    icon = encode_file_contents(\"data/saas/icon/default.svg\")",
            "",
            "                # store connector template for retrieval",
            "                try:",
            "                    FileConnectorTemplateLoader.get_connector_templates()[",
            "                        connector_type",
            "                    ] = ConnectorTemplate(",
            "                        config=load_yaml_as_string(config_file),",
            "                        dataset=load_yaml_as_string(",
            "                            f\"data/saas/dataset/{connector_type}_dataset.yml\"",
            "                        ),",
            "                        icon=icon,",
            "                        functions=None,",
            "                        human_readable=human_readable,",
            "                    )",
            "                except Exception:",
            "                    logger.exception(\"Unable to load {} connector\", connector_type)",
            "",
            "",
            "class CustomConnectorTemplateLoader(ConnectorTemplateLoader):",
            "    \"\"\"",
            "    Loads custom connector templates defined in the custom_connector_template database table.",
            "    \"\"\"",
            "",
            "    def _load_connector_templates(self) -> None:",
            "        logger.info(\"Loading connectors templates from the database.\")",
            "        db = get_api_session()",
            "        for template in CustomConnectorTemplate.all(db=db):",
            "            if (",
            "                template.replaceable",
            "                and CustomConnectorTemplateLoader._replacement_available(template)",
            "            ):",
            "                logger.info(",
            "                    f\"Replacing {template.key} connector template with newer version.\"",
            "                )",
            "                template.delete(db=db)",
            "                continue",
            "            try:",
            "                CustomConnectorTemplateLoader._register_template(template)",
            "            except Exception:",
            "                logger.exception(\"Unable to load {} connector\", template.key)",
            "",
            "    @staticmethod",
            "    def _replacement_available(template: CustomConnectorTemplate) -> bool:",
            "        \"\"\"",
            "        Check the connector templates in the FileConnectorTemplateLoader and return if a newer version is available.",
            "        \"\"\"",
            "        replacement_connector = (",
            "            FileConnectorTemplateLoader.get_connector_templates().get(template.key)",
            "        )",
            "        if not replacement_connector:",
            "            return False",
            "",
            "        custom_saas_config = SaaSConfig(**load_config_from_string(template.config))",
            "        replacement_saas_config = SaaSConfig(",
            "            **load_config_from_string(replacement_connector.config)",
            "        )",
            "        return parse_version(replacement_saas_config.version) > parse_version(",
            "            custom_saas_config.version",
            "        )",
            "",
            "    @classmethod",
            "    def _register_template(",
            "        cls,",
            "        template: CustomConnectorTemplate,",
            "    ) -> None:",
            "        \"\"\"",
            "        Registers a custom connector template by converting it to a ConnectorTemplate,",
            "        registering any custom functions, and adding it to the loader's template dictionary.",
            "        \"\"\"",
            "        connector_template = ConnectorTemplate(",
            "            config=template.config,",
            "            dataset=template.dataset,",
            "            icon=template.icon,",
            "            functions=template.functions,",
            "            human_readable=template.name,",
            "        )",
            "",
            "        # register custom functions if available",
            "        if template.functions:",
            "            register_custom_functions(template.functions)",
            "            logger.info(",
            "                f\"Loaded functions from the custom connector template '{template.key}'\"",
            "            )",
            "",
            "        # register the template in the loader's template dictionary",
            "        CustomConnectorTemplateLoader.get_connector_templates()[",
            "            template.key",
            "        ] = connector_template",
            "",
            "    # pylint: disable=too-many-branches",
            "    @classmethod",
            "    def save_template(cls, db: Session, zip_file: ZipFile) -> None:",
            "        \"\"\"",
            "        Extracts and validates the contents of a zip file containing a",
            "        custom connector template, registers the template, and saves it to the database.",
            "        \"\"\"",
            "",
            "        # verify the zip file before we use it",
            "        verify_zip(zip_file)",
            "",
            "        config_contents = None",
            "        dataset_contents = None",
            "        icon_contents = None",
            "        function_contents = None",
            "",
            "        for info in zip_file.infolist():",
            "            try:",
            "                file_contents = zip_file.read(info).decode()",
            "            except UnicodeDecodeError:",
            "                # skip any hidden metadata files that can't be decoded with UTF-8",
            "                logger.debug(f\"Unable to decode the file: {info.filename}\")",
            "                continue",
            "",
            "            if info.filename.endswith(\"config.yml\"):",
            "                if not config_contents:",
            "                    config_contents = file_contents",
            "                else:",
            "                    raise ValidationError(",
            "                        \"Multiple files ending with config.yml found, only one is allowed.\"",
            "                    )",
            "            elif info.filename.endswith(\"dataset.yml\"):",
            "                if not dataset_contents:",
            "                    dataset_contents = file_contents",
            "                else:",
            "                    raise ValidationError(",
            "                        \"Multiple files ending with dataset.yml found, only one is allowed.\"",
            "                    )",
            "            elif info.filename.endswith(\".svg\"):",
            "                if not icon_contents:",
            "                    verify_svg(file_contents)",
            "                    icon_contents = str_to_b64_str(file_contents)",
            "                else:",
            "                    raise ValidationError(",
            "                        \"Multiple svg files found, only one is allowed.\"",
            "                    )",
            "            elif info.filename.endswith(\".py\"):",
            "                if not function_contents:",
            "                    function_contents = file_contents",
            "                else:",
            "                    raise ValidationError(",
            "                        \"Multiple Python (.py) files found, only one is allowed.\"",
            "                    )",
            "",
            "        if not config_contents:",
            "            raise ValidationError(\"Zip file does not contain a config.yml file.\")",
            "",
            "        if not dataset_contents:",
            "            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")",
            "",
            "        # early validation of SaaS config and dataset",
            "        saas_config = SaaSConfig(**load_config_from_string(config_contents))",
            "        Dataset(**load_dataset_from_string(dataset_contents))",
            "",
            "        # extract connector_type, human_readable, and replaceable values from the SaaS config",
            "        connector_type = saas_config.type",
            "        human_readable = saas_config.name",
            "        replaceable = saas_config.replaceable",
            "",
            "        # if the incoming connector is flagged as replaceable we will update the version to match",
            "        # that of the existing connector template this way the custom connector template can be",
            "        # removed once a newer version is bundled with Fides",
            "        if replaceable:",
            "            existing_connector = (",
            "                FileConnectorTemplateLoader.get_connector_templates().get(",
            "                    connector_type",
            "                )",
            "            )",
            "            if existing_connector:",
            "                existing_config = SaaSConfig(",
            "                    **load_config_from_string(existing_connector.config)",
            "                )",
            "                config_contents = replace_version(",
            "                    config_contents, existing_config.version",
            "                )",
            "",
            "        template = CustomConnectorTemplate(",
            "            key=connector_type,",
            "            name=human_readable,",
            "            config=config_contents,",
            "            dataset=dataset_contents,",
            "            icon=icon_contents,",
            "            functions=function_contents,",
            "            replaceable=replaceable,",
            "        )",
            "",
            "        # attempt to register the template, raises an exception if validation fails",
            "        CustomConnectorTemplateLoader._register_template(template)",
            "",
            "        # save the custom connector to the database if it passed validation",
            "        CustomConnectorTemplate.create_or_update(",
            "            db=db,",
            "            data={",
            "                \"key\": connector_type,",
            "                \"name\": human_readable,",
            "                \"config\": config_contents,",
            "                \"dataset\": dataset_contents,",
            "                \"icon\": icon_contents,",
            "                \"functions\": function_contents,",
            "                \"replaceable\": replaceable,",
            "            },",
            "        )",
            "",
            "",
            "class ConnectorRegistry:",
            "    @classmethod",
            "    def _get_combined_templates(cls) -> Dict[str, ConnectorTemplate]:",
            "        \"\"\"",
            "        Returns a combined map of connector templates from all registered loaders.",
            "        The resulting map is an aggregation of templates from the file loader and the custom loader,",
            "        with custom loader templates taking precedence in case of conflicts.",
            "        \"\"\"",
            "        return {",
            "            **FileConnectorTemplateLoader.get_connector_templates(),  # type: ignore",
            "            **CustomConnectorTemplateLoader.get_connector_templates(),  # type: ignore",
            "        }",
            "",
            "    @classmethod",
            "    def connector_types(cls) -> List[str]:",
            "        \"\"\"List of registered SaaS connector types\"\"\"",
            "        return list(cls._get_combined_templates().keys())",
            "",
            "    @classmethod",
            "    def get_connector_template(cls, connector_type: str) -> Optional[ConnectorTemplate]:",
            "        \"\"\"",
            "        Returns an object containing the various SaaS connector artifacts",
            "        \"\"\"",
            "        return cls._get_combined_templates().get(connector_type)",
            "",
            "",
            "def create_connection_config_from_template_no_save(",
            "    db: Session,",
            "    template: ConnectorTemplate,",
            "    template_values: SaasConnectionTemplateValues,",
            "    system_id: Optional[str] = None,",
            ") -> ConnectionConfig:",
            "    \"\"\"Creates a SaaS connection config from a template without saving it.\"\"\"",
            "    # Load SaaS config from template and replace every instance of \"<instance_fides_key>\" with the fides_key",
            "    # the user has chosen",
            "    config_from_template: Dict = replace_config_placeholders(",
            "        template.config, \"<instance_fides_key>\", template_values.instance_key",
            "    )",
            "",
            "    data = {",
            "        \"key\": template_values.key",
            "        if template_values.key",
            "        else template_values.instance_key,",
            "        \"description\": template_values.description,",
            "        \"connection_type\": ConnectionType.saas,",
            "        \"access\": AccessLevel.write,",
            "        \"saas_config\": config_from_template,",
            "    }",
            "    if template_values.name:",
            "        data[\"name\"] = template_values.name",
            "",
            "    if system_id:",
            "        data[\"system_id\"] = system_id",
            "",
            "    # Create SaaS ConnectionConfig",
            "    connection_config = ConnectionConfig.create_without_saving(db, data=data)",
            "",
            "    return connection_config",
            "",
            "",
            "def upsert_dataset_config_from_template(",
            "    db: Session,",
            "    connection_config: ConnectionConfig,",
            "    template: ConnectorTemplate,",
            "    template_values: SaasConnectionTemplateValues,",
            ") -> DatasetConfig:",
            "    \"\"\"",
            "    Creates a `DatasetConfig` from a template",
            "    and associates it with a ConnectionConfig.",
            "    If the `DatasetConfig` already exists in the db,",
            "    then the existing record is updated.",
            "    \"\"\"",
            "    # Load the dataset config from template and replace every instance of \"<instance_fides_key>\" with the fides_key",
            "    # the user has chosen",
            "    dataset_from_template: Dict = replace_dataset_placeholders(",
            "        template.dataset, \"<instance_fides_key>\", template_values.instance_key",
            "    )",
            "    data = {",
            "        \"connection_config_id\": connection_config.id,",
            "        \"fides_key\": template_values.instance_key,",
            "        \"dataset\": dataset_from_template,  # Currently used for upserting a CTL Dataset",
            "    }",
            "    dataset_config = DatasetConfig.upsert_with_ctl_dataset(db, data=data)",
            "    return dataset_config",
            "",
            "",
            "def update_saas_configs(db: Session) -> None:",
            "    \"\"\"",
            "    Updates SaaS config instances currently in the DB if to the",
            "    corresponding template in the registry are found.",
            "",
            "    Effectively an \"update script\" for SaaS config instances,",
            "    to be run on server bootstrap.",
            "    \"\"\"",
            "    for connector_type in ConnectorRegistry.connector_types():",
            "        logger.debug(",
            "            \"Determining if any updates are needed for connectors of type {} based on templates...\",",
            "            connector_type,",
            "        )",
            "        template: ConnectorTemplate = ConnectorRegistry.get_connector_template(  # type: ignore",
            "            connector_type",
            "        )",
            "        saas_config = SaaSConfig(**load_config_from_string(template.config))",
            "        template_version: Version = parse_version(saas_config.version)",
            "",
            "        connection_configs: Iterable[ConnectionConfig] = ConnectionConfig.filter(",
            "            db=db,",
            "            conditions=(ConnectionConfig.saas_config[\"type\"].astext == connector_type),",
            "        ).all()",
            "        for connection_config in connection_configs:",
            "            saas_config_instance = SaaSConfig.parse_obj(connection_config.saas_config)",
            "            if parse_version(saas_config_instance.version) < template_version:",
            "                logger.info(",
            "                    \"Updating SaaS config instance '{}' of type '{}' as its version, {}, was found to be lower than the template version {}\",",
            "                    saas_config_instance.fides_key,",
            "                    connector_type,",
            "                    saas_config_instance.version,",
            "                    template_version,",
            "                )",
            "                try:",
            "                    update_saas_instance(",
            "                        db,",
            "                        connection_config,",
            "                        template,",
            "                        saas_config_instance,",
            "                    )",
            "                except Exception:",
            "                    logger.exception(",
            "                        \"Encountered error attempting to update SaaS config instance {}\",",
            "                        saas_config_instance.fides_key,",
            "                    )",
            "",
            "",
            "def update_saas_instance(",
            "    db: Session,",
            "    connection_config: ConnectionConfig,",
            "    template: ConnectorTemplate,",
            "    saas_config_instance: SaaSConfig,",
            ") -> None:",
            "    \"\"\"",
            "    Replace in the DB the existing SaaS instance configuration data",
            "    (SaaSConfig, DatasetConfig) associated with the given ConnectionConfig",
            "    with new instance configuration data based on the given ConnectorTemplate",
            "    \"\"\"",
            "    template_vals = SaasConnectionTemplateValues(",
            "        name=connection_config.name,",
            "        key=connection_config.key,",
            "        description=connection_config.description,",
            "        secrets=connection_config.secrets,",
            "        instance_key=saas_config_instance.fides_key,",
            "    )",
            "",
            "    config_from_template: Dict = replace_config_placeholders(",
            "        template.config, \"<instance_fides_key>\", template_vals.instance_key",
            "    )",
            "",
            "    connection_config.update_saas_config(db, SaaSConfig(**config_from_template))",
            "",
            "    upsert_dataset_config_from_template(db, connection_config, template, template_vals)",
            "",
            "",
            "def register_custom_functions(script: str) -> None:",
            "    \"\"\"",
            "    Registers custom functions by executing the given script in a restricted environment.",
            "",
            "    The script is compiled and executed with RestrictedPython, which is designed to reduce",
            "    the risk of executing untrusted code. It provides a set of safe builtins to prevent",
            "    malicious or unintended behavior.",
            "",
            "    Args:",
            "        script (str): The Python script containing the custom functions to be registered.",
            "",
            "    Raises:",
            "        FidesopsException: If allow_custom_connector_functions is disabled.",
            "        SyntaxError: If the script contains a syntax error or uses restricted language features.",
            "        Exception: If an exception occurs during the execution of the script.",
            "    \"\"\"",
            "",
            "    if CONFIG.security.allow_custom_connector_functions:",
            "        restricted_code = compile_restricted(",
            "            script, \"<string>\", \"exec\", policy=CustomRestrictingNodeTransformer",
            "        )",
            "        safe_builtins[\"__import__\"] = custom_guarded_import",
            "        safe_builtins[\"_getitem_\"] = getitem",
            "        safe_builtins[\"staticmethod\"] = staticmethod",
            "",
            "        # pylint: disable=exec-used",
            "        exec(",
            "            restricted_code,",
            "            {",
            "                \"__metaclass__\": type,",
            "                \"__name__\": \"restricted_module\",",
            "                \"__builtins__\": safe_builtins,",
            "            },",
            "        )",
            "    else:",
            "        raise FidesopsException(",
            "            message=\"The import of connector templates with custom functions is disabled by the 'security.allow_custom_connector_functions' setting.\"",
            "        )",
            "",
            "",
            "class CustomRestrictingNodeTransformer(RestrictingNodeTransformer):",
            "    \"\"\"",
            "    Custom node transformer class that extends RestrictedPython's RestrictingNodeTransformer",
            "    to allow the use of type annotations (AnnAssign) in restricted code.",
            "    \"\"\"",
            "",
            "    def visit_AnnAssign(self, node: AnnAssign) -> AST:",
            "        return self.node_contents_visit(node)",
            "",
            "",
            "def custom_guarded_import(",
            "    name: str,",
            "    _globals: Optional[dict] = None,",
            "    _locals: Optional[dict] = None,",
            "    fromlist: Optional[Tuple[str, ...]] = None,",
            "    level: int = 0,",
            ") -> Any:",
            "    \"\"\"",
            "    A custom import function that prevents the import of certain potentially unsafe modules.",
            "    \"\"\"",
            "    if name in [",
            "        \"os\",",
            "        \"sys\",",
            "        \"subprocess\",",
            "        \"shutil\",",
            "        \"socket\",",
            "        \"importlib\",",
            "        \"tempfile\",",
            "        \"glob\",",
            "    ]:",
            "        # raising SyntaxError to be consistent with exceptions thrown from other guarded functions",
            "        raise SyntaxError(f\"Import of '{name}' module is not allowed.\")",
            "    if fromlist is None:",
            "        fromlist = ()",
            "    return __import__(name, _globals, _locals, fromlist, level)"
        ],
        "afterPatchFile": [
            "# pylint: disable=protected-access",
            "import os",
            "from abc import ABC, abstractmethod",
            "from typing import Dict, Iterable, List, Optional, Type",
            "from zipfile import ZipFile",
            "",
            "from fideslang.models import Dataset",
            "from loguru import logger",
            "from packaging.version import Version",
            "from packaging.version import parse as parse_version",
            "from sqlalchemy.orm import Session",
            "",
            "from fides.api.api.deps import get_api_session",
            "from fides.api.common_exceptions import ValidationError",
            "from fides.api.cryptography.cryptographic_util import str_to_b64_str",
            "from fides.api.models.connectionconfig import (",
            "    AccessLevel,",
            "    ConnectionConfig,",
            "    ConnectionType,",
            ")",
            "from fides.api.models.custom_connector_template import CustomConnectorTemplate",
            "from fides.api.models.datasetconfig import DatasetConfig",
            "from fides.api.schemas.connection_configuration.saas_config_template_values import (",
            "    SaasConnectionTemplateValues,",
            ")",
            "from fides.api.schemas.saas.connector_template import ConnectorTemplate",
            "from fides.api.schemas.saas.saas_config import SaaSConfig",
            "from fides.api.util.saas_util import (",
            "    encode_file_contents,",
            "    load_config,",
            "    load_config_from_string,",
            "    load_dataset_from_string,",
            "    load_yaml_as_string,",
            "    replace_config_placeholders,",
            "    replace_dataset_placeholders,",
            "    replace_version,",
            ")",
            "from fides.api.util.unsafe_file_util import verify_svg, verify_zip",
            "",
            "",
            "class ConnectorTemplateLoader(ABC):",
            "    _instance: Optional[\"ConnectorTemplateLoader\"] = None",
            "",
            "    def __new__(cls: Type[\"ConnectorTemplateLoader\"]) -> \"ConnectorTemplateLoader\":",
            "        if cls._instance is None:",
            "            cls._instance = super().__new__(cls)",
            "            cls._instance._templates = {}  # type: ignore[attr-defined]",
            "            cls._instance._load_connector_templates()",
            "        return cls._instance",
            "",
            "    @classmethod",
            "    def get_connector_templates(cls) -> Dict[str, ConnectorTemplate]:",
            "        \"\"\"Returns a map of connection templates.\"\"\"",
            "        return cls()._instance._templates  # type: ignore[attr-defined, union-attr]",
            "",
            "    @abstractmethod",
            "    def _load_connector_templates(self) -> None:",
            "        \"\"\"Load connector templates into the _templates dictionary\"\"\"",
            "",
            "",
            "class FileConnectorTemplateLoader(ConnectorTemplateLoader):",
            "    \"\"\"",
            "    Loads SaaS connector templates from the data/saas directory.",
            "    \"\"\"",
            "",
            "    def _load_connector_templates(self) -> None:",
            "        logger.info(\"Loading connectors templates from the data/saas directory\")",
            "        for file in os.listdir(\"data/saas/config\"):",
            "            if file.endswith(\".yml\"):",
            "                config_file = os.path.join(\"data/saas/config\", file)",
            "                config_dict = load_config(config_file)",
            "                connector_type = config_dict[\"type\"]",
            "                human_readable = config_dict[\"name\"]",
            "",
            "                try:",
            "                    icon = encode_file_contents(f\"data/saas/icon/{connector_type}.svg\")",
            "                except FileNotFoundError:",
            "                    logger.debug(",
            "                        f\"Could not find the expected {connector_type}.svg in the data/saas/icon/ directory, using default icon\"",
            "                    )",
            "                    icon = encode_file_contents(\"data/saas/icon/default.svg\")",
            "",
            "                # store connector template for retrieval",
            "                try:",
            "                    FileConnectorTemplateLoader.get_connector_templates()[",
            "                        connector_type",
            "                    ] = ConnectorTemplate(",
            "                        config=load_yaml_as_string(config_file),",
            "                        dataset=load_yaml_as_string(",
            "                            f\"data/saas/dataset/{connector_type}_dataset.yml\"",
            "                        ),",
            "                        icon=icon,",
            "                        human_readable=human_readable,",
            "                    )",
            "                except Exception:",
            "                    logger.exception(\"Unable to load {} connector\", connector_type)",
            "",
            "",
            "class CustomConnectorTemplateLoader(ConnectorTemplateLoader):",
            "    \"\"\"",
            "    Loads custom connector templates defined in the custom_connector_template database table.",
            "    \"\"\"",
            "",
            "    def _load_connector_templates(self) -> None:",
            "        logger.info(\"Loading connectors templates from the database.\")",
            "        db = get_api_session()",
            "        for template in CustomConnectorTemplate.all(db=db):",
            "            if (",
            "                template.replaceable",
            "                and CustomConnectorTemplateLoader._replacement_available(template)",
            "            ):",
            "                logger.info(",
            "                    f\"Replacing {template.key} connector template with newer version.\"",
            "                )",
            "                template.delete(db=db)",
            "                continue",
            "            try:",
            "                CustomConnectorTemplateLoader._register_template(template)",
            "            except Exception:",
            "                logger.exception(\"Unable to load {} connector\", template.key)",
            "",
            "    @staticmethod",
            "    def _replacement_available(template: CustomConnectorTemplate) -> bool:",
            "        \"\"\"",
            "        Check the connector templates in the FileConnectorTemplateLoader and return if a newer version is available.",
            "        \"\"\"",
            "        replacement_connector = (",
            "            FileConnectorTemplateLoader.get_connector_templates().get(template.key)",
            "        )",
            "        if not replacement_connector:",
            "            return False",
            "",
            "        custom_saas_config = SaaSConfig(**load_config_from_string(template.config))",
            "        replacement_saas_config = SaaSConfig(",
            "            **load_config_from_string(replacement_connector.config)",
            "        )",
            "        return parse_version(replacement_saas_config.version) > parse_version(",
            "            custom_saas_config.version",
            "        )",
            "",
            "    @classmethod",
            "    def _register_template(",
            "        cls,",
            "        template: CustomConnectorTemplate,",
            "    ) -> None:",
            "        \"\"\"",
            "        Registers a custom connector template by converting it to a ConnectorTemplate",
            "        and adding it to the loader's template dictionary.",
            "        \"\"\"",
            "        connector_template = ConnectorTemplate(",
            "            config=template.config,",
            "            dataset=template.dataset,",
            "            icon=template.icon,",
            "            human_readable=template.name,",
            "        )",
            "",
            "        # register the template in the loader's template dictionary",
            "        CustomConnectorTemplateLoader.get_connector_templates()[",
            "            template.key",
            "        ] = connector_template",
            "",
            "    # pylint: disable=too-many-branches",
            "    @classmethod",
            "    def save_template(cls, db: Session, zip_file: ZipFile) -> None:",
            "        \"\"\"",
            "        Extracts and validates the contents of a zip file containing a",
            "        custom connector template, registers the template, and saves it to the database.",
            "        \"\"\"",
            "",
            "        # verify the zip file before we use it",
            "        verify_zip(zip_file)",
            "",
            "        config_contents = None",
            "        dataset_contents = None",
            "        icon_contents = None",
            "        function_contents = None",
            "",
            "        for info in zip_file.infolist():",
            "            try:",
            "                file_contents = zip_file.read(info).decode()",
            "            except UnicodeDecodeError:",
            "                # skip any hidden metadata files that can't be decoded with UTF-8",
            "                logger.debug(f\"Unable to decode the file: {info.filename}\")",
            "                continue",
            "",
            "            if info.filename.endswith(\"config.yml\"):",
            "                if not config_contents:",
            "                    config_contents = file_contents",
            "                else:",
            "                    raise ValidationError(",
            "                        \"Multiple files ending with config.yml found, only one is allowed.\"",
            "                    )",
            "            elif info.filename.endswith(\"dataset.yml\"):",
            "                if not dataset_contents:",
            "                    dataset_contents = file_contents",
            "                else:",
            "                    raise ValidationError(",
            "                        \"Multiple files ending with dataset.yml found, only one is allowed.\"",
            "                    )",
            "            elif info.filename.endswith(\".svg\"):",
            "                if not icon_contents:",
            "                    verify_svg(file_contents)",
            "                    icon_contents = str_to_b64_str(file_contents)",
            "                else:",
            "                    raise ValidationError(",
            "                        \"Multiple svg files found, only one is allowed.\"",
            "                    )",
            "",
            "        if not config_contents:",
            "            raise ValidationError(\"Zip file does not contain a config.yml file.\")",
            "",
            "        if not dataset_contents:",
            "            raise ValidationError(\"Zip file does not contain a dataset.yml file.\")",
            "",
            "        # early validation of SaaS config and dataset",
            "        saas_config = SaaSConfig(**load_config_from_string(config_contents))",
            "        Dataset(**load_dataset_from_string(dataset_contents))",
            "",
            "        # extract connector_type, human_readable, and replaceable values from the SaaS config",
            "        connector_type = saas_config.type",
            "        human_readable = saas_config.name",
            "        replaceable = saas_config.replaceable",
            "",
            "        # if the incoming connector is flagged as replaceable we will update the version to match",
            "        # that of the existing connector template this way the custom connector template can be",
            "        # removed once a newer version is bundled with Fides",
            "        if replaceable:",
            "            existing_connector = (",
            "                FileConnectorTemplateLoader.get_connector_templates().get(",
            "                    connector_type",
            "                )",
            "            )",
            "            if existing_connector:",
            "                existing_config = SaaSConfig(",
            "                    **load_config_from_string(existing_connector.config)",
            "                )",
            "                config_contents = replace_version(",
            "                    config_contents, existing_config.version",
            "                )",
            "",
            "        template = CustomConnectorTemplate(",
            "            key=connector_type,",
            "            name=human_readable,",
            "            config=config_contents,",
            "            dataset=dataset_contents,",
            "            icon=icon_contents,",
            "            replaceable=replaceable,",
            "        )",
            "",
            "        # attempt to register the template, raises an exception if validation fails",
            "        CustomConnectorTemplateLoader._register_template(template)",
            "",
            "        # save the custom connector to the database if it passed validation",
            "        CustomConnectorTemplate.create_or_update(",
            "            db=db,",
            "            data={",
            "                \"key\": connector_type,",
            "                \"name\": human_readable,",
            "                \"config\": config_contents,",
            "                \"dataset\": dataset_contents,",
            "                \"icon\": icon_contents,",
            "                \"functions\": function_contents,",
            "                \"replaceable\": replaceable,",
            "            },",
            "        )",
            "",
            "",
            "class ConnectorRegistry:",
            "    @classmethod",
            "    def _get_combined_templates(cls) -> Dict[str, ConnectorTemplate]:",
            "        \"\"\"",
            "        Returns a combined map of connector templates from all registered loaders.",
            "        The resulting map is an aggregation of templates from the file loader and the custom loader,",
            "        with custom loader templates taking precedence in case of conflicts.",
            "        \"\"\"",
            "        return {",
            "            **FileConnectorTemplateLoader.get_connector_templates(),  # type: ignore",
            "            **CustomConnectorTemplateLoader.get_connector_templates(),  # type: ignore",
            "        }",
            "",
            "    @classmethod",
            "    def connector_types(cls) -> List[str]:",
            "        \"\"\"List of registered SaaS connector types\"\"\"",
            "        return list(cls._get_combined_templates().keys())",
            "",
            "    @classmethod",
            "    def get_connector_template(cls, connector_type: str) -> Optional[ConnectorTemplate]:",
            "        \"\"\"",
            "        Returns an object containing the various SaaS connector artifacts",
            "        \"\"\"",
            "        return cls._get_combined_templates().get(connector_type)",
            "",
            "",
            "def create_connection_config_from_template_no_save(",
            "    db: Session,",
            "    template: ConnectorTemplate,",
            "    template_values: SaasConnectionTemplateValues,",
            "    system_id: Optional[str] = None,",
            ") -> ConnectionConfig:",
            "    \"\"\"Creates a SaaS connection config from a template without saving it.\"\"\"",
            "    # Load SaaS config from template and replace every instance of \"<instance_fides_key>\" with the fides_key",
            "    # the user has chosen",
            "    config_from_template: Dict = replace_config_placeholders(",
            "        template.config, \"<instance_fides_key>\", template_values.instance_key",
            "    )",
            "",
            "    data = {",
            "        \"key\": template_values.key",
            "        if template_values.key",
            "        else template_values.instance_key,",
            "        \"description\": template_values.description,",
            "        \"connection_type\": ConnectionType.saas,",
            "        \"access\": AccessLevel.write,",
            "        \"saas_config\": config_from_template,",
            "    }",
            "    if template_values.name:",
            "        data[\"name\"] = template_values.name",
            "",
            "    if system_id:",
            "        data[\"system_id\"] = system_id",
            "",
            "    # Create SaaS ConnectionConfig",
            "    connection_config = ConnectionConfig.create_without_saving(db, data=data)",
            "",
            "    return connection_config",
            "",
            "",
            "def upsert_dataset_config_from_template(",
            "    db: Session,",
            "    connection_config: ConnectionConfig,",
            "    template: ConnectorTemplate,",
            "    template_values: SaasConnectionTemplateValues,",
            ") -> DatasetConfig:",
            "    \"\"\"",
            "    Creates a `DatasetConfig` from a template",
            "    and associates it with a ConnectionConfig.",
            "    If the `DatasetConfig` already exists in the db,",
            "    then the existing record is updated.",
            "    \"\"\"",
            "    # Load the dataset config from template and replace every instance of \"<instance_fides_key>\" with the fides_key",
            "    # the user has chosen",
            "    dataset_from_template: Dict = replace_dataset_placeholders(",
            "        template.dataset, \"<instance_fides_key>\", template_values.instance_key",
            "    )",
            "    data = {",
            "        \"connection_config_id\": connection_config.id,",
            "        \"fides_key\": template_values.instance_key,",
            "        \"dataset\": dataset_from_template,  # Currently used for upserting a CTL Dataset",
            "    }",
            "    dataset_config = DatasetConfig.upsert_with_ctl_dataset(db, data=data)",
            "    return dataset_config",
            "",
            "",
            "def update_saas_configs(db: Session) -> None:",
            "    \"\"\"",
            "    Updates SaaS config instances currently in the DB if to the",
            "    corresponding template in the registry are found.",
            "",
            "    Effectively an \"update script\" for SaaS config instances,",
            "    to be run on server bootstrap.",
            "    \"\"\"",
            "    for connector_type in ConnectorRegistry.connector_types():",
            "        logger.debug(",
            "            \"Determining if any updates are needed for connectors of type {} based on templates...\",",
            "            connector_type,",
            "        )",
            "        template: ConnectorTemplate = ConnectorRegistry.get_connector_template(  # type: ignore",
            "            connector_type",
            "        )",
            "        saas_config = SaaSConfig(**load_config_from_string(template.config))",
            "        template_version: Version = parse_version(saas_config.version)",
            "",
            "        connection_configs: Iterable[ConnectionConfig] = ConnectionConfig.filter(",
            "            db=db,",
            "            conditions=(ConnectionConfig.saas_config[\"type\"].astext == connector_type),",
            "        ).all()",
            "        for connection_config in connection_configs:",
            "            saas_config_instance = SaaSConfig.parse_obj(connection_config.saas_config)",
            "            if parse_version(saas_config_instance.version) < template_version:",
            "                logger.info(",
            "                    \"Updating SaaS config instance '{}' of type '{}' as its version, {}, was found to be lower than the template version {}\",",
            "                    saas_config_instance.fides_key,",
            "                    connector_type,",
            "                    saas_config_instance.version,",
            "                    template_version,",
            "                )",
            "                try:",
            "                    update_saas_instance(",
            "                        db,",
            "                        connection_config,",
            "                        template,",
            "                        saas_config_instance,",
            "                    )",
            "                except Exception:",
            "                    logger.exception(",
            "                        \"Encountered error attempting to update SaaS config instance {}\",",
            "                        saas_config_instance.fides_key,",
            "                    )",
            "",
            "",
            "def update_saas_instance(",
            "    db: Session,",
            "    connection_config: ConnectionConfig,",
            "    template: ConnectorTemplate,",
            "    saas_config_instance: SaaSConfig,",
            ") -> None:",
            "    \"\"\"",
            "    Replace in the DB the existing SaaS instance configuration data",
            "    (SaaSConfig, DatasetConfig) associated with the given ConnectionConfig",
            "    with new instance configuration data based on the given ConnectorTemplate",
            "    \"\"\"",
            "    template_vals = SaasConnectionTemplateValues(",
            "        name=connection_config.name,",
            "        key=connection_config.key,",
            "        description=connection_config.description,",
            "        secrets=connection_config.secrets,",
            "        instance_key=saas_config_instance.fides_key,",
            "    )",
            "",
            "    config_from_template: Dict = replace_config_placeholders(",
            "        template.config, \"<instance_fides_key>\", template_vals.instance_key",
            "    )",
            "",
            "    connection_config.update_saas_config(db, SaaSConfig(**config_from_template))",
            "",
            "    upsert_dataset_config_from_template(db, connection_config, template, template_vals)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "4": [],
            "5": [],
            "6": [],
            "9": [],
            "14": [],
            "15": [],
            "19": [],
            "44": [],
            "99": [
                "FileConnectorTemplateLoader",
                "_load_connector_templates"
            ],
            "154": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "155": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "161": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "165": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "166": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "167": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "168": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "169": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "170": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "171": [
                "CustomConnectorTemplateLoader",
                "_register_template"
            ],
            "223": [
                "CustomConnectorTemplateLoader",
                "save_template"
            ],
            "224": [
                "CustomConnectorTemplateLoader",
                "save_template"
            ],
            "225": [
                "CustomConnectorTemplateLoader",
                "save_template"
            ],
            "226": [
                "CustomConnectorTemplateLoader",
                "save_template"
            ],
            "227": [
                "CustomConnectorTemplateLoader",
                "save_template"
            ],
            "228": [
                "CustomConnectorTemplateLoader",
                "save_template"
            ],
            "229": [
                "CustomConnectorTemplateLoader",
                "save_template"
            ],
            "269": [
                "CustomConnectorTemplateLoader",
                "save_template"
            ],
            "450": [],
            "451": [],
            "452": [
                "register_custom_functions"
            ],
            "453": [
                "register_custom_functions"
            ],
            "454": [
                "register_custom_functions"
            ],
            "455": [
                "register_custom_functions"
            ],
            "456": [
                "register_custom_functions"
            ],
            "457": [
                "register_custom_functions"
            ],
            "458": [
                "register_custom_functions"
            ],
            "459": [
                "register_custom_functions"
            ],
            "460": [
                "register_custom_functions"
            ],
            "461": [
                "register_custom_functions"
            ],
            "462": [
                "register_custom_functions"
            ],
            "463": [
                "register_custom_functions"
            ],
            "464": [
                "register_custom_functions"
            ],
            "465": [
                "register_custom_functions"
            ],
            "466": [
                "register_custom_functions"
            ],
            "467": [
                "register_custom_functions"
            ],
            "468": [
                "register_custom_functions"
            ],
            "469": [
                "register_custom_functions"
            ],
            "470": [
                "register_custom_functions"
            ],
            "471": [
                "register_custom_functions"
            ],
            "472": [
                "register_custom_functions"
            ],
            "473": [
                "register_custom_functions"
            ],
            "474": [
                "register_custom_functions"
            ],
            "475": [
                "register_custom_functions"
            ],
            "476": [
                "register_custom_functions"
            ],
            "477": [
                "register_custom_functions"
            ],
            "478": [
                "register_custom_functions"
            ],
            "479": [
                "register_custom_functions"
            ],
            "480": [
                "register_custom_functions"
            ],
            "481": [
                "register_custom_functions"
            ],
            "482": [
                "register_custom_functions"
            ],
            "483": [
                "register_custom_functions"
            ],
            "484": [
                "register_custom_functions"
            ],
            "485": [
                "register_custom_functions"
            ],
            "486": [
                "register_custom_functions"
            ],
            "487": [
                "register_custom_functions"
            ],
            "488": [
                "register_custom_functions"
            ],
            "489": [
                "register_custom_functions"
            ],
            "490": [],
            "491": [],
            "492": [
                "CustomRestrictingNodeTransformer"
            ],
            "493": [
                "CustomRestrictingNodeTransformer"
            ],
            "494": [
                "CustomRestrictingNodeTransformer"
            ],
            "495": [
                "CustomRestrictingNodeTransformer"
            ],
            "496": [
                "CustomRestrictingNodeTransformer"
            ],
            "497": [
                "CustomRestrictingNodeTransformer"
            ],
            "498": [
                "CustomRestrictingNodeTransformer",
                "visit_AnnAssign"
            ],
            "499": [
                "CustomRestrictingNodeTransformer",
                "visit_AnnAssign"
            ],
            "500": [],
            "501": [],
            "502": [
                "custom_guarded_import"
            ],
            "503": [
                "custom_guarded_import"
            ],
            "504": [
                "custom_guarded_import"
            ],
            "505": [
                "custom_guarded_import"
            ],
            "506": [
                "custom_guarded_import"
            ],
            "507": [
                "custom_guarded_import"
            ],
            "508": [
                "custom_guarded_import"
            ],
            "509": [
                "custom_guarded_import"
            ],
            "510": [
                "custom_guarded_import"
            ],
            "511": [
                "custom_guarded_import"
            ],
            "512": [
                "custom_guarded_import"
            ],
            "513": [
                "custom_guarded_import"
            ],
            "514": [
                "custom_guarded_import"
            ],
            "515": [
                "custom_guarded_import"
            ],
            "516": [
                "custom_guarded_import"
            ],
            "517": [
                "custom_guarded_import"
            ],
            "518": [
                "custom_guarded_import"
            ],
            "519": [
                "custom_guarded_import"
            ],
            "520": [
                "custom_guarded_import"
            ],
            "521": [
                "custom_guarded_import"
            ],
            "522": [
                "custom_guarded_import"
            ],
            "523": [
                "custom_guarded_import"
            ],
            "524": [
                "custom_guarded_import"
            ],
            "525": [
                "custom_guarded_import"
            ],
            "526": [
                "custom_guarded_import"
            ]
        },
        "addLocation": []
    },
    "src/fides/config/security_settings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         default=432000,"
            },
            "1": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\","
            },
            "2": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     )"
            },
            "3": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    allow_custom_connector_functions: Optional[bool] = Field("
            },
            "4": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        default=False,"
            },
            "5": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        description=\"Enables or disables the ability to import connector templates with custom functions. When enabled, custom functions which will be loaded in a restricted environment to minimize security risks.\","
            },
            "6": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    )"
            },
            "7": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     enable_audit_log_resource_middleware: Optional[bool] = Field("
            },
            "8": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         default=False,"
            },
            "9": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         description=\"Either enables the collection of audit log resource data or bypasses the middleware\","
            }
        },
        "frontPatchFile": [
            "\"\"\"This module handles finding and parsing fides configuration files.\"\"\"",
            "",
            "# pylint: disable=C0115,C0116, E0213",
            "from typing import Dict, List, Optional, Pattern, Tuple, Union",
            "",
            "import validators",
            "from pydantic import Field, validator",
            "from slowapi.wrappers import parse_many  # type: ignore",
            "",
            "from fides.api.cryptography.cryptographic_util import generate_salt, hash_with_salt",
            "from fides.api.oauth.roles import OWNER",
            "from fides.common.api.scope_registry import SCOPE_REGISTRY",
            "",
            "from .fides_settings import FidesSettings",
            "",
            "ENV_PREFIX = \"FIDES__SECURITY__\"",
            "",
            "",
            "class SecuritySettings(FidesSettings):",
            "    \"\"\"Configuration settings for application security.\"\"\"",
            "",
            "    aes_encryption_key_length: int = Field(",
            "        default=16,",
            "        description=\"Length of desired encryption key when using Fides to generate a random secure string used for AES encryption.\",",
            "    )",
            "    aes_gcm_nonce_length: int = Field(",
            "        default=12,",
            "        description=\"Length of desired random byte str for the AES GCM encryption used throughout Fides.\",",
            "    )",
            "    app_encryption_key: str = Field(",
            "        default=\"\", description=\"The key used to sign Fides API access tokens.\"",
            "    )",
            "    cors_origins: List[str] = Field(",
            "        default=[],",
            "        description=\"A list of client addresses allowed to communicate with the Fides webserver.\",",
            "    )",
            "    cors_origin_regex: Optional[Pattern] = Field(",
            "        default=None,",
            "        description=\"A regex pattern used to set the CORS origin allowlist.\",",
            "    )",
            "    drp_jwt_secret: Optional[str] = Field(",
            "        default=None,",
            "        description=\"JWT secret by which passed-in identity is decrypted according to the HS256 algorithm.\",",
            "    )",
            "    encoding: str = Field(",
            "        default=\"UTF-8\", description=\"Text encoding to use for the application.\"",
            "    )",
            "    env: str = Field(",
            "        default=\"dev\",",
            "        description=\"The default, `dev`, does not apply authentication to endpoints typically used by the CLI. The other option, `prod`, requires authentication for _all_ endpoints that may contain sensitive information.\",",
            "    )",
            "    identity_verification_attempt_limit: int = Field(",
            "        default=3,",
            "        description=\"The number of times identity verification will be attempted before raising an error.\",",
            "    )",
            "    oauth_root_client_id: str = Field(",
            "        default=\"\",",
            "        description=\"The value used to identify the Fides application root API client.\",",
            "    )",
            "    oauth_root_client_secret: str = Field(",
            "        default=\"\",",
            "        description=\"The secret value used to authenticate the Fides application root API client.\",",
            "    )",
            "    oauth_root_client_secret_hash: Optional[Tuple] = Field(",
            "        default=None,",
            "        description=\"Automatically generated by Fides, and represents a hashed value of the oauth_root_client_secret.\",",
            "    )",
            "    oauth_access_token_expire_minutes: int = Field(",
            "        default=11520,",
            "        description=\"The time in minutes for which Fides API tokens will be valid. Default value is equal to 8 days.\",",
            "    )",
            "    oauth_client_id_length_bytes: int = Field(",
            "        default=16,",
            "        description=\"Sets desired length in bytes of generated client id used for oauth.\",",
            "    )",
            "    oauth_client_secret_length_bytes: int = Field(",
            "        default=16,",
            "        description=\"Sets desired length in bytes of generated client secret used for oauth.\",",
            "    )",
            "    parent_server_password: Optional[str] = Field(",
            "        default=None,",
            "        description=\"When using a parent/child Fides deployment, this password will be used by the child server to access the parent server.\",",
            "    )",
            "    parent_server_username: Optional[str] = Field(",
            "        default=None,",
            "        description=\"When using a parent/child Fides deployment, this username will be used by the child server to access the parent server.\",",
            "    )",
            "    public_request_rate_limit: str = Field(",
            "        default=\"2000/minute\",",
            "        description=\"The number of requests from a single IP address allowed to hit a public endpoint within the specified time period\",",
            "    )",
            "    rate_limit_prefix: str = Field(",
            "        default=\"fides-\",",
            "        description=\"The prefix given to keys in the Redis cache used by the rate limiter.\",",
            "    )",
            "    request_rate_limit: str = Field(",
            "        default=\"1000/minute\",",
            "        description=\"The number of requests from a single IP address allowed to hit an endpoint within a rolling 60 second period.\",",
            "    )",
            "    root_user_scopes: List[str] = Field(",
            "        default=SCOPE_REGISTRY,",
            "        description=\"The list of scopes that are given to the root user.\",",
            "    )",
            "    root_user_roles: List[str] = Field(",
            "        default=[OWNER],",
            "        description=\"The list of roles that are given to the root user.\",",
            "    )",
            "    root_password: Optional[str] = Field(",
            "        default=None,",
            "        description=\"If set, this can be used in conjunction with root_username to log in without first creating a user in the database.\",",
            "    )",
            "",
            "    root_username: Optional[str] = Field(",
            "        default=None,",
            "        description=\"If set, this can be used in conjunction with root_password to log in without first creating a user in the database.\",",
            "    )",
            "    subject_request_download_link_ttl_seconds: int = Field(",
            "        default=432000,",
            "        description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",",
            "    )",
            "    allow_custom_connector_functions: Optional[bool] = Field(",
            "        default=False,",
            "        description=\"Enables or disables the ability to import connector templates with custom functions. When enabled, custom functions which will be loaded in a restricted environment to minimize security risks.\",",
            "    )",
            "    enable_audit_log_resource_middleware: Optional[bool] = Field(",
            "        default=False,",
            "        description=\"Either enables the collection of audit log resource data or bypasses the middleware\",",
            "    )",
            "",
            "    bastion_server_host: Optional[str] = Field(",
            "        default=None, description=\"An optional field to store the bastion server host\"",
            "    )",
            "    bastion_server_ssh_username: Optional[str] = Field(",
            "        default=None,",
            "        description=\"An optional field to store the username used to access the bastion server\",",
            "    )",
            "    bastion_server_ssh_private_key: Optional[str] = Field(",
            "        default=None,",
            "        description=\"An optional field to store the key used to SSH into the bastion server.\",",
            "    )",
            "    bastion_server_ssh_timeout: float = Field(",
            "        default=0.1,",
            "        description=\"The timeout in seconds for the transport socket (``socket.settimeout``)\",",
            "    )",
            "    bastion_server_ssh_tunnel_timeout: float = Field(",
            "        default=10,",
            "        description=\"The timeout in seconds for tunnel connection (open_channel timeout)\",",
            "    )",
            "",
            "    @validator(\"app_encryption_key\")",
            "    @classmethod",
            "    def validate_encryption_key_length(",
            "        cls, v: Optional[str], values: Dict[str, str]",
            "    ) -> Optional[str]:",
            "        \"\"\"Validate the encryption key is exactly 32 characters\"\"\"",
            "",
            "        # If the value is the default value, return immediately to prevent unwanted errors",
            "        if v == \"\":",
            "            return v",
            "",
            "        if v is None or len(v.encode(values.get(\"encoding\", \"UTF-8\"))) != 32:",
            "            raise ValueError(",
            "                \"APP_ENCRYPTION_KEY value must be exactly 32 characters long\"",
            "            )",
            "        return v",
            "",
            "    @validator(\"cors_origins\", pre=True)",
            "    @classmethod",
            "    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:",
            "        \"\"\"Return a list of valid origins for CORS requests\"\"\"",
            "",
            "        def validate(values: List[str]) -> None:",
            "            for value in values:",
            "                if value != \"*\":",
            "                    if not validators.url(value):",
            "                        raise ValueError(f\"{value} is not a valid url\")",
            "",
            "        if isinstance(v, str) and not v.startswith(\"[\"):",
            "            values = [i.strip() for i in v.split(\",\")]",
            "            validate(values)",
            "",
            "            return values",
            "        if isinstance(v, (list, str)):",
            "            validate(v)  # type: ignore",
            "",
            "            return v",
            "        raise ValueError(v)",
            "",
            "    @validator(\"oauth_root_client_secret_hash\")",
            "    @classmethod",
            "    def assemble_root_access_token(",
            "        cls, v: Optional[str], values: Dict[str, str]",
            "    ) -> Optional[Tuple]:",
            "        \"\"\"",
            "        Sets a hashed value of the root access key.",
            "        This is hashed as it is not wise to return a plaintext for of the",
            "        root credential anywhere in the system.",
            "        \"\"\"",
            "        value = values.get(\"oauth_root_client_secret\", \"\")",
            "",
            "        if not value:",
            "            return None",
            "",
            "        encoding = values.get(\"encoding\", \"UTF-8\")",
            "",
            "        salt = generate_salt()",
            "        hashed_client_id = hash_with_salt(value.encode(encoding), salt.encode(encoding))",
            "        oauth_root_client_secret_hash = (hashed_client_id, salt.encode(encoding))  # type: ignore",
            "        return oauth_root_client_secret_hash",
            "",
            "    @validator(\"request_rate_limit\")",
            "    @classmethod",
            "    def validate_request_rate_limit(",
            "        cls,",
            "        v: str,",
            "    ) -> str:",
            "        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"",
            "        try:",
            "            # Defer to `limits.parse_many` https://limits.readthedocs.io/en/stable/api.html#limits.parse_many",
            "            parse_many(v)",
            "        except ValueError:",
            "            message = \"\"\"",
            "            Ratelimits must be specified in the format: [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]",
            "            e.g. 10 per hour",
            "            e.g. 10/hour",
            "            e.g. 10/hour;100/day;2000 per year",
            "            e.g. 100/day, 500/7days",
            "            \"\"\"",
            "            raise ValueError(message)",
            "        return v",
            "",
            "    @validator(\"env\")",
            "    @classmethod",
            "    def validate_env(",
            "        cls,",
            "        v: str,",
            "    ) -> str:",
            "        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"",
            "        if v not in [\"dev\", \"prod\"]:",
            "            message = \"Security environment must be either 'dev' or 'prod'.\"",
            "            raise ValueError(message)",
            "        return v",
            "",
            "    class Config:",
            "        env_prefix = ENV_PREFIX"
        ],
        "afterPatchFile": [
            "\"\"\"This module handles finding and parsing fides configuration files.\"\"\"",
            "",
            "# pylint: disable=C0115,C0116, E0213",
            "from typing import Dict, List, Optional, Pattern, Tuple, Union",
            "",
            "import validators",
            "from pydantic import Field, validator",
            "from slowapi.wrappers import parse_many  # type: ignore",
            "",
            "from fides.api.cryptography.cryptographic_util import generate_salt, hash_with_salt",
            "from fides.api.oauth.roles import OWNER",
            "from fides.common.api.scope_registry import SCOPE_REGISTRY",
            "",
            "from .fides_settings import FidesSettings",
            "",
            "ENV_PREFIX = \"FIDES__SECURITY__\"",
            "",
            "",
            "class SecuritySettings(FidesSettings):",
            "    \"\"\"Configuration settings for application security.\"\"\"",
            "",
            "    aes_encryption_key_length: int = Field(",
            "        default=16,",
            "        description=\"Length of desired encryption key when using Fides to generate a random secure string used for AES encryption.\",",
            "    )",
            "    aes_gcm_nonce_length: int = Field(",
            "        default=12,",
            "        description=\"Length of desired random byte str for the AES GCM encryption used throughout Fides.\",",
            "    )",
            "    app_encryption_key: str = Field(",
            "        default=\"\", description=\"The key used to sign Fides API access tokens.\"",
            "    )",
            "    cors_origins: List[str] = Field(",
            "        default=[],",
            "        description=\"A list of client addresses allowed to communicate with the Fides webserver.\",",
            "    )",
            "    cors_origin_regex: Optional[Pattern] = Field(",
            "        default=None,",
            "        description=\"A regex pattern used to set the CORS origin allowlist.\",",
            "    )",
            "    drp_jwt_secret: Optional[str] = Field(",
            "        default=None,",
            "        description=\"JWT secret by which passed-in identity is decrypted according to the HS256 algorithm.\",",
            "    )",
            "    encoding: str = Field(",
            "        default=\"UTF-8\", description=\"Text encoding to use for the application.\"",
            "    )",
            "    env: str = Field(",
            "        default=\"dev\",",
            "        description=\"The default, `dev`, does not apply authentication to endpoints typically used by the CLI. The other option, `prod`, requires authentication for _all_ endpoints that may contain sensitive information.\",",
            "    )",
            "    identity_verification_attempt_limit: int = Field(",
            "        default=3,",
            "        description=\"The number of times identity verification will be attempted before raising an error.\",",
            "    )",
            "    oauth_root_client_id: str = Field(",
            "        default=\"\",",
            "        description=\"The value used to identify the Fides application root API client.\",",
            "    )",
            "    oauth_root_client_secret: str = Field(",
            "        default=\"\",",
            "        description=\"The secret value used to authenticate the Fides application root API client.\",",
            "    )",
            "    oauth_root_client_secret_hash: Optional[Tuple] = Field(",
            "        default=None,",
            "        description=\"Automatically generated by Fides, and represents a hashed value of the oauth_root_client_secret.\",",
            "    )",
            "    oauth_access_token_expire_minutes: int = Field(",
            "        default=11520,",
            "        description=\"The time in minutes for which Fides API tokens will be valid. Default value is equal to 8 days.\",",
            "    )",
            "    oauth_client_id_length_bytes: int = Field(",
            "        default=16,",
            "        description=\"Sets desired length in bytes of generated client id used for oauth.\",",
            "    )",
            "    oauth_client_secret_length_bytes: int = Field(",
            "        default=16,",
            "        description=\"Sets desired length in bytes of generated client secret used for oauth.\",",
            "    )",
            "    parent_server_password: Optional[str] = Field(",
            "        default=None,",
            "        description=\"When using a parent/child Fides deployment, this password will be used by the child server to access the parent server.\",",
            "    )",
            "    parent_server_username: Optional[str] = Field(",
            "        default=None,",
            "        description=\"When using a parent/child Fides deployment, this username will be used by the child server to access the parent server.\",",
            "    )",
            "    public_request_rate_limit: str = Field(",
            "        default=\"2000/minute\",",
            "        description=\"The number of requests from a single IP address allowed to hit a public endpoint within the specified time period\",",
            "    )",
            "    rate_limit_prefix: str = Field(",
            "        default=\"fides-\",",
            "        description=\"The prefix given to keys in the Redis cache used by the rate limiter.\",",
            "    )",
            "    request_rate_limit: str = Field(",
            "        default=\"1000/minute\",",
            "        description=\"The number of requests from a single IP address allowed to hit an endpoint within a rolling 60 second period.\",",
            "    )",
            "    root_user_scopes: List[str] = Field(",
            "        default=SCOPE_REGISTRY,",
            "        description=\"The list of scopes that are given to the root user.\",",
            "    )",
            "    root_user_roles: List[str] = Field(",
            "        default=[OWNER],",
            "        description=\"The list of roles that are given to the root user.\",",
            "    )",
            "    root_password: Optional[str] = Field(",
            "        default=None,",
            "        description=\"If set, this can be used in conjunction with root_username to log in without first creating a user in the database.\",",
            "    )",
            "",
            "    root_username: Optional[str] = Field(",
            "        default=None,",
            "        description=\"If set, this can be used in conjunction with root_password to log in without first creating a user in the database.\",",
            "    )",
            "    subject_request_download_link_ttl_seconds: int = Field(",
            "        default=432000,",
            "        description=\"The number of seconds that a pre-signed download URL when using S3 storage will be valid. The default is equal to 5 days.\",",
            "    )",
            "    enable_audit_log_resource_middleware: Optional[bool] = Field(",
            "        default=False,",
            "        description=\"Either enables the collection of audit log resource data or bypasses the middleware\",",
            "    )",
            "",
            "    bastion_server_host: Optional[str] = Field(",
            "        default=None, description=\"An optional field to store the bastion server host\"",
            "    )",
            "    bastion_server_ssh_username: Optional[str] = Field(",
            "        default=None,",
            "        description=\"An optional field to store the username used to access the bastion server\",",
            "    )",
            "    bastion_server_ssh_private_key: Optional[str] = Field(",
            "        default=None,",
            "        description=\"An optional field to store the key used to SSH into the bastion server.\",",
            "    )",
            "    bastion_server_ssh_timeout: float = Field(",
            "        default=0.1,",
            "        description=\"The timeout in seconds for the transport socket (``socket.settimeout``)\",",
            "    )",
            "    bastion_server_ssh_tunnel_timeout: float = Field(",
            "        default=10,",
            "        description=\"The timeout in seconds for tunnel connection (open_channel timeout)\",",
            "    )",
            "",
            "    @validator(\"app_encryption_key\")",
            "    @classmethod",
            "    def validate_encryption_key_length(",
            "        cls, v: Optional[str], values: Dict[str, str]",
            "    ) -> Optional[str]:",
            "        \"\"\"Validate the encryption key is exactly 32 characters\"\"\"",
            "",
            "        # If the value is the default value, return immediately to prevent unwanted errors",
            "        if v == \"\":",
            "            return v",
            "",
            "        if v is None or len(v.encode(values.get(\"encoding\", \"UTF-8\"))) != 32:",
            "            raise ValueError(",
            "                \"APP_ENCRYPTION_KEY value must be exactly 32 characters long\"",
            "            )",
            "        return v",
            "",
            "    @validator(\"cors_origins\", pre=True)",
            "    @classmethod",
            "    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:",
            "        \"\"\"Return a list of valid origins for CORS requests\"\"\"",
            "",
            "        def validate(values: List[str]) -> None:",
            "            for value in values:",
            "                if value != \"*\":",
            "                    if not validators.url(value):",
            "                        raise ValueError(f\"{value} is not a valid url\")",
            "",
            "        if isinstance(v, str) and not v.startswith(\"[\"):",
            "            values = [i.strip() for i in v.split(\",\")]",
            "            validate(values)",
            "",
            "            return values",
            "        if isinstance(v, (list, str)):",
            "            validate(v)  # type: ignore",
            "",
            "            return v",
            "        raise ValueError(v)",
            "",
            "    @validator(\"oauth_root_client_secret_hash\")",
            "    @classmethod",
            "    def assemble_root_access_token(",
            "        cls, v: Optional[str], values: Dict[str, str]",
            "    ) -> Optional[Tuple]:",
            "        \"\"\"",
            "        Sets a hashed value of the root access key.",
            "        This is hashed as it is not wise to return a plaintext for of the",
            "        root credential anywhere in the system.",
            "        \"\"\"",
            "        value = values.get(\"oauth_root_client_secret\", \"\")",
            "",
            "        if not value:",
            "            return None",
            "",
            "        encoding = values.get(\"encoding\", \"UTF-8\")",
            "",
            "        salt = generate_salt()",
            "        hashed_client_id = hash_with_salt(value.encode(encoding), salt.encode(encoding))",
            "        oauth_root_client_secret_hash = (hashed_client_id, salt.encode(encoding))  # type: ignore",
            "        return oauth_root_client_secret_hash",
            "",
            "    @validator(\"request_rate_limit\")",
            "    @classmethod",
            "    def validate_request_rate_limit(",
            "        cls,",
            "        v: str,",
            "    ) -> str:",
            "        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"",
            "        try:",
            "            # Defer to `limits.parse_many` https://limits.readthedocs.io/en/stable/api.html#limits.parse_many",
            "            parse_many(v)",
            "        except ValueError:",
            "            message = \"\"\"",
            "            Ratelimits must be specified in the format: [count] [per|/] [n (optional)] [second|minute|hour|day|month|year]",
            "            e.g. 10 per hour",
            "            e.g. 10/hour",
            "            e.g. 10/hour;100/day;2000 per year",
            "            e.g. 100/day, 500/7days",
            "            \"\"\"",
            "            raise ValueError(message)",
            "        return v",
            "",
            "    @validator(\"env\")",
            "    @classmethod",
            "    def validate_env(",
            "        cls,",
            "        v: str,",
            "    ) -> str:",
            "        \"\"\"Validate the formatting of `request_rate_limit`\"\"\"",
            "        if v not in [\"dev\", \"prod\"]:",
            "            message = \"Security environment must be either 'dev' or 'prod'.\"",
            "            raise ValueError(message)",
            "        return v",
            "",
            "    class Config:",
            "        env_prefix = ENV_PREFIX"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "121": [
                "SecuritySettings"
            ],
            "122": [
                "SecuritySettings"
            ],
            "123": [
                "SecuritySettings"
            ],
            "124": [
                "SecuritySettings"
            ]
        },
        "addLocation": []
    }
}