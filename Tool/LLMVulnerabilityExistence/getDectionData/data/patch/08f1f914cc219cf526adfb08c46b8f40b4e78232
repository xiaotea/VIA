{
    "nova/console/websocketproxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " Leverages websockify.py by Joel Martin"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " '''"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+import copy"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import socket"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import sys"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "                 detail = _(\"Origin header protocol does not match this host.\")"
            },
            "8": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "                 raise exception.ValidationError(detail=detail)"
            },
            "9": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.msg(_('connect info: %s'), str(connect_info))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+        sanitized_info = copy.copy(connect_info)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+        sanitized_info['token'] = '***'"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        self.msg(_('connect info: %s'), sanitized_info)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         host = connect_info['host']"
            },
            "16": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         port = int(connect_info['port'])"
            },
            "17": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 258,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "'''",
            "Websocket proxy that is compatible with OpenStack Nova.",
            "Leverages websockify.py by Joel Martin",
            "'''",
            "",
            "import socket",
            "import sys",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import encodeutils",
            "import six",
            "from six.moves import http_cookies as Cookie",
            "import six.moves.urllib.parse as urlparse",
            "import websockify",
            "",
            "from nova.compute import rpcapi as compute_rpcapi",
            "import nova.conf",
            "from nova.consoleauth import rpcapi as consoleauth_rpcapi",
            "from nova import context",
            "from nova import exception",
            "from nova.i18n import _",
            "from nova import objects",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class TenantSock(object):",
            "    \"\"\"A socket wrapper for communicating with the tenant.",
            "",
            "    This class provides a socket-like interface to the internal",
            "    websockify send/receive queue for the client connection to",
            "    the tenant user. It is used with the security proxy classes.",
            "    \"\"\"",
            "",
            "    def __init__(self, reqhandler):",
            "        self.reqhandler = reqhandler",
            "        self.queue = []",
            "",
            "    def recv(self, cnt):",
            "        # NB(sross): it's ok to block here because we know",
            "        #            exactly the sequence of data arriving",
            "        while len(self.queue) < cnt:",
            "            # new_frames looks like ['abc', 'def']",
            "            new_frames, closed = self.reqhandler.recv_frames()",
            "            # flatten frames onto queue",
            "            for frame in new_frames:",
            "                # The socket returns (byte) strings in Python 2...",
            "                if six.PY2:",
            "                    self.queue.extend(frame)",
            "                # ...and integers in Python 3. For the Python 3 case, we need",
            "                # to convert these to characters using 'chr' and then, as this",
            "                # returns unicode, convert the result to byte strings.",
            "                else:",
            "                    self.queue.extend(",
            "                        [six.binary_type(chr(c), 'ascii') for c in frame])",
            "",
            "            if closed:",
            "                break",
            "",
            "        popped = self.queue[0:cnt]",
            "        del self.queue[0:cnt]",
            "        return b''.join(popped)",
            "",
            "    def sendall(self, data):",
            "        self.reqhandler.send_frames([encodeutils.safe_encode(data)])",
            "",
            "    def finish_up(self):",
            "        self.reqhandler.send_frames([b''.join(self.queue)])",
            "",
            "    def close(self):",
            "        self.finish_up()",
            "        self.reqhandler.send_close()",
            "",
            "",
            "class NovaProxyRequestHandlerBase(object):",
            "    def address_string(self):",
            "        # NOTE(rpodolyaka): override the superclass implementation here and",
            "        # explicitly disable the reverse DNS lookup, which might fail on some",
            "        # deployments due to DNS configuration and break VNC access completely",
            "        return str(self.client_address[0])",
            "",
            "    def verify_origin_proto(self, connection_info, origin_proto):",
            "        access_url = connection_info.get('access_url')",
            "        if not access_url:",
            "            detail = _(\"No access_url in connection_info. \"",
            "                        \"Cannot validate protocol\")",
            "            raise exception.ValidationError(detail=detail)",
            "        expected_protos = [urlparse.urlparse(access_url).scheme]",
            "        # NOTE: For serial consoles the expected protocol could be ws or",
            "        # wss which correspond to http and https respectively in terms of",
            "        # security.",
            "        if 'ws' in expected_protos:",
            "            expected_protos.append('http')",
            "        if 'wss' in expected_protos:",
            "            expected_protos.append('https')",
            "",
            "        return origin_proto in expected_protos",
            "",
            "    def _check_console_port(self, ctxt, instance_uuid, port, console_type):",
            "",
            "        try:",
            "            instance = objects.Instance.get_by_uuid(ctxt, instance_uuid)",
            "        except exception.InstanceNotFound:",
            "            return",
            "",
            "        # NOTE(melwitt): The port is expected to be a str for validation.",
            "        return self.compute_rpcapi.validate_console_port(ctxt, instance,",
            "                                                         str(port),",
            "                                                         console_type)",
            "",
            "    def _get_connect_info_consoleauth(self, ctxt, token):",
            "        # NOTE(PaulMurray) consoleauth check_token() validates the token",
            "        # and does an rpc to compute manager to check the console port",
            "        # is correct.",
            "        rpcapi = consoleauth_rpcapi.ConsoleAuthAPI()",
            "        return rpcapi.check_token(ctxt, token=token)",
            "",
            "    def _get_connect_info_database(self, ctxt, token):",
            "        # NOTE(PaulMurray) ConsoleAuthToken.validate validates the token.",
            "        # We call the compute manager directly to check the console port",
            "        # is correct.",
            "        connect_info = objects.ConsoleAuthToken.validate(ctxt, token).to_dict()",
            "",
            "        valid_port = self._check_console_port(",
            "            ctxt, connect_info['instance_uuid'], connect_info['port'],",
            "            connect_info['console_type'])",
            "",
            "        if not valid_port:",
            "            raise exception.InvalidToken(token='***')",
            "",
            "        return connect_info",
            "",
            "    def _get_connect_info(self, ctxt, token):",
            "        \"\"\"Validate the token and get the connect info.\"\"\"",
            "        connect_info = None",
            "        # NOTE(PaulMurray) if we are using cells v1, we use the old consoleauth",
            "        # way of doing things. The database backend is not supported for cells",
            "        # v1.",
            "        if CONF.cells.enable:",
            "            connect_info = self._get_connect_info_consoleauth(ctxt, token)",
            "            if not connect_info:",
            "                raise exception.InvalidToken(token='***')",
            "        else:",
            "            # NOTE(melwitt): If consoleauth is enabled to aid in transitioning",
            "            # to the database backend, check it first before falling back to",
            "            # the database. Tokens that existed pre-database-backend will",
            "            # reside in the consoleauth service storage.",
            "            if CONF.workarounds.enable_consoleauth:",
            "                connect_info = self._get_connect_info_consoleauth(ctxt, token)",
            "            # If consoleauth is enabled to aid in transitioning to the database",
            "            # backend and we didn't find a token in the consoleauth service",
            "            # storage, check the database for a token because it's probably a",
            "            # post-database-backend token, which are stored in the database.",
            "            if not connect_info:",
            "                connect_info = self._get_connect_info_database(ctxt, token)",
            "",
            "        return connect_info",
            "",
            "    def new_websocket_client(self):",
            "        \"\"\"Called after a new WebSocket connection has been established.\"\"\"",
            "        # Reopen the eventlet hub to make sure we don't share an epoll",
            "        # fd with parent and/or siblings, which would be bad",
            "        from eventlet import hubs",
            "        hubs.use_hub()",
            "",
            "        # The nova expected behavior is to have token",
            "        # passed to the method GET of the request",
            "        parse = urlparse.urlparse(self.path)",
            "        if parse.scheme not in ('http', 'https'):",
            "            # From a bug in urlparse in Python < 2.7.4 we cannot support",
            "            # special schemes (cf: http://bugs.python.org/issue9374)",
            "            if sys.version_info < (2, 7, 4):",
            "                raise exception.NovaException(",
            "                    _(\"We do not support scheme '%s' under Python < 2.7.4, \"",
            "                      \"please use http or https\") % parse.scheme)",
            "",
            "        query = parse.query",
            "        token = urlparse.parse_qs(query).get(\"token\", [\"\"]).pop()",
            "        if not token:",
            "            # NoVNC uses it's own convention that forward token",
            "            # from the request to a cookie header, we should check",
            "            # also for this behavior",
            "            hcookie = self.headers.get('cookie')",
            "            if hcookie:",
            "                cookie = Cookie.SimpleCookie()",
            "                for hcookie_part in hcookie.split(';'):",
            "                    hcookie_part = hcookie_part.lstrip()",
            "                    try:",
            "                        cookie.load(hcookie_part)",
            "                    except Cookie.CookieError:",
            "                        # NOTE(stgleb): Do not print out cookie content",
            "                        # for security reasons.",
            "                        LOG.warning('Found malformed cookie')",
            "                    else:",
            "                        if 'token' in cookie:",
            "                            token = cookie['token'].value",
            "",
            "        ctxt = context.get_admin_context()",
            "        connect_info = self._get_connect_info(ctxt, token)",
            "",
            "        # Verify Origin",
            "        expected_origin_hostname = self.headers.get('Host')",
            "        if ':' in expected_origin_hostname:",
            "            e = expected_origin_hostname",
            "            if '[' in e and ']' in e:",
            "                expected_origin_hostname = e.split(']')[0][1:]",
            "            else:",
            "                expected_origin_hostname = e.split(':')[0]",
            "        expected_origin_hostnames = CONF.console.allowed_origins",
            "        expected_origin_hostnames.append(expected_origin_hostname)",
            "        origin_url = self.headers.get('Origin')",
            "        # missing origin header indicates non-browser client which is OK",
            "        if origin_url is not None:",
            "            origin = urlparse.urlparse(origin_url)",
            "            origin_hostname = origin.hostname",
            "            origin_scheme = origin.scheme",
            "            # If the console connection was forwarded by a proxy (example:",
            "            # haproxy), the original protocol could be contained in the",
            "            # X-Forwarded-Proto header instead of the Origin header. Prefer the",
            "            # forwarded protocol if it is present.",
            "            forwarded_proto = self.headers.get('X-Forwarded-Proto')",
            "            if forwarded_proto is not None:",
            "                origin_scheme = forwarded_proto",
            "            if origin_hostname == '' or origin_scheme == '':",
            "                detail = _(\"Origin header not valid.\")",
            "                raise exception.ValidationError(detail=detail)",
            "            if origin_hostname not in expected_origin_hostnames:",
            "                detail = _(\"Origin header does not match this host.\")",
            "                raise exception.ValidationError(detail=detail)",
            "            if not self.verify_origin_proto(connect_info, origin_scheme):",
            "                detail = _(\"Origin header protocol does not match this host.\")",
            "                raise exception.ValidationError(detail=detail)",
            "",
            "        self.msg(_('connect info: %s'), str(connect_info))",
            "        host = connect_info['host']",
            "        port = int(connect_info['port'])",
            "",
            "        # Connect to the target",
            "        self.msg(_(\"connecting to: %(host)s:%(port)s\") % {'host': host,",
            "                                                          'port': port})",
            "        tsock = self.socket(host, port, connect=True)",
            "",
            "        # Handshake as necessary",
            "        if connect_info.get('internal_access_path'):",
            "            tsock.send(encodeutils.safe_encode(",
            "                \"CONNECT %s HTTP/1.1\\r\\n\\r\\n\" %",
            "                connect_info['internal_access_path']))",
            "            end_token = \"\\r\\n\\r\\n\"",
            "            while True:",
            "                data = tsock.recv(4096, socket.MSG_PEEK)",
            "                token_loc = data.find(end_token)",
            "                if token_loc != -1:",
            "                    if data.split(\"\\r\\n\")[0].find(\"200\") == -1:",
            "                        raise exception.InvalidConnectionInfo()",
            "                    # remove the response from recv buffer",
            "                    tsock.recv(token_loc + len(end_token))",
            "                    break",
            "",
            "        if self.server.security_proxy is not None:",
            "            tenant_sock = TenantSock(self)",
            "",
            "            try:",
            "                tsock = self.server.security_proxy.connect(tenant_sock, tsock)",
            "            except exception.SecurityProxyNegotiationFailed:",
            "                LOG.exception(\"Unable to perform security proxying, shutting \"",
            "                              \"down connection\")",
            "                tenant_sock.close()",
            "                tsock.shutdown(socket.SHUT_RDWR)",
            "                tsock.close()",
            "                raise",
            "",
            "            tenant_sock.finish_up()",
            "",
            "        # Start proxying",
            "        try:",
            "            self.do_proxy(tsock)",
            "        except Exception:",
            "            if tsock:",
            "                tsock.shutdown(socket.SHUT_RDWR)",
            "                tsock.close()",
            "                self.vmsg(_(\"%(host)s:%(port)s: \"",
            "                          \"Websocket client or target closed\") %",
            "                          {'host': host, 'port': port})",
            "            raise",
            "",
            "",
            "class NovaProxyRequestHandler(NovaProxyRequestHandlerBase,",
            "                              websockify.ProxyRequestHandler):",
            "    def __init__(self, *args, **kwargs):",
            "        self._compute_rpcapi = None",
            "        websockify.ProxyRequestHandler.__init__(self, *args, **kwargs)",
            "",
            "    @property",
            "    def compute_rpcapi(self):",
            "        # Lazy load the rpcapi/ComputeAPI upon first use for this connection.",
            "        # This way, if we receive a TCP RST, we will not create a ComputeAPI",
            "        # object we won't use.",
            "        if not self._compute_rpcapi:",
            "            self._compute_rpcapi = compute_rpcapi.ComputeAPI()",
            "        return self._compute_rpcapi",
            "",
            "    def socket(self, *args, **kwargs):",
            "        return websockify.WebSocketServer.socket(*args, **kwargs)",
            "",
            "",
            "class NovaWebSocketProxy(websockify.WebSocketProxy):",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\":param security_proxy: instance of",
            "            nova.console.securityproxy.base.SecurityProxy",
            "",
            "        Create a new web socket proxy, optionally using the",
            "        @security_proxy instance to negotiate security layer",
            "        with the compute node.",
            "        \"\"\"",
            "        self.security_proxy = kwargs.pop('security_proxy', None)",
            "        super(NovaWebSocketProxy, self).__init__(*args, **kwargs)",
            "",
            "    @staticmethod",
            "    def get_logger():",
            "        return LOG"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "'''",
            "Websocket proxy that is compatible with OpenStack Nova.",
            "Leverages websockify.py by Joel Martin",
            "'''",
            "",
            "import copy",
            "import socket",
            "import sys",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import encodeutils",
            "import six",
            "from six.moves import http_cookies as Cookie",
            "import six.moves.urllib.parse as urlparse",
            "import websockify",
            "",
            "from nova.compute import rpcapi as compute_rpcapi",
            "import nova.conf",
            "from nova.consoleauth import rpcapi as consoleauth_rpcapi",
            "from nova import context",
            "from nova import exception",
            "from nova.i18n import _",
            "from nova import objects",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class TenantSock(object):",
            "    \"\"\"A socket wrapper for communicating with the tenant.",
            "",
            "    This class provides a socket-like interface to the internal",
            "    websockify send/receive queue for the client connection to",
            "    the tenant user. It is used with the security proxy classes.",
            "    \"\"\"",
            "",
            "    def __init__(self, reqhandler):",
            "        self.reqhandler = reqhandler",
            "        self.queue = []",
            "",
            "    def recv(self, cnt):",
            "        # NB(sross): it's ok to block here because we know",
            "        #            exactly the sequence of data arriving",
            "        while len(self.queue) < cnt:",
            "            # new_frames looks like ['abc', 'def']",
            "            new_frames, closed = self.reqhandler.recv_frames()",
            "            # flatten frames onto queue",
            "            for frame in new_frames:",
            "                # The socket returns (byte) strings in Python 2...",
            "                if six.PY2:",
            "                    self.queue.extend(frame)",
            "                # ...and integers in Python 3. For the Python 3 case, we need",
            "                # to convert these to characters using 'chr' and then, as this",
            "                # returns unicode, convert the result to byte strings.",
            "                else:",
            "                    self.queue.extend(",
            "                        [six.binary_type(chr(c), 'ascii') for c in frame])",
            "",
            "            if closed:",
            "                break",
            "",
            "        popped = self.queue[0:cnt]",
            "        del self.queue[0:cnt]",
            "        return b''.join(popped)",
            "",
            "    def sendall(self, data):",
            "        self.reqhandler.send_frames([encodeutils.safe_encode(data)])",
            "",
            "    def finish_up(self):",
            "        self.reqhandler.send_frames([b''.join(self.queue)])",
            "",
            "    def close(self):",
            "        self.finish_up()",
            "        self.reqhandler.send_close()",
            "",
            "",
            "class NovaProxyRequestHandlerBase(object):",
            "    def address_string(self):",
            "        # NOTE(rpodolyaka): override the superclass implementation here and",
            "        # explicitly disable the reverse DNS lookup, which might fail on some",
            "        # deployments due to DNS configuration and break VNC access completely",
            "        return str(self.client_address[0])",
            "",
            "    def verify_origin_proto(self, connection_info, origin_proto):",
            "        access_url = connection_info.get('access_url')",
            "        if not access_url:",
            "            detail = _(\"No access_url in connection_info. \"",
            "                        \"Cannot validate protocol\")",
            "            raise exception.ValidationError(detail=detail)",
            "        expected_protos = [urlparse.urlparse(access_url).scheme]",
            "        # NOTE: For serial consoles the expected protocol could be ws or",
            "        # wss which correspond to http and https respectively in terms of",
            "        # security.",
            "        if 'ws' in expected_protos:",
            "            expected_protos.append('http')",
            "        if 'wss' in expected_protos:",
            "            expected_protos.append('https')",
            "",
            "        return origin_proto in expected_protos",
            "",
            "    def _check_console_port(self, ctxt, instance_uuid, port, console_type):",
            "",
            "        try:",
            "            instance = objects.Instance.get_by_uuid(ctxt, instance_uuid)",
            "        except exception.InstanceNotFound:",
            "            return",
            "",
            "        # NOTE(melwitt): The port is expected to be a str for validation.",
            "        return self.compute_rpcapi.validate_console_port(ctxt, instance,",
            "                                                         str(port),",
            "                                                         console_type)",
            "",
            "    def _get_connect_info_consoleauth(self, ctxt, token):",
            "        # NOTE(PaulMurray) consoleauth check_token() validates the token",
            "        # and does an rpc to compute manager to check the console port",
            "        # is correct.",
            "        rpcapi = consoleauth_rpcapi.ConsoleAuthAPI()",
            "        return rpcapi.check_token(ctxt, token=token)",
            "",
            "    def _get_connect_info_database(self, ctxt, token):",
            "        # NOTE(PaulMurray) ConsoleAuthToken.validate validates the token.",
            "        # We call the compute manager directly to check the console port",
            "        # is correct.",
            "        connect_info = objects.ConsoleAuthToken.validate(ctxt, token).to_dict()",
            "",
            "        valid_port = self._check_console_port(",
            "            ctxt, connect_info['instance_uuid'], connect_info['port'],",
            "            connect_info['console_type'])",
            "",
            "        if not valid_port:",
            "            raise exception.InvalidToken(token='***')",
            "",
            "        return connect_info",
            "",
            "    def _get_connect_info(self, ctxt, token):",
            "        \"\"\"Validate the token and get the connect info.\"\"\"",
            "        connect_info = None",
            "        # NOTE(PaulMurray) if we are using cells v1, we use the old consoleauth",
            "        # way of doing things. The database backend is not supported for cells",
            "        # v1.",
            "        if CONF.cells.enable:",
            "            connect_info = self._get_connect_info_consoleauth(ctxt, token)",
            "            if not connect_info:",
            "                raise exception.InvalidToken(token='***')",
            "        else:",
            "            # NOTE(melwitt): If consoleauth is enabled to aid in transitioning",
            "            # to the database backend, check it first before falling back to",
            "            # the database. Tokens that existed pre-database-backend will",
            "            # reside in the consoleauth service storage.",
            "            if CONF.workarounds.enable_consoleauth:",
            "                connect_info = self._get_connect_info_consoleauth(ctxt, token)",
            "            # If consoleauth is enabled to aid in transitioning to the database",
            "            # backend and we didn't find a token in the consoleauth service",
            "            # storage, check the database for a token because it's probably a",
            "            # post-database-backend token, which are stored in the database.",
            "            if not connect_info:",
            "                connect_info = self._get_connect_info_database(ctxt, token)",
            "",
            "        return connect_info",
            "",
            "    def new_websocket_client(self):",
            "        \"\"\"Called after a new WebSocket connection has been established.\"\"\"",
            "        # Reopen the eventlet hub to make sure we don't share an epoll",
            "        # fd with parent and/or siblings, which would be bad",
            "        from eventlet import hubs",
            "        hubs.use_hub()",
            "",
            "        # The nova expected behavior is to have token",
            "        # passed to the method GET of the request",
            "        parse = urlparse.urlparse(self.path)",
            "        if parse.scheme not in ('http', 'https'):",
            "            # From a bug in urlparse in Python < 2.7.4 we cannot support",
            "            # special schemes (cf: http://bugs.python.org/issue9374)",
            "            if sys.version_info < (2, 7, 4):",
            "                raise exception.NovaException(",
            "                    _(\"We do not support scheme '%s' under Python < 2.7.4, \"",
            "                      \"please use http or https\") % parse.scheme)",
            "",
            "        query = parse.query",
            "        token = urlparse.parse_qs(query).get(\"token\", [\"\"]).pop()",
            "        if not token:",
            "            # NoVNC uses it's own convention that forward token",
            "            # from the request to a cookie header, we should check",
            "            # also for this behavior",
            "            hcookie = self.headers.get('cookie')",
            "            if hcookie:",
            "                cookie = Cookie.SimpleCookie()",
            "                for hcookie_part in hcookie.split(';'):",
            "                    hcookie_part = hcookie_part.lstrip()",
            "                    try:",
            "                        cookie.load(hcookie_part)",
            "                    except Cookie.CookieError:",
            "                        # NOTE(stgleb): Do not print out cookie content",
            "                        # for security reasons.",
            "                        LOG.warning('Found malformed cookie')",
            "                    else:",
            "                        if 'token' in cookie:",
            "                            token = cookie['token'].value",
            "",
            "        ctxt = context.get_admin_context()",
            "        connect_info = self._get_connect_info(ctxt, token)",
            "",
            "        # Verify Origin",
            "        expected_origin_hostname = self.headers.get('Host')",
            "        if ':' in expected_origin_hostname:",
            "            e = expected_origin_hostname",
            "            if '[' in e and ']' in e:",
            "                expected_origin_hostname = e.split(']')[0][1:]",
            "            else:",
            "                expected_origin_hostname = e.split(':')[0]",
            "        expected_origin_hostnames = CONF.console.allowed_origins",
            "        expected_origin_hostnames.append(expected_origin_hostname)",
            "        origin_url = self.headers.get('Origin')",
            "        # missing origin header indicates non-browser client which is OK",
            "        if origin_url is not None:",
            "            origin = urlparse.urlparse(origin_url)",
            "            origin_hostname = origin.hostname",
            "            origin_scheme = origin.scheme",
            "            # If the console connection was forwarded by a proxy (example:",
            "            # haproxy), the original protocol could be contained in the",
            "            # X-Forwarded-Proto header instead of the Origin header. Prefer the",
            "            # forwarded protocol if it is present.",
            "            forwarded_proto = self.headers.get('X-Forwarded-Proto')",
            "            if forwarded_proto is not None:",
            "                origin_scheme = forwarded_proto",
            "            if origin_hostname == '' or origin_scheme == '':",
            "                detail = _(\"Origin header not valid.\")",
            "                raise exception.ValidationError(detail=detail)",
            "            if origin_hostname not in expected_origin_hostnames:",
            "                detail = _(\"Origin header does not match this host.\")",
            "                raise exception.ValidationError(detail=detail)",
            "            if not self.verify_origin_proto(connect_info, origin_scheme):",
            "                detail = _(\"Origin header protocol does not match this host.\")",
            "                raise exception.ValidationError(detail=detail)",
            "",
            "        sanitized_info = copy.copy(connect_info)",
            "        sanitized_info['token'] = '***'",
            "        self.msg(_('connect info: %s'), sanitized_info)",
            "",
            "        host = connect_info['host']",
            "        port = int(connect_info['port'])",
            "",
            "        # Connect to the target",
            "        self.msg(_(\"connecting to: %(host)s:%(port)s\") % {'host': host,",
            "                                                          'port': port})",
            "        tsock = self.socket(host, port, connect=True)",
            "",
            "        # Handshake as necessary",
            "        if connect_info.get('internal_access_path'):",
            "            tsock.send(encodeutils.safe_encode(",
            "                \"CONNECT %s HTTP/1.1\\r\\n\\r\\n\" %",
            "                connect_info['internal_access_path']))",
            "            end_token = \"\\r\\n\\r\\n\"",
            "            while True:",
            "                data = tsock.recv(4096, socket.MSG_PEEK)",
            "                token_loc = data.find(end_token)",
            "                if token_loc != -1:",
            "                    if data.split(\"\\r\\n\")[0].find(\"200\") == -1:",
            "                        raise exception.InvalidConnectionInfo()",
            "                    # remove the response from recv buffer",
            "                    tsock.recv(token_loc + len(end_token))",
            "                    break",
            "",
            "        if self.server.security_proxy is not None:",
            "            tenant_sock = TenantSock(self)",
            "",
            "            try:",
            "                tsock = self.server.security_proxy.connect(tenant_sock, tsock)",
            "            except exception.SecurityProxyNegotiationFailed:",
            "                LOG.exception(\"Unable to perform security proxying, shutting \"",
            "                              \"down connection\")",
            "                tenant_sock.close()",
            "                tsock.shutdown(socket.SHUT_RDWR)",
            "                tsock.close()",
            "                raise",
            "",
            "            tenant_sock.finish_up()",
            "",
            "        # Start proxying",
            "        try:",
            "            self.do_proxy(tsock)",
            "        except Exception:",
            "            if tsock:",
            "                tsock.shutdown(socket.SHUT_RDWR)",
            "                tsock.close()",
            "                self.vmsg(_(\"%(host)s:%(port)s: \"",
            "                          \"Websocket client or target closed\") %",
            "                          {'host': host, 'port': port})",
            "            raise",
            "",
            "",
            "class NovaProxyRequestHandler(NovaProxyRequestHandlerBase,",
            "                              websockify.ProxyRequestHandler):",
            "    def __init__(self, *args, **kwargs):",
            "        self._compute_rpcapi = None",
            "        websockify.ProxyRequestHandler.__init__(self, *args, **kwargs)",
            "",
            "    @property",
            "    def compute_rpcapi(self):",
            "        # Lazy load the rpcapi/ComputeAPI upon first use for this connection.",
            "        # This way, if we receive a TCP RST, we will not create a ComputeAPI",
            "        # object we won't use.",
            "        if not self._compute_rpcapi:",
            "            self._compute_rpcapi = compute_rpcapi.ComputeAPI()",
            "        return self._compute_rpcapi",
            "",
            "    def socket(self, *args, **kwargs):",
            "        return websockify.WebSocketServer.socket(*args, **kwargs)",
            "",
            "",
            "class NovaWebSocketProxy(websockify.WebSocketProxy):",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\":param security_proxy: instance of",
            "            nova.console.securityproxy.base.SecurityProxy",
            "",
            "        Create a new web socket proxy, optionally using the",
            "        @security_proxy instance to negotiate security layer",
            "        with the compute node.",
            "        \"\"\"",
            "        self.security_proxy = kwargs.pop('security_proxy', None)",
            "        super(NovaWebSocketProxy, self).__init__(*args, **kwargs)",
            "",
            "    @staticmethod",
            "    def get_logger():",
            "        return LOG"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "251": [
                "NovaProxyRequestHandlerBase",
                "new_websocket_client"
            ]
        },
        "addLocation": []
    },
    "nova/consoleauth/manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         self.mc_instance.set(instance_uuid.encode('UTF-8'),"
            },
            "2": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "                              jsonutils.dumps(tokens))"
            },
            "3": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        LOG.info(\"Received Token: %(token)s, %(token_dict)s\","
            },
            "5": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                 {'token': token, 'token_dict': token_dict})"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        token_dict['token'] = '***'"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        LOG.info(\"Received Token: %(token_dict)s\", {'token_dict': token_dict})"
            },
            "8": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "     def _validate_token(self, context, token):"
            },
            "10": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         instance_uuid = token['instance_uuid']"
            },
            "11": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     def check_token(self, context, token):"
            },
            "12": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         token_str = self.mc.get(token.encode('UTF-8'))"
            },
            "13": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         token_valid = (token_str is not None)"
            },
            "14": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        LOG.info(\"Checking Token: %(token)s, %(token_valid)s\","
            },
            "15": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                 {'token': token, 'token_valid': token_valid})"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        LOG.info(\"Checking that token is known: %(token_valid)s\","
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+                 {'token_valid': token_valid})"
            },
            "18": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         if token_valid:"
            },
            "19": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             token = jsonutils.loads(token_str)"
            },
            "20": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "             if self._validate_token(context, token):"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# Copyright (c) 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#    you may not use this file except in compliance with the License.",
            "#    You may obtain a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#    See the License for the specific language governing permissions and",
            "#    limitations under the License.",
            "",
            "\"\"\"Auth Components for Consoles.\"\"\"",
            "",
            "import time",
            "",
            "from oslo_log import log as logging",
            "import oslo_messaging as messaging",
            "from oslo_serialization import jsonutils",
            "",
            "from nova import cache_utils",
            "from nova.cells import rpcapi as cells_rpcapi",
            "from nova.compute import rpcapi as compute_rpcapi",
            "import nova.conf",
            "from nova import context as nova_context",
            "from nova import manager",
            "from nova import objects",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class ConsoleAuthManager(manager.Manager):",
            "    \"\"\"Manages token based authentication.\"\"\"",
            "",
            "    target = messaging.Target(version='2.1')",
            "",
            "    def __init__(self, scheduler_driver=None, *args, **kwargs):",
            "        super(ConsoleAuthManager, self).__init__(service_name='consoleauth',",
            "                                                 *args, **kwargs)",
            "        self._mc = None",
            "        self._mc_instance = None",
            "        self.compute_rpcapi = compute_rpcapi.ComputeAPI()",
            "        self.cells_rpcapi = cells_rpcapi.CellsAPI()",
            "",
            "    @property",
            "    def mc(self):",
            "        if self._mc is None:",
            "            self._mc = cache_utils.get_client(CONF.consoleauth.token_ttl)",
            "        return self._mc",
            "",
            "    @property",
            "    def mc_instance(self):",
            "        if self._mc_instance is None:",
            "            self._mc_instance = cache_utils.get_client()",
            "        return self._mc_instance",
            "",
            "    def reset(self):",
            "        LOG.info('Reloading compute RPC API')",
            "        compute_rpcapi.LAST_VERSION = None",
            "        self.compute_rpcapi = compute_rpcapi.ComputeAPI()",
            "",
            "    def _get_tokens_for_instance(self, instance_uuid):",
            "        tokens_str = self.mc_instance.get(instance_uuid.encode('UTF-8'))",
            "        if not tokens_str:",
            "            tokens = []",
            "        else:",
            "            tokens = jsonutils.loads(tokens_str)",
            "        return tokens",
            "",
            "    def authorize_console(self, context, token, console_type, host, port,",
            "                          internal_access_path, instance_uuid,",
            "                          access_url=None):",
            "",
            "        token_dict = {'token': token,",
            "                      'instance_uuid': instance_uuid,",
            "                      'console_type': console_type,",
            "                      'host': host,",
            "                      'port': port,",
            "                      'internal_access_path': internal_access_path,",
            "                      'access_url': access_url,",
            "                      'last_activity_at': time.time()}",
            "        data = jsonutils.dumps(token_dict)",
            "",
            "        self.mc.set(token.encode('UTF-8'), data)",
            "        tokens = self._get_tokens_for_instance(instance_uuid)",
            "",
            "        # Remove the expired tokens from cache.",
            "        token_values = self.mc.get_multi(",
            "            [tok.encode('UTF-8') for tok in tokens])",
            "        tokens = [name for name, value in zip(tokens, token_values)",
            "                  if value is not None]",
            "        tokens.append(token)",
            "",
            "        self.mc_instance.set(instance_uuid.encode('UTF-8'),",
            "                             jsonutils.dumps(tokens))",
            "",
            "        LOG.info(\"Received Token: %(token)s, %(token_dict)s\",",
            "                 {'token': token, 'token_dict': token_dict})",
            "",
            "    def _validate_token(self, context, token):",
            "        instance_uuid = token['instance_uuid']",
            "        if instance_uuid is None:",
            "            return False",
            "",
            "        # NOTE(comstud): consoleauth was meant to run in API cells.  So,",
            "        # if cells is enabled, we must call down to the child cell for",
            "        # the instance.",
            "        if CONF.cells.enable:",
            "            return self.cells_rpcapi.validate_console_port(context,",
            "                    instance_uuid, token['port'], token['console_type'])",
            "",
            "        mapping = objects.InstanceMapping.get_by_instance_uuid(context,",
            "                                                               instance_uuid)",
            "        with nova_context.target_cell(context, mapping.cell_mapping) as cctxt:",
            "            instance = objects.Instance.get_by_uuid(cctxt, instance_uuid)",
            "",
            "            return self.compute_rpcapi.validate_console_port(",
            "                cctxt,",
            "                instance,",
            "                token['port'],",
            "                token['console_type'])",
            "",
            "    def check_token(self, context, token):",
            "        token_str = self.mc.get(token.encode('UTF-8'))",
            "        token_valid = (token_str is not None)",
            "        LOG.info(\"Checking Token: %(token)s, %(token_valid)s\",",
            "                 {'token': token, 'token_valid': token_valid})",
            "        if token_valid:",
            "            token = jsonutils.loads(token_str)",
            "            if self._validate_token(context, token):",
            "                return token",
            "",
            "    def delete_tokens_for_instance(self, context, instance_uuid):",
            "        tokens = self._get_tokens_for_instance(instance_uuid)",
            "        if tokens:",
            "            self.mc.delete_multi(",
            "                [tok.encode('UTF-8') for tok in tokens])",
            "        self.mc_instance.delete(instance_uuid.encode('UTF-8'))"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# Copyright (c) 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#    you may not use this file except in compliance with the License.",
            "#    You may obtain a copy of the License at",
            "#",
            "#        http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#    See the License for the specific language governing permissions and",
            "#    limitations under the License.",
            "",
            "\"\"\"Auth Components for Consoles.\"\"\"",
            "",
            "import time",
            "",
            "from oslo_log import log as logging",
            "import oslo_messaging as messaging",
            "from oslo_serialization import jsonutils",
            "",
            "from nova import cache_utils",
            "from nova.cells import rpcapi as cells_rpcapi",
            "from nova.compute import rpcapi as compute_rpcapi",
            "import nova.conf",
            "from nova import context as nova_context",
            "from nova import manager",
            "from nova import objects",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class ConsoleAuthManager(manager.Manager):",
            "    \"\"\"Manages token based authentication.\"\"\"",
            "",
            "    target = messaging.Target(version='2.1')",
            "",
            "    def __init__(self, scheduler_driver=None, *args, **kwargs):",
            "        super(ConsoleAuthManager, self).__init__(service_name='consoleauth',",
            "                                                 *args, **kwargs)",
            "        self._mc = None",
            "        self._mc_instance = None",
            "        self.compute_rpcapi = compute_rpcapi.ComputeAPI()",
            "        self.cells_rpcapi = cells_rpcapi.CellsAPI()",
            "",
            "    @property",
            "    def mc(self):",
            "        if self._mc is None:",
            "            self._mc = cache_utils.get_client(CONF.consoleauth.token_ttl)",
            "        return self._mc",
            "",
            "    @property",
            "    def mc_instance(self):",
            "        if self._mc_instance is None:",
            "            self._mc_instance = cache_utils.get_client()",
            "        return self._mc_instance",
            "",
            "    def reset(self):",
            "        LOG.info('Reloading compute RPC API')",
            "        compute_rpcapi.LAST_VERSION = None",
            "        self.compute_rpcapi = compute_rpcapi.ComputeAPI()",
            "",
            "    def _get_tokens_for_instance(self, instance_uuid):",
            "        tokens_str = self.mc_instance.get(instance_uuid.encode('UTF-8'))",
            "        if not tokens_str:",
            "            tokens = []",
            "        else:",
            "            tokens = jsonutils.loads(tokens_str)",
            "        return tokens",
            "",
            "    def authorize_console(self, context, token, console_type, host, port,",
            "                          internal_access_path, instance_uuid,",
            "                          access_url=None):",
            "",
            "        token_dict = {'token': token,",
            "                      'instance_uuid': instance_uuid,",
            "                      'console_type': console_type,",
            "                      'host': host,",
            "                      'port': port,",
            "                      'internal_access_path': internal_access_path,",
            "                      'access_url': access_url,",
            "                      'last_activity_at': time.time()}",
            "        data = jsonutils.dumps(token_dict)",
            "",
            "        self.mc.set(token.encode('UTF-8'), data)",
            "        tokens = self._get_tokens_for_instance(instance_uuid)",
            "",
            "        # Remove the expired tokens from cache.",
            "        token_values = self.mc.get_multi(",
            "            [tok.encode('UTF-8') for tok in tokens])",
            "        tokens = [name for name, value in zip(tokens, token_values)",
            "                  if value is not None]",
            "        tokens.append(token)",
            "",
            "        self.mc_instance.set(instance_uuid.encode('UTF-8'),",
            "                             jsonutils.dumps(tokens))",
            "        token_dict['token'] = '***'",
            "        LOG.info(\"Received Token: %(token_dict)s\", {'token_dict': token_dict})",
            "",
            "    def _validate_token(self, context, token):",
            "        instance_uuid = token['instance_uuid']",
            "        if instance_uuid is None:",
            "            return False",
            "",
            "        # NOTE(comstud): consoleauth was meant to run in API cells.  So,",
            "        # if cells is enabled, we must call down to the child cell for",
            "        # the instance.",
            "        if CONF.cells.enable:",
            "            return self.cells_rpcapi.validate_console_port(context,",
            "                    instance_uuid, token['port'], token['console_type'])",
            "",
            "        mapping = objects.InstanceMapping.get_by_instance_uuid(context,",
            "                                                               instance_uuid)",
            "        with nova_context.target_cell(context, mapping.cell_mapping) as cctxt:",
            "            instance = objects.Instance.get_by_uuid(cctxt, instance_uuid)",
            "",
            "            return self.compute_rpcapi.validate_console_port(",
            "                cctxt,",
            "                instance,",
            "                token['port'],",
            "                token['console_type'])",
            "",
            "    def check_token(self, context, token):",
            "        token_str = self.mc.get(token.encode('UTF-8'))",
            "        token_valid = (token_str is not None)",
            "        LOG.info(\"Checking that token is known: %(token_valid)s\",",
            "                 {'token_valid': token_valid})",
            "        if token_valid:",
            "            token = jsonutils.loads(token_str)",
            "            if self._validate_token(context, token):",
            "                return token",
            "",
            "    def delete_tokens_for_instance(self, context, instance_uuid):",
            "        tokens = self._get_tokens_for_instance(instance_uuid)",
            "        if tokens:",
            "            self.mc.delete_multi(",
            "                [tok.encode('UTF-8') for tok in tokens])",
            "        self.mc_instance.delete(instance_uuid.encode('UTF-8'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "103": [
                "ConsoleAuthManager",
                "authorize_console"
            ],
            "104": [
                "ConsoleAuthManager",
                "authorize_console"
            ],
            "105": [
                "ConsoleAuthManager",
                "authorize_console"
            ],
            "133": [
                "ConsoleAuthManager",
                "check_token"
            ],
            "134": [
                "ConsoleAuthManager",
                "check_token"
            ]
        },
        "addLocation": []
    },
    "nova/tests/unit/console/test_websocketproxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         validate.assert_called_with(mock.ANY, \"123-456-789\")"
            },
            "1": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "         self.wh.socket.assert_called_with('node1', 10000, connect=True)"
            },
            "2": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         self.wh.do_proxy.assert_called_with('<socket>')"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+        # ensure that token is masked when logged"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        connection_info = self.wh.msg.mock_calls[0][1][1]"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+        self.assertEqual('***', connection_info['token'])"
            },
            "6": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 301,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "     @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'"
            },
            "8": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "                 '_check_console_port')"
            }
        },
        "frontPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Tests for nova websocketproxy.\"\"\"",
            "",
            "import copy",
            "import socket",
            "",
            "import mock",
            "",
            "import nova.conf",
            "from nova.console.securityproxy import base",
            "from nova.console import websocketproxy",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova import objects",
            "from nova import test",
            "from nova.tests.unit import fake_console_auth_token as fake_ca",
            "from nova.tests import uuidsentinel as uuids",
            "from nova import utils",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class NovaProxyRequestHandlerDBTestCase(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaProxyRequestHandlerDBTestCase, self).setUp()",
            "",
            "        self.flags(console_allowed_origins=['allowed-origin-example-1.net',",
            "                                            'allowed-origin-example-2.net'])",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = websocketproxy.NovaWebSocketProxy()",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "    def _fake_console_db(self, **updates):",
            "        console_db = copy.deepcopy(fake_ca.fake_token_dict)",
            "        console_db['token_hash'] = utils.get_sha256_str('123-456-789')",
            "        if updates:",
            "            console_db.update(updates)",
            "        return console_db",
            "",
            "    fake_header = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token')",
            "    def test_new_websocket_client_db(",
            "            self, mock_ca_check, mock_validate_port, mock_inst_get,",
            "            mock_validate, internal_access_path=None,",
            "            instance_not_found=False):",
            "",
            "        db_obj = self._fake_console_db(",
            "            host='node1',",
            "            port=10000,",
            "            console_type='novnc',",
            "            access_url_base='https://example.net:6080',",
            "            internal_access_path=internal_access_path,",
            "            instance_uuid=uuids.instance,",
            "            # This is set by ConsoleAuthToken.validate",
            "            token='123-456-789'",
            "        )",
            "        ctxt = nova_context.get_context()",
            "        obj = nova.objects.ConsoleAuthToken._from_db_object(",
            "            ctxt, nova.objects.ConsoleAuthToken(), db_obj)",
            "        mock_validate.return_value = obj",
            "",
            "        if instance_not_found:",
            "            mock_inst_get.side_effect = exception.InstanceNotFound(",
            "                instance_id=uuids.instance)",
            "",
            "        if internal_access_path is None:",
            "            self.wh.socket.return_value = '<socket>'",
            "        else:",
            "            tsock = mock.MagicMock()",
            "            tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "            self.wh.socket.return_value = tsock",
            "",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        if instance_not_found:",
            "            self.assertRaises(exception.InvalidToken,",
            "                              self.wh.new_websocket_client)",
            "        else:",
            "            with mock.patch('nova.context.get_admin_context',",
            "                            return_value=ctxt):",
            "                self.wh.new_websocket_client()",
            "",
            "            mock_validate.assert_called_once_with(ctxt, '123-456-789')",
            "            mock_validate_port.assert_called_once_with(",
            "                ctxt, mock_inst_get.return_value, str(db_obj['port']),",
            "                db_obj['console_type'])",
            "            mock_ca_check.assert_not_called()",
            "",
            "            self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "",
            "            if internal_access_path is None:",
            "                self.wh.do_proxy.assert_called_with('<socket>')",
            "            else:",
            "                self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    def test_new_websocket_client_db_internal_access_path(self):",
            "        self.test_new_websocket_client_db(internal_access_path='vmid')",
            "",
            "    def test_new_websocket_client_db_instance_not_found(self):",
            "        self.test_new_websocket_client_db(instance_not_found=True)",
            "",
            "",
            "class NovaProxyRequestHandlerBaseTestCase(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaProxyRequestHandlerBaseTestCase, self).setUp()",
            "",
            "        self.flags(allowed_origins=['allowed-origin-example-1.net',",
            "                                    'allowed-origin-example-2.net'],",
            "                   group='console')",
            "        self.server = websocketproxy.NovaWebSocketProxy()",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = self.server",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "    fake_header = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_ipv6 = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://[2001:db8::1]:6080',",
            "        'Host': '[2001:db8::1]:6080',",
            "    }",
            "",
            "    fake_header_bad_token = {",
            "        'cookie': 'token=\"XXX\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_bad_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://bad-origin-example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_allowed_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://allowed-origin-example-2.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_blank_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': '',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_no_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_http = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'http://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_malformed_cookie = {",
            "        'cookie': '?=!; token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token')",
            "    def test_new_websocket_client_with_server_with_cells(self, check_token):",
            "        # this test cells enabled, so consoleauth should be used",
            "        CONF.set_override('enable', True, group='cells')",
            "        check_token.return_value = {",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url': 'https://example.net:6080'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        check_token.assert_called_with(mock.ANY, token=\"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token')",
            "    def test_new_websocket_client_enable_consoleauth(self, check_token):",
            "        self.flags(enable_consoleauth=True, group='workarounds')",
            "",
            "        check_token.return_value = {",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url': 'https://example.net:6080'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        check_token.assert_called_with(mock.ANY, token=\"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token',",
            "                return_value=None)",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_enable_consoleauth_fallback(self, validate,",
            "                                                              check_port,",
            "                                                              check_token):",
            "        # Since consoleauth is enabled, it should be called first before",
            "        # falling back to the database.",
            "        self.flags(enable_consoleauth=True, group='workarounds')",
            "",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        check_token.assert_called_with(mock.ANY, token=\"123-456-789\")",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_ipv6_url(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://[2001:db8::1]:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://[2001:db8::1]/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header_ipv6",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_token_invalid(self, validate):",
            "        validate.side_effect = exception.InvalidToken(token='XXX')",
            "",
            "        self.wh.path = \"http://127.0.0.1/?token=XXX\"",
            "        self.wh.headers = self.fake_header_bad_token",
            "",
            "        self.assertRaises(exception.InvalidToken,",
            "                          self.wh.new_websocket_client)",
            "        validate.assert_called_with(mock.ANY, \"XXX\")",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path(self, validate,",
            "                                                       check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'vmid',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        tsock.send.assert_called_with(test.MatchType(bytes))",
            "        self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path_err(self, validate,",
            "                                                           check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'xxx',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        tsock.recv.return_value = \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\"",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.InvalidConnectionInfo,",
            "                          self.wh.new_websocket_client)",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path_rfb(self, validate,",
            "                                                           check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'vmid',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        HTTP_RESP = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "        RFB_MSG = \"RFB 003.003\\n\"",
            "        # RFB negotiation message may arrive earlier.",
            "        tsock.recv.side_effect = [HTTP_RESP + RFB_MSG,",
            "                                  HTTP_RESP]",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        tsock.recv.assert_has_calls([mock.call(4096, socket.MSG_PEEK),",
            "                                     mock.call(len(HTTP_RESP))])",
            "        self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    @mock.patch.object(websocketproxy, 'sys')",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_py273_good_scheme(",
            "            self, validate, check_port, mock_sys):",
            "        mock_sys.version_info.return_value = (2, 7, 3)",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch.object(websocketproxy, 'sys')",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token')",
            "    def test_new_websocket_client_py273_special_scheme(",
            "            self, check_token, mock_sys):",
            "        mock_sys.version_info = (2, 7, 3)",
            "        check_token.return_value = {",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"ws://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('socket.getfqdn')",
            "    def test_address_string_doesnt_do_reverse_dns_lookup(self, getfqdn):",
            "        request_mock = mock.MagicMock()",
            "        request_mock.makefile().readline.side_effect = [",
            "            b'GET /vnc.html?token=123-456-789 HTTP/1.1\\r\\n',",
            "            b''",
            "        ]",
            "        server_mock = mock.MagicMock()",
            "        client_address = ('8.8.8.8', 54321)",
            "",
            "        handler = websocketproxy.NovaProxyRequestHandler(",
            "            request_mock, client_address, server_mock)",
            "        handler.log_message('log message using client address context info')",
            "",
            "        self.assertFalse(getfqdn.called)  # no reverse dns look up",
            "        self.assertEqual(handler.address_string(), '8.8.8.8')  # plain address",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_bad_origin_header(self, validate,",
            "                                                          check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_bad_origin",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_allowed_origin_header(self, validate,",
            "                                                              check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_allowed_origin",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_blank_origin_header(self, validate,",
            "                                                            check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_blank_origin",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_no_origin_header(self, validate,",
            "                                                         check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_no_origin",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_https_origin_proto_http(",
            "            self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'http://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_https_origin_proto_ws(self, validate,",
            "                                                              check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'serial',",
            "            'access_url_base': 'ws://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_http_forwarded_proto_https(self, validate,",
            "                                                             check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'serial',",
            "            'access_url_base': 'wss://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        header = {",
            "            'cookie': 'token=\"123-456-789\"',",
            "            'Origin': 'http://example.net:6080',",
            "            'Host': 'example.net:6080',",
            "            'X-Forwarded-Proto': 'https'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_bad_console_type(self, validate,",
            "                                                         check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'bad-console-type'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_malformed_cookie(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_malformed_cookie",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    def test_tcp_rst_no_compute_rpcapi(self):",
            "        # Tests that we don't create a ComputeAPI object if we receive a",
            "        # TCP RST message. Simulate by raising the socket.err upon recv.",
            "        err = socket.error('[Errno 104] Connection reset by peer')",
            "        self.wh.socket.recv.side_effect = err",
            "        conn = mock.MagicMock()",
            "        address = mock.MagicMock()",
            "        self.wh.server.top_new_client(conn, address)",
            "        self.assertIsNone(self.wh._compute_rpcapi)",
            "",
            "",
            "class NovaWebsocketSecurityProxyTestCase(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaWebsocketSecurityProxyTestCase, self).setUp()",
            "",
            "        self.flags(allowed_origins=['allowed-origin-example-1.net',",
            "                                    'allowed-origin-example-2.net'],",
            "                   group='console')",
            "",
            "        self.server = websocketproxy.NovaWebSocketProxy(",
            "            security_proxy=mock.MagicMock(",
            "                spec=base.SecurityProxy)",
            "        )",
            "",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = self.server",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "        def get_header(header):",
            "            if header == 'cookie':",
            "                return 'token=\"123-456-789\"'",
            "            elif header == 'Origin':",
            "                return 'https://example.net:6080'",
            "            elif header == 'Host':",
            "                return 'example.net:6080'",
            "            else:",
            "                return",
            "",
            "        self.wh.headers.get = get_header",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.close')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')",
            "    def test_proxy_connect_ok(self, mock_finish, mock_close,",
            "                              mock_port_validate, mock_get,",
            "                              mock_token_validate):",
            "        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(",
            "            instance_uuid=uuids.instance, host='node1', port='10000',",
            "            console_type='novnc', access_url_base='https://example.net:6080')",
            "        # The token and id attributes are set by the validate() method.",
            "        mock_token_validate.return_value.token = '123-456-789'",
            "        mock_token_validate.return_value.id = 1",
            "",
            "        sock = mock.MagicMock(",
            "            spec=websocketproxy.TenantSock)",
            "        self.server.security_proxy.connect.return_value = sock",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        self.wh.do_proxy.assert_called_with(sock)",
            "        mock_finish.assert_called_with()",
            "        self.assertEqual(len(mock_close.calls), 0)",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.close')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')",
            "    def test_proxy_connect_err(self, mock_finish, mock_close,",
            "                               mock_port_validate, mock_get,",
            "                               mock_token_validate):",
            "        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(",
            "            instance_uuid=uuids.instance, host='node1', port='10000',",
            "            console_type='novnc', access_url_base='https://example.net:6080')",
            "        # The token attribute is set by the validate() method.",
            "        mock_token_validate.return_value.token = '123-456-789'",
            "        mock_token_validate.return_value.id = 1",
            "",
            "        ex = exception.SecurityProxyNegotiationFailed(\"Wibble\")",
            "        self.server.security_proxy.connect.side_effect = ex",
            "",
            "        self.assertRaises(exception.SecurityProxyNegotiationFailed,",
            "                          self.wh.new_websocket_client)",
            "",
            "        self.assertEqual(len(self.wh.do_proxy.calls), 0)",
            "        mock_close.assert_called_with()",
            "        self.assertEqual(len(mock_finish.calls), 0)"
        ],
        "afterPatchFile": [
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Tests for nova websocketproxy.\"\"\"",
            "",
            "import copy",
            "import socket",
            "",
            "import mock",
            "",
            "import nova.conf",
            "from nova.console.securityproxy import base",
            "from nova.console import websocketproxy",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova import objects",
            "from nova import test",
            "from nova.tests.unit import fake_console_auth_token as fake_ca",
            "from nova.tests import uuidsentinel as uuids",
            "from nova import utils",
            "",
            "CONF = nova.conf.CONF",
            "",
            "",
            "class NovaProxyRequestHandlerDBTestCase(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaProxyRequestHandlerDBTestCase, self).setUp()",
            "",
            "        self.flags(console_allowed_origins=['allowed-origin-example-1.net',",
            "                                            'allowed-origin-example-2.net'])",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = websocketproxy.NovaWebSocketProxy()",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "    def _fake_console_db(self, **updates):",
            "        console_db = copy.deepcopy(fake_ca.fake_token_dict)",
            "        console_db['token_hash'] = utils.get_sha256_str('123-456-789')",
            "        if updates:",
            "            console_db.update(updates)",
            "        return console_db",
            "",
            "    fake_header = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token')",
            "    def test_new_websocket_client_db(",
            "            self, mock_ca_check, mock_validate_port, mock_inst_get,",
            "            mock_validate, internal_access_path=None,",
            "            instance_not_found=False):",
            "",
            "        db_obj = self._fake_console_db(",
            "            host='node1',",
            "            port=10000,",
            "            console_type='novnc',",
            "            access_url_base='https://example.net:6080',",
            "            internal_access_path=internal_access_path,",
            "            instance_uuid=uuids.instance,",
            "            # This is set by ConsoleAuthToken.validate",
            "            token='123-456-789'",
            "        )",
            "        ctxt = nova_context.get_context()",
            "        obj = nova.objects.ConsoleAuthToken._from_db_object(",
            "            ctxt, nova.objects.ConsoleAuthToken(), db_obj)",
            "        mock_validate.return_value = obj",
            "",
            "        if instance_not_found:",
            "            mock_inst_get.side_effect = exception.InstanceNotFound(",
            "                instance_id=uuids.instance)",
            "",
            "        if internal_access_path is None:",
            "            self.wh.socket.return_value = '<socket>'",
            "        else:",
            "            tsock = mock.MagicMock()",
            "            tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "            self.wh.socket.return_value = tsock",
            "",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        if instance_not_found:",
            "            self.assertRaises(exception.InvalidToken,",
            "                              self.wh.new_websocket_client)",
            "        else:",
            "            with mock.patch('nova.context.get_admin_context',",
            "                            return_value=ctxt):",
            "                self.wh.new_websocket_client()",
            "",
            "            mock_validate.assert_called_once_with(ctxt, '123-456-789')",
            "            mock_validate_port.assert_called_once_with(",
            "                ctxt, mock_inst_get.return_value, str(db_obj['port']),",
            "                db_obj['console_type'])",
            "            mock_ca_check.assert_not_called()",
            "",
            "            self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "",
            "            if internal_access_path is None:",
            "                self.wh.do_proxy.assert_called_with('<socket>')",
            "            else:",
            "                self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    def test_new_websocket_client_db_internal_access_path(self):",
            "        self.test_new_websocket_client_db(internal_access_path='vmid')",
            "",
            "    def test_new_websocket_client_db_instance_not_found(self):",
            "        self.test_new_websocket_client_db(instance_not_found=True)",
            "",
            "",
            "class NovaProxyRequestHandlerBaseTestCase(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaProxyRequestHandlerBaseTestCase, self).setUp()",
            "",
            "        self.flags(allowed_origins=['allowed-origin-example-1.net',",
            "                                    'allowed-origin-example-2.net'],",
            "                   group='console')",
            "        self.server = websocketproxy.NovaWebSocketProxy()",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = self.server",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "    fake_header = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_ipv6 = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://[2001:db8::1]:6080',",
            "        'Host': '[2001:db8::1]:6080',",
            "    }",
            "",
            "    fake_header_bad_token = {",
            "        'cookie': 'token=\"XXX\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_bad_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://bad-origin-example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_allowed_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'https://allowed-origin-example-2.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_blank_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': '',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_no_origin = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_http = {",
            "        'cookie': 'token=\"123-456-789\"',",
            "        'Origin': 'http://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    fake_header_malformed_cookie = {",
            "        'cookie': '?=!; token=\"123-456-789\"',",
            "        'Origin': 'https://example.net:6080',",
            "        'Host': 'example.net:6080',",
            "    }",
            "",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token')",
            "    def test_new_websocket_client_with_server_with_cells(self, check_token):",
            "        # this test cells enabled, so consoleauth should be used",
            "        CONF.set_override('enable', True, group='cells')",
            "        check_token.return_value = {",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url': 'https://example.net:6080'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        check_token.assert_called_with(mock.ANY, token=\"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token')",
            "    def test_new_websocket_client_enable_consoleauth(self, check_token):",
            "        self.flags(enable_consoleauth=True, group='workarounds')",
            "",
            "        check_token.return_value = {",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url': 'https://example.net:6080'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        check_token.assert_called_with(mock.ANY, token=\"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token',",
            "                return_value=None)",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_enable_consoleauth_fallback(self, validate,",
            "                                                              check_port,",
            "                                                              check_token):",
            "        # Since consoleauth is enabled, it should be called first before",
            "        # falling back to the database.",
            "        self.flags(enable_consoleauth=True, group='workarounds')",
            "",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        check_token.assert_called_with(mock.ANY, token=\"123-456-789\")",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "        # ensure that token is masked when logged",
            "        connection_info = self.wh.msg.mock_calls[0][1][1]",
            "        self.assertEqual('***', connection_info['token'])",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_ipv6_url(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://[2001:db8::1]:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://[2001:db8::1]/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header_ipv6",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_token_invalid(self, validate):",
            "        validate.side_effect = exception.InvalidToken(token='XXX')",
            "",
            "        self.wh.path = \"http://127.0.0.1/?token=XXX\"",
            "        self.wh.headers = self.fake_header_bad_token",
            "",
            "        self.assertRaises(exception.InvalidToken,",
            "                          self.wh.new_websocket_client)",
            "        validate.assert_called_with(mock.ANY, \"XXX\")",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path(self, validate,",
            "                                                       check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'vmid',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        tsock.recv.return_value = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        tsock.send.assert_called_with(test.MatchType(bytes))",
            "        self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path_err(self, validate,",
            "                                                           check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'xxx',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        tsock.recv.return_value = \"HTTP/1.1 500 Internal Server Error\\r\\n\\r\\n\"",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.InvalidConnectionInfo,",
            "                          self.wh.new_websocket_client)",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_internal_access_path_rfb(self, validate,",
            "                                                           check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'internal_access_path': 'vmid',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        tsock = mock.MagicMock()",
            "        HTTP_RESP = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"",
            "        RFB_MSG = \"RFB 003.003\\n\"",
            "        # RFB negotiation message may arrive earlier.",
            "        tsock.recv.side_effect = [HTTP_RESP + RFB_MSG,",
            "                                  HTTP_RESP]",
            "",
            "        self.wh.socket.return_value = tsock",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        tsock.recv.assert_has_calls([mock.call(4096, socket.MSG_PEEK),",
            "                                     mock.call(len(HTTP_RESP))])",
            "        self.wh.do_proxy.assert_called_with(tsock)",
            "",
            "    @mock.patch.object(websocketproxy, 'sys')",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_py273_good_scheme(",
            "            self, validate, check_port, mock_sys):",
            "        mock_sys.version_info.return_value = (2, 7, 3)",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch.object(websocketproxy, 'sys')",
            "    @mock.patch('nova.consoleauth.rpcapi.ConsoleAuthAPI.check_token')",
            "    def test_new_websocket_client_py273_special_scheme(",
            "            self, check_token, mock_sys):",
            "        mock_sys.version_info = (2, 7, 3)",
            "        check_token.return_value = {",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"ws://127.0.0.1/?token=123-456-789\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('socket.getfqdn')",
            "    def test_address_string_doesnt_do_reverse_dns_lookup(self, getfqdn):",
            "        request_mock = mock.MagicMock()",
            "        request_mock.makefile().readline.side_effect = [",
            "            b'GET /vnc.html?token=123-456-789 HTTP/1.1\\r\\n',",
            "            b''",
            "        ]",
            "        server_mock = mock.MagicMock()",
            "        client_address = ('8.8.8.8', 54321)",
            "",
            "        handler = websocketproxy.NovaProxyRequestHandler(",
            "            request_mock, client_address, server_mock)",
            "        handler.log_message('log message using client address context info')",
            "",
            "        self.assertFalse(getfqdn.called)  # no reverse dns look up",
            "        self.assertEqual(handler.address_string(), '8.8.8.8')  # plain address",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_bad_origin_header(self, validate,",
            "                                                          check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_bad_origin",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_allowed_origin_header(self, validate,",
            "                                                              check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_allowed_origin",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_blank_origin_header(self, validate,",
            "                                                            check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_blank_origin",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_no_origin_header(self, validate,",
            "                                                         check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_no_origin",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_https_origin_proto_http(",
            "            self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'http://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_https_origin_proto_ws(self, validate,",
            "                                                              check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'serial',",
            "            'access_url_base': 'ws://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_http_forwarded_proto_https(self, validate,",
            "                                                             check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'serial',",
            "            'access_url_base': 'wss://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        header = {",
            "            'cookie': 'token=\"123-456-789\"',",
            "            'Origin': 'http://example.net:6080',",
            "            'Host': 'example.net:6080',",
            "            'X-Forwarded-Proto': 'https'",
            "        }",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"https://127.0.0.1/\"",
            "        self.wh.headers = header",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_new_websocket_client_novnc_bad_console_type(self, validate,",
            "                                                         check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'bad-console-type'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header",
            "",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.wh.new_websocket_client)",
            "",
            "    @mock.patch('nova.console.websocketproxy.NovaProxyRequestHandlerBase.'",
            "                '_check_console_port')",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    def test_malformed_cookie(self, validate, check_port):",
            "        params = {",
            "            'id': 1,",
            "            'token': '123-456-789',",
            "            'instance_uuid': uuids.instance,",
            "            'host': 'node1',",
            "            'port': '10000',",
            "            'console_type': 'novnc',",
            "            'access_url_base': 'https://example.net:6080'",
            "        }",
            "        validate.return_value = objects.ConsoleAuthToken(**params)",
            "",
            "        self.wh.socket.return_value = '<socket>'",
            "        self.wh.path = \"http://127.0.0.1/\"",
            "        self.wh.headers = self.fake_header_malformed_cookie",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        validate.assert_called_with(mock.ANY, \"123-456-789\")",
            "        self.wh.socket.assert_called_with('node1', 10000, connect=True)",
            "        self.wh.do_proxy.assert_called_with('<socket>')",
            "",
            "    def test_tcp_rst_no_compute_rpcapi(self):",
            "        # Tests that we don't create a ComputeAPI object if we receive a",
            "        # TCP RST message. Simulate by raising the socket.err upon recv.",
            "        err = socket.error('[Errno 104] Connection reset by peer')",
            "        self.wh.socket.recv.side_effect = err",
            "        conn = mock.MagicMock()",
            "        address = mock.MagicMock()",
            "        self.wh.server.top_new_client(conn, address)",
            "        self.assertIsNone(self.wh._compute_rpcapi)",
            "",
            "",
            "class NovaWebsocketSecurityProxyTestCase(test.NoDBTestCase):",
            "",
            "    def setUp(self):",
            "        super(NovaWebsocketSecurityProxyTestCase, self).setUp()",
            "",
            "        self.flags(allowed_origins=['allowed-origin-example-1.net',",
            "                                    'allowed-origin-example-2.net'],",
            "                   group='console')",
            "",
            "        self.server = websocketproxy.NovaWebSocketProxy(",
            "            security_proxy=mock.MagicMock(",
            "                spec=base.SecurityProxy)",
            "        )",
            "",
            "        with mock.patch('websockify.ProxyRequestHandler'):",
            "            self.wh = websocketproxy.NovaProxyRequestHandler()",
            "        self.wh.server = self.server",
            "        self.wh.path = \"http://127.0.0.1/?token=123-456-789\"",
            "        self.wh.socket = mock.MagicMock()",
            "        self.wh.msg = mock.MagicMock()",
            "        self.wh.do_proxy = mock.MagicMock()",
            "        self.wh.headers = mock.MagicMock()",
            "",
            "        def get_header(header):",
            "            if header == 'cookie':",
            "                return 'token=\"123-456-789\"'",
            "            elif header == 'Origin':",
            "                return 'https://example.net:6080'",
            "            elif header == 'Host':",
            "                return 'example.net:6080'",
            "            else:",
            "                return",
            "",
            "        self.wh.headers.get = get_header",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.close')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')",
            "    def test_proxy_connect_ok(self, mock_finish, mock_close,",
            "                              mock_port_validate, mock_get,",
            "                              mock_token_validate):",
            "        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(",
            "            instance_uuid=uuids.instance, host='node1', port='10000',",
            "            console_type='novnc', access_url_base='https://example.net:6080')",
            "        # The token and id attributes are set by the validate() method.",
            "        mock_token_validate.return_value.token = '123-456-789'",
            "        mock_token_validate.return_value.id = 1",
            "",
            "        sock = mock.MagicMock(",
            "            spec=websocketproxy.TenantSock)",
            "        self.server.security_proxy.connect.return_value = sock",
            "",
            "        self.wh.new_websocket_client()",
            "",
            "        self.wh.do_proxy.assert_called_with(sock)",
            "        mock_finish.assert_called_with()",
            "        self.assertEqual(len(mock_close.calls), 0)",
            "",
            "    @mock.patch('nova.objects.ConsoleAuthToken.validate')",
            "    @mock.patch('nova.objects.Instance.get_by_uuid')",
            "    @mock.patch('nova.compute.rpcapi.ComputeAPI.validate_console_port')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.close')",
            "    @mock.patch('nova.console.websocketproxy.TenantSock.finish_up')",
            "    def test_proxy_connect_err(self, mock_finish, mock_close,",
            "                               mock_port_validate, mock_get,",
            "                               mock_token_validate):",
            "        mock_token_validate.return_value = nova.objects.ConsoleAuthToken(",
            "            instance_uuid=uuids.instance, host='node1', port='10000',",
            "            console_type='novnc', access_url_base='https://example.net:6080')",
            "        # The token attribute is set by the validate() method.",
            "        mock_token_validate.return_value.token = '123-456-789'",
            "        mock_token_validate.return_value.id = 1",
            "",
            "        ex = exception.SecurityProxyNegotiationFailed(\"Wibble\")",
            "        self.server.security_proxy.connect.side_effect = ex",
            "",
            "        self.assertRaises(exception.SecurityProxyNegotiationFailed,",
            "                          self.wh.new_websocket_client)",
            "",
            "        self.assertEqual(len(self.wh.do_proxy.calls), 0)",
            "        mock_close.assert_called_with()",
            "        self.assertEqual(len(mock_finish.calls), 0)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.console.test_websocketproxy.NovaProxyRequestHandlerBaseTestCase.test_new_websocket_client.params"
        ]
    },
    "nova/tests/unit/consoleauth/test_consoleauth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         self.stub_out(self.rpcapi + 'validate_console_port',"
            },
            "1": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "                       fake_validate_console_port)"
            },
            "2": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+    @mock.patch('nova.consoleauth.manager.LOG.info')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+    def test_authorize_does_not_log_token_secrete(self, mock_info):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        self.manager_api.authorize_console("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+            self.context, 'secret', 'novnc', '127.0.0.1', '8080', 'host',"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+            self.instance_uuid)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        mock_info.assert_called_once_with("
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            'Received Token: %(token_dict)s', test.MatchType(dict))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        self.assertEqual("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+            '***', mock_info.mock_calls[0][1][1]['token_dict']['token'])"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     @mock.patch('nova.objects.instance.Instance.get_by_uuid')"
            },
            "15": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     def test_multiple_tokens_for_instance(self, mock_get):"
            },
            "16": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         mock_get.return_value = None"
            },
            "17": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "             mock_delete.assert_called_once_with("
            },
            "18": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "                 self.instance_uuid.encode('UTF-8'))"
            },
            "19": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+    @mock.patch('nova.consoleauth.manager.LOG.info')"
            },
            "21": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     @mock.patch('nova.objects.instance.Instance.get_by_uuid')"
            },
            "22": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_wrong_token_has_port(self, mock_get):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+    def test_wrong_token_has_port(self, mock_get, mock_log):"
            },
            "24": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         mock_get.return_value = None"
            },
            "25": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         token = u'mytok'"
            },
            "27": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "                                         '127.0.0.1', '8080', 'host',"
            },
            "28": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "                                         instance_uuid=self.instance_uuid)"
            },
            "29": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         self.assertIsNone(self.manager_api.check_token(self.context, token))"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        mock_log.assert_has_calls(["
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            mock.call("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+                'Received Token: %(token_dict)s', mock.ANY),"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            mock.call("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+                'Checking that token is known: %(token_valid)s',"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+                {'token_valid': True}),"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        ])"
            },
            "37": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     def test_delete_expired_tokens(self):"
            },
            "39": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         self.useFixture(test.TimeOverride())"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"",
            "Tests for Consoleauth Code.",
            "",
            "\"\"\"",
            "",
            "import mock",
            "from oslo_utils import timeutils",
            "import six",
            "",
            "from nova.consoleauth import manager",
            "from nova import context",
            "from nova import objects",
            "from nova import test",
            "from nova.tests import uuidsentinel as uuids",
            "",
            "",
            "class ConsoleauthTestCase(test.NoDBTestCase):",
            "    \"\"\"Test Case for consoleauth.\"\"\"",
            "",
            "    rpcapi = 'nova.compute.rpcapi.ComputeAPI.'",
            "",
            "    def setUp(self):",
            "        super(ConsoleauthTestCase, self).setUp()",
            "        self.manager_api = self.manager = manager.ConsoleAuthManager()",
            "        self.context = context.get_admin_context()",
            "        self.instance_uuid = '00000000-0000-0000-0000-000000000000'",
            "        self.is_cells = False",
            "",
            "    def test_reset(self):",
            "        with mock.patch('nova.compute.rpcapi.ComputeAPI') as mock_rpc:",
            "            old_rpcapi = self.manager_api.compute_rpcapi",
            "            self.manager_api.reset()",
            "            mock_rpc.assert_called_once_with()",
            "            self.assertNotEqual(old_rpcapi,",
            "                                self.manager_api.compute_rpcapi)",
            "",
            "    @mock.patch('nova.objects.instance.Instance.get_by_uuid')",
            "    def test_tokens_expire(self, mock_get):",
            "        mock_get.return_value = None",
            "        # NOTE(danms): Get the faked InstanceMapping from the SingleCellSimple",
            "        # fixture so we can return it from our own mock to verify",
            "        # that it was called",
            "        fake_im = objects.InstanceMapping.get_by_instance_uuid(self.context,",
            "                uuids.instance)",
            "",
            "        # Test that tokens expire correctly.",
            "        self.useFixture(test.TimeOverride())",
            "        token = u'mytok'",
            "        self.flags(token_ttl=1, group='consoleauth')",
            "",
            "        self._stub_validate_console_port(True)",
            "",
            "        self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                         '127.0.0.1', '8080', 'host',",
            "                                         self.instance_uuid)",
            "        with mock.patch('nova.objects.InstanceMapping.'",
            "                        'get_by_instance_uuid') as mock_get:",
            "            mock_get.return_value = fake_im",
            "            self.assertIsNotNone(self.manager_api.check_token(self.context,",
            "                                                              token))",
            "            timeutils.advance_time_seconds(1)",
            "            self.assertIsNone(self.manager_api.check_token(self.context,",
            "                                                           token))",
            "            if not self.is_cells:",
            "                mock_get.assert_called_once_with(self.context,",
            "                                                 self.instance_uuid)",
            "",
            "    def _stub_validate_console_port(self, result):",
            "        def fake_validate_console_port(self, ctxt, instance,",
            "                                       port, console_type):",
            "            return result",
            "",
            "        self.stub_out(self.rpcapi + 'validate_console_port',",
            "                      fake_validate_console_port)",
            "",
            "    @mock.patch('nova.objects.instance.Instance.get_by_uuid')",
            "    def test_multiple_tokens_for_instance(self, mock_get):",
            "        mock_get.return_value = None",
            "",
            "        tokens = [u\"token\" + str(i) for i in range(10)]",
            "",
            "        self._stub_validate_console_port(True)",
            "",
            "        for token in tokens:",
            "            self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                          '127.0.0.1', '8080', 'host',",
            "                                          self.instance_uuid)",
            "",
            "        for token in tokens:",
            "            self.assertIsNotNone(",
            "                    self.manager_api.check_token(self.context, token))",
            "",
            "    def test_delete_tokens_for_instance(self):",
            "        tokens = [u\"token\" + str(i) for i in range(10)]",
            "        for token in tokens:",
            "            self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                          '127.0.0.1', '8080', 'host',",
            "                                          self.instance_uuid)",
            "        self.manager_api.delete_tokens_for_instance(self.context,",
            "                self.instance_uuid)",
            "        stored_tokens = self.manager._get_tokens_for_instance(",
            "                self.instance_uuid)",
            "",
            "        self.assertEqual(len(stored_tokens), 0)",
            "",
            "        for token in tokens:",
            "            self.assertIsNone(",
            "                self.manager_api.check_token(self.context, token))",
            "",
            "    def test_delete_tokens_for_instance_no_tokens(self):",
            "        with test.nested(",
            "            mock.patch.object(self.manager, '_get_tokens_for_instance',",
            "                              return_value=[]),",
            "            mock.patch.object(self.manager.mc, 'delete_multi'),",
            "            mock.patch.object(self.manager.mc_instance, 'delete')",
            "        ) as (",
            "            mock_get_tokens, mock_delete_multi, mock_delete",
            "        ):",
            "            self.manager.delete_tokens_for_instance(",
            "                self.context, self.instance_uuid)",
            "            # Since here were no tokens, we didn't try to clear anything",
            "            # from the cache.",
            "            mock_delete_multi.assert_not_called()",
            "            mock_delete.assert_called_once_with(",
            "                self.instance_uuid.encode('UTF-8'))",
            "",
            "    @mock.patch('nova.objects.instance.Instance.get_by_uuid')",
            "    def test_wrong_token_has_port(self, mock_get):",
            "        mock_get.return_value = None",
            "",
            "        token = u'mytok'",
            "",
            "        self._stub_validate_console_port(False)",
            "",
            "        self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                        '127.0.0.1', '8080', 'host',",
            "                                        instance_uuid=self.instance_uuid)",
            "        self.assertIsNone(self.manager_api.check_token(self.context, token))",
            "",
            "    def test_delete_expired_tokens(self):",
            "        self.useFixture(test.TimeOverride())",
            "        token = u'mytok'",
            "        self.flags(token_ttl=1, group='consoleauth')",
            "",
            "        self._stub_validate_console_port(True)",
            "",
            "        self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                         '127.0.0.1', '8080', 'host',",
            "                                         self.instance_uuid)",
            "        timeutils.advance_time_seconds(1)",
            "        self.assertIsNone(self.manager_api.check_token(self.context, token))",
            "",
            "        token1 = u'mytok2'",
            "        self.manager_api.authorize_console(self.context, token1, 'novnc',",
            "                                       '127.0.0.1', '8080', 'host',",
            "                                       self.instance_uuid)",
            "        stored_tokens = self.manager._get_tokens_for_instance(",
            "                self.instance_uuid)",
            "        # when trying to store token1, expired token is removed fist.",
            "        self.assertEqual(len(stored_tokens), 1)",
            "        self.assertEqual(stored_tokens[0], token1)",
            "",
            "",
            "class ControlauthMemcacheEncodingTestCase(test.NoDBTestCase):",
            "    def setUp(self):",
            "        super(ControlauthMemcacheEncodingTestCase, self).setUp()",
            "        self.manager = manager.ConsoleAuthManager()",
            "        self.context = context.get_admin_context()",
            "        self.u_token = u\"token\"",
            "        self.u_instance = u\"instance\"",
            "",
            "    def test_authorize_console_encoding(self):",
            "        with test.nested(",
            "                mock.patch.object(self.manager.mc_instance,",
            "                                  'set', return_value=None),",
            "                mock.patch.object(self.manager.mc_instance,",
            "                                  'get', return_value='[\"token\"]'),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'set', return_value=None),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'get', return_value=None),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'get_multi', return_value=[\"token1\"]),",
            "        ) as (",
            "                mock_instance_set,",
            "                mock_instance_get,",
            "                mock_set,",
            "                mock_get,",
            "                mock_get_multi):",
            "            self.manager.authorize_console(self.context, self.u_token,",
            "                                           'novnc', '127.0.0.1', '8080',",
            "                                           'host', self.u_instance)",
            "            mock_set.assert_has_calls([mock.call(b'token', mock.ANY)])",
            "            mock_instance_get.assert_has_calls([mock.call(b'instance')])",
            "            mock_get_multi.assert_has_calls([mock.call([b'token'])])",
            "            mock_instance_set.assert_has_calls(",
            "                    [mock.call(b'instance', mock.ANY)])",
            "",
            "    def test_check_token_encoding(self):",
            "        with mock.patch.object(self.manager.mc,",
            "                               \"get\",",
            "                               return_value=None) as mock_get:",
            "            self.manager.check_token(self.context, self.u_token)",
            "            mock_get.assert_called_once_with(test.MatchType(six.binary_type))",
            "",
            "    def test_delete_tokens_for_instance_encoding(self):",
            "        with test.nested(",
            "                mock.patch.object(self.manager.mc_instance,",
            "                                  'get', return_value='[\"token\"]'),",
            "                mock.patch.object(self.manager.mc_instance,",
            "                                  'delete', return_value=True),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'get'),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'delete_multi', return_value=True),",
            "        ) as (",
            "                mock_instance_get,",
            "                mock_instance_delete,",
            "                mock_get,",
            "                mock_delete_multi):",
            "            self.manager.delete_tokens_for_instance(self.context,",
            "                                                    self.u_instance)",
            "            mock_instance_get.assert_has_calls([mock.call(b'instance')])",
            "            mock_instance_delete.assert_has_calls([mock.call(b'instance')])",
            "            mock_delete_multi.assert_has_calls([mock.call([b'token'])])",
            "",
            "",
            "class CellsConsoleauthTestCase(ConsoleauthTestCase):",
            "    \"\"\"Test Case for consoleauth w/ cells enabled.\"\"\"",
            "",
            "    rpcapi = 'nova.cells.rpcapi.CellsAPI.'",
            "",
            "    def setUp(self):",
            "        super(CellsConsoleauthTestCase, self).setUp()",
            "        self.flags(enable=True, group='cells')",
            "        self.is_cells = True"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"",
            "Tests for Consoleauth Code.",
            "",
            "\"\"\"",
            "",
            "import mock",
            "from oslo_utils import timeutils",
            "import six",
            "",
            "from nova.consoleauth import manager",
            "from nova import context",
            "from nova import objects",
            "from nova import test",
            "from nova.tests import uuidsentinel as uuids",
            "",
            "",
            "class ConsoleauthTestCase(test.NoDBTestCase):",
            "    \"\"\"Test Case for consoleauth.\"\"\"",
            "",
            "    rpcapi = 'nova.compute.rpcapi.ComputeAPI.'",
            "",
            "    def setUp(self):",
            "        super(ConsoleauthTestCase, self).setUp()",
            "        self.manager_api = self.manager = manager.ConsoleAuthManager()",
            "        self.context = context.get_admin_context()",
            "        self.instance_uuid = '00000000-0000-0000-0000-000000000000'",
            "        self.is_cells = False",
            "",
            "    def test_reset(self):",
            "        with mock.patch('nova.compute.rpcapi.ComputeAPI') as mock_rpc:",
            "            old_rpcapi = self.manager_api.compute_rpcapi",
            "            self.manager_api.reset()",
            "            mock_rpc.assert_called_once_with()",
            "            self.assertNotEqual(old_rpcapi,",
            "                                self.manager_api.compute_rpcapi)",
            "",
            "    @mock.patch('nova.objects.instance.Instance.get_by_uuid')",
            "    def test_tokens_expire(self, mock_get):",
            "        mock_get.return_value = None",
            "        # NOTE(danms): Get the faked InstanceMapping from the SingleCellSimple",
            "        # fixture so we can return it from our own mock to verify",
            "        # that it was called",
            "        fake_im = objects.InstanceMapping.get_by_instance_uuid(self.context,",
            "                uuids.instance)",
            "",
            "        # Test that tokens expire correctly.",
            "        self.useFixture(test.TimeOverride())",
            "        token = u'mytok'",
            "        self.flags(token_ttl=1, group='consoleauth')",
            "",
            "        self._stub_validate_console_port(True)",
            "",
            "        self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                         '127.0.0.1', '8080', 'host',",
            "                                         self.instance_uuid)",
            "        with mock.patch('nova.objects.InstanceMapping.'",
            "                        'get_by_instance_uuid') as mock_get:",
            "            mock_get.return_value = fake_im",
            "            self.assertIsNotNone(self.manager_api.check_token(self.context,",
            "                                                              token))",
            "            timeutils.advance_time_seconds(1)",
            "            self.assertIsNone(self.manager_api.check_token(self.context,",
            "                                                           token))",
            "            if not self.is_cells:",
            "                mock_get.assert_called_once_with(self.context,",
            "                                                 self.instance_uuid)",
            "",
            "    def _stub_validate_console_port(self, result):",
            "        def fake_validate_console_port(self, ctxt, instance,",
            "                                       port, console_type):",
            "            return result",
            "",
            "        self.stub_out(self.rpcapi + 'validate_console_port',",
            "                      fake_validate_console_port)",
            "",
            "    @mock.patch('nova.consoleauth.manager.LOG.info')",
            "    def test_authorize_does_not_log_token_secrete(self, mock_info):",
            "        self.manager_api.authorize_console(",
            "            self.context, 'secret', 'novnc', '127.0.0.1', '8080', 'host',",
            "            self.instance_uuid)",
            "",
            "        mock_info.assert_called_once_with(",
            "            'Received Token: %(token_dict)s', test.MatchType(dict))",
            "        self.assertEqual(",
            "            '***', mock_info.mock_calls[0][1][1]['token_dict']['token'])",
            "",
            "    @mock.patch('nova.objects.instance.Instance.get_by_uuid')",
            "    def test_multiple_tokens_for_instance(self, mock_get):",
            "        mock_get.return_value = None",
            "",
            "        tokens = [u\"token\" + str(i) for i in range(10)]",
            "",
            "        self._stub_validate_console_port(True)",
            "",
            "        for token in tokens:",
            "            self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                          '127.0.0.1', '8080', 'host',",
            "                                          self.instance_uuid)",
            "",
            "        for token in tokens:",
            "            self.assertIsNotNone(",
            "                    self.manager_api.check_token(self.context, token))",
            "",
            "    def test_delete_tokens_for_instance(self):",
            "        tokens = [u\"token\" + str(i) for i in range(10)]",
            "        for token in tokens:",
            "            self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                          '127.0.0.1', '8080', 'host',",
            "                                          self.instance_uuid)",
            "        self.manager_api.delete_tokens_for_instance(self.context,",
            "                self.instance_uuid)",
            "        stored_tokens = self.manager._get_tokens_for_instance(",
            "                self.instance_uuid)",
            "",
            "        self.assertEqual(len(stored_tokens), 0)",
            "",
            "        for token in tokens:",
            "            self.assertIsNone(",
            "                self.manager_api.check_token(self.context, token))",
            "",
            "    def test_delete_tokens_for_instance_no_tokens(self):",
            "        with test.nested(",
            "            mock.patch.object(self.manager, '_get_tokens_for_instance',",
            "                              return_value=[]),",
            "            mock.patch.object(self.manager.mc, 'delete_multi'),",
            "            mock.patch.object(self.manager.mc_instance, 'delete')",
            "        ) as (",
            "            mock_get_tokens, mock_delete_multi, mock_delete",
            "        ):",
            "            self.manager.delete_tokens_for_instance(",
            "                self.context, self.instance_uuid)",
            "            # Since here were no tokens, we didn't try to clear anything",
            "            # from the cache.",
            "            mock_delete_multi.assert_not_called()",
            "            mock_delete.assert_called_once_with(",
            "                self.instance_uuid.encode('UTF-8'))",
            "",
            "    @mock.patch('nova.consoleauth.manager.LOG.info')",
            "    @mock.patch('nova.objects.instance.Instance.get_by_uuid')",
            "    def test_wrong_token_has_port(self, mock_get, mock_log):",
            "        mock_get.return_value = None",
            "",
            "        token = u'mytok'",
            "",
            "        self._stub_validate_console_port(False)",
            "",
            "        self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                        '127.0.0.1', '8080', 'host',",
            "                                        instance_uuid=self.instance_uuid)",
            "        self.assertIsNone(self.manager_api.check_token(self.context, token))",
            "        mock_log.assert_has_calls([",
            "            mock.call(",
            "                'Received Token: %(token_dict)s', mock.ANY),",
            "            mock.call(",
            "                'Checking that token is known: %(token_valid)s',",
            "                {'token_valid': True}),",
            "        ])",
            "",
            "    def test_delete_expired_tokens(self):",
            "        self.useFixture(test.TimeOverride())",
            "        token = u'mytok'",
            "        self.flags(token_ttl=1, group='consoleauth')",
            "",
            "        self._stub_validate_console_port(True)",
            "",
            "        self.manager_api.authorize_console(self.context, token, 'novnc',",
            "                                         '127.0.0.1', '8080', 'host',",
            "                                         self.instance_uuid)",
            "        timeutils.advance_time_seconds(1)",
            "        self.assertIsNone(self.manager_api.check_token(self.context, token))",
            "",
            "        token1 = u'mytok2'",
            "        self.manager_api.authorize_console(self.context, token1, 'novnc',",
            "                                       '127.0.0.1', '8080', 'host',",
            "                                       self.instance_uuid)",
            "        stored_tokens = self.manager._get_tokens_for_instance(",
            "                self.instance_uuid)",
            "        # when trying to store token1, expired token is removed fist.",
            "        self.assertEqual(len(stored_tokens), 1)",
            "        self.assertEqual(stored_tokens[0], token1)",
            "",
            "",
            "class ControlauthMemcacheEncodingTestCase(test.NoDBTestCase):",
            "    def setUp(self):",
            "        super(ControlauthMemcacheEncodingTestCase, self).setUp()",
            "        self.manager = manager.ConsoleAuthManager()",
            "        self.context = context.get_admin_context()",
            "        self.u_token = u\"token\"",
            "        self.u_instance = u\"instance\"",
            "",
            "    def test_authorize_console_encoding(self):",
            "        with test.nested(",
            "                mock.patch.object(self.manager.mc_instance,",
            "                                  'set', return_value=None),",
            "                mock.patch.object(self.manager.mc_instance,",
            "                                  'get', return_value='[\"token\"]'),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'set', return_value=None),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'get', return_value=None),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'get_multi', return_value=[\"token1\"]),",
            "        ) as (",
            "                mock_instance_set,",
            "                mock_instance_get,",
            "                mock_set,",
            "                mock_get,",
            "                mock_get_multi):",
            "            self.manager.authorize_console(self.context, self.u_token,",
            "                                           'novnc', '127.0.0.1', '8080',",
            "                                           'host', self.u_instance)",
            "            mock_set.assert_has_calls([mock.call(b'token', mock.ANY)])",
            "            mock_instance_get.assert_has_calls([mock.call(b'instance')])",
            "            mock_get_multi.assert_has_calls([mock.call([b'token'])])",
            "            mock_instance_set.assert_has_calls(",
            "                    [mock.call(b'instance', mock.ANY)])",
            "",
            "    def test_check_token_encoding(self):",
            "        with mock.patch.object(self.manager.mc,",
            "                               \"get\",",
            "                               return_value=None) as mock_get:",
            "            self.manager.check_token(self.context, self.u_token)",
            "            mock_get.assert_called_once_with(test.MatchType(six.binary_type))",
            "",
            "    def test_delete_tokens_for_instance_encoding(self):",
            "        with test.nested(",
            "                mock.patch.object(self.manager.mc_instance,",
            "                                  'get', return_value='[\"token\"]'),",
            "                mock.patch.object(self.manager.mc_instance,",
            "                                  'delete', return_value=True),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'get'),",
            "                mock.patch.object(self.manager.mc,",
            "                                  'delete_multi', return_value=True),",
            "        ) as (",
            "                mock_instance_get,",
            "                mock_instance_delete,",
            "                mock_get,",
            "                mock_delete_multi):",
            "            self.manager.delete_tokens_for_instance(self.context,",
            "                                                    self.u_instance)",
            "            mock_instance_get.assert_has_calls([mock.call(b'instance')])",
            "            mock_instance_delete.assert_has_calls([mock.call(b'instance')])",
            "            mock_delete_multi.assert_has_calls([mock.call([b'token'])])",
            "",
            "",
            "class CellsConsoleauthTestCase(ConsoleauthTestCase):",
            "    \"\"\"Test Case for consoleauth w/ cells enabled.\"\"\"",
            "",
            "    rpcapi = 'nova.cells.rpcapi.CellsAPI.'",
            "",
            "    def setUp(self):",
            "        super(CellsConsoleauthTestCase, self).setUp()",
            "        self.flags(enable=True, group='cells')",
            "        self.is_cells = True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "143": [
                "ConsoleauthTestCase",
                "test_wrong_token_has_port"
            ]
        },
        "addLocation": [
            "nova.tests.unit.consoleauth.test_consoleauth.ConsoleauthTestCase.self"
        ]
    }
}