{
    "master/buildbot/test/unit/test_www_auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         self.auth.updateUserInfo = mock.Mock(side_effect=updateUserInfo)"
            },
            "1": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "         res = yield self.render_resource(self.rsrc, b'/auth/login')"
            },
            "3": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(res, {'redirected': 'h:/a/b/#/'})"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        self.assertEqual(res, {'redirected': b'h:/a/b/#/'})"
            },
            "5": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         self.assertFalse(self.auth.maybeAutoLogin.called)"
            },
            "6": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         self.auth.updateUserInfo.assert_called_with(mock.ANY)"
            },
            "7": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         self.assertEqual(self.master.session.user_info,"
            },
            "8": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "     def test_render(self):"
            },
            "9": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         self.master.session.expire = mock.Mock()"
            },
            "10": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         res = yield self.render_resource(self.rsrc, b'/auth/logout')"
            },
            "11": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(res, {'redirected': 'h:/a/b/#/'})"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+        self.assertEqual(res, {'redirected': b'h:/a/b/#/'})"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        self.master.session.expire.assert_called_with()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+    @defer.inlineCallbacks"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+    def test_render_with_crlf(self):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+        self.master.session.expire = mock.Mock()"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+        res = yield self.render_resource(self.rsrc, b'/auth/logout?redirect=%0d%0abla')"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+        # everything after a %0d shall be stripped"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+        self.assertEqual(res, {'redirected': b'h:/a/b/#'})"
            },
            "21": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "         self.master.session.expire.assert_called_with()"
            }
        },
        "frontPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "import mock",
            "",
            "from twisted.cred.checkers import InMemoryUsernamePasswordDatabaseDontUse",
            "from twisted.cred.credentials import UsernamePassword",
            "from twisted.cred.error import UnauthorizedLogin",
            "from twisted.internet import defer",
            "from twisted.trial import unittest",
            "from twisted.web.error import Error",
            "from twisted.web.guard import BasicCredentialFactory",
            "from twisted.web.guard import HTTPAuthSessionWrapper",
            "from twisted.web.resource import IResource",
            "",
            "from buildbot.test.util import www",
            "from buildbot.www import auth",
            "",
            "",
            "class AuthResourceMixin:",
            "",
            "    def setUpAuthResource(self):",
            "        self.master = self.make_master(url='h:/a/b/')",
            "        self.auth = self.master.config.www['auth']",
            "        self.master.www.auth = self.auth",
            "        self.auth.master = self.master",
            "",
            "",
            "class AuthRootResource(www.WwwTestMixin, AuthResourceMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.setUpAuthResource()",
            "        self.rsrc = auth.AuthRootResource(self.master)",
            "",
            "    def test_getChild_login(self):",
            "        glr = mock.Mock(name='glr')",
            "        self.master.www.auth.getLoginResource = glr",
            "        child = self.rsrc.getChild(b'login', mock.Mock(name='req'))",
            "        self.assertIdentical(child, glr())",
            "",
            "    def test_getChild_logout(self):",
            "        glr = mock.Mock(name='glr')",
            "        self.master.www.auth.getLogoutResource = glr",
            "        child = self.rsrc.getChild(b'logout', mock.Mock(name='req'))",
            "        self.assertIdentical(child, glr())",
            "",
            "",
            "class AuthBase(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.auth = auth.AuthBase()",
            "        self.master = self.make_master(url='h:/a/b/')",
            "        self.auth.master = self.master",
            "        self.req = self.make_request(b'/')",
            "",
            "    @defer.inlineCallbacks",
            "    def test_maybeAutoLogin(self):",
            "        self.assertEqual((yield self.auth.maybeAutoLogin(self.req)), None)",
            "",
            "    def test_getLoginResource(self):",
            "        with self.assertRaises(Error):",
            "            self.auth.getLoginResource()",
            "",
            "    @defer.inlineCallbacks",
            "    def test_updateUserInfo(self):",
            "        self.auth.userInfoProvider = auth.UserInfoProviderBase()",
            "        self.auth.userInfoProvider.getUserInfo = lambda un: {'info': un}",
            "        self.req.session.user_info = {'username': 'elvira'}",
            "        yield self.auth.updateUserInfo(self.req)",
            "        self.assertEqual(self.req.session.user_info,",
            "                         {'info': 'elvira', 'username': 'elvira'})",
            "",
            "    def getConfigDict(self):",
            "        self.assertEqual(auth.getConfigDict(),",
            "                         {'name': 'AuthBase'})",
            "",
            "",
            "class UseAuthInfoProviderBase(unittest.TestCase):",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getUserInfo(self):",
            "        uip = auth.UserInfoProviderBase()",
            "        self.assertEqual((yield uip.getUserInfo('jess')),",
            "                         {'email': 'jess'})",
            "",
            "",
            "class NoAuth(unittest.TestCase):",
            "",
            "    def test_exists(self):",
            "        assert auth.NoAuth",
            "",
            "",
            "class RemoteUserAuth(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.auth = auth.RemoteUserAuth(header=b'HDR')",
            "        self.make_master()",
            "        self.request = self.make_request(b'/')",
            "",
            "    @defer.inlineCallbacks",
            "    def test_maybeAutoLogin(self):",
            "        self.request.input_headers[b'HDR'] = b'rachel@foo.com'",
            "        yield self.auth.maybeAutoLogin(self.request)",
            "        self.assertEqual(self.request.session.user_info, {",
            "                         'username': 'rachel',",
            "                         'realm': 'foo.com',",
            "                         'email': 'rachel'})",
            "",
            "    @defer.inlineCallbacks",
            "    def test_maybeAutoLogin_no_header(self):",
            "        try:",
            "            yield self.auth.maybeAutoLogin(self.request)",
            "        except Error as e:",
            "            self.assertEqual(int(e.status), 403)",
            "        else:",
            "            self.fail(\"403 expected\")",
            "",
            "    @defer.inlineCallbacks",
            "    def test_maybeAutoLogin_mismatched_value(self):",
            "        self.request.input_headers[b'HDR'] = b'rachel'",
            "        try:",
            "            yield self.auth.maybeAutoLogin(self.request)",
            "        except Error as e:",
            "            self.assertEqual(int(e.status), 403)",
            "        else:",
            "            self.fail(\"403 expected\")",
            "",
            "",
            "class AuthRealm(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.auth = auth.RemoteUserAuth(header=b'HDR')",
            "        self.auth = auth.NoAuth()",
            "        self.make_master()",
            "",
            "    def test_requestAvatar(self):",
            "        realm = auth.AuthRealm(self.master, self.auth)",
            "        itfc, rsrc, logout = realm.requestAvatar(\"me\", None, IResource)",
            "        self.assertIdentical(itfc, IResource)",
            "        self.assertIsInstance(rsrc, auth.PreAuthenticatedLoginResource)",
            "",
            "",
            "class TwistedICredAuthBase(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    # twisted.web makes it difficult to simulate the authentication process, so",
            "    # this only tests the mechanics of the getLoginResource method.",
            "",
            "    def test_getLoginResource(self):",
            "        self.auth = auth.TwistedICredAuthBase(",
            "            credentialFactories=[BasicCredentialFactory(\"buildbot\")],",
            "            checkers=[InMemoryUsernamePasswordDatabaseDontUse(good=b'guy')])",
            "        self.auth.master = self.make_master(url='h:/a/b/')",
            "        rsrc = self.auth.getLoginResource()",
            "        self.assertIsInstance(rsrc, HTTPAuthSessionWrapper)",
            "",
            "",
            "class UserPasswordAuth(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def test_passwordStringToBytes(self):",
            "        login = {\"user_string\": \"password\",",
            "                 \"user_bytes\": b\"password\"}",
            "        correct_login = {b\"user_string\": b\"password\",",
            "                         b\"user_bytes\": b\"password\"}",
            "        self.auth = auth.UserPasswordAuth(login)",
            "        self.assertEqual(self.auth.checkers[0].users, correct_login)",
            "",
            "        login = [(\"user_string\", \"password\"),",
            "                 (\"user_bytes\", b\"password\")]",
            "        correct_login = {b\"user_string\": b\"password\",",
            "                         b\"user_bytes\": b\"password\"}",
            "        self.auth = auth.UserPasswordAuth(login)",
            "        self.assertEqual(self.auth.checkers[0].users, correct_login)",
            "",
            "",
            "class CustomAuth(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    class MockCustomAuth(auth.CustomAuth):",
            "        def check_credentials(self, us, ps):",
            "            return us == 'fellow' and ps == 'correct'",
            "",
            "    @defer.inlineCallbacks",
            "    def test_callable(self):",
            "        self.auth = self.MockCustomAuth()",
            "        cred_good = UsernamePassword('fellow', 'correct')",
            "        result_good = yield self.auth.checkers[0].requestAvatarId(cred_good)",
            "        self.assertEqual(result_good, 'fellow')",
            "        cred_bad = UsernamePassword('bandid', 'incorrect')",
            "        defer_bad = self.auth.checkers[0].requestAvatarId(cred_bad)",
            "        yield self.assertFailure(defer_bad, UnauthorizedLogin)",
            "",
            "",
            "class LoginResource(www.WwwTestMixin, AuthResourceMixin, unittest.TestCase):",
            "",
            "    @defer.inlineCallbacks",
            "    def test_render(self):",
            "        self.setUpAuthResource()",
            "        self.rsrc = auth.LoginResource(self.master)",
            "        self.rsrc.renderLogin = mock.Mock(",
            "            spec=self.rsrc.renderLogin, return_value=defer.succeed(b'hi'))",
            "",
            "        yield self.render_resource(self.rsrc, b'/auth/login')",
            "        self.rsrc.renderLogin.assert_called_with(mock.ANY)",
            "",
            "",
            "class PreAuthenticatedLoginResource(www.WwwTestMixin, AuthResourceMixin,",
            "                                    unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.setUpAuthResource()",
            "        self.rsrc = auth.PreAuthenticatedLoginResource(self.master, 'him')",
            "",
            "    @defer.inlineCallbacks",
            "    def test_render(self):",
            "        self.auth.maybeAutoLogin = mock.Mock()",
            "",
            "        def updateUserInfo(request):",
            "            session = request.getSession()",
            "            session.user_info['email'] = session.user_info['username'] + \"@org\"",
            "            session.updateSession(request)",
            "",
            "        self.auth.updateUserInfo = mock.Mock(side_effect=updateUserInfo)",
            "",
            "        res = yield self.render_resource(self.rsrc, b'/auth/login')",
            "        self.assertEqual(res, {'redirected': 'h:/a/b/#/'})",
            "        self.assertFalse(self.auth.maybeAutoLogin.called)",
            "        self.auth.updateUserInfo.assert_called_with(mock.ANY)",
            "        self.assertEqual(self.master.session.user_info,",
            "                         {'email': 'him@org', 'username': 'him'})",
            "",
            "",
            "class LogoutResource(www.WwwTestMixin, AuthResourceMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.setUpAuthResource()",
            "        self.rsrc = auth.LogoutResource(self.master)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_render(self):",
            "        self.master.session.expire = mock.Mock()",
            "        res = yield self.render_resource(self.rsrc, b'/auth/logout')",
            "        self.assertEqual(res, {'redirected': 'h:/a/b/#/'})",
            "        self.master.session.expire.assert_called_with()"
        ],
        "afterPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "import mock",
            "",
            "from twisted.cred.checkers import InMemoryUsernamePasswordDatabaseDontUse",
            "from twisted.cred.credentials import UsernamePassword",
            "from twisted.cred.error import UnauthorizedLogin",
            "from twisted.internet import defer",
            "from twisted.trial import unittest",
            "from twisted.web.error import Error",
            "from twisted.web.guard import BasicCredentialFactory",
            "from twisted.web.guard import HTTPAuthSessionWrapper",
            "from twisted.web.resource import IResource",
            "",
            "from buildbot.test.util import www",
            "from buildbot.www import auth",
            "",
            "",
            "class AuthResourceMixin:",
            "",
            "    def setUpAuthResource(self):",
            "        self.master = self.make_master(url='h:/a/b/')",
            "        self.auth = self.master.config.www['auth']",
            "        self.master.www.auth = self.auth",
            "        self.auth.master = self.master",
            "",
            "",
            "class AuthRootResource(www.WwwTestMixin, AuthResourceMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.setUpAuthResource()",
            "        self.rsrc = auth.AuthRootResource(self.master)",
            "",
            "    def test_getChild_login(self):",
            "        glr = mock.Mock(name='glr')",
            "        self.master.www.auth.getLoginResource = glr",
            "        child = self.rsrc.getChild(b'login', mock.Mock(name='req'))",
            "        self.assertIdentical(child, glr())",
            "",
            "    def test_getChild_logout(self):",
            "        glr = mock.Mock(name='glr')",
            "        self.master.www.auth.getLogoutResource = glr",
            "        child = self.rsrc.getChild(b'logout', mock.Mock(name='req'))",
            "        self.assertIdentical(child, glr())",
            "",
            "",
            "class AuthBase(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.auth = auth.AuthBase()",
            "        self.master = self.make_master(url='h:/a/b/')",
            "        self.auth.master = self.master",
            "        self.req = self.make_request(b'/')",
            "",
            "    @defer.inlineCallbacks",
            "    def test_maybeAutoLogin(self):",
            "        self.assertEqual((yield self.auth.maybeAutoLogin(self.req)), None)",
            "",
            "    def test_getLoginResource(self):",
            "        with self.assertRaises(Error):",
            "            self.auth.getLoginResource()",
            "",
            "    @defer.inlineCallbacks",
            "    def test_updateUserInfo(self):",
            "        self.auth.userInfoProvider = auth.UserInfoProviderBase()",
            "        self.auth.userInfoProvider.getUserInfo = lambda un: {'info': un}",
            "        self.req.session.user_info = {'username': 'elvira'}",
            "        yield self.auth.updateUserInfo(self.req)",
            "        self.assertEqual(self.req.session.user_info,",
            "                         {'info': 'elvira', 'username': 'elvira'})",
            "",
            "    def getConfigDict(self):",
            "        self.assertEqual(auth.getConfigDict(),",
            "                         {'name': 'AuthBase'})",
            "",
            "",
            "class UseAuthInfoProviderBase(unittest.TestCase):",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getUserInfo(self):",
            "        uip = auth.UserInfoProviderBase()",
            "        self.assertEqual((yield uip.getUserInfo('jess')),",
            "                         {'email': 'jess'})",
            "",
            "",
            "class NoAuth(unittest.TestCase):",
            "",
            "    def test_exists(self):",
            "        assert auth.NoAuth",
            "",
            "",
            "class RemoteUserAuth(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.auth = auth.RemoteUserAuth(header=b'HDR')",
            "        self.make_master()",
            "        self.request = self.make_request(b'/')",
            "",
            "    @defer.inlineCallbacks",
            "    def test_maybeAutoLogin(self):",
            "        self.request.input_headers[b'HDR'] = b'rachel@foo.com'",
            "        yield self.auth.maybeAutoLogin(self.request)",
            "        self.assertEqual(self.request.session.user_info, {",
            "                         'username': 'rachel',",
            "                         'realm': 'foo.com',",
            "                         'email': 'rachel'})",
            "",
            "    @defer.inlineCallbacks",
            "    def test_maybeAutoLogin_no_header(self):",
            "        try:",
            "            yield self.auth.maybeAutoLogin(self.request)",
            "        except Error as e:",
            "            self.assertEqual(int(e.status), 403)",
            "        else:",
            "            self.fail(\"403 expected\")",
            "",
            "    @defer.inlineCallbacks",
            "    def test_maybeAutoLogin_mismatched_value(self):",
            "        self.request.input_headers[b'HDR'] = b'rachel'",
            "        try:",
            "            yield self.auth.maybeAutoLogin(self.request)",
            "        except Error as e:",
            "            self.assertEqual(int(e.status), 403)",
            "        else:",
            "            self.fail(\"403 expected\")",
            "",
            "",
            "class AuthRealm(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.auth = auth.RemoteUserAuth(header=b'HDR')",
            "        self.auth = auth.NoAuth()",
            "        self.make_master()",
            "",
            "    def test_requestAvatar(self):",
            "        realm = auth.AuthRealm(self.master, self.auth)",
            "        itfc, rsrc, logout = realm.requestAvatar(\"me\", None, IResource)",
            "        self.assertIdentical(itfc, IResource)",
            "        self.assertIsInstance(rsrc, auth.PreAuthenticatedLoginResource)",
            "",
            "",
            "class TwistedICredAuthBase(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    # twisted.web makes it difficult to simulate the authentication process, so",
            "    # this only tests the mechanics of the getLoginResource method.",
            "",
            "    def test_getLoginResource(self):",
            "        self.auth = auth.TwistedICredAuthBase(",
            "            credentialFactories=[BasicCredentialFactory(\"buildbot\")],",
            "            checkers=[InMemoryUsernamePasswordDatabaseDontUse(good=b'guy')])",
            "        self.auth.master = self.make_master(url='h:/a/b/')",
            "        rsrc = self.auth.getLoginResource()",
            "        self.assertIsInstance(rsrc, HTTPAuthSessionWrapper)",
            "",
            "",
            "class UserPasswordAuth(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def test_passwordStringToBytes(self):",
            "        login = {\"user_string\": \"password\",",
            "                 \"user_bytes\": b\"password\"}",
            "        correct_login = {b\"user_string\": b\"password\",",
            "                         b\"user_bytes\": b\"password\"}",
            "        self.auth = auth.UserPasswordAuth(login)",
            "        self.assertEqual(self.auth.checkers[0].users, correct_login)",
            "",
            "        login = [(\"user_string\", \"password\"),",
            "                 (\"user_bytes\", b\"password\")]",
            "        correct_login = {b\"user_string\": b\"password\",",
            "                         b\"user_bytes\": b\"password\"}",
            "        self.auth = auth.UserPasswordAuth(login)",
            "        self.assertEqual(self.auth.checkers[0].users, correct_login)",
            "",
            "",
            "class CustomAuth(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    class MockCustomAuth(auth.CustomAuth):",
            "        def check_credentials(self, us, ps):",
            "            return us == 'fellow' and ps == 'correct'",
            "",
            "    @defer.inlineCallbacks",
            "    def test_callable(self):",
            "        self.auth = self.MockCustomAuth()",
            "        cred_good = UsernamePassword('fellow', 'correct')",
            "        result_good = yield self.auth.checkers[0].requestAvatarId(cred_good)",
            "        self.assertEqual(result_good, 'fellow')",
            "        cred_bad = UsernamePassword('bandid', 'incorrect')",
            "        defer_bad = self.auth.checkers[0].requestAvatarId(cred_bad)",
            "        yield self.assertFailure(defer_bad, UnauthorizedLogin)",
            "",
            "",
            "class LoginResource(www.WwwTestMixin, AuthResourceMixin, unittest.TestCase):",
            "",
            "    @defer.inlineCallbacks",
            "    def test_render(self):",
            "        self.setUpAuthResource()",
            "        self.rsrc = auth.LoginResource(self.master)",
            "        self.rsrc.renderLogin = mock.Mock(",
            "            spec=self.rsrc.renderLogin, return_value=defer.succeed(b'hi'))",
            "",
            "        yield self.render_resource(self.rsrc, b'/auth/login')",
            "        self.rsrc.renderLogin.assert_called_with(mock.ANY)",
            "",
            "",
            "class PreAuthenticatedLoginResource(www.WwwTestMixin, AuthResourceMixin,",
            "                                    unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.setUpAuthResource()",
            "        self.rsrc = auth.PreAuthenticatedLoginResource(self.master, 'him')",
            "",
            "    @defer.inlineCallbacks",
            "    def test_render(self):",
            "        self.auth.maybeAutoLogin = mock.Mock()",
            "",
            "        def updateUserInfo(request):",
            "            session = request.getSession()",
            "            session.user_info['email'] = session.user_info['username'] + \"@org\"",
            "            session.updateSession(request)",
            "",
            "        self.auth.updateUserInfo = mock.Mock(side_effect=updateUserInfo)",
            "",
            "        res = yield self.render_resource(self.rsrc, b'/auth/login')",
            "        self.assertEqual(res, {'redirected': b'h:/a/b/#/'})",
            "        self.assertFalse(self.auth.maybeAutoLogin.called)",
            "        self.auth.updateUserInfo.assert_called_with(mock.ANY)",
            "        self.assertEqual(self.master.session.user_info,",
            "                         {'email': 'him@org', 'username': 'him'})",
            "",
            "",
            "class LogoutResource(www.WwwTestMixin, AuthResourceMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.setUpAuthResource()",
            "        self.rsrc = auth.LogoutResource(self.master)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_render(self):",
            "        self.master.session.expire = mock.Mock()",
            "        res = yield self.render_resource(self.rsrc, b'/auth/logout')",
            "        self.assertEqual(res, {'redirected': b'h:/a/b/#/'})",
            "        self.master.session.expire.assert_called_with()",
            "",
            "    @defer.inlineCallbacks",
            "    def test_render_with_crlf(self):",
            "        self.master.session.expire = mock.Mock()",
            "        res = yield self.render_resource(self.rsrc, b'/auth/logout?redirect=%0d%0abla')",
            "        # everything after a %0d shall be stripped",
            "        self.assertEqual(res, {'redirected': b'h:/a/b/#'})",
            "        self.master.session.expire.assert_called_with()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "236": [
                "PreAuthenticatedLoginResource",
                "test_render"
            ],
            "253": [
                "LogoutResource",
                "test_render"
            ]
        },
        "addLocation": []
    },
    "master/buildbot/test/unit/test_www_avatar.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         rsrc.reconfigResource(master.config)"
            },
            "1": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         res = yield self.render_resource(rsrc, b'/?email=foo')"
            },
            "3": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(res, dict(redirected='//www.gravatar.com/avatar/acbd18db4cc2f85ce'"
            },
            "4": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                   'def654fccc4a4d8?d=retro&s=32'))"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        self.assertEqual(res, dict(redirected=b'//www.gravatar.com/avatar/acbd18db4cc2f85ce'"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                                   b'def654fccc4a4d8?d=retro&s=32'))"
            },
            "7": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     @defer.inlineCallbacks"
            },
            "9": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     def test_custom(self):"
            },
            "10": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         rsrc.reconfigResource(master.config)"
            },
            "11": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         res = yield self.render_resource(rsrc, b'/?email=foo')"
            },
            "13": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(res, dict(redirected='//www.gravatar.com/avatar/acbd18db4cc2f85ce'"
            },
            "14": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                         'def654fccc4a4d8?d=retro&s=32'))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        self.assertEqual(res, dict(redirected=b'//www.gravatar.com/avatar/acbd18db4cc2f85ce'"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                         b'def654fccc4a4d8?d=retro&s=32'))"
            }
        },
        "frontPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "from twisted.internet import defer",
            "from twisted.trial import unittest",
            "",
            "from buildbot.test.util import www",
            "from buildbot.www import auth",
            "from buildbot.www import avatar",
            "",
            "",
            "class AvatarResource(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    @defer.inlineCallbacks",
            "    def test_default(self):",
            "        master = self.make_master(",
            "            url='http://a/b/', auth=auth.NoAuth(), avatar_methods=[])",
            "        rsrc = avatar.AvatarResource(master)",
            "        rsrc.reconfigResource(master.config)",
            "",
            "        res = yield self.render_resource(rsrc, b'/')",
            "        self.assertEqual(",
            "            res, dict(redirected=avatar.AvatarResource.defaultAvatarUrl))",
            "",
            "    @defer.inlineCallbacks",
            "    def test_gravatar(self):",
            "        master = self.make_master(",
            "            url='http://a/b/', auth=auth.NoAuth(), avatar_methods=[avatar.AvatarGravatar()])",
            "        rsrc = avatar.AvatarResource(master)",
            "        rsrc.reconfigResource(master.config)",
            "",
            "        res = yield self.render_resource(rsrc, b'/?email=foo')",
            "        self.assertEqual(res, dict(redirected='//www.gravatar.com/avatar/acbd18db4cc2f85ce'",
            "                                   'def654fccc4a4d8?d=retro&s=32'))",
            "",
            "    @defer.inlineCallbacks",
            "    def test_custom(self):",
            "        class CustomAvatar(avatar.AvatarBase):",
            "",
            "            def getUserAvatar(self, email, size, defaultAvatarUrl):",
            "                return defer.succeed((b\"image/png\", email +",
            "                                      str(size).encode('utf-8') +",
            "                                      defaultAvatarUrl))",
            "",
            "        master = self.make_master(",
            "            url='http://a/b/', auth=auth.NoAuth(), avatar_methods=[CustomAvatar()])",
            "        rsrc = avatar.AvatarResource(master)",
            "        rsrc.reconfigResource(master.config)",
            "",
            "        res = yield self.render_resource(rsrc, b'/?email=foo')",
            "        self.assertEqual(res, b\"foo32http://a/b/img/nobody.png\")",
            "",
            "    @defer.inlineCallbacks",
            "    def test_custom_not_found(self):",
            "        # use gravatar if the custom avatar fail to return a response",
            "        class CustomAvatar(avatar.AvatarBase):",
            "",
            "            def getUserAvatar(self, email, size, defaultAvatarUrl):",
            "                return defer.succeed(None)",
            "",
            "        master = self.make_master(url=b'http://a/b/', auth=auth.NoAuth(),",
            "                                  avatar_methods=[CustomAvatar(), avatar.AvatarGravatar()])",
            "        rsrc = avatar.AvatarResource(master)",
            "        rsrc.reconfigResource(master.config)",
            "",
            "        res = yield self.render_resource(rsrc, b'/?email=foo')",
            "        self.assertEqual(res, dict(redirected='//www.gravatar.com/avatar/acbd18db4cc2f85ce'",
            "                         'def654fccc4a4d8?d=retro&s=32'))"
        ],
        "afterPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "from twisted.internet import defer",
            "from twisted.trial import unittest",
            "",
            "from buildbot.test.util import www",
            "from buildbot.www import auth",
            "from buildbot.www import avatar",
            "",
            "",
            "class AvatarResource(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    @defer.inlineCallbacks",
            "    def test_default(self):",
            "        master = self.make_master(",
            "            url='http://a/b/', auth=auth.NoAuth(), avatar_methods=[])",
            "        rsrc = avatar.AvatarResource(master)",
            "        rsrc.reconfigResource(master.config)",
            "",
            "        res = yield self.render_resource(rsrc, b'/')",
            "        self.assertEqual(",
            "            res, dict(redirected=avatar.AvatarResource.defaultAvatarUrl))",
            "",
            "    @defer.inlineCallbacks",
            "    def test_gravatar(self):",
            "        master = self.make_master(",
            "            url='http://a/b/', auth=auth.NoAuth(), avatar_methods=[avatar.AvatarGravatar()])",
            "        rsrc = avatar.AvatarResource(master)",
            "        rsrc.reconfigResource(master.config)",
            "",
            "        res = yield self.render_resource(rsrc, b'/?email=foo')",
            "        self.assertEqual(res, dict(redirected=b'//www.gravatar.com/avatar/acbd18db4cc2f85ce'",
            "                                   b'def654fccc4a4d8?d=retro&s=32'))",
            "",
            "    @defer.inlineCallbacks",
            "    def test_custom(self):",
            "        class CustomAvatar(avatar.AvatarBase):",
            "",
            "            def getUserAvatar(self, email, size, defaultAvatarUrl):",
            "                return defer.succeed((b\"image/png\", email +",
            "                                      str(size).encode('utf-8') +",
            "                                      defaultAvatarUrl))",
            "",
            "        master = self.make_master(",
            "            url='http://a/b/', auth=auth.NoAuth(), avatar_methods=[CustomAvatar()])",
            "        rsrc = avatar.AvatarResource(master)",
            "        rsrc.reconfigResource(master.config)",
            "",
            "        res = yield self.render_resource(rsrc, b'/?email=foo')",
            "        self.assertEqual(res, b\"foo32http://a/b/img/nobody.png\")",
            "",
            "    @defer.inlineCallbacks",
            "    def test_custom_not_found(self):",
            "        # use gravatar if the custom avatar fail to return a response",
            "        class CustomAvatar(avatar.AvatarBase):",
            "",
            "            def getUserAvatar(self, email, size, defaultAvatarUrl):",
            "                return defer.succeed(None)",
            "",
            "        master = self.make_master(url=b'http://a/b/', auth=auth.NoAuth(),",
            "                                  avatar_methods=[CustomAvatar(), avatar.AvatarGravatar()])",
            "        rsrc = avatar.AvatarResource(master)",
            "        rsrc.reconfigResource(master.config)",
            "",
            "        res = yield self.render_resource(rsrc, b'/?email=foo')",
            "        self.assertEqual(res, dict(redirected=b'//www.gravatar.com/avatar/acbd18db4cc2f85ce'",
            "                         b'def654fccc4a4d8?d=retro&s=32'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "45": [
                "AvatarResource",
                "test_gravatar"
            ],
            "46": [
                "AvatarResource",
                "test_gravatar"
            ],
            "79": [
                "AvatarResource",
                "test_custom_not_found"
            ],
            "80": [
                "AvatarResource",
                "test_custom_not_found"
            ]
        },
        "addLocation": []
    },
    "master/buildbot/test/unit/test_www_oauth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": 426,
                "PatchRowcode": "         res = yield self.render_resource(rsrc, b'/')"
            },
            "1": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 427,
                "PatchRowcode": "         rsrc.auth.getLoginURL.assert_called_once_with(None)"
            },
            "2": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 428,
                "PatchRowcode": "         rsrc.auth.verifyCode.assert_not_called()"
            },
            "3": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(res, {'redirected': '://'})"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+        self.assertEqual(res, {'redirected': b'://'})"
            },
            "5": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": 430,
                "PatchRowcode": "         rsrc.auth.getLoginURL.reset_mock()"
            },
            "6": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 431,
                "PatchRowcode": "         rsrc.auth.verifyCode.reset_mock()"
            },
            "7": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "         res = yield self.render_resource(rsrc, b'/?code=code!')"
            },
            "8": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "         rsrc.auth.getLoginURL.assert_not_called()"
            },
            "9": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "         rsrc.auth.verifyCode.assert_called_once_with(b\"code!\")"
            },
            "10": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "         self.assertEqual(self.master.session.user_info, {'username': 'bar'})"
            },
            "11": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(res, {'redirected': '://me'})"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 436,
                "PatchRowcode": "+        self.assertEqual(res, {'redirected': b'://me'})"
            },
            "13": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "         res = yield self.render_resource(rsrc, b'/?token=token!')"
            },
            "14": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "         rsrc.auth.getLoginURL.assert_not_called()"
            },
            "15": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "         rsrc.auth.acceptToken.assert_called_once_with(b\"token!\")"
            },
            "16": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 440,
                "PatchRowcode": "         self.assertEqual(self.master.session.user_info, {'username': 'bar'})"
            },
            "17": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(res, {'redirected': '://me'})"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+        self.assertEqual(res, {'redirected': b'://me'})"
            },
            "19": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 442,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 443,
                "PatchRowcode": "     def test_getConfig(self):"
            },
            "21": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 444,
                "PatchRowcode": "         self.assertEqual(self.githubAuth.getConfigDict(), {'fa_icon': 'fa-github', 'autologin': False,"
            }
        },
        "frontPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "import json",
            "import os",
            "import webbrowser",
            "",
            "import mock",
            "",
            "from twisted.internet import defer",
            "from twisted.internet import reactor",
            "from twisted.internet import threads",
            "from twisted.python import failure",
            "from twisted.trial import unittest",
            "from twisted.web.resource import Resource",
            "from twisted.web.server import Site",
            "",
            "from buildbot.test.util import www",
            "from buildbot.test.util.config import ConfigErrorsMixin",
            "from buildbot.util import bytes2unicode",
            "",
            "try:",
            "    import requests",
            "except ImportError:",
            "    requests = None",
            "",
            "",
            "if requests:",
            "    from buildbot.www import oauth2  # pylint: disable=ungrouped-imports",
            "",
            "",
            "class FakeResponse(object):",
            "",
            "    def __init__(self, _json):",
            "        self.json = lambda: _json",
            "        self.content = json.dumps(_json)",
            "",
            "    def raise_for_status(self):",
            "        pass",
            "",
            "",
            "class OAuth2Auth(www.WwwTestMixin, ConfigErrorsMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        if requests is None:",
            "            raise unittest.SkipTest(\"Need to install requests to test oauth2\")",
            "",
            "        self.patch(requests, 'request', mock.Mock(spec=requests.request))",
            "        self.patch(requests, 'post', mock.Mock(spec=requests.post))",
            "        self.patch(requests, 'get', mock.Mock(spec=requests.get))",
            "",
            "        self.googleAuth = oauth2.GoogleAuth(\"ggclientID\", \"clientSECRET\")",
            "        self.githubAuth = oauth2.GitHubAuth(\"ghclientID\", \"clientSECRET\")",
            "        self.githubAuth_v4 = oauth2.GitHubAuth(",
            "            \"ghclientID\", \"clientSECRET\", apiVersion=4)",
            "        self.githubAuth_v4_teams = oauth2.GitHubAuth(",
            "            \"ghclientID\", \"clientSECRET\", apiVersion=4, getTeamsMembership=True)",
            "        self.githubAuthEnt = oauth2.GitHubAuth(",
            "            \"ghclientID\", \"clientSECRET\", serverURL=\"https://git.corp.fakecorp.com\")",
            "        self.gitlabAuth = oauth2.GitLabAuth(",
            "            \"https://gitlab.test/\", \"glclientID\", \"clientSECRET\")",
            "        self.bitbucketAuth = oauth2.BitbucketAuth(\"bbclientID\", \"clientSECRET\")",
            "",
            "        for auth in [self.googleAuth, self.githubAuth, self.githubAuth_v4, self.githubAuth_v4_teams,",
            "                     self.githubAuthEnt, self.gitlabAuth, self.bitbucketAuth]:",
            "            self._master = master = self.make_master(url='h:/a/b/', auth=auth)",
            "            auth.reconfigAuth(master, master.config)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getGoogleLoginURL(self):",
            "        res = yield self.googleAuth.getLoginURL('http://redir')",
            "        exp = (\"https://accounts.google.com/o/oauth2/auth?client_id=ggclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+\"",
            "               \"https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.googleAuth.getLoginURL(None)",
            "        exp = (\"https://accounts.google.com/o/oauth2/auth?client_id=ggclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+\"",
            "               \"https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile\")",
            "",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getGithubLoginURL(self):",
            "        res = yield self.githubAuth.getLoginURL('http://redir')",
            "        exp = (\"https://github.com/login/oauth/authorize?client_id=ghclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=user%3Aemail+read%3Aorg&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.githubAuth.getLoginURL(None)",
            "        exp = (\"https://github.com/login/oauth/authorize?client_id=ghclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=user%3Aemail+read%3Aorg\")",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getGithubELoginURL(self):",
            "        res = yield self.githubAuthEnt.getLoginURL('http://redir')",
            "        exp = (\"https://git.corp.fakecorp.com/login/oauth/authorize?client_id=ghclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=user%3Aemail+read%3Aorg&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.githubAuthEnt.getLoginURL(None)",
            "        exp = (\"https://git.corp.fakecorp.com/login/oauth/authorize?client_id=ghclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=user%3Aemail+read%3Aorg\")",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getGitLabLoginURL(self):",
            "        res = yield self.gitlabAuth.getLoginURL('http://redir')",
            "        exp = (\"https://gitlab.test/oauth/authorize\"",
            "               \"?client_id=glclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&\"",
            "               \"response_type=code&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.gitlabAuth.getLoginURL(None)",
            "        exp = (\"https://gitlab.test/oauth/authorize\"",
            "               \"?client_id=glclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&\"",
            "               \"response_type=code\")",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getBitbucketLoginURL(self):",
            "        res = yield self.bitbucketAuth.getLoginURL('http://redir')",
            "        exp = (\"https://bitbucket.org/site/oauth2/authorize?\"",
            "               \"client_id=bbclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&\"",
            "               \"response_type=code&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.bitbucketAuth.getLoginURL(None)",
            "        exp = (\"https://bitbucket.org/site/oauth2/authorize?\"",
            "               \"client_id=bbclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&\"",
            "               \"response_type=code\")",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GoogleVerifyCode(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.googleAuth.get = mock.Mock(side_effect=[dict(",
            "            name=\"foo bar\",",
            "            email=\"bar@foo\", picture=\"http://pic\")])",
            "        res = yield self.googleAuth.verifyCode(\"code!\")",
            "        self.assertEqual({'avatar_url': 'http://pic', 'email': 'bar@foo',",
            "                          'full_name': 'foo bar', 'username': 'bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GithubVerifyCode(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.githubAuth.get = mock.Mock(side_effect=[",
            "            dict(  # /user",
            "                login=\"bar\",",
            "                name=\"foo bar\",",
            "                email=\"buzz@bar\"),",
            "            [  # /user/emails",
            "                {'email': 'buzz@bar', 'verified': True, 'primary': False},",
            "                {'email': 'bar@foo', 'verified': True, 'primary': True}],",
            "            [  # /user/orgs",
            "                dict(login=\"hello\"),",
            "                dict(login=\"grp\"),",
            "            ]])",
            "        res = yield self.githubAuth.verifyCode(\"code!\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          'groups': [\"hello\", \"grp\"],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GithubAcceptToken(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.githubAuth.get = mock.Mock(side_effect=[",
            "            dict(  # /user",
            "                login=\"bar\",",
            "                name=\"foo bar\",",
            "                email=\"buzz@bar\"),",
            "            [  # /user/emails",
            "                {'email': 'buzz@bar', 'verified': True, 'primary': False},",
            "                {'email': 'bar@foo', 'verified': True, 'primary': True}],",
            "            [  # /user/orgs",
            "                dict(login=\"hello\"),",
            "                dict(login=\"grp\"),",
            "            ]])",
            "        res = yield self.githubAuth.acceptToken(\"TOK3N\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          'groups': [\"hello\", \"grp\"],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GithubAcceptToken_v4(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.githubAuth_v4.post = mock.Mock(side_effect=[",
            "            {",
            "                'data': {",
            "                    'viewer': {",
            "                        'organizations': {",
            "                            'edges': [",
            "                                {",
            "                                    'node': {",
            "                                        'login': 'hello'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'login': 'grp'",
            "                                    }",
            "                                }",
            "                            ]",
            "                        },",
            "                        'login': 'bar',",
            "                        'email': 'bar@foo',",
            "                        'name': 'foo bar'",
            "                    }",
            "                }",
            "            }",
            "        ])",
            "        res = yield self.githubAuth_v4.acceptToken(\"TOK3N\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          'groups': [\"hello\", \"grp\"],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GithubAcceptToken_v4_teams(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.githubAuth_v4_teams.post = mock.Mock(side_effect=[",
            "            {",
            "                'data': {",
            "                    'viewer': {",
            "                        'organizations': {",
            "                            'edges': [",
            "                                {",
            "                                    'node': {",
            "                                        'login': 'hello'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'login': 'grp'",
            "                                    }",
            "                                }",
            "                            ]",
            "                        },",
            "                        'login': 'bar',",
            "                        'email': 'bar@foo',",
            "                        'name': 'foo bar'",
            "                    }",
            "                }",
            "            },",
            "            {",
            "                'data': {",
            "                    'hello': {",
            "                        'teams': {",
            "                            'edges': [",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'developers',",
            "                                        'slug': 'develpers'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'contributors',",
            "                                        'slug': 'contributors'",
            "                                    }",
            "                                }",
            "                            ]",
            "                        }",
            "                    },",
            "                    'grp': {",
            "                        'teams': {",
            "                            'edges': [",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'developers',",
            "                                        'slug': 'develpers'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'contributors',",
            "                                        'slug': 'contributors'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'committers',",
            "                                        'slug': 'committers'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'Team with spaces and caps',",
            "                                        'slug': 'team-with-spaces-and-caps'",
            "                                    }",
            "                                },",
            "                            ]",
            "                        }",
            "                    },",
            "                }",
            "            }",
            "        ])",
            "        res = yield self.githubAuth_v4_teams.acceptToken(\"TOK3N\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          'groups': [",
            "                              'hello',",
            "                              'grp',",
            "                              'grp/Team with spaces and caps',",
            "                              'grp/committers',",
            "                              'grp/contributors',",
            "                              'grp/developers',",
            "                              'grp/develpers',",
            "                              'grp/team-with-spaces-and-caps',",
            "                              'hello/contributors',",
            "                              'hello/developers',",
            "                              'hello/develpers',",
            "                          ],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    def test_GitHubAuthBadApiVersion(self):",
            "        for bad_api_version in (2, 5, 'a'):",
            "            with self.assertRaisesConfigError(",
            "                    'GitHubAuth apiVersion must be 3 or 4 not '):",
            "                oauth2.GitHubAuth(\"ghclientID\", \"clientSECRET\",",
            "                                  apiVersion=bad_api_version)",
            "",
            "    def test_GitHubAuthRaiseErrorWithApiV3AndGetTeamMembership(self):",
            "        with self.assertRaisesConfigError(",
            "                'Retrieving team membership information using GitHubAuth is only possible using GitHub api v4.'):",
            "            oauth2.GitHubAuth(\"ghclientID\", \"clientSECRET\", apiVersion=3, getTeamsMembership=True)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GitlabVerifyCode(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.gitlabAuth.get = mock.Mock(side_effect=[",
            "            {  # /user",
            "                \"name\": \"Foo Bar\",",
            "                \"username\": \"fbar\",",
            "                \"id\": 5,",
            "                \"avatar_url\": \"https://avatar/fbar.png\",",
            "                \"email\": \"foo@bar\",",
            "                \"twitter\": \"fb\",",
            "            },",
            "            [  # /groups",
            "                {\"id\": 10, \"name\": \"Hello\", \"path\": \"hello\"},",
            "                {\"id\": 20, \"name\": \"Group\", \"path\": \"grp\"},",
            "            ]])",
            "        res = yield self.gitlabAuth.verifyCode(\"code!\")",
            "        self.assertEqual({\"full_name\": \"Foo Bar\",",
            "                          \"username\": \"fbar\",",
            "                          \"email\": \"foo@bar\",",
            "                          \"avatar_url\": \"https://avatar/fbar.png\",",
            "                          \"groups\": [\"hello\", \"grp\"]}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_BitbucketVerifyCode(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.bitbucketAuth.get = mock.Mock(side_effect=[",
            "            dict(  # /user",
            "                username=\"bar\",",
            "                display_name=\"foo bar\"),",
            "            dict(  # /user/emails",
            "                values=[",
            "                    {'email': 'buzz@bar', 'is_primary': False},",
            "                    {'email': 'bar@foo', 'is_primary': True}]),",
            "            dict(  # /teams?role=member",
            "                values=[",
            "                    {'username': 'hello'},",
            "                    {'username': 'grp'}])",
            "        ])",
            "        res = yield self.bitbucketAuth.verifyCode(\"code!\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          \"groups\": [\"hello\", \"grp\"],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_loginResource(self):",
            "        class fakeAuth(object):",
            "            homeUri = \"://me\"",
            "            getLoginURL = mock.Mock(side_effect=lambda x: defer.succeed(\"://\"))",
            "            verifyCode = mock.Mock(",
            "                side_effect=lambda code: defer.succeed({\"username\": \"bar\"}))",
            "            acceptToken = mock.Mock(",
            "                side_effect=lambda token: defer.succeed({\"username\": \"bar\"}))",
            "            userInfoProvider = None",
            "",
            "        rsrc = self.githubAuth.getLoginResource()",
            "        rsrc.auth = fakeAuth()",
            "        res = yield self.render_resource(rsrc, b'/')",
            "        rsrc.auth.getLoginURL.assert_called_once_with(None)",
            "        rsrc.auth.verifyCode.assert_not_called()",
            "        self.assertEqual(res, {'redirected': '://'})",
            "        rsrc.auth.getLoginURL.reset_mock()",
            "        rsrc.auth.verifyCode.reset_mock()",
            "        res = yield self.render_resource(rsrc, b'/?code=code!')",
            "        rsrc.auth.getLoginURL.assert_not_called()",
            "        rsrc.auth.verifyCode.assert_called_once_with(b\"code!\")",
            "        self.assertEqual(self.master.session.user_info, {'username': 'bar'})",
            "        self.assertEqual(res, {'redirected': '://me'})",
            "        res = yield self.render_resource(rsrc, b'/?token=token!')",
            "        rsrc.auth.getLoginURL.assert_not_called()",
            "        rsrc.auth.acceptToken.assert_called_once_with(b\"token!\")",
            "        self.assertEqual(self.master.session.user_info, {'username': 'bar'})",
            "        self.assertEqual(res, {'redirected': '://me'})",
            "",
            "    def test_getConfig(self):",
            "        self.assertEqual(self.githubAuth.getConfigDict(), {'fa_icon': 'fa-github', 'autologin': False,",
            "                                                           'name': 'GitHub', 'oauth2': True})",
            "        self.assertEqual(self.googleAuth.getConfigDict(), {'fa_icon': 'fa-google-plus', 'autologin': False,",
            "                                                           'name': 'Google', 'oauth2': True})",
            "        self.assertEqual(self.gitlabAuth.getConfigDict(), {'fa_icon': 'fa-git', 'autologin': False,",
            "                                                           'name': 'GitLab', 'oauth2': True})",
            "        self.assertEqual(self.bitbucketAuth.getConfigDict(), {'fa_icon': 'fa-bitbucket', 'autologin': False,",
            "                                                              'name': 'Bitbucket', 'oauth2': True})",
            "",
            "# unit tests are not very useful to write new oauth support",
            "# so following is an e2e test, which opens a browser, and do the oauth",
            "# negotiation. The browser window close in the end of the test",
            "",
            "# in order to use this tests, you need to create Github/Google ClientID (see doc on how to do it)",
            "# point OAUTHCONF environment variable to a file with following params:",
            "#  {",
            "#  \"GitHubAuth\": {",
            "#     \"CLIENTID\": \"XX",
            "#     \"CLIENTSECRET\": \"XX\"",
            "#  },",
            "#  \"GoogleAuth\": {",
            "#     \"CLIENTID\": \"XX\",",
            "#     \"CLIENTSECRET\": \"XX\"",
            "#  }",
            "#  \"GitLabAuth\": {",
            "#     \"INSTANCEURI\": \"XX\",",
            "#     \"CLIENTID\": \"XX\",",
            "#     \"CLIENTSECRET\": \"XX\"",
            "#  }",
            "#  }",
            "",
            "",
            "class OAuth2AuthGitHubE2E(www.WwwTestMixin, unittest.TestCase):",
            "    authClass = \"GitHubAuth\"",
            "",
            "    def _instantiateAuth(self, cls, config):",
            "        return cls(config[\"CLIENTID\"], config[\"CLIENTSECRET\"])",
            "",
            "    def setUp(self):",
            "        if requests is None:",
            "            raise unittest.SkipTest(\"Need to install requests to test oauth2\")",
            "",
            "        if \"OAUTHCONF\" not in os.environ:",
            "            raise unittest.SkipTest(",
            "                \"Need to pass OAUTHCONF path to json file via environ to run this e2e test\")",
            "",
            "        with open(os.environ['OAUTHCONF']) as f:",
            "            jsonData = f.read()",
            "        config = json.loads(jsonData)[self.authClass]",
            "        from buildbot.www import oauth2",
            "        self.auth = self._instantiateAuth(",
            "            getattr(oauth2, self.authClass), config)",
            "",
            "        # 5000 has to be hardcoded, has oauth clientids are bound to a fully",
            "        # classified web site",
            "        master = self.make_master(url='http://localhost:5000/', auth=self.auth)",
            "        self.auth.reconfigAuth(master, master.config)",
            "",
            "    def tearDown(self):",
            "        from twisted.internet.tcp import Server",
            "        # browsers has the bad habit on not closing the persistent",
            "        # connections, so we need to hack them away to make trial happy",
            "        f = failure.Failure(Exception(\"test end\"))",
            "        for reader in reactor.getReaders():",
            "            if isinstance(reader, Server):",
            "                reader.connectionLost(f)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_E2E(self):",
            "        d = defer.Deferred()",
            "        import twisted",
            "        twisted.web.http._logDateTimeUsers = 1",
            "",
            "        class HomePage(Resource):",
            "            isLeaf = True",
            "",
            "            def render_GET(self, request):",
            "                info = request.getSession().user_info",
            "                reactor.callLater(0, d.callback, info)",
            "                return (b\"<html><script>setTimeout(close,1000)</script><body>WORKED: \" +",
            "                        info + b\"</body></html>\")",
            "",
            "        class MySite(Site):",
            "",
            "            def makeSession(self):",
            "                uid = self._mkuid()",
            "                session = self.sessions[uid] = self.sessionFactory(self, uid)",
            "                return session",
            "        root = Resource()",
            "        root.putChild(b\"\", HomePage())",
            "        auth = Resource()",
            "        root.putChild(b'auth', auth)",
            "        auth.putChild(b'login', self.auth.getLoginResource())",
            "        site = MySite(root)",
            "        listener = reactor.listenTCP(5000, site)",
            "",
            "        def thd():",
            "            res = requests.get('http://localhost:5000/auth/login')",
            "            content = bytes2unicode(res.content)",
            "            webbrowser.open(content)",
            "        threads.deferToThread(thd)",
            "        res = yield d",
            "        yield listener.stopListening()",
            "        yield site.stopFactory()",
            "",
            "        self.assertIn(\"full_name\", res)",
            "        self.assertIn(\"email\", res)",
            "        self.assertIn(\"username\", res)",
            "",
            "",
            "class OAuth2AuthGoogleE2E(OAuth2AuthGitHubE2E):",
            "    authClass = \"GoogleAuth\"",
            "",
            "",
            "class OAuth2AuthGitLabE2E(OAuth2AuthGitHubE2E):",
            "    authClass = \"GitLabAuth\"",
            "",
            "    def _instantiateAuth(self, cls, config):",
            "        return cls(config[\"INSTANCEURI\"], config[\"CLIENTID\"], config[\"CLIENTSECRET\"])"
        ],
        "afterPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "import json",
            "import os",
            "import webbrowser",
            "",
            "import mock",
            "",
            "from twisted.internet import defer",
            "from twisted.internet import reactor",
            "from twisted.internet import threads",
            "from twisted.python import failure",
            "from twisted.trial import unittest",
            "from twisted.web.resource import Resource",
            "from twisted.web.server import Site",
            "",
            "from buildbot.test.util import www",
            "from buildbot.test.util.config import ConfigErrorsMixin",
            "from buildbot.util import bytes2unicode",
            "",
            "try:",
            "    import requests",
            "except ImportError:",
            "    requests = None",
            "",
            "",
            "if requests:",
            "    from buildbot.www import oauth2  # pylint: disable=ungrouped-imports",
            "",
            "",
            "class FakeResponse(object):",
            "",
            "    def __init__(self, _json):",
            "        self.json = lambda: _json",
            "        self.content = json.dumps(_json)",
            "",
            "    def raise_for_status(self):",
            "        pass",
            "",
            "",
            "class OAuth2Auth(www.WwwTestMixin, ConfigErrorsMixin, unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        if requests is None:",
            "            raise unittest.SkipTest(\"Need to install requests to test oauth2\")",
            "",
            "        self.patch(requests, 'request', mock.Mock(spec=requests.request))",
            "        self.patch(requests, 'post', mock.Mock(spec=requests.post))",
            "        self.patch(requests, 'get', mock.Mock(spec=requests.get))",
            "",
            "        self.googleAuth = oauth2.GoogleAuth(\"ggclientID\", \"clientSECRET\")",
            "        self.githubAuth = oauth2.GitHubAuth(\"ghclientID\", \"clientSECRET\")",
            "        self.githubAuth_v4 = oauth2.GitHubAuth(",
            "            \"ghclientID\", \"clientSECRET\", apiVersion=4)",
            "        self.githubAuth_v4_teams = oauth2.GitHubAuth(",
            "            \"ghclientID\", \"clientSECRET\", apiVersion=4, getTeamsMembership=True)",
            "        self.githubAuthEnt = oauth2.GitHubAuth(",
            "            \"ghclientID\", \"clientSECRET\", serverURL=\"https://git.corp.fakecorp.com\")",
            "        self.gitlabAuth = oauth2.GitLabAuth(",
            "            \"https://gitlab.test/\", \"glclientID\", \"clientSECRET\")",
            "        self.bitbucketAuth = oauth2.BitbucketAuth(\"bbclientID\", \"clientSECRET\")",
            "",
            "        for auth in [self.googleAuth, self.githubAuth, self.githubAuth_v4, self.githubAuth_v4_teams,",
            "                     self.githubAuthEnt, self.gitlabAuth, self.bitbucketAuth]:",
            "            self._master = master = self.make_master(url='h:/a/b/', auth=auth)",
            "            auth.reconfigAuth(master, master.config)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getGoogleLoginURL(self):",
            "        res = yield self.googleAuth.getLoginURL('http://redir')",
            "        exp = (\"https://accounts.google.com/o/oauth2/auth?client_id=ggclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+\"",
            "               \"https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.googleAuth.getLoginURL(None)",
            "        exp = (\"https://accounts.google.com/o/oauth2/auth?client_id=ggclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+\"",
            "               \"https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile\")",
            "",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getGithubLoginURL(self):",
            "        res = yield self.githubAuth.getLoginURL('http://redir')",
            "        exp = (\"https://github.com/login/oauth/authorize?client_id=ghclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=user%3Aemail+read%3Aorg&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.githubAuth.getLoginURL(None)",
            "        exp = (\"https://github.com/login/oauth/authorize?client_id=ghclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=user%3Aemail+read%3Aorg\")",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getGithubELoginURL(self):",
            "        res = yield self.githubAuthEnt.getLoginURL('http://redir')",
            "        exp = (\"https://git.corp.fakecorp.com/login/oauth/authorize?client_id=ghclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=user%3Aemail+read%3Aorg&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.githubAuthEnt.getLoginURL(None)",
            "        exp = (\"https://git.corp.fakecorp.com/login/oauth/authorize?client_id=ghclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&response_type=code&\"",
            "               \"scope=user%3Aemail+read%3Aorg\")",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getGitLabLoginURL(self):",
            "        res = yield self.gitlabAuth.getLoginURL('http://redir')",
            "        exp = (\"https://gitlab.test/oauth/authorize\"",
            "               \"?client_id=glclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&\"",
            "               \"response_type=code&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.gitlabAuth.getLoginURL(None)",
            "        exp = (\"https://gitlab.test/oauth/authorize\"",
            "               \"?client_id=glclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&\"",
            "               \"response_type=code\")",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_getBitbucketLoginURL(self):",
            "        res = yield self.bitbucketAuth.getLoginURL('http://redir')",
            "        exp = (\"https://bitbucket.org/site/oauth2/authorize?\"",
            "               \"client_id=bbclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&\"",
            "               \"response_type=code&\"",
            "               \"state=redirect%3Dhttp%253A%252F%252Fredir\")",
            "        self.assertEqual(res, exp)",
            "        res = yield self.bitbucketAuth.getLoginURL(None)",
            "        exp = (\"https://bitbucket.org/site/oauth2/authorize?\"",
            "               \"client_id=bbclientID&\"",
            "               \"redirect_uri=h%3A%2Fa%2Fb%2Fauth%2Flogin&\"",
            "               \"response_type=code\")",
            "        self.assertEqual(res, exp)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GoogleVerifyCode(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.googleAuth.get = mock.Mock(side_effect=[dict(",
            "            name=\"foo bar\",",
            "            email=\"bar@foo\", picture=\"http://pic\")])",
            "        res = yield self.googleAuth.verifyCode(\"code!\")",
            "        self.assertEqual({'avatar_url': 'http://pic', 'email': 'bar@foo',",
            "                          'full_name': 'foo bar', 'username': 'bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GithubVerifyCode(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.githubAuth.get = mock.Mock(side_effect=[",
            "            dict(  # /user",
            "                login=\"bar\",",
            "                name=\"foo bar\",",
            "                email=\"buzz@bar\"),",
            "            [  # /user/emails",
            "                {'email': 'buzz@bar', 'verified': True, 'primary': False},",
            "                {'email': 'bar@foo', 'verified': True, 'primary': True}],",
            "            [  # /user/orgs",
            "                dict(login=\"hello\"),",
            "                dict(login=\"grp\"),",
            "            ]])",
            "        res = yield self.githubAuth.verifyCode(\"code!\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          'groups': [\"hello\", \"grp\"],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GithubAcceptToken(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.githubAuth.get = mock.Mock(side_effect=[",
            "            dict(  # /user",
            "                login=\"bar\",",
            "                name=\"foo bar\",",
            "                email=\"buzz@bar\"),",
            "            [  # /user/emails",
            "                {'email': 'buzz@bar', 'verified': True, 'primary': False},",
            "                {'email': 'bar@foo', 'verified': True, 'primary': True}],",
            "            [  # /user/orgs",
            "                dict(login=\"hello\"),",
            "                dict(login=\"grp\"),",
            "            ]])",
            "        res = yield self.githubAuth.acceptToken(\"TOK3N\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          'groups': [\"hello\", \"grp\"],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GithubAcceptToken_v4(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.githubAuth_v4.post = mock.Mock(side_effect=[",
            "            {",
            "                'data': {",
            "                    'viewer': {",
            "                        'organizations': {",
            "                            'edges': [",
            "                                {",
            "                                    'node': {",
            "                                        'login': 'hello'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'login': 'grp'",
            "                                    }",
            "                                }",
            "                            ]",
            "                        },",
            "                        'login': 'bar',",
            "                        'email': 'bar@foo',",
            "                        'name': 'foo bar'",
            "                    }",
            "                }",
            "            }",
            "        ])",
            "        res = yield self.githubAuth_v4.acceptToken(\"TOK3N\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          'groups': [\"hello\", \"grp\"],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GithubAcceptToken_v4_teams(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.githubAuth_v4_teams.post = mock.Mock(side_effect=[",
            "            {",
            "                'data': {",
            "                    'viewer': {",
            "                        'organizations': {",
            "                            'edges': [",
            "                                {",
            "                                    'node': {",
            "                                        'login': 'hello'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'login': 'grp'",
            "                                    }",
            "                                }",
            "                            ]",
            "                        },",
            "                        'login': 'bar',",
            "                        'email': 'bar@foo',",
            "                        'name': 'foo bar'",
            "                    }",
            "                }",
            "            },",
            "            {",
            "                'data': {",
            "                    'hello': {",
            "                        'teams': {",
            "                            'edges': [",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'developers',",
            "                                        'slug': 'develpers'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'contributors',",
            "                                        'slug': 'contributors'",
            "                                    }",
            "                                }",
            "                            ]",
            "                        }",
            "                    },",
            "                    'grp': {",
            "                        'teams': {",
            "                            'edges': [",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'developers',",
            "                                        'slug': 'develpers'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'contributors',",
            "                                        'slug': 'contributors'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'committers',",
            "                                        'slug': 'committers'",
            "                                    }",
            "                                },",
            "                                {",
            "                                    'node': {",
            "                                        'name': 'Team with spaces and caps',",
            "                                        'slug': 'team-with-spaces-and-caps'",
            "                                    }",
            "                                },",
            "                            ]",
            "                        }",
            "                    },",
            "                }",
            "            }",
            "        ])",
            "        res = yield self.githubAuth_v4_teams.acceptToken(\"TOK3N\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          'groups': [",
            "                              'hello',",
            "                              'grp',",
            "                              'grp/Team with spaces and caps',",
            "                              'grp/committers',",
            "                              'grp/contributors',",
            "                              'grp/developers',",
            "                              'grp/develpers',",
            "                              'grp/team-with-spaces-and-caps',",
            "                              'hello/contributors',",
            "                              'hello/developers',",
            "                              'hello/develpers',",
            "                          ],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    def test_GitHubAuthBadApiVersion(self):",
            "        for bad_api_version in (2, 5, 'a'):",
            "            with self.assertRaisesConfigError(",
            "                    'GitHubAuth apiVersion must be 3 or 4 not '):",
            "                oauth2.GitHubAuth(\"ghclientID\", \"clientSECRET\",",
            "                                  apiVersion=bad_api_version)",
            "",
            "    def test_GitHubAuthRaiseErrorWithApiV3AndGetTeamMembership(self):",
            "        with self.assertRaisesConfigError(",
            "                'Retrieving team membership information using GitHubAuth is only possible using GitHub api v4.'):",
            "            oauth2.GitHubAuth(\"ghclientID\", \"clientSECRET\", apiVersion=3, getTeamsMembership=True)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_GitlabVerifyCode(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.gitlabAuth.get = mock.Mock(side_effect=[",
            "            {  # /user",
            "                \"name\": \"Foo Bar\",",
            "                \"username\": \"fbar\",",
            "                \"id\": 5,",
            "                \"avatar_url\": \"https://avatar/fbar.png\",",
            "                \"email\": \"foo@bar\",",
            "                \"twitter\": \"fb\",",
            "            },",
            "            [  # /groups",
            "                {\"id\": 10, \"name\": \"Hello\", \"path\": \"hello\"},",
            "                {\"id\": 20, \"name\": \"Group\", \"path\": \"grp\"},",
            "            ]])",
            "        res = yield self.gitlabAuth.verifyCode(\"code!\")",
            "        self.assertEqual({\"full_name\": \"Foo Bar\",",
            "                          \"username\": \"fbar\",",
            "                          \"email\": \"foo@bar\",",
            "                          \"avatar_url\": \"https://avatar/fbar.png\",",
            "                          \"groups\": [\"hello\", \"grp\"]}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_BitbucketVerifyCode(self):",
            "        requests.get.side_effect = []",
            "        requests.post.side_effect = [",
            "            FakeResponse(dict(access_token=\"TOK3N\"))]",
            "        self.bitbucketAuth.get = mock.Mock(side_effect=[",
            "            dict(  # /user",
            "                username=\"bar\",",
            "                display_name=\"foo bar\"),",
            "            dict(  # /user/emails",
            "                values=[",
            "                    {'email': 'buzz@bar', 'is_primary': False},",
            "                    {'email': 'bar@foo', 'is_primary': True}]),",
            "            dict(  # /teams?role=member",
            "                values=[",
            "                    {'username': 'hello'},",
            "                    {'username': 'grp'}])",
            "        ])",
            "        res = yield self.bitbucketAuth.verifyCode(\"code!\")",
            "        self.assertEqual({'email': 'bar@foo',",
            "                          'username': 'bar',",
            "                          \"groups\": [\"hello\", \"grp\"],",
            "                          'full_name': 'foo bar'}, res)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_loginResource(self):",
            "        class fakeAuth(object):",
            "            homeUri = \"://me\"",
            "            getLoginURL = mock.Mock(side_effect=lambda x: defer.succeed(\"://\"))",
            "            verifyCode = mock.Mock(",
            "                side_effect=lambda code: defer.succeed({\"username\": \"bar\"}))",
            "            acceptToken = mock.Mock(",
            "                side_effect=lambda token: defer.succeed({\"username\": \"bar\"}))",
            "            userInfoProvider = None",
            "",
            "        rsrc = self.githubAuth.getLoginResource()",
            "        rsrc.auth = fakeAuth()",
            "        res = yield self.render_resource(rsrc, b'/')",
            "        rsrc.auth.getLoginURL.assert_called_once_with(None)",
            "        rsrc.auth.verifyCode.assert_not_called()",
            "        self.assertEqual(res, {'redirected': b'://'})",
            "        rsrc.auth.getLoginURL.reset_mock()",
            "        rsrc.auth.verifyCode.reset_mock()",
            "        res = yield self.render_resource(rsrc, b'/?code=code!')",
            "        rsrc.auth.getLoginURL.assert_not_called()",
            "        rsrc.auth.verifyCode.assert_called_once_with(b\"code!\")",
            "        self.assertEqual(self.master.session.user_info, {'username': 'bar'})",
            "        self.assertEqual(res, {'redirected': b'://me'})",
            "        res = yield self.render_resource(rsrc, b'/?token=token!')",
            "        rsrc.auth.getLoginURL.assert_not_called()",
            "        rsrc.auth.acceptToken.assert_called_once_with(b\"token!\")",
            "        self.assertEqual(self.master.session.user_info, {'username': 'bar'})",
            "        self.assertEqual(res, {'redirected': b'://me'})",
            "",
            "    def test_getConfig(self):",
            "        self.assertEqual(self.githubAuth.getConfigDict(), {'fa_icon': 'fa-github', 'autologin': False,",
            "                                                           'name': 'GitHub', 'oauth2': True})",
            "        self.assertEqual(self.googleAuth.getConfigDict(), {'fa_icon': 'fa-google-plus', 'autologin': False,",
            "                                                           'name': 'Google', 'oauth2': True})",
            "        self.assertEqual(self.gitlabAuth.getConfigDict(), {'fa_icon': 'fa-git', 'autologin': False,",
            "                                                           'name': 'GitLab', 'oauth2': True})",
            "        self.assertEqual(self.bitbucketAuth.getConfigDict(), {'fa_icon': 'fa-bitbucket', 'autologin': False,",
            "                                                              'name': 'Bitbucket', 'oauth2': True})",
            "",
            "# unit tests are not very useful to write new oauth support",
            "# so following is an e2e test, which opens a browser, and do the oauth",
            "# negotiation. The browser window close in the end of the test",
            "",
            "# in order to use this tests, you need to create Github/Google ClientID (see doc on how to do it)",
            "# point OAUTHCONF environment variable to a file with following params:",
            "#  {",
            "#  \"GitHubAuth\": {",
            "#     \"CLIENTID\": \"XX",
            "#     \"CLIENTSECRET\": \"XX\"",
            "#  },",
            "#  \"GoogleAuth\": {",
            "#     \"CLIENTID\": \"XX\",",
            "#     \"CLIENTSECRET\": \"XX\"",
            "#  }",
            "#  \"GitLabAuth\": {",
            "#     \"INSTANCEURI\": \"XX\",",
            "#     \"CLIENTID\": \"XX\",",
            "#     \"CLIENTSECRET\": \"XX\"",
            "#  }",
            "#  }",
            "",
            "",
            "class OAuth2AuthGitHubE2E(www.WwwTestMixin, unittest.TestCase):",
            "    authClass = \"GitHubAuth\"",
            "",
            "    def _instantiateAuth(self, cls, config):",
            "        return cls(config[\"CLIENTID\"], config[\"CLIENTSECRET\"])",
            "",
            "    def setUp(self):",
            "        if requests is None:",
            "            raise unittest.SkipTest(\"Need to install requests to test oauth2\")",
            "",
            "        if \"OAUTHCONF\" not in os.environ:",
            "            raise unittest.SkipTest(",
            "                \"Need to pass OAUTHCONF path to json file via environ to run this e2e test\")",
            "",
            "        with open(os.environ['OAUTHCONF']) as f:",
            "            jsonData = f.read()",
            "        config = json.loads(jsonData)[self.authClass]",
            "        from buildbot.www import oauth2",
            "        self.auth = self._instantiateAuth(",
            "            getattr(oauth2, self.authClass), config)",
            "",
            "        # 5000 has to be hardcoded, has oauth clientids are bound to a fully",
            "        # classified web site",
            "        master = self.make_master(url='http://localhost:5000/', auth=self.auth)",
            "        self.auth.reconfigAuth(master, master.config)",
            "",
            "    def tearDown(self):",
            "        from twisted.internet.tcp import Server",
            "        # browsers has the bad habit on not closing the persistent",
            "        # connections, so we need to hack them away to make trial happy",
            "        f = failure.Failure(Exception(\"test end\"))",
            "        for reader in reactor.getReaders():",
            "            if isinstance(reader, Server):",
            "                reader.connectionLost(f)",
            "",
            "    @defer.inlineCallbacks",
            "    def test_E2E(self):",
            "        d = defer.Deferred()",
            "        import twisted",
            "        twisted.web.http._logDateTimeUsers = 1",
            "",
            "        class HomePage(Resource):",
            "            isLeaf = True",
            "",
            "            def render_GET(self, request):",
            "                info = request.getSession().user_info",
            "                reactor.callLater(0, d.callback, info)",
            "                return (b\"<html><script>setTimeout(close,1000)</script><body>WORKED: \" +",
            "                        info + b\"</body></html>\")",
            "",
            "        class MySite(Site):",
            "",
            "            def makeSession(self):",
            "                uid = self._mkuid()",
            "                session = self.sessions[uid] = self.sessionFactory(self, uid)",
            "                return session",
            "        root = Resource()",
            "        root.putChild(b\"\", HomePage())",
            "        auth = Resource()",
            "        root.putChild(b'auth', auth)",
            "        auth.putChild(b'login', self.auth.getLoginResource())",
            "        site = MySite(root)",
            "        listener = reactor.listenTCP(5000, site)",
            "",
            "        def thd():",
            "            res = requests.get('http://localhost:5000/auth/login')",
            "            content = bytes2unicode(res.content)",
            "            webbrowser.open(content)",
            "        threads.deferToThread(thd)",
            "        res = yield d",
            "        yield listener.stopListening()",
            "        yield site.stopFactory()",
            "",
            "        self.assertIn(\"full_name\", res)",
            "        self.assertIn(\"email\", res)",
            "        self.assertIn(\"username\", res)",
            "",
            "",
            "class OAuth2AuthGoogleE2E(OAuth2AuthGitHubE2E):",
            "    authClass = \"GoogleAuth\"",
            "",
            "",
            "class OAuth2AuthGitLabE2E(OAuth2AuthGitHubE2E):",
            "    authClass = \"GitLabAuth\"",
            "",
            "    def _instantiateAuth(self, cls, config):",
            "        return cls(config[\"INSTANCEURI\"], config[\"CLIENTID\"], config[\"CLIENTSECRET\"])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "429": [
                "OAuth2Auth",
                "test_loginResource"
            ],
            "436": [
                "OAuth2Auth",
                "test_loginResource"
            ],
            "441": [
                "OAuth2Auth",
                "test_loginResource"
            ]
        },
        "addLocation": []
    },
    "master/buildbot/test/unit/test_www_resource.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         rsrc = resource.RedirectResource(master, b'foo')"
            },
            "1": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         self.render_resource(rsrc, b'/')"
            },
            "2": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         self.assertEqual(self.request.redirected_to, b'h:/a/b/foo')"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    def test_redirect_cr_lf(self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        master = self.make_master(url=b'h:/a/b/')"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        rsrc = resource.RedirectResource(master, b'foo\\r\\nbar')"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        self.render_resource(rsrc, b'/')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        self.assertEqual(self.request.redirected_to, b'h:/a/b/foo')"
            }
        },
        "frontPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "",
            "from twisted.trial import unittest",
            "",
            "from buildbot.test.util import www",
            "from buildbot.www import resource",
            "",
            "",
            "class ResourceSubclass(resource.Resource):",
            "",
            "    needsReconfig = True",
            "",
            "",
            "class Resource(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def test_base_url(self):",
            "        master = self.make_master(url=b'h:/a/b/')",
            "        rsrc = resource.Resource(master)",
            "        self.assertEqual(rsrc.base_url, b'h:/a/b/')",
            "",
            "    def test_reconfigResource_registration(self):",
            "        master = self.make_master(url=b'h:/a/b/')",
            "        rsrc = ResourceSubclass(master)",
            "        master.www.resourceNeedsReconfigs.assert_called_with(rsrc)",
            "",
            "",
            "class RedirectResource(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def test_redirect(self):",
            "        master = self.make_master(url=b'h:/a/b/')",
            "        rsrc = resource.RedirectResource(master, b'foo')",
            "        self.render_resource(rsrc, b'/')",
            "        self.assertEqual(self.request.redirected_to, b'h:/a/b/foo')"
        ],
        "afterPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "",
            "from twisted.trial import unittest",
            "",
            "from buildbot.test.util import www",
            "from buildbot.www import resource",
            "",
            "",
            "class ResourceSubclass(resource.Resource):",
            "",
            "    needsReconfig = True",
            "",
            "",
            "class Resource(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def test_base_url(self):",
            "        master = self.make_master(url=b'h:/a/b/')",
            "        rsrc = resource.Resource(master)",
            "        self.assertEqual(rsrc.base_url, b'h:/a/b/')",
            "",
            "    def test_reconfigResource_registration(self):",
            "        master = self.make_master(url=b'h:/a/b/')",
            "        rsrc = ResourceSubclass(master)",
            "        master.www.resourceNeedsReconfigs.assert_called_with(rsrc)",
            "",
            "",
            "class RedirectResource(www.WwwTestMixin, unittest.TestCase):",
            "",
            "    def test_redirect(self):",
            "        master = self.make_master(url=b'h:/a/b/')",
            "        rsrc = resource.RedirectResource(master, b'foo')",
            "        self.render_resource(rsrc, b'/')",
            "        self.assertEqual(self.request.redirected_to, b'h:/a/b/foo')",
            "",
            "    def test_redirect_cr_lf(self):",
            "        master = self.make_master(url=b'h:/a/b/')",
            "        rsrc = resource.RedirectResource(master, b'foo\\r\\nbar')",
            "        self.render_resource(rsrc, b'/')",
            "        self.assertEqual(self.request.redirected_to, b'h:/a/b/foo')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tensorflow.python.kernel_tests.data_structures.list_ops_test.ListOpsTest.testResourceVariableScatterGatherInt64",
            "master.buildbot.test.unit.test_www_resource.RedirectResource.self"
        ]
    },
    "master/buildbot/www/resource.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " # Copyright Buildbot Team Members"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+import re"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from twisted.internet import defer"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from twisted.python import log"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from twisted.web import resource"
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from buildbot.util import unicode2bytes"
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+_CR_LF_RE = re.compile(br\"[\\r\\n]+.*\")"
            },
            "12": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class Redirect(Error):"
            },
            "14": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+def protect_redirect_url(url):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    return _CR_LF_RE.sub(b\"\", url)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+class Redirect(Error):"
            },
            "20": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     def __init__(self, url):"
            },
            "21": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         Error.__init__(self, 302, \"redirect\")"
            },
            "22": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.url = url"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        self.url = protect_redirect_url(unicode2bytes(url))"
            },
            "24": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " class Resource(resource.Resource):"
            },
            "27": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     def render(self, request):"
            },
            "29": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         redir = self.base_url + self.basepath"
            },
            "30": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        request.redirect(redir)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        request.redirect(protect_redirect_url(redir))"
            },
            "32": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         return redir"
            }
        },
        "frontPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "",
            "from twisted.internet import defer",
            "from twisted.python import log",
            "from twisted.web import resource",
            "from twisted.web import server",
            "from twisted.web.error import Error",
            "",
            "from buildbot.util import unicode2bytes",
            "",
            "",
            "class Redirect(Error):",
            "",
            "    def __init__(self, url):",
            "        Error.__init__(self, 302, \"redirect\")",
            "        self.url = url",
            "",
            "",
            "class Resource(resource.Resource):",
            "",
            "    # if this is true for a class, then instances will have their",
            "    # reconfigResource(new_config) methods called on reconfig.",
            "    needsReconfig = False",
            "",
            "    # as a convenience, subclasses have a ``master`` attribute, a",
            "    # ``base_url`` attribute giving Buildbot's base URL,",
            "    # and ``static_url`` attribute giving Buildbot's static files URL",
            "",
            "    @property",
            "    def base_url(self):",
            "        return self.master.config.buildbotURL",
            "",
            "    def __init__(self, master):",
            "        resource.Resource.__init__(self)",
            "        self.master = master",
            "        if self.needsReconfig and master is not None:",
            "            master.www.resourceNeedsReconfigs(self)",
            "",
            "    def reconfigResource(self, new_config):",
            "        raise NotImplementedError",
            "",
            "    def asyncRenderHelper(self, request, _callable, writeError=None):",
            "        def writeErrorDefault(msg, errcode=400):",
            "            request.setResponseCode(errcode)",
            "            request.setHeader(b'content-type', b'text/plain; charset=utf-8')",
            "            request.write(msg)",
            "            request.finish()",
            "        if writeError is None:",
            "            writeError = writeErrorDefault",
            "        try:",
            "            d = _callable(request)",
            "        except Exception as e:",
            "            d = defer.fail(e)",
            "",
            "        @d.addCallback",
            "        def finish(s):",
            "            try:",
            "                if s is not None:",
            "                    request.write(s)",
            "                request.finish()",
            "            except RuntimeError:  # pragma: no-cover",
            "                # this occurs when the client has already disconnected; ignore",
            "                # it (see #2027)",
            "                log.msg(\"http client disconnected before results were sent\")",
            "",
            "        @d.addErrback",
            "        def failHttpRedirect(f):",
            "            f.trap(Redirect)",
            "            request.redirect(f.value.url)",
            "            request.finish()",
            "            return None",
            "",
            "        @d.addErrback",
            "        def failHttpError(f):",
            "            f.trap(Error)",
            "            e = f.value",
            "            message = unicode2bytes(e.message)",
            "            writeError(message, errcode=int(e.status))",
            "",
            "        @d.addErrback",
            "        def fail(f):",
            "            log.err(f, 'While rendering resource:')",
            "            try:",
            "                writeError(b'internal error - see logs', errcode=500)",
            "            except Exception:",
            "                try:",
            "                    request.finish()",
            "                except Exception:",
            "                    pass",
            "",
            "        return server.NOT_DONE_YET",
            "",
            "",
            "class RedirectResource(Resource):",
            "",
            "    def __init__(self, master, basepath):",
            "        Resource.__init__(self, master)",
            "        self.basepath = basepath",
            "",
            "    def render(self, request):",
            "        redir = self.base_url + self.basepath",
            "        request.redirect(redir)",
            "        return redir"
        ],
        "afterPatchFile": [
            "# This file is part of Buildbot.  Buildbot is free software: you can",
            "# redistribute it and/or modify it under the terms of the GNU General Public",
            "# License as published by the Free Software Foundation, version 2.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more",
            "# details.",
            "#",
            "# You should have received a copy of the GNU General Public License along with",
            "# this program; if not, write to the Free Software Foundation, Inc., 51",
            "# Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",
            "#",
            "# Copyright Buildbot Team Members",
            "",
            "",
            "import re",
            "",
            "from twisted.internet import defer",
            "from twisted.python import log",
            "from twisted.web import resource",
            "from twisted.web import server",
            "from twisted.web.error import Error",
            "",
            "from buildbot.util import unicode2bytes",
            "",
            "_CR_LF_RE = re.compile(br\"[\\r\\n]+.*\")",
            "",
            "",
            "def protect_redirect_url(url):",
            "    return _CR_LF_RE.sub(b\"\", url)",
            "",
            "",
            "class Redirect(Error):",
            "    def __init__(self, url):",
            "        Error.__init__(self, 302, \"redirect\")",
            "        self.url = protect_redirect_url(unicode2bytes(url))",
            "",
            "",
            "class Resource(resource.Resource):",
            "",
            "    # if this is true for a class, then instances will have their",
            "    # reconfigResource(new_config) methods called on reconfig.",
            "    needsReconfig = False",
            "",
            "    # as a convenience, subclasses have a ``master`` attribute, a",
            "    # ``base_url`` attribute giving Buildbot's base URL,",
            "    # and ``static_url`` attribute giving Buildbot's static files URL",
            "",
            "    @property",
            "    def base_url(self):",
            "        return self.master.config.buildbotURL",
            "",
            "    def __init__(self, master):",
            "        resource.Resource.__init__(self)",
            "        self.master = master",
            "        if self.needsReconfig and master is not None:",
            "            master.www.resourceNeedsReconfigs(self)",
            "",
            "    def reconfigResource(self, new_config):",
            "        raise NotImplementedError",
            "",
            "    def asyncRenderHelper(self, request, _callable, writeError=None):",
            "        def writeErrorDefault(msg, errcode=400):",
            "            request.setResponseCode(errcode)",
            "            request.setHeader(b'content-type', b'text/plain; charset=utf-8')",
            "            request.write(msg)",
            "            request.finish()",
            "        if writeError is None:",
            "            writeError = writeErrorDefault",
            "        try:",
            "            d = _callable(request)",
            "        except Exception as e:",
            "            d = defer.fail(e)",
            "",
            "        @d.addCallback",
            "        def finish(s):",
            "            try:",
            "                if s is not None:",
            "                    request.write(s)",
            "                request.finish()",
            "            except RuntimeError:  # pragma: no-cover",
            "                # this occurs when the client has already disconnected; ignore",
            "                # it (see #2027)",
            "                log.msg(\"http client disconnected before results were sent\")",
            "",
            "        @d.addErrback",
            "        def failHttpRedirect(f):",
            "            f.trap(Redirect)",
            "            request.redirect(f.value.url)",
            "            request.finish()",
            "            return None",
            "",
            "        @d.addErrback",
            "        def failHttpError(f):",
            "            f.trap(Error)",
            "            e = f.value",
            "            message = unicode2bytes(e.message)",
            "            writeError(message, errcode=int(e.status))",
            "",
            "        @d.addErrback",
            "        def fail(f):",
            "            log.err(f, 'While rendering resource:')",
            "            try:",
            "                writeError(b'internal error - see logs', errcode=500)",
            "            except Exception:",
            "                try:",
            "                    request.finish()",
            "                except Exception:",
            "                    pass",
            "",
            "        return server.NOT_DONE_YET",
            "",
            "",
            "class RedirectResource(Resource):",
            "",
            "    def __init__(self, master, basepath):",
            "        Resource.__init__(self, master)",
            "        self.basepath = basepath",
            "",
            "    def render(self, request):",
            "        redir = self.base_url + self.basepath",
            "        request.redirect(protect_redirect_url(redir))",
            "        return redir"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [
                "Redirect"
            ],
            "30": [
                "Redirect",
                "__init__"
            ],
            "116": [
                "RedirectResource",
                "render"
            ]
        },
        "addLocation": []
    }
}