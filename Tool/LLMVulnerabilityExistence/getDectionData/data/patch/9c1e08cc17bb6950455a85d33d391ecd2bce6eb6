{
    "requests_kerberos/kerberos_.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         if response.status_code == 401:"
            },
            "1": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "             _r = self.handle_401(response, **kwargs)"
            },
            "2": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "             log.debug(\"handle_response(): returning {0}\".format(_r))"
            },
            "3": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return _r"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+            return self.handle_response(_r, **kwargs)"
            },
            "5": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         else:"
            },
            "6": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "             _r = self.handle_other(response)"
            },
            "7": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "             log.debug(\"handle_response(): returning {0}\".format(_r))"
            }
        },
        "frontPatchFile": [
            "import kerberos",
            "import re",
            "import logging",
            "",
            "from requests.auth import AuthBase",
            "from requests.models import Response",
            "from requests.compat import urlparse, StringIO",
            "from requests.structures import CaseInsensitiveDict",
            "from requests.cookies import cookiejar_from_dict",
            "",
            "from .exceptions import MutualAuthenticationError",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "# Different types of mutual authentication:",
            "#  with mutual_authentication set to REQUIRED, all responses will be",
            "#   authenticated with the exception of errors. Errors will have their contents",
            "#   and headers stripped. If a non-error response cannot be authenticated, a",
            "#   MutualAuthenticationError exception will be raised.",
            "# with mutual_authentication set to OPTIONAL, mutual authentication will be",
            "#   attempted if supported, and if supported and failed, a",
            "#   MutualAuthenticationError exception will be raised. Responses which do not",
            "#   support mutual authentication will be returned directly to the user.",
            "# with mutual_authentication set to DISABLED, mutual authentication will not be",
            "#   attempted, even if supported.",
            "REQUIRED = 1",
            "OPTIONAL = 2",
            "DISABLED = 3",
            "",
            "",
            "class SanitizedResponse(Response):",
            "    \"\"\"The :class:`Response <Response>` object, which contains a server's",
            "    response to an HTTP request.",
            "",
            "    This differs from `requests.models.Response` in that it's headers and",
            "    content have been sanitized. This is only used for HTTP Error messages",
            "    which do not support mutual authentication when mutual authentication is",
            "    required.\"\"\"",
            "",
            "    def __init__(self, response):",
            "        super(SanitizedResponse, self).__init__()",
            "        self.status_code = response.status_code",
            "        self.encoding = response.encoding",
            "        self.raw = response.raw",
            "        self.reason = response.reason",
            "        self.url = response.url",
            "        self.request = response.request",
            "        self.connection = response.connection",
            "        self._content_consumed = True",
            "",
            "        self._content = \"\"",
            "        self.cookies = cookiejar_from_dict({})",
            "        self.headers = CaseInsensitiveDict()",
            "        self.headers['content-length'] = '0'",
            "        for header in ('date', 'server'):",
            "            if header in response.headers:",
            "                self.headers[header] = response.headers[header]",
            "",
            "",
            "def _negotiate_value(response):",
            "    \"\"\"Extracts the gssapi authentication token from the appropriate header\"\"\"",
            "    if hasattr(_negotiate_value, 'regex'):",
            "        regex = _negotiate_value.regex",
            "    else:",
            "        # There's no need to re-compile this EVERY time it is called. Compile",
            "        # it once and you won't have the performance hit of the compilation.",
            "        regex = re.compile('(?:.*,)*\\s*Negotiate\\s*([^,]*),?', re.I)",
            "        _negotiate_value.regex = regex",
            "",
            "    authreq = response.headers.get('www-authenticate', None)",
            "",
            "    if authreq:",
            "        match_obj = regex.search(authreq)",
            "        if match_obj:",
            "            return match_obj.group(1)",
            "",
            "    return None",
            "",
            "",
            "class HTTPKerberosAuth(AuthBase):",
            "    \"\"\"Attaches HTTP GSSAPI/Kerberos Authentication to the given Request",
            "    object.\"\"\"",
            "    def __init__(self, mutual_authentication=REQUIRED, service=\"HTTP\"):",
            "        self.context = {}",
            "        self.mutual_authentication = mutual_authentication",
            "        self.pos = None",
            "        self.service = service",
            "",
            "    def generate_request_header(self, response):",
            "        \"\"\"",
            "        Generates the GSSAPI authentication token with kerberos.",
            "",
            "        If any GSSAPI step fails, return None.",
            "",
            "        \"\"\"",
            "        host = urlparse(response.url).hostname",
            "",
            "        try:",
            "            result, self.context[host] = kerberos.authGSSClientInit(",
            "                \"{0}@{1}\".format(self.service, host))",
            "        except kerberos.GSSError as e:",
            "            log.error(\"generate_request_header(): authGSSClientInit() failed:\")",
            "            log.exception(e)",
            "            return None",
            "",
            "        if result < 1:",
            "            log.error(\"generate_request_header(): authGSSClientInit() failed: \"",
            "                      \"{0}\".format(result))",
            "            return None",
            "",
            "        try:",
            "            result = kerberos.authGSSClientStep(self.context[host],",
            "                                                _negotiate_value(response))",
            "        except kerberos.GSSError as e:",
            "            log.error(\"generate_request_header(): authGSSClientStep() failed:\")",
            "            log.exception(e)",
            "            return None",
            "",
            "        if result < 0:",
            "            log.error(\"generate_request_header(): authGSSClientStep() failed: \"",
            "                      \"{0}\".format(result))",
            "            return None",
            "",
            "        try:",
            "            gss_response = kerberos.authGSSClientResponse(self.context[host])",
            "        except kerberos.GSSError as e:",
            "            log.error(\"generate_request_header(): authGSSClientResponse() \"",
            "                      \"failed:\")",
            "            log.exception(e)",
            "            return None",
            "",
            "        return \"Negotiate {0}\".format(gss_response)",
            "",
            "    def authenticate_user(self, response, **kwargs):",
            "        \"\"\"Handles user authentication with gssapi/kerberos\"\"\"",
            "",
            "        auth_header = self.generate_request_header(response)",
            "        if auth_header is None:",
            "            # GSS Failure, return existing response",
            "            return response",
            "",
            "        log.debug(\"authenticate_user(): Authorization header: {0}\".format(",
            "            auth_header))",
            "        response.request.headers['Authorization'] = auth_header",
            "",
            "        # Consume the content so we can reuse the connection for the next",
            "        # request.",
            "        response.content",
            "        response.raw.release_conn()",
            "",
            "        _r = response.connection.send(response.request, **kwargs)",
            "        _r.history.append(response)",
            "",
            "        log.debug(\"authenticate_user(): returning {0}\".format(_r))",
            "        return _r",
            "",
            "    def handle_401(self, response, **kwargs):",
            "        \"\"\"Handles 401's, attempts to use gssapi/kerberos authentication\"\"\"",
            "",
            "        log.debug(\"handle_401(): Handling: 401\")",
            "        if _negotiate_value(response) is not None:",
            "            _r = self.authenticate_user(response, **kwargs)",
            "            log.debug(\"handle_401(): returning {0}\".format(_r))",
            "            return _r",
            "        else:",
            "            log.debug(\"handle_401(): Kerberos is not supported\")",
            "            log.debug(\"handle_401(): returning {0}\".format(response))",
            "            return response",
            "",
            "    def handle_other(self, response):",
            "        \"\"\"Handles all responses with the exception of 401s.",
            "",
            "        This is necessary so that we can authenticate responses if requested\"\"\"",
            "",
            "        log.debug(\"handle_other(): Handling: %d\" % response.status_code)",
            "",
            "        if self.mutual_authentication in (REQUIRED, OPTIONAL):",
            "",
            "            is_http_error = response.status_code >= 400",
            "",
            "            if _negotiate_value(response) is not None:",
            "                log.debug(\"handle_other(): Authenticating the server\")",
            "                if not self.authenticate_server(response):",
            "                    # Mutual authentication failure when mutual auth is wanted,",
            "                    # raise an exception so the user doesn't use an untrusted",
            "                    # response.",
            "                    log.error(\"handle_other(): Mutual authentication failed\")",
            "                    raise MutualAuthenticationError(\"Unable to authenticate \"",
            "                                                    \"{0}\".format(response))",
            "",
            "                # Authentication successful",
            "                log.debug(\"handle_other(): returning {0}\".format(response))",
            "                return response",
            "",
            "            elif is_http_error or self.mutual_authentication == OPTIONAL:",
            "                log.error(\"handle_other(): Mutual authentication unavailable \"",
            "                          \"on {0} response\".format(response.status_code))",
            "",
            "                if self.mutual_authentication == REQUIRED:",
            "                    return SanitizedResponse(response)",
            "                else:",
            "                    return response",
            "            else:",
            "                # Unable to attempt mutual authentication when mutual auth is",
            "                # required, raise an exception so the user doesnt use an",
            "                # untrusted response.",
            "                log.error(\"handle_other(): Mutual authentication failed\")",
            "                raise MutualAuthenticationError(\"Unable to authenticate \"",
            "                                                \"{0}\".format(response))",
            "        else:",
            "            log.debug(\"handle_other(): returning {0}\".format(response))",
            "            return response",
            "",
            "    def authenticate_server(self, response):",
            "        \"\"\"",
            "        Uses GSSAPI to authenticate the server.",
            "",
            "        Returns True on success, False on failure.",
            "        \"\"\"",
            "",
            "        log.debug(\"authenticate_server(): Authenticate header: {0}\".format(",
            "            _negotiate_value(response)))",
            "",
            "        host = urlparse(response.url).hostname",
            "",
            "        try:",
            "            result = kerberos.authGSSClientStep(self.context[host],",
            "                                                _negotiate_value(response))",
            "        except kerberos.GSSError as e:",
            "            log.error(\"authenticate_server(): authGSSClientStep() failed:\")",
            "            log.exception(e)",
            "            return False",
            "",
            "        if result < 1:",
            "            log.error(\"auhenticate_server(): authGSSClientStep() failed: \"",
            "                      \"{0}\".format(result))",
            "            return False",
            "",
            "        log.debug(\"authenticate_server(): returning {0}\".format(response))",
            "        return True",
            "",
            "    def handle_response(self, response, **kwargs):",
            "        \"\"\"Takes the given response and tries kerberos-auth, as needed.\"\"\"",
            "",
            "        if self.pos is not None:",
            "            # Rewind the file position indicator of the body to where",
            "            # it was to resend the request.",
            "            response.request.body.seek(self.pos)",
            "",
            "        if response.status_code == 401:",
            "            _r = self.handle_401(response, **kwargs)",
            "            log.debug(\"handle_response(): returning {0}\".format(_r))",
            "            return _r",
            "        else:",
            "            _r = self.handle_other(response)",
            "            log.debug(\"handle_response(): returning {0}\".format(_r))",
            "            return _r",
            "",
            "    def deregister(self, response):",
            "        \"\"\"Deregisters the response handler\"\"\"",
            "        response.request.deregister_hook('response', self.handle_response)",
            "",
            "    def __call__(self, request):",
            "        request.register_hook('response', self.handle_response)",
            "        try:",
            "            self.pos = request.body.tell()",
            "        except AttributeError:",
            "            pass",
            "        return request"
        ],
        "afterPatchFile": [
            "import kerberos",
            "import re",
            "import logging",
            "",
            "from requests.auth import AuthBase",
            "from requests.models import Response",
            "from requests.compat import urlparse, StringIO",
            "from requests.structures import CaseInsensitiveDict",
            "from requests.cookies import cookiejar_from_dict",
            "",
            "from .exceptions import MutualAuthenticationError",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "# Different types of mutual authentication:",
            "#  with mutual_authentication set to REQUIRED, all responses will be",
            "#   authenticated with the exception of errors. Errors will have their contents",
            "#   and headers stripped. If a non-error response cannot be authenticated, a",
            "#   MutualAuthenticationError exception will be raised.",
            "# with mutual_authentication set to OPTIONAL, mutual authentication will be",
            "#   attempted if supported, and if supported and failed, a",
            "#   MutualAuthenticationError exception will be raised. Responses which do not",
            "#   support mutual authentication will be returned directly to the user.",
            "# with mutual_authentication set to DISABLED, mutual authentication will not be",
            "#   attempted, even if supported.",
            "REQUIRED = 1",
            "OPTIONAL = 2",
            "DISABLED = 3",
            "",
            "",
            "class SanitizedResponse(Response):",
            "    \"\"\"The :class:`Response <Response>` object, which contains a server's",
            "    response to an HTTP request.",
            "",
            "    This differs from `requests.models.Response` in that it's headers and",
            "    content have been sanitized. This is only used for HTTP Error messages",
            "    which do not support mutual authentication when mutual authentication is",
            "    required.\"\"\"",
            "",
            "    def __init__(self, response):",
            "        super(SanitizedResponse, self).__init__()",
            "        self.status_code = response.status_code",
            "        self.encoding = response.encoding",
            "        self.raw = response.raw",
            "        self.reason = response.reason",
            "        self.url = response.url",
            "        self.request = response.request",
            "        self.connection = response.connection",
            "        self._content_consumed = True",
            "",
            "        self._content = \"\"",
            "        self.cookies = cookiejar_from_dict({})",
            "        self.headers = CaseInsensitiveDict()",
            "        self.headers['content-length'] = '0'",
            "        for header in ('date', 'server'):",
            "            if header in response.headers:",
            "                self.headers[header] = response.headers[header]",
            "",
            "",
            "def _negotiate_value(response):",
            "    \"\"\"Extracts the gssapi authentication token from the appropriate header\"\"\"",
            "    if hasattr(_negotiate_value, 'regex'):",
            "        regex = _negotiate_value.regex",
            "    else:",
            "        # There's no need to re-compile this EVERY time it is called. Compile",
            "        # it once and you won't have the performance hit of the compilation.",
            "        regex = re.compile('(?:.*,)*\\s*Negotiate\\s*([^,]*),?', re.I)",
            "        _negotiate_value.regex = regex",
            "",
            "    authreq = response.headers.get('www-authenticate', None)",
            "",
            "    if authreq:",
            "        match_obj = regex.search(authreq)",
            "        if match_obj:",
            "            return match_obj.group(1)",
            "",
            "    return None",
            "",
            "",
            "class HTTPKerberosAuth(AuthBase):",
            "    \"\"\"Attaches HTTP GSSAPI/Kerberos Authentication to the given Request",
            "    object.\"\"\"",
            "    def __init__(self, mutual_authentication=REQUIRED, service=\"HTTP\"):",
            "        self.context = {}",
            "        self.mutual_authentication = mutual_authentication",
            "        self.pos = None",
            "        self.service = service",
            "",
            "    def generate_request_header(self, response):",
            "        \"\"\"",
            "        Generates the GSSAPI authentication token with kerberos.",
            "",
            "        If any GSSAPI step fails, return None.",
            "",
            "        \"\"\"",
            "        host = urlparse(response.url).hostname",
            "",
            "        try:",
            "            result, self.context[host] = kerberos.authGSSClientInit(",
            "                \"{0}@{1}\".format(self.service, host))",
            "        except kerberos.GSSError as e:",
            "            log.error(\"generate_request_header(): authGSSClientInit() failed:\")",
            "            log.exception(e)",
            "            return None",
            "",
            "        if result < 1:",
            "            log.error(\"generate_request_header(): authGSSClientInit() failed: \"",
            "                      \"{0}\".format(result))",
            "            return None",
            "",
            "        try:",
            "            result = kerberos.authGSSClientStep(self.context[host],",
            "                                                _negotiate_value(response))",
            "        except kerberos.GSSError as e:",
            "            log.error(\"generate_request_header(): authGSSClientStep() failed:\")",
            "            log.exception(e)",
            "            return None",
            "",
            "        if result < 0:",
            "            log.error(\"generate_request_header(): authGSSClientStep() failed: \"",
            "                      \"{0}\".format(result))",
            "            return None",
            "",
            "        try:",
            "            gss_response = kerberos.authGSSClientResponse(self.context[host])",
            "        except kerberos.GSSError as e:",
            "            log.error(\"generate_request_header(): authGSSClientResponse() \"",
            "                      \"failed:\")",
            "            log.exception(e)",
            "            return None",
            "",
            "        return \"Negotiate {0}\".format(gss_response)",
            "",
            "    def authenticate_user(self, response, **kwargs):",
            "        \"\"\"Handles user authentication with gssapi/kerberos\"\"\"",
            "",
            "        auth_header = self.generate_request_header(response)",
            "        if auth_header is None:",
            "            # GSS Failure, return existing response",
            "            return response",
            "",
            "        log.debug(\"authenticate_user(): Authorization header: {0}\".format(",
            "            auth_header))",
            "        response.request.headers['Authorization'] = auth_header",
            "",
            "        # Consume the content so we can reuse the connection for the next",
            "        # request.",
            "        response.content",
            "        response.raw.release_conn()",
            "",
            "        _r = response.connection.send(response.request, **kwargs)",
            "        _r.history.append(response)",
            "",
            "        log.debug(\"authenticate_user(): returning {0}\".format(_r))",
            "        return _r",
            "",
            "    def handle_401(self, response, **kwargs):",
            "        \"\"\"Handles 401's, attempts to use gssapi/kerberos authentication\"\"\"",
            "",
            "        log.debug(\"handle_401(): Handling: 401\")",
            "        if _negotiate_value(response) is not None:",
            "            _r = self.authenticate_user(response, **kwargs)",
            "            log.debug(\"handle_401(): returning {0}\".format(_r))",
            "            return _r",
            "        else:",
            "            log.debug(\"handle_401(): Kerberos is not supported\")",
            "            log.debug(\"handle_401(): returning {0}\".format(response))",
            "            return response",
            "",
            "    def handle_other(self, response):",
            "        \"\"\"Handles all responses with the exception of 401s.",
            "",
            "        This is necessary so that we can authenticate responses if requested\"\"\"",
            "",
            "        log.debug(\"handle_other(): Handling: %d\" % response.status_code)",
            "",
            "        if self.mutual_authentication in (REQUIRED, OPTIONAL):",
            "",
            "            is_http_error = response.status_code >= 400",
            "",
            "            if _negotiate_value(response) is not None:",
            "                log.debug(\"handle_other(): Authenticating the server\")",
            "                if not self.authenticate_server(response):",
            "                    # Mutual authentication failure when mutual auth is wanted,",
            "                    # raise an exception so the user doesn't use an untrusted",
            "                    # response.",
            "                    log.error(\"handle_other(): Mutual authentication failed\")",
            "                    raise MutualAuthenticationError(\"Unable to authenticate \"",
            "                                                    \"{0}\".format(response))",
            "",
            "                # Authentication successful",
            "                log.debug(\"handle_other(): returning {0}\".format(response))",
            "                return response",
            "",
            "            elif is_http_error or self.mutual_authentication == OPTIONAL:",
            "                log.error(\"handle_other(): Mutual authentication unavailable \"",
            "                          \"on {0} response\".format(response.status_code))",
            "",
            "                if self.mutual_authentication == REQUIRED:",
            "                    return SanitizedResponse(response)",
            "                else:",
            "                    return response",
            "            else:",
            "                # Unable to attempt mutual authentication when mutual auth is",
            "                # required, raise an exception so the user doesnt use an",
            "                # untrusted response.",
            "                log.error(\"handle_other(): Mutual authentication failed\")",
            "                raise MutualAuthenticationError(\"Unable to authenticate \"",
            "                                                \"{0}\".format(response))",
            "        else:",
            "            log.debug(\"handle_other(): returning {0}\".format(response))",
            "            return response",
            "",
            "    def authenticate_server(self, response):",
            "        \"\"\"",
            "        Uses GSSAPI to authenticate the server.",
            "",
            "        Returns True on success, False on failure.",
            "        \"\"\"",
            "",
            "        log.debug(\"authenticate_server(): Authenticate header: {0}\".format(",
            "            _negotiate_value(response)))",
            "",
            "        host = urlparse(response.url).hostname",
            "",
            "        try:",
            "            result = kerberos.authGSSClientStep(self.context[host],",
            "                                                _negotiate_value(response))",
            "        except kerberos.GSSError as e:",
            "            log.error(\"authenticate_server(): authGSSClientStep() failed:\")",
            "            log.exception(e)",
            "            return False",
            "",
            "        if result < 1:",
            "            log.error(\"auhenticate_server(): authGSSClientStep() failed: \"",
            "                      \"{0}\".format(result))",
            "            return False",
            "",
            "        log.debug(\"authenticate_server(): returning {0}\".format(response))",
            "        return True",
            "",
            "    def handle_response(self, response, **kwargs):",
            "        \"\"\"Takes the given response and tries kerberos-auth, as needed.\"\"\"",
            "",
            "        if self.pos is not None:",
            "            # Rewind the file position indicator of the body to where",
            "            # it was to resend the request.",
            "            response.request.body.seek(self.pos)",
            "",
            "        if response.status_code == 401:",
            "            _r = self.handle_401(response, **kwargs)",
            "            log.debug(\"handle_response(): returning {0}\".format(_r))",
            "            return self.handle_response(_r, **kwargs)",
            "        else:",
            "            _r = self.handle_other(response)",
            "            log.debug(\"handle_response(): returning {0}\".format(_r))",
            "            return _r",
            "",
            "    def deregister(self, response):",
            "        \"\"\"Deregisters the response handler\"\"\"",
            "        response.request.deregister_hook('response', self.handle_response)",
            "",
            "    def __call__(self, request):",
            "        request.register_hook('response', self.handle_response)",
            "        try:",
            "            self.pos = request.body.tell()",
            "        except AttributeError:",
            "            pass",
            "        return request"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "254": [
                "HTTPKerberosAuth",
                "handle_response"
            ]
        },
        "addLocation": []
    },
    "test_requests_kerberos.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "             response.connection = connection"
            },
            "1": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "             response._content = \"\""
            },
            "2": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "             response.raw = raw"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "             auth = requests_kerberos.HTTPKerberosAuth()"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+            auth.handle_other = Mock(return_value=response_ok)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "             r = auth.handle_response(response)"
            },
            "8": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 410,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 411,
                "PatchRowcode": "             self.assertTrue(response in r.history)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+            auth.handle_other.assert_called_with(response_ok)"
            },
            "11": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 413,
                "PatchRowcode": "             self.assertEqual(r, response_ok)"
            },
            "12": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 414,
                "PatchRowcode": "             self.assertEqual(request.headers['Authorization'], 'Negotiate GSSRESPONSE')"
            },
            "13": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 415,
                "PatchRowcode": "             connection.send.assert_called_with(request)"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "\"\"\"Tests for requests_kerberos.\"\"\"",
            "",
            "from mock import Mock, patch",
            "import requests",
            "import kerberos",
            "import requests_kerberos",
            "import unittest",
            "",
            "# kerberos.authClientInit() is called with the service name (HTTP@FQDN) and",
            "# returns 1 and a kerberos context object on success. Returns -1 on failure.",
            "clientInit_complete = Mock(return_value=(1, \"CTX\"))",
            "clientInit_error = Mock(return_value=(-1, \"CTX\"))",
            "",
            "# kerberos.authGSSClientStep() is called with the kerberos context object",
            "# returned by authGSSClientInit and the negotiate auth token provided in the",
            "# http response's www-authenticate header. It returns 0 or 1 on success. 0",
            "# Indicates that authentication is progressing but not complete.",
            "clientStep_complete = Mock(return_value=1)",
            "clientStep_continue = Mock(return_value=0)",
            "clientStep_error = Mock(return_value=-1)",
            "clientStep_exception = Mock(side_effect=kerberos.GSSError)",
            "",
            "# kerberos.authGSSCLientResponse() is called with the kerberos context which",
            "# was initially returned by authGSSClientInit and had been mutated by a call by",
            "# authGSSClientStep. It returns a string.",
            "clientResponse = Mock(return_value=\"GSSRESPONSE\")",
            "",
            "# Note: we're not using the @mock.patch decorator:",
            "# > My only word of warning is that in the past, the patch decorator hides",
            "# > tests when using the standard unittest library.",
            "# > -- sigmavirus24 in https://github.com/requests/requests-kerberos/issues/1",
            "",
            "",
            "",
            "class KerberosTestCase(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        \"\"\"Setup.\"\"\"",
            "        clientInit_complete.reset_mock()",
            "        clientInit_error.reset_mock()",
            "        clientStep_complete.reset_mock()",
            "        clientStep_continue.reset_mock()",
            "        clientStep_error.reset_mock()",
            "        clientStep_exception.reset_mock()",
            "        clientResponse.reset_mock()",
            "",
            "    def tearDown(self):",
            "        \"\"\"Teardown.\"\"\"",
            "        pass",
            "",
            "    def test_negotate_value_extraction(self):",
            "        response = requests.Response()",
            "        response.headers = {'www-authenticate': 'negotiate token'}",
            "        self.assertEqual(",
            "            requests_kerberos.kerberos_._negotiate_value(response),",
            "            'token'",
            "        )",
            "",
            "    def test_negotate_value_extraction_none(self):",
            "        response = requests.Response()",
            "        response.headers = {}",
            "        self.assertTrue(",
            "            requests_kerberos.kerberos_._negotiate_value(response) is None",
            "        )",
            "",
            "    def test_generate_request_header(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "            response = requests.Response()",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            self.assertEqual(",
            "                auth.generate_request_header(response),",
            "                \"Negotiate GSSRESPONSE\"",
            "            )",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_continue.assert_called_with(\"CTX\", \"token\")",
            "            clientResponse.assert_called_with(\"CTX\")",
            "",
            "    def test_generate_request_header_init_error(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_error,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "            response = requests.Response()",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            self.assertEqual(",
            "                auth.generate_request_header(response),",
            "                None",
            "            )",
            "            clientInit_error.assert_called_with(\"HTTP@www.example.org\")",
            "            self.assertFalse(clientStep_continue.called)",
            "            self.assertFalse(clientResponse.called)",
            "",
            "    def test_generate_request_header_step_error(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_error):",
            "            response = requests.Response()",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            self.assertEqual(",
            "                auth.generate_request_header(response),",
            "                None",
            "            )",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_error.assert_called_with(\"CTX\", \"token\")",
            "            self.assertFalse(clientResponse.called)",
            "",
            "    def test_authenticate_user(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken'}",
            "",
            "            connection = Mock()",
            "            connection.send = Mock(return_value=response_ok)",
            "",
            "            raw = Mock()",
            "            raw.release_conn = Mock(return_value=None)",
            "",
            "            request = requests.Request()",
            "            response = requests.Response()",
            "            response.request = request",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            response.status_code = 401",
            "            response.connection = connection",
            "            response._content = \"\"",
            "            response.raw = raw",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            r = auth.authenticate_user(response)",
            "",
            "            self.assertTrue(response in r.history)",
            "            self.assertEqual(r, response_ok)",
            "            self.assertEqual(request.headers['Authorization'], 'Negotiate GSSRESPONSE')",
            "            connection.send.assert_called_with(request)",
            "            raw.release_conn.assert_called_with()",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_continue.assert_called_with(\"CTX\", \"token\")",
            "            clientResponse.assert_called_with(\"CTX\")",
            "",
            "",
            "    def test_handle_401(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken'}",
            "",
            "            connection = Mock()",
            "            connection.send = Mock(return_value=response_ok)",
            "",
            "            raw = Mock()",
            "            raw.release_conn = Mock(return_value=None)",
            "",
            "            request = requests.Request()",
            "            response = requests.Response()",
            "            response.request = request",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            response.status_code = 401",
            "            response.connection = connection",
            "            response._content = \"\"",
            "            response.raw = raw",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            r = auth.handle_401(response)",
            "",
            "            self.assertTrue(response in r.history)",
            "            self.assertEqual(r, response_ok)",
            "            self.assertEqual(request.headers['Authorization'], 'Negotiate GSSRESPONSE')",
            "            connection.send.assert_called_with(request)",
            "            raw.release_conn.assert_called_with()",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_continue.assert_called_with(\"CTX\", \"token\")",
            "            clientResponse.assert_called_with(\"CTX\")",
            "",
            "    def test_authenticate_server(self):",
            "        with patch.multiple('kerberos', authGSSClientStep=clientStep_complete):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "            result = auth.authenticate_server(response_ok)",
            "",
            "            self.assertTrue(result)",
            "            clientStep_complete.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "    def test_handle_other(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_complete):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_other(response_ok)",
            "",
            "            self.assertEqual(r, response_ok)",
            "            clientStep_complete.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "    def test_handle_response_200(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_complete):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_response(response_ok)",
            "",
            "            self.assertEqual(r, response_ok)",
            "            clientStep_complete.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "    def test_handle_response_200_mutual_auth_required_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {}",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            self.assertRaises(requests_kerberos.MutualAuthenticationError,",
            "                              auth.handle_response,",
            "                              response_ok)",
            "",
            "            self.assertFalse(clientStep_error.called)",
            "",
            "    def test_handle_response_200_mutual_auth_required_failure_2(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_exception):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            self.assertRaises(requests_kerberos.MutualAuthenticationError,",
            "                              auth.handle_response,",
            "                              response_ok)",
            "",
            "            clientStep_exception.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "    def test_handle_response_200_mutual_auth_optional_hard_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth(requests_kerberos.OPTIONAL)",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "",
            "            self.assertRaises(requests_kerberos.MutualAuthenticationError,",
            "                              auth.handle_response,",
            "                              response_ok)",
            "",
            "            clientStep_error.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "",
            "    def test_handle_response_200_mutual_auth_optional_soft_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth(requests_kerberos.OPTIONAL)",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_response(response_ok)",
            "",
            "            self.assertEqual(r, response_ok)",
            "",
            "            self.assertFalse(clientStep_error.called)",
            "",
            "    def test_handle_response_500_mutual_auth_required_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_500 = requests.Response()",
            "            response_500.url = \"http://www.example.org/\"",
            "            response_500.status_code = 500",
            "            response_500.headers = {}",
            "            response_500.request = \"REQUEST\"",
            "            response_500.connection = \"CONNECTION\"",
            "            response_500._content = \"CONTENT\"",
            "            response_500.encoding = \"ENCODING\"",
            "            response_500.raw = \"RAW\"",
            "            response_500.cookies = \"COOKIES\"",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_response(response_500)",
            "",
            "            self.assertNotEqual(r, response_500)",
            "            self.assertNotEqual(r.headers, response_500.headers)",
            "            self.assertEqual(r.status_code, response_500.status_code)",
            "            self.assertEqual(r.encoding, response_500.encoding)",
            "            self.assertEqual(r.raw, response_500.raw)",
            "            self.assertEqual(r.url, response_500.url)",
            "            self.assertEqual(r.reason, response_500.reason)",
            "            self.assertEqual(r.connection, response_500.connection)",
            "            self.assertEqual(r.content, b'')",
            "            self.assertNotEqual(r.cookies, response_500.cookies)",
            "",
            "            self.assertFalse(clientStep_error.called)",
            "",
            "    def test_handle_response_500_mutual_auth_optional_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_500 = requests.Response()",
            "            response_500.url = \"http://www.example.org/\"",
            "            response_500.status_code = 500",
            "            response_500.headers = {}",
            "            response_500.request = \"REQUEST\"",
            "            response_500.connection = \"CONNECTION\"",
            "            response_500._content = \"CONTENT\"",
            "            response_500.encoding = \"ENCODING\"",
            "            response_500.raw = \"RAW\"",
            "            response_500.cookies = \"COOKIES\"",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth(requests_kerberos.OPTIONAL)",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_response(response_500)",
            "",
            "            self.assertEqual(r, response_500)",
            "",
            "            self.assertFalse(clientStep_error.called)",
            "",
            "",
            "    def test_handle_response_401(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken'}",
            "",
            "            connection = Mock()",
            "            connection.send = Mock(return_value=response_ok)",
            "",
            "            raw = Mock()",
            "            raw.release_conn = Mock(return_value=None)",
            "",
            "            request = requests.Request()",
            "            response = requests.Response()",
            "            response.request = request",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            response.status_code = 401",
            "            response.connection = connection",
            "            response._content = \"\"",
            "            response.raw = raw",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            r = auth.handle_response(response)",
            "",
            "            self.assertTrue(response in r.history)",
            "            self.assertEqual(r, response_ok)",
            "            self.assertEqual(request.headers['Authorization'], 'Negotiate GSSRESPONSE')",
            "            connection.send.assert_called_with(request)",
            "            raw.release_conn.assert_called_with()",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_continue.assert_called_with(\"CTX\", \"token\")",
            "            clientResponse.assert_called_with(\"CTX\")",
            "",
            "    def test_generate_request_header_custom_service(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_error,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "            response = requests.Response()",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            auth = requests_kerberos.HTTPKerberosAuth(service=\"barfoo\")",
            "            auth.generate_request_header(response),",
            "            clientInit_error.assert_called_with(\"barfoo@www.example.org\")",
            "",
            "if __name__ == '__main__':",
            "    unittest.main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "\"\"\"Tests for requests_kerberos.\"\"\"",
            "",
            "from mock import Mock, patch",
            "import requests",
            "import kerberos",
            "import requests_kerberos",
            "import unittest",
            "",
            "# kerberos.authClientInit() is called with the service name (HTTP@FQDN) and",
            "# returns 1 and a kerberos context object on success. Returns -1 on failure.",
            "clientInit_complete = Mock(return_value=(1, \"CTX\"))",
            "clientInit_error = Mock(return_value=(-1, \"CTX\"))",
            "",
            "# kerberos.authGSSClientStep() is called with the kerberos context object",
            "# returned by authGSSClientInit and the negotiate auth token provided in the",
            "# http response's www-authenticate header. It returns 0 or 1 on success. 0",
            "# Indicates that authentication is progressing but not complete.",
            "clientStep_complete = Mock(return_value=1)",
            "clientStep_continue = Mock(return_value=0)",
            "clientStep_error = Mock(return_value=-1)",
            "clientStep_exception = Mock(side_effect=kerberos.GSSError)",
            "",
            "# kerberos.authGSSCLientResponse() is called with the kerberos context which",
            "# was initially returned by authGSSClientInit and had been mutated by a call by",
            "# authGSSClientStep. It returns a string.",
            "clientResponse = Mock(return_value=\"GSSRESPONSE\")",
            "",
            "# Note: we're not using the @mock.patch decorator:",
            "# > My only word of warning is that in the past, the patch decorator hides",
            "# > tests when using the standard unittest library.",
            "# > -- sigmavirus24 in https://github.com/requests/requests-kerberos/issues/1",
            "",
            "",
            "",
            "class KerberosTestCase(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        \"\"\"Setup.\"\"\"",
            "        clientInit_complete.reset_mock()",
            "        clientInit_error.reset_mock()",
            "        clientStep_complete.reset_mock()",
            "        clientStep_continue.reset_mock()",
            "        clientStep_error.reset_mock()",
            "        clientStep_exception.reset_mock()",
            "        clientResponse.reset_mock()",
            "",
            "    def tearDown(self):",
            "        \"\"\"Teardown.\"\"\"",
            "        pass",
            "",
            "    def test_negotate_value_extraction(self):",
            "        response = requests.Response()",
            "        response.headers = {'www-authenticate': 'negotiate token'}",
            "        self.assertEqual(",
            "            requests_kerberos.kerberos_._negotiate_value(response),",
            "            'token'",
            "        )",
            "",
            "    def test_negotate_value_extraction_none(self):",
            "        response = requests.Response()",
            "        response.headers = {}",
            "        self.assertTrue(",
            "            requests_kerberos.kerberos_._negotiate_value(response) is None",
            "        )",
            "",
            "    def test_generate_request_header(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "            response = requests.Response()",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            self.assertEqual(",
            "                auth.generate_request_header(response),",
            "                \"Negotiate GSSRESPONSE\"",
            "            )",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_continue.assert_called_with(\"CTX\", \"token\")",
            "            clientResponse.assert_called_with(\"CTX\")",
            "",
            "    def test_generate_request_header_init_error(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_error,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "            response = requests.Response()",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            self.assertEqual(",
            "                auth.generate_request_header(response),",
            "                None",
            "            )",
            "            clientInit_error.assert_called_with(\"HTTP@www.example.org\")",
            "            self.assertFalse(clientStep_continue.called)",
            "            self.assertFalse(clientResponse.called)",
            "",
            "    def test_generate_request_header_step_error(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_error):",
            "            response = requests.Response()",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            self.assertEqual(",
            "                auth.generate_request_header(response),",
            "                None",
            "            )",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_error.assert_called_with(\"CTX\", \"token\")",
            "            self.assertFalse(clientResponse.called)",
            "",
            "    def test_authenticate_user(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken'}",
            "",
            "            connection = Mock()",
            "            connection.send = Mock(return_value=response_ok)",
            "",
            "            raw = Mock()",
            "            raw.release_conn = Mock(return_value=None)",
            "",
            "            request = requests.Request()",
            "            response = requests.Response()",
            "            response.request = request",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            response.status_code = 401",
            "            response.connection = connection",
            "            response._content = \"\"",
            "            response.raw = raw",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            r = auth.authenticate_user(response)",
            "",
            "            self.assertTrue(response in r.history)",
            "            self.assertEqual(r, response_ok)",
            "            self.assertEqual(request.headers['Authorization'], 'Negotiate GSSRESPONSE')",
            "            connection.send.assert_called_with(request)",
            "            raw.release_conn.assert_called_with()",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_continue.assert_called_with(\"CTX\", \"token\")",
            "            clientResponse.assert_called_with(\"CTX\")",
            "",
            "",
            "    def test_handle_401(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken'}",
            "",
            "            connection = Mock()",
            "            connection.send = Mock(return_value=response_ok)",
            "",
            "            raw = Mock()",
            "            raw.release_conn = Mock(return_value=None)",
            "",
            "            request = requests.Request()",
            "            response = requests.Response()",
            "            response.request = request",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            response.status_code = 401",
            "            response.connection = connection",
            "            response._content = \"\"",
            "            response.raw = raw",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            r = auth.handle_401(response)",
            "",
            "            self.assertTrue(response in r.history)",
            "            self.assertEqual(r, response_ok)",
            "            self.assertEqual(request.headers['Authorization'], 'Negotiate GSSRESPONSE')",
            "            connection.send.assert_called_with(request)",
            "            raw.release_conn.assert_called_with()",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_continue.assert_called_with(\"CTX\", \"token\")",
            "            clientResponse.assert_called_with(\"CTX\")",
            "",
            "    def test_authenticate_server(self):",
            "        with patch.multiple('kerberos', authGSSClientStep=clientStep_complete):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "            result = auth.authenticate_server(response_ok)",
            "",
            "            self.assertTrue(result)",
            "            clientStep_complete.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "    def test_handle_other(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_complete):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_other(response_ok)",
            "",
            "            self.assertEqual(r, response_ok)",
            "            clientStep_complete.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "    def test_handle_response_200(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_complete):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_response(response_ok)",
            "",
            "            self.assertEqual(r, response_ok)",
            "            clientStep_complete.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "    def test_handle_response_200_mutual_auth_required_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {}",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            self.assertRaises(requests_kerberos.MutualAuthenticationError,",
            "                              auth.handle_response,",
            "                              response_ok)",
            "",
            "            self.assertFalse(clientStep_error.called)",
            "",
            "    def test_handle_response_200_mutual_auth_required_failure_2(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_exception):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            self.assertRaises(requests_kerberos.MutualAuthenticationError,",
            "                              auth.handle_response,",
            "                              response_ok)",
            "",
            "            clientStep_exception.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "    def test_handle_response_200_mutual_auth_optional_hard_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken',",
            "                                   'authorization': 'Negotiate GSSRESPONSE'",
            "            }",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth(requests_kerberos.OPTIONAL)",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "",
            "            self.assertRaises(requests_kerberos.MutualAuthenticationError,",
            "                              auth.handle_response,",
            "                              response_ok)",
            "",
            "            clientStep_error.assert_called_with(\"CTX\", \"servertoken\")",
            "",
            "",
            "    def test_handle_response_200_mutual_auth_optional_soft_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth(requests_kerberos.OPTIONAL)",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_response(response_ok)",
            "",
            "            self.assertEqual(r, response_ok)",
            "",
            "            self.assertFalse(clientStep_error.called)",
            "",
            "    def test_handle_response_500_mutual_auth_required_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_500 = requests.Response()",
            "            response_500.url = \"http://www.example.org/\"",
            "            response_500.status_code = 500",
            "            response_500.headers = {}",
            "            response_500.request = \"REQUEST\"",
            "            response_500.connection = \"CONNECTION\"",
            "            response_500._content = \"CONTENT\"",
            "            response_500.encoding = \"ENCODING\"",
            "            response_500.raw = \"RAW\"",
            "            response_500.cookies = \"COOKIES\"",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_response(response_500)",
            "",
            "            self.assertNotEqual(r, response_500)",
            "            self.assertNotEqual(r.headers, response_500.headers)",
            "            self.assertEqual(r.status_code, response_500.status_code)",
            "            self.assertEqual(r.encoding, response_500.encoding)",
            "            self.assertEqual(r.raw, response_500.raw)",
            "            self.assertEqual(r.url, response_500.url)",
            "            self.assertEqual(r.reason, response_500.reason)",
            "            self.assertEqual(r.connection, response_500.connection)",
            "            self.assertEqual(r.content, b'')",
            "            self.assertNotEqual(r.cookies, response_500.cookies)",
            "",
            "            self.assertFalse(clientStep_error.called)",
            "",
            "    def test_handle_response_500_mutual_auth_optional_failure(self):",
            "        with patch('kerberos.authGSSClientStep', clientStep_error):",
            "",
            "            response_500 = requests.Response()",
            "            response_500.url = \"http://www.example.org/\"",
            "            response_500.status_code = 500",
            "            response_500.headers = {}",
            "            response_500.request = \"REQUEST\"",
            "            response_500.connection = \"CONNECTION\"",
            "            response_500._content = \"CONTENT\"",
            "            response_500.encoding = \"ENCODING\"",
            "            response_500.raw = \"RAW\"",
            "            response_500.cookies = \"COOKIES\"",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth(requests_kerberos.OPTIONAL)",
            "            auth.context = {\"www.example.org\": \"CTX\"}",
            "",
            "            r = auth.handle_response(response_500)",
            "",
            "            self.assertEqual(r, response_500)",
            "",
            "            self.assertFalse(clientStep_error.called)",
            "",
            "",
            "    def test_handle_response_401(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_complete,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "",
            "            response_ok = requests.Response()",
            "            response_ok.url = \"http://www.example.org/\"",
            "            response_ok.status_code = 200",
            "            response_ok.headers = {'www-authenticate': 'negotiate servertoken'}",
            "",
            "            connection = Mock()",
            "            connection.send = Mock(return_value=response_ok)",
            "",
            "            raw = Mock()",
            "            raw.release_conn = Mock(return_value=None)",
            "",
            "            request = requests.Request()",
            "            response = requests.Response()",
            "            response.request = request",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            response.status_code = 401",
            "            response.connection = connection",
            "            response._content = \"\"",
            "            response.raw = raw",
            "",
            "            auth = requests_kerberos.HTTPKerberosAuth()",
            "            auth.handle_other = Mock(return_value=response_ok)",
            "",
            "            r = auth.handle_response(response)",
            "",
            "            self.assertTrue(response in r.history)",
            "            auth.handle_other.assert_called_with(response_ok)",
            "            self.assertEqual(r, response_ok)",
            "            self.assertEqual(request.headers['Authorization'], 'Negotiate GSSRESPONSE')",
            "            connection.send.assert_called_with(request)",
            "            raw.release_conn.assert_called_with()",
            "            clientInit_complete.assert_called_with(\"HTTP@www.example.org\")",
            "            clientStep_continue.assert_called_with(\"CTX\", \"token\")",
            "            clientResponse.assert_called_with(\"CTX\")",
            "",
            "    def test_generate_request_header_custom_service(self):",
            "        with patch.multiple('kerberos',",
            "                            authGSSClientInit=clientInit_error,",
            "                            authGSSClientResponse=clientResponse,",
            "                            authGSSClientStep=clientStep_continue):",
            "            response = requests.Response()",
            "            response.url = \"http://www.example.org/\"",
            "            response.headers = {'www-authenticate': 'negotiate token'}",
            "            auth = requests_kerberos.HTTPKerberosAuth(service=\"barfoo\")",
            "            auth.generate_request_header(response),",
            "            clientInit_error.assert_called_with(\"barfoo@www.example.org\")",
            "",
            "if __name__ == '__main__':",
            "    unittest.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "aiosmtpd.smtp.SMTP"
        ]
    }
}