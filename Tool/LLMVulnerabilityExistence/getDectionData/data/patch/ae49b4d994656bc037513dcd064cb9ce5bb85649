{
    "django/core/validators.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # ...or ipv4"
            },
            "1": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  # ...or ipv6"
            },
            "2": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         r'(?::\\d+)?'  # optional port"
            },
            "3": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        r'(?:/?|[/?]\\S+)\\Z', re.IGNORECASE)"
            },
            "5": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     message = _('Enter a valid URL.')"
            },
            "6": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     schemes = ['http', 'https', 'ftp', 'ftps']"
            },
            "7": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         else:"
            },
            "9": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             url = value"
            },
            "10": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+integer_validator = RegexValidator("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+    re.compile('^-?\\d+\\Z'),"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+    message=_('Enter a valid integer.'),"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    code='invalid',"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 117,
                "PatchRowcode": " def validate_integer(value):"
            },
            "19": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    try:"
            },
            "20": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        int(value)"
            },
            "21": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except (ValueError, TypeError):"
            },
            "22": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise ValidationError(_('Enter a valid integer.'), code='invalid')"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    return integer_validator(value)"
            },
            "24": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " @deconstructible"
            },
            "27": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " class EmailValidator(object):"
            },
            "28": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "     message = _('Enter a valid email address.')"
            },
            "29": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "     code = 'invalid'"
            },
            "30": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     user_regex = re.compile("
            },
            "31": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*$\"  # dot-atom"
            },
            "32": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"$)',  # quoted-string"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\\Z\"  # dot-atom"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"\\Z)',  # quoted-string"
            },
            "35": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         re.IGNORECASE)"
            },
            "36": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     domain_regex = re.compile("
            },
            "37": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,}(?<!-))$',"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,}(?<!-))\\Z',"
            },
            "39": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         re.IGNORECASE)"
            },
            "40": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "     literal_regex = re.compile("
            },
            "41": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)"
            },
            "42": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        r'\\[([A-f0-9:\\.]+)\\]$',"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        r'\\[([A-f0-9:\\.]+)\\]\\Z',"
            },
            "44": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         re.IGNORECASE)"
            },
            "45": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     domain_whitelist = ['localhost']"
            },
            "46": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " validate_email = EmailValidator()"
            },
            "49": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-slug_re = re.compile(r'^[-a-zA-Z0-9_]+$')"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+slug_re = re.compile(r'^[-a-zA-Z0-9_]+\\Z')"
            },
            "52": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " validate_slug = RegexValidator(slug_re, _(\"Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.\"), 'invalid')"
            },
            "53": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-ipv4_re = re.compile(r'^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}$')"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+ipv4_re = re.compile(r'^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}\\Z')"
            },
            "56": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " validate_ipv4_address = RegexValidator(ipv4_re, _('Enter a valid IPv4 address.'), 'invalid')"
            },
            "57": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 192,
                "PatchRowcode": " "
            },
            "58": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 193,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "         raise ValueError(\"The protocol '%s' is unknown. Supported: %s\""
            },
            "60": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "                          % (protocol, list(ip_address_validator_map)))"
            },
            "61": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-comma_separated_int_list_re = re.compile('^[\\d,]+$')"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+comma_separated_int_list_re = re.compile('^[\\d,]+\\Z')"
            },
            "64": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 232,
                "PatchRowcode": " validate_comma_separated_integer_list = RegexValidator(comma_separated_int_list_re, _('Enter only digits separated by commas.'), 'invalid')"
            },
            "65": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import re",
            "",
            "from django.core.exceptions import ValidationError",
            "from django.utils.deconstruct import deconstructible",
            "from django.utils.translation import ugettext_lazy as _, ungettext_lazy",
            "from django.utils.encoding import force_text",
            "from django.utils.ipv6 import is_valid_ipv6_address",
            "from django.utils import six",
            "from django.utils.six.moves.urllib.parse import urlsplit, urlunsplit",
            "",
            "",
            "# These values, if given to validate(), will trigger the self.required check.",
            "EMPTY_VALUES = (None, '', [], (), {})",
            "",
            "",
            "@deconstructible",
            "class RegexValidator(object):",
            "    regex = ''",
            "    message = _('Enter a valid value.')",
            "    code = 'invalid'",
            "    inverse_match = False",
            "    flags = 0",
            "",
            "    def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):",
            "        if regex is not None:",
            "            self.regex = regex",
            "        if message is not None:",
            "            self.message = message",
            "        if code is not None:",
            "            self.code = code",
            "        if inverse_match is not None:",
            "            self.inverse_match = inverse_match",
            "        if flags is not None:",
            "            self.flags = flags",
            "        if self.flags and not isinstance(self.regex, six.string_types):",
            "            raise TypeError(\"If the flags are set, regex must be a regular expression string.\")",
            "",
            "        # Compile the regex if it was not passed pre-compiled.",
            "        if isinstance(self.regex, six.string_types):",
            "            self.regex = re.compile(self.regex, self.flags)",
            "",
            "    def __call__(self, value):",
            "        \"\"\"",
            "        Validates that the input matches the regular expression",
            "        if inverse_match is False, otherwise raises ValidationError.",
            "        \"\"\"",
            "        if not (self.inverse_match is not bool(self.regex.search(",
            "                force_text(value)))):",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "    def __eq__(self, other):",
            "        return (",
            "            isinstance(other, RegexValidator) and",
            "            self.regex.pattern == other.regex.pattern and",
            "            self.regex.flags == other.regex.flags and",
            "            (self.message == other.message) and",
            "            (self.code == other.code) and",
            "            (self.inverse_match == other.inverse_match)",
            "        )",
            "",
            "    def __ne__(self, other):",
            "        return not (self == other)",
            "",
            "",
            "@deconstructible",
            "class URLValidator(RegexValidator):",
            "    regex = re.compile(",
            "        r'^(?:[a-z0-9\\.\\-]*)://'  # scheme is validated separately",
            "        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}(?<!-)\\.?)|'  # domain...",
            "        r'localhost|'  # localhost...",
            "        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # ...or ipv4",
            "        r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  # ...or ipv6",
            "        r'(?::\\d+)?'  # optional port",
            "        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)",
            "    message = _('Enter a valid URL.')",
            "    schemes = ['http', 'https', 'ftp', 'ftps']",
            "",
            "    def __init__(self, schemes=None, **kwargs):",
            "        super(URLValidator, self).__init__(**kwargs)",
            "        if schemes is not None:",
            "            self.schemes = schemes",
            "",
            "    def __call__(self, value):",
            "        value = force_text(value)",
            "        # Check first if the scheme is valid",
            "        scheme = value.split('://')[0].lower()",
            "        if scheme not in self.schemes:",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "        # Then check full URL",
            "        try:",
            "            super(URLValidator, self).__call__(value)",
            "        except ValidationError as e:",
            "            # Trivial case failed. Try for possible IDN domain",
            "            if value:",
            "                scheme, netloc, path, query, fragment = urlsplit(value)",
            "                try:",
            "                    netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE",
            "                except UnicodeError:  # invalid domain part",
            "                    raise e",
            "                url = urlunsplit((scheme, netloc, path, query, fragment))",
            "                super(URLValidator, self).__call__(url)",
            "            else:",
            "                raise",
            "        else:",
            "            url = value",
            "",
            "",
            "def validate_integer(value):",
            "    try:",
            "        int(value)",
            "    except (ValueError, TypeError):",
            "        raise ValidationError(_('Enter a valid integer.'), code='invalid')",
            "",
            "",
            "@deconstructible",
            "class EmailValidator(object):",
            "    message = _('Enter a valid email address.')",
            "    code = 'invalid'",
            "    user_regex = re.compile(",
            "        r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*$\"  # dot-atom",
            "        r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"$)',  # quoted-string",
            "        re.IGNORECASE)",
            "    domain_regex = re.compile(",
            "        r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,}(?<!-))$',",
            "        re.IGNORECASE)",
            "    literal_regex = re.compile(",
            "        # literal form, ipv4 or ipv6 address (SMTP 4.1.3)",
            "        r'\\[([A-f0-9:\\.]+)\\]$',",
            "        re.IGNORECASE)",
            "    domain_whitelist = ['localhost']",
            "",
            "    def __init__(self, message=None, code=None, whitelist=None):",
            "        if message is not None:",
            "            self.message = message",
            "        if code is not None:",
            "            self.code = code",
            "        if whitelist is not None:",
            "            self.domain_whitelist = whitelist",
            "",
            "    def __call__(self, value):",
            "        value = force_text(value)",
            "",
            "        if not value or '@' not in value:",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "        user_part, domain_part = value.rsplit('@', 1)",
            "",
            "        if not self.user_regex.match(user_part):",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "        if (domain_part not in self.domain_whitelist and",
            "                not self.validate_domain_part(domain_part)):",
            "            # Try for possible IDN domain-part",
            "            try:",
            "                domain_part = domain_part.encode('idna').decode('ascii')",
            "                if self.validate_domain_part(domain_part):",
            "                    return",
            "            except UnicodeError:",
            "                pass",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "    def validate_domain_part(self, domain_part):",
            "        if self.domain_regex.match(domain_part):",
            "            return True",
            "",
            "        literal_match = self.literal_regex.match(domain_part)",
            "        if literal_match:",
            "            ip_address = literal_match.group(1)",
            "            try:",
            "                validate_ipv46_address(ip_address)",
            "                return True",
            "            except ValidationError:",
            "                pass",
            "        return False",
            "",
            "    def __eq__(self, other):",
            "        return isinstance(other, EmailValidator) and (self.domain_whitelist == other.domain_whitelist) and (self.message == other.message) and (self.code == other.code)",
            "",
            "validate_email = EmailValidator()",
            "",
            "slug_re = re.compile(r'^[-a-zA-Z0-9_]+$')",
            "validate_slug = RegexValidator(slug_re, _(\"Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.\"), 'invalid')",
            "",
            "ipv4_re = re.compile(r'^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}$')",
            "validate_ipv4_address = RegexValidator(ipv4_re, _('Enter a valid IPv4 address.'), 'invalid')",
            "",
            "",
            "def validate_ipv6_address(value):",
            "    if not is_valid_ipv6_address(value):",
            "        raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')",
            "",
            "",
            "def validate_ipv46_address(value):",
            "    try:",
            "        validate_ipv4_address(value)",
            "    except ValidationError:",
            "        try:",
            "            validate_ipv6_address(value)",
            "        except ValidationError:",
            "            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')",
            "",
            "ip_address_validator_map = {",
            "    'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),",
            "    'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),",
            "    'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),",
            "}",
            "",
            "",
            "def ip_address_validators(protocol, unpack_ipv4):",
            "    \"\"\"",
            "    Depending on the given parameters returns the appropriate validators for",
            "    the GenericIPAddressField.",
            "",
            "    This code is here, because it is exactly the same for the model and the form field.",
            "    \"\"\"",
            "    if protocol != 'both' and unpack_ipv4:",
            "        raise ValueError(",
            "            \"You can only use `unpack_ipv4` if `protocol` is set to 'both'\")",
            "    try:",
            "        return ip_address_validator_map[protocol.lower()]",
            "    except KeyError:",
            "        raise ValueError(\"The protocol '%s' is unknown. Supported: %s\"",
            "                         % (protocol, list(ip_address_validator_map)))",
            "",
            "comma_separated_int_list_re = re.compile('^[\\d,]+$')",
            "validate_comma_separated_integer_list = RegexValidator(comma_separated_int_list_re, _('Enter only digits separated by commas.'), 'invalid')",
            "",
            "",
            "@deconstructible",
            "class BaseValidator(object):",
            "    compare = lambda self, a, b: a is not b",
            "    clean = lambda self, x: x",
            "    message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')",
            "    code = 'limit_value'",
            "",
            "    def __init__(self, limit_value):",
            "        self.limit_value = limit_value",
            "",
            "    def __call__(self, value):",
            "        cleaned = self.clean(value)",
            "        params = {'limit_value': self.limit_value, 'show_value': cleaned}",
            "        if self.compare(cleaned, self.limit_value):",
            "            raise ValidationError(self.message, code=self.code, params=params)",
            "",
            "    def __eq__(self, other):",
            "        return isinstance(other, self.__class__) and (self.limit_value == other.limit_value) and (self.message == other.message) and (self.code == other.code)",
            "",
            "",
            "@deconstructible",
            "class MaxValueValidator(BaseValidator):",
            "    compare = lambda self, a, b: a > b",
            "    message = _('Ensure this value is less than or equal to %(limit_value)s.')",
            "    code = 'max_value'",
            "",
            "",
            "@deconstructible",
            "class MinValueValidator(BaseValidator):",
            "    compare = lambda self, a, b: a < b",
            "    message = _('Ensure this value is greater than or equal to %(limit_value)s.')",
            "    code = 'min_value'",
            "",
            "",
            "@deconstructible",
            "class MinLengthValidator(BaseValidator):",
            "    compare = lambda self, a, b: a < b",
            "    clean = lambda self, x: len(x)",
            "    message = ungettext_lazy(",
            "        'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',",
            "        'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',",
            "        'limit_value')",
            "    code = 'min_length'",
            "",
            "",
            "@deconstructible",
            "class MaxLengthValidator(BaseValidator):",
            "    compare = lambda self, a, b: a > b",
            "    clean = lambda self, x: len(x)",
            "    message = ungettext_lazy(",
            "        'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',",
            "        'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',",
            "        'limit_value')",
            "    code = 'max_length'"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import re",
            "",
            "from django.core.exceptions import ValidationError",
            "from django.utils.deconstruct import deconstructible",
            "from django.utils.translation import ugettext_lazy as _, ungettext_lazy",
            "from django.utils.encoding import force_text",
            "from django.utils.ipv6 import is_valid_ipv6_address",
            "from django.utils import six",
            "from django.utils.six.moves.urllib.parse import urlsplit, urlunsplit",
            "",
            "",
            "# These values, if given to validate(), will trigger the self.required check.",
            "EMPTY_VALUES = (None, '', [], (), {})",
            "",
            "",
            "@deconstructible",
            "class RegexValidator(object):",
            "    regex = ''",
            "    message = _('Enter a valid value.')",
            "    code = 'invalid'",
            "    inverse_match = False",
            "    flags = 0",
            "",
            "    def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):",
            "        if regex is not None:",
            "            self.regex = regex",
            "        if message is not None:",
            "            self.message = message",
            "        if code is not None:",
            "            self.code = code",
            "        if inverse_match is not None:",
            "            self.inverse_match = inverse_match",
            "        if flags is not None:",
            "            self.flags = flags",
            "        if self.flags and not isinstance(self.regex, six.string_types):",
            "            raise TypeError(\"If the flags are set, regex must be a regular expression string.\")",
            "",
            "        # Compile the regex if it was not passed pre-compiled.",
            "        if isinstance(self.regex, six.string_types):",
            "            self.regex = re.compile(self.regex, self.flags)",
            "",
            "    def __call__(self, value):",
            "        \"\"\"",
            "        Validates that the input matches the regular expression",
            "        if inverse_match is False, otherwise raises ValidationError.",
            "        \"\"\"",
            "        if not (self.inverse_match is not bool(self.regex.search(",
            "                force_text(value)))):",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "    def __eq__(self, other):",
            "        return (",
            "            isinstance(other, RegexValidator) and",
            "            self.regex.pattern == other.regex.pattern and",
            "            self.regex.flags == other.regex.flags and",
            "            (self.message == other.message) and",
            "            (self.code == other.code) and",
            "            (self.inverse_match == other.inverse_match)",
            "        )",
            "",
            "    def __ne__(self, other):",
            "        return not (self == other)",
            "",
            "",
            "@deconstructible",
            "class URLValidator(RegexValidator):",
            "    regex = re.compile(",
            "        r'^(?:[a-z0-9\\.\\-]*)://'  # scheme is validated separately",
            "        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}(?<!-)\\.?)|'  # domain...",
            "        r'localhost|'  # localhost...",
            "        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # ...or ipv4",
            "        r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  # ...or ipv6",
            "        r'(?::\\d+)?'  # optional port",
            "        r'(?:/?|[/?]\\S+)\\Z', re.IGNORECASE)",
            "    message = _('Enter a valid URL.')",
            "    schemes = ['http', 'https', 'ftp', 'ftps']",
            "",
            "    def __init__(self, schemes=None, **kwargs):",
            "        super(URLValidator, self).__init__(**kwargs)",
            "        if schemes is not None:",
            "            self.schemes = schemes",
            "",
            "    def __call__(self, value):",
            "        value = force_text(value)",
            "        # Check first if the scheme is valid",
            "        scheme = value.split('://')[0].lower()",
            "        if scheme not in self.schemes:",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "        # Then check full URL",
            "        try:",
            "            super(URLValidator, self).__call__(value)",
            "        except ValidationError as e:",
            "            # Trivial case failed. Try for possible IDN domain",
            "            if value:",
            "                scheme, netloc, path, query, fragment = urlsplit(value)",
            "                try:",
            "                    netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE",
            "                except UnicodeError:  # invalid domain part",
            "                    raise e",
            "                url = urlunsplit((scheme, netloc, path, query, fragment))",
            "                super(URLValidator, self).__call__(url)",
            "            else:",
            "                raise",
            "        else:",
            "            url = value",
            "",
            "integer_validator = RegexValidator(",
            "    re.compile('^-?\\d+\\Z'),",
            "    message=_('Enter a valid integer.'),",
            "    code='invalid',",
            ")",
            "",
            "",
            "def validate_integer(value):",
            "    return integer_validator(value)",
            "",
            "",
            "@deconstructible",
            "class EmailValidator(object):",
            "    message = _('Enter a valid email address.')",
            "    code = 'invalid'",
            "    user_regex = re.compile(",
            "        r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\\Z\"  # dot-atom",
            "        r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"\\Z)',  # quoted-string",
            "        re.IGNORECASE)",
            "    domain_regex = re.compile(",
            "        r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,}(?<!-))\\Z',",
            "        re.IGNORECASE)",
            "    literal_regex = re.compile(",
            "        # literal form, ipv4 or ipv6 address (SMTP 4.1.3)",
            "        r'\\[([A-f0-9:\\.]+)\\]\\Z',",
            "        re.IGNORECASE)",
            "    domain_whitelist = ['localhost']",
            "",
            "    def __init__(self, message=None, code=None, whitelist=None):",
            "        if message is not None:",
            "            self.message = message",
            "        if code is not None:",
            "            self.code = code",
            "        if whitelist is not None:",
            "            self.domain_whitelist = whitelist",
            "",
            "    def __call__(self, value):",
            "        value = force_text(value)",
            "",
            "        if not value or '@' not in value:",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "        user_part, domain_part = value.rsplit('@', 1)",
            "",
            "        if not self.user_regex.match(user_part):",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "        if (domain_part not in self.domain_whitelist and",
            "                not self.validate_domain_part(domain_part)):",
            "            # Try for possible IDN domain-part",
            "            try:",
            "                domain_part = domain_part.encode('idna').decode('ascii')",
            "                if self.validate_domain_part(domain_part):",
            "                    return",
            "            except UnicodeError:",
            "                pass",
            "            raise ValidationError(self.message, code=self.code)",
            "",
            "    def validate_domain_part(self, domain_part):",
            "        if self.domain_regex.match(domain_part):",
            "            return True",
            "",
            "        literal_match = self.literal_regex.match(domain_part)",
            "        if literal_match:",
            "            ip_address = literal_match.group(1)",
            "            try:",
            "                validate_ipv46_address(ip_address)",
            "                return True",
            "            except ValidationError:",
            "                pass",
            "        return False",
            "",
            "    def __eq__(self, other):",
            "        return isinstance(other, EmailValidator) and (self.domain_whitelist == other.domain_whitelist) and (self.message == other.message) and (self.code == other.code)",
            "",
            "validate_email = EmailValidator()",
            "",
            "slug_re = re.compile(r'^[-a-zA-Z0-9_]+\\Z')",
            "validate_slug = RegexValidator(slug_re, _(\"Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.\"), 'invalid')",
            "",
            "ipv4_re = re.compile(r'^(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}\\Z')",
            "validate_ipv4_address = RegexValidator(ipv4_re, _('Enter a valid IPv4 address.'), 'invalid')",
            "",
            "",
            "def validate_ipv6_address(value):",
            "    if not is_valid_ipv6_address(value):",
            "        raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')",
            "",
            "",
            "def validate_ipv46_address(value):",
            "    try:",
            "        validate_ipv4_address(value)",
            "    except ValidationError:",
            "        try:",
            "            validate_ipv6_address(value)",
            "        except ValidationError:",
            "            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')",
            "",
            "ip_address_validator_map = {",
            "    'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),",
            "    'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),",
            "    'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),",
            "}",
            "",
            "",
            "def ip_address_validators(protocol, unpack_ipv4):",
            "    \"\"\"",
            "    Depending on the given parameters returns the appropriate validators for",
            "    the GenericIPAddressField.",
            "",
            "    This code is here, because it is exactly the same for the model and the form field.",
            "    \"\"\"",
            "    if protocol != 'both' and unpack_ipv4:",
            "        raise ValueError(",
            "            \"You can only use `unpack_ipv4` if `protocol` is set to 'both'\")",
            "    try:",
            "        return ip_address_validator_map[protocol.lower()]",
            "    except KeyError:",
            "        raise ValueError(\"The protocol '%s' is unknown. Supported: %s\"",
            "                         % (protocol, list(ip_address_validator_map)))",
            "",
            "comma_separated_int_list_re = re.compile('^[\\d,]+\\Z')",
            "validate_comma_separated_integer_list = RegexValidator(comma_separated_int_list_re, _('Enter only digits separated by commas.'), 'invalid')",
            "",
            "",
            "@deconstructible",
            "class BaseValidator(object):",
            "    compare = lambda self, a, b: a is not b",
            "    clean = lambda self, x: x",
            "    message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')",
            "    code = 'limit_value'",
            "",
            "    def __init__(self, limit_value):",
            "        self.limit_value = limit_value",
            "",
            "    def __call__(self, value):",
            "        cleaned = self.clean(value)",
            "        params = {'limit_value': self.limit_value, 'show_value': cleaned}",
            "        if self.compare(cleaned, self.limit_value):",
            "            raise ValidationError(self.message, code=self.code, params=params)",
            "",
            "    def __eq__(self, other):",
            "        return isinstance(other, self.__class__) and (self.limit_value == other.limit_value) and (self.message == other.message) and (self.code == other.code)",
            "",
            "",
            "@deconstructible",
            "class MaxValueValidator(BaseValidator):",
            "    compare = lambda self, a, b: a > b",
            "    message = _('Ensure this value is less than or equal to %(limit_value)s.')",
            "    code = 'max_value'",
            "",
            "",
            "@deconstructible",
            "class MinValueValidator(BaseValidator):",
            "    compare = lambda self, a, b: a < b",
            "    message = _('Ensure this value is greater than or equal to %(limit_value)s.')",
            "    code = 'min_value'",
            "",
            "",
            "@deconstructible",
            "class MinLengthValidator(BaseValidator):",
            "    compare = lambda self, a, b: a < b",
            "    clean = lambda self, x: len(x)",
            "    message = ungettext_lazy(",
            "        'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',",
            "        'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',",
            "        'limit_value')",
            "    code = 'min_length'",
            "",
            "",
            "@deconstructible",
            "class MaxLengthValidator(BaseValidator):",
            "    compare = lambda self, a, b: a > b",
            "    clean = lambda self, x: len(x)",
            "    message = ungettext_lazy(",
            "        'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',",
            "        'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',",
            "        'limit_value')",
            "    code = 'max_length'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "76": [
                "URLValidator"
            ],
            "112": [
                "validate_integer"
            ],
            "113": [
                "validate_integer"
            ],
            "114": [
                "validate_integer"
            ],
            "115": [
                "validate_integer"
            ],
            "123": [
                "EmailValidator"
            ],
            "124": [
                "EmailValidator"
            ],
            "127": [
                "EmailValidator"
            ],
            "131": [
                "EmailValidator"
            ],
            "184": [
                "slug_re"
            ],
            "187": [
                "ipv4_re"
            ],
            "228": [
                "comma_separated_int_list_re"
            ]
        },
        "addLocation": []
    }
}